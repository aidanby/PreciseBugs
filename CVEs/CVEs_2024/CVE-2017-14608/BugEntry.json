{"buggy_code": ["2017-09-12  Alex Tutubalin <lexa@lexa.ru>\n * Fix for possible heap overrun in Canon makernotes parser\n * LibRaw 0.18.4\n\n2017-09-09  Alex Tutubalin <lexa@lexa.ru>\n * Fix for CVE-2017-13735\n * CVE-2017-14265: Additional check for X-Trans CFA pattern data\n * LibRaw 0.18.3\n\n2017-03-08  Alex Tutubalin <lexa@lexa.ru>\n * Fixed several errors (Secunia advisory SA75000)\n * ACES colorspace output option included in dcraw_emu help page\n * Avoided possible 32-bit overflows in Sony metadata parser\n * Phase One flat field code called even for half-s\n * LibRaw 0.18.2\n\n2017-02-12  Alex Tutubalin <lexa@lexa.ru>\n * Camera Support: Sigma Quatto H\n * Fixed bug in FujiExpoMidPointShift parser\n * Fixed wrong black level in Sony A350\n * Added standard integer types for VisualStudio 2008 and earlier\n * LibRaw 0.18.1\n \n2016-12-27  Alex Tutubalin <lexa@lexa.ru>\n * Licensing changes:\n    - there is no 'LibRaw Software License 27032010' licensing anymore (and all signed\n      agreements have expired)\n    - LibRaw is now dual-licensed: LGPL 2.1 or CDDL 1.0\n\n * Camera support (+87):\n     Apple: iPad Pro, iPhone SE, iPhone 6s, iPhone 6 plus, iPhone 7, iPhone 7 plus\n     BlackMagic Micro Cinema Camera, URSA, URSA Mini\n     Canon PowerShot G5 X, PowerShot G7 X Mark II, PowerShot G9 X,\n       IXUS 160 (CHDK hack), EOS 5D Mark IV, EOS 80D, EOS 1300D, EOS M10, EOS M5,\n       EOS-1D X Mark II\n     Casio EX-ZR4000/5000\n     DXO One,\n     FujiFilm X-Pro2, X70, X-E2S, X-T2\n     Gione E7\n     GITUP GIT2\n     Google Pixel,Pixel XL\n     Hasselblad X1D, True Zoom\n     HTC MyTouch 4G, One (A9), One (M9), 10\n     Huawei P9\n     Leica M (Typ 262), M-D (Typ 262), S (Typ 007), SL (Typ 601), X-U (Typ 113), TL\n     LG G3, G4\n     Meizy MX4\n     Nikon D5, D500, D3400\n     Olympus E-PL8, E-M10 Mark II, Pen F, SH-3, E-M1-II\n     Panasonic DMC-G8/80/81/85, DMC-GX80/85, DMC-TZ80/81/85/ZS60, DMC-TZ100/101/ZS100,DMC-LX9/10/15, FZ2000/FZ2500\n     Pentax K-1, K-3 II, K-70\n     PhaseOne IQ3 100MP\n     RaspberryPi Camera, Camera V2\n     Ricoh GR II\n     Samsung Galaxy S7, S7 Edge\n     Sigma sd Quattro\n     Sony A7S II, ILCA-68 (A68),ILCE-6300,DSC-RX1R II,DSC-RX10III, DSC-RX100V,ILCA-99M2 (A99-II), a6500\n          IMX214, IMX219, IMX230, IMX298-mipi 16mp, IMX219-mipi 8mp, Xperia L\n     PtGrey GRAS-50S5C\n     YUNEEC CGO4\n     Xiaomi MI3, RedMi Note3 Pro\n\n * Floating point DNG support:\n    - new data fields:\n      imgdata.rawdata.float_image - bayer float data\n      imgdata.rawdata.float3_image - 3-component float data\n      imgdata.rawdata.float4_image - 4-component float data\n      imgdata.color.fmaximum - float data maximum (calculated from real data,\n          rounded to 1.0 if below 1.0)\n   - new raw processing flag\n      LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT - converts float data to 16-bit\n        integer immediately after decoding with default parameters\n   - new API Calls:\n      int LibRaw::is_floating_point() returns non-zero if RAW file contains\n          floating point data\n      int LibRaw::have_fpdata() returns non-zero if rawdata.float*_image is not\n        null (so FP data has been unpacked but not converted to integrer, see below).\n      LibRaw::convertFloatToInt(float dmin=4096.f, float dmax=32767.f, float dtarget = 16383.f)\n        converts float/float3/float4_image to raw_image/color3/color4_image with or without scaling:\n       - if both real data maximum and metadata maximum are within the range ( >= dmin && <=dmax), float\n         data is just converted to integer\n       - if data is out of the range given above, values are scaled so real data maximum becomes dtarget\n       - if data was rescaled (normalized), scale multiplier is stored in imgdata.color.fnorm\n\n * LibRaw can be built with Adobe DNG SDK support to decode exotic DNG formats (e.g. 8 bit).\n   See README.DNGSDK.txt for details\n\n * New API calls\n    unsigned LibRaw::capabilities and C-API libraw_capabilities()\n    allows developers to determine LibRaw compile flags at runtime.\n    Returns ORed bit fields:\n    LIBRAW_CAPS_RAWSPEED - LibRaw was compiled with RawSpeed Support\n    LIBRAW_CAPS_DNGSDK - LibRaw was compiled with Adobe DNG SDK\n    LIBRAW_CAPS_DEMOSAICSGPL2, LIBRAW_CAPS_DEMOSAICSGPL3 - LibRaw was compiled with demosaic packs (GPL2/GPL3)\n\n * More metadata parsed:\n    - White balance coefficients stored in the raw file are extracted into:\n     int imgdata.color.WBCoeffs[256][4] - array indexed by EXIF lightsource type\n        for example, WBCoeffs[21][..] contains coefficients for D65 lightsource\n     float imgdata.color.WBCT_Coeffs[64][5] contains white balance data specified\n       for given color temperature: WBCT_Coeffs[i][0] contains temperature value,\n       and [1]..[4] are WB coefficients.\n    - DNG analog balance, per-channel black/white level, and forward matrix\n    - vendor specific metadata stored in vendor-specific data structures\n\n * new C-API calls:\n    void libraw_set_user_mul(libraw_data_t *lr,int index, float val);\n    void libraw_set_ca_correction(libraw_data_t *lr,int ca_correc, float ca_red, float ca_blue);\n    void libraw_set_cfalinenoise(libraw_data_t *lr,int cfaline, float linenoise);\n    void libraw_set_wf_debanding(libraw_data_t *lr, int wf_debanding, float wfd0, float wfd1, float wfd2, float wfd3);\n    void libraw_set_interpolation_passes(libraw_data_t *lr,int passes);\n\n * Existing API changes:\n    imgdata.params fields (all very specific purpose): sony_arw2_options, sraw_ycc, and params.x3f_flags\n    replaced with single bit-field raw_processing_options\n    See  LIBRAW_PROCESSING_* bits in documentation.\n\n * zlib library is optional\n   Use -DUSE_ZLIB to compile with zlib (to provide deflate DNG support)\n * libjpeg version: jpeg_mem_src() is mandatory, so use libjpeg-turbo\n   or libjpeg 8+\n * Fixes in vng_intepolate to make modern compilers happy\n * Fixed bug in Sony SR2 files black level\n * DNG files with BlackLevel both in vendor makernotes and BlackLevel:\n    BlackLevel tag always takes precedence\n * strlen replaced with strnlen in most cases, added local version of strnlen\n * ChannelBlackLevel added to canon makernotes\n * unpack_thumb() data size/offset check against file size\n\n2015-08-15  Alex Tutubalin <lexa@lexa.ru>\n\n * LibRaw 0.17\n\n * Fixed dcraw.c ljpeg_start possibly buffer overrun\n\n * fixed several bugs detected by using American Fuzzy Lop\n\n * C-API extension to support 3DLut Creator\n\n * More metadata parsing/extraction:\n    - XMP packet extracted (if exists)\n    - DNG Color information parsed\n    - GPS data (partially) parsed\n    - EXIF/Makernotes parsed for used optics (for both RAW files and DNG converted by Adobe convertor).\n\n * Exif/Makernotes parser callback (called for each processed tag)\n\n * Sony ARW2.3 decoder:\n   - params.sony_arw2_hack removed, decoded data are always in 0...17k range (note the difference with dcraw!)\n   - Additional processing options for Sony lossy compression techincal analysis.\n\n * Dcraw 9.26 imported (but some changes not approved because Libraw do it better) with some exceptions:\n    - no Pentax K3-II frame selection code\n    - no built-in JPEG decompressor\n\n * Many improvements in data decoding/processing:\n    - Correct decoding of black level values from metadata for many formats, LibRaw do not rely on hardcoded black levels.\n\n * 224 camera models added to supported camera list.\n   Some of them are new (released since LibRaw 0.16 come out), some was supported before, but missed from the list.\n   Added cameras are:\n\n  Alcatel 5035D\n  BlackMagic Pocket Cinema Camera, Production Camera 4k\n  Canon PowerShot A550, A3300 IS, G1 X Mark II, G7 X, SD950, SX60 HS, EOS 7D Mark II, EOS 20Da, EOS 60Da, EOS 1200D, EOS-1D C, 5DS, 5DS R, 750D, 760D, M2, M3, G3 X\n  Casio EX-FC300S, EX-FC400S, EX-Z1080, EX-ZR700, EX-ZR710, EX-ZR750, EX-ZR800, EX-ZR850, EX-ZR1000, EX-ZR1100, ZR1200, ZR1300, EX-ZR1500, EX-100, EX-10\n  Digital Bolex D16,D16M\n  DJI 4384x3288,\n  Epson R-D1s, R-D1x\n  FujiFilm E505,S1,S205EXR,HS10,HS11,HS22EXR,HS33EXR,HS35EXR,F505EXR,F605EXR,F775EXR,F900EXR,X100T,X30,X-T1,X-T1 Graphite Silver, XQ2, X-A2, X-T10\n  Hasselblad H5D-60, H5D-50,H5D-50c,H5D-40,H4D-60,H4D-50,H4D-40,H4D-31,H3DII-22,H3DII-31,H3DII-39,H3DII-50,H3D-22,H3D-31,H3D-39,H2D-22,H2D-39,CF-22,CF-31,CF-39,Stellar II,HV\n  HTC UltraPixel\n  Imacon Ixpress 96, 96C, 384, 384C (single shot only),132C,  528C (single shot only)\n  ISG 2020x1520\n  Ikonoskop A-Cam dII Panchromatic, A-Cam dII\n  Kinefinity KineMINI, KineRAW Mini, KineRAW S35\n  Kodak DCS460D, S-1\n  Leaf Credo 50\n  Lenovo a820\n  Leica Digital-Modul-R, D-Lux (Typ 109), M (Typ 240), Monochrom (Typ 240), M-E, M-P, R8, S, T (Typ 701), X (Typ 113), X2, X-E (Typ 102), V-Lux (Typ 114), Monochrom (Typ 246), Q\n  Matrix 4608x3288\n  Nikon D4s, D600, D610, D750, D800, D800E, D810, D3300, D5500, Df, 1 J4, 1 S2, 1 V3, Coolpix P340, Coolscan NEF, D7200, 1 J5,D810A\n  Nokia 1200x1600\n  Olympus E-450, E-600, E-PL6, E-PL7, E-M1, E-M10, E-M5 Mark II, SP565UZ, STYLUS1s, SH-2, TG-4, AIR-A01\n  Panasonic DMC-CM1, DMC-FZ7, DMC-FZ70, DMC-FZ1000, DMC-GF7, DMC-GH4, AG-GH4, DMC-GM1s, DMC-GM5, DMC-LX100, DMC-TZ60/61/SZ40, DMC-TZ70, FZ300/330, GX8\n  Pentax GR, K110D, K-01,  K-S1, Q, QS-1, 645Z, K-S2, K3 II\n  PhaseOne IQ250, IQ260, IQ260 Achromatic, IQ280, Achromatic+, P 20+, P 21, P 25+, P 30+, P 40+\n  Ricoh GXR MOUNT A12, GXR MOUNT A16 24-85mm F3.5-5.5, GXR, S10 24-72mm F2.5-4.4 VC, GXR, GR A12 50mm F2.5 MACRO, GXR, GR LENS A12 28mm F2.5, GXR, GXR P10\n  Samsung GX-1L, NX1, NX5, NX1000, NX1100, NX30, NX300, NX300M, NX3000, NX mini, Galaxy S3, Galaxy Nexus, NX500\n  Sigma dp1 Quattro, dp2 Quattro, dp3 Quattro, dp0 Quattro\n  Sinar eMotion 22, eMotion 54, eSpirit 65, eMotion 75, eVolution 75, Sinarback 54\n  Sony A7 II, A7S, ILCA-77M2 (A77-II), ILCE-3000, ILCE-5000, ILCE-5100, ILCE-6000, ILCE-QX1, DSC-RX100III, DSLR-A560, NEX-VG20, NEX-VG30, NEX-VG900, IMX135-mipi 13mp, IMX135-QCOM, IMX072-mipi, RX100-IV, A7R-II, RX10-II\n\n * Fujifilm F700/S20Pro second frame support\n\n2014-02-01  Alex Tutubalin <lexa@lexa.ru>\n   * Updated Oly E-M10 & Panasonic TZ60/61 color data\n   * Updated foveon SD9-14 white level\n   * Support for 1x1 BlackLevelRepeatDim\n\n2014-01-31  Alex Tutubalin <lexa@lexa.ru>\n   * imported dcraw 1.461: fixed error in BlackLevelDim handling\n   * Accurate work with pattern black-level (cblack[6+])\n   * Support for Olympus E-M10 and Fujifilm X-T1\n   * Adjusted possbile maximum value for Sigma SD9 small raws\n\n2014-01-27 Alex Tutubalin <lexa@lexa.ru>\n   * dcraw 1.460:  Nikon D3300, Panasonic DMC-TZ61, Sony  ILCE-5000\n2014-01-25 Alex Tutubalin <lexa@lexa.ru>\n   * PhaseOne IQ250 support (both compressed and uncompressed)\n2014-01-21 Alex Tutubalin <lexa@lexa.ru>\n   * imgdata.params.sony_arw2_hack removed.\n     It always on for ARW2-files.\n   * New imgdata.params.sony_arw2_options processing flags\n     Values:\n       LIBRAW_SONYARW2_NONE - normal processing\n       LIBRAW_SONYARW2_BASEONLY - BASE pixels outputeed, delta pixels set to 0\n       LIBRAW_SONYARW2_DELTAONLY - Delta pixels written to raw data, base pixels zeroed\n       LIBRAW_SONYARW2_DELTAZEROBASE - Only deltas written without base offset\n\n2014-01-20 Alex Tutubalin <lexa@lexa.ru>\n  * Imported dcraw 9.20:\n    - Support for DNG BlackLevelRepeatDim tags\n    - imgdata.color.cblack[] holds variable BlackLevel for DNG files (up to ~4k values)\n    - imgdata.params.use_camera_matrix is now ON by default. Set it to 3 if you want\n      to force use of DNG embedded matrix.\n    - Tone curve for Canon RMF format supported\n    - Color data for Canon C500\n  * Additional camera support:\n     Alcatel 5035D\n     DJI 4384x3288\n     Fujifilm F900EXR\n     Kodak 12MP\n     Matrix 4608x3288\n     Nokia 1200x1600\n     Olympus E-PL6\n     Panasonic DMC-FZ7\n\n2014-01-17 Alex Tutubalin <lexa@lexa.ru>\n  * Camera support:\n     Added: Fujifilm XE2, XQ1\n     Color data updated: Nikon D4 1 AW1/J3, Fuji X-M2\n     Fixes: Nikon D610 visible image area, Canon A3300 bayer\n     pattern\n  * RawSpeed support: enabled processing for cameras,\n    unknown to RawSpeed\n  * Fixed error in LibRaw::unpack_thumb()\n  * little improve performance in my_strcasestr\n  * Fix compiler errors for VS2012/OpenMP\n  * Fixed typo which prevents to use Demosaic Pack GPL2\n  * LibRaw 0.16.0-Release\n\n2013-11-15 Alex Tutubalin <lexa@lexa.ru>\n  * New cameras supported\n     Leica C, X VARIO\n     Nikon D5300, D610, Df, 1 AW1\n     Nokia Lumia 1020, 1520\n     Olympus STYLUS1\n     Pentax K-3\n     Sony RX10, A3000 (ILCE-3000),\n  * Color data updated:\n     Canon S120\n     Nikon P7800, 1 J3\n     Olympus E-M1\n  * Corrected image visible area sizes\n    Canon G16\n    Sigma pre-Merrill cameras: small and medium-sized RAWs\n\n  * Better EXIF parsing:\n     - ISO values for new Nikon cameras (D4, D800)\n     - black level extraction for Nikon D5300\n     - correct Olympus color data conversion\n\n  * Better Visual Studio compatibility (esp. old versions)\n  * Cmake build: added ws2_32 library for MinGW builds\n  * LibRaw 0.16.0-Beta1\n\n2013-10-22 Alex Tutubalin <lexa@lexa.ru>\n  * Support for new cameras:\n    Sony A7, A7R\n    Panasonic GM1\n\n  * Sony RX1R and RX100M2 color data updated.\n\n  * Sony cameras model name is set by SonyModelID EXIF tag\n\n  * Sony ARW2: black level and color matrix extracted from EXIF data\n\n  * Samsung: black level and color matrix extracted from EXIF;\n    Camera multipliers are now extracted correctly even if black is not 0\n\n  * Better source compatibility with Mac OS X compilation\n\n  * Better source compatibility with Win32 compilation\n\n  * DNG without Compression tag assumed uncompressed\n\n  * Better X3F-tools based Foveon support:\n    - new Foveon metadata parser based on X3F-tools. So, if LibRaw compiled\n      without demosaic-pack-GPL2, then no dcraw Foveon code used.\n    - Support for Medium resolution RAWs from DPx Merrill and SD1 cameras.\n      RAW data extracted as is (4800x1600 pixels), aspect ratio is set to\n      0.5, so these RAWs are processed to full-size 4800x3200 RGB.\n    - Support for Foveon thumbnail extraction. Only JPEG and bitmap\n      thumbnails extracted, but 'foveon' (RAW) thumbnails are really not used\n      in production cameras.\n    - New imgdata.params.force_foveon_x3f flag\n      Forces use of x3f-tools based code for Foveon processing if LibRaw\n      compiled with demosaic-pack-GPL2 (and does nothing if LibRaw compiled\n      without this pack).\n      New flag -disadcf added to dcraw_emu sample to use this flag.\n    - LibRaw do not calls exit() on broken Foveon files.\n\n  * API/ABI changed, so all code using LibRaw should be recompiled.\n\n  * LibRaw 0.16.0-Alpha3\n\n\n2013-10-16 Alex Tutubalin <lexa@lexa.ru>\n  * Support for new cameras:\n    Canon S120 (preliminary color data), G16\n    Fujifilm X-A1 (preliminary color data)\n    Hasselblad Lunar, Stellar\n    Nikon P7800 (preliminary color data)\n    Pentax K50, K500, Q7\n    Samsung Galaxy NX (EK-GN120)\n    Sony NEX-5T\n\n  * Updated color data for:\n    Samsung NX300\n    Sony RX1R\n    Sigma SD1, SD1 Merrill, DPxx (only if non-GPL2 foveon decoder used)\n\n  * Image dimensions table for Foveon cameras (only if\n    non-GPL2 foveon decoder used)\n\n  * Fixed memory leak in x3f-tools code (new Foveon decoder)\n  * Fixed DHT-demosaic incompatibility with MS VisualStudio in OpenMP directives\n  * Additional image size checks.\n  * LibRaw 0.16-Alpha2\n\n2013-09-22 Alex Tutubalin <lexa@lexa.ru>\n  * Support for new cameras:\n     Baumer TXG14\n     Blackmagic Cinema\n     Canon EOS 70D, C500\n     Fujifilm X-M1\n     Nikon D5200\n     Olympus E-P5,E-M1\n     OmniVision OV5647 (Raspberry Pi)\n     Panasonic LF1, GX7, GF6\n     Richon GR\n     Samsung NX300, NX1100, NX2000\n     Sony RX100II, RX1R, NEX-3N\n\n  * Support for Foveon sensor based on X3F code by Roland Karlsson\n    BSD-like license, so included in main LibRaw code.\n    No 'foveon intepolation', so no way to get good colors from\n    old Sigma cameras (SD9, SD14, Polaroid x530). For modern Foveon cameras\n    one may try to create ICC profile (not supplied).\n\n    TODO: thumbnail extraction, fast cancelation\n\n    Old foveon_*_load_raw (from dcraw) code is used if compiled with\n    LIBRAW_DEMOSAIC_PACK_GPL2\n\n  * API Changes:\n\n    + New parameters in imgdata.params:\n      - imgdata.params.no_interpolation - disables interpolation step in\n        LibRaw::dcraw_process() call.\n      - imgdata.params.no_auto_scale - disables call to scale_colors() in\n        LibRaw::dcraw_process() call.\n      - imgdata.params.sraw_ycc - disables Canon sRAW YCbCr to RGB conversion\n        in LibRaw::unpack() call (use for RAW analyzers\n\n    + New Fuji X-Trans handling:\n      - imgdata.iparams.filters value is now 9 for Fuji X-Trans (instead of 2)\n      - imgdata.iparams.xtrans[6][6] matrix contains row/col to color mapping\n        for Fuji X-Trans sensor.\n\n    + LibRaw::setCancelFlag() - use for fast decoder termination\n\n    + LibRaw_abstract_datastream::make_byte_buffer() call is not needed more.\n\n    + New demosaic code: DHT Demosaic by Anton Petrusevich\n      Set params.user_qual=11 to use.\n\n    + New demosaic code: Modified AHD Demosaic by Anton Petrusevich\n      Set params.user_qual=12 to use.\n\n    + New C-API call libraw_COLOR(libraw_data_t *t, int row,int col)\n      (so LibRaw::COLOR(row,col) exposed to C-API users)\n\n  * Removed faster lossless jpeg decoder ported from RawSpeed library\n    some years ago. Build LibRaw with RawSpeed to get fast decoding.\n\n  * Fixed decoding error for some Canon sRAW files.\n\n  * Disabled RawSpeed's bad pixel processing if RawSpeed used.\n\n  * EOS M and EOS 70D added to unique Canon ID table\n\n  * Canon EOS model name normalized by unique ID table\n\n  * Backported 0.15.4 input data checks\n\n  * Support for CMake builds\n\n  * Updated RawSpeed supported camera list\n\n  * Internals changed, so all code using LibRaw should be recompiled.\n\n  * LibRaw 0.16.0-Alpha1\n\n2013-05-23 Alex Tutubalin <lexa@lexa.ru>\n\n LibRaw 0.15-Release\n\n New camera/format support:\n  * Adobe DNG:\tfast Load DNG (LightRoom 4.x), support for\n\t\tlossy-compressed DNG (LR 4.x, requires libjpeg 6+)\n  * Canon:\tG1 X, SX220 HS, EOS 5D Mark III, EOS 650D, EOS 1D-X,\n\t\t100D (Rebel SL1), 700D (Rebel T5i), 6D, EOS M, G15, S110, SX50\n  * Casio:\tEX-ZR100,EX-Z8\n  * Fujifilm:\tX-S1, HS30EXR, X1-Pro,X-E1, X20, X100S, SL1000, HS50EXR,\n  \t\tF800EXR, XF1\n  * Leica:\tD-LUX6 and V-LUX4\n  * Nikon:\tD4, D3200, D800, D800E, 1 J2, 1 V2, D600, 1 J3, 1 S1, Coolpix A,\n\t\tCoolpix P330, Coolpix P7700, D7100\n  * Olympus:\tE-M5, XZ-2, XZ-10, E-PL5, E-PM2\n  * Panasonic:\tG5, G6, DMC-GF5, FZ200, GH3, LX7\n  * Pentax:\tMX-1, K-5 II, K-5 IIs, K-30, Q10\n  * Samsung:\tEX2F, NX20, NX210, support for the new firmware for NX100\n  * Sigma:\tSD15, SD1, SD1 Merill, DP1, DP1S, DP1X, DP2, DP2S, DP2X\n\t\t(only with Demosaic-pack-GPL2)\n  * Sony:\tSLT-A58, RX-1, SLT-A99, NEX-5R, NEX-6, NEX-F3, SLT-A37, SLT-A57\n  * Multishot files:\tImacon Ixpress 39Mpix\n\nAPI changes:\n  1. dcraw_process() can now be called several times with different parameters\n     without re-opening and unpacking the file for second and consecutive\n     calls to dcraw_process\n\n  2. deleted (nobody uses those)\n   - LibRaw::dcraw_document_mode_processing  (and respective C-API)\n   - imgdata.color.color_flags data field\n\n  3. LibRaw::unpack() now decodes data into different buffers, the buffer\n     depends on the raw data type\n     - imgdata.rawdata.raw_image - 1 color component per pixel,\n       for b/w and Bayer type sensors\n     - imgdata.rawdata.color3_image - 3 color components per pixel,\n       sRAW/mRAW files, RawSpeed decoding\n     - imgdata.rawdata.color4_image - 4 components per pixel, the 4th\n       component can be void\n\n   4. Support for compiling with RawSpeed library, http://rawstudio.org/blog/?p=800\n      details are in README.RawSpeed\n\n   5. Suppression of banding\n\n   6. New API calls\n     - recycle_datastream(),\n     - open_file(wchar_t*) (Win32)\n\n\n2012-04-05 Alex Tutubalin <lexa@lexa.ru>\n        * Casio EX-Z500 support\n        * (possible) I/O exceptions on file open catched in open_datastream\n        * Fixed possible read-after-buffer in Sony ARW2 decoder\n        * Fixed mingw32 errors when compiling LibRaw_windows_datastream\n        * Makefile.msvc: support of OpenMP and LCMS (uncomment to use)\n        * Fixed decoding of some Leaf Aptus II files\n        * LibRaw 0.14.6-Release\n\n2011-12-24 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug (uninitialized variable) in SMAL format decoding.\n\n        * Imported new dcraw 9.12 (1.446): support for Leica V-LUX 3,\n          updated color data for Canon S100, Fujifilm X10, Nikon 1 J1/V1,\n          Panasonic GX1, Samsung NX200, Sony NEX-7\n\n        * LibRaw 0.14.5-Release\n\n2011-12-12 Alex Tutubalin <lexa@lexa.ru>\n\n        * Fixes to Panasonic/Leica file parser to prevent crash\n          on broken jpegs.\n\n        * Fixes to include order in src/libraw_datastream.cpp to\n          better compile with KDEWIN\n\n        * Floating-point DNGs are rejected on early processing stage.\n\n        * Support for new cameras: Canon S100, Fuji X10, Panasonic GX1,\n          Samsung NX200, Sony NEX-7.\n\n        * LibRaw 0.14.4-Release\n\n\n2011-10-26 Alex Tutubalin <lexa@lexa.ru>\n        * Bug fixes in black level subtraction code for PhaseOne files\n\n        * New API call LibRaw::get_internal_data_pointer() for developers\n           who need access to libraw_internal_data fields (i.e.\n           Fuji SuperCCD layout).\n\n        *  doc/API-overview fixes to reflect 0.14 changes\n\n        * LibRaw 0.14.3-Release\n\n2011-10-19 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in Canon 1D and 1Ds files decoding.\n        * New decoder information bit DECODER_HASRAWCURVE\n        * LibRaw 0.14.2-Release\n\n2011-10-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.11/1.445:\n          + Support for new cameras added: Fujifilm F600EXR, Nikon P7100,\n            Olympus E-PL3 and E-PM1, Panasonic DMC-FZ150, Sony NEX-5N,\n            A65 and A77.\n          + Changed color data for: Olympus E-P3, Panasonic G3 and GF3,\n            PhaseOne H25, P40 and P65, Sony NEX-C3, NEX-5, NEX-3, A35 and A55.\n          + Support for dark frame extraction on Sony cameras.\n\n        * DCB demosaicing: reserving 6 pixels instead of 3 to suppress\n          colored image frame.\n        * LibRaw 0.14.1-Release\n\n2011-09-21 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to make Visual C++/OpenMP more happy\n        * Fix megapixel calculation for postprocessing_benchmark in half mode\n        * Shlib version number increment\n        * LibRaw 0.14.0-Release\n\n2011-09-04 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug with Kodak thumbnail extraction\n        * raw2image_ex() always return value\n        * LibRaw 0.14.0-Beta2\n\n2011-09-02 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to LibRaw_file_datastream interface\n\n        * OpenMP speedup of postprocessing steps (up to 50% for\n          half mode and 4-core machine)\n\n        * LibRaw 0.14.0-Beta1\n\n2011-08-20 Alex Tutubalin <lexa@lexa.ru>\n\n        * Patch to dcraw_emu for SunStudio compiler compatibility\n\n        * Fixed crash in unprocessed_raw sample due to uninitialized\n          timestamp variable.\n\n        * Fixed crash in raw decoding if raw_width/raw_height is\n          less than resulting image width/height.\n\n        * imgdata.sizes.flip is set from user_flip only on\n          postprocessing and/or adjust_sizes_info_only()\n\n        * Fixed buffer overrun for some LJPEG-compressed files\n\n        * Most of LibRaw_datastream function bodies are moved to\n          separate source file\n\n        * LibRaw_windows_datastream is merged to main sourcetree\n\n        * LibRaw 0.14.0-Alpha5\n\n2011-08-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.10 (1.444), support for new cameras added:\n          ARRIRAW format, Canon SX30 IS, Leica D-LUX 5 and V-LUX2,\n          Olympus E-P3, Panasonic G3 and GF3, Sony NEX-C3 and SLT-A35\n\n        * Support for RedOne digital movie cameras (R3D format).\n          To enable this support you should:\n           + install libjasper JPEG2000 support library\n\n           + compile LibRaw with -DUSE_JASPER compiler switch (./configure\n             will do it for you)\n\n           + If you use own LibRaw_datastream implementation, you should\n             implement make_jas_stream() call for your datastream. See\n             bottom of src/libraw_cxx.cpp for  implementations in datafile\n             and mem-buffer LibRaw streams.\n\n        * Bugfix: green matching is turned off if output image is shrinked\n          due to wavelet filtering or aberration correction.\n\n        * fixed open_file()/adjust_sizes_info_only() code path\n\n        * Removed imgdata.sizes.bottom_margin and right_margin data fields\n          use imgdata.sizes.raw_width - width - left_margin to get right one,\n          the same with bottom_margin.\n\n        * minor ./configure cleanup\n\n        * Qmake files and Visual Studio Project files are updated.\n\n        * New version check macros:\n          For use at runtime checks:\n           LIBRAW_RUNTIME_CHECK_VERSION_EXACT() - checks  that runtime\n            major/minor version numbers are same with compile-time values.\n\n           LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() - checks that runtime\n            version is not less that compile-time one.\n\n          For use at compile-time in preprocessor directives:\n           LIBRAW_COMPILE_CHECK_VERSION_EXACT(major,minor) - Compile-time\n            check that LibRaw version is exact major.minor.\n\n           LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) - Compile-time\n            check that version is not less than major.minor.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha4\n\n2011-07-19 Alex Tutubalin <lexa@lexa.ru>\n        * New sample samples/postprocessing_benchmark.cpp\n          This sample measures postprocessing speed.\n          All demosaic methods, averaged white balance, median\n          filtering, wavelet filtration, highlight recovery, and\n          cropping are supported.\n\n        * Removed LibRaw::rotate_fuji_raw() call and corresponding C-API call.\n\n        * The LibRaw::adjust_sizes_info_only() call may be called repeated\n          and mixed with dcraw_process() call.\n\n        * Postprocessing speedup and optimization, especially if cropping set.\n\n        * Cropping works for FujiCCD raws. For the technical reasons, the position\n          of top-left corner of crop area will be rounded to the nearest\n          multiple of 4 (the corner is shifted top-left).\n\n        * LibRaw 0.14.0-Alpha3\n\n2011-07-15 Alex Tutubalin <lexa@lexa.ru>\n        * imported cropping code from 0.13 branch\n\n2011-07-12 Alex Tutubalin <lexa@lexa.ru>\n        * samples/multirender_test - check for different clip settings\n\n2011-07-11 Alex Tutubalin <lexa@lexa.ru>\n        * New call LibRaw::free_image(), deallocates imgdata.image buffer.\n          Use this call if current postprocessing results are not\n          needed, but it is to early to call recycle() because\n          dcraw_process() may be called later.\n\n        * New C-API calls\n          libraw_raw2image() - C API for LibRaw::raw2image()\n          libraw_free_image() - C API for LibRaw::free_image()\n          libraw_get_decoder_info() - C API for LibRaw::get_decoder_info()\n\n        * Bugfix: change of params.user_flip aftee open()/unpack()\n          calls should work.\n\n        * LibRaw 0.14.0-Alpha2\n\n2011-07-10 Alex Tutubalin <lexa@lexa.ru>\n        * Multiple rendering (LibRaw::dcraw_process() calls) allowed\n          without re-opening RAW file thrfough the sequence of open()/unpack()\n          calls.\n          You should be able to change any processing parameters (except\n          shot_select parameter) between dcraw_process() calls.\n\n          + New sample in samples/multirender_test.cpp: renders data 4 times:\n            in half and full modes with different white balance settings.\n\n          + Unprocessed RAW data is stored in separate data buffer:\n            (2 bytes per pixel for all Bayer-pattern images,\n            8 bytes per pixel for Foveon, sRAW, and other full-color raw\n            formats), so now LibRaw uses 25% more memory for full processing of\n            most common Bayer images; while for just unpack memory is reduced\n            4 times.\n\n          + New call LibRaw::raw2image() fills imgdata.image array\n            with fresh copy of data.\n            There is no need to call raw2image() separately if you use\n            dcraw_process() or dcraw_document_mode_processing() calls.\n\n          + New call LibRaw::get_decoder_info() to determine raw data\n            storage layout. See samples/unprocessed_raw.cpp for an example\n            of how to use it.\n\n        If your code uses usual open()/unpack()/dcraw_process() call\n        sequence, then NOTHING CHANGED: your program should produce same\n        results. For interactive programs you may skip open()/unpack()\n        calls after adjusting processing parameters, so user should see\n        image refreshed much faster.\n\n        If your code uses raw data (open+unpack calls), you need to call\n        LibRaw::raw2image(), and imgdata.image will contain same bitmap\n        as in LibRaw 0.13.x\n\n        If you code uses access to masked borders data, you need to\n        rewrite it. See samples/unprocessed_raw.cpp as a sample.\n\n        Unfortunately, documentation is untouched yet. This problem will be\n        fixed in next Alpha release.\n\n        Other changes:\n\n        * No separate imgdata.masked_pixels buffers, Bayer raw formats are read\n          to buffer with borders. So, no ugly add_masked_border_to_bitmap()\n          call.\n\n        * No filtering_mode parameter. Raw tone curve is applied\n          at unpack() stage; zero pixels removed on postprocesing stage.\n\n        * unprocessed_raw and 4colors samples are adjusted to use\n          new RAW data storage layout.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha1\n\n2011-07-03 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic cleanup in Libraw_memmgr code\n\n        * Permit OpenMP support on MS VS2008\n\n        * More general mem_image interface:\n          + New call get_mem_image_format returns bitmap size and bit depth\n          + New call copy_mem_image can copy bitmap into buffer with\n            different color order (RGB/BGR) and line stride\n          + dcraw_make_mem_image() uses calls mentioned above\n          + see documentation for info on these function parameters.\n\n        * libraw/librawwindows.h implements LibRaw_datastream class based\n          on Windows memory mapped files.Win32/64-only\n          Thanks to Linc Brookes.\n\n        * Fixed parallel make errors in configure/Makefile.am\n\n        * LibRaw 0.13.6-Release\n\n\n2011-05-18 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.08/1.443:\n           + New color data for Canon 600D and 1100D, Fuji S200EXR\n           + New camera supported: Fuji HS20EXR and F550EXR, Kodak Z990,\n                                   Nikon D5100, Olympus E-PL1s and XZ-1,\n                                   Samsung NX11, Sony A230 and 290.\n        * LibRaw 0.13.5-Release\n\n2011-04-02 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.07/1.442:\n          + Support for Canon 600D and 1100D, Hasselblad H4D-60,\n            Olympus E-PL2\n        * Color data for Leaf Aptus II and Canon Powershot S2 IS\n        * LibRaw 0.13.4-Release\n\n2011-03-30 Alex Tutubalin <lexa@lexa.ru>\n        * Preliminary support for Leaf Aptus II cameras (no color data yet):\n          Leaf Aptus II 6,7,8,10 and 12 are tested, Aptus II 5 should work.\n        * Preliminary support for Fujifilm X100 camera (again, no color data).\n        * Fixed possible after the end of buffer read when working with\n          in-memory data.\n        * Fixed possible loss of JPEG stream sync marks in LJPEG decoder\n          (this bug was found only for Leaf Aptus II RAWs).\n        * LibRaw 0.13.3-Release\n\n2011-03-08 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed broken camera white balance reading for some Sony cameras\n        * LibRaw 0.13.2-Release\n\n2011-02-25 Alex Tutubalin <lexa@lexa.ru>\n\t* Sony A390 support (colordata from A380)\n\t* Leica D-LUX 4: fixed typo in camera name in colordata\n\n2011-02-15 Alex Tutubalin <lexa@lexa.ru>\n\t* New -mem option for dcraw_emu: I/O via allocated buffer\n\t* Removed debug printf from LibRaw_memory_buffer code\n\t* Preliminary shared library support\n\n2011-02-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Added qmake .pro and Visual Studio 2008 sln/vcproj project files\n2011-02-07 Alex Tutubalin <lexa@lexa.ru>\n        * dcraw_emu documentation updated\n        * ./configure stuff changed for correct linking on some systems\n        * FBDD denoising is disabled for full-color images and 4-color bayer\n          data (including forced 4-color via four_color_rgb option)\n        * LibRaw 0.13.1-Release\n\n2011-02-05 Alex Tutubalin <lexa@lexa.ru>\n        * ./configure fixes for PACKAGE_REQUIRES\n        * Makefile.msvc: correct compiler flags for demosaic packs\n        * dcraw.c 9.06/1.440 imported:\n          + New camera support: Canon S95, Casio EX-Z1080, Panasonic GF2\n            and GH2, Samsung NX100, Sony A-580\n          + New color data for: Canon G12, Nikon D3100, D7000 and P7000,\n            Olympus E-5, Pentax K-r and K-5, Samsung NX10 and WB2000\n        * green_matching() code is disabled for half-size processing\n        * LibRaw 0.13.0-Release\n\n2011-01-15 Alex Tutubalin <lexa@lexa.ru>\n        * Fallback to old huffman decoder for Sony files with unspecified\n          data length (Sony A100)\n        * Fixed incomplete data fields reset in LibRaw::recycle()\n        * LibRaw 0.13.0-Beta3\n\n2011-01-13 Alex Tutubalin <lexa@lexa.ru>\n        * Better parsing of unknown command-line params in dcraw_emu sample\n        * Brigtness table in ahd_demosaic is calculated in reversed order\n          to prevent possible (very unlikely) multithreaded app problem.\n        * New exposure correction code based on linear-cubic root combination.\n          New working correction range is from 0.25 (-2 stops) to 8 (+3 stops)\n        * LibRaw 0.13.0-Beta2\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixed file extension in half_mt.c sample\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Three patches provided by Jacques Desmis:\n          - Exposure correction before demosaic (demosaic pack GPL3)\n\t  - OpenMP speed-up in median filters (demosaic pack GPL2)\n\t  - OpenMP speed-up in green equilibration (demosaic pack GPL3)\n\t* Merged 0.12.2-0.12.3 changes:\n          - Patches for ./configure system for better LCMS2 support\n\t  - Patches for ./configure system\n\t  - math.h included before any other includes to make KDE compile\n\t    with Visual C++ happy\n\t  - Fuji FinePix S5500 size adjusted to ignore (rare?) garbage\n\t    at top of frame.\n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.13.0-Beta1\n\n2010-12-22 Alex Tutubalin <lexa@lexa.ru>\n        * Zero copy huffman buffer for LibRaw_buffer_datastream\n        * Fixed memory leak in compressed NEFs handling\n        * LibRaw 0.13.0-Alpha2\n\n2010-12-20 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic-pack-GPL3 changes:\n          + New noise reduction methods before demosaic\n             - Banding suppression\n             - High-frequency noise suppression\n             - Green channel equalization\n          + New chromatic abberration correction.\n          All three methods are written by Emil Martinec for Raw Therapee.\n          Adapted to LibRaw by Jacques Desmis\n\n        * Merged Foveon code fix from LibRaw 0.12.1\n\n        * LJPEG decompressor speed-up (about 1.5 times for Canon cameras\n          and slightly less for others). Some ideas are from RawSpeed library.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.13.0-Alpha1\n\n2010-12-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Thread-safe and demosaic packs support for MinGW build\n\t* Demosaic packs support for MS VC build\n        * LibRaw 0.12.0-Release\n\n2010-12-09 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in add_masked_borders_to_bitmap() call for cameras\n          with odd pixels border.\n        * New command line options for unprocessed_raw sample:\n           -B - subtract black level, -M - add masked pixels to bitmap.\n        * Foveon-sensor cameras added to supported camera list if\n          compiled with demosaic pack GPL2\n        * LibRaw 0.12.0-Beta4\n\n2010-12-05 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic packs support in Makefile.dist\n        * Foveon support in LibRaw demosaic pack GPL2\n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.12.0-Beta3\n\n2010-11-27 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed allocation bug in lmmse_interpolation (demosaic-pack-GPL2)\n\t* In LMMSE and AMaZE interpolators allocation changed to calloc\n\t  to make valgrind happy with uninitialized values\n        * Changes in distribution-making scripts\n        * LibRaw 0.12.0-Beta2\n\n2010-11-21 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes to green_matching code by Sergey Pavlov\n\n2010-11-20 Alex Tutubalin <lexa@lexa.ru>\n        * Update for new demosaic-pack-GPL3\n\t* LibRaw 0.12.0-Beta1\n\n2010-11-19 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic pack(s) supported via ./configure\n\n2010-11-17 Alex Tutubalin <lexa@lexa.ru>\n\t* LCMS2 support\n\t* afd_interpolate(2,1) instead of (5,0)\n        * dcraw_emu sample command line keys added and reordered\n          to reflect changes in LibRaw 0.12.\n\t* Nikon P7000: color matrix data and black level patch for ISO >=400\n\t  Thanks to Gunnar Thorburn\n        * Support for several industrial cameras based on Sony ICX 625/655\n\t  sensor: JAI BB500CL/GE, SVS625CL, ptGrey GRAS-50S5C\n\t  Thanks to kaare\n\n2010-11-15 Alex Tutubalin <lexa@lexa.ru>\n\n        * Several demosaic algorithms, found in other open-source RAW processing\n          packages are implemented in LibRaw.\n\n          1) DCB demosaic and FBDD denoise by Jacek Gozdz are included in\n             main LibRaw source.\n          2) GPL2 demosaic pack with these demosaic methods:\n             * AFD and LMMSE implementations from PerfectRaw by Manuel Llorens\n             * VCD, Modified AHD, post-demosaic refinemend and median\n               filters by Paul Lee\n          3) GPL3 demosaic pack with AMaZe interpolation  by Emil Martinec\n\n          See more details in README.demosaic-packs\n\n        * Current implementation of dcraw_emu sample allows only selection\n          of demosaic method (via -q) options. All other parameters change\n          will be implemented later.\n\n\t* LibRaw 0.12-alpha1\n\n2010-11-11 Alex Tutubalin <lexa@lexa.ru>\n\t* Imported 0.11(2) version changes:\n\t  + Fixed dcraw_emu command line processing code\n          + OpenMP is completely disabled on MacOS X if compiled with -pthread\n            due to well-known MacOS problem.\n          + dcraw 9.05 (1.439) imported, many new cameras supported:\n              Canon: G12, SX120, 60D,\n              Hasselblad H4D, Nokia X2, Olympus E-5,\n              Nikon: D3100, D7000, P7000,\n              Panasonic: FZ40, FZ100, LX5,\n              Pentax: K-r, K-5, 645D,\n              Samsung GX20, WB2000\n\t* LibRaw 0.12-alpha0\n\n2010-11-08 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes for Sun Studio compiler compatibility\n\t* Fixes for Visual Studio 2010 compatibility\n\t* All russian-language files are converted to UTF-8\n\t* LibRaw 0.11.0-Release\n\n2010-10-18 Alex Tutubalin <lexa@lexa.ru>\n           * Disabled OpenMP for wavelet_denoise under Mac OS X\n           * More Visual C++ 2003 warnings cleaned in libraw/*h files\n           * LibRaw 0.11-Beta7\n\n2010-10-16 Alex Tutubalin <lexa@lexa.ru>\n           * internal/dcraw_fileio.c can be compiled with -DDCRAW_VERBOSE again\n           * fixed comment style in libraw_datastream.h\n           * LibRaw 0.11-Beta6\n\n2010-10-15 Alex Tutubalin <lexa@lexa.ru>\n\n           * New changes to I/O layer. Three LibRaw_*datastream clasees are\n             exists:\n               + LibRaw_buffer_datastream - buffer reaging\n               + LibRaw_file_datastream - file reading using iostreams\n                 (large files are no supported on some systems)\n               + LibRaw_bigfile_datastream - FILE*-based file I/O\n\n           *  file/bigfile_datastream is selected automatically by\n              LibRaw::open_file based on input file size.\n              By default, files larger than 250Mb are opened using\n              bigfile interface, you may change this behaviour\n              by using second optional parameter of open_file()\n\n           * There is no way to use default parameter values in C API,\n             so new call libraw_open_file_ex added with two parameters\n             (file name and minimal file size for bigfile_datastream use).\n\n           * all client code should be recompiled due to internals change.\n\n           * All LibRaw_abstract_datastream functions are virtual again. You may\n             (again) use your own I/O layer.\n\n           * new -d key for dcraw_emu sample: print timings of processing stages\n\n           * simple_dcraw sample simplified: no mmap code\n\n           * LibRaw 0.11-Beta5\n\n2010-10-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in exception handling in OpenMP sections in\n             AHD interpolation code.\n\n           * LibRaw_datastreams are now C++ iostreams based instead of old\n             plain FILE* calls.\n             LibRaw::open_file() in multithreaded programs are WAY faster\n             on many OSes (Linux, Windows, MacOSX) because of no extra locks.\n\n           * all client code should be recompiled due to internals change.\n\n           * LibRaw 0.11-Beta4\n\n\n2010-10-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in LibRaw::dcraw_process() code: for half_size\n             processing, params.four_color_rgb was set to 1 internally\n             and not returned back after postprocessing.\n\n           * Several Visual Studio 2003 compatibility fixes\n\n            * AHD interpolation refactored. Now it is about 10% faster than\n              dcraw in single-process mode and up to 1.5 times faster on\n              4-core and OpenMP (total execution time counted, not AHD itself)\n              Thanks to Adam Hooper\n           * AHD interpolation refactored. Now it is about 10% faster than\n             dcraw in single-process mode and up to 1.5 times faster on\n             4-core and OpenMP (total execution time counted, not AHD itself)\n             Thanks to Adam Hooper\n\n           * LibRaw 0.11-Beta3\n\n2010-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * Phase One files: LibRaw::unpack() sets colordata.black to\n             approximately correct value.\n\n           * Fixed minor error in setting colordata.maximum value\n             for Phase One files.\n\n           * LibRaw::subtract_black() sets colordata.black and\n             colordata.cblack[] to zero to preserve data integrity.\n\n           * LibRaw 0.11-Beta2\n\n\n2010-09-04 Alex Tutubalin <lexa@lexa.ru>\n\n           * It is now possible to crop output image on postprocessing\n            stage (dcraw_process). Coordinates and size of the output box\n            are set via imgdata.params.cropbox[4] parameter. Look into\n            LibRaw documentation for more details.\n\n              + New fatal error code LIBRAW_BAD_CROP\n\n              + New dcraw_emu sample command line switch: -B x y w h\n                (sets cropbox)\n\n             Thanks to Patrick and Jan.\n\n            * Processing pipeline has changed: the black level is subtracted\n              from data on postprocessing stage either automatically\n              (on dcraw_process() stage) or by special LibRaw API call:\n\n               + New API calls:  LibRaw::subtract_black() (C++ API) and\n                 libraw_subtract_black (C API).\n                 If you use dcraw_process() or dcraw_document_mode_processing()\n                 calls YOU DON'T NEED to call subtract_black() directly.\n\n               + The raw preprocessing mode LIBRAW_FILTERING_NOBLACKS\n                 is deprecated and removed from LibRaw.\n\n             * New ./configure script.\n               Use ./configure -h for usage details.\n               Thanks to Siddhesh Poyarekar\n\n             * New API cals static LibRaw::dcraw_clear_mem() (C++ API)\n               and libraw_dcraw_clear_mem(..) (C API).\n               This calls are used to free memory, allocated by\n               dcraw_make_mem_image() and dcraw_make_mem_thumb() instead\n               of free() call.\n\n               In some cases LibRaw and calling process have different\n               memory managers, so free() of make_mem_image() data\n               results to program crash (especially in Win32/VisualStudio\n               enviroment).\n\n             * LibRaw::free() is now private instead of public (again).\n\n             * Minor changes and bugfixes:\n\n               + Memory allocation exceptions (std::bad_alloc) are caught,\n                 so LibRaw API calls will return reasonable error codes\n                 instead of C++ exception (possibly unhandled).\n                 This problem is very unlikely to see in wild: if application\n                 cannot allocate small data for internal structure, it will\n                 always fail on allocation for RAW image data.\n\n               + WIN32/VisualStudio 2008/2010: fopen,fscanf and sscanf calls\n                 in Libraw_datastream code are changed to *_s (secure) ones.\n\n               + Debug print removed from fatal error handler.\n\n               + Mmaped I/O for dcraw_emu sample is turned on via -E switch\n                 now (because old -B switch is used for settng cropbox).\n\n           * all client code should be recompiled due to structures size change\n\n           * LibRaw 0.11-Beta1\n\n\n2010-07-31 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.04 (1.438) imported: changes in tiff metadata parser,\n            fixed a typo in Canon A720 model name\n           * small patch in Sony ARW2 unpacking code to make valgrind happy\n           * LibRaw 0.10.0-Beta3.\n\n2010-07-05 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.03 (1.437) imported:\n             + New cameras: Canon SX20, Nikon D3s, Olympus E-P2, Panasoni DMC-GF1,\n               Samsung EX1, Sony A450\n             + Color data changed for some cameras\n\n           * LibRaw 0.10.0-Beta2.\n\n2010-06-06 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.01 (1.434) imported:\n             + Separate black levels for each color channel.\n             + New cameras: Canon 550D, Casio EX-Z1050, Fuji HS10/HS11,\n               Kodak Z981, Panasonic G2 and G10, Phase One P65,\n               Samsung NX-10 and WB550, Sony NEX-3 and NEX-5.\n             + Fixed file descriptor leak in dark frame subtraction processing\n\n           * Fixed dcraw 9.01's bug in DNG black level processing\n\n           * Preliminary support for Sony A450 camera.\n\n           * New command-line switch -h in mem_image sample (half_size support)\n\n           * Some patches by Johannes Hanika (darktable author):\n              + OpenMP speedup  for PPG-interpolation\n              + green_matching  - suppress of 'color maze' on cameras with\n              different green channel sensitivity. This option is turns on\n              by  filed with same name in imgdata.params\n\n           * all client code should be recompiled due to structures size\n             change\n\n           * LibRaw::free() is now public instead of private.\n\n           * LibRaw 0.10.0-Beta1.\n\n2010-05-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in 8-bit RAW processing code\n           * LibRaw 0.9.1-Release\n\n2010-04-26 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support: OpenMP is possible under MinGW (untested)\n           * LibRaw 0.9.0-Release\n\n2010-04-21 Alex Tutubalin <lexa@lexa.ru>\n           * Finally fixed inconsistency in Fuji files processing\n           * New COLOR(row,col) call to get bayer color index in image[] array\n           * Old FC() call is deprecated and will be removed in future releases\n           * unprocessed_raw sample switched to COLOR() call\n           * LibRaw 0.9.0-Beta5\n\n\n2010-04-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in unpacking DNG files made from Fuji RAFs.\n           * LibRaw 0.9.0-Beta4\n\n2010-04-09 Alex Tutubalin <lexa@lexa.ru>\n\n           * Fixed typecast error (problem reported only on gcc 4.2.1/32bit)\n            in CRW files processing.\n\n           * C++ API call LibRaw::adjust_maximum() is now deprecated and\n             de-documented, use params.adjust_maximum_thr instead (on by default)\n\n           *  C-API call libraw_adjust_maximum() removed.\n\n           * New postprocessing parameter params.adjust_maximum_thr\n             This parameter replaces LibRaw::adjust_maximum(), but more flexible\n             Defaults are reasonable (0.75, same as in old adjust_maximum),\n             look into documentation for more details.\n\n           * Removed last OpenMP warning\n\n           * dcraw_emu's -c parameter now wants numeric (float) argument. This value\n             is assigned to params.adjust_maximum_thr.\n             Use -c 0.0 for dcraw compatibility.\n\n           * all client code should be recompiled due to structures size\n             change\n\n           * LibRaw 0.9.0-Beta3\n\n\n2010-03-29 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug in channel_maximum[] calculation for\n             Panasonic cameras.\n           * channel_maximum[] data now calculated for ALL cameras.\n           * OpenMP warnings suppressed.\n           * Documented the -c command-line switch for dcraw_emu sample.\n           * Removed extra messages from dcraw_emu sample.\n           * LibRaw 0.9.0-Beta2\n\n2010-03-28 Alex Tutubalin <lexa@lexa.ru>\n\n           New licensing:\n\n           * Triple licensing (selected by LibRaw user):\n\n              + LGPL 2.1 (http://www.gnu.org/licenses/lgpl-2.1.html)\n              + CDDL 1.0 (http://www.opensource.org/licenses/cddl1.txt)\n              + LibRaw Software License (27 March 2010 version)\n               (http://www.libraw.org/data/LICENSE.LibRaw.pdf)\n\n           * There is no separate LibRaw-Lite and LibRaw-Commercial versions,\n             only single LibRaw.\n             Current LibRaw-Lite and LibRaw-Commercial users should switch\n             to LibRaw without loss of functionality.\n             It is possible to change licensig too (e.g. from LGPL to CDDL\n             for LibRaw-Lite users and from LibRaw License to LGPL or CDDL\n             for LibRaw-Commercial users).\n\n           * No Foveon support :(\n             It is not possible to get good color from Foveon sensors with\n             *any* converter. So, there is no need to support these cameras.\n             Dcraw's Foveon-processing code is too strict licensed (GPL),\n             so we choose to drop it.\n\n           New Features:\n\n           * New data field  colordata.channel_maximum[4] - per channel data\n            maximum (calculated for most cameras, 0 for others).\n\n           * New call LibRaw::adjust_maximum() (and libraw_adjust_maximum() in C API).\n             This call changes hardcoded colordata.maximum value to calculated\n             at unpack stage. This helps suppress false color in highlights\n             (magenta clouds and so).\n\n           * New command line parameter -c for dcraw_emu sample. Calls adjust_maximum()\n             for each processed file.\n\n           * all client code should be recompiled due to structures size\n             change\n\n           * LibRaw 0.9.0-Beta1\n\n2010-02-06 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed ambiguity in pow/sqrt calls (to make Sun C++ compiler happy)\n           * OpenMP is not supported under MS Visual Studio\n           * Masked a bug in RIFF format parser\n           * LibRaw 0.8.6\n\n2009-12-30 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in simple_dcraw sample parameters processing\n           * Imported dcraw 8.99 (1.432):\n             + New cameras: Canon:  1D mk IV, Canon S90; Casio Z750,\n               Nikon D3S, Pentax K-x, Sony A-500/550, Fuji S200EXR\n             + New color data for Canon G11 and Sony A850\n             + Changes in Canon sRAW processing\n             + Changes in Kodak metadata processing\n             + Changes in uncompressed Fuji files processing (FinePix S5xxx)\n           * LibRaw 0.8.5\n\n2009-11-21 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed a bug in processing of uncompressed Phase One files\n           * LibRaw 0.8.4\n\n2009-10-24 Alex Tutubalin <lexa@lexa.ru>\n           + Imported dcraw 8.98/1.431:\n             * New Cameras: Canon 7D, Panasonic GF1, Sony A850 and A380,\n             Casio Z850, Nikon D300s\n           + changes in libraw_datastream.h to make compilers more happy\n           * LibRaw 0.8.3\n\n2009-09-02 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed bug in Hasselblad .3FR unpacking code\n           * Imported dcraw 8.97/1.428: Nikon D3000 image width fix\n           * LibRaw 0.8.2\n\n2009-08-31 Alex Tutubalin <lexa@lexa.ru>\n           + Enum LibRaw_thumbnail_formats (LIBRAW_IMAGE_*) values changed to\n             match values in  enum LibRaw_image_formats (LIBRAW_THUMBNAIL_*).\n             You need to recompile all sources using these constants.\n\n2009-08-30 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.97/1.427:\n             + new cameras: Canon A470, Canon G11 (without color data),\n                Nikon D3000, Olympus E-P1, Panasonic DMC-FZ35/FZ38\n             + some changes in decoding code.\n            * Fixes for Microsoft Visual C++ 6.0 compatibility\n            * C-API dcraw_make_mem_thumb() call finally exported in API\n           * LibRaw 0.8.1\n\n2009-08-24 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.96/1.426\n             + New cameras: Casio EX-Z60 and EX-Z75, Kodak Z980,\n               Nikon D5000,  Olympus X200, D560Z,C350Z,E620,\n               Pentax K7, Sony A330.\n             + New color data for many cameras\n             + Generalized unpacker code for Canon and Casio P&S cameras\n           * LibRaw 0.8.0-Release\n\n2009-08-13 Alex Tutubalin <lexa@lexa.ru>\n           * RAW files larger than 2Gb are supported on:\n              - Unix (all supported: FreeBSD, MacOS X, Linux)\n              - Windows (with C runtime version  >= 8.0)\n           * bzero replaced with memset to make Solaris users happy\n           * All applications on 32-bit systems should be recompiled\n             due to data structures size changes.\n           * Minor fixes in windows makefile\n           * LibRaw 0.8.0-Beta5\n\n2009-07-21 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.95 (1.425):\n             + new huffman tree code\n             + New cameras supported: AGFAPHOTO DC-833m, Casio EX-S20,\n                Phase One P65, Samsung S850\n             + Removed hardcoded white-balance data for many P&S cameras.\n               It is recommended to set params.use_camera_wb to 1 for\n               safe WB.\n           * Fixes for Nikon D5000 files: no pink stripe at\n             right side of frame\n           * C-wrapper: added missed calls\n               libraw_dcraw_make_mem_image\n               libraw_dcraw_ make_mem_thumb\n           * Minor fixes to make non-gcc compilers more happy\n           * Internal structures changed, full recompilation of all client\n             code is needed.\n           * LibRaw 0.8.0-Beta4\n\n2009-06-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes: gamma  curve processing was not performed in\n              dcraw_write_mem_image()\n           * Fixes: gamma curve processing was not performed for\n              Kodak thumbnails\n           * LibRaw 0.8.0-Beta3\n\n2009-06-05 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes in documentation: params.gamm[] described more precisely\n           * Fixes in version number, 0.8-beta1 was mistakenly 0.0.0-beta1\n           * LibRaw 0.8.0-Beta2\n\n2009-06-04 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.94 (1.423):\n             + New camera support:\n                 Canon: SX1, 500D/Rebel T1i, A570, A590, SX110\n                 Kodak Z1015, Motorola PIXL, Olympus E30, Panasonic DMC-GH1\n             + Improved color data for Nikon D3X\n             + New gamma curve model\n             + Many changes in RAW unpacking code\n             + Canon cameras: black level is not subtracted if set\n               params.document_mode > 1\n\n           * API changed: params.gamma_16bit field removed. Gamma curve is\n             set via params.gamm[0]/gamm[1] values (see documentation and\n             samples for details)\n           * LibRaw::identify() splitted to avoid MS VS2008 bug (too many\n             nested blocks)\n\n           * Samples: dcraw_emu and mem_image samples supports new dcraw\n              16bit/gamma semantics:\n                -6: set 16 bit output\n                -4: set 16 bit output and linear gamma curve and no auto\n                   brighness\n           *  LibRaw 0.8.0-Beta1\n\n2009-04-28 Alex Tutubalin <lexa@lexa.ru>\n           * Identify sample renamed to raw-identify (name conflict\n             with ImageMagic)\n           * Copyright notice changes\n           * Many compiler warnings removed\n\n2009-04-07 Alex Tutubalin <lexa@lexa.ru>\n           * More accurate types conversion in libraw_datastream.h\n           * New postprocessing parameter auto_bright_thr: set portion of\n             clipped pixels for auto brightening code (instead of\n             dcraw-derived hardcoded 1%)\n           * -U  option for dcraw_emu sample sets auto_bright_thr parameter\n           * all client code should be recompiled due to structures size\n             change\n           * LibRaw 0.7.2-Release\n\n2009-03-22 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed typo in OpenMP support code\n           * MinGW support\n           * dcraw source is included in distribution\n           * LibRaw 0.7.1-Release\n\n2009-03-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fuji SuperCCD RAWs: color channels unshuffled on RAW\n             read stage (moved from postprocessing stage)\n\n           * LibRaw 0.7.0-Release\n\n2009-03-13 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.93/1.421 imported:\n             + more accurate pentax dSLR support\n             + fixes in Kodak 620x/720x identification\n             + faster identification procedure for some formats.\n           * LibRaw 0.7.0-Beta5\n\n\n2009-03-08 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.92/1.420 imported:\n             + user-specified gamma curve\n             + Pentax K2000/Km support\n             + Changes in Canon sRAW processing (support for 5D2 fw 1.07)\n\n           * all client code should be recompiled\n\n           * LibRaw 0.7.0-Beta4\n\n2009-02-13 Alex Tutubalin <lexa@lexa.ru>\n           * bugfix: 4channels sample finally subtracts black by default\n           * dcraw 8.91/1.419 imported:\n              + fixes in RIFF files parsing\n\n           * LibRaw 0.7.0-Beta3\n\n2009-02-12 Alex Tutubalin <lexa@lexa.ru>\n           * Black level was not calculated for Canon RAWs in\n             some filtering modes\n\n           * 4channels sample prints calculated black level\n             (scaled if autoscaling used).\n             Also output file names for this sample now includes\n             color channel name (R/G/B/G2 or C/M/Y/G)\n\n           * LibRaw 0.7.0-Beta2\n\n2009-02-09 Alex Tutubalin <lexa@lexa.ru>\n           * New sample 4channels: splits RAW color channels into four\n             separate TIFFs\n\n           * LibRaw 0.7.0-Beta1\n\n2009-02-07 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in external jpeg metadata reading code.\n\n           * Cleaned some C++ warnings\n\n           * dcraw 8.91/1.418 imported\n             + Hasselblad V96C support\n\n           * You need to clean and recompile client code which\n             uses LibRaw_*_datastream classes.\n\n           * LibRaw 0.7.0-Alpha6\n\n2009-01-30  Alex Tutubalin <lexa@lexa.ru>\n\n           * New data input framework is created. It is possible now to\n             easyly implement your own data input interface for LibRaw\n             (e.g. for reading RAW data from network data stream)\n\n           * All older programs using previous LibRaw versions are\n\t     compatible at source code level.\n\n           * LibRaw can read RAW data from memory buffer via\n             new LibRaw::open_buffer() API call (implemented on top of\n             new input framework).\n             This call used in sample application dcraw_emu and simple_dcraw\n             (with -B command-line switch) to test new API.\n\n           * Error handling callback functions now can be called with\n             NULL filename passed (if underlying data stream object\n             does not know file name).\n             So, client error handling callbacks should work with NULL\n             filename.\n\n           * All client code should be recompiled\n\n           * Imported dcraw 8.90/1.417:\n              + Support for loading White Balance data from\n                Sony ARW files edited with Sony IDC software.\n\n           * LibRaw 0.7.0-Alpha5\n\n2009-01-17 Alex Tutubalin <lexa@lexa.ru>\n           * Raw filtering mode LIBRAW_FILTERING_NOPOSTPROCESS has renamed\n            to LIBRAW_FILTERING_NORAWCURVE for better reflect its purpose.\n            This filtering_mode bit turns off tone curve applying on\n            RAW data on bayer-pattern cameras with raw tone curve:\n              + Adobe DNG (only RAW with bayer pattern)\n              + Nikon compressed NEF\n              + Some Kodak cameras\n              + Sony A700/A900 (tone curve applied to 8-bit raws)\n\n           * unprocessed_raw sample: added command-line key -N, this key\n             turns on LIBRAW_FILTERING_NORAWCURVE filtering mode.\n\n           * New scheme of Fuji RAW processing (introduced in 0.7-Alpha3)\n             supports DNG files generated from Fuji RAF.\n\n           * Imported dcraw 8.90/1.416:\n              + better support for Samsung S85\n              + fixed possible integer overflow in wavelet denoising code\n\n           * LibRaw 0.7.0-Alpha4\n\n\n2009-01-14 Alex Tutubalin <lexa@lexa.ru>\n           * Black mask extraction supported for all files with bayer data\n            (one component per pixel). Black mask data not avaliable\n            for multi-component data (Foveon, Canon sRAW, Sinar 4-shot,\n            Kodak YCC/YRGB).\n\n           * Black level subtraction can be turned off for all bayer\n            cameras (added support for PhaseOne backs).\n\n           * Fujifilm camera processing model changed:\n              + RAW data is extracted without 45-degree rotation\n              + dcraw-compatible rotation is performed on postptocessing stage\n              + it is possible to rotate RAW data without postprocessing\n                by LibRaw::rotate_fuji_raw() call.\n\n           * New filtering mode setting: LIBRAW_FILTERING_NOPOSTPROCESS\n             This bits turns off RAW tone curve processing based on tone curve\n             readed from RAW metadata.\n             This mode supported only for PhaseOne backs now (to be supported\n             on all relevant cameras in nearest future releases)\n\n           * Black level data (got from RAW data) are stored for PhaseOne backs.\n\n           * Black level subtraction bug (derived from dcraw) fixed\n             for PhaseOne files.\n\n           * Fixed processing of -s parameter for dcraw_emu sample\n\n           * Parameter  -s N (select shot number) added to\n             unprocessed_raw sample.\n\n           * Imported dcraw 8.90/1.414:\n              + changes in QuickTake 100 metadata processing\n              + changes in external jpeg processing code\n              + Samsung S85 support\n\n           * All client code should be recompiled\n\n           * LibRaw 0.7.0-Alpha3 released\n\n2009-01-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in add_masked_borders: crash if output dimensions\n            is already larger than raw dimensions\n            * Fixed out of bounds in samples/unprocessed_raw.cpp for files\n            with non-square pixels\n\n           * LibRaw 0.7.0-Alpha2 released\n\n2009-01-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in  0.7.0-a0: black frame size has not reset,\n             so in batch processing there is an error in black frame\n             size for files without black frame.\n\n           * Implemented reading of black/masked pixels data for\n             near all cameras with masked pixels, exclding:\n              + Canon sRAW, Leaf (MOS), Sinar 4-shot - more than one\n                color component in black frame (redesign of black frame\n                data structures required).\n              + Fuji SuperCCD: need to design right methods of extraction\n                (should we rotate and resize black pixels as active ones??)\n\n            * Tested for most dSLR data formats with masked pixels: 7 of 9\n              untested formats are from old P&S cameras.\n\n           * New call LibRaw::unpack_function_name() returns unpack function name\n             (useful for testers only)\n\n           * New identify sample parameters (useful for test-suite builders\n             to check test coverage):\n                  -u - print unpack function name\n                  -f - print masked frame size\n             These parameters works only for identify run without -v parameter\n\n           * Imported dcraw 8.89/1.411\n             + changes in Panasonic FZ50 files parsing\n\n           * LibRaw 0.7.0-Alpha1 released\n\n\n2009-01-05 Alex Tutubalin <lexa@lexa.ru>\n           * It is possible to turn off RAW data filtration (black level\n             subtraction,              zero pixels averaging):\n                + supported on all cameras except Foveon and Phase One\n                + filtraction controlled by new parameter \"filtering_mode\"\n                + it is possible to expand API by filtering procedures\n                  built for specific camera model.\n\n           * Black border (masked pixels) extraction:\n                + API (data structures) for storing black mask.\n                + Black mask extraction supported only for limited list of\n                  data formats:\n                       - Canon .CRW, .CR2 (with exception of sRAW),A600, A5\n                       - Adobe DNG (both converted RAW and native DNG)\n                       - Nikon NEF (compressed only)\n                  this list to be expanded in future LibRaw versions\n           * New call add_masked_borders_to_bitmap makes full bitmap\n             'masked border' + image\n           * Usage sample for functionality listed above:\n              samples/unprocessed_raw\n           * Imported dcraw 8.89/1.410:\n              + fixed bugs in Hasselblad .fff decoding\n              + fixes in Imacon metadata decoding\n           * Documentation changes\n           * All client code should be recompiled\n           * LibRaw 0.7.0-Alpha0\n\n\n2009-01-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug (filedescriptor and buffer memory leak)  in thumbnail\n             extraction when called before metadata analysis.\n             Thanks to Albert Astalis Cid.\n           * LibRaw 0.6.4 Release\n\n2008-12-11 Alex Tutubalin <lexa@lexa.ru>\n           * Imported new edition of dcraw 8.89 (version 1.409)\n           * Nikon NEF decoding changed\n           * LibRaw 0.6.3 Release\n\n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * fixed bug in Panasonic .RW2 processing (only for thread-safe version,\n             single-threaded version was not affected)\n           * All client code should be recompiled\n           * LibRaw 0.6.2 Release\n\n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * Imported  dcraw 8.89 (version 1.407)\n           * New cameras:\n               Canon G10 & 5D Mk2, Leaf AFi 7, Leica D-LUX4, Panasonic FX150 & G1,\n               Fujifilm IS Pro,\n           * Changed camera support (color conversion tables):\n               Canon 50D, Nikon D90 & P6000, Panasonic LX3 & FZ28, Sony A900\n           * LibRaw 0.6.2 beta\n\n2008-09-25 Alex Tutubalin <lexa@lexa.ru>\n           * Added new data field  float LibRaw::imgdata.color.cam_xyz[4][3].\n           This field contains constant table (different for each camera) for\n           Camera RGB->XYZ conversion.\n           * All client code should be recompiled\n           * LibRaw 0.6.1 Release\n\n2008-09-18 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.88 imported:\n              - new cameras (Canon 50D, Sony A900, Nikon D90 & P6000,\n                Panasonic LX3 FZ28)\n              - new method of black point subtraction for Canon cameras,\n                preliminary banding supression.\n            * Stack memory usage lowered (some thread data moved to dynamic\n            memory)\n            * some patches for MSVC compatibility\n            * LibRaw 0.6.0 Release\n\n2008-09-16 Alex Tutubalin <lexa@lexa.ru>\n           * Enum definitions changed to make gcc -pedantic happy\n           * Compiler/preprocessor flags does not affects LibRaw class field set\n           (i.e. structure for thread local storage is always allocated)\n           * Default library compilation mode (i.e. sources imported in another\n             project) is thread-safe\n\n2008-09-14 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support for most CPU consuming steps of processing:\n             ahd_interpolation. wavelet_denoise\n             10-30% speed-up of full processing pipe on 2-core CPU\n             OpenMP supported only on gcc (Linux/FreeBSD and Mac OS X)\n\n           * LibRaw 0.6.0-Beta-1\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           *  All set_**handler accepts additional void* pointer, which should point to\n            callback private data. This pointer passed to user callback when it called.\n\n           * LibRaw 0.6.0-alpha5\n\n           * All client code should be recompiled\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           * New processing stages in enum LibRaw_progress:\n             LIBRAW_PROGRESS_BAD_PIXELS LIBRAW_PROGRESS_DARK_FRAME\n            (reserved stages LIBRAW_PROGRESS_RESERVED_PRE1-PRE2 has removed)\n           * libraw_strprogress() - convert progress code into string\n\n           * Added progress/cancellation user callbacks\n             + new fatal error code: CANCELLED_BY_CALLBACK\n             + sample usage in samples/dcraw_emu.cpp (try run it with -v -v -v opts)\n\n           * LibRaw 0.6.0-alpha4\n\n           * All client code should be recompiled\n\n2008-09-08 Alex Tutubalin <lexa@lexa.ru>\n           * ICC-profiles support (same as in dcraw)\n             + input/output profiles (specified as path to 'icc' file or 'embed' for\n               embedded input profile)\n             + additional warnings\n             + LCMS library used\n\n           * support of bad pixel map (caller should specify path to bad pixel file\n              in dcraw-compatible format)\n\n           * dark frame subtraction support (caller should supply path to 16-bit PGM\n              map). samples/simple_dcraw.cpp - -4 option added for dark frame file\n              generation\n\n           * support of bad pixeld map (dcraw-compatible format)\n\n           * the dcraw_emu sample supports all new features (ICC, dark frame, bad\n              pixels)\n\n           * libraw/libraw_version.h, defines, calls and macros for version checks:\n              + LibRaw::version(), LibRaw::versionNumber(), LIBRAW_CHECK_VERSION()\n\n           * List of supported cameras:\n              + LibRaw::cameraCount()\n              + LibRaw::cameraList()\n\n           * fixed error in adjust_sizes_info_only\n\n           * documentation changes\n\n           * LibRaw 0.6.0-alpha3\n\n2008-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * samples/mem_image.c - bitwise equal output with dcraw -4\n             (PPMs outputted with network byte order)\n           * LibRaw 0.6.0-alpha2\n\n2008-09-06 Alex Tutubalin <lexa@lexa.ru>\n           * Added calls dcraw_make_mem_image and dcraw_make_mem_image:\n             + functions (and supporting code)\n             + documentation changed\n             + new sample code samples/mem_image.cpp\n           * Added processing parameter  LibRaw::imgdata.params.gamma_16bit\n              (set to 1 to make gamma correction for 16-bit output)\n           * LibRaw 0.6.0-alpha1\n\n2008-08-28 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 1.404 (8.87) imported:\n             - 6 new cameras supported (Canon 1000D, A720, SD300;\n                Nikon D700, Oly E-520,Kodak C603)\n           * Licensing changed to GPL v2\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * mmap/malloc+read IO-layer removed due to no performance gain.\n              FILE I/O returned\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * dcraw 1.403 imported\n              - changes in ljpeg decompression (index values cut to 12 bit)\n              - changes in parse_foveon() jpeg thumbnail extraction\n            * LibRaw 0.5.3 released\n\n2008-04-24  Alex Tutubalin <lexa@lexa.ru>\n            * Linux build of samples/identify fixed\n            * documentation editorial\n            * LibRaw 0.5.2 released\n\n2008-04-21  Alex Tutubalin <lexa@lexa.ru>\n            * All documentation translated to English\n            * English changelog started :)\n            * minor bug (include path) fixed in samples/half_mt\n            * LibRaw 0.5.1 released\n", "#ifndef IGNOREALL\n/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2015 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.476 $\n   $Date: 2015/05/25 02:29:14 $\n */\n/*@out DEFINES\n#ifndef USE_JPEG\n#define NO_JPEG\n#endif\n#ifndef USE_JASPER\n#define NO_JASPER\n#endif\n@end DEFINES */\n\n#define NO_LCMS\n#define DCRAW_VERBOSE\n//@out DEFINES\n#define DCRAW_VERSION \"9.26\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _USE_MATH_DEFINES\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n//@end DEFINES\n\n#if defined(DJGPP) || defined(__MINGW32__)\n#define fseeko fseek\n#define ftello ftell\n#else\n#define fgetc getc_unlocked\n#endif\n//@out DEFINES\n#ifdef __CYGWIN__\n#include <io.h>\n#endif\n#if defined WIN32 || defined (__MINGW32__)\n#include <sys/utime.h>\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define snprintf _snprintf\n#define strcasecmp stricmp\n#define strncasecmp strnicmp\n//@end DEFINES\ntypedef __int64 INT64;\ntypedef unsigned __int64 UINT64;\n//@out DEFINES\n#else\n#include <unistd.h>\n#include <utime.h>\n#include <netinet/in.h>\ntypedef long long INT64;\ntypedef unsigned long long UINT64;\n#endif\n\n#ifdef NODEPS\n#define NO_JASPER\n#define NO_JPEG\n#define NO_LCMS\n#endif\n#ifndef NO_JASPER\n#include <jasper/jasper.h>\t/* Decode Red camera movies */\n#endif\n#ifndef NO_JPEG\n#include <jpeglib.h>\t\t/* Decode compressed Kodak DC120 photos */\n#endif\t\t\t\t/* and Adobe Lossy DNGs */\n#ifndef NO_LCMS\n#ifdef USE_LCMS\n#include <lcms.h>\t\t/* Support color profiles */\n#else\n#include <lcms2.h>\t\t/* Support color profiles */\n#endif\n#endif\n#ifdef LOCALEDIR\n#include <libintl.h>\n#define _(String) gettext(String)\n#else\n#define _(String) (String)\n#endif\n\n#ifdef LJPEG_DECODE\n#error Please compile dcraw.c by itself.\n#error Do not link it with ljpeg_decode.\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * sizeof (long))\n#endif\n//@end DEFINES\n\n#if !defined(uchar)\n#define uchar unsigned char\n#endif\n#if !defined(ushort)\n#define ushort unsigned short\n#endif\n\n/*\n   All global variables are defined here, and all functions that\n   access them are prefixed with \"CLASS\".  Note that a thread-safe\n   C++ class cannot have non-const static local variables.\n */\nFILE *ifp, *ofp;\nshort order;\nconst char *ifname;\nchar *meta_data, xtrans[6][6], xtrans_abs[6][6];\nchar cdesc[5], desc[512], make[64], model[64], model2[64], artist[64],software[64];\nfloat flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;\ntime_t timestamp;\noff_t strip_offset, data_offset;\noff_t thumb_offset, meta_offset, profile_offset;\nunsigned shot_order, kodak_cbpp, exif_cfa, unique_id;\nunsigned thumb_length, meta_length, profile_length;\nunsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;\nunsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;\nunsigned black, maximum, mix_green, raw_color, zero_is_bad;\nunsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;\nunsigned tile_width, tile_length, gpsdata[32], load_flags;\nunsigned flip, tiff_flip, filters, colors;\nushort raw_height, raw_width, height, width, top_margin, left_margin;\nushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;\nushort *raw_image, (*image)[4], cblack[4102];\nushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];\ndouble pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };\nfloat bright=1, user_mul[4]={0,0,0,0}, threshold=0;\nint mask[8][4];\nint half_size=0, four_color_rgb=0, document_mode=0, highlight=0;\nint verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=1;\nint output_color=1, output_bps=8, output_tiff=0, med_passes=0;\nint no_auto_bright=0;\nunsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };\nfloat cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];\nconst double xyz_rgb[3][3] = {\t\t\t/* XYZ from RGB */\n  { 0.412453, 0.357580, 0.180423 },\n  { 0.212671, 0.715160, 0.072169 },\n  { 0.019334, 0.119193, 0.950227 } };\nconst float d65_white[3] = { 0.950456, 1, 1.088754 };\nint histogram[4][0x2000];\nvoid (*write_thumb)(), (*write_fun)();\nvoid (*load_raw)(), (*thumb_load_raw)();\njmp_buf failure;\n\nstruct decode {\n  struct decode *branch[2];\n  int leaf;\n} first_decode[2048], *second_decode, *free_decode;\n\nstruct tiff_ifd {\n  int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;\n  int t_tile_width, t_tile_length,sample_format,predictor;\n  float t_shutter;\n} tiff_ifd[10];\n\nstruct ph1 {\n  int format, key_off, tag_21a;\n  int t_black, split_col, black_col, split_row, black_row;\n  float tag_210;\n} ph1;\n\n#define CLASS\n\n//@out DEFINES\n#define FORC(cnt) for (c=0; c < cnt; c++)\n#define FORC3 FORC(3)\n#define FORC4 FORC(4)\n#define FORCC for (c=0; c < colors && c < 4; c++)\n\n#define SQR(x) ((x)*(x))\n#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))\n#define CLIP(x) LIM((int)(x),0,65535)\n#define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }\n\n#define my_swap(type, i, j) {type t = i; i = j; j = t;}\n\nstatic float fMAX(float a, float b)\n{\n  return MAX(a,b);\n}\n\n/*\n   In order to inline this calculation, I make the risky\n   assumption that all filter patterns can be described\n   by a repeating pattern of eight rows and two columns\n\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\n   because its pattern is 16x16, not 2x8.\n\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\n\n\tPowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\n\t0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\n\t1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\n\t2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\n\t3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\n\t\t\t4 C Y C Y C Y\t4 Y C Y C Y C\n\tPowerShot A5\t5 G M G M G M\t5 G M G M G M\n\t0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\n\t\t\t7 M G M G M G\t7 M G M G M G\n\t  0 1 2 3 4 5\n\t0 C Y C Y C Y\n\t1 G M G M G M\n\t2 C Y C Y C Y\n\t3 M G M G M G\n\n   All RGB cameras use one of these Bayer grids:\n\n\t0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\n\t1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\n\t2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\n\t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n */\n\n#define RAW(row,col) \\\n\traw_image[(row)*raw_width+(col)]\n//@end DEFINES\n\n#define FC(row,col) \\\n\t(filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)\n\n//@out DEFINES\n#define BAYER(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]\n\n#define BAYER2(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]\n//@end DEFINES\n\n/* @out COMMON\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end COMMON */\n\n//@out COMMON\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return(p ? p-s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a,b) local_strnlen(a,b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n int r = fp->read(buf,len,1);\n buf[len-1] = 0;\n return r;\n}\n#define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr (char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf,sizeof(buf)-1)\n\n//@end COMMON\n\n\nvoid CLASS merror (void *ptr, const char *where)\n{\n  if (ptr) return;\n  fprintf (stderr,_(\"%s: Out of memory in %s\\n\"), ifname, where);\n  longjmp (failure, 1);\n}\n\nvoid CLASS derror()\n{\n  if (!data_error) {\n    fprintf (stderr, \"%s: \", ifname);\n    if (feof(ifp))\n      fprintf (stderr,_(\"Unexpected end of file\\n\"));\n    else\n      fprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) ftello(ifp));\n  }\n  data_error++;\n}\n\n//@out COMMON\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG\t1\n#define AdobeDNG\t2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords,int maxlen)\n{\n  line[maxlen-1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while(1)\n  {\n    while(isspace(*p)) p++;\n    if(*p == '\\0') return nwords;\n    words[nwords++] = p;\n    while(!isspace(*p) && *p != '\\0') p++;\n    if(*p == '\\0') return nwords;\n    *p++ = '\\0';\n    if(nwords >= maxwords) return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f){\n\tif ((a >> 4) > 9) return 0;\n\telse if ((a & 0x0f) > 9) return 0;\n\telse if ((b >> 4) > 9) return 0;\n\telse if ((b & 0x0f) > 9) return 0;\n\telse if ((c >> 4) > 9) return 0;\n\telse if ((c & 0x0f) > 9) return 0;\n\telse if ((d >> 4) > 9) return 0;\n\telse if ((d & 0x0f) > 9) return 0;\n\telse if ((e >> 4) > 9) return 0;\n\telse if ((e & 0x0f) > 9) return 0;\n\telse if ((f >> 4) > 9) return 0;\n\telse if ((f & 0x0f) > 9) return 0;\nreturn 1;\n}\n\nstatic ushort bcd2dec(uchar data){\n\tif ((data >> 4) > 9) return 0;\n\telse if ((data & 0x0f) > 9) return 0;\n\telse return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] = \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s)\t// specific to some Canon Makernotes fields, where they have endian in reverse\n{\n\tif (order == 0x4d4d)\t\t/* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n\t\treturn s[0] | s[1] << 8;\n\telse\t\t\t\t\t\t/* \"MM\" means big-endian... */\n\t\treturn s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u,v;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:\n      u.d = (unsigned int) get4();\n      v.d = (unsigned int)get4();\n      return u.d / (v.d ? v.d : 1);\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10:\n      u.d = (signed int) get4();\n      v.d = (signed int)get4();\n      return u.d / (v.d?v.d:1);\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS cubic_spline (const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);\n  if (!A) return;\n  A[0] = (float *) (A + 2*len);\n  for (i = 1; i < 2*len; i++)\n    A[i] = A[0] + 2*len*i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));\n  for (i = 0; i < len; i++) {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len-1; i > 0; i--) {\n    b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);\n    d[i-1] = x[i] - x[i-1];\n  }\n  for (i = 1; i < len-1; i++) {\n    A[i][i] = 2 * (d[i-1] + d[i]);\n    if (i > 1) {\n      A[i][i-1] = d[i-1];\n      A[i-1][i] = d[i-1];\n    }\n    A[i][len-1] = 6 * (b[i+1] - b[i]);\n  }\n  for(i = 1; i < len-2; i++) {\n    float v = A[i+1][i] / A[i][i];\n    for(j = 1; j <= len-1; j++)\n      A[i+1][j] -= v * A[i][j];\n  }\n  for(i = len-2; i > 0; i--) {\n    float acc = 0;\n    for(j = i; j <= len-2; j++)\n      acc += A[i][j]*c[j];\n    c[i] = (A[i][len-1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++) {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len-1; j++) {\n      if (x[j] <= x_out && x_out <= x[j+1]) {\n\tfloat v = x_out - x[j];\n\ty_out = y[j] +\n\t  ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v\n\t   + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :\n\t\t(ushort)(y_out * 65535.0 + 0.5));\n  }\n  free (A);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25) return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row+=8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    FORC(2) free (huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free (huff[c]);\n}\n//@end COMMON\n\nstruct jhead {\n  int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];\n  ushort quant[64], idct[64], *huff[20], *free[20], *row;\n};\n\n//@out COMMON\n\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;\n  do {\n    if(feof(ifp)) return 0;\n    if(cnt++ > 1024) return 0; // 1024 tags limit\n    if (!fread (data, 2, 2, ifp)) return 0;\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:        // start of frame; lossless, Huffman\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc1:\n      case 0xffc0:\n\tjh->algo = tag & 0xff;\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:          // define Huffman tables\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && !((c = *dp++) & -20); )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:          // start of scan\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdb:\n\tFORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 ||\n     !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;\n  if (info_only) return 1;\n  if (!jh->huff[0]) return 0;\n  FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n  if(!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row=0, col=0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if(jh.clrs == 4 && jwide >= raw_width*2) jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*raw_height);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*raw_height);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp (failure, 3);\n#endif\n      if ((unsigned) row < raw_height) RAW(row,col) = val;\n      if (++col >= raw_width)\n\tcol = (row++,0);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  ljpeg_end (&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(load_flags & 256)\n  {\n\twidth = raw_width;\n\theight = raw_height;\n  }\n\n  try {\n#endif\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n\t  rp = (short *) ljpeg_row (jrow++, &jh);\n\tif (col >= width) continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC (jh.clrs-2)\n              {\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n                ip[col + (c >> 1)*width + (c & 1)][1] = ip[col + (c >> 1)*width + (c & 1)][2] = 8192;\n              }\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC (jh.clrs-2)\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else\n#endif\n          {\n            FORC (jh.clrs-2)\n              ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n          }\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n    {\n      ljpeg_end (&jh);\n      maximum = 0x3fff;\n      height = saved_h;\n      width = saved_w;\n      return;\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (row & (jh.sraw >> 1))\n    {\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n          {\n\t       ip[col][c] =  ip[col-width][c];\n          }\n          else\n          {\n              ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n          }\n    }\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB) )\n#endif\n    for ( ; rp < ip[0]; rp+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (unique_id == 0x80000218 ||\n          unique_id == 0x80000250 ||\n          unique_id == 0x80000261 ||\n          unique_id == 0x80000281 ||\n          unique_id == 0x80000287) {\n        rp[1] = (rp[1] << 2) + hue;\n        rp[2] = (rp[2] << 2) + hue;\n        pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n        pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n        pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n      } else {\n        if (unique_id < 0x80000218) rp[0] -= 512;\n        pix[0] = rp[0] + rp[2];\n        pix[2] = rp[0] + rp[1];\n        pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n      }\n      FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += tiff_samples;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select) (*rp)--;\n}\n\nvoid CLASS ljpeg_idct (struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = { 0 };\n  static const uchar zigzag[80] =\n  {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,\n    40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,\n    29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,\n    47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;\n  memset (work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];\n  for (i=1; i < 64; i++ ) {\n    len = gethuff (jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15) break;\n    coef = getbits(len);\n    if ((coef & (1 << (len-1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= MIN (is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try {\n#endif\n      switch (jh.algo) {\n      case 0xc1:\n\tjh.vpred[0] = 16384;\n\tgetbits(-1);\n\tfor (jrow=0; jrow+7 < jh.high; jrow += 8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  for (jcol=0; jcol+7 < jh.wide; jcol += 8) {\n\t    ljpeg_idct (&jh);\n\t    rp = jh.idct;\n\t    row = trow + jcol/tile_width + jrow*2;\n\t    col = tcol + jcol%tile_width;\n\t    for (i=0; i < 16; i+=2)\n\t      for (j=0; j < 8; j++)\n\t\tadobe_copy_pixel (row+i, col+j, &rp);\n\t  }\n\t}\n\tbreak;\n      case 0xc3:\n\tfor (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  rp = ljpeg_row (jrow, &jh);\n\t  for (jcol=0; jcol < jwide; jcol++) {\n\t    adobe_copy_pixel (trow+row, tcol+col, &rp);\n\t    if (++col >= tile_width || col >= raw_width)\n\t      row += 1 + (col = 0);\n\t  }\n\t}\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n    }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n    }\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (pixel);\n    throw ;\n  }\n#endif\n  free (pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width*3*tiff_bps/8;\n  if(tiff_bps <= 8)\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n  else\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n  fseek (ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char*)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for(int row = 0; row < raw_height; row++)\n    {\n      int red = fread (buf, 1, bufsize, ifp);\n      unsigned short (*ip)[4] = (unsigned short (*)[4]) image + row*width;\n      if(tiff_bps <= 8)\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[buf[col*3]];\n            ip[col][1] = curve[buf[col*3+1]];\n            ip[col][2] = curve[buf[col*3+2]];\n            ip[col][3]=0;\n          }\n      else\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[ubuf[col*3]];\n            ip[col][1] = curve[ubuf[col*3+1]];\n            ip[col][2] = curve[ubuf[col*3+2]];\n            ip[col][3]=0;\n          }\n    }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (min=row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n      i = gethuff(huff);\n      len = i & 15;\n      shl = i >> 4;\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (huff);\n    throw;\n  }\n#endif\n  free (huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col=0; col < raw_width; col++) {\n      if (!(b = col & 1)) {\n\tbitbuf = 0;\n\tFORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;\n\tFORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705*yuv[3];\n      rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];\n      rgb[2] = yuv[b] + 1.732446*yuv[2];\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"Pentax\",  \"Optio 33WR\" },\n    { 0x03, \"Nikon\",   \"E3200\" },\n    { 0x32, \"Nikon\",   \"E3700\" },\n    { 0x33, \"Olympus\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n//@end COMMON\n\nvoid CLASS jpeg_thumb();\n\n//@out COMMON\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length, 2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0) return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < high; y++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5];\n\t row < raw_height && row < rend &&\n\t row < head[1]+head[3]-head[5]; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4];\n\t     col < raw_width &&\n\t     col < cend && col < head[0]+head[2]-head[4]; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  /* static */ const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2]={NULL,NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!meta_length)\n#else\n  if (half_size || !meta_length)\n#endif\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  while (entries--) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n      }\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131 || type == 137)\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    } else if (tag == 0x41f && !qlin_applied) { /* Quadrant linearization */\n      ushort lc[2][2][16], ref[16];\n      int qr, qc;\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 16; i++)\n\t    lc[qr][qc][i] = get4();\n      for (i = 0; i < 16; i++) {\n\tint v = 0;\n\tfor (qr = 0; qr < 2; qr++)\n\t  for (qc = 0; qc < 2; qc++)\n\t    v += lc[qr][qc][i];\n\tref[i] = (v + 2) >> 2;\n      }\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[19], cf[19];\n\t  for (i = 0; i < 16; i++) {\n\t    cx[1+i] = lc[qr][qc][i];\n\t    cf[1+i] = ref[i];\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n          cf[18] = cx[18] = 65535;\n\t  cubic_spline(cx, cf, 19);\n\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n\t}\n      }\n      qlin_applied = 1;\n    } else if (tag == 0x41e && !qmult_applied) { /* Quadrant multipliers */\n      float qmult[2][2] = { { 1, 1 }, { 1, 1 } };\n      get4(); get4(); get4(); get4();\n      qmult[0][0] = 1.0 + getreal(11);\n      get4(); get4(); get4(); get4(); get4();\n      qmult[0][1] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][0] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][1] = 1.0 + getreal(11);\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col=0; col < raw_width; col++) {\n\t  i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);\n\t  RAW(row,col) = LIM(i,0,65535);\n\t}\n      }\n      qmult_applied = 1;\n    } else if (tag == 0x431 && !qmult_applied) { /* Quadrant combined */\n      ushort lc[2][2][7], ref[7];\n      int qr, qc;\n      for (i = 0; i < 7; i++)\n\tref[i] = get4();\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 7; i++)\n\t    lc[qr][qc][i] = get4();\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[9], cf[9];\n\t  for (i = 0; i < 7; i++) {\n\t    cx[1+i] = ref[i];\n\t    cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[8] = cf[8] = 65535;\n\t  cubic_spline(cx, cf, 9);\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n        }\n      }\n      qmult_applied = 1;\n      qlin_applied = 1;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    }\n    free (yval[0]);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if(yval[0]) free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw()\");\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw()\");\n      if (ph1.black_col)\n        {\n          fseek (ifp, ph1.black_col, SEEK_SET);\n          read_shorts ((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height*2);\n        }\n      if (ph1.black_row)\n        {\n          fseek (ifp, ph1.black_row, SEEK_SET);\n          read_shorts ((ushort *) imgdata.rawdata.ph1_rblack[0], raw_width*2);\n        }\n      }\n#endif\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short (*)[2]) (offset + raw_height);\n  fseek (ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n      read_shorts ((ushort *) c_black[0], raw_height*2);\n  r_black = c_black + raw_height;\n  fseek (ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n      read_shorts ((ushort *) r_black[0], raw_width*2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_cblack,(ushort*)c_black[0],raw_height*2*sizeof(ushort));\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_rblack,(ushort*)r_black[0],raw_width*2*sizeof(ushort));\n    }\n#endif\n\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (col=0; col < raw_width; col++) {\n      int shift = ph1.format == 8? 0: 2;\n      i = (pixel[col] << shift) - ph1.t_black\n\t+ c_black[row][col >= ph1.split_col]\n\t+ r_black[col][row >= ph1.split_row];\n      if (i > 0) RAW(row,col) = i;\n    }\n#else\n    if(ph1.format == 8)\n      memmove(&RAW(row,0),&pixel[0],raw_width*2);\n    else\n      for (col=0; col < raw_width; col++)\n      \tRAW(row,col) = pixel[col] << 2;\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  back[4] = (int *) calloc (raw_width, 3*sizeof **back);\n  merror (back[4], \"hasselblad_load_raw()\");\n  FORC3 back[c] = back[4] + c*raw_width;\n  cblack[6] >>= sh = tiff_samples > 1;\n  shot = LIM(shot_select, 1, tiff_samples) - 1;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC4 back[(c+3) & 3] = back[c];\n    for (col=0; col < raw_width; col+=2) {\n      for (s=0; s < tiff_samples*2; s+=2) {\n\tFORC(2) len[c] = ph1_huff(jh.huff[0]);\n\tFORC(2) {\n\t  diff[s+c] = ph1_bits(len[c]);\n\t  if ((diff[s+c] & (1 << (len[c]-1))) == 0)\n\t    diff[s+c] -= (1 << len[c]) - 1;\n\t  if (diff[s+c] == 65535) diff[s+c] = -32768;\n\t}\n      }\n      for (s=col; s < col+2; s++) {\n\tpred = 0x8000 + load_flags;\n\tif (col) pred = back[2][s-2];\n\tif (col && row > 1) switch (jh.psv) {\n\t  case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;\n\t}\n\tf = (row & 1)*3 ^ ((col+s) & 1);\n\tFORC (tiff_samples) {\n\t  pred += diff[(s & 1)*tiff_samples+c];\n\t  upix = pred >> sh & 0xffff;\n\t  if (raw_image && c == shot)\n\t    RAW(row,s) = upix;\n\t  if (image) {\n\t    urow = row-top_margin  + (c & 1);\n\t    ucol = col-left_margin - ((c >> 1) & 1);\n\t    ip = &image[urow*width+ucol][f];\n\t    if (urow < height && ucol < width)\n\t      *ip = c < 4 ? upix : (*ip + upix) >> 1;\n\t  }\n\t}\n\tback[2][s] = pred;\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (back[4]);\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  free (back[4]);\n  ljpeg_end (&jh);\n  if (image) mix_green = 1;\n}\n\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n  }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n    int row, col, bits=0;\n    while (1 << ++bits < maximum);\n    for (row=raw_height-1; row >= 0; row--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcheckCancel();\n#endif\n\tread_shorts (&raw_image[row*raw_width], raw_width);\n\tfor (col=0; col < raw_width; col++)\n\t\tif ((RAW(row,col) >>= load_flags) >> bits\n\t\t\t&& (unsigned) (row-top_margin) < height\n\t\t\t&& (unsigned) (col-left_margin) < width) derror();\n    }\n}\n\n\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image) return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width*3*sizeof(unsigned short));\n  merror(buf,\"imacon_full_load_raw\");\n#endif\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf,width*3);\n    unsigned short (*rowp)[4] = &image[row*width];\n    for (col=0; col < width; col++)\n      {\n        rowp[col][0]=buf[col*3];\n        rowp[col][1]=buf[col*3+1];\n        rowp[col][2]=buf[col*3+2];\n        rowp[col][3]=0;\n      }\n#else\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < raw_width; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&\n\trow < height+top_margin && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom () {\n\n/* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek (ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread (&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right)*5)+3)>>2) + 0x1f)&(~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616;  /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order) {\n    case 0: /* RGGB */\n      filters = 0x94949494;\n      break;\n    case 1: /* GBRG */\n      filters = 0x49494949;\n      break;\n    case 3: /* GRBG */\n      filters = 0x61616161;\n      break;\n  }\n}\n\nvoid CLASS broadcom_load_raw() {\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *) malloc (raw_stride*2);\n  merror (data, \"broadcom_load_raw()\");\n\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+raw_stride, 1, raw_stride, ifp) < raw_stride) derror();\n    FORC(raw_stride) data[c] = data[raw_stride+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n  double sum[]={0,0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (data);\n    throw;\n  }\n#endif\n  free (data);\n  maximum = 0x3ff;\n  if (strncmp(make,\"OmniVision\",10)) return;\n  row = raw_height/2;\n  FORC(width-1) {\n    sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));\n    sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));\n  }\n  if (sum[1] > sum[0]) filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5*raw_width >> 5) << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_tight_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n}\n  free (data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf=0;\n\n  bwide = (raw_width+5)/6 << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_loose_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=8, col+=6) {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c^7];\n      FORC(6) RAW(row,col+c) = (bitbuf >> c*10) & 0x3ff;\n    }\n  }\n  free (data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int*)malloc(sizeof(int)*(raw_width/3+1));\n  merror(words,\"canon_rmf_load_raw\");\n#endif\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words,sizeof(int),raw_width/3,ifp);\n    for (col=0; col < raw_width-2; col+=3)\n      {\n        bits = words[col/3];\n        FORC3 {\n          orow = row;\n          if ((ocol = col+c-4) < 0)\n            {\n              ocol += raw_width;\n              if ((orow -= 2) < 0)\n                orow += raw_height;\n            }\n          RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n        }\n      }\n#else\n    for (col=0; col < raw_width-2; col+=3) {\n      bits = get4();\n      FORC3 {\n\torow = row;\n\tif ((ocol = col+c-4) < 0) {\n\t  ocol += raw_width;\n\t  if ((orow -= 2) < 0)\n\t    orow += raw_height;\n\t}\n\tRAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress (&cinfo);\n    longjmp (failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n    ((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager {\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit (j_common_ptr cinfo)\n{\n  jpegErrorManager* myerr = (jpegErrorManager*) cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if(data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf,\"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char*) malloc(width*3);\n  jpeg_create_decompress (&cinfo);\n  merror(pixel_buf,\"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf,data_size,1,ifp);\n  swab ((char*)jpg_buf, (char*)jpg_buf, data_size);\n  try\n    {\n      jpeg_mem_src(&cinfo, jpg_buf, data_size);\n      int rc = jpeg_read_header(&cinfo, TRUE);\n      if(rc!=1)\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n      jpeg_start_decompress (&cinfo);\n      if ((cinfo.output_width      != width  ) ||\n          (cinfo.output_height*2   != height ) ||\n          (cinfo.output_components != 3      ))\n        {\n          throw LIBRAW_EXCEPTION_DECODE_JPEG;\n        }\n\n      unsigned char *buf[1];\n      buf[0] = pixel_buf;\n\n      while (cinfo.output_scanline < cinfo.output_height)\n        {\n          checkCancel();\n          row = cinfo.output_scanline * 2;\n          jpeg_read_scanlines (&cinfo, buf, 1);\n          unsigned char (*pixel)[3] = (unsigned char (*)[3]) buf[0];\n          for (col=0; col < width; col+=2) {\n            RAW(row+0,col+0) = pixel[col+0][1] << 1;\n            RAW(row+1,col+1) = pixel[col+1][1] << 1;\n            RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n            RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n          }\n        }\n    }\n  catch (...)\n        {\n          jpeg_finish_decompress (&cinfo);\n          jpeg_destroy_decompress (&cinfo);\n          free(jpg_buf);\n          free(pixel_buf);\n          throw;\n        }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--) {\n      opcode = get4(); get4(); get4();\n      if (opcode != 8)\n      { fseek (ifp, get4(), SEEK_CUR); continue; }\n      fseek (ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2) break;\n      fseek (ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8) break;\n      for (i=0; i <= deg && i < 9; i++)\n\tcoeff[i] = getreal(12);\n      for (i=0; i < 256; i++) {\n\tfor (tot=j=0; j <= deg; j++)\n\t  tot += coeff[j] * pow(i/255.0, (int)j);\n\tcur[c][i] = tot*0xffff;\n      }\n    }\n    order = sorder;\n  } else {\n    gamma_curve (1/2.4, 12.92, 1, 255);\n    FORC3 memcpy (cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    jpeg_destroy_decompress (&cinfo);\n    throw;\n  }\n#endif\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;\n    }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, sum=0;\n\n  huff[0] = 15;\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--; )\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width+1);\n  merror (data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      /* flag checks if outside of loop */\n      if(! (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n         || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n         )\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else pix[i]=0;\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i=0; i < 16; i++, col+=2)\n            {\n              unsigned slope = pix[i] < 1001? 2 : curve[pix[i]<<1]-curve[(pix[i]<<1)-2];\n              unsigned step = 1 << sh;\n              RAW(row,col)=curve[pix[i]<<1]>black+imgdata.params.sony_arw2_posterization_thr?\n                LIM(((slope*step*1000)/(curve[pix[i]<<1]-black)),0,10000):0;\n            }\n        }\n      else\n        {\n          for (i=0; i < 16; i++, col+=2)\n            RAW(row,col) = curve[pix[i] << 1];\n        }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (data);\n    throw;\n  }\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum=10000;\n#endif\n  free (data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, strip_offset+row*4, SEEK_SET);\n    fseek (ifp, data_offset+get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7:4;\n    for (col=0; col < raw_width; col+=16) {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c]) {\n\tcase 3: len[c] = ph1_bits(4);\tbreak;\n\tcase 2: len[c]--;\t\tbreak;\n\tcase 1: len[c]++;\n      }\n      for (c=0; c < 16; c+=2) {\n\ti = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n\tif (c == 14) c = -1;\n      }\n    }\n  }\n  for (row=0; row < raw_height-1; row+=2)\n    for (col=0; col < raw_width-1; col+=2)\n      SWAP (RAW(row,col+1), RAW(row+1,col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] =\n  { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,\n    0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };\n  ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n=i=0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek (ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(),get2());\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0; pmode = 7;\n    FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;\n    prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1));\t// green\n    prow[~row & 1] = &RAW(row-2,0);\t\t\t// red and blue\n    for (tab=0; tab+15 < raw_width; tab+=16) {\n      if (~opt & 4 && !(tab & 63)) {\n\ti = ph1_bits(2);\n\tmag = i < 3 ? mag-'2'+\"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n\tpmode = 7 - 4*ph1_bits(1);\n      else if (!ph1_bits(1))\n\tpmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1)) {\n\tFORC4 len[c] = ph1_bits(2);\n\tFORC4 {\n\t  i = ((row & 1) << 1 | (c & 1)) % 3;\n\t  len[c] = len[c] < 3 ? lent[i][0]-'1'+\"120\"[len[c]] : ph1_bits(4);\n\t  lent[i][0] = lent[i][1];\n\t  lent[i][1] = len[c];\n\t}\n      }\n      FORC(16) {\n\tcol = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));\n\tpred = (pmode == 7 || row < 2)\n\t     ? (tab ? RAW(row,tab-2+(col & 1)) : init)\n\t     : (prow[col & 1][col-'4'+\"0224468\"[pmode]] +\n\t\tprow[col & 1][col-'4'+\"0244668\"[pmode]] + 1) >> 1;\n\tdiff = ph1_bits (i = len[c >> 2]);\n\tif (diff >> (i-1)) diff -= 1 << i;\n\tdiff = diff * (mag*2+1) + mag;\n\tRAW(row,col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width*raw_height)\n       seg[1][0] = raw_width*raw_height;\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n            ((data + (((data & (1 << (nbits-1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(pix>=raw_width*raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar) fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n    {\n      jas_stream_close (in);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n    }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2), (width+2)*2);\n  merror (img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try {\n#endif\n  FORC4 {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    fastexitflag=true;\n  }\n#endif\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\n//@end COMMON\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder (unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code) {\n    for (i=0; i < size; i++)\n      huff[i] = get4();\n    memset (first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode+2048) {\n    fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp (failure, 2);\n  }\n  if (code)\n    for (i=0; i < size; i++)\n      if (huff[i] == code) {\n\tcur->leaf = i;\n\treturn;\n      }\n  if ((len = code >> 27) > 26) return;\n  code = (len+1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder (size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder (size, code+1);\n}\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff (ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i=0; i < 13; i++) {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j=0; j < 256 >> clen; )\n      huff[code+ ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n\t}\n      }\n    }\n  }\n#ifdef DCRAW_VERBOSE\n   else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n#endif\n}\n\nconst char * CLASS foveon_camf_param (const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'P') continue;\n    if (strcmp (block, pos+sget4(pos+12))) continue;\n    cp = pos + sget4(pos+16);\n    num = sget4(cp);\n    dp = pos + sget4(cp+4);\n    while (num--) {\n      cp += 8;\n      if (!strcmp (param, dp+sget4(cp)))\n\treturn dp+sget4(cp+4);\n    }\n  }\n  return 0;\n}\n\nvoid * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'M') continue;\n    if (strcmp (name, pos+sget4(pos+12))) continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos+16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp+4)) > 3) break;\n    dp = pos + sget4(cp+8);\n    for (i=ndim; i--; ) {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;\n    mat = (unsigned *) malloc ((size = dsize) * 4);\n    merror (mat, \"foveon_camf_matrix()\");\n    for (i=0; i < size; i++)\n      if (type && type != 6)\n\tmat[i] = sget4(dp + i*4);\n      else\n\tmat[i] = sget4(dp + i*2) & 0xffff;\n    return mat;\n  }\n#ifdef DCRAW_VERBOSE\n  fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n#endif\n  return 0;\n}\n\nint CLASS foveon_fixed (void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name) return 0;\n  dp = foveon_camf_matrix (dim, name);\n  if (!dp) return 0;\n  memcpy (ptr, dp, size*4);\n  free (dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg (short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;\n\n  for (i=range[0]; i <= range[1]; i++) {\n    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\n    if (min > val) min = val;\n    if (max < val) max = val;\n  }\n  if (range[1] - range[0] == 1) return sum/2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort * CLASS foveon_make_curve (double max, double mul, double filt)\n{\n  short *curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt) filt = 0.8;\n  size = 4*M_PI*max / filt;\n  if (size == UINT_MAX) size--;\n  curve = (short *) calloc (size+1, sizeof *curve);\n  merror (curve, \"foveon_make_curve()\");\n  curve[0] = size;\n  for (i=0; i < size; i++) {\n    x = i*filt/max/4;\n    curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;\n  }\n  return curve;\n}\n\nvoid CLASS foveon_make_curves\n\t(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max=0;\n  int c;\n\n  FORC3 mul[c] = dq[c]/div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve (short *curve, int i)\n{\n  if (abs(i) >= curve[0]) return 0;\n  return i < 0 ? -curve[1-i] : curve[1+i];\n}\n\n#define image ((short (*)[4]) image)\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\n  short *pix, prev[3], *curve[8], (*shrink)[3];\n  float cfilt=0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float (*black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p=0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum=0, trsum[3];\n  char str[128];\n  const char* cp;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Foveon interpolation...\\n\"));\n#endif\n\n  foveon_load_camf();\n  foveon_fixed (dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed (satlev, 3, \"SaturationLevel\");\n  foveon_fixed (keep, 4, \"KeepImageArea\");\n  foveon_fixed (active, 4, \"ActiveImageArea\");\n  foveon_fixed (chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed (color_dq, 3,\n\tfoveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))\n\t\t foveon_fixed (&cfilt, 1, \"ColumnFilter\");\n\n  memset (ddft, 0, sizeof ddft);\n  if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")\n\t || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))\n    for (i=0; i < 2; i++) {\n      foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n\tfor (col = dstb[0]; col <= dstb[2]; col++)\n\t  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];\n      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\n    }\n\n  if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n#endif\n    return; }\n  foveon_fixed (cam_xyz, 9, cp);\n  foveon_fixed (correct, 9,\n\tfoveon_camf_param (\"WhiteBalanceCorrections\", model2));\n  memset (last, 0, sizeof last);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n  #define LAST(x,y) last[(i+x)%3][(c+y)%3]\n  for (i=0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\n  #undef LAST\n  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;\n  sprintf (str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param (\"IncludeBlocks\", str))\n    foveon_fixed (div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\n  for (i=0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves (curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves (curve+3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  curve[6] = foveon_make_curve (dsum, dsum, cfilt);\n  curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);\n\n  sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");\n  if (!sgain) return;\n  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\n  sgx = (width + dim[1]-2) / (dim[1]-1);\n\n  black = (float (*)[3]) calloc (height, sizeof *black);\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +\n\trow / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    FORC3 black[row][c] =\n\t( foveon_avg (image[row*width]+c, dscr[0], cfilt) +\n\t  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3\n\t  - ddft[0][c][0] ) / 4 - ddft[0][c][1];\n  }\n  memcpy (black, black+8, sizeof *black*8);\n  memcpy (black+height-11, black+height-22, 11*sizeof *black);\n  memcpy (last, black, sizeof last);\n\n  for (row=1; row < height-1; row++) {\n    FORC3 if (last[1][c] > last[0][c]) {\n\tif (last[1][c] > last[2][c])\n\t  black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\n      } else\n\tif (last[1][c] < last[2][c])\n\t  black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\n    memmove (last, last+1, 2*sizeof last[0]);\n    memcpy (last[2], black[row+1], sizeof last[2]);\n  }\n  FORC3 black[row][c] = (last[0][c] + last[1][c])/2;\n  FORC3 black[0][c] = (black[1][c] + black[3][c])/2;\n\n  val = 1 - exp(-1/24.0);\n  memcpy (fsum, black, sizeof fsum);\n  for (row=1; row < height; row++)\n    FORC3 fsum[c] += black[row][c] =\n\t(black[row][c] - black[row-1][c])*val + black[row-1][c];\n  memcpy (last[0], black[height-1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--; )\n    FORC3 last[0][c] = black[row][c] =\n\t(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\n\n  memset (total, 0, sizeof total);\n  for (row=2; row < height; row+=4)\n    for (col=2; col < width; col+=4) {\n      FORC3 total[c] += (short) image[row*width+col][c];\n      total[3]++;\n    }\n  for (row=0; row < height; row++)\n    FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);\n\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +\n\trow / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    pix = image[row*width];\n    memcpy (prev, pix, sizeof prev);\n    frow = row / (height-1.0) * (dim[2]-1);\n    if ((irow = frow) == dim[2]-1) irow--;\n    frow -= irow;\n    for (i=0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\n\t\t\t  sgain[(irow+1)*dim[1]+i][c] *    frow;\n    for (col=0; col < width; col++) {\n      FORC3 {\n\tdiff = pix[c] - prev[c];\n\tprev[c] = pix[c];\n\tipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\n\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)\n\t\t- black[row][c] );\n      }\n      FORC3 {\n\twork[0][c] = ipix[c] * ipix[c] >> 14;\n\twork[2][c] = ipix[c] * work[0][c] >> 14;\n\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\n      }\n      FORC3 {\n\tfor (val=i=0; i < 3; i++)\n\t  for (  j=0; j < 3; j++)\n\t    val += ppm[c][i][j] * work[i][j];\n\tipix[c] = floor ((ipix[c] + floor(val)) *\n\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\n\t\t  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);\n\tif (ipix[c] > 32000) ipix[c] = 32000;\n\tpix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free (black);\n  free (sgrow);\n  free (sgain);\n\n  if ((badpix = (unsigned *) foveon_camf_matrix (dim, \"BadPixels\"))) {\n    for (i=0; i < dim[0]; i++) {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20       ) - keep[1];\n      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)\n\tcontinue;\n      memset (fsum, 0, sizeof fsum);\n      for (sum=j=0; j < 8; j++)\n\tif (badpix[i] & (1 << j)) {\n\t  FORC3 fsum[c] += (short)\n\t\timage[(row+hood[j*2])*width+col+hood[j*2+1]][c];\n\t  sum++;\n\t}\n      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;\n    }\n    free (badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);\n  merror (smrow[6], \"foveon_interpolate()\");\n  for (i=0; i < 5; i++)\n    smrow[i] = smrow[6] + i*width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tsmrow[4][col][0] =\n\t  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      smred = ( 6 *  smrow[2][col][0]\n\t      + 4 * (smrow[1][col][0] + smrow[3][col][0])\n\t      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\n      if (col == 2)\n\tsmred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\n      if (i > 32000) i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3 {\n    i = satlev[c] / div[c];\n    if (min > i) min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c=1; c < 3; c++) {\n      if (min > pix[c]) min = pix[c];\n      if (max < pix[c]) max = pix[c];\n    }\n    if (min >= limit*2) {\n      pix[0] = pix[1] = pix[2] = max;\n    } else {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i*i >> 14);\n      i = i*i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n/*\n   Because photons that miss one detector often hit another,\n   the sum R+G+B is much less noisy than the individual colors.\n   So smooth the hues without smoothing the total.\n */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -\n\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] =\n\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      for (total[3]=375, sum=60, c=0; c < 3; c++) {\n\tfor (total[c]=i=0; i < 5; i++)\n\t  total[c] += smrow[i][col][c];\n\ttotal[3] += total[c];\n\tsum += pix[c];\n      }\n      if (sum < 0) sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve (curve[6],\n\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);\n    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);\n    FORC3 {\n      for (dsum=i=0; i < 3; i++)\n\tdsum += trans[c][i] * pix[i];\n      if (dsum < 0)  dsum = 0;\n      if (dsum > 24000) dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  shrink = (short (*)[3]) calloc ((height/4), (width/4)*sizeof *shrink);\n  merror (shrink, \"foveon_interpolate()\");\n  for (row = height/4; row--; )\n    for (col=0; col < width/4; col++) {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i=0; i < 4; i++)\n\tfor (j=0; j < 4; j++)\n\t  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];\n      FORC3\n\tif (row+2 > height/4)\n\t  shrink[row*(width/4)+col][c] = ipix[c] >> 4;\n\telse\n\t  shrink[row*(width/4)+col][c] =\n\t    (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row=0; row < (height & ~3); row++) {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3 ; col--; )\n\tFORC3 smrow[0][col][c] = ipix[c] =\n\t  (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col=0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] =\n\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy (smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col=0; col < (width & ~3); col++)\n\tFORC3 smrow[2][col][c] =\n\t  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\n\n  /* Adjust the chroma toward the smooth values */\n    for (col=0; col < (width & ~3); col++) {\n      for (i=j=30, c=0; c < 3; c++) {\n\ti += smrow[2][col][c];\n\tj += image[row*width+col][c];\n      }\n      j = (j << 16) / i;\n      for (sum=c=0; c < 3; c++) {\n\tipix[c] = foveon_apply_curve (curve[c+3],\n\t  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);\n\tsum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3 {\n\ti = image[row*width+col][c] + ipix[c] - sum;\n\tif (i < 0) i = 0;\n\timage[row*width+col][c] = i;\n      }\n    }\n  }\n  free (shrink);\n  free (smrow[6]);\n  for (i=0; i < 8; i++)\n    free (curve[i]);\n\n  /* Trim off the black border */\n  active[1] -= keep[1];\n  active[3] -= 2;\n  i = active[2] - active[0];\n  for (row=0; row < active[3]-active[1]; row++)\n    memcpy (image[row*i], image[(row+active[1])*width+active[0]],\n\t i * sizeof *image);\n  width = i;\n  height = row;\n}\n#undef image\n\n/* RESTRICTED code ends here */\n\n//@out COMMON\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n    c, m, mblack[8], zero, val;\n#else\n    c, m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3] > 0) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)\n      for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n//@end COMMON\n\n/* @out FILEIO\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end FILEIO */\n\n\n// @out FILEIO\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n// @end FILEIO\n  else {\n    for (len=32 ; ; len *= 2) {\n      fname = (char *) malloc (len);\n      if (!fname) return;\n      if (getcwd (fname, len-16)) break;\n      free (fname);\n      if (errno != ERANGE) return;\n    }\n#if defined(WIN32) || defined(DJGPP)\n    if (fname[1] == ':')\n      memmove (fname, fname+2, len-2);\n    for (cp=fname; *cp; cp++)\n      if (*cp == '\\\\') *cp = '/';\n#endif\n    cp = fname + strlen(fname);\n    if (cp[-1] == '/') cp--;\n    while (*fname == '/') {\n      strcpy (cp, \"/.badpixels\");\n      if ((fp = fopen (fname, \"r\"))) break;\n      if (cp == fname) break;\n      while (*--cp != '/');\n    }\n    free (fname);\n  }\n// @out FILEIO\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}\n\nvoid CLASS subtract (const char *fname)\n{\n  FILE *fp;\n  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);\n#endif\n\n  if (!(fp = fopen (fname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n    perror (fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\n    if (c == '#')  comment = 1;\n    if (c == '\\n') comment = 0;\n    if (comment) continue;\n    if (isdigit(c)) number = 1;\n    if (number) {\n      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\n      else if (isspace(c)) {\n\tnumber = 0;  nd++;\n      } else error = 1;\n    }\n  }\n  if (error || nd < 3) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose (fp);  return;\n  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {\n#ifdef DCRAW_VERBOSE\n      fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose (fp);  return;\n  }\n  pixel = (ushort *) calloc (width, sizeof *pixel);\n  merror (pixel, \"subtract()\");\n  for (row=0; row < height; row++) {\n    fread (pixel, 2, width, fp);\n    for (col=0; col < width; col++)\n      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\n  }\n  free (pixel);\n  fclose (fp);\n  memset (cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n#endif\n}\n//@end FILEIO\n\n//@out COMMON\n\nstatic const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if(num > 0.00001)\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] /= num;\n        pre_mul[i] = 1 / num;\n      }\n    else\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] = 0.0;\n        pre_mul[i] = 1.0;\n      }\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER2(row,col);\n\tBAYER2(row,col) = black + (BAYER2(row,col)-black)/2;\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (pass=0; pass < 2; pass++) {\n    for (raw_color = i=0; i < colors; i++)\n      for (j=0; j < 3; j++)\n\tfor (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\t  cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff (rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq=0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)\n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(load_raw == &LibRaw::nikon_load_sraw)\n      {\n        // Nikon sRAW: camera WB already applied:\n        pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;\n      }\n    else\n#endif\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw\n      && !use_camera_wb && !use_auto_wb\n      && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )\n    {\n      for(c=0;c<3;c++)\n        pre_mul[c]/=cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0) pre_mul[1] = 1;\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {\n    FORC4 cblack[FC(c/2,c%2)] +=\n\tcblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    if (!(val = ((ushort *)image)[i])) continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +\n\t\t\ti/4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n      if (filters == 9) {\n\tfor (row=0; row < 3; row++)\n\t  for (col=1; col < 4; col++)\n\t    if (!(image[row*width+col][0] | image[row*width+col][2]))\n\t      goto break2;  break2:\n\tfor ( ; row < height; row+=3)\n\t  for (col=(col-1)%3+1; col < width-1; col+=3) {\n\t    img = image + row*width+col;\n\t    for (c=0; c < 3; c+=2)\n\t      img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n\t  }\n      }\n    } else {\n      img = (ushort (*)[4]) calloc (height, width*sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size) colors++;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 9) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = sum[c]>0?256 / sum[c]:0;\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,-128, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,-120, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,-128, +0,-1,+0,+1,1,-120, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,-128,\n    +1,-1,+1,+1,0,-120, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 9) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab (ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb) {\n#ifndef LIBRAW_NOTHREADS\n    if(cbrt[0] < -1.0f)\n#endif\n    for (i=0; i < 0x10000; i++) {\n      r = i / 65535.0;\n      cbrt[i] = r > 0.008856 ? pow(r,1.f/3.0f) : 7.787f*r + 16.f/116.0f;\n    }\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (xyz_cam[i][j] = k=0; k < 3; k++)\n\t  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int) xyz[0])];\n  xyz[1] = cbrt[CLIP((int) xyz[1])];\n  xyz[2] = cbrt[CLIP((int) xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512\t\t/* Tile Size */\n#define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate (int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int cstat[4]={0,0,0,0};\n#endif\n\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },\n\tpatt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },\n\t\t\t{ 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },\n\tdir[4] = { 1,TS,TS+1,TS-1 };\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)    [TS][3], (*lix)[3];\n   float (*drv)[TS][TS], diff[6], tr;\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/* Check against right pattern */\n  for (row = 0; row < 6; row++)\n         for (col = 0; col < 6; col++)\n                 cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16 \n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n         throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n\n  cielab (0,0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *) malloc (TS*TS*(ndir*11+6));\n  merror (buffer, \"xtrans_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));\n  drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));\n  homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));\n\n/* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row=0; row < 3; row++)\n    for (col=0; col < 3; col++)\n      for (ng=d=0; d < 10; d+=2) {\n\tg = fcol(row,col) == 1;\n\tif (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;\n\tif (ng == 4) { sgrow = row; sgcol = col; }\n\tif (ng == g+1) FORC(8) {\n\t  v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];\n\t  h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];\n\t  allhex[row][col][0][c^(g*2 & d)] = h + v*width;\n\t  allhex[row][col][1][c^(g*2 & d)] = h + v*TS;\n\t}\n      }\n\n/* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row=2; row < height-2; row++)\n    for (min=~(max=0), col=2; col < width-2; col++) {\n      if (fcol(row,col) == 1 && (min=~(max=0))) continue;\n      pix = image + row*width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max) FORC(6) {\n\tval = pix[hex[c]][1];\n\tif (min > val) min = val;\n\tif (max < val) max = val;\n      }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row-sgrow) % 3) {\n\tcase 1: if (row < height-3) { row++; col--; } break;\n\tcase 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;\n      }\n    }\n\n  for (top=3; top < height-19; top += TS-16)\n    for (left=3; left < width-19; left += TS-16) {\n      mrow = MIN (top+TS, height-3);\n      mcol = MIN (left+TS, width-3);\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++)\n\t  memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);\n      FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);\n\n/* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++) {\n\t  if ((f = fcol(row,col)) == 1) continue;\n\t  pix = image + row*width + col;\n\t  hex = allhex[row % 3][col % 3][0];\n\t  color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -\n\t\t\t 46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);\n\t  color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +\n\t\t\t 92 * (pix[      0 ][f] - pix[ -hex[2]][f]);\n\t  FORC(2) color[1][2+c] =\n\t\t164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *\n\t\t(2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);\n\t  FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =\n\t\tLIM(color[1][c] >> 8,pix[0][1],pix[0][3]);\n\t}\n\n      for (pass=0; pass < passes; pass++) {\n\tif (pass == 1)\n\t  memcpy (rgb+=4, buffer, 4*sizeof *rgb);\n\n/* Recalculate green from interpolated values of closer pixels:\t*/\n\tif (pass) {\n\t  for (row=top+2; row < mrow-2; row++)\n\t    for (col=left+2; col < mcol-2; col++) {\n\t      if ((f = fcol(row,col)) == 1) continue;\n\t      pix = image + row*width + col;\n\t      hex = allhex[row % 3][col % 3][1];\n\t      for (d=3; d < 6; d++) {\n\t\trix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];\n\t\tval = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]\n\t\t    - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];\n\t\trix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);\n\t      }\n\t    }\n\t}\n\n/* Interpolate red and blue values for solitary green pixels:\t*/\n\tfor (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)\n\t  for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    h = fcol(row,col+1);\n\t    memset (diff, 0, sizeof diff);\n\t    for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {\n\t      for (c=0; c < 2; c++, h^=2) {\n\t\tg = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];\n\t\tcolor[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];\n\t\tif (d > 1)\n\t\t  diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]\n\t\t\t\t- rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);\n\t      }\n\t      if (d > 1 && (d & 1))\n\t\tif (diff[d-1] < diff[d])\n\t\t  FORC(2) color[c*2][d] = color[c*2][d-1];\n\t      if (d < 2 || (d & 1)) {\n\t\tFORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);\n\t\trix += TS*TS;\n\t      }\n\t    }\n\t  }\n\n/* Interpolate red for blue pixels and vice versa:\t\t*/\n\tfor (row=top+3; row < mrow-3; row++)\n\t  for (col=left+3; col < mcol-3; col++) {\n\t    if ((f = 2-fcol(row,col)) == 1) continue;\n\t    rix = &rgb[0][row-top][col-left];\n\t    c = (row-sgrow) % 3 ? TS:1;\n\t    h = 3 * (c ^ TS ^ 1);\n\t    for (d=0; d < 4; d++, rix += TS*TS) {\n\t      i = d > 1 || ((d ^ c) & 1) ||\n\t\t ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <\n\t\t2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;\n\t      rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +\n\t\t  2*rix[0][1] - rix[i][1] - rix[-i][1])/2);\n\t    }\n\t  }\n\n/* Fill in red and blue for 2x2 blocks of green:\t\t*/\n\tfor (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)\n\t  for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    hex = allhex[row % 3][col % 3][1];\n\t    for (d=0; d < ndir; d+=2, rix += TS*TS)\n\t      if (hex[d] + hex[d+1]) {\n\t\tg = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);\n\t      } else {\n\t\tg = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);\n\t      }\n\t  }\n      }\n      rgb = (ushort(*)[TS][TS][3]) buffer;\n      mrow -= top;\n      mcol -= left;\n\n/* Convert to CIELab and differentiate in all directions:\t*/\n      for (d=0; d < ndir; d++) {\n\tfor (row=2; row < mrow-2; row++)\n\t  for (col=2; col < mcol-2; col++)\n\t    cielab (rgb[d][row][col], lab[row][col]);\n\tfor (f=dir[d & 3],row=3; row < mrow-3; row++)\n\t  for (col=3; col < mcol-3; col++) {\n\t    lix = &lab[row][col];\n\t    g = 2*lix[0][0] - lix[f][0] - lix[-f][0];\n\t    drv[d][row][col] = SQR(g)\n\t      + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))\n\t      + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));\n\t  }\n      }\n\n/* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir*TS*TS);\n      for (row=4; row < mrow-4; row++)\n\tfor (col=4; col < mcol-4; col++) {\n\t  for (tr=FLT_MAX, d=0; d < ndir; d++)\n\t    if (tr > drv[d][row][col])\n\t\ttr = drv[d][row][col];\n\t  tr *= 8;\n\t  for (d=0; d < ndir; d++)\n\t    for (v=-1; v <= 1; v++)\n\t      for (h=-1; h <= 1; h++)\n\t\tif (drv[d][row+v][col+h] <= tr)\n\t\t  homo[d][row][col]++;\n\t}\n\n/* Average the most homogenous pixels for the final result:\t*/\n      if (height-top < TS+4) mrow = height-top+2;\n      if (width-left < TS+4) mcol = width-left+2;\n      for (row = MIN(top,8); row < mrow-8; row++)\n\tfor (col = MIN(left,8); col < mcol-8; col++) {\n\t  for (d=0; d < ndir; d++)\n\t    for (hm[d]=0, v=-2; v <= 2; v++)\n\t      for (h=-2; h <= 2; h++)\n\t\thm[d] += homo[d][row+v][col+h];\n\t  for (d=0; d < ndir-4; d++)\n\t    if (hm[d] < hm[d+4]) hm[d  ] = 0; else\n\t    if (hm[d] > hm[d+4]) hm[d+4] = 0;\n\t  for (max=hm[0],d=1; d < ndir; d++)\n\t    if (max < hm[d]) max = hm[d];\n\t  max -= max >> 3;\n\t  memset (avg, 0, sizeof avg);\n\t  for (d=0; d < ndir; d++)\n\t    if (hm[d] >= max) {\n\t      FORC3 avg[c] += rgb[d][row][col][c];\n\t      avg[3]++;\n\t    }\n\t  FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];\n\t}\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0],lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n\n  cielab(0,0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {\n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab (0,0);\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row=top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    cielab (rix[0],lix[0]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high, wide*sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nint CLASS parse_tiff_ifd (int base);\n\n//@out COMMON\n\nstatic float powf_lim(float a, float b, float limup)\n{\n  return (b>limup || b < -limup)?0.f:powf(a,b);\n}\nstatic float powf64(float a, float b)\n{\n  return powf_lim(a,b,64.f);\n}\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x) {\n  float t;\n  if (x >= 0.0) {\n    t = ceilf(x);\n    if (t - x > 0.5) t -= 1.0;\n    return t;\n  } else {\n    t = ceilf(-x);\n    if (t + x > 0.5) t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff)) return 0.0f;\n  return powf64(2.0, in/64.0);\n}\n\nstatic float _CanonConvertEV (short in)\n{\n\tshort EV, Sign, Frac;\n\tfloat Frac_f;\n\tEV = in;\n\tif (EV < 0) {\n\t  EV = -EV;\n\t  Sign = -1;\n\t} else {\n\t  Sign = 1;\n\t}\n\tFrac = EV & 0x1f;\n\tEV -= Frac;\t\t\t// remove fraction\n\n\tif (Frac == 0x0c) {\t\t// convert 1/3 and 2/3 codes\n\t  Frac_f = 32.0f / 3.0f;\n\t} else if (Frac == 0x14) {\n\t  Frac_f = 64.0f / 3.0f;\n\t} else Frac_f = (float) Frac;\n\n\treturn ((float)Sign * ((float)EV + Frac_f))/32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures (unsigned id)\n      {\n      imgdata.lens.makernotes.CamID = id;\n\tif (\n            (id == 0x80000001) ||\t// 1D\n            (id == 0x80000174) ||\t// 1D2\n            (id == 0x80000232) ||\t// 1D2N\n            (id == 0x80000169) ||\t// 1D3\n            (id == 0x80000281)\t\t// 1D4\n            )\n          {\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n          }\n        else\n          if (\n              (id == 0x80000167) ||\t// 1Ds\n              (id == 0x80000188) ||\t// 1Ds2\n              (id == 0x80000215) ||\t// 1Ds3\n              (id == 0x80000269) ||\t// 1DX\n              (id == 0x80000328) ||\t// 1DX2\n              (id == 0x80000324) ||\t// 1DC\n              (id == 0x80000213) ||\t// 5D\n              (id == 0x80000218) ||\t// 5D2\n              (id == 0x80000285) ||\t// 5D3\n              (id == 0x80000349) ||\t// 5D4\n              (id == 0x80000382) ||\t// 5DS\n              (id == 0x80000401) ||\t// 5DS R\n              (id == 0x80000302) \t// 6D\n              )\n            {\n              imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n            }\n          else\n            if (\n                (id == 0x80000331) ||\t// M\n                (id == 0x80000355) ||\t// M2\n                (id == 0x80000374) || \t// M3\n                (id == 0x80000384) || \t// M10\n                (id == 0x80000394)  \t// M5\n                )\n              {\n                imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n              }\n            else\n              if (\n                  (id == 0x01140000) ||\t// D30\n                  (id == 0x01668000) ||\t// D60\n                  (id > 0x80000000)\n                  )\n                {\n                  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n                }\n              else\n                {\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                }\n\n\treturn;\n      }\n\nvoid CLASS processCanonCameraInfo (unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0;\n  if(maxlen<16) return; // too short, so broken\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id) {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal  = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12)) iCanonLensID = 151;\n    else iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n    {\n      if(iCanonFocalType>=maxlen) return; // broken;\n      imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n      if (!imgdata.lens.makernotes.FocalType)\t// zero means 'fixed' here, replacing with standard '1'\n        imgdata.lens.makernotes.FocalType = 1;\n    }\n  if (!imgdata.lens.makernotes.CurFocal)\n    {\n      if(iCanonCurFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n    }\n  if (!imgdata.lens.makernotes.LensID)\n    {\n      if(iCanonLensID>=maxlen) return; // broken;\n      imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n    }\n  if (!imgdata.lens.makernotes.MinFocal)\n    {\n      if(iCanonMinFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n    }\n  if (!imgdata.lens.makernotes.MaxFocal)\n    {\n      if(iCanonMaxFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n    }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens) {\n    if(iCanonLens+64>=maxlen) return; // broken;\n    if (CameraInfo[iCanonLens] < 65)\t\t\t\t\t\t\t\t// non-Canon lens\n      {\n        memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n      }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n      {\n        memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n        memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n        memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings ()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2(); get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2(); get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2(); get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets (int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2) fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets (short WBCTversion)\n{\n\tif (WBCTversion == 0)\n\t  for (int i=0; i<15; i++)// tint, as shot R, as shot B, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if (WBCTversion == 1)\n\t  for (int i=0; i<15; i++)\t// as shot R, as shot B, tint, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n\t\t((unique_id == 0x80000374) ||\t// M3\n\t\t (unique_id == 0x80000384) ||\t// M10\n\t\t (unique_id == 0x80000394) ||\t// M5\n\t\t (unique_id == 0x03970000)))\t// G7 X Mark II\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n                ((unique_id == 0x03950000) || (unique_id == 0x03930000)))\t// G5 X, G9 X\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\treturn;\n}\n\nvoid CLASS processNikonLensData (uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n  else\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n    {\n      if (imgdata.lens.nikon.NikonLensType & 0x04)\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n      else\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n      imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n    {\n      imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n      imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20) {\n    switch (len) {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n      {\n        if ((LensData[i - 1]) &&\n            (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n          imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n        if (LensData[i + 7]) imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n      }\n    imgdata.lens.makernotes.LensID =\n      (unsigned long long) LensData[i] << 56 |\n      (unsigned long long) LensData[i + 1] << 48 |\n      (unsigned long long) LensData[i + 2] << 40 |\n      (unsigned long long) LensData[i + 3] << 32 |\n      (unsigned long long) LensData[i + 4] << 24 |\n      (unsigned long long) LensData[i + 5] << 16 |\n      (unsigned long long) LensData[i + 6] << 8 |\n      (unsigned long long) imgdata.lens.nikon.NikonLensType;\n\n  }\n  else if ((len == 459) || (len == 590))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n    }\n  else if (len == 509)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n    }\n  else if (len == 879)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n    }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures (unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) ||\t// E-1\n      (id == 0x4434303431ULL) ||\t// E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n\t  if ((id == 0x4434303430ULL) ||\t// E-1\n      \t  (id == 0x4434303431ULL) ||\t// E-330\n      \t  ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n      \t  (id == 0x5330303233ULL) ||\t// E-620\n      \t  (id == 0x5330303239ULL) ||\t// E-450\n      \t  (id == 0x5330303330ULL) ||\t// E-600\n      \t  (id == 0x5330303333ULL))\t\t// E-5\n      {\n      \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n      }\n  \telse\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n      }\n  }\n  else\n  {\n      imgdata.lens.makernotes.LensMount =\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes (unsigned tag, unsigned type, unsigned len) {\n\nif (tag == 0x0001) Canon_CameraSettings();\n        else if (tag == 0x0002)\t\t\t// focal length\n          {\n            imgdata.lens.makernotes.FocalType = get2();\n            imgdata.lens.makernotes.CurFocal = get2();\n            if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n              {\n                imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n              }\n          }\n\n        else if (tag == 0x0004)\t\t\t// shot info\n          {\n            short tempAp;\n            fseek(ifp, 30, SEEK_CUR);\n            imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n            fseek(ifp, 8-32, SEEK_CUR);\n            if ((tempAp = get2()) != 0x7fff)\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n            if (imgdata.lens.makernotes.CurAp < 0.7f)\n            {\n              fseek(ifp, 32, SEEK_CUR);\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n            }\n            if (!aperture) aperture = imgdata.lens.makernotes.CurAp;\n          }\n\n        else if (tag == 0x0095 &&\t\t// lens model tag\n                 !imgdata.lens.makernotes.Lens[0])\n          {\n            fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            if (imgdata.lens.makernotes.Lens[0] < 65)\t\t\t\t\t// non-Canon lens\n              fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n            else\n              {\n                char efs[2];\n                imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n                imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n                fread(efs, 2, 1, ifp);\n                if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n                  {\t// \"EF-S, TS-E, MP-E, EF-M\" lenses\n                    imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n                    imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n                    imgdata.lens.makernotes.Lens[4] = 32;\n                    if (efs[1] == 83)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n                        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n                      }\n                    else if (efs[1] == 77)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n                      }\n                  }\n                else\n                  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \"EF\" lenses\n                    imgdata.lens.makernotes.Lens[2] = 32;\n                    imgdata.lens.makernotes.Lens[3] = efs[0];\n                    imgdata.lens.makernotes.Lens[4] = efs[1];\n                  }\n                fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n              }\n          }\n\n        else if (tag == 0x00a9)\n          {\n            long int save1 = ftell(ifp);\n            fseek (ifp, save1+(0x5<<1), SEEK_SET);\n            Canon_WBpresets(0,0);\n            fseek (ifp, save1, SEEK_SET);\n          }\n\n        else if (tag == 0x00e0)\t\t\t// sensor info\n          {\n            imgdata.makernotes.canon.SensorWidth           = (get2(),get2());\n            imgdata.makernotes.canon.SensorHeight          = get2();\n            imgdata.makernotes.canon.SensorLeftBorder      = (get2(),get2(),get2());\n            imgdata.makernotes.canon.SensorTopBorder       = get2();\n            imgdata.makernotes.canon.SensorRightBorder     = get2();\n            imgdata.makernotes.canon.SensorBottomBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskLeftBorder   = get2();\n            imgdata.makernotes.canon.BlackMaskTopBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskRightBorder  = get2();\n            imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n          }\n\n    else if (tag == 0x4001 && len > 500)\n      {\n        int c;\n        long int save1 = ftell(ifp);\n        switch (len)\n          {\n          case 582:\n            imgdata.makernotes.canon.CanonColorDataVer = 1;\t// 20D / 350D\n            {\n            \tfseek (ifp, save1+(0x23<<1), SEEK_SET);\n            \tCanon_WBpresets(2,2);\n            \tfseek (ifp, save1+(0x4b<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 653:\n            imgdata.makernotes.canon.CanonColorDataVer = 2;\t// 1Dmk2 / 1DsMK2\n            {\n            \tfseek (ifp, save1+(0x27<<1), SEEK_SET);\n            \tCanon_WBpresets(2,12);\n            \tfseek (ifp, save1+(0xa4<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 796:\n            imgdata.makernotes.canon.CanonColorDataVer = 3;\t// 1DmkIIN / 5D / 30D / 400D\n\t    imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n\t    {\n\t      fseek (ifp, save1+(0x4e<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0x85<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n\t      fseek (ifp, save1+(0x0c4<<1), SEEK_SET); // offset 196 short\n\t      int bls=0;\n\t      FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n\t      imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n\t    }\n\t    break;\n            // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n            // 7D / 40D / 50D / 60D / 450D / 500D\n            // 550D / 1000D / 1100D\n          case 674: case 692: case 702: case 1227: case 1250:\n          case 1251: case 1337: case 1338: case 1346:\n            imgdata.makernotes.canon.CanonColorDataVer = 4;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n\t      fseek (ifp, save1+(0x53<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0xa8<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0e7<<1), SEEK_SET); // offset 231 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4)\n                || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n              {\n                fseek (ifp, save1+(0x2b9<<1), SEEK_SET);\t\t// offset 697 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n                     (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n              {\n                fseek (ifp, save1+(0x2d0<<1), SEEK_SET);\t\t// offset 720 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n              {\n                fseek (ifp, save1+(0x2d4<<1), SEEK_SET);\t\t// offset 724 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n          case 5120:\n            imgdata.makernotes.canon.CanonColorDataVer = 5;\t// PowerSot G10, G12, G5 X, EOS M3, EOS M5\n            {\n              fseek (ifp, save1+(0x56<<1), SEEK_SET);\n              if ((unique_id == 0x03970000) || // G7 X Mark II\n                  (unique_id == 0x80000394))   // EOS M5\n              {\n                fseek(ifp, 18, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                fseek(ifp, 8, SEEK_CUR);\n                Canon_WBpresets(8,24);\n                fseek(ifp, 168, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n                fseek(ifp, 24, SEEK_CUR);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek(ifp, 6, SEEK_CUR);\n              }\n              else\n              {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                get2();\n                Canon_WBpresets(2,12);\n                fseek (ifp, save1+(0xba<<1), SEEK_SET);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek (ifp, save1+(0x108<<1), SEEK_SET);  // offset 264 short\n              }\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            break;\n\n          case 1273: case 1275:\n            imgdata.makernotes.canon.CanonColorDataVer = 6;\t// 600D / 1200D\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x67<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xbc<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0fb<<1), SEEK_SET);\t\t\t// offset 251 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            fseek (ifp, save1+(0x1e4<<1), SEEK_SET);\t\t\t// offset 484 shorts\n            imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n            FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n            break;\n\n            // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n          case 1312: case 1313: case 1316: case 1506:\n            imgdata.makernotes.canon.CanonColorDataVer = 7;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x80<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xd5<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x114<<1), SEEK_SET);\t\t\t// offset 276 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n              {\n                fseek (ifp, save1+(0x1fd<<1), SEEK_SET);\t\t// offset 509 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              } else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n              {\n                fseek (ifp, save1+(0x2dd<<1), SEEK_SET);\t\t// offset 733 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n            // 5DS / 5DS R / 80D / 1300D / 5D4\n          case 1560: case 1592: case 1353:\n            imgdata.makernotes.canon.CanonColorDataVer = 8;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x85<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0x107<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x146<<1), SEEK_SET);\t\t\t// offset 326 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n              if (imgdata.makernotes.canon.CanonColorDataSubVer == 14)  // 1300D\n                {\n                  fseek (ifp, save1+(0x231<<1), SEEK_SET);\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n              else\n                {\n                  fseek (ifp, save1+(0x30f<<1), SEEK_SET);\t\t// offset 783 shorts\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n            break;\n\n          }\n        fseek (ifp, save1, SEEK_SET);\n      }\n}\n\nvoid CLASS setPentaxBodyFeatures (unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id) {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO (ushort c)\n{\n  int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};\n  double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};\n#define numel (sizeof(code)/sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++) {\n    if (code[i] == c) {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel) iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo (unsigned id, unsigned len)\t// tag 0x0207\n{\n\tushort iLensData = 0;\n\tuchar *table_buf;\n\ttable_buf = (uchar*)malloc(MAX(len,128));\n\tfread(table_buf, len, 1, ifp);\n\tif ((id < 0x12b9c)  ||\n        (((id == 0x12b9c)   ||  // K100D\n          (id == 0x12b9d)   ||  // K110D\n          (id == 0x12ba2)) &&   // K100D Super\n\t\t ((!table_buf[20] ||\n\t\t  (table_buf[20] == 0xff)))))\n\t  {\n\t\tiLensData = 3;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t(((unsigned)table_buf[0]) << 8) + table_buf[1];\n\t  }\n\telse switch (len)\n\t  {\n\t  case 90:\t\t\t\t\t\t\t// LensInfo3\n\t\tiLensData = 13;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 91:\t\t\t\t\t\t\t// LensInfo4\n\t\tiLensData = 12;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 80:\t\t\t\t\t\t\t// LensInfo5\n\t  case 128:\n\t\tiLensData = 15;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) <<8) + table_buf[5];\n\t\tbreak;\n\t  default:\n\t\tif (id >= 0x12b9c)\t\t\t\t// LensInfo2\n\t\t  {\n\t\t\tiLensData = 4;\n\t\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t\t((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) <<8) + table_buf[3];\n\t\t  }\n\t  }\n\tif (iLensData)\n\t  {\n\t\tif (table_buf[iLensData+9] &&\n\t\t\t(fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n\t\t  imgdata.lens.makernotes.CurFocal =\n\t\t\t10*(table_buf[iLensData+9]>>2) * powf64(4, (table_buf[iLensData+9] & 0x03)-2);\n\t\tif (table_buf[iLensData+10] & 0xf0)\n\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0xf0) >>4)/4.0f);\n\t\tif (table_buf[iLensData+10] & 0x0f)\n\t\t  imgdata.lens.makernotes.MinAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0x0f) + 10)/4.0f);\n\n\t\tif (iLensData != 12)\n\t\t  {\n\t\t\tswitch (table_buf[iLensData] & 0x06)\n\t\t\t  {\n\t\t\t  case 0: imgdata.lens.makernotes.MinAp4MinFocal = 22.0f; break;\n\t\t\t  case 2: imgdata.lens.makernotes.MinAp4MinFocal = 32.0f; break;\n\t\t\t  case 4: imgdata.lens.makernotes.MinAp4MinFocal = 45.0f; break;\n\t\t\t  case 6: imgdata.lens.makernotes.MinAp4MinFocal = 16.0f; break;\n\t\t\t  }\n\t\t\tif (table_buf[iLensData] & 0x70)\n\t\t\t  imgdata.lens.makernotes.LensFStops =\n\t\t\t\t((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n\t\t\timgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData+3] & 0xf8);\n\t\t\timgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData+3] & 0x07);\n\n\t\t\tif ((table_buf[iLensData+14] > 1) &&\n\t\t\t\t(fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+14] & 0x7f) -1)/32.0f);\n\t\t  }\n\t\telse if ((id != 0x12e76) &&\t// K-5\n\t\t\t\t (table_buf[iLensData+15] > 1) &&\n\t\t\t\t (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t  {\n\t\t\timgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t  powf64(2.0f, (float)((table_buf[iLensData+15] & 0x7f) -1)/32.0f);\n\t\t  }\n\t  }\n\tfree(table_buf);\n\treturn;\n}\n\nvoid CLASS setPhaseOneFeatures (unsigned id) {\n\n  ushort i;\n  static const struct {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n    // Phase One section:\n    {1, \"Hasselblad V\"},\n    {10, \"PhaseOne/Mamiya\"},\n    {12, \"Contax 645\"},\n    {16, \"Hasselblad V\"},\n    {17, \"Hasselblad V\"},\n    {18, \"Contax 645\"},\n    {19, \"PhaseOne/Mamiya\"},\n    {20, \"Hasselblad V\"},\n    {21, \"Contax 645\"},\n    {22, \"PhaseOne/Mamiya\"},\n    {23, \"Hasselblad V\"},\n    {24, \"Hasselblad H\"},\n    {25, \"PhaseOne/Mamiya\"},\n    {32, \"Contax 645\"},\n    {34, \"Hasselblad V\"},\n    {35, \"Hasselblad V\"},\n    {36, \"Hasselblad H\"},\n    {37, \"Contax 645\"},\n    {38, \"PhaseOne/Mamiya\"},\n    {39, \"Hasselblad V\"},\n    {40, \"Hasselblad H\"},\n    {41, \"Contax 645\"},\n    {42, \"PhaseOne/Mamiya\"},\n    {44, \"Hasselblad V\"},\n    {45, \"Hasselblad H\"},\n    {46, \"Contax 645\"},\n    {47, \"PhaseOne/Mamiya\"},\n    {48, \"Hasselblad V\"},\n    {49, \"Hasselblad H\"},\n    {50, \"Contax 645\"},\n    {51, \"PhaseOne/Mamiya\"},\n    {52, \"Hasselblad V\"},\n    {53, \"Hasselblad H\"},\n    {54, \"Contax 645\"},\n    {55, \"PhaseOne/Mamiya\"},\n    {67, \"Hasselblad V\"},\n    {68, \"Hasselblad H\"},\n    {69, \"Contax 645\"},\n    {70, \"PhaseOne/Mamiya\"},\n    {71, \"Hasselblad V\"},\n    {72, \"Hasselblad H\"},\n    {73, \"Contax 645\"},\n    {74, \"PhaseOne/Mamiya\"},\n    {76, \"Hasselblad V\"},\n    {77, \"Hasselblad H\"},\n    {78, \"Contax 645\"},\n    {79, \"PhaseOne/Mamiya\"},\n    {80, \"Hasselblad V\"},\n    {81, \"Hasselblad H\"},\n    {82, \"Contax 645\"},\n    {83, \"PhaseOne/Mamiya\"},\n    {84, \"Hasselblad V\"},\n    {85, \"Hasselblad H\"},\n    {86, \"Contax 645\"},\n    {87, \"PhaseOne/Mamiya\"},\n    {99, \"Hasselblad V\"},\n    {100, \"Hasselblad H\"},\n    {101, \"Contax 645\"},\n    {102, \"PhaseOne/Mamiya\"},\n    {103, \"Hasselblad V\"},\n    {104, \"Hasselblad H\"},\n    {105, \"PhaseOne/Mamiya\"},\n    {106, \"Contax 645\"},\n    {112, \"Hasselblad V\"},\n    {113, \"Hasselblad H\"},\n    {114, \"Contax 645\"},\n    {115, \"PhaseOne/Mamiya\"},\n    {131, \"Hasselblad V\"},\n    {132, \"Hasselblad H\"},\n    {133, \"Contax 645\"},\n    {134, \"PhaseOne/Mamiya\"},\n    {135, \"Hasselblad V\"},\n    {136, \"Hasselblad H\"},\n    {137, \"Contax 645\"},\n    {138, \"PhaseOne/Mamiya\"},\n    {140, \"Hasselblad V\"},\n    {141, \"Hasselblad H\"},\n    {142, \"Contax 645\"},\n    {143, \"PhaseOne/Mamiya\"},\n    {148, \"Hasselblad V\"},\n    {149, \"Hasselblad H\"},\n    {150, \"Contax 645\"},\n    {151, \"PhaseOne/Mamiya\"},\n    {160, \"A-250\"},\n    {161, \"A-260\"},\n    {162, \"A-280\"},\n    {167, \"Hasselblad V\"},\n    {168, \"Hasselblad H\"},\n    {169, \"Contax 645\"},\n    {170, \"PhaseOne/Mamiya\"},\n    {172, \"Hasselblad V\"},\n    {173, \"Hasselblad H\"},\n    {174, \"Contax 645\"},\n    {175, \"PhaseOne/Mamiya\"},\n    {176, \"Hasselblad V\"},\n    {177, \"Hasselblad H\"},\n    {178, \"Contax 645\"},\n    {179, \"PhaseOne/Mamiya\"},\n    {180, \"Hasselblad V\"},\n    {181, \"Hasselblad H\"},\n    {182, \"Contax 645\"},\n    {183, \"PhaseOne/Mamiya\"},\n    {208, \"Hasselblad V\"},\n    {211, \"PhaseOne/Mamiya\"},\n    {448, \"Phase One 645AF\"},\n    {457, \"Phase One 645DF\"},\n    {471, \"Phase One 645DF+\"},\n    {704, \"Phase One iXA\"},\n    {705, \"Phase One iXA - R\"},\n    {706, \"Phase One iXU 150\"},\n    {707, \"Phase One iXU 150 - NIR\"},\n    {708, \"Phase One iXU 180\"},\n    {721, \"Phase One iXR\"},\n    // Leaf section:\n    {333,\"Mamiya\"},\n    {329,\"Universal\"},\n    {330,\"Hasselblad H1/H2\"},\n    {332,\"Contax\"},\n    {336,\"AFi\"},\n    {327,\"Mamiya\"},\n    {324,\"Universal\"},\n    {325,\"Hasselblad H1/H2\"},\n    {326,\"Contax\"},\n    {335,\"AFi\"},\n    {340,\"Mamiya\"},\n    {337,\"Universal\"},\n    {338,\"Hasselblad H1/H2\"},\n    {339,\"Contax\"},\n    {323,\"Mamiya\"},\n    {320,\"Universal\"},\n    {322,\"Hasselblad H1/H2\"},\n    {321,\"Contax\"},\n    {334,\"AFi\"},\n    {369,\"Universal\"},\n    {370,\"Mamiya\"},\n    {371,\"Hasselblad H1/H2\"},\n    {372,\"Contax\"},\n    {373,\"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0]) {\n    for (i=0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id) {\n        strcpy(imgdata.lens.makernotes.body,p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes (unsigned tag, unsigned type) {\n      switch (tag) {\n      case 0x1002: imgdata.makernotes.fuji.WB_Preset = get2(); break;\n      case 0x1011: imgdata.other.FlashEC = getreal(type); break;\n      case 0x1020: imgdata.makernotes.fuji.Macro = get2(); break;\n      case 0x1021: imgdata.makernotes.fuji.FocusMode = get2(); break;\n      case 0x1022: imgdata.makernotes.fuji.AFMode = get2(); break;\n      case 0x1023: imgdata.makernotes.fuji.FocusPixel[0] = get2();\n                   imgdata.makernotes.fuji.FocusPixel[1] = get2();\n      break;\n      case 0x1034: imgdata.makernotes.fuji.ExrMode = get2(); break;\n      case 0x1050: imgdata.makernotes.fuji.ShutterType = get2(); break;\n      case 0x1400: imgdata.makernotes.fuji.FujiDynamicRange = get2(); break;\n      case 0x1401: imgdata.makernotes.fuji.FujiFilmMode = get2(); break;\n      case 0x1402: imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2(); break;\n      case 0x1403: imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2(); break;\n      case 0x140b: imgdata.makernotes.fuji.FujiAutoDynamicRange = get2(); break;\n      case 0x1404: imgdata.lens.makernotes.MinFocal = getreal(type); break;\n      case 0x1405: imgdata.lens.makernotes.MaxFocal = getreal(type); break;\n      case 0x1406: imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type); break;\n      case 0x1407: imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type); break;\n      case 0x1422: imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n                   imgdata.shootinginfo.ImageStabilization = (imgdata.makernotes.fuji.ImageStabilization[0]<<9) + imgdata.makernotes.fuji.ImageStabilization[1];\n      break;\n      case 0x1431: imgdata.makernotes.fuji.Rating = get4(); break;\n      case 0x3820: imgdata.makernotes.fuji.FrameRate = get2(); break;\n      case 0x3821: imgdata.makernotes.fuji.FrameWidth = get2(); break;\n      case 0x3822: imgdata.makernotes.fuji.FrameHeight = get2(); break;\n      }\nreturn;\n}\n\nvoid CLASS setSonyBodyFeatures (unsigned id) {\n\n  imgdata.lens.makernotes.CamID = id;\n  if (\t// FF cameras\n      (id == 257) ||\t\t// a900\n      (id == 269) ||\t\t// a850\n      (id == 340) ||\t\t// ILCE-7M2\n      (id == 318) ||\t\t// ILCE-7S\n      (id == 350) ||\t\t// ILCE-7SM2\n      (id == 311) ||\t\t// ILCE-7R\n      (id == 347) ||\t\t// ILCE-7RM2\n      (id == 306) ||\t\t// ILCE-7\n      (id == 298) ||\t\t// DSC-RX1\n      (id == 299) ||\t\t// NEX-VG900\n      (id == 310) ||\t\t// DSC-RX1R\n      (id == 344) ||\t\t// DSC-RX1RM2\n      (id == 354) ||\t\t// ILCA-99M2\n      (id == 294)\t\t// SLT-99, Hasselblad HV\n      )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n  else if ((id == 297) ||  // DSC-RX100\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n         )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n    }\n\n  else if (id != 002)     // DSC-R1\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    }\n\n  if      (               // E-mount cameras, ILCE series\n           (id == 302) ||\n           (id == 306) ||\n           (id == 311) ||\n           (id == 312) ||\n           (id == 313) ||\n           (id == 318) ||\n           (id == 339) ||\n           (id == 340) ||\n           (id == 346) ||\n           (id == 347) ||\n           (id == 350) ||\n           (id == 360)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n    }\n  else if (               // E-mount cameras, NEX series\n           (id == 278) ||\n           (id == 279) ||\n           (id == 284) ||\n           (id == 288) ||\n           (id == 289) ||\n           (id == 290) ||\n           (id == 293) ||\n           (id == 295) ||\n           (id == 296) ||\n           (id == 299) ||\n           (id == 300) ||\n           (id == 305) ||\n           (id == 307)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n    }\n\n  else if (\t// A-mount cameras, DSLR series\n           (id == 256) ||\n           (id == 257) ||\n           (id == 258) ||\n           (id == 259) ||\n           (id == 260) ||\n           (id == 261) ||\n           (id == 262) ||\n           (id == 263) ||\n           (id == 264) ||\n           (id == 265) ||\n           (id == 266) ||\n           (id == 269) ||\n           (id == 270) ||\n           (id == 273) ||\n           (id == 274) ||\n           (id == 275) ||\n           (id == 282) ||\n           (id == 283)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n    }\n  else if (\t// A-mount cameras, SLT series\n           (id == 280) ||\n           (id == 281) ||\n           (id == 285) ||\n           (id == 286) ||\n           (id == 287) ||\n           (id == 291) ||\n           (id == 292) ||\n           (id == 294) ||\n           (id == 303)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n    }\n  else if (\t// A-mount cameras, ILCA series\n           (id == 319)  ||\n           (id == 353)  ||\n           (id == 354)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n    }\n\n  else if (\t// DSC\n           (id == 002) ||  // DSC-R1\n           (id == 297) ||  // DSC-RX100\n           (id == 298) ||  // DSC-RX1\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 310) ||  // DSC-RX1R\n           (id == 344) ||  // DSC-RX1RM2\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n           )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n    }\n  return;\n}\n\nvoid CLASS parseSonyLensType2 (uchar a, uchar b) {\n  ushort lid2;\n  lid2 = (((ushort)a)<<8) | ((ushort)b);\n  if (!lid2) return;\n  if (lid2 < 0x100)\n    {\n      if ((imgdata.lens.makernotes.AdapterID != 0x4900) &&\n          (imgdata.lens.makernotes.AdapterID != 0xEF00))\n      {\n        imgdata.lens.makernotes.AdapterID = lid2;\n        switch (lid2) {\n        case 1:\n        case 2:\n        case 3:\n        case 6:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n        case 44:\n        case 78:\n        case 239:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n        }\n      }\n    }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n    {\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n    }\n  return;\n}\n\n#define strnXcat(buf,string) strncat(buf,string,LIM(sizeof(buf)-strbuflen(buf)-1,0,sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures (uchar a, uchar b) {\n\n  ushort features;\n  features = (((ushort)a)<<8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) ||\n      !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100)) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n    {\n  \t  imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n  \t  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n  \t  if ((features & 0x0200) && (features & 0x0100)) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0200) {\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0100) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t  }\n    }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\" );\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf+1,\n\t    strbuflen(imgdata.lens.makernotes.LensFeatures_suf)-1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c (uchar * buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n    {\n      switch (SonySubstitution[buf[0x0008]]) {\n      case 1:\n      case 5:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 4:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n        break;\n      }\n    }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |\n    ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2 (SonySubstitution[buf[0x000a]],\t// LensType2 - Sony lens ids\n                        SonySubstitution[buf[0x0009]]);\n  return;\n}\n\n\nvoid CLASS process_Sony_0x9050 (uchar * buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n    {\n      if (buf[0])\n        imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n\n      if (buf[1])\n        imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n    }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    {\n      if (buf[0x3d] | buf[0x3c])\n        {\n          lid = SonySubstitution[buf[0x3d]] << 8 |\n            SonySubstitution[buf[0x3c]];\n          imgdata.lens.makernotes.CurAp =\n            powf64(2.0f, ((float)lid/256.0f - 16.0f) / 2.0f);\n        }\n      if (buf[0x105] &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n        imgdata.lens.makernotes.LensMount =\n          SonySubstitution[buf[0x105]];\n      if (buf[0x106])\n        imgdata.lens.makernotes.LensFormat =\n          SonySubstitution[buf[0x106]];\n    }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n    {\n      parseSonyLensType2 (SonySubstitution[buf[0x0108]],\t\t// LensType2 - Sony lens ids\n                          SonySubstitution[buf[0x0107]]);\n    }\n  if ((imgdata.lens.makernotes.LensID == -1) &&\n      (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n    {\n      imgdata.lens.makernotes.LensID =\t\t // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 |\n        SonySubstitution[buf[0x0109]];\n\n      if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n          (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n      else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n          (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n          (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n    }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures (SonySubstitution[buf[0x115]],\n                           SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long long b88 = SonySubstitution[buf[0x88]];\n    unsigned long long b89 = SonySubstitution[buf[0x89]];\n    unsigned long long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06llx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05llx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") ||\n           !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG))) {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) ||\n           !strcmp(buf, \"Panasonic\")) {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8)) {\n    base = ftell(ifp) - 10;\n  nf: order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") ||\n           !strcmp(buf, \"LEICA\") ||\n           !strcmp(buf, \"Ricoh\") ||\n           !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") ||\n           !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) &&\n\t\t\t\t(dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if(len > 8 && pos+len > 2* fsize) continue;\n    tag |= uptag << 16;\n    if(len > 100*1024*1024) goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000) // camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t // Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes (tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len,ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n      {\n        if (tag == 0x1d)\t\t\t\t\t\t\t// serial number\n          while ((c = fgetc(ifp)) && c != EOF)\n          {\n            if ((!custom_serial) && (!isdigit(c)))\n            {\n              if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n              {\n                custom_serial = 34;\n              }\n              else\n              {\n                custom_serial = 96;\n              }\n            }\n            serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n          }\n        else if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0097)\n          {\n            for (i=0; i < 4; i++)\n\t            ver97 = ver97 * 10 + fgetc(ifp)-'0';\n\t          if (ver97 == 601)  // Coolpix A\n\t          {\n\t            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n\t          }\n\t        }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n\n        else if (tag == 0xa7)\t\t\t\t\t// shutter count\n          {\n            NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n            if ((NikonLensDataVersion > 200) && lenNikonLensData)\n            {\n              if (custom_serial)\n              {\n                ci = xlat[0][custom_serial];\n              }\n              else\n              {\n                ci = xlat[0][serial & 0xff];\n              }\n              cj = xlat[1][NikonKey];\n              ck = 0x60;\n              for (i = 0; i < lenNikonLensData; i++)\n                table_buf[i] ^= (cj += ci * ck++);\n              processNikonLensData(table_buf, lenNikonLensData);\n              lenNikonLensData = 0;\n              free(table_buf);\n            }\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n\n        else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n          {\n            unsigned char cc;\n            fread(&cc, 1, 1, ifp);\n            iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n            break;\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        int SubDirOffsetValid =\n              strncmp (model, \"E-300\", 5) &&\n              strncmp (model, \"E-330\", 5) &&\n              strncmp (model, \"E-400\", 5) &&\n              strncmp (model, \"E-500\", 5) &&\n              strncmp (model, \"E-1\", 3);\n\n        if ((tag == 0x2010) || (tag == 0x2020))\n          {\n            fseek(ifp, save - 4, SEEK_SET);\n            fseek(ifp, base + get4(), SEEK_SET);\n            parse_makernote_0xc634(base, tag, dng_writer);\n          }\n        if (!SubDirOffsetValid &&\n            ((len > 4) ||\n             ( ((type == 3) || (type == 8)) && (len > 2))  ||\n             ( ((type == 4) || (type == 9)) && (len > 1))  || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n        switch (tag) {\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20100102:\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x20100201:\n          imgdata.lens.makernotes.LensID =\n            (unsigned long long)fgetc(ifp)<<16 |\n            (unsigned long long)(fgetc(ifp), fgetc(ifp))<<8 |\n            (unsigned long long)fgetc(ifp);\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          if ((!imgdata.lens.LensSerial[0]))\n              stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens,len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment,len, ifp);\n          break;\n        case 0x20200401:\n\t      imgdata.other.FlashEC = getreal(type);\n\t      break;\n        }\n        skip_Oly_broken_tags:;\n      }\n\n    else if (!strncmp(make, \"PENTAX\", 6) ||\n             !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n               PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t     for (int i = 0; i < nWB; i++)\n\t       {\n\t\t imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\t fseek(ifp, 2, SEEK_CUR);\n\t\t imgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\t imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\t imgdata.color.WBCT_Coeffs[i][3] = get2();\n        \t}\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 12, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) &&\n             (dng_writer == AdobeDNG))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            imgdata.lens.makernotes.CamID = unique_id = get4();\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n          {\n            unique_id = get2();\n            setSonyBodyFeatures(unique_id);\n            if (table_buf_0x9050_present)\n              {\n                process_Sony_0x9050(table_buf_0x9050, unique_id);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n            if (table_buf_0x940c_present)\n              {\n                if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                  {\n                    process_Sony_0x940c(table_buf_0x940c);\n                  }\n                free (table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n\n                  // a450, a500, a550, a560, a580\n                  // a33, a35, a55\n                  // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len) {\n                case 368:\n                case 5478:\n                  // a700, a850, a900: CameraInfo\n                  if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n                    {\n                      if (table_buf[0] | table_buf[3])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                      if (table_buf[2] | table_buf[5])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    }\n                  break;\n                default:\n                  // CameraInfo2 & 3\n                  if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n                    {\n                      if (table_buf[1] | table_buf[2])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                      if (table_buf[3] | table_buf[4])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                      if (table_buf[5])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                      if (table_buf[6])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                    }\n                }\n              }\n            free(table_buf);\n          }\n\n\t\telse if (tag == 0x0104)\n\t\t  {\n\t\t    imgdata.other.FlashEC = getreal(type);\n\t\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 65535)\t\t\t\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len < 256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n              {\n                if (table_buf[1] | table_buf[2])\n                  imgdata.lens.makernotes.MinFocal =\n                    bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                if (table_buf[3] | table_buf[4])\n                  imgdata.lens.makernotes.MaxFocal =\n                    bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                if (table_buf[5])\n                  imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                if (table_buf[6])\n                  imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                parseSonyLensFeatures(table_buf[0], table_buf[7]);\n              }\n            free(table_buf);\n          }\n      }\n  next:\n    fseek (ifp, save, SEEK_SET);\n  }\n quit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  /*placeholder */\n}\n#endif\n\n\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strncmp(make,\"Nokia\",5)) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\") ||\n             !strcmp (buf,\"PENTAX \")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n             !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\n\tnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n             !strcmp (buf,\"LEICA\") ||\n             !strcmp (buf,\"Ricoh\") ||\n             !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n           !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (!strncmp(model, \"M8\", 2) ||\n          !strncasecmp(model, \"Leica M8\", 8) ||\n          !strncasecmp(model, \"LEICA X\", 7))\n        {\n          base = ftell(ifp)-8;\n        }\n      else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n        {\n          base = 0;\n        }\n      else if (!strncmp(model, \"M9\", 2) ||\n               !strncasecmp(model, \"Leica M9\", 8) ||\n               !strncasecmp(model, \"M Monochrom\", 11) ||\n               !strncasecmp(model, \"Leica M Monochrom\", 11))\n        {\n          if (!uptag)\n            {\n              base = ftell(ifp) - 10;\n              fseek (ifp, 8, SEEK_CUR);\n            }\n          else if (uptag == 0x3400)\n            {\n              fseek (ifp, 10, SEEK_CUR);\n              base += 10;\n            }\n        }\n      else if (!strncasecmp(model, \"LEICA T\", 7))\n      \t{\n      \t  base = ftell(ifp)-8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n      \t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (!strncasecmp(model, \"LEICA SL\", 8))\n      \t{\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      \t  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n      \t}\n#endif\n    }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if(len > 8 && _pos+len > 2* fsize) continue;\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000)\t// camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t// Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4)) {\n      if (tag == 0x0010) {\n         char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n         char *words[4];\n         char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n         int year, nwords, ynum_len;\n         unsigned c;\n         stmread(FujiSerial, len, ifp);\n         nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n         for (int i = 0; i < nwords; i++) {\n           mm[2] = dd[2] = 0;\n           if (strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1) < 18)\n              if (i == 0)\n\t         strncpy (imgdata.shootinginfo.InternalBodySerial,\n\t\t \twords[0],\n\t\t\tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n              else\n\t      {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t       snprintf (tbuf, sizeof(tbuf), \"%s %s\",\n\t            imgdata.shootinginfo.InternalBodySerial, words[i]);\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n\t       }\n           else\n           {\n             strncpy (dd, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-14, 2);\n             strncpy (mm, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-16, 2);\n             strncpy (yy, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18, 2);\n             year = (yy[0]-'0')*10 + (yy[1]-'0');\n             if (year <70) year += 2000; else year += 1900;\n\n             ynum_len = (int)strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18;\n             strncpy(ynum, words[i], ynum_len);\n             ynum[ynum_len] = 0;\n             for ( int j = 0; ynum[j] && ynum[j+1] && sscanf(ynum+j, \"%2x\", &c); j += 2) ystr[j/2] = c;\n             ystr[ynum_len / 2 + 1] = 0;\n             strcpy (model2, ystr);\n\n             if (i == 0) {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n               if (nwords == 1)\n\t\t   snprintf (tbuf,sizeof(tbuf),\n\t\t\t   \"%s %s %d:%s:%s\",\n\t\t\t   words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12,\n\t\t\t\tystr, year, mm, dd);\n\n               else\n\t\t snprintf (tbuf,sizeof(tbuf),\n\t\t\t    \"%s %d:%s:%s %s\",\n\t\t\t    ystr, year, mm, dd,\n\t\t\t    words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n             } else {\n\t\tchar tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t        snprintf (tbuf, sizeof(tbuf),\n\t\t\"%s %s %d:%s:%s %s\",\n\t\timgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,\n\t\t words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\t\t strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t\t \tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n      \t     }\n           }\n         }\n      }\n      else\n\tparseFujiMakernotes (tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                 )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\",5))\n      {\n        if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0012)\n          {\n            char a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c) imgdata.other.FlashEC = (float)(a*b)/(float)c;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData>0)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n        else if (tag == 0x00a0)\n          {\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        switch (tag) {\n        case 0x0404:\n        case 0x101a:\n        case 0x20100101:\n          if (!imgdata.shootinginfo.BodySerial[0])\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n        case 0x20100102:\n          if (!imgdata.shootinginfo.InternalBodySerial[0])\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20401112:\n          imgdata.makernotes.olympus.OlympusCropID = get2();\n          break;\n        case 0x20401113:\n          FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n          break;\n        case 0x20100201:\n          {\n            unsigned long long oly_lensid [3];\n            oly_lensid[0] = fgetc(ifp);\n            fgetc(ifp);\n            oly_lensid[1] = fgetc(ifp);\n            oly_lensid[2] = fgetc(ifp);\n            imgdata.lens.makernotes.LensID =\n              (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n          }\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          break;\n        }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) &&\n             !strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n    \t  {\n    \t     char buffer[17];\n    \t     int count=0;\n    \t     fread(buffer, 16, 1, ifp);\n    \t     buffer[16] = 0;\n    \t     for (int i=0; i<16; i++)\n    \t     {\n//    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n    \t        if ((isspace(buffer[i])) ||\n    \t            (buffer[i] == 0x2D) ||\n    \t            (isalnum(buffer[i])))\n    \t        count++;\n    \t     }\n    \t     if (count == 16)\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%8s\", buffer+8);\n    \t        buffer[8] = 0;\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t     }\n    \t     else\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10], buffer[11]);\n    \t     }\n    \t  }\n        else if ((tag == 0x1001) && (type == 3))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            imgdata.lens.makernotes.LensID = -1;\n            imgdata.lens.makernotes.FocalType = 1;\n          }\n\n        else if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n        else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n      }\n\n    else if (!strncmp(make, \"RICOH\", 5) &&\n             strncmp(model, \"PENTAX\", 6))\n      {\n    \tif ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n    \t  {\n    \t     char buffer[9];\n    \t     buffer[8] = 0;\n    \t     fread(buffer, 8, 1, ifp);\n    \t     sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t  }\n\n    \telse if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n          else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n\n        else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n          {\n            short ntags, cur_tag;\n            fseek(ifp, 20, SEEK_CUR);\n            ntags = get2();\n            cur_tag = get2();\n            while (cur_tag != 0x002c)\n              {\n                fseek(ifp, 10, SEEK_CUR);\n                cur_tag = get2();\n              }\n            fseek(ifp, 6, SEEK_CUR);\n            fseek(ifp, get4()+20, SEEK_SET);\n            stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n            get2();\n            imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n            switch(imgdata.lens.makernotes.LensID) {\n              case 1:\n              case 2:\n              case 3:\n              case 5:\n              case 6:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            \timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n              break;\n              case 8:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            \timgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            \timgdata.lens.makernotes.LensID = -1;\n              break;\n              default:\n            \timgdata.lens.makernotes.LensID = -1;\n            }\n            fseek(ifp, 17, SEEK_CUR);\n            stread(imgdata.lens.LensSerial, 12, ifp);\n          }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) ||\n              !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n            \tPentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t    for (int i = 0; i < nWB; i++)\n\t      {\n\t\timgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\tfseek(ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\timgdata.color.WBCT_Coeffs[i][3] = get2();\n\t      }\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 2, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            unique_id = imgdata.lens.makernotes.CamID = get4();\n          }\n         else if (tag == 0xa002)\n          {\n             stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n        {\n          unique_id = get2();\n          setSonyBodyFeatures(unique_id);\n          if (table_buf_0x9050_present)\n            {\n              process_Sony_0x9050(table_buf_0x9050, unique_id);\n              free (table_buf_0x9050);\n              table_buf_0x9050_present = 0;\n            }\n          if (table_buf_0x940c_present)\n            {\n              if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                {\n                  process_Sony_0x940c(table_buf_0x940c);\n                }\n              free (table_buf_0x940c);\n              table_buf_0x940c_present = 0;\n            }\n        }\n\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n                  \t\t\t\t// a450, a500, a550, a560, a580\n                  \t\t\t\t// a33, a35, a55\n                  \t\t\t\t// NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len)\n                  {\n                  case 368:\n                  case 5478:\n                    // a700, a850, a900: CameraInfo\n                    if (table_buf[0] | table_buf[3])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                    if (table_buf[2] | table_buf[5])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    break;\n                  default:\n                    // CameraInfo2 & 3\n                    if (table_buf[1] | table_buf[2])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                    if (table_buf[3] | table_buf[4])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                    if (table_buf[5])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                    if (table_buf[6])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                }\n              }\n            free(table_buf);\n          }\n\n        else if ((tag == 0x0020) &&\t\t\t\t// WBInfoA100, needs 0xb028 processing\n                 !strncasecmp(model, \"DSLR-A100\", 9))\n\t  {\n\t    fseek(ifp,0x49dc,SEEK_CUR);\n\t    stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n\t  }\n\n\telse if (tag == 0x0104)\n\t  {\n\t    imgdata.other.FlashEC = getreal(type);\n\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 256000)\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len <256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal =\n                bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal =\n                bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            free(table_buf);\n          }\n      }\n\n    fseek(ifp,_pos,SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 37 && strstr(make,\"NIKON\") && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc,1,1,ifp);\n        iso_speed = int(100.0 * powf64(2.0f,float(cc)/12.0-5.0));\n      }\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n\tiso_speed = 50 * powf64(2.0, i/32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = powf64(2.0, i/64.0);\n#endif\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = powf64(2.0, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make,\"Canon\",5))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4) unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n\tif (!strncasecmp(make,\"Olympus\",7))\n\t{\n\t  short nWB, tWB;\n\t  if ((tag == 0x20300108) || (tag == 0x20310109))\n\t      imgdata.makernotes.olympus.ColorSpace = get2();\n\n\t  if ((tag == 0x20400102) && (len == 2) &&\n\t      (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n\t    {\n\t      int i;\n\t      for (i=0; i<64; i++)\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] =\n\t\t  imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t      for (i=64; i<256; i++)\n\t\timgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t    }\n\t  if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n\t    {\n\t      ushort CT;\n\t      nWB = tag-0x20400102;\n\t      switch (nWB)\n\t\t{\n                case 0 : CT = 3000; tWB = LIBRAW_WBI_Tungsten; break;\n\t\tcase 1 : CT = 3300; tWB = 0x100; break;\n\t\tcase 2 : CT = 3600; tWB = 0x100; break;\n\t\tcase 3 : CT = 3900; tWB = 0x100; break;\n                case 4 : CT = 4000; tWB = LIBRAW_WBI_FL_W; break;\n\t\tcase 5 : CT = 4300; tWB = 0x100; break;\n                case 6 : CT = 4500; tWB = LIBRAW_WBI_FL_D; break;\n\t\tcase 7 : CT = 4800; tWB = 0x100; break;\n                case 8 : CT = 5300; tWB = LIBRAW_WBI_FineWeather; break;\n                case 9 : CT = 6000; tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: CT = 6600; tWB = LIBRAW_WBI_FL_N; break;\n                case 11: CT = 7500; tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: CT = 0; tWB = 0x100;\n\t\t}\n\t      if (CT)\n\t\t{\n\t\t  imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n\t\t  imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n\t\t  imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n\t\t  if (len == 4)\n\t\t    {\n\t\t      imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n\t\t      imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t\t    }\n\t\t}\n\t      if (tWB != 0x100)\n\t\tFORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c+1];\n\t    }\n\t  if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n\t    {\n\t      nWB = tag-0x20400113;\n\t      imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t      switch (nWB)\n\t\t{\n                case 0:  tWB = LIBRAW_WBI_Tungsten; break;\n                case 4:  tWB = LIBRAW_WBI_FL_W; break;\n                case 6:  tWB = LIBRAW_WBI_FL_D; break;\n                case 8:  tWB = LIBRAW_WBI_FineWeather; break;\n                case 9:  tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: tWB = LIBRAW_WBI_FL_N; break;\n                case 11: tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: tWB = 0x100;\n\t\t}\n\t      if (tWB != 0x100)\n\t\timgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] =\n\t\t  imgdata.color.WBCT_Coeffs[nWB][2];\n\t    }\n\n\t  if (tag == 0x20400121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n\t      if (len == 4)\n\t\t{\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t\t}\n\t    }\n\t  if (tag == 0x2040011f)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t    }\n\t  if (tag == 0x30000120)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n\t      if (len == 2)\n\t\t{\n\t\t  for (int i=0; i<256; i++)\n\t\t    imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t\t}\n\t    }\n\t  if (tag == 0x30000121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n\t    }\n\t  if (tag == 0x30000122)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n\t    }\n\t  if (tag == 0x30000123)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n\t    }\n\t  if (tag == 0x30000124)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n\t    }\n\t  if (tag == 0x30000130)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n\t    }\n\t  if (tag == 0x30000131)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n\t    }\n\t  if (tag == 0x30000132)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n\t    }\n\t  if (tag == 0x30000133)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n\t    }\n\n\t  if((tag == 0x20400805) && (len == 2))\n\t    {\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[0]=getreal(type);\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[1]=getreal(type);\n\t      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n\t    }\n\t  if (tag == 0x20200401)\n\t    {\n\t      imgdata.other.FlashEC = getreal(type);\n\t    }\n\t}\n    fseek(ifp,_pos2,SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d) {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1) {  // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  FORC4 cam_mul[c ^ (c >> 1)] = get2();\n\t  break;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7) {\t// shutter count\n      NikonKey = fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp);\n        if ( (unsigned) (ver97-200) < 17) {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i=0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n          sget2 (buf97 + (i & -2) + c*2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601)  // Coolpix A\n    \t{\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    \t}\n#endif\n    }\n\n    if(tag == 0xb001 && type == 3)\t// Sony ModelID\n      {\n        unique_id = get2();\n      }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n         FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make,\"NIKON\") && len == 4)\n      {\n        FORC4 cblack[c ^ c >> 1] = get2();\n        i = cblack[3];\n        FORC3 if(i>cblack[c]) i = cblack[c];\n        FORC4 cblack[c]-=i;\n        black += i;\n      }\n#endif\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tint loopc = 0;\n#endif\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(loopc++>1024)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n          for (i=0; i < 3; i++)\n\t  {\n#ifdef LIBRAW_LIBRARY_BUILD\n           if (!imgdata.makernotes.olympus.ColorSpace)\n\t   {\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n\t   }\n           else\n\t   {\n            FORC3 imgdata.color.ccm[i][c] = ((short) get2()) / 256.0;\n\t   }\n#else\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n#endif\n          }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek (ifp, get4()+base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    if (tag == 0x2010)\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, 0x2010);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n\n    if (\n         ((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) &&\n         ((type == 7) || (type == 13)) &&\n         !strncasecmp(make,\"Olympus\",7)\n       )\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, tag);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf,\"OLYMP\",5))\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i+=18; i <= len; i+=10) {\n      \tget2();\n      \tFORC4 sraw_mul[c ^ (c >> 1)] = get2();\n      \tif (sraw_mul[1] == 1170) break;\n      }\n    }\n    if(!strncasecmp(make,\"Samsung\",7))\n      {\n        if (tag == 0xa020) // get the full Samsung encryption key\n            for (i=0; i<11; i++) SamsungKey[i] = get4();\n        if (tag == 0xa021) // get and decode Samsung cam_mul array\n            FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 0xa023)\n          {\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n              }\n          }\n        if (tag == 0xa024)\n          {\n            FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c+1];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n              }\n          }\n        if (tag == 0xa025)\n           imgdata.color.linear_max[0]=\n             imgdata.color.linear_max[1]=\n             imgdata.color.linear_max[2]=\n             imgdata.color.linear_max[3]= get4() - SamsungKey[0];\n        if (tag == 0xa030 && len == 9)\n            for (i=0; i < 3; i++)\n              FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n#endif\n        if (tag == 0xa031 && len == 9)\t// get and decode Samsung color matrix\n            for (i=0; i < 3; i++)\n              FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n\n        if (tag == 0xa028)\n          FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n      }\n    else\n      {\n        // Somebody else use 0xa021 and 0xa028?\n        if (tag == 0xa021)\n          FORC4 cam_mul[c ^ (c >> 1)] = get4();\n        if (tag == 0xa028)\n          FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n      }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo,ape;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && savepos + len > fsize*2) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n    switch (tag) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n      case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t   shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;  // 0x829d FNumber\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 34866:\n        if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\",4) || !strncasecmp(make, \"CANON\",5)))\n          iso_speed = getreal(type);\n        break;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)\n\t\t     tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t\tshutter = powf64(2.0, expo);\n\t\tbreak;\n      case 37378:                                       // 0x9202 ApertureValue\n        if ((fabs(ape = getreal(type))<256.0) && (!aperture))\n          aperture = powf64(2.0, ape/2);\n        break;\n      case 37385:  flash_used = getreal(type);          break;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  \t                         // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n       if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n         char mn_text[512];\n         char* pos;\n         char ccms[512];\n         ushort l;\n         float num;\n\n         fgets(mn_text, len, ifp);\n         pos = strstr(mn_text, \"gain_r=\");\n         if (pos) cam_mul[0] = atof(pos+7);\n         pos = strstr(mn_text, \"gain_b=\");\n         if (pos) cam_mul[2] = atof(pos+7);\n         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n         else cam_mul[0] = cam_mul[2] = 0.0f;\n\n         pos = strstr(mn_text, \"ccm=\") + 4;\n         l = strstr(pos, \" \") - pos;\n         memcpy (ccms, pos, l);\n         ccms[l] = '\\0';\n\n         pos = strtok (ccms, \",\");\n         for (l=0; l<4; l++) {\n           num = 0.0;\n           for (c=0; c<3; c++) {\n             imgdata.color.ccm[l][c] = (float)atoi(pos);\n             num += imgdata.color.ccm[l][c];\n             pos = strtok (NULL, \",\");\n           }\n           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n         }\n       }\n       else\n#endif\n        parse_makernote (base, 0);\n       break;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n  \treturn;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--) {\n    tiff_get(base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n    case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;\n    case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;\n    case 5:  imgdata.other.parsed_gps.altref = getc(ifp); break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9: imgdata.other.parsed_gps.gpsstatus = getc(ifp); break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"AFi-II 7\",\"Aptus-II 7\",\"\",\"Aptus-II 6\",\"\",\"\",\"Aptus-II 10\",\"Aptus-II 5\",\n    \"\",\"\",\"\",\"\",\"Aptus-II 10R\",\"Aptus-II 8\",\"\",\"Aptus-II 12\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data,\"CameraObj_camera_type\")) {\n\tstmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data,\"back_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.BodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));\n       strcpy (imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data,\"CaptProf_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n       strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n// IB end\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\t((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x10000) len = 0x10000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x10000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[len<0x1000?0xfff:len-1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags (int wb, unsigned type)\n{\n\tfloat mul[3]={1,1,1}, num, mul2;\n\tint c;\n\tFORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n\timgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n\tmul2 = mul[1] * mul[1];\n\timgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n\timgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n\treturn;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  INT64 fsize = ifp->size();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > 2*fsize) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n    if (tag == 1011) imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());\n      wbi = -2;\n    }\n\n    if (tag == 0x0848) Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849) Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a) Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b) Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93) imgdata.color.linear_max[0] =\n                         imgdata.color.linear_max[1] =\n                         imgdata.color.linear_max[2] =\n                         imgdata.color.linear_max[3] = get2();\n        if (tag == 0x09ce)\n\t\tstmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);\n        if (tag == 0xfa00)\n\t\tstmread(imgdata.shootinginfo.BodySerial, len, ifp);\n\tif (tag == 0xfa27)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\t  }\n\tif (tag == 0xfa28)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\t  }\n\tif (tag == 0xfa29)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\t  }\n\tif (tag == 0xfa2a)\n\t  {\n            FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\t  }\n\n    if (tag == 2120 + wbi ||\n        (wbi<0 && tag == 2125))  /* use Auto WB if illuminant index is not set */\n      {\n        FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n        FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 0x903) iso_speed = getreal(type);\n    //if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#endif\n//@end COMMON\n\nvoid CLASS parse_minolta (int base);\nint CLASS parse_tiff (int base);\n\n//@out COMMON\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!strncasecmp(make, \"SONY\", 4) ||\n      (!strncasecmp(make, \"Hasselblad\", 10) &&\n        (!strncasecmp(model, \"Stellar\", 7) ||\n         !strncasecmp(model, \"Lunar\", 5) ||\n         !strncasecmp(model, \"HV\",2))))\n  {\n  \tswitch (tag) {\n\tcase 0x7300: // SR2 black level\n\t    for (int i = 0; i < 4 && i < len; i++)\n\t      cblack[i] = get2();\n\t  break;\n\tcase 0x7480:\n\tcase 0x7820:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\tbreak;\n\tcase 0x7481:\n\tcase 0x7821:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n\tbreak;\n\tcase 0x7482:\n\tcase 0x7822:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\tbreak;\n\tcase 0x7483:\n\tcase 0x7823:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n\tbreak;\n\tcase 0x7484:\n\tcase 0x7824:\n\t    imgdata.color.WBCT_Coeffs[0][0] = 4500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[0][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n\tbreak;\n\tcase 0x7486:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\tbreak;\n\tcase 0x7825:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\tbreak;\n\tcase 0x7826:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n\tbreak;\n\tcase 0x7827:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n\tbreak;\n\tcase 0x7828:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n\tbreak;\n\tcase 0x7829:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n\tbreak;\n\tcase 0x782a:\n\t    imgdata.color.WBCT_Coeffs[1][0] = 8500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[1][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n\tbreak;\n\tcase 0x782b:\n\t    imgdata.color.WBCT_Coeffs[2][0] = 6000;\n\t    FORC3 imgdata.color.WBCT_Coeffs[2][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n\tbreak;\n\tcase 0x782c:\n\t    imgdata.color.WBCT_Coeffs[3][0] = 3200;\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c+1] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] = imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n\tbreak;\n\tcase 0x782d:\n\t    imgdata.color.WBCT_Coeffs[4][0] = 2500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[4][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n\tbreak;\n\tcase 0x787f:\n\t    FORC3 imgdata.color.linear_max[c] = get2();\n\t    imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n\tbreak;\n\t}\n  }\n#endif\n\n\n    switch (tag) {\n      case 1:   if(len==4) pana_raw = get4(); break;\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:   if ((i = get2())) filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=i;\n#endif\n      break;\n      case 8:\n      case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=get2();\n#endif\n      break;\n      case 14: case 15: case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw) {\n          imgdata.color.linear_max[tag-14] = get2();\n          if (tag == 15 ) imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        }\n#endif\n      break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 19:\n\tif(pana_raw) {\n\t  ushort nWB, cnt, tWB;\n\t  nWB = get2();\n\t  if (nWB > 0x100) break;\n\t  for (cnt=0; cnt<nWB; cnt++) {\n\t    tWB = get2();\n\t    if (tWB < 0x100) {\n\t      imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n\t    } else get4();\n\t  }\n\t}\n      break;\n#endif\n      case 23:\n\tif (type == 3) iso_speed = get2();\n      break;\n      case 28: case 29: case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          {\n            pana_black[tag-28] = get2();\n          }\n        else\n#endif\n          {\n\t     cblack[tag-28] = get2();\n\t     cblack[3] = cblack[1];\n          }\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-36] = get2();\n\tbreak;\n      case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(pana_raw) {\n\t    ushort nWB, cnt, tWB;\n\t    nWB = get2();\n\t    if (nWB > 0x100) break;\n\t    for (cnt=0; cnt<nWB; cnt++) {\n\t        tWB = get2();\n\t        if (tWB < 0x100) {\n\t            imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t        } else fseek(ifp, 6, SEEK_CUR);\n\t    }\n\t}\n\tbreak;\n#endif\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tif (tiff_bps < tiff_ifd[ifd].bps)\n\t    tiff_bps = tiff_ifd[ifd].bps;\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tif (tiff_ifd[ifd].bps > 12) break;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 278:\n\ttiff_ifd[ifd].rows_per_strip = getint(type);\n\tbreak;\n#endif\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_offsets = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_offsets_count = len;\n\t    for(int i=0; i< len; i++)\n\t      tiff_ifd[ifd].strip_offsets[i]=get4()+base;\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    if ((tiff_ifd[ifd].t_width > 4*tiff_ifd[ifd].t_height) & ~jh.clrs) {\n\t      tiff_ifd[ifd].t_width  /= 2;\n\t      tiff_ifd[ifd].t_height *= 2;\n\t    }\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_byte_counts = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_byte_counts_count = len;\n\t    for(int i=0; i< len; i++)\n\t\ttiff_ifd[ifd].strip_byte_counts[i]=get4();\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 317:\n\ttiff_ifd[ifd].predictor = getint(type);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 1)\n\t  tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n      case 325:\n\ttiff_ifd[ifd].bytes = len > 1 ? ftell(ifp): get4();\n\tbreak;\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n         \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif  \n\t  break;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {\n          fseek (ifp, ftell(ifp)+4, SEEK_SET);\n          fseek (ifp, get4()+base, SEEK_SET);\n          parse_tiff_ifd (base);\n          break;\n\t}\n#endif\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 339:\n\ttiff_ifd[ifd].sample_format = getint(type);\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 700:\n        if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n          {\n            xmpdata = (char*)malloc(xmplen = len+1);\n            fread(xmpdata,len,1,ifp);\n            xmpdata[len]=0;\n          }\n        break;\n#endif\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i=0; i < 3; i++) {\n        float num = 0.0;\n        for (c=0; c<3; c++) {\n          imgdata.color.ccm[i][c] = (float) ((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01) FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n\t  FORC4 cblack[c ^ c >> 1] = get2();\n\t  i = cblack[3];\n\t  FORC3 if(i>cblack[c]) i = cblack[c];\n\t  FORC4 cblack[c]-=i;\n\t  black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);\n#endif\n      break;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33421:\t\t\t/* CFARepeatPatternDim */\n\tif (get2() == 6 && get2() == 6)\n\t  filters = 9;\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n\tif (filters == 9) {\n\t  FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;\n\t  break;\n\t}\n      case 64777:\t\t\t/* Kodak P-series */\n        if(len == 36)\n          {\n            filters = 9;\n            colors = 3;\n            FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n          }\n        else if(len > 0)\n          {\n            if ((plen=len) > 16) plen = 16;\n            fread (cfa_pat, 1, plen, ifp);\n            for (colors=cfa=i=0; i < plen && colors < 4; i++) {\n              colors += !(cfa & (1 << cfa_pat[i]));\n              cfa |= 1 << cfa_pat[i];\n            }\n            if (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n            if (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n            goto guess_cfa_pc;\n          }\n        break;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\ttiff_ifd[ifd].t_shutter = shutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= MAX(1,num);\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n        {\n          unsigned pos;\n          fseek(ifp, pos = (get4() + base), SEEK_SET);\n          parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n          fseek(ifp, pos, SEEK_SET);\n          parse_gps_libraw(base);\n#endif\n        }\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 40976:\n\tstrip_offset = get4();\n\tswitch (tiff_ifd[ifd].comp) {\n\t  case 32770: load_raw = &CLASS samsung_load_raw;   break;\n\t  case 32772: load_raw = &CLASS samsung2_load_raw;  break;\n\t  case 32773: load_raw = &CLASS samsung3_load_raw;  break;\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (len < 1 || len > 2560000 || !(cbuf = (char *) malloc(len))) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfread (cbuf, 1, len, ifp);\n#else\n\tif(fread (cbuf, 1, len, ifp) != len)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n        cbuf[len-1] = 0;\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag=1;\n#endif\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50708:\t\t\t/* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n        stmread(imgdata.color.UniqueCameraModel, len, ifp);\n        imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;\n#endif\n\tif (model[0]) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfgets (make, 64, ifp);\n#else\n        strncpy (make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n\tif ((cp = strchr(make,' '))) {\n\t  strcpy(model,cp+1);\n\t  *cp = 0;\n\t}\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (filters == 9) break;\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n        FORCC tab[cfa_pc[c]] = c;\n        cdesc[c] = 0;\n        for (i=16; i--; )\n          filters = filters << 2 | tab[cfa_pat[i % plen]];\n        filters -= !filters;\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) fuji_width = 1;\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[4] = \n#endif\n\tcblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[5] = \n#endif\n\tcblack[5] = get2();\n\tif (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof (cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.color.dng_levels.dng_cblack[4]=\n\t    imgdata.color.dng_levels.dng_cblack[5]= \n#endif\n\t    cblack[4] = cblack[5] = 1;\n\tbreak;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcase 0xf00c: {\n    \tunsigned fwb[4];\n    \tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t  if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n\t\t  {\n\t\t    long long f_save = ftell(ifp);\n\t\t    int fj, found = 0;\n\t\t    ushort *rafdata = (ushort*) malloc (sizeof(ushort)*libraw_internal_data.unpacker_data.lenRAFData);\n\t\t    fseek (ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n\t\t    fread (rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n\t\t    fseek(ifp, f_save, SEEK_SET);\n\t\t    for (int fi=0; fi<(libraw_internal_data.unpacker_data.lenRAFData-3); fi++)\n\t\t\t{\n\t\t\t  if ((fwb[0]==rafdata[fi]) && (fwb[1]==rafdata[fi+1]) && (fwb[2]==rafdata[fi+2]))\n\t\t\t  {\n\t\t\t    if (rafdata[fi-15] != fwb[0]) continue;\n\t\t\t    fi = fi - 15;\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] = rafdata[fi];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi+1];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi+2];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = rafdata[fi+3];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi+4];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi+5];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = rafdata[fi+6];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi+7];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi+8];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = rafdata[fi+9];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi+10];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi+11];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = rafdata[fi+12];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi+13];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi+14];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = rafdata[fi+15];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi+16];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi+17];\n\n                fi += 111;\n                for (fj = fi; fj<(fi+15); fj+=3)\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    found = 1;\n                    break;\n                  }\n                if (found)\n                {\n                  int FujiCCT_K [31] = {2500,2550,2650,2700,2800,2850,2950,3000,3100,3200,3300,3400,3600,3700,3800,4000,4200,4300,4500,4800,5000,5300,5600,5900,6300,6700,7100,7700,8300,9100,10000};\n                  fj = fj - 93;\n                  for (int iCCT=0; iCCT < 31; iCCT++)\n                  {\n                    imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                    imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT*3+1+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT*3+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT*3+2+fj];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t    free (rafdata);\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\t\tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t}\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50709:\n        stmread(imgdata.color.LocalizedCameraModel,len, ifp);\n      break;\n#endif\n\n      case 61450:\n\tcblack[4] = cblack[5] = MIN(sqrt((double)len),64);\n      case 50714:\t\t\t/* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1  && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n\t  {\n\t    for(i=0; i < colors && i < 4 && i < len; i++)\n\t      imgdata.color.dng_levels.dng_cblack[i]=\n\t        cblack[i]=\n\t\t  getreal(type)+0.5;\n\n\t    imgdata.color.dng_levels.dng_black= black = 0;\n\t  }\n\telse\n#endif\n\t  if((cblack[4] * cblack[5] < 2) && len == 1)\n\t    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t      imgdata.color.dng_levels.dng_black= \n#endif\n\t        black =\n\t\t  getreal(type);\n\t    }\n\t  else if(cblack[4] * cblack[5] <= len)\n\t    {\n\t      FORC (cblack[4] * cblack[5])\n\t\tcblack[6+c] = getreal(type);\n\t      black = 0;\n\t      FORC4\n\t\tcblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n              if(tag == 50714)\n\t      {\n\t        FORC (cblack[4] * cblack[5])\n\t          imgdata.color.dng_levels.dng_cblack[6+c]= cblack[6+c];\n\t        imgdata.color.dng_levels.dng_black=0;\n\t        FORC4\n\t          imgdata.color.dng_levels.dng_cblack[c]= 0;\n\t      }\n#endif\n\t    }\n      break;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_black += num/len + 0.5;\n#endif\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_whitelevel[0]=\n#endif\n\tmaximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1 ) // Linear DNG case\n\t\tfor(i=1; i < colors && i < 4 && i < len; i++)\n\t\t\timgdata.color.dng_levels.dng_whitelevel[i]=getint(type);\n#endif\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tif(pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50778:\n        imgdata.color.dng_color[0].illuminant = get2();\n        break;\n      case 50779:\n        imgdata.color.dng_color[1].illuminant = get2();\n        break;\n#endif\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 50721?0:1;\n#endif\n\tFORCC for (j=0; j < 3; j++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.dng_color[i].colormatrix[c][j]=\n#endif\n\t  cm[c][j] = getreal(type);\n          }\n\tuse_cm = 1;\n\tbreak;\n\n\tcase 0xc714:\t\t\t/* ForwardMatrix1 */\n        case 0xc715:\t\t\t/* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 0xc714?0:1;\n#endif\n\tfor (j=0; j < 3; j++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[i].forwardmatrix[j][c]=\n#endif\n              fm[j][c] = getreal(type);\n            }\n\tbreak;\n\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        j = tag == 50723?0:1;\n#endif\n\tfor (i=0; i < colors; i++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[j].calibration[i][c]=\n#endif\n              cc[i][c] = getreal(type);\n            }\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC{\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_levels.analogbalance[c]=\n#endif\n\t      ab[c] = getreal(type);\n\t}\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50730:\t\t\t/* DNG: Baseline Exposure */\n        baseline_exposure = getreal(type);\n        break;\n#endif\n\t\t  // IB start\n    case 50740:\t\t\t/* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        char mbuf[64];\n        unsigned short makernote_found = 0;\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n          {\n            order = 0x4d4d;\t\t\t\t// Adobe header is always in \"MM\" / big endian\n            curr_pos = start_pos + 6;\n            while (curr_pos + 8 - start_pos <= len)\n              {\n                fread(mbuf, 1, 4, ifp);\n                curr_pos += 8;\n                if (!strncmp(mbuf, \"MakN\", 4)) {\n                  makernote_found = 1;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n                parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n                break;\n                }\n              }\n          }\n        else\n          {\n            fread(mbuf + 6, 1, 2, ifp);\n            if (!strcmp(mbuf, \"PENTAX \") ||\n                !strcmp(mbuf, \"SAMSUNG\"))\n              {\n                makernote_found = 1;\n                fseek(ifp, start_pos, SEEK_SET);\n                parse_makernote_0xc634(base, 0, CameraDNG);\n              }\n          }\n\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      // IB end\n#endif\n      if (dng_version) break;\n      parse_minolta (j = get4()+base);\n      fseek (ifp, j, SEEK_SET);\n      parse_tiff_ifd (base);\n      break;\n    case 50752:\n      read_shorts (cr2_slice, 3);\n      break;\n    case 50829:\t\t\t/* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830:\t\t\t/* MaskedAreas */\n      for (i=0; i < len && i < 32; i++)\n        ((int*)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009:\t\t\t/* OpcodeList2 */\n      meta_offset = ftell(ifp);\n      break;\n    case 64772:\t\t\t/* Kodak P-series */\n      if (len < 13) break;\n      fseek (ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek (ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cmatrix, cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n        {\n          thumb_misc   = jh.bits;\n          thumb_width  = jh.wide;\n          thumb_height = jh.high;\n        }\n    }\n  }\n  for (i=tiff_nifds; i--; ) {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    os = raw_width*raw_height;\n    ns = tiff_ifd[i].t_width*tiff_ifd[i].t_height;\n    if (tiff_bps) {\n        os *= tiff_bps;\n        ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n\tunsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n\t ns && ((ns > os && (ties = 1)) ||\n\t\t(ns == os && shot_select == ties++))) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tiff_ifd[i].bytes;\n#endif\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n      shutter       = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties) is_raw = ties;\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2) {\n\t  tiff_bps = 14;\n\t  load_raw = &CLASS unpacked_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n\t// Sony 14-bit uncompressed\n        if(!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2)\n          {\n\t    tiff_bps = 14;\n            load_raw = &CLASS unpacked_load_raw;\n            break;\n\t  }\n        if(!strncasecmp(make,\"Nikon\",5) && !strncmp(software,\"Nikon Scan\",10))\n          {\n            load_raw = &CLASS nikon_coolscan_load_raw;\n            raw_color = 1;\n            filters = 0;\n            break;\n          }\n#endif\n\tif (!strncmp(make,\"OLYMPUS\",7) &&\n\t\ttiff_ifd[raw].bytes*2 == raw_width*raw_height*3)\n\t  load_flags = 24;\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\n\t\t   if (!strncmp(make,\"OLYMPUS\",7) &&\n\t\t\ttiff_ifd[raw].bytes*7 > raw_width*raw_height)\n\t\t     load_raw = &CLASS olympus_load_raw;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  if (model[0] == 'N') load_flags = 80;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS nikon_yuv_load_raw;\n\t  gamma_curve (1/2.4, 12.92, 1, 4095);\n\t  memset (cblack, 0, sizeof cblack);\n\t  filters = 0;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if(raw_width*raw_height*3 == tiff_ifd[raw].bytes*2)\n            {\n              load_raw = &CLASS packed_load_raw;\n              load_flags=80;\n            }\n          else if(tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n\t\t  tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n\t    {\n\t      int fit = 1;\n\t      for(int i = 0; i < tiff_ifd[raw].strip_byte_counts_count-1; i++) // all but last\n\t\tif(tiff_ifd[raw].strip_byte_counts[i]*2 != tiff_ifd[raw].rows_per_strip*raw_width*3)\n\t\t  {\n\t\t    fit = 0;\n\t\t    break;\n\t\t  }\n\t      if(fit)\n\t\tload_raw = &CLASS nikon_load_striped_packed_raw;\n\t      else\n\t\tload_raw = &CLASS nikon_load_raw; // fallback\n\t    }\n\telse\n#endif\n            load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: case 34892: break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8: break;\n#endif\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( ((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&\n\t  (tiff_compress & -16) != 32768)\n          || (tiff_bps == 8 && strncmp(make,\"Phase\",5) &&\n\t  !strcasestr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n         && strncmp(software,\"Nikon Scan\",10))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw\n        && (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33\n\t&& tiff_ifd[i].phint != 32803\n\t&& tiff_ifd[i].phint != 34892\n        && unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps)+1) >\n\t      thumb_width *       thumb_height / (SQR(thumb_misc)+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strncmp(make,\"Imacon\",6))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x524946:\t\t\t\t/* RIF */\n    if (!strncasecmp(model,\"DSLR-A100\", 9))\n    {\n      fseek(ifp, 8, SEEK_CUR);\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n      get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n    }\n\tbreak;\n#endif\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname))\n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff (int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38) {\n      parse_ciff (ftell(ifp), len, depth+1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004) parse_ciff (ftell(ifp), len, depth+1);\n#endif\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = powf64(2.0f, -int_to_float((get4(),get4())));\n      aperture = powf64(2.0f, int_to_float(get4())/2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a) {\n//      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(),get2()) + get2())/32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture  = _CanonConvertAperture((get2(),get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture  = powf64(2.0, (get2(),(short)get2())/64.0);\n#endif\n      shutter   = powf64(2.0,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n      {\n\tINT64 o = ftell(ifp);\n\tfseek (ifp, (0x5<<1), SEEK_CUR);\n\tCanon_WBpresets(0,0);\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x102d)\n      {\n\tINT64 o = ftell(ifp);\n\tCanon_CameraSettings();\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x580b)\n      {\n        if (strcmp(model,\"Canon EOS D30\")) sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n        else sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len>>16, len&0xffff);\n      }\n#endif\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[LIM(0,wbi,17)]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[LIM(0,wbi,17)]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[LIM(0,wbi,9)]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi>=0 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c) {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal  = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2) {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n\tif(imgdata.lens.makernotes.CanonFocalUnits>1)\n\t  imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834)\n      {\n         unique_id  = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n         setCanonBodyFeatures(unique_id);\n#endif\n      }\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      } else {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4) imgdata.lens.makernotes.CurAp =  powf64(2.0f, (int_to_float(data)/2.0f));\n      else imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type)/2.0f));\n      break;\n    case 0x0403:\n      if (type == 4) imgdata.lens.makernotes.CurFocal =  int_to_float(data);\n      else imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4) {\n        imgdata.lens.makernotes.MinFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n        {\n          imgdata.lens.makernotes.MinFocal = 0.0f;\n        }\n      break;\n    case 0x0417:\n      if (type == 4) {\n        imgdata.lens.makernotes.MaxFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.P1_color[0].romm_cam[i]=\n#endif\n\t  ((float *)romm_cam)[i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_col = data+base;\t\tbreak;\n      case 0x224:  ph1.split_row = data;\t\tbreak;\n      case 0x225:  ph1.black_row = data+base;\t\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x226:\n\tfor (i=0; i < 9; i++)\n\t  imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n\tbreak;\n#endif\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0]) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek (ifp, 6, SEEK_CUR);\n    fseek (ifp, meta_offset+get4(), SEEK_SET);\n    entries = get4();  get4();\n    while (entries--) {\n      tag  = get4();\n      len  = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek (ifp, meta_offset+data, SEEK_SET);\n      if (tag == 0x0407) {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        } else {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x131) {\n      filters = 9;\n      FORC(36)\n        {\n           int q = fgetc(ifp);\n           xtrans_abs[0][35 - c] = MAX(0,MIN(q,2)); /* & 3;*/\n        }\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    }\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b =fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    } else if (tag == 0x2100) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    } else if (tag == 0x2200) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    } else if (tag == 0x2300) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    } else if (tag == 0x2301) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    } else if (tag == 0x2302) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    } else if (tag == 0x2310) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    } else if (tag == 0x2400) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n    }\n#endif\n// IB end\n    else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000) tag = get4();\n      if (tag > 10000) tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len>>1);\n#endif\n\t  order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n    )\t\t/* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (save+hlen, len-hlen, 0);\n    }\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp)+7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n//@end COMMON\n\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t  is_foveon = 1;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  ((int *)poff)[i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  if (!strcmp (name, \"CAMSERIAL\"))\n\t    strcpy (imgdata.shootinginfo.BodySerial, value);\n\t  if (!strcmp (name, \"FLEQ35MM\"))\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n          if (!strcmp (name, \"LENSARANGE\"))\n            {\n              char *sp;\n              imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n              sp = strrchr (value, ' ');\n              if (sp)\n                {\n                  imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n                  if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n                    my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n                }\n            }\n          if (!strcmp (name, \"LENSFRANGE\"))\n            {\n              char *sp;\n              imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n              sp = strrchr (value, ' ');\n              if (sp)\n                {\n                  imgdata.lens.makernotes.MaxFocal = atof(sp);\n                  if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n                    my_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n                }\n            }\n          if (!strcmp (name, \"LENSMODEL\"))\n            {\n              char *sp;\n              imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);\n              if (imgdata.lens.makernotes.LensID)\n                imgdata.lens.makernotes.LensMount = Sigma_X3F;\n            }\n        }\n#endif\n    }\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n//@out COMMON\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n\t,int internal_only\n#endif\n)\n{\n  static const struct {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0,\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0, \n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp, same as sd Quattro */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if(colors>4 || colors < 1) return;\n\n  int bl4=(cblack[0]+cblack[1]+cblack[2]+cblack[3])/4,bl64=0;\n  if(cblack[4]*cblack[5]>0)\n  {\n\t  for (unsigned c = 0; c < 4096 && c < cblack[4]*cblack[5]; c++)\n\t\t  bl64+=cblack[c+6];\n\t  bl64 /= cblack[4]*cblack[5];\n  }\n  int rblack  = black+bl4+bl64;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix))) {\n      if(!dng_version)\n\t{\n\t  if (table[i].t_black>0)\n\t    {\n\t      black   = (ushort) table[i].t_black;\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  else if(table[i].t_black <0 && rblack == 0 )\n\t    {\n\t      black   = (ushort) (-table[i].t_black);\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  if (table[i].t_maximum)\n\t      maximum = (ushort) table[i].t_maximum;\n\t}\n      if (table[i].trans[0]) {\n\tfor (raw_color = j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\t\tif(internal_only)\n\t\t\timgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\t\telse\n                  imgdata.color.cam_xyz[0][j] =\n#endif\n                    ((double*)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(!internal_only)\n#endif\n          cam_xyz_coeff (rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n  string[len-1]=0;\n  if(len<3) return; // also not needed\n  len = strnlen(string,len-1);\n  for(int i=len-1; i>=0; i--)\n  {\n    if(isspace(string[i]))\n      string[i]=0;\n    else\n      break;\n  }\n}\n\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 },\n  };\n  static const ushort canon[][11] = {\n    { 1944, 1416,   0,  0, 48,  0 },\n    { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },\n    { 2224, 1456,  48,  6,  0,  2 },\n    { 2376, 1728,  12,  6, 52,  2 },\n    { 2672, 1968,  12,  6, 44,  2 },\n    { 3152, 2068,  64, 12,  0,  0, 16 },\n    { 3160, 2344,  44, 12,  4,  4 },\n    { 3344, 2484,   4,  6, 52,  6 },\n    { 3516, 2328,  42, 14,  0,  0 },\n    { 3596, 2360,  74, 12,  0,  0 },\n    { 3744, 2784,  52, 12,  8, 12 },\n    { 3944, 2622,  30, 18,  6,  2 },\n    { 3948, 2622,  42, 18,  0,  2 },\n    { 3984, 2622,  76, 20,  0,  2, 14 },\n    { 4104, 3048,  48, 12, 24, 12 },\n    { 4116, 2178,   4,  2,  0,  0 },\n    { 4152, 2772, 192, 12,  0,  0 },\n    { 4160, 3124, 104, 11,  8, 65 },\n    { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },\n    { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },\n    { 4312, 2876,  22, 18,  0,  2 },\n    { 4352, 2874,  62, 18,  0,  0 },\n    { 4476, 2954,  90, 34,  0,  0 },\n    { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },\n    { 4480, 3366,  80, 50,  0,  0 },\n    { 4496, 3366,  80, 50, 12,  0 },\n    { 4768, 3516,  96, 16,  0,  0, 0, 16 },\n    { 4832, 3204,  62, 26,  0,  0 },\n    { 4832, 3228,  62, 51,  0,  0 },\n    { 5108, 3349,  98, 13,  0,  0 },\n    { 5120, 3318, 142, 45, 62,  0 },\n    { 5280, 3528,  72, 52,  0,  0 },  /* EOS M */\n    { 5344, 3516, 142, 51,  0,  0 },\n    { 5344, 3584, 126,100,  0,  2 },\n    { 5360, 3516, 158, 51,  0,  0 },\n    { 5568, 3708,  72, 38,  0,  0 },\n    { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },\n    { 5712, 3774,  62, 20, 10,  2 },\n    { 5792, 3804, 158, 51,  0,  0 },\n    { 5920, 3950, 122, 80,  2,  0 },\n    { 6096, 4056, 72, 34,  0,  0 },     /* EOS M3 */\n    { 6288, 4056, 266, 36,  0,  0 },     /* EOS 80D */\n    { 6880, 4544, 136, 42,  0,  0 },     /* EOS 5D4 */\n    { 8896, 5920, 160, 64,  0,  0 },\n  };\n  static const struct {\n    ushort id;\n    char t_model[20];\n  } unique[] = {\n    { 0x001, \"EOS-1D\" },\n    { 0x167, \"EOS-1DS\" },\n    { 0x168, \"EOS 10D\" },\n    { 0x169, \"EOS-1D Mark III\" },\n    { 0x170, \"EOS 300D\" },\n    { 0x174, \"EOS-1D Mark II\" },\n    { 0x175, \"EOS 20D\" },\n    { 0x176, \"EOS 450D\" },\n    { 0x188, \"EOS-1Ds Mark II\" },\n    { 0x189, \"EOS 350D\" },\n    { 0x190, \"EOS 40D\" },\n    { 0x213, \"EOS 5D\" },\n    { 0x215, \"EOS-1Ds Mark III\" },\n    { 0x218, \"EOS 5D Mark II\" },\n    { 0x232, \"EOS-1D Mark II N\" },\n    { 0x234, \"EOS 30D\" },\n    { 0x236, \"EOS 400D\" },\n    { 0x250, \"EOS 7D\" },\n    { 0x252, \"EOS 500D\" },\n    { 0x254, \"EOS 1000D\" },\n    { 0x261, \"EOS 50D\" },\n    { 0x269, \"EOS-1D X\" },\n    { 0x270, \"EOS 550D\" },\n    { 0x281, \"EOS-1D Mark IV\" },\n    { 0x285, \"EOS 5D Mark III\" },\n    { 0x286, \"EOS 600D\" },\n    { 0x287, \"EOS 60D\" },\n    { 0x288, \"EOS 1100D\" },\n    { 0x289, \"EOS 7D Mark II\" },\n    { 0x301, \"EOS 650D\" },\n    { 0x302, \"EOS 6D\" },\n    { 0x324, \"EOS-1D C\" },\n    { 0x325, \"EOS 70D\" },\n    { 0x326, \"EOS 700D\" },\n    { 0x327, \"EOS 1200D\" },\n    { 0x328, \"EOS-1D X Mark II\" },\n    { 0x331, \"EOS M\" },\n    { 0x335, \"EOS M2\" },\n    { 0x374, \"EOS M3\"},   /* temp */\n    { 0x384, \"EOS M10\"},  /* temp */\n    { 0x394, \"EOS M5\"},   /* temp */\n    { 0x346, \"EOS 100D\" },\n    { 0x347, \"EOS 760D\" },\n    { 0x349, \"EOS 5D Mark IV\" },\n    { 0x350, \"EOS 80D\"},\n    { 0x382, \"EOS 5DS\" },\n    { 0x393, \"EOS 750D\" },\n    { 0x401, \"EOS 5DS R\" },\n    { 0x404, \"EOS 1300D\" },\n  }, sonique[] = {\n    { 0x002, \"DSC-R1\" },\n    { 0x100, \"DSLR-A100\" },\n    { 0x101, \"DSLR-A900\" },\n    { 0x102, \"DSLR-A700\" },\n    { 0x103, \"DSLR-A200\" },\n    { 0x104, \"DSLR-A350\" },\n    { 0x105, \"DSLR-A300\" },\n    { 0x106, \"DSLR-A900\" },\n    { 0x107, \"DSLR-A380\" },\n    { 0x108, \"DSLR-A330\" },\n    { 0x109, \"DSLR-A230\" },\n    { 0x10a, \"DSLR-A290\" },\n    { 0x10d, \"DSLR-A850\" },\n    { 0x10e, \"DSLR-A850\" },\n    { 0x111, \"DSLR-A550\" },\n    { 0x112, \"DSLR-A500\" },\n    { 0x113, \"DSLR-A450\" },\n    { 0x116, \"NEX-5\" },\n    { 0x117, \"NEX-3\" },\n    { 0x118, \"SLT-A33\" },\n    { 0x119, \"SLT-A55V\" },\n    { 0x11a, \"DSLR-A560\" },\n    { 0x11b, \"DSLR-A580\" },\n    { 0x11c, \"NEX-C3\" },\n    { 0x11d, \"SLT-A35\" },\n    { 0x11e, \"SLT-A65V\" },\n    { 0x11f, \"SLT-A77V\" },\n    { 0x120, \"NEX-5N\" },\n    { 0x121, \"NEX-7\" },\n    { 0x122, \"NEX-VG20E\"},\n    { 0x123, \"SLT-A37\" },\n    { 0x124, \"SLT-A57\" },\n    { 0x125, \"NEX-F3\" },\n    { 0x126, \"SLT-A99V\" },\n    { 0x127, \"NEX-6\" },\n    { 0x128, \"NEX-5R\" },\n    { 0x129, \"DSC-RX100\" },\n    { 0x12a, \"DSC-RX1\" },\n    { 0x12b, \"NEX-VG900\" },\n    { 0x12c, \"NEX-VG30E\" },\n    { 0x12e, \"ILCE-3000\" },\n    { 0x12f, \"SLT-A58\" },\n    { 0x131, \"NEX-3N\" },\n    { 0x132, \"ILCE-7\" },\n    { 0x133, \"NEX-5T\" },\n    { 0x134, \"DSC-RX100M2\" },\n    { 0x135, \"DSC-RX10\" },\n    { 0x136, \"DSC-RX1R\" },\n    { 0x137, \"ILCE-7R\" },\n    { 0x138, \"ILCE-6000\" },\n    { 0x139, \"ILCE-5000\" },\n    { 0x13d, \"DSC-RX100M3\" },\n    { 0x13e, \"ILCE-7S\" },\n    { 0x13f, \"ILCA-77M2\" },\n    { 0x153, \"ILCE-5100\" },\n    { 0x154, \"ILCE-7M2\" },\n    { 0x155, \"DSC-RX100M4\" },\n    { 0x156, \"DSC-RX10M2\" },\n    { 0x158, \"DSC-RX1RM2\" },\n    { 0x15a, \"ILCE-QX1\" },\n    { 0x15b, \"ILCE-7RM2\" },\n    { 0x15e, \"ILCE-7SM2\" },\n    { 0x161, \"ILCA-68\" },\n    { 0x162, \"ILCA-99M2\" },\n    { 0x163, \"DSC-RX10M3\" },\n    { 0x164, \"DSC-RX100M5\"},\n    { 0x165, \"ILCE-6300\" },\n    { 0x168, \"ILCE-6500\"},\n  };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t\n    const_table[]\n#else\n  static const struct {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  }\n  table[]\n#endif\n   = {\n    {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-080C\" },\n    {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-145C\" },\n    {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-201C\" },\n    {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\" },\n    {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\" },\n    { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-810C\" },\n    { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,\"AgfaPhoto\",\"DC-833m\" },\n    {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,\"Alcatel\",\"5035D\" },\n    {  31850496,4608,3456, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 4:3\" },\n    {  23887872,4608,2592, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 16:9\" },\n//   Android Raw dumps id start\n//   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n    {  1540857,2688,1520, 0, 0, 0, 0, 1,0x61,0,0,\"Samsung\",\"S3\" },\n    {  2658304,1212,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontMipi\" },\n    {  2842624,1296,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontQCOM\" },\n    {  2969600,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wMipi\" },\n    {  3170304,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wQCOM\" },\n    {  3763584,1584,1184, 0, 0, 0, 0, 96,0x61,0,0,\"I_Mobile\",\"I_StyleQ6\" },\n    {  5107712,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel1\" },\n    {  5382640,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel2\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5364240,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  6299648,2592,1944, 0, 0, 0, 0, 1 ,0x16,0,0,\"OmniVisi\",\"OV5648\" },\n    {  6721536,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"OmniVisi\",\"OV56482\" },\n    {  6746112,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"OneSV\" },\n    {  9631728,2532,1902, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"5mp\" },\n    {  9830400,2560,1920, 0, 0, 0, 0, 96,0x61,0,0,\"NGM\",\"ForwardArt\" },\n    { 10186752,3264,2448, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX219-mipi 8mp\" },\n    { 10223360,2608,1944, 0, 0, 0, 0, 96,0x16,0,0,\"Sony\",\"IMX\" },\n    { 10782464,3282,2448, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"MyTouch4GSlide\" },\n    { 10788864,3282,2448, 0, 0, 0, 0, 0, 0x16,0,0,\"Xperia\",\"L\" },\n    { 15967488,3264,2446, 0, 0, 0, 0, 96,0x16,0,0,\"OmniVison\",\"OV8850\" },\n    { 16224256,4208,3082, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3MipiL\" },\n    { 16424960,4208,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"IMX135\",\"MipiL\" },\n    { 17326080,4164,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3LQCom\" },\n    { 17522688,4212,3120, 0, 0, 0, 0, 0,0x16,0,0,\"Sony\",\"IMX135-QCOM\" },\n    { 19906560,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7mipi\" },\n    { 19976192,5312,2988, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G4\" },\n    { 20389888,4632,3480, 0, 0, 0, 0, 1, 0x16,0,0,\"Xiaomi\",\"RedmiNote3Pro\" },\n    { 20500480,4656,3496, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX298-mipi 16mp\" },\n    { 21233664,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7qcom\" },\n    { 26023936,4192,3104, 0, 0, 0, 0, 96,0x94,0,0,\"THL\",\"5000\" },\n    { 26257920,4208,3120, 0, 0, 0, 0, 96,0x94,0,0,\"Sony\",\"IMX214\" },\n    { 26357760,4224,3120, 0, 0, 0, 0, 96,0x61,0,0,\"OV\",\"13860\" },\n    { 41312256,5248,3936, 0, 0, 0, 0, 96,0x61,0,0,\"Meizu\",\"MX4\" },\n    { 42923008,5344,4016, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"IMX230\" },\n    //   Android Raw dumps id end\n    {  20137344,3664,2748,0, 0, 0, 0,0x40,0x49,0,0,\"Aptina\",\"MT9J003\",0xffff },\n    {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,\"Baumer\",\"TXG14\",1078 },\n    {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,\"Canon\",\"PowerShot SD300\" },\n    {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,\"Canon\",\"PowerShot A460\" },\n    {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,\"Canon\",\"PowerShot A610\" },\n    {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,\"Canon\",\"PowerShot A530\" },\n    {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot S3 IS\" },\n    {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot A620\" },\n    {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,\"Canon\",\"PowerShot A470\" },\n    { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,\"Canon\",\"PowerShot A720 IS\" },\n    { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,\"Canon\",\"PowerShot A630\" },\n    { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,\"Canon\",\"PowerShot A640\" },\n    { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot A650\" },\n    { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,\"Canon\",\"PowerShot SX110 IS\" },\n    { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,\"Canon\",\"PowerShot SX120 IS\" },\n    { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot SX20 IS\" },\n    { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,\"Canon\",\"PowerShot SX220 HS\" },\n    { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,\"Canon\",\"PowerShot SX30 IS\" },\n    { 24724224,4704,3504, 8,16,56, 8,40,0x49,0,2,\"Canon\",\"PowerShot A3300 IS\" },\n    { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,\"Canon\",\"IXUS 160\" },\n    {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,\"Casio\",\"QV-2000UX\" },\n    {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,\"Casio\",\"QV-3*00EX\" },\n    {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,\"Casio\",\"QV-5700\" },\n    {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,\"Casio\",\"EX-Z60\" },\n    {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,\"Casio\",\"EX-S20\" },\n    {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,\"Casio\",\"EX-S100\" },\n    {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,\"Casio\",\"QV-R41\" },\n    {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,\"Casio\",\"EX-P505\" },\n    {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,\"Casio\",\"QV-R51\" },\n    {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,\"Casio\",\"EX-Z50\" },\n    {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,\"Casio\",\"EX-Z500\" },\n    {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,\"Casio\",\"EX-Z55\" },\n    {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,\"Casio\",\"EX-P600\" },\n    { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,\"Casio\",\"EX-Z750\" },\n    { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,\"Casio\",\"EX-Z75\" },\n    { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,\"Casio\",\"EX-P700\" },\n    { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,\"Casio\",\"EX-Z850\" },\n    { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,\"Casio\",\"EX-Z8\" },\n    { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,\"Casio\",\"EX-Z1050\" },\n    { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,\"Casio\",\"EX-ZR100\" },\n    {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,\"Casio\",\"QV-4000\" },\n    {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,\"Creative\",\"PC-CAM 600\" },\n    { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,\"DJI\" },\n    { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,\"Matrix\" },\n    {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,\"Foculus\",\"531C\" },\n    {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,\"Generic\" },\n    {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,\"Kodak\",\"DCS200\" },\n    {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\" },\n    {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\",3160 },\n    {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\" },\n    {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\",3160 },\n    {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\" },\n    { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\",31556 },\n    { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"12MP\" },\n    {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,\"Kodak\",\"KAI-0340\" },\n    { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,\"Lenovo\",\"A820\" },\n    {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,\"Micron\",\"2010\",3212 },\n    {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,\"Minolta\",\"RD175\",513 },\n    {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,\"Nikon\",\"E900\" },\n    {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,\"Nikon\",\"E950\" },\n    {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,\"Nikon\",\"E2100\" },\n    {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,\"Nikon\",\"E990\" },\n    {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,\"Nikon\",\"E3700\" },\n    {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E4500\" },\n    {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,\"Nikon\",\"E4300\" },\n    {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E5000\" },\n    {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,\"Nikon\",\"COOLPIX S6\" },\n    {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,\"Olympus\",\"C770UZ\" },\n    {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,\"Pentax\",\"Optio S\" },\n    {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S\" },\n    {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S4\" },\n    { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,\"Pentax\",\"Optio 750Z\" },\n    {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\" },\n    {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\",8 },\n    { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,\"Pixelink\",\"A782\" },\n    {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,\"RoverShot\",\"3320AF\" },\n    {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,\"ST Micro\",\"STV680 VGA\" },\n    { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n    {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n  };\n#ifdef LIBRAW_LIBRARY_BUILD\n    libraw_custom_camera_t\n      table[64 + sizeof(const_table)/sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] =\n    { \"AgfaPhoto\", \"Canon\", \"Casio\", \"Epson\", \"Fujifilm\",\n      \"Mamiya\", \"Minolta\", \"Motorola\", \"Kodak\", \"Konica\", \"Leica\",\n      \"Nikon\", \"Nokia\", \"Olympus\", \"Pentax\", \"Phase One\", \"Ricoh\",\n      \"Samsung\", \"Sigma\", \"Sinar\", \"Sony\" };\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize=1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64,table,imgdata.params.custom_camera_strings);\n  for(int q = 0; q < sizeof(const_table)/sizeof(const_table[0]); q++)\n\tmemmove(&table[q+camera_count],&const_table[q],sizeof(const_table[0]));\n  camera_count += sizeof(const_table)/sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX;\t/* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread (head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread (head, 1, 32, ifp);\n#endif\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (hlen, flen-hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 52, SEEK_SET);\n    switch (get4()) {\n      case  7: iso_speed = 25;  break;\n      case  8: iso_speed = 32;  break;\n      case  9: iso_speed = 40;  break;\n      case 10: iso_speed = 50;  break;\n      case 11: iso_speed = 64;  break;\n      case 12: iso_speed = 80;  break;\n      case 13: iso_speed = 100; break;\n      case 14: iso_speed = 125; break;\n      case 15: iso_speed = 160; break;\n      case 16: iso_speed = 200; break;\n      case 17: iso_speed = 250; break;\n      case 18: iso_speed = 320; break;\n      case 19: iso_speed = 400; break;\n    }\n    shutter = powf64(2.0f, (((float)get4())/8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek (ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek (ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head+0x1c);\n    memcpy(model2, head+0x3c, 4);\n    model2[4]=0;\n#endif\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4())?1:0;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head+4,\"ftypqt   \",9)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_qt (fsize);\n    is_raw = 0;\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i*8 / (width * height)) {\n      case  8: load_raw = &CLASS eight_bit_load_raw;  break;\n      case 10: load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"XPDS\",4)) {\n    order = 0x4949;\n    fseek (ifp, 0x800, SEEK_SET);\n    fread (make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width  = get2();\n    fseek (ifp, 56, SEEK_CUR);\n    fread (model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve (0, 12.25, 1, 1023);\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"Red\");\n    strcpy (model,\"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n  else if (!memcmp (head,\"FOVb\",4))\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n        parse_foveon();\n      else\n#endif\n        parse_x3f();\n#else\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      parse_foveon();\n#endif\n#endif\n    }\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  if(make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize=i=0; i < camera_count; i++)\n#else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\",5))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          }\n#endif\n\tstrcpy (model, table[i].t_model);\n\tflip = table[i].flags >> 2;\n\tzero_is_bad = table[i].flags & 2;\n\tif (table[i].flags & 1)\n\t  parse_external_jpeg();\n\tdata_offset = table[i].offset == 0xffff?0:table[i].offset;\n\traw_width   = table[i].rw;\n\traw_height  = table[i].rh;\n\tleft_margin = table[i].lm;\n\t top_margin = table[i].tm;\n\twidth  = raw_width - left_margin - table[i].rm;\n\theight = raw_height - top_margin - table[i].bm;\n\tfilters = 0x1010101 * table[i].cf;\n\tcolors = 4 - !((filters & filters >> 1) & 0x5555);\n\tload_flags = table[i].lf;\n\tswitch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {\n\t  case 6:\n\t    load_raw = &CLASS minolta_rd175_load_raw;  break;\n\t  case 8:\n\t    load_raw = &CLASS eight_bit_load_raw;  break;\n\t  case 10:\n           if ((fsize-data_offset)/raw_height*3 >= raw_width*4) {\n             load_raw = &CLASS android_loose_load_raw;  break;\n           } else if (load_flags & 1) {\n             load_raw = &CLASS android_tight_load_raw;  break;\n           }\n\t  case 12:\n\t    load_flags |= 128;\n\t    load_raw = &CLASS packed_load_raw;     break;\n\t  case 16:\n\t    order = 0x4949 | 0x404 * (load_flags & 1);\n\t    tiff_bps -= load_flags >> 4;\n\t    tiff_bps -= load_flags = load_flags >> 1 & 7;\n\t    load_raw = table[i].offset == 0xffff ? &CLASS  unpacked_load_raw_reversed : &CLASS  unpacked_load_raw;\n\t}\n\tmaximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model,\"RP_imx219\",9) && sz >= 0x9cb600 &&\n        !fseek (ifp, -0x9cb600, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n\tstrcpy (make, \"Broadcom\");\n\tstrcpy (model, \"RPi IMX219\");\n\tif (raw_height > raw_width) flip = 5;\n\tdata_offset = ftell(ifp) + 0x8000 - 0x20;\n\tparse_broadcom();\n\tblack = 66;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    } else\n      if (!(strncmp(model,\"ov5647\",6) && strncmp(model,\"RP_OV5647\",9)) && sz >= 0x61b800 &&\n        !fseek (ifp, -0x61b800, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n      strcpy (make, \"Broadcom\");\n      if (!strncmp(model,\"ov5647\",6))\n        strcpy (model, \"RPi OV5647 v.1\");\n      else\n        strcpy (model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width) flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n\tblack = 16;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model,\"ov\",2) && strncmp(model,\"RP_OV\",5)) && sz>=6404096 &&\n        !fseek (ifp, -6404096, SEEK_END) &&\n\t  fread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    } else is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr (make, corp[i]))\t/* Simplify company names */\n\t    strcpy (make, corp[i]);\n  if ((!strncmp(make,\"Kodak\",5) || !strncmp(make,\"Leica\",5)) &&\n\t((cp = strcasestr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  if (!strncasecmp(model,\"PENTAX\",6))\n    strcpy (make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make,sizeof(make));\n  remove_trailing_spaces(model,sizeof(model));\n#else\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n#endif\n  i = strbuflen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width == 6080 && !strcmp(model,\"K-70\"))\n     { height  = 4016; top_margin=32; width=6020; left_margin = 60; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 6080 && !strcmp(model,\"K-3 II\")) /* moved back */\n    { left_margin = 4;  width  = 6040; }\n  if (width == 6080 && !strcmp(model,\"K-3\"))\n    { left_margin = 4;  width  = 6040; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw *= tiff_samples;\n    else\t colors  = tiff_samples;\n    switch (tiff_compress) {\n      case 0:  /* Compression not set, assuming uncompressed */\n      case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;\n      case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8:     load_raw = &CLASS  deflate_dng_load_raw;  break;\n#endif\n      case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;\n      default:    load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\",5) && unique_id)\n      {\n        for (i = 0; i < sizeof unique / sizeof *unique; i++)\n          if (unique_id == 0x80000000 + unique[i].id)\n            {\n              strcpy(model, unique[i].t_model);\n              break;\n            }\n      }\n    if (!strncasecmp(make, \"Sony\",4) && unique_id)\n      {\n        for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n          if (unique_id == sonique[i].id)\n            {\n              strcpy(model, sonique[i].t_model);\n              break;\n            }\n      }\n    goto dng_skip;\n  }\n  if (!strncmp(make,\"Canon\",5) && !fsize && tiff_bps != 15) {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i=0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1]) {\n\twidth  = raw_width - (left_margin = canon[i][2]);\n\theight = raw_height - (top_margin = canon[i][3]);\n\twidth  -= canon[i][4];\n\theight -= canon[i][5];\n\tmask[0][1] =  canon[i][6];\n\tmask[0][3] = -canon[i][7];\n\tmask[1][1] =  canon[i][8];\n\tmask[1][3] = -canon[i][9];\n\tif (canon[i][10]) filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000) {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make,\"Canon\",5) && unique_id)\n    {\n      for (i=0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n          {\n            adobe_coeff (\"Canon\", unique[i].t_model);\n            strcpy(model,unique[i].t_model);\n          }\n    }\n\n  if (!strncasecmp(make,\"Sony\",4) && unique_id)\n    {\n      for (i=0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n          {\n            adobe_coeff (\"Sony\", sonique[i].t_model);\n            strcpy(model,sonique[i].t_model);\n          }\n    }\n\n  if (!strncmp(make,\"Nikon\",5)) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model,\"KAI-0340\")\n\t&& find_green (16, 16, 3840, 5120) < 25) {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy (model,\"C603\");\n  }\n\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if(!strncmp(make,\"Pentax\",6))\n  {\n    if(!strncmp(model,\"K-1\",3))\n    {\n  \ttop_margin = 18;\n \theight = raw_height - top_margin;\n\tif(raw_width == 7392)\n\t{\n\t  left_margin = 6;\n\t  width = 7376;\n\t}\n    }\n  }\n  else if (!strncmp(make,\"Canon\",5) && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) {\n      SWAP(height,width);\n      SWAP(raw_height,raw_width);\n    }\n    if (width == 7200 && height == 3888)\n      {\n\traw_width  = width  = 6480;\n\traw_height = height = 4320;\n      }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    filters = 0x1e4b4e1b;\ncanon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\") ||\n\t     !strcmp(model,\"PowerShot G1\")) {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    mask[1][3] = -4;\n    top_margin=16;\n    left_margin = 92;\n  } else if (!strcmp(model,\"PowerShot S120\")) {\n        raw_width = 4192;\n        raw_height = 3062;\n        width = 4022;\n        height = 3016;\n        mask[0][0] = top_margin = 31;\n        mask[0][2] = top_margin + height;\n        left_margin = 120;\n        mask[0][1] = 23;\n        mask[0][3] = 72;\n  } else if (!strcmp(model,\"PowerShot G16\")) {\n      mask[0][0] = 0;\n      mask[0][2] = 80;\n      mask[0][1] = 0;\n      mask[0][3] = 16;\n      top_margin = 29;\n      left_margin = 120;\n      width = raw_width-left_margin-48;\n      height = raw_height-top_margin-14;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin = 17;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\") ||\n\t     !strcmp(model,\"COOLPIX A\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t    !strncmp(model,\"D6\",2)  ||\n\t    !strncmp(model,\"D800\",4)) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\") ||\n\t     !strcmp(model,\"Df\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strncmp(make,\"Nikon\",5) && raw_width == 4032) {\n    if(!strcmp(model,\"COOLPIX P7700\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7700\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else if(!strcmp(model,\"COOLPIX P7800\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7800\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else  if(!strcmp(model,\"COOLPIX P340\"))\n      load_flags=0;\n  } else if (!strncmp(model,\"COOLPIX P\",9) && raw_width != 4032) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed==0) && !strstr(software,\"V1.2\") )\n      black = 255;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  } else if (fsize == 3178560) {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  } else if (fsize == 4771840) {\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (fsize == 2940928) {\n    if (!timestamp && !nikon_e2100())\n      strcpy (model,\"E2500\");\n    if (!strcmp(model,\"E2500\")) {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  } else if (fsize == 4775936) {\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (fsize == 6291456) {\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strncmp(make,\"Fujifilm\",8)) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848 || width == 3664) filters = 0x16161616;\n    if (width == 4032 || width == 4952) left_margin = 0;\n    if (width == 3328 && (width -= 66)) left_margin = 34;\n    if (width == 4936) left_margin = 4;\n    if (width == 6032) left_margin = 0;\n    if (!strcmp(model,\"HS50EXR\") ||\n\t!strcmp(model,\"F900EXR\")) {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if(!strcmp(model,\"S5500\"))\n      {\n        height -= (top_margin=6);\n      }\n    if (fuji_layout) raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36) ((char *)xtrans)[c] =\n\txtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strncasecmp(make,\"Minolta\",7)) {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strncmp(make,\"Samsung\",7) && !strcmp(model,\"NX3000\")) {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_height == 3714) {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5664) {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 6496) {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n    black = 1 << (tiff_bps - 7);\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (strstr(model,\"WB550\")) {\n    strcpy (model, \"WB550\");\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3030;\n    width  = 4040;\n    top_margin = 15;\n    left_margin=24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    black = 16;\n  } else if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"640x480\")) {\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strncmp(make,\"Hasselblad\",10)) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if(!strncasecmp(model,\"H3D\",3))\n        {\n          adobe_coeff(\"Hasselblad\",\"H3DII-39\");\n          strcpy(model,\"H3DII-39\");\n        }\n    } else if (raw_width == 7410 || raw_width == 8282) {\n      height -= 84;\n      width  -= 82;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\",\"H4D-40\");\n      strcpy(model,\"H4D-40\");\n    }\n    else if( raw_width == 8384) // X1D\n    {\n     top_margin  = 96;\n     height -= 96;\n     left_margin = 48;\n     width  -= 106;\n     adobe_coeff(\"Hasselblad\",\"X1D\");\n    }\n    else if (raw_width == 9044) {\n      if(black > 500)\n        {\n          top_margin = 12;\n          left_margin = 44;\n          width = 8956;\n          height = 6708;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H4D-60\");\n          strcpy(model,\"H4D-60\");\n          black = 512;\n        }\n      else\n        {\n          height = 6716;\n          width  = 8964;\n          top_margin  = 8;\n          left_margin = 40;\n          black += load_flags = 256;\n          maximum = 0x8101;\n          strcpy(model,\"H3DII-60\");\n        }\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    } else if (raw_width == 8282 && raw_height == 6240) {\n      if(!strncasecmp(model,\"H5D\",3))\n        {\n          /* H5D 50*/\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          black = 256;\n          strcpy(model,\"H5D-50\");\n        }\n      else if(!strncasecmp(model,\"H3D\",3))\n        {\n          black=0;\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H3D-50\");\n          strcpy(model,\"H3D-50\");\n        }\n    } else if (raw_width == 8374 && raw_height == 6304) {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model,\"H5D-50c\");\n    }\n    if (tiff_samples > 1) {\n      is_raw = tiff_samples+1;\n      if (!shot_select && !half_size) filters = 0;\n    }\n  } else if (!strncmp(make,\"Sinar\",5)) {\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size) filters = 0;\n    maximum = 0x3fff;\n  } else if (!strncmp(make,\"Leaf\",4)) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strncmp(make,\"Leica\",5) || !strncmp(make,\"Panasonic\",9)\n      || !strncasecmp(make,\"YUNEEC\",6)) {\n    if (raw_width > 0&& ((flen - data_offset) / (raw_width*8/7) == raw_height) )\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strncmp(make,\"Olympus\",7)) {\n    height += height & 1;\n    if (exif_cfa) filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (width == 9280) { width -= 6; height -= 6; }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"STYLUS1\")) {\n      width -= 14;\n      maximum = 0xfff;\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"TG-4\")) {\n      width -= 16;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 3984) {\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4288) {\n    width -= 32;\n  }  else if (!strcmp(make, \"Sony\") && raw_width == 4600) {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4928) {\n    if (height < 3280) width -= 8;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 5504) { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 6048) {\n    width -= 24;\n    if (strstr(model,\"RX1\") || strstr(model,\"A99\"))\n      width -= 6;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 7392) {\n    width -= 30;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 8000) {\n    width -= 32;\n    if (!strncmp(model, \"DSC\", 3)) {\n      tiff_bps = 14;\n      load_raw = &CLASS unpacked_load_raw;\n    }\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      height -= 4;\n      width  -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603\") || !strcmp(model,\"C330\")\n\t|| !strcmp(model,\"12MP\")) {\n    order = 0x4949;\n    if (filters && data_offset) {\n      fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw  =  filters   ? &CLASS eight_bit_load_raw :\n      strcmp(model,\"C330\") ? &CLASS kodak_c603_load_raw :\n\t\t\t     &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strncasecmp(make,\"Kodak\",5)) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6) ||\n\t!strncmp(model,\"EOSDCS\",6) ||\n\t!strncmp(model,\"DCS4\",4)) {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ') model[6] = 0;\n      if (!strcmp(model,\"DCS460A\")) goto bw;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      goto bw;\n    } else if (!strcmp(model,\"DCS760M\")) {\nbw:   colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      iso_speed=84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      iso_speed=160;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      iso_speed=140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strncmp(make,\"Rollei\",6) && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(dng_version) /* Override black level by DNG tags */\n  {\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0,\n    (sizeof(cblack)/sizeof(cblack[0])),\n    (sizeof(imgdata.color.dng_levels.dng_cblack)/sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for(int i=0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2) )\n\t&& cmatrix[0][0] > 0.125) {\n    memcpy (rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color) adobe_coeff (make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(imgdata.color.cam_xyz[0][0]<0.01)\n\t  adobe_coeff (make, model,1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum)\n    {\n      maximum = (1 << tiff_bps) - 1;\n      if(maximum < 0x10000 && curve[maximum]>0 &&    load_raw == &CLASS sony_arw2_load_raw)\n        maximum = curve[maximum];\n    }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if(raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX) flip = tiff_flip;\n  if (flip == UINT_MAX) flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if(flip > 89 || flip < -89)\n   {\n     switch ((flip+3600) % 360)\n     {\n       case 270:  flip = 5;  break;\n       case 180:  flip = 3;  break;\n       case  90:  flip = 6;  break;\n     }\n   }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\n\n//@end COMMON\n\n//@out FILEIO\n#ifndef NO_LCMS\nvoid CLASS apply_profile (const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile=0, hOutProfile=0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n  if (strcmp (input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile (input, \"r\");\n  else if (profile_length) {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *) malloc (profile_length);\n    merror (prof, \"apply_profile()\");\n    fseek (ifp, profile_offset, SEEK_SET);\n    fread (prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem (prof, profile_length);\n    free (prof);\n#else\n    hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);\n#endif\n  } else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n    }\n  if (!hInProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n          return;\n      }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen (output, \"rb\"))) {\n    fread (&size, 4, 1, fp);\n    fseek (fp, 0, SEEK_SET);\n    oprof = (unsigned *) malloc (size = ntohl(size));\n    merror (oprof, \"apply_profile()\");\n    fread (oprof, 1, size, fp);\n    fclose (fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {\n      free (oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n else\n    fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n          goto quit;\n      }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);\n#endif\n  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\n\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform (hTransform, image, image, width*height);\n  raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\n  cmsDeleteTransform (hTransform);\n  cmsCloseProfile (hOutProfile);\nquit:\n  cmsCloseProfile (hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);\n#endif\n}\n#endif\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double aces_rgb[3][3] =\n  { { 0.432996, 0.375380, 0.189317 },\n    { 0.089427, 0.816523, 0.102989 },\n    { 0.019165, 0.118150, 0.941914 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 ||\n\t\toutput_color < 1 || output_color > 6;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (high, wide*sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n//@end COMMON\n\n\nstruct tiff_tag {\n  ushort tag, type;\n  int count;\n  union { char c[4]; short s[2]; int i; } val;\n};\n\nstruct tiff_hdr {\n  ushort t_order, magic;\n  int ifd;\n  ushort pad, ntag;\n  struct tiff_tag tag[23];\n  int nextifd;\n  ushort pad2, nexif;\n  struct tiff_tag exif[4];\n  ushort pad3, ngps;\n  struct tiff_tag gpst[10];\n  short bps[4];\n  int rat[10];\n  unsigned gps[26];\n  char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];\n};\n\n//@out COMMON\n\nvoid CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2) {\n    count = strnlen((char *)th + val, count-1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val+c];\n  } else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n  if (full) {\n    tiff_set (th, &th->ntag, 254, 4, 1, 0);\n    tiff_set (th, &th->ntag, 256, 4, 1, width);\n    tiff_set (th, &th->ntag, 257, 4, 1, height);\n    tiff_set (th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (th, &th->ntag, 259, 3, 1, 1);\n    tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (th, &th->ntag, 277, 3, 1, colors);\n    tiff_set (th, &th->ntag, 278, 4, 1, height);\n    tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (th, &th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (th, &th->ntag, 284, 3, 1, 1);\n  tiff_set (th, &th->ntag, 296, 3, 1, 2);\n  tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (th, &th->ngps,  0, 1,  4, 0x202);\n    tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n#endif\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n//@end COMMON\n\nint CLASS main (int argc, const char **argv)\n{\n  int arg, status=0, quality, i, c;\n  int timestamp_only=0, thumbnail_only=0, identify_only=0;\n  int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;\n  int use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;\n  const char *sp, *bpfile=0, *dark_frame=0, *write_ext;\n  char opm, opt, *ofname, *cp;\n  struct utimbuf ut;\n#ifndef NO_LCMS\n  const char *cam_profile=0, *out_profile=0;\n#endif\n\n#ifndef LOCALTIME\n  putenv ((char *) \"TZ=UTC\");\n#endif\n#ifdef LOCALEDIR\n  setlocale (LC_CTYPE, \"\");\n  setlocale (LC_MESSAGES, \"\");\n  bindtextdomain (\"dcraw\", LOCALEDIR);\n  textdomain (\"dcraw\");\n#endif\n\n  if (argc == 1) {\n    printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\n    puts(_(\"-v        Print verbose messages\"));\n    puts(_(\"-c        Write image data to standard output\"));\n    puts(_(\"-e        Extract embedded thumbnail image\"));\n    puts(_(\"-i        Identify files without decoding them\"));\n    puts(_(\"-i -v     Identify files and show metadata\"));\n    puts(_(\"-z        Change file dates to camera timestamp\"));\n    puts(_(\"-w        Use camera white balance, if possible\"));\n    puts(_(\"-a        Average the whole image for white balance\"));\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\n    puts(_(\"-r <r g b g> Set custom white balance\"));\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\n    puts(_(\"-k <num>  Set the darkness level\"));\n    puts(_(\"-S <num>  Set the saturation level\"));\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\n#ifndef NO_LCMS\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\n#endif\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\n    puts(_(\"-W        Don't automatically brighten the image\"));\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\n    puts(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\n    puts(_(\"-6        Write 16-bit instead of 8-bit\"));\n    puts(_(\"-4        Linear 16-bit, same as \\\"-6 -W -g 1 1\\\"\"));\n    puts(_(\"-T        Write TIFF instead of PPM\"));\n    puts(\"\");\n    return 1;\n  }\n  argv[argc] = \"\";\n  for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {\n    opt = argv[arg++][1];\n    if ((cp = (char *) strchr (sp=\"nbrkStqmHACg\", opt)))\n      for (i=0; i < \"114111111422\"[cp-sp]-'0'; i++)\n\tif (!isdigit(argv[arg+i][0])) {\n\t  fprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\n\t  return 1;\n\t}\n    switch (opt) {\n      case 'n':  threshold   = atof(argv[arg++]);  break;\n      case 'b':  bright      = atof(argv[arg++]);  break;\n      case 'r':\n\t   FORC4 user_mul[c] = atof(argv[arg++]);  break;\n      case 'C':  aber[0] = 1 / atof(argv[arg++]);\n\t\t aber[2] = 1 / atof(argv[arg++]);  break;\n      case 'g':  gamm[0] =     atof(argv[arg++]);\n\t\t gamm[1] =     atof(argv[arg++]);\n\t\t if (gamm[0]) gamm[0] = 1/gamm[0]; break;\n      case 'k':  user_black  = atoi(argv[arg++]);  break;\n      case 'S':  user_sat    = atoi(argv[arg++]);  break;\n      case 't':  user_flip   = atoi(argv[arg++]);  break;\n      case 'q':  user_qual   = atoi(argv[arg++]);  break;\n      case 'm':  med_passes  = atoi(argv[arg++]);  break;\n      case 'H':  highlight   = atoi(argv[arg++]);  break;\n      case 's':\n\tshot_select = abs(atoi(argv[arg]));\n\tmulti_out = !strcmp(argv[arg++],\"all\");\n\tbreak;\n      case 'o':\n\tif (isdigit(argv[arg][0]) && !argv[arg][1])\n\t  output_color = atoi(argv[arg++]);\n#ifndef NO_LCMS\n\telse     out_profile = argv[arg++];\n\tbreak;\n      case 'p':  cam_profile = argv[arg++];\n#endif\n\tbreak;\n      case 'P':  bpfile     = argv[arg++];  break;\n      case 'K':  dark_frame = argv[arg++];  break;\n      case 'z':  timestamp_only    = 1;  break;\n      case 'e':  thumbnail_only    = 1;  break;\n      case 'i':  identify_only     = 1;  break;\n      case 'c':  write_to_stdout   = 1;  break;\n      case 'v':  verbose           = 1;  break;\n      case 'h':  half_size         = 1;  break;\n      case 'f':  four_color_rgb    = 1;  break;\n      case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);\n      case 'a':  use_auto_wb       = 1;  break;\n      case 'w':  use_camera_wb     = 1;  break;\n      case 'M':  use_camera_matrix = 3 * (opm == '+');  break;\n      case 'I':  read_from_stdin   = 1;  break;\n      case 'E':  document_mode++;\n      case 'D':  document_mode++;\n      case 'd':  document_mode++;\n      case 'j':  use_fuji_rotate   = 0;  break;\n      case 'W':  no_auto_bright    = 1;  break;\n      case 'T':  output_tiff       = 1;  break;\n      case '4':  gamm[0] = gamm[1] =\n\t\t no_auto_bright    = 1;\n      case '6':  output_bps       = 16;  break;\n      default:\n\tfprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);\n\treturn 1;\n    }\n  }\n  if (arg == argc) {\n    fprintf (stderr,_(\"No files to process.\\n\"));\n    return 1;\n  }\n  if (write_to_stdout) {\n    if (isatty(1)) {\n      fprintf (stderr,_(\"Will not write an image to the terminal!\\n\"));\n      return 1;\n    }\n#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)\n    if (setmode(1,O_BINARY) < 0) {\n      perror (\"setmode()\");\n      return 1;\n    }\n#endif\n  }\n  for ( ; arg < argc; arg++) {\n    status = 1;\n    raw_image = 0;\n    image = 0;\n    oprof = 0;\n    meta_data = ofname = 0;\n    ofp = stdout;\n    if (setjmp (failure)) {\n      if (fileno(ifp) > 2) fclose(ifp);\n      if (fileno(ofp) > 2) fclose(ofp);\n      status = 1;\n      goto cleanup;\n    }\n    ifname = argv[arg];\n    if (!(ifp = fopen (ifname, \"rb\"))) {\n      perror (ifname);\n      continue;\n    }\n    status = (identify(),!is_raw);\n    if (user_flip >= 0)\n      flip = user_flip;\n    switch ((flip+3600) % 360) {\n      case 270:  flip = 5;  break;\n      case 180:  flip = 3;  break;\n      case  90:  flip = 6;\n    }\n    if (timestamp_only) {\n      if ((status = !timestamp))\n\tfprintf (stderr,_(\"%s has no timestamp.\\n\"), ifname);\n      else if (identify_only)\n\tprintf (\"%10ld%10d %s\\n\", (long) timestamp, shot_order, ifname);\n      else {\n\tif (verbose)\n\t  fprintf (stderr,_(\"%s time set to %d.\\n\"), ifname, (int) timestamp);\n\tut.actime = ut.modtime = timestamp;\n\tutime (ifname, &ut);\n      }\n      goto next;\n    }\n    write_fun = &CLASS write_ppm_tiff;\n    if (thumbnail_only) {\n      if ((status = !thumb_offset)) {\n\tfprintf (stderr,_(\"%s has no thumbnail.\\n\"), ifname);\n\tgoto next;\n      } else if (thumb_load_raw) {\n\tload_raw = thumb_load_raw;\n\tdata_offset = thumb_offset;\n\theight = thumb_height;\n\twidth  = thumb_width;\n\tfilters = 0;\n\tcolors = 3;\n      } else {\n\tfseek (ifp, thumb_offset, SEEK_SET);\n\twrite_fun = write_thumb;\n\tgoto thumbnail;\n      }\n    }\n    if (load_raw == &CLASS kodak_ycbcr_load_raw) {\n      height += height & 1;\n      width  += width  & 1;\n    }\n\n    if (identify_only && verbose && make[0]) {\n      printf (_(\"\\nFilename: %s\\n\"), ifname);\n      printf (_(\"Timestamp: %s\"), ctime(&timestamp));\n      printf (_(\"Camera: %s %s\\n\"), make, model);\n      if (artist[0])\n\tprintf (_(\"Owner: %s\\n\"), artist);\n      if (dng_version) {\n\tprintf (_(\"DNG Version: \"));\n\tfor (i=24; i >= 0; i -= 8)\n\t  printf (\"%d%c\", dng_version >> i & 255, i ? '.':'\\n');\n      }\n      printf (_(\"ISO speed: %d\\n\"), (int) iso_speed);\n      printf (_(\"Shutter: \"));\n      if (shutter > 0 && shutter < 1)\n\tshutter = (printf (\"1/\"), 1 / shutter);\n      printf (_(\"%0.1f sec\\n\"), shutter);\n      printf (_(\"Aperture: f/%0.1f\\n\"), aperture);\n      printf (_(\"Focal length: %0.1f mm\\n\"), focal_len);\n      printf (_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\"):_(\"no\"));\n      printf (_(\"Number of raw images: %d\\n\"), is_raw);\n      if (pixel_aspect != 1)\n\tprintf (_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);\n      if (thumb_offset)\n\tprintf (_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);\n      printf (_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);\n    } else if (!is_raw)\n      fprintf (stderr,_(\"Cannot decode file %s\\n\"), ifname);\n    if (!is_raw) goto next;\n    shrink = filters && (half_size || (!identify_only &&\n\t(threshold || aber[0] != 1 || aber[2] != 1)));\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (identify_only) {\n      if (verbose) {\n\tif (document_mode == 3) {\n\t  top_margin = left_margin = fuji_width = 0;\n\t  height = raw_height;\n\t  width  = raw_width;\n\t}\n\tiheight = (height + shrink) >> shrink;\n\tiwidth  = (width  + shrink) >> shrink;\n\tif (use_fuji_rotate) {\n\t  if (fuji_width) {\n\t    fuji_width = (fuji_width - 1 + shrink) >> shrink;\n\t    iwidth = fuji_width / sqrt(0.5);\n\t    iheight = (iheight - fuji_width) / sqrt(0.5);\n\t  } else {\n\t    if (pixel_aspect < 1) iheight = iheight / pixel_aspect + 0.5;\n\t    if (pixel_aspect > 1) iwidth  = iwidth  * pixel_aspect + 0.5;\n\t  }\n\t}\n\tif (flip & 4)\n\t  SWAP(iheight,iwidth);\n\tprintf (_(\"Image size:  %4d x %d\\n\"), width, height);\n\tprintf (_(\"Output size: %4d x %d\\n\"), iwidth, iheight);\n\tprintf (_(\"Raw colors: %d\"), colors);\n\tif (filters) {\n\t  int fhigh = 2, fwide = 2;\n\t  if ((filters ^ (filters >>  8)) & 0xff)   fhigh = 4;\n\t  if ((filters ^ (filters >> 16)) & 0xffff) fhigh = 8;\n\t  if (filters == 1) fhigh = fwide = 16;\n\t  if (filters == 9) fhigh = fwide = 6;\n\t  printf (_(\"\\nFilter pattern: \"));\n\t  for (i=0; i < fhigh; i++)\n\t    for (c = i && putchar('/') && 0; c < fwide; c++)\n\t      putchar (cdesc[fcol(i,c)]);\n\t}\n\tprintf (_(\"\\nDaylight multipliers:\"));\n\tFORCC printf (\" %f\", pre_mul[c]);\n\tif (cam_mul[0] > 0) {\n\t  printf (_(\"\\nCamera multipliers:\"));\n\t  FORC4 printf (\" %f\", cam_mul[c]);\n\t}\n\tputchar ('\\n');\n      } else\n\tprintf (_(\"%s is a %s %s image.\\n\"), ifname, make, model);\nnext:\n      fclose(ifp);\n      continue;\n    }\n    if (meta_length) {\n      meta_data = (char *) malloc (meta_length);\n      merror (meta_data, \"main()\");\n    }\n    if (filters || colors == 1) {\n      raw_image = (ushort *) calloc ((raw_height+7), raw_width*2);\n      merror (raw_image, \"main()\");\n    } else {\n      image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);\n      merror (image, \"main()\");\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Loading %s %s image from %s ...\\n\"),\n\tmake, model, ifname);\n    if (shot_select >= is_raw)\n      fprintf (stderr,_(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"),\n\tifname, shot_select);\n    fseeko (ifp, data_offset, SEEK_SET);\n    if (raw_image && read_from_stdin)\n      fread (raw_image, 2, raw_height*raw_width, stdin);\n    else (*load_raw)();\n    if (document_mode == 3) {\n      top_margin = left_margin = fuji_width = 0;\n      height = raw_height;\n      width  = raw_width;\n    }\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (raw_image) {\n      image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);\n      merror (image, \"main()\");\n      crop_masked_pixels();\n      free (raw_image);\n    }\n    if (zero_is_bad) remove_zeroes();\n    bad_pixels (bpfile);\n    if (dark_frame) subtract (dark_frame);\n    quality = 2 + !fuji_width;\n    if (user_qual >= 0) quality = user_qual;\n    i = cblack[3];\n    FORC3 if (i > cblack[c]) i = cblack[c];\n    FORC4 cblack[c] -= i;\n    black += i;\n    i = cblack[6];\n    FORC (cblack[4] * cblack[5])\n      if (i > cblack[6+c]) i = cblack[6+c];\n    FORC (cblack[4] * cblack[5])\n      cblack[6+c] -= i;\n    black += i;\n    if (user_black >= 0) black = user_black;\n    FORC4 cblack[c] += black;\n    if (user_sat > 0) maximum = user_sat;\n#ifdef COLORCHECK\n    colorcheck();\n#endif\n    if (is_foveon) {\n      if (document_mode || load_raw == &CLASS foveon_dp_load_raw) {\n\tfor (i=0; i < height*width*4; i++)\n\t  if ((short) image[0][i] < 0) image[0][i] = 0;\n      } else foveon_interpolate();\n    } else if (document_mode < 2)\n      scale_colors();\n    pre_interpolate();\n    if (filters && !document_mode) {\n      if (quality == 0)\n\tlin_interpolate();\n      else if (quality == 1 || colors > 3)\n\tvng_interpolate();\n      else if (quality == 2 && filters > 1000)\n\tppg_interpolate();\n      else if (filters == 9)\n\txtrans_interpolate (quality*2-3);\n      else\n\tahd_interpolate();\n    }\n    if (mix_green)\n      for (colors=3, i=0; i < height*width; i++)\n\timage[i][1] = (image[i][1] + image[i][3]) >> 1;\n    if (!is_foveon && colors == 3) median_filter();\n    if (!is_foveon && highlight == 2) blend_highlights();\n    if (!is_foveon && highlight > 2) recover_highlights();\n    if (use_fuji_rotate) fuji_rotate();\n#ifndef NO_LCMS\n    if (cam_profile) apply_profile (cam_profile, out_profile);\n#endif\n    convert_to_rgb();\n    if (use_fuji_rotate) stretch();\nthumbnail:\n    if (write_fun == &CLASS jpeg_thumb)\n      write_ext = \".jpg\";\n    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)\n      write_ext = \".tiff\";\n    else\n      write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors*5-5;\n    ofname = (char *) malloc (strlen(ifname) + 64);\n    merror (ofname, \"main()\");\n    if (write_to_stdout)\n      strcpy (ofname,_(\"standard output\"));\n    else {\n      strcpy (ofname, ifname);\n      if ((cp = strrchr (ofname, '.'))) *cp = 0;\n      if (multi_out)\n\tsprintf (ofname+strlen(ofname), \"_%0*d\",\n\t\tsnprintf(0,0,\"%d\",is_raw-1), shot_select);\n      if (thumbnail_only)\n\tstrcat (ofname, \".thumb\");\n      strcat (ofname, write_ext);\n      ofp = fopen (ofname, \"wb\");\n      if (!ofp) {\n\tstatus = 1;\n\tperror (ofname);\n\tgoto cleanup;\n      }\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Writing data to %s ...\\n\"), ofname);\n    (*write_fun)();\n    fclose(ifp);\n    if (ofp != stdout) fclose(ofp);\ncleanup:\n    if (meta_data) free (meta_data);\n    if (ofname) free (ofname);\n    if (oprof) free (oprof);\n    if (image) free (image);\n    if (multi_out) {\n      if (++shot_select < is_raw) arg--;\n      else shot_select = 0;\n    }\n  }\n  return status;\n}\n#endif\n", "/* \n  Copyright 2008-2017 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return(p ? p-s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a,b) local_strnlen(a,b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n int r = fp->read(buf,len,1);\n buf[len-1] = 0;\n return r;\n}\n#define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr (char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf,sizeof(buf)-1)\n\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG\t1\n#define AdobeDNG\t2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords,int maxlen)\n{\n  line[maxlen-1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while(1)\n  {\n    while(isspace(*p)) p++;\n    if(*p == '\\0') return nwords;\n    words[nwords++] = p;\n    while(!isspace(*p) && *p != '\\0') p++;\n    if(*p == '\\0') return nwords;\n    *p++ = '\\0';\n    if(nwords >= maxwords) return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f){\n\tif ((a >> 4) > 9) return 0;\n\telse if ((a & 0x0f) > 9) return 0;\n\telse if ((b >> 4) > 9) return 0;\n\telse if ((b & 0x0f) > 9) return 0;\n\telse if ((c >> 4) > 9) return 0;\n\telse if ((c & 0x0f) > 9) return 0;\n\telse if ((d >> 4) > 9) return 0;\n\telse if ((d & 0x0f) > 9) return 0;\n\telse if ((e >> 4) > 9) return 0;\n\telse if ((e & 0x0f) > 9) return 0;\n\telse if ((f >> 4) > 9) return 0;\n\telse if ((f & 0x0f) > 9) return 0;\nreturn 1;\n}\n\nstatic ushort bcd2dec(uchar data){\n\tif ((data >> 4) > 9) return 0;\n\telse if ((data & 0x0f) > 9) return 0;\n\telse return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] = \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s)\t// specific to some Canon Makernotes fields, where they have endian in reverse\n{\n\tif (order == 0x4d4d)\t\t/* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n\t\treturn s[0] | s[1] << 8;\n\telse\t\t\t\t\t\t/* \"MM\" means big-endian... */\n\t\treturn s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u,v;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:\n      u.d = (unsigned int) get4();\n      v.d = (unsigned int)get4();\n      return u.d / (v.d ? v.d : 1);\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10:\n      u.d = (signed int) get4();\n      v.d = (signed int)get4();\n      return u.d / (v.d?v.d:1);\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS cubic_spline (const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);\n  if (!A) return;\n  A[0] = (float *) (A + 2*len);\n  for (i = 1; i < 2*len; i++)\n    A[i] = A[0] + 2*len*i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));\n  for (i = 0; i < len; i++) {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len-1; i > 0; i--) {\n    b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);\n    d[i-1] = x[i] - x[i-1];\n  }\n  for (i = 1; i < len-1; i++) {\n    A[i][i] = 2 * (d[i-1] + d[i]);\n    if (i > 1) {\n      A[i][i-1] = d[i-1];\n      A[i-1][i] = d[i-1];\n    }\n    A[i][len-1] = 6 * (b[i+1] - b[i]);\n  }\n  for(i = 1; i < len-2; i++) {\n    float v = A[i+1][i] / A[i][i];\n    for(j = 1; j <= len-1; j++)\n      A[i+1][j] -= v * A[i][j];\n  }\n  for(i = len-2; i > 0; i--) {\n    float acc = 0;\n    for(j = i; j <= len-2; j++)\n      acc += A[i][j]*c[j];\n    c[i] = (A[i][len-1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++) {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len-1; j++) {\n      if (x[j] <= x_out && x_out <= x[j+1]) {\n\tfloat v = x_out - x[j];\n\ty_out = y[j] +\n\t  ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v\n\t   + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :\n\t\t(ushort)(y_out * 65535.0 + 0.5));\n  }\n  free (A);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25) return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row+=8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    FORC(2) free (huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free (huff[c]);\n}\n\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;\n  do {\n    if(feof(ifp)) return 0;\n    if(cnt++ > 1024) return 0; // 1024 tags limit\n    if (!fread (data, 2, 2, ifp)) return 0;\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:        // start of frame; lossless, Huffman\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc1:\n      case 0xffc0:\n\tjh->algo = tag & 0xff;\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:          // define Huffman tables\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && !((c = *dp++) & -20); )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:          // start of scan\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdb:\n\tFORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 ||\n     !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;\n  if (info_only) return 1;\n  if (!jh->huff[0]) return 0;\n  FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n  if(!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row=0, col=0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if(jh.clrs == 4 && jwide >= raw_width*2) jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*raw_height);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*raw_height);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp (failure, 3);\n#endif\n      if ((unsigned) row < raw_height) RAW(row,col) = val;\n      if (++col >= raw_width)\n\tcol = (row++,0);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  ljpeg_end (&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(load_flags & 256)\n  {\n\twidth = raw_width;\n\theight = raw_height;\n  }\n\n  try {\n#endif\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n\t  rp = (short *) ljpeg_row (jrow++, &jh);\n\tif (col >= width) continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC (jh.clrs-2)\n              {\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n                ip[col + (c >> 1)*width + (c & 1)][1] = ip[col + (c >> 1)*width + (c & 1)][2] = 8192;\n              }\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC (jh.clrs-2)\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else\n#endif\n          {\n            FORC (jh.clrs-2)\n              ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n          }\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n    {\n      ljpeg_end (&jh);\n      maximum = 0x3fff;\n      height = saved_h;\n      width = saved_w;\n      return;\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (row & (jh.sraw >> 1))\n    {\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n          {\n\t       ip[col][c] =  ip[col-width][c];\n          }\n          else\n          {\n              ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n          }\n    }\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB) )\n#endif\n    for ( ; rp < ip[0]; rp+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (unique_id == 0x80000218 ||\n          unique_id == 0x80000250 ||\n          unique_id == 0x80000261 ||\n          unique_id == 0x80000281 ||\n          unique_id == 0x80000287) {\n        rp[1] = (rp[1] << 2) + hue;\n        rp[2] = (rp[2] << 2) + hue;\n        pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n        pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n        pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n      } else {\n        if (unique_id < 0x80000218) rp[0] -= 512;\n        pix[0] = rp[0] + rp[2];\n        pix[2] = rp[0] + rp[1];\n        pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n      }\n      FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += tiff_samples;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select) (*rp)--;\n}\n\nvoid CLASS ljpeg_idct (struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = { 0 };\n  static const uchar zigzag[80] =\n  {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,\n    40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,\n    29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,\n    47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;\n  memset (work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];\n  for (i=1; i < 64; i++ ) {\n    len = gethuff (jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15) break;\n    coef = getbits(len);\n    if ((coef & (1 << (len-1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= MIN (is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try {\n#endif\n      switch (jh.algo) {\n      case 0xc1:\n\tjh.vpred[0] = 16384;\n\tgetbits(-1);\n\tfor (jrow=0; jrow+7 < jh.high; jrow += 8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  for (jcol=0; jcol+7 < jh.wide; jcol += 8) {\n\t    ljpeg_idct (&jh);\n\t    rp = jh.idct;\n\t    row = trow + jcol/tile_width + jrow*2;\n\t    col = tcol + jcol%tile_width;\n\t    for (i=0; i < 16; i+=2)\n\t      for (j=0; j < 8; j++)\n\t\tadobe_copy_pixel (row+i, col+j, &rp);\n\t  }\n\t}\n\tbreak;\n      case 0xc3:\n\tfor (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  rp = ljpeg_row (jrow, &jh);\n\t  for (jcol=0; jcol < jwide; jcol++) {\n\t    adobe_copy_pixel (trow+row, tcol+col, &rp);\n\t    if (++col >= tile_width || col >= raw_width)\n\t      row += 1 + (col = 0);\n\t  }\n\t}\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n    }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n    }\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (pixel);\n    throw ;\n  }\n#endif\n  free (pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width*3*tiff_bps/8;\n  if(tiff_bps <= 8)\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n  else\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n  fseek (ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char*)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for(int row = 0; row < raw_height; row++)\n    {\n      int red = fread (buf, 1, bufsize, ifp);\n      unsigned short (*ip)[4] = (unsigned short (*)[4]) image + row*width;\n      if(tiff_bps <= 8)\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[buf[col*3]];\n            ip[col][1] = curve[buf[col*3+1]];\n            ip[col][2] = curve[buf[col*3+2]];\n            ip[col][3]=0;\n          }\n      else\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[ubuf[col*3]];\n            ip[col][1] = curve[ubuf[col*3+1]];\n            ip[col][2] = curve[ubuf[col*3+2]];\n            ip[col][3]=0;\n          }\n    }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (min=row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n      i = gethuff(huff);\n      len = i & 15;\n      shl = i >> 4;\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (huff);\n    throw;\n  }\n#endif\n  free (huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col=0; col < raw_width; col++) {\n      if (!(b = col & 1)) {\n\tbitbuf = 0;\n\tFORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;\n\tFORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705*yuv[3];\n      rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];\n      rgb[2] = yuv[b] + 1.732446*yuv[2];\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"Pentax\",  \"Optio 33WR\" },\n    { 0x03, \"Nikon\",   \"E3200\" },\n    { 0x32, \"Nikon\",   \"E3700\" },\n    { 0x33, \"Olympus\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length, 2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0) return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < high; y++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5];\n\t row < raw_height && row < rend &&\n\t row < head[1]+head[3]-head[5]; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4];\n\t     col < raw_width &&\n\t     col < cend && col < head[0]+head[2]-head[4]; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  /* static */ const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2]={NULL,NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!meta_length)\n#else\n  if (half_size || !meta_length)\n#endif\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  while (entries--) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n      }\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131 || type == 137)\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    } else if (tag == 0x41f && !qlin_applied) { /* Quadrant linearization */\n      ushort lc[2][2][16], ref[16];\n      int qr, qc;\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 16; i++)\n\t    lc[qr][qc][i] = get4();\n      for (i = 0; i < 16; i++) {\n\tint v = 0;\n\tfor (qr = 0; qr < 2; qr++)\n\t  for (qc = 0; qc < 2; qc++)\n\t    v += lc[qr][qc][i];\n\tref[i] = (v + 2) >> 2;\n      }\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[19], cf[19];\n\t  for (i = 0; i < 16; i++) {\n\t    cx[1+i] = lc[qr][qc][i];\n\t    cf[1+i] = ref[i];\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n          cf[18] = cx[18] = 65535;\n\t  cubic_spline(cx, cf, 19);\n\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n\t}\n      }\n      qlin_applied = 1;\n    } else if (tag == 0x41e && !qmult_applied) { /* Quadrant multipliers */\n      float qmult[2][2] = { { 1, 1 }, { 1, 1 } };\n      get4(); get4(); get4(); get4();\n      qmult[0][0] = 1.0 + getreal(11);\n      get4(); get4(); get4(); get4(); get4();\n      qmult[0][1] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][0] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][1] = 1.0 + getreal(11);\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col=0; col < raw_width; col++) {\n\t  i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);\n\t  RAW(row,col) = LIM(i,0,65535);\n\t}\n      }\n      qmult_applied = 1;\n    } else if (tag == 0x431 && !qmult_applied) { /* Quadrant combined */\n      ushort lc[2][2][7], ref[7];\n      int qr, qc;\n      for (i = 0; i < 7; i++)\n\tref[i] = get4();\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 7; i++)\n\t    lc[qr][qc][i] = get4();\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[9], cf[9];\n\t  for (i = 0; i < 7; i++) {\n\t    cx[1+i] = ref[i];\n\t    cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[8] = cf[8] = 65535;\n\t  cubic_spline(cx, cf, 9);\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n        }\n      }\n      qmult_applied = 1;\n      qlin_applied = 1;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    }\n    free (yval[0]);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if(yval[0]) free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw()\");\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw()\");\n      if (ph1.black_col)\n        {\n          fseek (ifp, ph1.black_col, SEEK_SET);\n          read_shorts ((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height*2);\n        }\n      if (ph1.black_row)\n        {\n          fseek (ifp, ph1.black_row, SEEK_SET);\n          read_shorts ((ushort *) imgdata.rawdata.ph1_rblack[0], raw_width*2);\n        }\n      }\n#endif\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short (*)[2]) (offset + raw_height);\n  fseek (ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n      read_shorts ((ushort *) c_black[0], raw_height*2);\n  r_black = c_black + raw_height;\n  fseek (ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n      read_shorts ((ushort *) r_black[0], raw_width*2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_cblack,(ushort*)c_black[0],raw_height*2*sizeof(ushort));\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_rblack,(ushort*)r_black[0],raw_width*2*sizeof(ushort));\n    }\n#endif\n\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (col=0; col < raw_width; col++) {\n      int shift = ph1.format == 8? 0: 2;\n      i = (pixel[col] << shift) - ph1.t_black\n\t+ c_black[row][col >= ph1.split_col]\n\t+ r_black[col][row >= ph1.split_row];\n      if (i > 0) RAW(row,col) = i;\n    }\n#else\n    if(ph1.format == 8)\n      memmove(&RAW(row,0),&pixel[0],raw_width*2);\n    else\n      for (col=0; col < raw_width; col++)\n      \tRAW(row,col) = pixel[col] << 2;\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  back[4] = (int *) calloc (raw_width, 3*sizeof **back);\n  merror (back[4], \"hasselblad_load_raw()\");\n  FORC3 back[c] = back[4] + c*raw_width;\n  cblack[6] >>= sh = tiff_samples > 1;\n  shot = LIM(shot_select, 1, tiff_samples) - 1;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC4 back[(c+3) & 3] = back[c];\n    for (col=0; col < raw_width; col+=2) {\n      for (s=0; s < tiff_samples*2; s+=2) {\n\tFORC(2) len[c] = ph1_huff(jh.huff[0]);\n\tFORC(2) {\n\t  diff[s+c] = ph1_bits(len[c]);\n\t  if ((diff[s+c] & (1 << (len[c]-1))) == 0)\n\t    diff[s+c] -= (1 << len[c]) - 1;\n\t  if (diff[s+c] == 65535) diff[s+c] = -32768;\n\t}\n      }\n      for (s=col; s < col+2; s++) {\n\tpred = 0x8000 + load_flags;\n\tif (col) pred = back[2][s-2];\n\tif (col && row > 1) switch (jh.psv) {\n\t  case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;\n\t}\n\tf = (row & 1)*3 ^ ((col+s) & 1);\n\tFORC (tiff_samples) {\n\t  pred += diff[(s & 1)*tiff_samples+c];\n\t  upix = pred >> sh & 0xffff;\n\t  if (raw_image && c == shot)\n\t    RAW(row,s) = upix;\n\t  if (image) {\n\t    urow = row-top_margin  + (c & 1);\n\t    ucol = col-left_margin - ((c >> 1) & 1);\n\t    ip = &image[urow*width+ucol][f];\n\t    if (urow < height && ucol < width)\n\t      *ip = c < 4 ? upix : (*ip + upix) >> 1;\n\t  }\n\t}\n\tback[2][s] = pred;\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (back[4]);\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  free (back[4]);\n  ljpeg_end (&jh);\n  if (image) mix_green = 1;\n}\n\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n  }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n    int row, col, bits=0;\n    while (1 << ++bits < maximum);\n    for (row=raw_height-1; row >= 0; row--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcheckCancel();\n#endif\n\tread_shorts (&raw_image[row*raw_width], raw_width);\n\tfor (col=0; col < raw_width; col++)\n\t\tif ((RAW(row,col) >>= load_flags) >> bits\n\t\t\t&& (unsigned) (row-top_margin) < height\n\t\t\t&& (unsigned) (col-left_margin) < width) derror();\n    }\n}\n\n\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image) return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width*3*sizeof(unsigned short));\n  merror(buf,\"imacon_full_load_raw\");\n#endif\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf,width*3);\n    unsigned short (*rowp)[4] = &image[row*width];\n    for (col=0; col < width; col++)\n      {\n        rowp[col][0]=buf[col*3];\n        rowp[col][1]=buf[col*3+1];\n        rowp[col][2]=buf[col*3+2];\n        rowp[col][3]=0;\n      }\n#else\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < raw_width; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&\n\trow < height+top_margin && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom () {\n\n/* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek (ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread (&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right)*5)+3)>>2) + 0x1f)&(~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616;  /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order) {\n    case 0: /* RGGB */\n      filters = 0x94949494;\n      break;\n    case 1: /* GBRG */\n      filters = 0x49494949;\n      break;\n    case 3: /* GRBG */\n      filters = 0x61616161;\n      break;\n  }\n}\n\nvoid CLASS broadcom_load_raw() {\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *) malloc (raw_stride*2);\n  merror (data, \"broadcom_load_raw()\");\n\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+raw_stride, 1, raw_stride, ifp) < raw_stride) derror();\n    FORC(raw_stride) data[c] = data[raw_stride+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n  double sum[]={0,0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (data);\n    throw;\n  }\n#endif\n  free (data);\n  maximum = 0x3ff;\n  if (strncmp(make,\"OmniVision\",10)) return;\n  row = raw_height/2;\n  FORC(width-1) {\n    sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));\n    sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));\n  }\n  if (sum[1] > sum[0]) filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5*raw_width >> 5) << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_tight_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n}\n  free (data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf=0;\n\n  bwide = (raw_width+5)/6 << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_loose_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=8, col+=6) {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c^7];\n      FORC(6) RAW(row,col+c) = (bitbuf >> c*10) & 0x3ff;\n    }\n  }\n  free (data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int*)malloc(sizeof(int)*(raw_width/3+1));\n  merror(words,\"canon_rmf_load_raw\");\n#endif\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words,sizeof(int),raw_width/3,ifp);\n    for (col=0; col < raw_width-2; col+=3)\n      {\n        bits = words[col/3];\n        FORC3 {\n          orow = row;\n          if ((ocol = col+c-4) < 0)\n            {\n              ocol += raw_width;\n              if ((orow -= 2) < 0)\n                orow += raw_height;\n            }\n          RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n        }\n      }\n#else\n    for (col=0; col < raw_width-2; col+=3) {\n      bits = get4();\n      FORC3 {\n\torow = row;\n\tif ((ocol = col+c-4) < 0) {\n\t  ocol += raw_width;\n\t  if ((orow -= 2) < 0)\n\t    orow += raw_height;\n\t}\n\tRAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress (&cinfo);\n    longjmp (failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n    ((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager {\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit (j_common_ptr cinfo)\n{\n  jpegErrorManager* myerr = (jpegErrorManager*) cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if(data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf,\"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char*) malloc(width*3);\n  jpeg_create_decompress (&cinfo);\n  merror(pixel_buf,\"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf,data_size,1,ifp);\n  swab ((char*)jpg_buf, (char*)jpg_buf, data_size);\n  try\n    {\n      jpeg_mem_src(&cinfo, jpg_buf, data_size);\n      int rc = jpeg_read_header(&cinfo, TRUE);\n      if(rc!=1)\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n      jpeg_start_decompress (&cinfo);\n      if ((cinfo.output_width      != width  ) ||\n          (cinfo.output_height*2   != height ) ||\n          (cinfo.output_components != 3      ))\n        {\n          throw LIBRAW_EXCEPTION_DECODE_JPEG;\n        }\n\n      unsigned char *buf[1];\n      buf[0] = pixel_buf;\n\n      while (cinfo.output_scanline < cinfo.output_height)\n        {\n          checkCancel();\n          row = cinfo.output_scanline * 2;\n          jpeg_read_scanlines (&cinfo, buf, 1);\n          unsigned char (*pixel)[3] = (unsigned char (*)[3]) buf[0];\n          for (col=0; col < width; col+=2) {\n            RAW(row+0,col+0) = pixel[col+0][1] << 1;\n            RAW(row+1,col+1) = pixel[col+1][1] << 1;\n            RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n            RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n          }\n        }\n    }\n  catch (...)\n        {\n          jpeg_finish_decompress (&cinfo);\n          jpeg_destroy_decompress (&cinfo);\n          free(jpg_buf);\n          free(pixel_buf);\n          throw;\n        }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--) {\n      opcode = get4(); get4(); get4();\n      if (opcode != 8)\n      { fseek (ifp, get4(), SEEK_CUR); continue; }\n      fseek (ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2) break;\n      fseek (ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8) break;\n      for (i=0; i <= deg && i < 9; i++)\n\tcoeff[i] = getreal(12);\n      for (i=0; i < 256; i++) {\n\tfor (tot=j=0; j <= deg; j++)\n\t  tot += coeff[j] * pow(i/255.0, (int)j);\n\tcur[c][i] = tot*0xffff;\n      }\n    }\n    order = sorder;\n  } else {\n    gamma_curve (1/2.4, 12.92, 1, 255);\n    FORC3 memcpy (cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    jpeg_destroy_decompress (&cinfo);\n    throw;\n  }\n#endif\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;\n    }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, sum=0;\n\n  huff[0] = 15;\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--; )\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width+1);\n  merror (data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      /* flag checks if outside of loop */\n      if(! (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n         || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n         )\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else pix[i]=0;\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i=0; i < 16; i++, col+=2)\n            {\n              unsigned slope = pix[i] < 1001? 2 : curve[pix[i]<<1]-curve[(pix[i]<<1)-2];\n              unsigned step = 1 << sh;\n              RAW(row,col)=curve[pix[i]<<1]>black+imgdata.params.sony_arw2_posterization_thr?\n                LIM(((slope*step*1000)/(curve[pix[i]<<1]-black)),0,10000):0;\n            }\n        }\n      else\n        {\n          for (i=0; i < 16; i++, col+=2)\n            RAW(row,col) = curve[pix[i] << 1];\n        }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (data);\n    throw;\n  }\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum=10000;\n#endif\n  free (data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, strip_offset+row*4, SEEK_SET);\n    fseek (ifp, data_offset+get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7:4;\n    for (col=0; col < raw_width; col+=16) {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c]) {\n\tcase 3: len[c] = ph1_bits(4);\tbreak;\n\tcase 2: len[c]--;\t\tbreak;\n\tcase 1: len[c]++;\n      }\n      for (c=0; c < 16; c+=2) {\n\ti = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n\tif (c == 14) c = -1;\n      }\n    }\n  }\n  for (row=0; row < raw_height-1; row+=2)\n    for (col=0; col < raw_width-1; col+=2)\n      SWAP (RAW(row,col+1), RAW(row+1,col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] =\n  { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,\n    0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };\n  ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n=i=0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek (ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(),get2());\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0; pmode = 7;\n    FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;\n    prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1));\t// green\n    prow[~row & 1] = &RAW(row-2,0);\t\t\t// red and blue\n    for (tab=0; tab+15 < raw_width; tab+=16) {\n      if (~opt & 4 && !(tab & 63)) {\n\ti = ph1_bits(2);\n\tmag = i < 3 ? mag-'2'+\"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n\tpmode = 7 - 4*ph1_bits(1);\n      else if (!ph1_bits(1))\n\tpmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1)) {\n\tFORC4 len[c] = ph1_bits(2);\n\tFORC4 {\n\t  i = ((row & 1) << 1 | (c & 1)) % 3;\n\t  len[c] = len[c] < 3 ? lent[i][0]-'1'+\"120\"[len[c]] : ph1_bits(4);\n\t  lent[i][0] = lent[i][1];\n\t  lent[i][1] = len[c];\n\t}\n      }\n      FORC(16) {\n\tcol = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));\n\tpred = (pmode == 7 || row < 2)\n\t     ? (tab ? RAW(row,tab-2+(col & 1)) : init)\n\t     : (prow[col & 1][col-'4'+\"0224468\"[pmode]] +\n\t\tprow[col & 1][col-'4'+\"0244668\"[pmode]] + 1) >> 1;\n\tdiff = ph1_bits (i = len[c >> 2]);\n\tif (diff >> (i-1)) diff -= 1 << i;\n\tdiff = diff * (mag*2+1) + mag;\n\tRAW(row,col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width*raw_height)\n       seg[1][0] = raw_width*raw_height;\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n            ((data + (((data & (1 << (nbits-1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(pix>=raw_width*raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar) fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n    {\n      jas_stream_close (in);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n    }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2), (width+2)*2);\n  merror (img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try {\n#endif\n  FORC4 {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    fastexitflag=true;\n  }\n#endif\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n    c, m, mblack[8], zero, val;\n#else\n    c, m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3] > 0) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)\n      for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n\nstatic const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if(num > 0.00001)\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] /= num;\n        pre_mul[i] = 1 / num;\n      }\n    else\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] = 0.0;\n        pre_mul[i] = 1.0;\n      }\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER2(row,col);\n\tBAYER2(row,col) = black + (BAYER2(row,col)-black)/2;\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (pass=0; pass < 2; pass++) {\n    for (raw_color = i=0; i < colors; i++)\n      for (j=0; j < 3; j++)\n\tfor (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\t  cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff (rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq=0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)\n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(load_raw == &LibRaw::nikon_load_sraw)\n      {\n        // Nikon sRAW: camera WB already applied:\n        pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;\n      }\n    else\n#endif\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw\n      && !use_camera_wb && !use_auto_wb\n      && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )\n    {\n      for(c=0;c<3;c++)\n        pre_mul[c]/=cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0) pre_mul[1] = 1;\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {\n    FORC4 cblack[FC(c/2,c%2)] +=\n\tcblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    if (!(val = ((ushort *)image)[i])) continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +\n\t\t\ti/4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n      if (filters == 9) {\n\tfor (row=0; row < 3; row++)\n\t  for (col=1; col < 4; col++)\n\t    if (!(image[row*width+col][0] | image[row*width+col][2]))\n\t      goto break2;  break2:\n\tfor ( ; row < height; row+=3)\n\t  for (col=(col-1)%3+1; col < width-1; col+=3) {\n\t    img = image + row*width+col;\n\t    for (c=0; c < 3; c+=2)\n\t      img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n\t  }\n      }\n    } else {\n      img = (ushort (*)[4]) calloc (height, width*sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size) colors++;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 9) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = sum[c]>0?256 / sum[c]:0;\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,-128, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,-120, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,-128, +0,-1,+0,+1,1,-120, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,-128,\n    +1,-1,+1,+1,0,-120, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 9) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab (ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb) {\n#ifndef LIBRAW_NOTHREADS\n    if(cbrt[0] < -1.0f)\n#endif\n    for (i=0; i < 0x10000; i++) {\n      r = i / 65535.0;\n      cbrt[i] = r > 0.008856 ? pow(r,1.f/3.0f) : 7.787f*r + 16.f/116.0f;\n    }\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (xyz_cam[i][j] = k=0; k < 3; k++)\n\t  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int) xyz[0])];\n  xyz[1] = cbrt[CLIP((int) xyz[1])];\n  xyz[2] = cbrt[CLIP((int) xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512\t\t/* Tile Size */\n#define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate (int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int cstat[4]={0,0,0,0};\n#endif\n\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },\n\tpatt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },\n\t\t\t{ 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },\n\tdir[4] = { 1,TS,TS+1,TS-1 };\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)    [TS][3], (*lix)[3];\n   float (*drv)[TS][TS], diff[6], tr;\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/* Check against right pattern */\n  for (row = 0; row < 6; row++)\n         for (col = 0; col < 6; col++)\n                 cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16 \n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n         throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n\n  cielab (0,0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *) malloc (TS*TS*(ndir*11+6));\n  merror (buffer, \"xtrans_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));\n  drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));\n  homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));\n\n/* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row=0; row < 3; row++)\n    for (col=0; col < 3; col++)\n      for (ng=d=0; d < 10; d+=2) {\n\tg = fcol(row,col) == 1;\n\tif (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;\n\tif (ng == 4) { sgrow = row; sgcol = col; }\n\tif (ng == g+1) FORC(8) {\n\t  v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];\n\t  h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];\n\t  allhex[row][col][0][c^(g*2 & d)] = h + v*width;\n\t  allhex[row][col][1][c^(g*2 & d)] = h + v*TS;\n\t}\n      }\n\n/* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row=2; row < height-2; row++)\n    for (min=~(max=0), col=2; col < width-2; col++) {\n      if (fcol(row,col) == 1 && (min=~(max=0))) continue;\n      pix = image + row*width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max) FORC(6) {\n\tval = pix[hex[c]][1];\n\tif (min > val) min = val;\n\tif (max < val) max = val;\n      }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row-sgrow) % 3) {\n\tcase 1: if (row < height-3) { row++; col--; } break;\n\tcase 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;\n      }\n    }\n\n  for (top=3; top < height-19; top += TS-16)\n    for (left=3; left < width-19; left += TS-16) {\n      mrow = MIN (top+TS, height-3);\n      mcol = MIN (left+TS, width-3);\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++)\n\t  memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);\n      FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);\n\n/* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++) {\n\t  if ((f = fcol(row,col)) == 1) continue;\n\t  pix = image + row*width + col;\n\t  hex = allhex[row % 3][col % 3][0];\n\t  color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -\n\t\t\t 46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);\n\t  color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +\n\t\t\t 92 * (pix[      0 ][f] - pix[ -hex[2]][f]);\n\t  FORC(2) color[1][2+c] =\n\t\t164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *\n\t\t(2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);\n\t  FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =\n\t\tLIM(color[1][c] >> 8,pix[0][1],pix[0][3]);\n\t}\n\n      for (pass=0; pass < passes; pass++) {\n\tif (pass == 1)\n\t  memcpy (rgb+=4, buffer, 4*sizeof *rgb);\n\n/* Recalculate green from interpolated values of closer pixels:\t*/\n\tif (pass) {\n\t  for (row=top+2; row < mrow-2; row++)\n\t    for (col=left+2; col < mcol-2; col++) {\n\t      if ((f = fcol(row,col)) == 1) continue;\n\t      pix = image + row*width + col;\n\t      hex = allhex[row % 3][col % 3][1];\n\t      for (d=3; d < 6; d++) {\n\t\trix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];\n\t\tval = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]\n\t\t    - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];\n\t\trix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);\n\t      }\n\t    }\n\t}\n\n/* Interpolate red and blue values for solitary green pixels:\t*/\n\tfor (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)\n\t  for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    h = fcol(row,col+1);\n\t    memset (diff, 0, sizeof diff);\n\t    for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {\n\t      for (c=0; c < 2; c++, h^=2) {\n\t\tg = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];\n\t\tcolor[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];\n\t\tif (d > 1)\n\t\t  diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]\n\t\t\t\t- rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);\n\t      }\n\t      if (d > 1 && (d & 1))\n\t\tif (diff[d-1] < diff[d])\n\t\t  FORC(2) color[c*2][d] = color[c*2][d-1];\n\t      if (d < 2 || (d & 1)) {\n\t\tFORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);\n\t\trix += TS*TS;\n\t      }\n\t    }\n\t  }\n\n/* Interpolate red for blue pixels and vice versa:\t\t*/\n\tfor (row=top+3; row < mrow-3; row++)\n\t  for (col=left+3; col < mcol-3; col++) {\n\t    if ((f = 2-fcol(row,col)) == 1) continue;\n\t    rix = &rgb[0][row-top][col-left];\n\t    c = (row-sgrow) % 3 ? TS:1;\n\t    h = 3 * (c ^ TS ^ 1);\n\t    for (d=0; d < 4; d++, rix += TS*TS) {\n\t      i = d > 1 || ((d ^ c) & 1) ||\n\t\t ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <\n\t\t2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;\n\t      rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +\n\t\t  2*rix[0][1] - rix[i][1] - rix[-i][1])/2);\n\t    }\n\t  }\n\n/* Fill in red and blue for 2x2 blocks of green:\t\t*/\n\tfor (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)\n\t  for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    hex = allhex[row % 3][col % 3][1];\n\t    for (d=0; d < ndir; d+=2, rix += TS*TS)\n\t      if (hex[d] + hex[d+1]) {\n\t\tg = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);\n\t      } else {\n\t\tg = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);\n\t      }\n\t  }\n      }\n      rgb = (ushort(*)[TS][TS][3]) buffer;\n      mrow -= top;\n      mcol -= left;\n\n/* Convert to CIELab and differentiate in all directions:\t*/\n      for (d=0; d < ndir; d++) {\n\tfor (row=2; row < mrow-2; row++)\n\t  for (col=2; col < mcol-2; col++)\n\t    cielab (rgb[d][row][col], lab[row][col]);\n\tfor (f=dir[d & 3],row=3; row < mrow-3; row++)\n\t  for (col=3; col < mcol-3; col++) {\n\t    lix = &lab[row][col];\n\t    g = 2*lix[0][0] - lix[f][0] - lix[-f][0];\n\t    drv[d][row][col] = SQR(g)\n\t      + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))\n\t      + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));\n\t  }\n      }\n\n/* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir*TS*TS);\n      for (row=4; row < mrow-4; row++)\n\tfor (col=4; col < mcol-4; col++) {\n\t  for (tr=FLT_MAX, d=0; d < ndir; d++)\n\t    if (tr > drv[d][row][col])\n\t\ttr = drv[d][row][col];\n\t  tr *= 8;\n\t  for (d=0; d < ndir; d++)\n\t    for (v=-1; v <= 1; v++)\n\t      for (h=-1; h <= 1; h++)\n\t\tif (drv[d][row+v][col+h] <= tr)\n\t\t  homo[d][row][col]++;\n\t}\n\n/* Average the most homogenous pixels for the final result:\t*/\n      if (height-top < TS+4) mrow = height-top+2;\n      if (width-left < TS+4) mcol = width-left+2;\n      for (row = MIN(top,8); row < mrow-8; row++)\n\tfor (col = MIN(left,8); col < mcol-8; col++) {\n\t  for (d=0; d < ndir; d++)\n\t    for (hm[d]=0, v=-2; v <= 2; v++)\n\t      for (h=-2; h <= 2; h++)\n\t\thm[d] += homo[d][row+v][col+h];\n\t  for (d=0; d < ndir-4; d++)\n\t    if (hm[d] < hm[d+4]) hm[d  ] = 0; else\n\t    if (hm[d] > hm[d+4]) hm[d+4] = 0;\n\t  for (max=hm[0],d=1; d < ndir; d++)\n\t    if (max < hm[d]) max = hm[d];\n\t  max -= max >> 3;\n\t  memset (avg, 0, sizeof avg);\n\t  for (d=0; d < ndir; d++)\n\t    if (hm[d] >= max) {\n\t      FORC3 avg[c] += rgb[d][row][col][c];\n\t      avg[3]++;\n\t    }\n\t  FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];\n\t}\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0],lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n\n  cielab(0,0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {\n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab (0,0);\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row=top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    cielab (rix[0],lix[0]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high, wide*sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nstatic float powf_lim(float a, float b, float limup)\n{\n  return (b>limup || b < -limup)?0.f:powf(a,b);\n}\nstatic float powf64(float a, float b)\n{\n  return powf_lim(a,b,64.f);\n}\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x) {\n  float t;\n  if (x >= 0.0) {\n    t = ceilf(x);\n    if (t - x > 0.5) t -= 1.0;\n    return t;\n  } else {\n    t = ceilf(-x);\n    if (t + x > 0.5) t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff)) return 0.0f;\n  return powf64(2.0, in/64.0);\n}\n\nstatic float _CanonConvertEV (short in)\n{\n\tshort EV, Sign, Frac;\n\tfloat Frac_f;\n\tEV = in;\n\tif (EV < 0) {\n\t  EV = -EV;\n\t  Sign = -1;\n\t} else {\n\t  Sign = 1;\n\t}\n\tFrac = EV & 0x1f;\n\tEV -= Frac;\t\t\t// remove fraction\n\n\tif (Frac == 0x0c) {\t\t// convert 1/3 and 2/3 codes\n\t  Frac_f = 32.0f / 3.0f;\n\t} else if (Frac == 0x14) {\n\t  Frac_f = 64.0f / 3.0f;\n\t} else Frac_f = (float) Frac;\n\n\treturn ((float)Sign * ((float)EV + Frac_f))/32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures (unsigned id)\n      {\n      imgdata.lens.makernotes.CamID = id;\n\tif (\n            (id == 0x80000001) ||\t// 1D\n            (id == 0x80000174) ||\t// 1D2\n            (id == 0x80000232) ||\t// 1D2N\n            (id == 0x80000169) ||\t// 1D3\n            (id == 0x80000281)\t\t// 1D4\n            )\n          {\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n          }\n        else\n          if (\n              (id == 0x80000167) ||\t// 1Ds\n              (id == 0x80000188) ||\t// 1Ds2\n              (id == 0x80000215) ||\t// 1Ds3\n              (id == 0x80000269) ||\t// 1DX\n              (id == 0x80000328) ||\t// 1DX2\n              (id == 0x80000324) ||\t// 1DC\n              (id == 0x80000213) ||\t// 5D\n              (id == 0x80000218) ||\t// 5D2\n              (id == 0x80000285) ||\t// 5D3\n              (id == 0x80000349) ||\t// 5D4\n              (id == 0x80000382) ||\t// 5DS\n              (id == 0x80000401) ||\t// 5DS R\n              (id == 0x80000302) \t// 6D\n              )\n            {\n              imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n            }\n          else\n            if (\n                (id == 0x80000331) ||\t// M\n                (id == 0x80000355) ||\t// M2\n                (id == 0x80000374) || \t// M3\n                (id == 0x80000384) || \t// M10\n                (id == 0x80000394)  \t// M5\n                )\n              {\n                imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n              }\n            else\n              if (\n                  (id == 0x01140000) ||\t// D30\n                  (id == 0x01668000) ||\t// D60\n                  (id > 0x80000000)\n                  )\n                {\n                  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n                }\n              else\n                {\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                }\n\n\treturn;\n      }\n\nvoid CLASS processCanonCameraInfo (unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0;\n  if(maxlen<16) return; // too short, so broken\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id) {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal  = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12)) iCanonLensID = 151;\n    else iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n    {\n      if(iCanonFocalType>=maxlen) return; // broken;\n      imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n      if (!imgdata.lens.makernotes.FocalType)\t// zero means 'fixed' here, replacing with standard '1'\n        imgdata.lens.makernotes.FocalType = 1;\n    }\n  if (!imgdata.lens.makernotes.CurFocal)\n    {\n      if(iCanonCurFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n    }\n  if (!imgdata.lens.makernotes.LensID)\n    {\n      if(iCanonLensID>=maxlen) return; // broken;\n      imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n    }\n  if (!imgdata.lens.makernotes.MinFocal)\n    {\n      if(iCanonMinFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n    }\n  if (!imgdata.lens.makernotes.MaxFocal)\n    {\n      if(iCanonMaxFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n    }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens) {\n    if(iCanonLens+64>=maxlen) return; // broken;\n    if (CameraInfo[iCanonLens] < 65)\t\t\t\t\t\t\t\t// non-Canon lens\n      {\n        memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n      }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n      {\n        memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n        memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n        memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings ()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2(); get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2(); get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2(); get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets (int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2) fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets (short WBCTversion)\n{\n\tif (WBCTversion == 0)\n\t  for (int i=0; i<15; i++)// tint, as shot R, as shot B, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if (WBCTversion == 1)\n\t  for (int i=0; i<15; i++)\t// as shot R, as shot B, tint, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n\t\t((unique_id == 0x80000374) ||\t// M3\n\t\t (unique_id == 0x80000384) ||\t// M10\n\t\t (unique_id == 0x80000394) ||\t// M5\n\t\t (unique_id == 0x03970000)))\t// G7 X Mark II\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n                ((unique_id == 0x03950000) || (unique_id == 0x03930000)))\t// G5 X, G9 X\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\treturn;\n}\n\nvoid CLASS processNikonLensData (uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n  else\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n    {\n      if (imgdata.lens.nikon.NikonLensType & 0x04)\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n      else\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n      imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n    {\n      imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n      imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20) {\n    switch (len) {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n      {\n        if ((LensData[i - 1]) &&\n            (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n          imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n        if (LensData[i + 7]) imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n      }\n    imgdata.lens.makernotes.LensID =\n      (unsigned long long) LensData[i] << 56 |\n      (unsigned long long) LensData[i + 1] << 48 |\n      (unsigned long long) LensData[i + 2] << 40 |\n      (unsigned long long) LensData[i + 3] << 32 |\n      (unsigned long long) LensData[i + 4] << 24 |\n      (unsigned long long) LensData[i + 5] << 16 |\n      (unsigned long long) LensData[i + 6] << 8 |\n      (unsigned long long) imgdata.lens.nikon.NikonLensType;\n\n  }\n  else if ((len == 459) || (len == 590))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n    }\n  else if (len == 509)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n    }\n  else if (len == 879)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n    }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures (unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) ||\t// E-1\n      (id == 0x4434303431ULL) ||\t// E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n\t  if ((id == 0x4434303430ULL) ||\t// E-1\n      \t  (id == 0x4434303431ULL) ||\t// E-330\n      \t  ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n      \t  (id == 0x5330303233ULL) ||\t// E-620\n      \t  (id == 0x5330303239ULL) ||\t// E-450\n      \t  (id == 0x5330303330ULL) ||\t// E-600\n      \t  (id == 0x5330303333ULL))\t\t// E-5\n      {\n      \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n      }\n  \telse\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n      }\n  }\n  else\n  {\n      imgdata.lens.makernotes.LensMount =\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes (unsigned tag, unsigned type, unsigned len) {\n\nif (tag == 0x0001) Canon_CameraSettings();\n        else if (tag == 0x0002)\t\t\t// focal length\n          {\n            imgdata.lens.makernotes.FocalType = get2();\n            imgdata.lens.makernotes.CurFocal = get2();\n            if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n              {\n                imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n              }\n          }\n\n        else if (tag == 0x0004)\t\t\t// shot info\n          {\n            short tempAp;\n            fseek(ifp, 30, SEEK_CUR);\n            imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n            fseek(ifp, 8-32, SEEK_CUR);\n            if ((tempAp = get2()) != 0x7fff)\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n            if (imgdata.lens.makernotes.CurAp < 0.7f)\n            {\n              fseek(ifp, 32, SEEK_CUR);\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n            }\n            if (!aperture) aperture = imgdata.lens.makernotes.CurAp;\n          }\n\n        else if (tag == 0x0095 &&\t\t// lens model tag\n                 !imgdata.lens.makernotes.Lens[0])\n          {\n            fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            if (imgdata.lens.makernotes.Lens[0] < 65)\t\t\t\t\t// non-Canon lens\n              fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n            else\n              {\n                char efs[2];\n                imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n                imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n                fread(efs, 2, 1, ifp);\n                if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n                  {\t// \"EF-S, TS-E, MP-E, EF-M\" lenses\n                    imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n                    imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n                    imgdata.lens.makernotes.Lens[4] = 32;\n                    if (efs[1] == 83)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n                        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n                      }\n                    else if (efs[1] == 77)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n                      }\n                  }\n                else\n                  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \"EF\" lenses\n                    imgdata.lens.makernotes.Lens[2] = 32;\n                    imgdata.lens.makernotes.Lens[3] = efs[0];\n                    imgdata.lens.makernotes.Lens[4] = efs[1];\n                  }\n                fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n              }\n          }\n\n        else if (tag == 0x00a9)\n          {\n            long int save1 = ftell(ifp);\n            fseek (ifp, save1+(0x5<<1), SEEK_SET);\n            Canon_WBpresets(0,0);\n            fseek (ifp, save1, SEEK_SET);\n          }\n\n        else if (tag == 0x00e0)\t\t\t// sensor info\n          {\n            imgdata.makernotes.canon.SensorWidth           = (get2(),get2());\n            imgdata.makernotes.canon.SensorHeight          = get2();\n            imgdata.makernotes.canon.SensorLeftBorder      = (get2(),get2(),get2());\n            imgdata.makernotes.canon.SensorTopBorder       = get2();\n            imgdata.makernotes.canon.SensorRightBorder     = get2();\n            imgdata.makernotes.canon.SensorBottomBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskLeftBorder   = get2();\n            imgdata.makernotes.canon.BlackMaskTopBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskRightBorder  = get2();\n            imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n          }\n\n    else if (tag == 0x4001 && len > 500)\n      {\n        int c;\n        long int save1 = ftell(ifp);\n        switch (len)\n          {\n          case 582:\n            imgdata.makernotes.canon.CanonColorDataVer = 1;\t// 20D / 350D\n            {\n            \tfseek (ifp, save1+(0x23<<1), SEEK_SET);\n            \tCanon_WBpresets(2,2);\n            \tfseek (ifp, save1+(0x4b<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 653:\n            imgdata.makernotes.canon.CanonColorDataVer = 2;\t// 1Dmk2 / 1DsMK2\n            {\n            \tfseek (ifp, save1+(0x27<<1), SEEK_SET);\n            \tCanon_WBpresets(2,12);\n            \tfseek (ifp, save1+(0xa4<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 796:\n            imgdata.makernotes.canon.CanonColorDataVer = 3;\t// 1DmkIIN / 5D / 30D / 400D\n\t    imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n\t    {\n\t      fseek (ifp, save1+(0x4e<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0x85<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n\t      fseek (ifp, save1+(0x0c4<<1), SEEK_SET); // offset 196 short\n\t      int bls=0;\n\t      FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n\t      imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n\t    }\n\t    break;\n            // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n            // 7D / 40D / 50D / 60D / 450D / 500D\n            // 550D / 1000D / 1100D\n          case 674: case 692: case 702: case 1227: case 1250:\n          case 1251: case 1337: case 1338: case 1346:\n            imgdata.makernotes.canon.CanonColorDataVer = 4;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n\t      fseek (ifp, save1+(0x53<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0xa8<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0e7<<1), SEEK_SET); // offset 231 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4)\n                || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n              {\n                fseek (ifp, save1+(0x2b9<<1), SEEK_SET);\t\t// offset 697 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n                     (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n              {\n                fseek (ifp, save1+(0x2d0<<1), SEEK_SET);\t\t// offset 720 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n              {\n                fseek (ifp, save1+(0x2d4<<1), SEEK_SET);\t\t// offset 724 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n          case 5120:\n            imgdata.makernotes.canon.CanonColorDataVer = 5;\t// PowerSot G10, G12, G5 X, EOS M3, EOS M5\n            {\n              fseek (ifp, save1+(0x56<<1), SEEK_SET);\n              if ((unique_id == 0x03970000) || // G7 X Mark II\n                  (unique_id == 0x80000394))   // EOS M5\n              {\n                fseek(ifp, 18, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                fseek(ifp, 8, SEEK_CUR);\n                Canon_WBpresets(8,24);\n                fseek(ifp, 168, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n                fseek(ifp, 24, SEEK_CUR);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek(ifp, 6, SEEK_CUR);\n              }\n              else\n              {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                get2();\n                Canon_WBpresets(2,12);\n                fseek (ifp, save1+(0xba<<1), SEEK_SET);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek (ifp, save1+(0x108<<1), SEEK_SET);  // offset 264 short\n              }\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            break;\n\n          case 1273: case 1275:\n            imgdata.makernotes.canon.CanonColorDataVer = 6;\t// 600D / 1200D\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x67<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xbc<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0fb<<1), SEEK_SET);\t\t\t// offset 251 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            fseek (ifp, save1+(0x1e4<<1), SEEK_SET);\t\t\t// offset 484 shorts\n            imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n            FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n            break;\n\n            // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n          case 1312: case 1313: case 1316: case 1506:\n            imgdata.makernotes.canon.CanonColorDataVer = 7;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x80<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xd5<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x114<<1), SEEK_SET);\t\t\t// offset 276 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n              {\n                fseek (ifp, save1+(0x1fd<<1), SEEK_SET);\t\t// offset 509 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              } else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n              {\n                fseek (ifp, save1+(0x2dd<<1), SEEK_SET);\t\t// offset 733 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n            // 5DS / 5DS R / 80D / 1300D / 5D4\n          case 1560: case 1592: case 1353:\n            imgdata.makernotes.canon.CanonColorDataVer = 8;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x85<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0x107<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x146<<1), SEEK_SET);\t\t\t// offset 326 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n              if (imgdata.makernotes.canon.CanonColorDataSubVer == 14)  // 1300D\n                {\n                  fseek (ifp, save1+(0x231<<1), SEEK_SET);\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n              else\n                {\n                  fseek (ifp, save1+(0x30f<<1), SEEK_SET);\t\t// offset 783 shorts\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n            break;\n\n          }\n        fseek (ifp, save1, SEEK_SET);\n      }\n}\n\nvoid CLASS setPentaxBodyFeatures (unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id) {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO (ushort c)\n{\n  int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};\n  double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};\n#define numel (sizeof(code)/sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++) {\n    if (code[i] == c) {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel) iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo (unsigned id, unsigned len)\t// tag 0x0207\n{\n\tushort iLensData = 0;\n\tuchar *table_buf;\n\ttable_buf = (uchar*)malloc(MAX(len,128));\n\tfread(table_buf, len, 1, ifp);\n\tif ((id < 0x12b9c)  ||\n        (((id == 0x12b9c)   ||  // K100D\n          (id == 0x12b9d)   ||  // K110D\n          (id == 0x12ba2)) &&   // K100D Super\n\t\t ((!table_buf[20] ||\n\t\t  (table_buf[20] == 0xff)))))\n\t  {\n\t\tiLensData = 3;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t(((unsigned)table_buf[0]) << 8) + table_buf[1];\n\t  }\n\telse switch (len)\n\t  {\n\t  case 90:\t\t\t\t\t\t\t// LensInfo3\n\t\tiLensData = 13;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 91:\t\t\t\t\t\t\t// LensInfo4\n\t\tiLensData = 12;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 80:\t\t\t\t\t\t\t// LensInfo5\n\t  case 128:\n\t\tiLensData = 15;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) <<8) + table_buf[5];\n\t\tbreak;\n\t  default:\n\t\tif (id >= 0x12b9c)\t\t\t\t// LensInfo2\n\t\t  {\n\t\t\tiLensData = 4;\n\t\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t\t((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) <<8) + table_buf[3];\n\t\t  }\n\t  }\n\tif (iLensData)\n\t  {\n\t\tif (table_buf[iLensData+9] &&\n\t\t\t(fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n\t\t  imgdata.lens.makernotes.CurFocal =\n\t\t\t10*(table_buf[iLensData+9]>>2) * powf64(4, (table_buf[iLensData+9] & 0x03)-2);\n\t\tif (table_buf[iLensData+10] & 0xf0)\n\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0xf0) >>4)/4.0f);\n\t\tif (table_buf[iLensData+10] & 0x0f)\n\t\t  imgdata.lens.makernotes.MinAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0x0f) + 10)/4.0f);\n\n\t\tif (iLensData != 12)\n\t\t  {\n\t\t\tswitch (table_buf[iLensData] & 0x06)\n\t\t\t  {\n\t\t\t  case 0: imgdata.lens.makernotes.MinAp4MinFocal = 22.0f; break;\n\t\t\t  case 2: imgdata.lens.makernotes.MinAp4MinFocal = 32.0f; break;\n\t\t\t  case 4: imgdata.lens.makernotes.MinAp4MinFocal = 45.0f; break;\n\t\t\t  case 6: imgdata.lens.makernotes.MinAp4MinFocal = 16.0f; break;\n\t\t\t  }\n\t\t\tif (table_buf[iLensData] & 0x70)\n\t\t\t  imgdata.lens.makernotes.LensFStops =\n\t\t\t\t((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n\t\t\timgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData+3] & 0xf8);\n\t\t\timgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData+3] & 0x07);\n\n\t\t\tif ((table_buf[iLensData+14] > 1) &&\n\t\t\t\t(fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+14] & 0x7f) -1)/32.0f);\n\t\t  }\n\t\telse if ((id != 0x12e76) &&\t// K-5\n\t\t\t\t (table_buf[iLensData+15] > 1) &&\n\t\t\t\t (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t  {\n\t\t\timgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t  powf64(2.0f, (float)((table_buf[iLensData+15] & 0x7f) -1)/32.0f);\n\t\t  }\n\t  }\n\tfree(table_buf);\n\treturn;\n}\n\nvoid CLASS setPhaseOneFeatures (unsigned id) {\n\n  ushort i;\n  static const struct {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n    // Phase One section:\n    {1, \"Hasselblad V\"},\n    {10, \"PhaseOne/Mamiya\"},\n    {12, \"Contax 645\"},\n    {16, \"Hasselblad V\"},\n    {17, \"Hasselblad V\"},\n    {18, \"Contax 645\"},\n    {19, \"PhaseOne/Mamiya\"},\n    {20, \"Hasselblad V\"},\n    {21, \"Contax 645\"},\n    {22, \"PhaseOne/Mamiya\"},\n    {23, \"Hasselblad V\"},\n    {24, \"Hasselblad H\"},\n    {25, \"PhaseOne/Mamiya\"},\n    {32, \"Contax 645\"},\n    {34, \"Hasselblad V\"},\n    {35, \"Hasselblad V\"},\n    {36, \"Hasselblad H\"},\n    {37, \"Contax 645\"},\n    {38, \"PhaseOne/Mamiya\"},\n    {39, \"Hasselblad V\"},\n    {40, \"Hasselblad H\"},\n    {41, \"Contax 645\"},\n    {42, \"PhaseOne/Mamiya\"},\n    {44, \"Hasselblad V\"},\n    {45, \"Hasselblad H\"},\n    {46, \"Contax 645\"},\n    {47, \"PhaseOne/Mamiya\"},\n    {48, \"Hasselblad V\"},\n    {49, \"Hasselblad H\"},\n    {50, \"Contax 645\"},\n    {51, \"PhaseOne/Mamiya\"},\n    {52, \"Hasselblad V\"},\n    {53, \"Hasselblad H\"},\n    {54, \"Contax 645\"},\n    {55, \"PhaseOne/Mamiya\"},\n    {67, \"Hasselblad V\"},\n    {68, \"Hasselblad H\"},\n    {69, \"Contax 645\"},\n    {70, \"PhaseOne/Mamiya\"},\n    {71, \"Hasselblad V\"},\n    {72, \"Hasselblad H\"},\n    {73, \"Contax 645\"},\n    {74, \"PhaseOne/Mamiya\"},\n    {76, \"Hasselblad V\"},\n    {77, \"Hasselblad H\"},\n    {78, \"Contax 645\"},\n    {79, \"PhaseOne/Mamiya\"},\n    {80, \"Hasselblad V\"},\n    {81, \"Hasselblad H\"},\n    {82, \"Contax 645\"},\n    {83, \"PhaseOne/Mamiya\"},\n    {84, \"Hasselblad V\"},\n    {85, \"Hasselblad H\"},\n    {86, \"Contax 645\"},\n    {87, \"PhaseOne/Mamiya\"},\n    {99, \"Hasselblad V\"},\n    {100, \"Hasselblad H\"},\n    {101, \"Contax 645\"},\n    {102, \"PhaseOne/Mamiya\"},\n    {103, \"Hasselblad V\"},\n    {104, \"Hasselblad H\"},\n    {105, \"PhaseOne/Mamiya\"},\n    {106, \"Contax 645\"},\n    {112, \"Hasselblad V\"},\n    {113, \"Hasselblad H\"},\n    {114, \"Contax 645\"},\n    {115, \"PhaseOne/Mamiya\"},\n    {131, \"Hasselblad V\"},\n    {132, \"Hasselblad H\"},\n    {133, \"Contax 645\"},\n    {134, \"PhaseOne/Mamiya\"},\n    {135, \"Hasselblad V\"},\n    {136, \"Hasselblad H\"},\n    {137, \"Contax 645\"},\n    {138, \"PhaseOne/Mamiya\"},\n    {140, \"Hasselblad V\"},\n    {141, \"Hasselblad H\"},\n    {142, \"Contax 645\"},\n    {143, \"PhaseOne/Mamiya\"},\n    {148, \"Hasselblad V\"},\n    {149, \"Hasselblad H\"},\n    {150, \"Contax 645\"},\n    {151, \"PhaseOne/Mamiya\"},\n    {160, \"A-250\"},\n    {161, \"A-260\"},\n    {162, \"A-280\"},\n    {167, \"Hasselblad V\"},\n    {168, \"Hasselblad H\"},\n    {169, \"Contax 645\"},\n    {170, \"PhaseOne/Mamiya\"},\n    {172, \"Hasselblad V\"},\n    {173, \"Hasselblad H\"},\n    {174, \"Contax 645\"},\n    {175, \"PhaseOne/Mamiya\"},\n    {176, \"Hasselblad V\"},\n    {177, \"Hasselblad H\"},\n    {178, \"Contax 645\"},\n    {179, \"PhaseOne/Mamiya\"},\n    {180, \"Hasselblad V\"},\n    {181, \"Hasselblad H\"},\n    {182, \"Contax 645\"},\n    {183, \"PhaseOne/Mamiya\"},\n    {208, \"Hasselblad V\"},\n    {211, \"PhaseOne/Mamiya\"},\n    {448, \"Phase One 645AF\"},\n    {457, \"Phase One 645DF\"},\n    {471, \"Phase One 645DF+\"},\n    {704, \"Phase One iXA\"},\n    {705, \"Phase One iXA - R\"},\n    {706, \"Phase One iXU 150\"},\n    {707, \"Phase One iXU 150 - NIR\"},\n    {708, \"Phase One iXU 180\"},\n    {721, \"Phase One iXR\"},\n    // Leaf section:\n    {333,\"Mamiya\"},\n    {329,\"Universal\"},\n    {330,\"Hasselblad H1/H2\"},\n    {332,\"Contax\"},\n    {336,\"AFi\"},\n    {327,\"Mamiya\"},\n    {324,\"Universal\"},\n    {325,\"Hasselblad H1/H2\"},\n    {326,\"Contax\"},\n    {335,\"AFi\"},\n    {340,\"Mamiya\"},\n    {337,\"Universal\"},\n    {338,\"Hasselblad H1/H2\"},\n    {339,\"Contax\"},\n    {323,\"Mamiya\"},\n    {320,\"Universal\"},\n    {322,\"Hasselblad H1/H2\"},\n    {321,\"Contax\"},\n    {334,\"AFi\"},\n    {369,\"Universal\"},\n    {370,\"Mamiya\"},\n    {371,\"Hasselblad H1/H2\"},\n    {372,\"Contax\"},\n    {373,\"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0]) {\n    for (i=0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id) {\n        strcpy(imgdata.lens.makernotes.body,p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes (unsigned tag, unsigned type) {\n      switch (tag) {\n      case 0x1002: imgdata.makernotes.fuji.WB_Preset = get2(); break;\n      case 0x1011: imgdata.other.FlashEC = getreal(type); break;\n      case 0x1020: imgdata.makernotes.fuji.Macro = get2(); break;\n      case 0x1021: imgdata.makernotes.fuji.FocusMode = get2(); break;\n      case 0x1022: imgdata.makernotes.fuji.AFMode = get2(); break;\n      case 0x1023: imgdata.makernotes.fuji.FocusPixel[0] = get2();\n                   imgdata.makernotes.fuji.FocusPixel[1] = get2();\n      break;\n      case 0x1034: imgdata.makernotes.fuji.ExrMode = get2(); break;\n      case 0x1050: imgdata.makernotes.fuji.ShutterType = get2(); break;\n      case 0x1400: imgdata.makernotes.fuji.FujiDynamicRange = get2(); break;\n      case 0x1401: imgdata.makernotes.fuji.FujiFilmMode = get2(); break;\n      case 0x1402: imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2(); break;\n      case 0x1403: imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2(); break;\n      case 0x140b: imgdata.makernotes.fuji.FujiAutoDynamicRange = get2(); break;\n      case 0x1404: imgdata.lens.makernotes.MinFocal = getreal(type); break;\n      case 0x1405: imgdata.lens.makernotes.MaxFocal = getreal(type); break;\n      case 0x1406: imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type); break;\n      case 0x1407: imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type); break;\n      case 0x1422: imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n                   imgdata.shootinginfo.ImageStabilization = (imgdata.makernotes.fuji.ImageStabilization[0]<<9) + imgdata.makernotes.fuji.ImageStabilization[1];\n      break;\n      case 0x1431: imgdata.makernotes.fuji.Rating = get4(); break;\n      case 0x3820: imgdata.makernotes.fuji.FrameRate = get2(); break;\n      case 0x3821: imgdata.makernotes.fuji.FrameWidth = get2(); break;\n      case 0x3822: imgdata.makernotes.fuji.FrameHeight = get2(); break;\n      }\nreturn;\n}\n\nvoid CLASS setSonyBodyFeatures (unsigned id) {\n\n  imgdata.lens.makernotes.CamID = id;\n  if (\t// FF cameras\n      (id == 257) ||\t\t// a900\n      (id == 269) ||\t\t// a850\n      (id == 340) ||\t\t// ILCE-7M2\n      (id == 318) ||\t\t// ILCE-7S\n      (id == 350) ||\t\t// ILCE-7SM2\n      (id == 311) ||\t\t// ILCE-7R\n      (id == 347) ||\t\t// ILCE-7RM2\n      (id == 306) ||\t\t// ILCE-7\n      (id == 298) ||\t\t// DSC-RX1\n      (id == 299) ||\t\t// NEX-VG900\n      (id == 310) ||\t\t// DSC-RX1R\n      (id == 344) ||\t\t// DSC-RX1RM2\n      (id == 354) ||\t\t// ILCA-99M2\n      (id == 294)\t\t// SLT-99, Hasselblad HV\n      )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n  else if ((id == 297) ||  // DSC-RX100\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n         )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n    }\n\n  else if (id != 002)     // DSC-R1\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    }\n\n  if      (               // E-mount cameras, ILCE series\n           (id == 302) ||\n           (id == 306) ||\n           (id == 311) ||\n           (id == 312) ||\n           (id == 313) ||\n           (id == 318) ||\n           (id == 339) ||\n           (id == 340) ||\n           (id == 346) ||\n           (id == 347) ||\n           (id == 350) ||\n           (id == 360)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n    }\n  else if (               // E-mount cameras, NEX series\n           (id == 278) ||\n           (id == 279) ||\n           (id == 284) ||\n           (id == 288) ||\n           (id == 289) ||\n           (id == 290) ||\n           (id == 293) ||\n           (id == 295) ||\n           (id == 296) ||\n           (id == 299) ||\n           (id == 300) ||\n           (id == 305) ||\n           (id == 307)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n    }\n\n  else if (\t// A-mount cameras, DSLR series\n           (id == 256) ||\n           (id == 257) ||\n           (id == 258) ||\n           (id == 259) ||\n           (id == 260) ||\n           (id == 261) ||\n           (id == 262) ||\n           (id == 263) ||\n           (id == 264) ||\n           (id == 265) ||\n           (id == 266) ||\n           (id == 269) ||\n           (id == 270) ||\n           (id == 273) ||\n           (id == 274) ||\n           (id == 275) ||\n           (id == 282) ||\n           (id == 283)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n    }\n  else if (\t// A-mount cameras, SLT series\n           (id == 280) ||\n           (id == 281) ||\n           (id == 285) ||\n           (id == 286) ||\n           (id == 287) ||\n           (id == 291) ||\n           (id == 292) ||\n           (id == 294) ||\n           (id == 303)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n    }\n  else if (\t// A-mount cameras, ILCA series\n           (id == 319)  ||\n           (id == 353)  ||\n           (id == 354)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n    }\n\n  else if (\t// DSC\n           (id == 002) ||  // DSC-R1\n           (id == 297) ||  // DSC-RX100\n           (id == 298) ||  // DSC-RX1\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 310) ||  // DSC-RX1R\n           (id == 344) ||  // DSC-RX1RM2\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n           )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n    }\n  return;\n}\n\nvoid CLASS parseSonyLensType2 (uchar a, uchar b) {\n  ushort lid2;\n  lid2 = (((ushort)a)<<8) | ((ushort)b);\n  if (!lid2) return;\n  if (lid2 < 0x100)\n    {\n      if ((imgdata.lens.makernotes.AdapterID != 0x4900) &&\n          (imgdata.lens.makernotes.AdapterID != 0xEF00))\n      {\n        imgdata.lens.makernotes.AdapterID = lid2;\n        switch (lid2) {\n        case 1:\n        case 2:\n        case 3:\n        case 6:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n        case 44:\n        case 78:\n        case 239:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n        }\n      }\n    }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n    {\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n    }\n  return;\n}\n\n#define strnXcat(buf,string) strncat(buf,string,LIM(sizeof(buf)-strbuflen(buf)-1,0,sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures (uchar a, uchar b) {\n\n  ushort features;\n  features = (((ushort)a)<<8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) ||\n      !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100)) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n    {\n  \t  imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n  \t  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n  \t  if ((features & 0x0200) && (features & 0x0100)) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0200) {\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0100) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t  }\n    }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\" );\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf+1,\n\t    strbuflen(imgdata.lens.makernotes.LensFeatures_suf)-1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c (uchar * buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n    {\n      switch (SonySubstitution[buf[0x0008]]) {\n      case 1:\n      case 5:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 4:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n        break;\n      }\n    }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |\n    ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2 (SonySubstitution[buf[0x000a]],\t// LensType2 - Sony lens ids\n                        SonySubstitution[buf[0x0009]]);\n  return;\n}\n\n\nvoid CLASS process_Sony_0x9050 (uchar * buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n    {\n      if (buf[0])\n        imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n\n      if (buf[1])\n        imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n    }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    {\n      if (buf[0x3d] | buf[0x3c])\n        {\n          lid = SonySubstitution[buf[0x3d]] << 8 |\n            SonySubstitution[buf[0x3c]];\n          imgdata.lens.makernotes.CurAp =\n            powf64(2.0f, ((float)lid/256.0f - 16.0f) / 2.0f);\n        }\n      if (buf[0x105] &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n        imgdata.lens.makernotes.LensMount =\n          SonySubstitution[buf[0x105]];\n      if (buf[0x106])\n        imgdata.lens.makernotes.LensFormat =\n          SonySubstitution[buf[0x106]];\n    }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n    {\n      parseSonyLensType2 (SonySubstitution[buf[0x0108]],\t\t// LensType2 - Sony lens ids\n                          SonySubstitution[buf[0x0107]]);\n    }\n  if ((imgdata.lens.makernotes.LensID == -1) &&\n      (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n    {\n      imgdata.lens.makernotes.LensID =\t\t // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 |\n        SonySubstitution[buf[0x0109]];\n\n      if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n          (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n      else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n          (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n          (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n    }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures (SonySubstitution[buf[0x115]],\n                           SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long long b88 = SonySubstitution[buf[0x88]];\n    unsigned long long b89 = SonySubstitution[buf[0x89]];\n    unsigned long long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06llx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05llx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") ||\n           !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG))) {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) ||\n           !strcmp(buf, \"Panasonic\")) {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8)) {\n    base = ftell(ifp) - 10;\n  nf: order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") ||\n           !strcmp(buf, \"LEICA\") ||\n           !strcmp(buf, \"Ricoh\") ||\n           !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") ||\n           !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) &&\n\t\t\t\t(dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if(len > 8 && pos+len > 2* fsize) continue;\n    tag |= uptag << 16;\n    if(len > 100*1024*1024) goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000) // camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t // Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes (tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len,ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n      {\n        if (tag == 0x1d)\t\t\t\t\t\t\t// serial number\n          while ((c = fgetc(ifp)) && c != EOF)\n          {\n            if ((!custom_serial) && (!isdigit(c)))\n            {\n              if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n              {\n                custom_serial = 34;\n              }\n              else\n              {\n                custom_serial = 96;\n              }\n            }\n            serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n          }\n        else if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0097)\n          {\n            for (i=0; i < 4; i++)\n\t            ver97 = ver97 * 10 + fgetc(ifp)-'0';\n\t          if (ver97 == 601)  // Coolpix A\n\t          {\n\t            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n\t          }\n\t        }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n\n        else if (tag == 0xa7)\t\t\t\t\t// shutter count\n          {\n            NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n            if ((NikonLensDataVersion > 200) && lenNikonLensData)\n            {\n              if (custom_serial)\n              {\n                ci = xlat[0][custom_serial];\n              }\n              else\n              {\n                ci = xlat[0][serial & 0xff];\n              }\n              cj = xlat[1][NikonKey];\n              ck = 0x60;\n              for (i = 0; i < lenNikonLensData; i++)\n                table_buf[i] ^= (cj += ci * ck++);\n              processNikonLensData(table_buf, lenNikonLensData);\n              lenNikonLensData = 0;\n              free(table_buf);\n            }\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n\n        else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n          {\n            unsigned char cc;\n            fread(&cc, 1, 1, ifp);\n            iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n            break;\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        int SubDirOffsetValid =\n              strncmp (model, \"E-300\", 5) &&\n              strncmp (model, \"E-330\", 5) &&\n              strncmp (model, \"E-400\", 5) &&\n              strncmp (model, \"E-500\", 5) &&\n              strncmp (model, \"E-1\", 3);\n\n        if ((tag == 0x2010) || (tag == 0x2020))\n          {\n            fseek(ifp, save - 4, SEEK_SET);\n            fseek(ifp, base + get4(), SEEK_SET);\n            parse_makernote_0xc634(base, tag, dng_writer);\n          }\n        if (!SubDirOffsetValid &&\n            ((len > 4) ||\n             ( ((type == 3) || (type == 8)) && (len > 2))  ||\n             ( ((type == 4) || (type == 9)) && (len > 1))  || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n        switch (tag) {\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20100102:\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x20100201:\n          imgdata.lens.makernotes.LensID =\n            (unsigned long long)fgetc(ifp)<<16 |\n            (unsigned long long)(fgetc(ifp), fgetc(ifp))<<8 |\n            (unsigned long long)fgetc(ifp);\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          if ((!imgdata.lens.LensSerial[0]))\n              stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens,len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment,len, ifp);\n          break;\n        case 0x20200401:\n\t      imgdata.other.FlashEC = getreal(type);\n\t      break;\n        }\n        skip_Oly_broken_tags:;\n      }\n\n    else if (!strncmp(make, \"PENTAX\", 6) ||\n             !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n               PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t     for (int i = 0; i < nWB; i++)\n\t       {\n\t\t imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\t fseek(ifp, 2, SEEK_CUR);\n\t\t imgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\t imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\t imgdata.color.WBCT_Coeffs[i][3] = get2();\n        \t}\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 12, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) &&\n             (dng_writer == AdobeDNG))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            imgdata.lens.makernotes.CamID = unique_id = get4();\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n          {\n            unique_id = get2();\n            setSonyBodyFeatures(unique_id);\n            if (table_buf_0x9050_present)\n              {\n                process_Sony_0x9050(table_buf_0x9050, unique_id);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n            if (table_buf_0x940c_present)\n              {\n                if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                  {\n                    process_Sony_0x940c(table_buf_0x940c);\n                  }\n                free (table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n\n                  // a450, a500, a550, a560, a580\n                  // a33, a35, a55\n                  // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len) {\n                case 368:\n                case 5478:\n                  // a700, a850, a900: CameraInfo\n                  if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n                    {\n                      if (table_buf[0] | table_buf[3])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                      if (table_buf[2] | table_buf[5])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    }\n                  break;\n                default:\n                  // CameraInfo2 & 3\n                  if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n                    {\n                      if (table_buf[1] | table_buf[2])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                      if (table_buf[3] | table_buf[4])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                      if (table_buf[5])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                      if (table_buf[6])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                    }\n                }\n              }\n            free(table_buf);\n          }\n\n\t\telse if (tag == 0x0104)\n\t\t  {\n\t\t    imgdata.other.FlashEC = getreal(type);\n\t\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 65535)\t\t\t\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len < 256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n              {\n                if (table_buf[1] | table_buf[2])\n                  imgdata.lens.makernotes.MinFocal =\n                    bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                if (table_buf[3] | table_buf[4])\n                  imgdata.lens.makernotes.MaxFocal =\n                    bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                if (table_buf[5])\n                  imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                if (table_buf[6])\n                  imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                parseSonyLensFeatures(table_buf[0], table_buf[7]);\n              }\n            free(table_buf);\n          }\n      }\n  next:\n    fseek (ifp, save, SEEK_SET);\n  }\n quit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  /*placeholder */\n}\n#endif\n\n\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strncmp(make,\"Nokia\",5)) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\") ||\n             !strcmp (buf,\"PENTAX \")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n             !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\n\tnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n             !strcmp (buf,\"LEICA\") ||\n             !strcmp (buf,\"Ricoh\") ||\n             !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n           !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (!strncmp(model, \"M8\", 2) ||\n          !strncasecmp(model, \"Leica M8\", 8) ||\n          !strncasecmp(model, \"LEICA X\", 7))\n        {\n          base = ftell(ifp)-8;\n        }\n      else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n        {\n          base = 0;\n        }\n      else if (!strncmp(model, \"M9\", 2) ||\n               !strncasecmp(model, \"Leica M9\", 8) ||\n               !strncasecmp(model, \"M Monochrom\", 11) ||\n               !strncasecmp(model, \"Leica M Monochrom\", 11))\n        {\n          if (!uptag)\n            {\n              base = ftell(ifp) - 10;\n              fseek (ifp, 8, SEEK_CUR);\n            }\n          else if (uptag == 0x3400)\n            {\n              fseek (ifp, 10, SEEK_CUR);\n              base += 10;\n            }\n        }\n      else if (!strncasecmp(model, \"LEICA T\", 7))\n      \t{\n      \t  base = ftell(ifp)-8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n      \t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (!strncasecmp(model, \"LEICA SL\", 8))\n      \t{\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      \t  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n      \t}\n#endif\n    }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if(len > 8 && _pos+len > 2* fsize) continue;\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000)\t// camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t// Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4)) {\n      if (tag == 0x0010) {\n         char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n         char *words[4];\n         char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n         int year, nwords, ynum_len;\n         unsigned c;\n         stmread(FujiSerial, len, ifp);\n         nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n         for (int i = 0; i < nwords; i++) {\n           mm[2] = dd[2] = 0;\n           if (strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1) < 18)\n              if (i == 0)\n\t         strncpy (imgdata.shootinginfo.InternalBodySerial,\n\t\t \twords[0],\n\t\t\tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n              else\n\t      {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t       snprintf (tbuf, sizeof(tbuf), \"%s %s\",\n\t            imgdata.shootinginfo.InternalBodySerial, words[i]);\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n\t       }\n           else\n           {\n             strncpy (dd, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-14, 2);\n             strncpy (mm, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-16, 2);\n             strncpy (yy, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18, 2);\n             year = (yy[0]-'0')*10 + (yy[1]-'0');\n             if (year <70) year += 2000; else year += 1900;\n\n             ynum_len = (int)strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18;\n             strncpy(ynum, words[i], ynum_len);\n             ynum[ynum_len] = 0;\n             for ( int j = 0; ynum[j] && ynum[j+1] && sscanf(ynum+j, \"%2x\", &c); j += 2) ystr[j/2] = c;\n             ystr[ynum_len / 2 + 1] = 0;\n             strcpy (model2, ystr);\n\n             if (i == 0) {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n               if (nwords == 1)\n\t\t   snprintf (tbuf,sizeof(tbuf),\n\t\t\t   \"%s %s %d:%s:%s\",\n\t\t\t   words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12,\n\t\t\t\tystr, year, mm, dd);\n\n               else\n\t\t snprintf (tbuf,sizeof(tbuf),\n\t\t\t    \"%s %d:%s:%s %s\",\n\t\t\t    ystr, year, mm, dd,\n\t\t\t    words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n             } else {\n\t\tchar tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t        snprintf (tbuf, sizeof(tbuf),\n\t\t\"%s %s %d:%s:%s %s\",\n\t\timgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,\n\t\t words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\t\t strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t\t \tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n      \t     }\n           }\n         }\n      }\n      else\n\tparseFujiMakernotes (tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                 )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\",5))\n      {\n        if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0012)\n          {\n            char a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c) imgdata.other.FlashEC = (float)(a*b)/(float)c;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData>0)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n        else if (tag == 0x00a0)\n          {\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        switch (tag) {\n        case 0x0404:\n        case 0x101a:\n        case 0x20100101:\n          if (!imgdata.shootinginfo.BodySerial[0])\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n        case 0x20100102:\n          if (!imgdata.shootinginfo.InternalBodySerial[0])\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20401112:\n          imgdata.makernotes.olympus.OlympusCropID = get2();\n          break;\n        case 0x20401113:\n          FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n          break;\n        case 0x20100201:\n          {\n            unsigned long long oly_lensid [3];\n            oly_lensid[0] = fgetc(ifp);\n            fgetc(ifp);\n            oly_lensid[1] = fgetc(ifp);\n            oly_lensid[2] = fgetc(ifp);\n            imgdata.lens.makernotes.LensID =\n              (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n          }\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          break;\n        }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) &&\n             !strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n    \t  {\n    \t     char buffer[17];\n    \t     int count=0;\n    \t     fread(buffer, 16, 1, ifp);\n    \t     buffer[16] = 0;\n    \t     for (int i=0; i<16; i++)\n    \t     {\n//    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n    \t        if ((isspace(buffer[i])) ||\n    \t            (buffer[i] == 0x2D) ||\n    \t            (isalnum(buffer[i])))\n    \t        count++;\n    \t     }\n    \t     if (count == 16)\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%8s\", buffer+8);\n    \t        buffer[8] = 0;\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t     }\n    \t     else\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10], buffer[11]);\n    \t     }\n    \t  }\n        else if ((tag == 0x1001) && (type == 3))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            imgdata.lens.makernotes.LensID = -1;\n            imgdata.lens.makernotes.FocalType = 1;\n          }\n\n        else if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n        else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n      }\n\n    else if (!strncmp(make, \"RICOH\", 5) &&\n             strncmp(model, \"PENTAX\", 6))\n      {\n    \tif ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n    \t  {\n    \t     char buffer[9];\n    \t     buffer[8] = 0;\n    \t     fread(buffer, 8, 1, ifp);\n    \t     sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t  }\n\n    \telse if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n          else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n\n        else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n          {\n            short ntags, cur_tag;\n            fseek(ifp, 20, SEEK_CUR);\n            ntags = get2();\n            cur_tag = get2();\n            while (cur_tag != 0x002c)\n              {\n                fseek(ifp, 10, SEEK_CUR);\n                cur_tag = get2();\n              }\n            fseek(ifp, 6, SEEK_CUR);\n            fseek(ifp, get4()+20, SEEK_SET);\n            stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n            get2();\n            imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n            switch(imgdata.lens.makernotes.LensID) {\n              case 1:\n              case 2:\n              case 3:\n              case 5:\n              case 6:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            \timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n              break;\n              case 8:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            \timgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            \timgdata.lens.makernotes.LensID = -1;\n              break;\n              default:\n            \timgdata.lens.makernotes.LensID = -1;\n            }\n            fseek(ifp, 17, SEEK_CUR);\n            stread(imgdata.lens.LensSerial, 12, ifp);\n          }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) ||\n              !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n            \tPentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t    for (int i = 0; i < nWB; i++)\n\t      {\n\t\timgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\tfseek(ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\timgdata.color.WBCT_Coeffs[i][3] = get2();\n\t      }\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 2, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            unique_id = imgdata.lens.makernotes.CamID = get4();\n          }\n         else if (tag == 0xa002)\n          {\n             stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n        {\n          unique_id = get2();\n          setSonyBodyFeatures(unique_id);\n          if (table_buf_0x9050_present)\n            {\n              process_Sony_0x9050(table_buf_0x9050, unique_id);\n              free (table_buf_0x9050);\n              table_buf_0x9050_present = 0;\n            }\n          if (table_buf_0x940c_present)\n            {\n              if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                {\n                  process_Sony_0x940c(table_buf_0x940c);\n                }\n              free (table_buf_0x940c);\n              table_buf_0x940c_present = 0;\n            }\n        }\n\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n                  \t\t\t\t// a450, a500, a550, a560, a580\n                  \t\t\t\t// a33, a35, a55\n                  \t\t\t\t// NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len)\n                  {\n                  case 368:\n                  case 5478:\n                    // a700, a850, a900: CameraInfo\n                    if (table_buf[0] | table_buf[3])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                    if (table_buf[2] | table_buf[5])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    break;\n                  default:\n                    // CameraInfo2 & 3\n                    if (table_buf[1] | table_buf[2])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                    if (table_buf[3] | table_buf[4])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                    if (table_buf[5])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                    if (table_buf[6])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                }\n              }\n            free(table_buf);\n          }\n\n        else if ((tag == 0x0020) &&\t\t\t\t// WBInfoA100, needs 0xb028 processing\n                 !strncasecmp(model, \"DSLR-A100\", 9))\n\t  {\n\t    fseek(ifp,0x49dc,SEEK_CUR);\n\t    stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n\t  }\n\n\telse if (tag == 0x0104)\n\t  {\n\t    imgdata.other.FlashEC = getreal(type);\n\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 256000)\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len <256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal =\n                bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal =\n                bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            free(table_buf);\n          }\n      }\n\n    fseek(ifp,_pos,SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 37 && strstr(make,\"NIKON\") && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc,1,1,ifp);\n        iso_speed = int(100.0 * powf64(2.0f,float(cc)/12.0-5.0));\n      }\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n\tiso_speed = 50 * powf64(2.0, i/32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = powf64(2.0, i/64.0);\n#endif\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = powf64(2.0, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make,\"Canon\",5))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4) unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n\tif (!strncasecmp(make,\"Olympus\",7))\n\t{\n\t  short nWB, tWB;\n\t  if ((tag == 0x20300108) || (tag == 0x20310109))\n\t      imgdata.makernotes.olympus.ColorSpace = get2();\n\n\t  if ((tag == 0x20400102) && (len == 2) &&\n\t      (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n\t    {\n\t      int i;\n\t      for (i=0; i<64; i++)\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] =\n\t\t  imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t      for (i=64; i<256; i++)\n\t\timgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t    }\n\t  if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n\t    {\n\t      ushort CT;\n\t      nWB = tag-0x20400102;\n\t      switch (nWB)\n\t\t{\n                case 0 : CT = 3000; tWB = LIBRAW_WBI_Tungsten; break;\n\t\tcase 1 : CT = 3300; tWB = 0x100; break;\n\t\tcase 2 : CT = 3600; tWB = 0x100; break;\n\t\tcase 3 : CT = 3900; tWB = 0x100; break;\n                case 4 : CT = 4000; tWB = LIBRAW_WBI_FL_W; break;\n\t\tcase 5 : CT = 4300; tWB = 0x100; break;\n                case 6 : CT = 4500; tWB = LIBRAW_WBI_FL_D; break;\n\t\tcase 7 : CT = 4800; tWB = 0x100; break;\n                case 8 : CT = 5300; tWB = LIBRAW_WBI_FineWeather; break;\n                case 9 : CT = 6000; tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: CT = 6600; tWB = LIBRAW_WBI_FL_N; break;\n                case 11: CT = 7500; tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: CT = 0; tWB = 0x100;\n\t\t}\n\t      if (CT)\n\t\t{\n\t\t  imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n\t\t  imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n\t\t  imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n\t\t  if (len == 4)\n\t\t    {\n\t\t      imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n\t\t      imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t\t    }\n\t\t}\n\t      if (tWB != 0x100)\n\t\tFORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c+1];\n\t    }\n\t  if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n\t    {\n\t      nWB = tag-0x20400113;\n\t      imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t      switch (nWB)\n\t\t{\n                case 0:  tWB = LIBRAW_WBI_Tungsten; break;\n                case 4:  tWB = LIBRAW_WBI_FL_W; break;\n                case 6:  tWB = LIBRAW_WBI_FL_D; break;\n                case 8:  tWB = LIBRAW_WBI_FineWeather; break;\n                case 9:  tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: tWB = LIBRAW_WBI_FL_N; break;\n                case 11: tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: tWB = 0x100;\n\t\t}\n\t      if (tWB != 0x100)\n\t\timgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] =\n\t\t  imgdata.color.WBCT_Coeffs[nWB][2];\n\t    }\n\n\t  if (tag == 0x20400121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n\t      if (len == 4)\n\t\t{\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t\t}\n\t    }\n\t  if (tag == 0x2040011f)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t    }\n\t  if (tag == 0x30000120)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n\t      if (len == 2)\n\t\t{\n\t\t  for (int i=0; i<256; i++)\n\t\t    imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t\t}\n\t    }\n\t  if (tag == 0x30000121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n\t    }\n\t  if (tag == 0x30000122)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n\t    }\n\t  if (tag == 0x30000123)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n\t    }\n\t  if (tag == 0x30000124)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n\t    }\n\t  if (tag == 0x30000130)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n\t    }\n\t  if (tag == 0x30000131)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n\t    }\n\t  if (tag == 0x30000132)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n\t    }\n\t  if (tag == 0x30000133)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n\t    }\n\n\t  if((tag == 0x20400805) && (len == 2))\n\t    {\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[0]=getreal(type);\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[1]=getreal(type);\n\t      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n\t    }\n\t  if (tag == 0x20200401)\n\t    {\n\t      imgdata.other.FlashEC = getreal(type);\n\t    }\n\t}\n    fseek(ifp,_pos2,SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d) {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1) {  // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  FORC4 cam_mul[c ^ (c >> 1)] = get2();\n\t  break;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7) {\t// shutter count\n      NikonKey = fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp);\n        if ( (unsigned) (ver97-200) < 17) {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i=0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n          sget2 (buf97 + (i & -2) + c*2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601)  // Coolpix A\n    \t{\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    \t}\n#endif\n    }\n\n    if(tag == 0xb001 && type == 3)\t// Sony ModelID\n      {\n        unique_id = get2();\n      }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n         FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make,\"NIKON\") && len == 4)\n      {\n        FORC4 cblack[c ^ c >> 1] = get2();\n        i = cblack[3];\n        FORC3 if(i>cblack[c]) i = cblack[c];\n        FORC4 cblack[c]-=i;\n        black += i;\n      }\n#endif\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tint loopc = 0;\n#endif\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(loopc++>1024)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n          for (i=0; i < 3; i++)\n\t  {\n#ifdef LIBRAW_LIBRARY_BUILD\n           if (!imgdata.makernotes.olympus.ColorSpace)\n\t   {\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n\t   }\n           else\n\t   {\n            FORC3 imgdata.color.ccm[i][c] = ((short) get2()) / 256.0;\n\t   }\n#else\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n#endif\n          }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek (ifp, get4()+base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    if (tag == 0x2010)\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, 0x2010);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n\n    if (\n         ((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) &&\n         ((type == 7) || (type == 13)) &&\n         !strncasecmp(make,\"Olympus\",7)\n       )\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, tag);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf,\"OLYMP\",5))\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i+=18; i <= len; i+=10) {\n      \tget2();\n      \tFORC4 sraw_mul[c ^ (c >> 1)] = get2();\n      \tif (sraw_mul[1] == 1170) break;\n      }\n    }\n    if(!strncasecmp(make,\"Samsung\",7))\n      {\n        if (tag == 0xa020) // get the full Samsung encryption key\n            for (i=0; i<11; i++) SamsungKey[i] = get4();\n        if (tag == 0xa021) // get and decode Samsung cam_mul array\n            FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 0xa023)\n          {\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n              }\n          }\n        if (tag == 0xa024)\n          {\n            FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c+1];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n              }\n          }\n        if (tag == 0xa025)\n           imgdata.color.linear_max[0]=\n             imgdata.color.linear_max[1]=\n             imgdata.color.linear_max[2]=\n             imgdata.color.linear_max[3]= get4() - SamsungKey[0];\n        if (tag == 0xa030 && len == 9)\n            for (i=0; i < 3; i++)\n              FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n#endif\n        if (tag == 0xa031 && len == 9)\t// get and decode Samsung color matrix\n            for (i=0; i < 3; i++)\n              FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n\n        if (tag == 0xa028)\n          FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n      }\n    else\n      {\n        // Somebody else use 0xa021 and 0xa028?\n        if (tag == 0xa021)\n          FORC4 cam_mul[c ^ (c >> 1)] = get4();\n        if (tag == 0xa028)\n          FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n      }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo,ape;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && savepos + len > fsize*2) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n    switch (tag) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n      case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t   shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;  // 0x829d FNumber\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 34866:\n        if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\",4) || !strncasecmp(make, \"CANON\",5)))\n          iso_speed = getreal(type);\n        break;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)\n\t\t     tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t\tshutter = powf64(2.0, expo);\n\t\tbreak;\n      case 37378:                                       // 0x9202 ApertureValue\n        if ((fabs(ape = getreal(type))<256.0) && (!aperture))\n          aperture = powf64(2.0, ape/2);\n        break;\n      case 37385:  flash_used = getreal(type);          break;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  \t                         // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n       if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n         char mn_text[512];\n         char* pos;\n         char ccms[512];\n         ushort l;\n         float num;\n\n         fgets(mn_text, len, ifp);\n         pos = strstr(mn_text, \"gain_r=\");\n         if (pos) cam_mul[0] = atof(pos+7);\n         pos = strstr(mn_text, \"gain_b=\");\n         if (pos) cam_mul[2] = atof(pos+7);\n         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n         else cam_mul[0] = cam_mul[2] = 0.0f;\n\n         pos = strstr(mn_text, \"ccm=\") + 4;\n         l = strstr(pos, \" \") - pos;\n         memcpy (ccms, pos, l);\n         ccms[l] = '\\0';\n\n         pos = strtok (ccms, \",\");\n         for (l=0; l<4; l++) {\n           num = 0.0;\n           for (c=0; c<3; c++) {\n             imgdata.color.ccm[l][c] = (float)atoi(pos);\n             num += imgdata.color.ccm[l][c];\n             pos = strtok (NULL, \",\");\n           }\n           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n         }\n       }\n       else\n#endif\n        parse_makernote (base, 0);\n       break;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n  \treturn;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--) {\n    tiff_get(base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n    case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;\n    case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;\n    case 5:  imgdata.other.parsed_gps.altref = getc(ifp); break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9: imgdata.other.parsed_gps.gpsstatus = getc(ifp); break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"AFi-II 7\",\"Aptus-II 7\",\"\",\"Aptus-II 6\",\"\",\"\",\"Aptus-II 10\",\"Aptus-II 5\",\n    \"\",\"\",\"\",\"\",\"Aptus-II 10R\",\"Aptus-II 8\",\"\",\"Aptus-II 12\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data,\"CameraObj_camera_type\")) {\n\tstmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data,\"back_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.BodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));\n       strcpy (imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data,\"CaptProf_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n       strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n// IB end\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\t((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x10000) len = 0x10000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x10000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[len<0x1000?0xfff:len-1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags (int wb, unsigned type)\n{\n\tfloat mul[3]={1,1,1}, num, mul2;\n\tint c;\n\tFORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n\timgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n\tmul2 = mul[1] * mul[1];\n\timgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n\timgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n\treturn;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  INT64 fsize = ifp->size();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > 2*fsize) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n    if (tag == 1011) imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());\n      wbi = -2;\n    }\n\n    if (tag == 0x0848) Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849) Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a) Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b) Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93) imgdata.color.linear_max[0] =\n                         imgdata.color.linear_max[1] =\n                         imgdata.color.linear_max[2] =\n                         imgdata.color.linear_max[3] = get2();\n        if (tag == 0x09ce)\n\t\tstmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);\n        if (tag == 0xfa00)\n\t\tstmread(imgdata.shootinginfo.BodySerial, len, ifp);\n\tif (tag == 0xfa27)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\t  }\n\tif (tag == 0xfa28)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\t  }\n\tif (tag == 0xfa29)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\t  }\n\tif (tag == 0xfa2a)\n\t  {\n            FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\t  }\n\n    if (tag == 2120 + wbi ||\n        (wbi<0 && tag == 2125))  /* use Auto WB if illuminant index is not set */\n      {\n        FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n        FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 0x903) iso_speed = getreal(type);\n    //if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#endif\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!strncasecmp(make, \"SONY\", 4) ||\n      (!strncasecmp(make, \"Hasselblad\", 10) &&\n        (!strncasecmp(model, \"Stellar\", 7) ||\n         !strncasecmp(model, \"Lunar\", 5) ||\n         !strncasecmp(model, \"HV\",2))))\n  {\n  \tswitch (tag) {\n\tcase 0x7300: // SR2 black level\n\t    for (int i = 0; i < 4 && i < len; i++)\n\t      cblack[i] = get2();\n\t  break;\n\tcase 0x7480:\n\tcase 0x7820:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\tbreak;\n\tcase 0x7481:\n\tcase 0x7821:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n\tbreak;\n\tcase 0x7482:\n\tcase 0x7822:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\tbreak;\n\tcase 0x7483:\n\tcase 0x7823:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n\tbreak;\n\tcase 0x7484:\n\tcase 0x7824:\n\t    imgdata.color.WBCT_Coeffs[0][0] = 4500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[0][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n\tbreak;\n\tcase 0x7486:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\tbreak;\n\tcase 0x7825:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\tbreak;\n\tcase 0x7826:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n\tbreak;\n\tcase 0x7827:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n\tbreak;\n\tcase 0x7828:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n\tbreak;\n\tcase 0x7829:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n\tbreak;\n\tcase 0x782a:\n\t    imgdata.color.WBCT_Coeffs[1][0] = 8500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[1][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n\tbreak;\n\tcase 0x782b:\n\t    imgdata.color.WBCT_Coeffs[2][0] = 6000;\n\t    FORC3 imgdata.color.WBCT_Coeffs[2][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n\tbreak;\n\tcase 0x782c:\n\t    imgdata.color.WBCT_Coeffs[3][0] = 3200;\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c+1] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] = imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n\tbreak;\n\tcase 0x782d:\n\t    imgdata.color.WBCT_Coeffs[4][0] = 2500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[4][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n\tbreak;\n\tcase 0x787f:\n\t    FORC3 imgdata.color.linear_max[c] = get2();\n\t    imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n\tbreak;\n\t}\n  }\n#endif\n\n\n    switch (tag) {\n      case 1:   if(len==4) pana_raw = get4(); break;\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:   if ((i = get2())) filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=i;\n#endif\n      break;\n      case 8:\n      case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=get2();\n#endif\n      break;\n      case 14: case 15: case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw) {\n          imgdata.color.linear_max[tag-14] = get2();\n          if (tag == 15 ) imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        }\n#endif\n      break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 19:\n\tif(pana_raw) {\n\t  ushort nWB, cnt, tWB;\n\t  nWB = get2();\n\t  if (nWB > 0x100) break;\n\t  for (cnt=0; cnt<nWB; cnt++) {\n\t    tWB = get2();\n\t    if (tWB < 0x100) {\n\t      imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n\t    } else get4();\n\t  }\n\t}\n      break;\n#endif\n      case 23:\n\tif (type == 3) iso_speed = get2();\n      break;\n      case 28: case 29: case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          {\n            pana_black[tag-28] = get2();\n          }\n        else\n#endif\n          {\n\t     cblack[tag-28] = get2();\n\t     cblack[3] = cblack[1];\n          }\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-36] = get2();\n\tbreak;\n      case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(pana_raw) {\n\t    ushort nWB, cnt, tWB;\n\t    nWB = get2();\n\t    if (nWB > 0x100) break;\n\t    for (cnt=0; cnt<nWB; cnt++) {\n\t        tWB = get2();\n\t        if (tWB < 0x100) {\n\t            imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t        } else fseek(ifp, 6, SEEK_CUR);\n\t    }\n\t}\n\tbreak;\n#endif\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tif (tiff_bps < tiff_ifd[ifd].bps)\n\t    tiff_bps = tiff_ifd[ifd].bps;\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tif (tiff_ifd[ifd].bps > 12) break;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 278:\n\ttiff_ifd[ifd].rows_per_strip = getint(type);\n\tbreak;\n#endif\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_offsets = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_offsets_count = len;\n\t    for(int i=0; i< len; i++)\n\t      tiff_ifd[ifd].strip_offsets[i]=get4()+base;\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    if ((tiff_ifd[ifd].t_width > 4*tiff_ifd[ifd].t_height) & ~jh.clrs) {\n\t      tiff_ifd[ifd].t_width  /= 2;\n\t      tiff_ifd[ifd].t_height *= 2;\n\t    }\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_byte_counts = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_byte_counts_count = len;\n\t    for(int i=0; i< len; i++)\n\t\ttiff_ifd[ifd].strip_byte_counts[i]=get4();\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 317:\n\ttiff_ifd[ifd].predictor = getint(type);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 1)\n\t  tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n      case 325:\n\ttiff_ifd[ifd].bytes = len > 1 ? ftell(ifp): get4();\n\tbreak;\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n         \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif  \n\t  break;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {\n          fseek (ifp, ftell(ifp)+4, SEEK_SET);\n          fseek (ifp, get4()+base, SEEK_SET);\n          parse_tiff_ifd (base);\n          break;\n\t}\n#endif\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 339:\n\ttiff_ifd[ifd].sample_format = getint(type);\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 700:\n        if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n          {\n            xmpdata = (char*)malloc(xmplen = len+1);\n            fread(xmpdata,len,1,ifp);\n            xmpdata[len]=0;\n          }\n        break;\n#endif\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i=0; i < 3; i++) {\n        float num = 0.0;\n        for (c=0; c<3; c++) {\n          imgdata.color.ccm[i][c] = (float) ((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01) FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n\t  FORC4 cblack[c ^ c >> 1] = get2();\n\t  i = cblack[3];\n\t  FORC3 if(i>cblack[c]) i = cblack[c];\n\t  FORC4 cblack[c]-=i;\n\t  black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);\n#endif\n      break;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33421:\t\t\t/* CFARepeatPatternDim */\n\tif (get2() == 6 && get2() == 6)\n\t  filters = 9;\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n\tif (filters == 9) {\n\t  FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;\n\t  break;\n\t}\n      case 64777:\t\t\t/* Kodak P-series */\n        if(len == 36)\n          {\n            filters = 9;\n            colors = 3;\n            FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n          }\n        else if(len > 0)\n          {\n            if ((plen=len) > 16) plen = 16;\n            fread (cfa_pat, 1, plen, ifp);\n            for (colors=cfa=i=0; i < plen && colors < 4; i++) {\n              colors += !(cfa & (1 << cfa_pat[i]));\n              cfa |= 1 << cfa_pat[i];\n            }\n            if (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n            if (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n            goto guess_cfa_pc;\n          }\n        break;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\ttiff_ifd[ifd].t_shutter = shutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= MAX(1,num);\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n        {\n          unsigned pos;\n          fseek(ifp, pos = (get4() + base), SEEK_SET);\n          parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n          fseek(ifp, pos, SEEK_SET);\n          parse_gps_libraw(base);\n#endif\n        }\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 40976:\n\tstrip_offset = get4();\n\tswitch (tiff_ifd[ifd].comp) {\n\t  case 32770: load_raw = &CLASS samsung_load_raw;   break;\n\t  case 32772: load_raw = &CLASS samsung2_load_raw;  break;\n\t  case 32773: load_raw = &CLASS samsung3_load_raw;  break;\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (len < 1 || len > 2560000 || !(cbuf = (char *) malloc(len))) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfread (cbuf, 1, len, ifp);\n#else\n\tif(fread (cbuf, 1, len, ifp) != len)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n        cbuf[len-1] = 0;\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag=1;\n#endif\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50708:\t\t\t/* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n        stmread(imgdata.color.UniqueCameraModel, len, ifp);\n        imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;\n#endif\n\tif (model[0]) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfgets (make, 64, ifp);\n#else\n        strncpy (make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n\tif ((cp = strchr(make,' '))) {\n\t  strcpy(model,cp+1);\n\t  *cp = 0;\n\t}\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (filters == 9) break;\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n        FORCC tab[cfa_pc[c]] = c;\n        cdesc[c] = 0;\n        for (i=16; i--; )\n          filters = filters << 2 | tab[cfa_pat[i % plen]];\n        filters -= !filters;\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) fuji_width = 1;\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[4] = \n#endif\n\tcblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[5] = \n#endif\n\tcblack[5] = get2();\n\tif (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof (cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.color.dng_levels.dng_cblack[4]=\n\t    imgdata.color.dng_levels.dng_cblack[5]= \n#endif\n\t    cblack[4] = cblack[5] = 1;\n\tbreak;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcase 0xf00c: {\n    \tunsigned fwb[4];\n    \tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t  if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n\t\t  {\n\t\t    long long f_save = ftell(ifp);\n\t\t    int fj, found = 0;\n\t\t    ushort *rafdata = (ushort*) malloc (sizeof(ushort)*libraw_internal_data.unpacker_data.lenRAFData);\n\t\t    fseek (ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n\t\t    fread (rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n\t\t    fseek(ifp, f_save, SEEK_SET);\n\t\t    for (int fi=0; fi<(libraw_internal_data.unpacker_data.lenRAFData-3); fi++)\n\t\t\t{\n\t\t\t  if ((fwb[0]==rafdata[fi]) && (fwb[1]==rafdata[fi+1]) && (fwb[2]==rafdata[fi+2]))\n\t\t\t  {\n\t\t\t    if (rafdata[fi-15] != fwb[0]) continue;\n\t\t\t    fi = fi - 15;\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] = rafdata[fi];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi+1];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi+2];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = rafdata[fi+3];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi+4];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi+5];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = rafdata[fi+6];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi+7];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi+8];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = rafdata[fi+9];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi+10];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi+11];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = rafdata[fi+12];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi+13];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi+14];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = rafdata[fi+15];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi+16];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi+17];\n\n                fi += 111;\n                for (fj = fi; fj<(fi+15); fj+=3)\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    found = 1;\n                    break;\n                  }\n                if (found)\n                {\n                  int FujiCCT_K [31] = {2500,2550,2650,2700,2800,2850,2950,3000,3100,3200,3300,3400,3600,3700,3800,4000,4200,4300,4500,4800,5000,5300,5600,5900,6300,6700,7100,7700,8300,9100,10000};\n                  fj = fj - 93;\n                  for (int iCCT=0; iCCT < 31; iCCT++)\n                  {\n                    imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                    imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT*3+1+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT*3+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT*3+2+fj];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t    free (rafdata);\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\t\tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t}\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50709:\n        stmread(imgdata.color.LocalizedCameraModel,len, ifp);\n      break;\n#endif\n\n      case 61450:\n\tcblack[4] = cblack[5] = MIN(sqrt((double)len),64);\n      case 50714:\t\t\t/* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1  && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n\t  {\n\t    for(i=0; i < colors && i < 4 && i < len; i++)\n\t      imgdata.color.dng_levels.dng_cblack[i]=\n\t        cblack[i]=\n\t\t  getreal(type)+0.5;\n\n\t    imgdata.color.dng_levels.dng_black= black = 0;\n\t  }\n\telse\n#endif\n\t  if((cblack[4] * cblack[5] < 2) && len == 1)\n\t    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t      imgdata.color.dng_levels.dng_black= \n#endif\n\t        black =\n\t\t  getreal(type);\n\t    }\n\t  else if(cblack[4] * cblack[5] <= len)\n\t    {\n\t      FORC (cblack[4] * cblack[5])\n\t\tcblack[6+c] = getreal(type);\n\t      black = 0;\n\t      FORC4\n\t\tcblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n              if(tag == 50714)\n\t      {\n\t        FORC (cblack[4] * cblack[5])\n\t          imgdata.color.dng_levels.dng_cblack[6+c]= cblack[6+c];\n\t        imgdata.color.dng_levels.dng_black=0;\n\t        FORC4\n\t          imgdata.color.dng_levels.dng_cblack[c]= 0;\n\t      }\n#endif\n\t    }\n      break;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_black += num/len + 0.5;\n#endif\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_whitelevel[0]=\n#endif\n\tmaximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1 ) // Linear DNG case\n\t\tfor(i=1; i < colors && i < 4 && i < len; i++)\n\t\t\timgdata.color.dng_levels.dng_whitelevel[i]=getint(type);\n#endif\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tif(pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50778:\n        imgdata.color.dng_color[0].illuminant = get2();\n        break;\n      case 50779:\n        imgdata.color.dng_color[1].illuminant = get2();\n        break;\n#endif\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 50721?0:1;\n#endif\n\tFORCC for (j=0; j < 3; j++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.dng_color[i].colormatrix[c][j]=\n#endif\n\t  cm[c][j] = getreal(type);\n          }\n\tuse_cm = 1;\n\tbreak;\n\n\tcase 0xc714:\t\t\t/* ForwardMatrix1 */\n        case 0xc715:\t\t\t/* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 0xc714?0:1;\n#endif\n\tfor (j=0; j < 3; j++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[i].forwardmatrix[j][c]=\n#endif\n              fm[j][c] = getreal(type);\n            }\n\tbreak;\n\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        j = tag == 50723?0:1;\n#endif\n\tfor (i=0; i < colors; i++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[j].calibration[i][c]=\n#endif\n              cc[i][c] = getreal(type);\n            }\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC{\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_levels.analogbalance[c]=\n#endif\n\t      ab[c] = getreal(type);\n\t}\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50730:\t\t\t/* DNG: Baseline Exposure */\n        baseline_exposure = getreal(type);\n        break;\n#endif\n\t\t  // IB start\n    case 50740:\t\t\t/* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        char mbuf[64];\n        unsigned short makernote_found = 0;\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n          {\n            order = 0x4d4d;\t\t\t\t// Adobe header is always in \"MM\" / big endian\n            curr_pos = start_pos + 6;\n            while (curr_pos + 8 - start_pos <= len)\n              {\n                fread(mbuf, 1, 4, ifp);\n                curr_pos += 8;\n                if (!strncmp(mbuf, \"MakN\", 4)) {\n                  makernote_found = 1;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n                parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n                break;\n                }\n              }\n          }\n        else\n          {\n            fread(mbuf + 6, 1, 2, ifp);\n            if (!strcmp(mbuf, \"PENTAX \") ||\n                !strcmp(mbuf, \"SAMSUNG\"))\n              {\n                makernote_found = 1;\n                fseek(ifp, start_pos, SEEK_SET);\n                parse_makernote_0xc634(base, 0, CameraDNG);\n              }\n          }\n\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      // IB end\n#endif\n      if (dng_version) break;\n      parse_minolta (j = get4()+base);\n      fseek (ifp, j, SEEK_SET);\n      parse_tiff_ifd (base);\n      break;\n    case 50752:\n      read_shorts (cr2_slice, 3);\n      break;\n    case 50829:\t\t\t/* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830:\t\t\t/* MaskedAreas */\n      for (i=0; i < len && i < 32; i++)\n        ((int*)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009:\t\t\t/* OpcodeList2 */\n      meta_offset = ftell(ifp);\n      break;\n    case 64772:\t\t\t/* Kodak P-series */\n      if (len < 13) break;\n      fseek (ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek (ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cmatrix, cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n        {\n          thumb_misc   = jh.bits;\n          thumb_width  = jh.wide;\n          thumb_height = jh.high;\n        }\n    }\n  }\n  for (i=tiff_nifds; i--; ) {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    os = raw_width*raw_height;\n    ns = tiff_ifd[i].t_width*tiff_ifd[i].t_height;\n    if (tiff_bps) {\n        os *= tiff_bps;\n        ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n\tunsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n\t ns && ((ns > os && (ties = 1)) ||\n\t\t(ns == os && shot_select == ties++))) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tiff_ifd[i].bytes;\n#endif\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n      shutter       = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties) is_raw = ties;\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2) {\n\t  tiff_bps = 14;\n\t  load_raw = &CLASS unpacked_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n\t// Sony 14-bit uncompressed\n        if(!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2)\n          {\n\t    tiff_bps = 14;\n            load_raw = &CLASS unpacked_load_raw;\n            break;\n\t  }\n        if(!strncasecmp(make,\"Nikon\",5) && !strncmp(software,\"Nikon Scan\",10))\n          {\n            load_raw = &CLASS nikon_coolscan_load_raw;\n            raw_color = 1;\n            filters = 0;\n            break;\n          }\n#endif\n\tif (!strncmp(make,\"OLYMPUS\",7) &&\n\t\ttiff_ifd[raw].bytes*2 == raw_width*raw_height*3)\n\t  load_flags = 24;\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\n\t\t   if (!strncmp(make,\"OLYMPUS\",7) &&\n\t\t\ttiff_ifd[raw].bytes*7 > raw_width*raw_height)\n\t\t     load_raw = &CLASS olympus_load_raw;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  if (model[0] == 'N') load_flags = 80;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS nikon_yuv_load_raw;\n\t  gamma_curve (1/2.4, 12.92, 1, 4095);\n\t  memset (cblack, 0, sizeof cblack);\n\t  filters = 0;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if(raw_width*raw_height*3 == tiff_ifd[raw].bytes*2)\n            {\n              load_raw = &CLASS packed_load_raw;\n              load_flags=80;\n            }\n          else if(tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n\t\t  tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n\t    {\n\t      int fit = 1;\n\t      for(int i = 0; i < tiff_ifd[raw].strip_byte_counts_count-1; i++) // all but last\n\t\tif(tiff_ifd[raw].strip_byte_counts[i]*2 != tiff_ifd[raw].rows_per_strip*raw_width*3)\n\t\t  {\n\t\t    fit = 0;\n\t\t    break;\n\t\t  }\n\t      if(fit)\n\t\tload_raw = &CLASS nikon_load_striped_packed_raw;\n\t      else\n\t\tload_raw = &CLASS nikon_load_raw; // fallback\n\t    }\n\telse\n#endif\n            load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: case 34892: break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8: break;\n#endif\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( ((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&\n\t  (tiff_compress & -16) != 32768)\n          || (tiff_bps == 8 && strncmp(make,\"Phase\",5) &&\n\t  !strcasestr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n         && strncmp(software,\"Nikon Scan\",10))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw\n        && (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33\n\t&& tiff_ifd[i].phint != 32803\n\t&& tiff_ifd[i].phint != 34892\n        && unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps)+1) >\n\t      thumb_width *       thumb_height / (SQR(thumb_misc)+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strncmp(make,\"Imacon\",6))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x524946:\t\t\t\t/* RIF */\n    if (!strncasecmp(model,\"DSLR-A100\", 9))\n    {\n      fseek(ifp, 8, SEEK_CUR);\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n      get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n    }\n\tbreak;\n#endif\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname))\n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff (int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38) {\n      parse_ciff (ftell(ifp), len, depth+1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004) parse_ciff (ftell(ifp), len, depth+1);\n#endif\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = powf64(2.0f, -int_to_float((get4(),get4())));\n      aperture = powf64(2.0f, int_to_float(get4())/2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a) {\n//      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(),get2()) + get2())/32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture  = _CanonConvertAperture((get2(),get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture  = powf64(2.0, (get2(),(short)get2())/64.0);\n#endif\n      shutter   = powf64(2.0,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n      {\n\tINT64 o = ftell(ifp);\n\tfseek (ifp, (0x5<<1), SEEK_CUR);\n\tCanon_WBpresets(0,0);\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x102d)\n      {\n\tINT64 o = ftell(ifp);\n\tCanon_CameraSettings();\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x580b)\n      {\n        if (strcmp(model,\"Canon EOS D30\")) sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n        else sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len>>16, len&0xffff);\n      }\n#endif\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[LIM(0,wbi,17)]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[LIM(0,wbi,17)]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[LIM(0,wbi,9)]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi>=0 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c) {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal  = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2) {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n\tif(imgdata.lens.makernotes.CanonFocalUnits>1)\n\t  imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834)\n      {\n         unique_id  = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n         setCanonBodyFeatures(unique_id);\n#endif\n      }\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      } else {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4) imgdata.lens.makernotes.CurAp =  powf64(2.0f, (int_to_float(data)/2.0f));\n      else imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type)/2.0f));\n      break;\n    case 0x0403:\n      if (type == 4) imgdata.lens.makernotes.CurFocal =  int_to_float(data);\n      else imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4) {\n        imgdata.lens.makernotes.MinFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n        {\n          imgdata.lens.makernotes.MinFocal = 0.0f;\n        }\n      break;\n    case 0x0417:\n      if (type == 4) {\n        imgdata.lens.makernotes.MaxFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.P1_color[0].romm_cam[i]=\n#endif\n\t  ((float *)romm_cam)[i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_col = data+base;\t\tbreak;\n      case 0x224:  ph1.split_row = data;\t\tbreak;\n      case 0x225:  ph1.black_row = data+base;\t\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x226:\n\tfor (i=0; i < 9; i++)\n\t  imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n\tbreak;\n#endif\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0]) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek (ifp, 6, SEEK_CUR);\n    fseek (ifp, meta_offset+get4(), SEEK_SET);\n    entries = get4();  get4();\n    while (entries--) {\n      tag  = get4();\n      len  = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek (ifp, meta_offset+data, SEEK_SET);\n      if (tag == 0x0407) {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        } else {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x131) {\n      filters = 9;\n      FORC(36)\n        {\n           int q = fgetc(ifp);\n           xtrans_abs[0][35 - c] = MAX(0,MIN(q,2)); /* & 3;*/\n        }\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    }\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b =fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    } else if (tag == 0x2100) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    } else if (tag == 0x2200) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    } else if (tag == 0x2300) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    } else if (tag == 0x2301) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    } else if (tag == 0x2302) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    } else if (tag == 0x2310) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    } else if (tag == 0x2400) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n    }\n#endif\n// IB end\n    else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000) tag = get4();\n      if (tag > 10000) tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len>>1);\n#endif\n\t  order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n    )\t\t/* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (save+hlen, len-hlen, 0);\n    }\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp)+7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n\t,int internal_only\n#endif\n)\n{\n  static const struct {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0,\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0, \n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp, same as sd Quattro */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if(colors>4 || colors < 1) return;\n\n  int bl4=(cblack[0]+cblack[1]+cblack[2]+cblack[3])/4,bl64=0;\n  if(cblack[4]*cblack[5]>0)\n  {\n\t  for (unsigned c = 0; c < 4096 && c < cblack[4]*cblack[5]; c++)\n\t\t  bl64+=cblack[c+6];\n\t  bl64 /= cblack[4]*cblack[5];\n  }\n  int rblack  = black+bl4+bl64;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix))) {\n      if(!dng_version)\n\t{\n\t  if (table[i].t_black>0)\n\t    {\n\t      black   = (ushort) table[i].t_black;\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  else if(table[i].t_black <0 && rblack == 0 )\n\t    {\n\t      black   = (ushort) (-table[i].t_black);\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  if (table[i].t_maximum)\n\t      maximum = (ushort) table[i].t_maximum;\n\t}\n      if (table[i].trans[0]) {\n\tfor (raw_color = j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\t\tif(internal_only)\n\t\t\timgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\t\telse\n                  imgdata.color.cam_xyz[0][j] =\n#endif\n                    ((double*)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(!internal_only)\n#endif\n          cam_xyz_coeff (rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n  string[len-1]=0;\n  if(len<3) return; // also not needed\n  len = strnlen(string,len-1);\n  for(int i=len-1; i>=0; i--)\n  {\n    if(isspace(string[i]))\n      string[i]=0;\n    else\n      break;\n  }\n}\n\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 },\n  };\n  static const ushort canon[][11] = {\n    { 1944, 1416,   0,  0, 48,  0 },\n    { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },\n    { 2224, 1456,  48,  6,  0,  2 },\n    { 2376, 1728,  12,  6, 52,  2 },\n    { 2672, 1968,  12,  6, 44,  2 },\n    { 3152, 2068,  64, 12,  0,  0, 16 },\n    { 3160, 2344,  44, 12,  4,  4 },\n    { 3344, 2484,   4,  6, 52,  6 },\n    { 3516, 2328,  42, 14,  0,  0 },\n    { 3596, 2360,  74, 12,  0,  0 },\n    { 3744, 2784,  52, 12,  8, 12 },\n    { 3944, 2622,  30, 18,  6,  2 },\n    { 3948, 2622,  42, 18,  0,  2 },\n    { 3984, 2622,  76, 20,  0,  2, 14 },\n    { 4104, 3048,  48, 12, 24, 12 },\n    { 4116, 2178,   4,  2,  0,  0 },\n    { 4152, 2772, 192, 12,  0,  0 },\n    { 4160, 3124, 104, 11,  8, 65 },\n    { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },\n    { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },\n    { 4312, 2876,  22, 18,  0,  2 },\n    { 4352, 2874,  62, 18,  0,  0 },\n    { 4476, 2954,  90, 34,  0,  0 },\n    { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },\n    { 4480, 3366,  80, 50,  0,  0 },\n    { 4496, 3366,  80, 50, 12,  0 },\n    { 4768, 3516,  96, 16,  0,  0, 0, 16 },\n    { 4832, 3204,  62, 26,  0,  0 },\n    { 4832, 3228,  62, 51,  0,  0 },\n    { 5108, 3349,  98, 13,  0,  0 },\n    { 5120, 3318, 142, 45, 62,  0 },\n    { 5280, 3528,  72, 52,  0,  0 },  /* EOS M */\n    { 5344, 3516, 142, 51,  0,  0 },\n    { 5344, 3584, 126,100,  0,  2 },\n    { 5360, 3516, 158, 51,  0,  0 },\n    { 5568, 3708,  72, 38,  0,  0 },\n    { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },\n    { 5712, 3774,  62, 20, 10,  2 },\n    { 5792, 3804, 158, 51,  0,  0 },\n    { 5920, 3950, 122, 80,  2,  0 },\n    { 6096, 4056, 72, 34,  0,  0 },     /* EOS M3 */\n    { 6288, 4056, 266, 36,  0,  0 },     /* EOS 80D */\n    { 6880, 4544, 136, 42,  0,  0 },     /* EOS 5D4 */\n    { 8896, 5920, 160, 64,  0,  0 },\n  };\n  static const struct {\n    ushort id;\n    char t_model[20];\n  } unique[] = {\n    { 0x001, \"EOS-1D\" },\n    { 0x167, \"EOS-1DS\" },\n    { 0x168, \"EOS 10D\" },\n    { 0x169, \"EOS-1D Mark III\" },\n    { 0x170, \"EOS 300D\" },\n    { 0x174, \"EOS-1D Mark II\" },\n    { 0x175, \"EOS 20D\" },\n    { 0x176, \"EOS 450D\" },\n    { 0x188, \"EOS-1Ds Mark II\" },\n    { 0x189, \"EOS 350D\" },\n    { 0x190, \"EOS 40D\" },\n    { 0x213, \"EOS 5D\" },\n    { 0x215, \"EOS-1Ds Mark III\" },\n    { 0x218, \"EOS 5D Mark II\" },\n    { 0x232, \"EOS-1D Mark II N\" },\n    { 0x234, \"EOS 30D\" },\n    { 0x236, \"EOS 400D\" },\n    { 0x250, \"EOS 7D\" },\n    { 0x252, \"EOS 500D\" },\n    { 0x254, \"EOS 1000D\" },\n    { 0x261, \"EOS 50D\" },\n    { 0x269, \"EOS-1D X\" },\n    { 0x270, \"EOS 550D\" },\n    { 0x281, \"EOS-1D Mark IV\" },\n    { 0x285, \"EOS 5D Mark III\" },\n    { 0x286, \"EOS 600D\" },\n    { 0x287, \"EOS 60D\" },\n    { 0x288, \"EOS 1100D\" },\n    { 0x289, \"EOS 7D Mark II\" },\n    { 0x301, \"EOS 650D\" },\n    { 0x302, \"EOS 6D\" },\n    { 0x324, \"EOS-1D C\" },\n    { 0x325, \"EOS 70D\" },\n    { 0x326, \"EOS 700D\" },\n    { 0x327, \"EOS 1200D\" },\n    { 0x328, \"EOS-1D X Mark II\" },\n    { 0x331, \"EOS M\" },\n    { 0x335, \"EOS M2\" },\n    { 0x374, \"EOS M3\"},   /* temp */\n    { 0x384, \"EOS M10\"},  /* temp */\n    { 0x394, \"EOS M5\"},   /* temp */\n    { 0x346, \"EOS 100D\" },\n    { 0x347, \"EOS 760D\" },\n    { 0x349, \"EOS 5D Mark IV\" },\n    { 0x350, \"EOS 80D\"},\n    { 0x382, \"EOS 5DS\" },\n    { 0x393, \"EOS 750D\" },\n    { 0x401, \"EOS 5DS R\" },\n    { 0x404, \"EOS 1300D\" },\n  }, sonique[] = {\n    { 0x002, \"DSC-R1\" },\n    { 0x100, \"DSLR-A100\" },\n    { 0x101, \"DSLR-A900\" },\n    { 0x102, \"DSLR-A700\" },\n    { 0x103, \"DSLR-A200\" },\n    { 0x104, \"DSLR-A350\" },\n    { 0x105, \"DSLR-A300\" },\n    { 0x106, \"DSLR-A900\" },\n    { 0x107, \"DSLR-A380\" },\n    { 0x108, \"DSLR-A330\" },\n    { 0x109, \"DSLR-A230\" },\n    { 0x10a, \"DSLR-A290\" },\n    { 0x10d, \"DSLR-A850\" },\n    { 0x10e, \"DSLR-A850\" },\n    { 0x111, \"DSLR-A550\" },\n    { 0x112, \"DSLR-A500\" },\n    { 0x113, \"DSLR-A450\" },\n    { 0x116, \"NEX-5\" },\n    { 0x117, \"NEX-3\" },\n    { 0x118, \"SLT-A33\" },\n    { 0x119, \"SLT-A55V\" },\n    { 0x11a, \"DSLR-A560\" },\n    { 0x11b, \"DSLR-A580\" },\n    { 0x11c, \"NEX-C3\" },\n    { 0x11d, \"SLT-A35\" },\n    { 0x11e, \"SLT-A65V\" },\n    { 0x11f, \"SLT-A77V\" },\n    { 0x120, \"NEX-5N\" },\n    { 0x121, \"NEX-7\" },\n    { 0x122, \"NEX-VG20E\"},\n    { 0x123, \"SLT-A37\" },\n    { 0x124, \"SLT-A57\" },\n    { 0x125, \"NEX-F3\" },\n    { 0x126, \"SLT-A99V\" },\n    { 0x127, \"NEX-6\" },\n    { 0x128, \"NEX-5R\" },\n    { 0x129, \"DSC-RX100\" },\n    { 0x12a, \"DSC-RX1\" },\n    { 0x12b, \"NEX-VG900\" },\n    { 0x12c, \"NEX-VG30E\" },\n    { 0x12e, \"ILCE-3000\" },\n    { 0x12f, \"SLT-A58\" },\n    { 0x131, \"NEX-3N\" },\n    { 0x132, \"ILCE-7\" },\n    { 0x133, \"NEX-5T\" },\n    { 0x134, \"DSC-RX100M2\" },\n    { 0x135, \"DSC-RX10\" },\n    { 0x136, \"DSC-RX1R\" },\n    { 0x137, \"ILCE-7R\" },\n    { 0x138, \"ILCE-6000\" },\n    { 0x139, \"ILCE-5000\" },\n    { 0x13d, \"DSC-RX100M3\" },\n    { 0x13e, \"ILCE-7S\" },\n    { 0x13f, \"ILCA-77M2\" },\n    { 0x153, \"ILCE-5100\" },\n    { 0x154, \"ILCE-7M2\" },\n    { 0x155, \"DSC-RX100M4\" },\n    { 0x156, \"DSC-RX10M2\" },\n    { 0x158, \"DSC-RX1RM2\" },\n    { 0x15a, \"ILCE-QX1\" },\n    { 0x15b, \"ILCE-7RM2\" },\n    { 0x15e, \"ILCE-7SM2\" },\n    { 0x161, \"ILCA-68\" },\n    { 0x162, \"ILCA-99M2\" },\n    { 0x163, \"DSC-RX10M3\" },\n    { 0x164, \"DSC-RX100M5\"},\n    { 0x165, \"ILCE-6300\" },\n    { 0x168, \"ILCE-6500\"},\n  };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t\n    const_table[]\n#else\n  static const struct {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  }\n  table[]\n#endif\n   = {\n    {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-080C\" },\n    {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-145C\" },\n    {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-201C\" },\n    {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\" },\n    {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\" },\n    { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-810C\" },\n    { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,\"AgfaPhoto\",\"DC-833m\" },\n    {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,\"Alcatel\",\"5035D\" },\n    {  31850496,4608,3456, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 4:3\" },\n    {  23887872,4608,2592, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 16:9\" },\n//   Android Raw dumps id start\n//   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n    {  1540857,2688,1520, 0, 0, 0, 0, 1,0x61,0,0,\"Samsung\",\"S3\" },\n    {  2658304,1212,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontMipi\" },\n    {  2842624,1296,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontQCOM\" },\n    {  2969600,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wMipi\" },\n    {  3170304,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wQCOM\" },\n    {  3763584,1584,1184, 0, 0, 0, 0, 96,0x61,0,0,\"I_Mobile\",\"I_StyleQ6\" },\n    {  5107712,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel1\" },\n    {  5382640,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel2\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5364240,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  6299648,2592,1944, 0, 0, 0, 0, 1 ,0x16,0,0,\"OmniVisi\",\"OV5648\" },\n    {  6721536,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"OmniVisi\",\"OV56482\" },\n    {  6746112,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"OneSV\" },\n    {  9631728,2532,1902, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"5mp\" },\n    {  9830400,2560,1920, 0, 0, 0, 0, 96,0x61,0,0,\"NGM\",\"ForwardArt\" },\n    { 10186752,3264,2448, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX219-mipi 8mp\" },\n    { 10223360,2608,1944, 0, 0, 0, 0, 96,0x16,0,0,\"Sony\",\"IMX\" },\n    { 10782464,3282,2448, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"MyTouch4GSlide\" },\n    { 10788864,3282,2448, 0, 0, 0, 0, 0, 0x16,0,0,\"Xperia\",\"L\" },\n    { 15967488,3264,2446, 0, 0, 0, 0, 96,0x16,0,0,\"OmniVison\",\"OV8850\" },\n    { 16224256,4208,3082, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3MipiL\" },\n    { 16424960,4208,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"IMX135\",\"MipiL\" },\n    { 17326080,4164,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3LQCom\" },\n    { 17522688,4212,3120, 0, 0, 0, 0, 0,0x16,0,0,\"Sony\",\"IMX135-QCOM\" },\n    { 19906560,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7mipi\" },\n    { 19976192,5312,2988, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G4\" },\n    { 20389888,4632,3480, 0, 0, 0, 0, 1, 0x16,0,0,\"Xiaomi\",\"RedmiNote3Pro\" },\n    { 20500480,4656,3496, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX298-mipi 16mp\" },\n    { 21233664,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7qcom\" },\n    { 26023936,4192,3104, 0, 0, 0, 0, 96,0x94,0,0,\"THL\",\"5000\" },\n    { 26257920,4208,3120, 0, 0, 0, 0, 96,0x94,0,0,\"Sony\",\"IMX214\" },\n    { 26357760,4224,3120, 0, 0, 0, 0, 96,0x61,0,0,\"OV\",\"13860\" },\n    { 41312256,5248,3936, 0, 0, 0, 0, 96,0x61,0,0,\"Meizu\",\"MX4\" },\n    { 42923008,5344,4016, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"IMX230\" },\n    //   Android Raw dumps id end\n    {  20137344,3664,2748,0, 0, 0, 0,0x40,0x49,0,0,\"Aptina\",\"MT9J003\",0xffff },\n    {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,\"Baumer\",\"TXG14\",1078 },\n    {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,\"Canon\",\"PowerShot SD300\" },\n    {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,\"Canon\",\"PowerShot A460\" },\n    {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,\"Canon\",\"PowerShot A610\" },\n    {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,\"Canon\",\"PowerShot A530\" },\n    {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot S3 IS\" },\n    {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot A620\" },\n    {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,\"Canon\",\"PowerShot A470\" },\n    { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,\"Canon\",\"PowerShot A720 IS\" },\n    { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,\"Canon\",\"PowerShot A630\" },\n    { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,\"Canon\",\"PowerShot A640\" },\n    { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot A650\" },\n    { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,\"Canon\",\"PowerShot SX110 IS\" },\n    { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,\"Canon\",\"PowerShot SX120 IS\" },\n    { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot SX20 IS\" },\n    { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,\"Canon\",\"PowerShot SX220 HS\" },\n    { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,\"Canon\",\"PowerShot SX30 IS\" },\n    { 24724224,4704,3504, 8,16,56, 8,40,0x49,0,2,\"Canon\",\"PowerShot A3300 IS\" },\n    { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,\"Canon\",\"IXUS 160\" },\n    {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,\"Casio\",\"QV-2000UX\" },\n    {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,\"Casio\",\"QV-3*00EX\" },\n    {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,\"Casio\",\"QV-5700\" },\n    {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,\"Casio\",\"EX-Z60\" },\n    {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,\"Casio\",\"EX-S20\" },\n    {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,\"Casio\",\"EX-S100\" },\n    {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,\"Casio\",\"QV-R41\" },\n    {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,\"Casio\",\"EX-P505\" },\n    {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,\"Casio\",\"QV-R51\" },\n    {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,\"Casio\",\"EX-Z50\" },\n    {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,\"Casio\",\"EX-Z500\" },\n    {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,\"Casio\",\"EX-Z55\" },\n    {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,\"Casio\",\"EX-P600\" },\n    { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,\"Casio\",\"EX-Z750\" },\n    { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,\"Casio\",\"EX-Z75\" },\n    { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,\"Casio\",\"EX-P700\" },\n    { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,\"Casio\",\"EX-Z850\" },\n    { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,\"Casio\",\"EX-Z8\" },\n    { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,\"Casio\",\"EX-Z1050\" },\n    { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,\"Casio\",\"EX-ZR100\" },\n    {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,\"Casio\",\"QV-4000\" },\n    {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,\"Creative\",\"PC-CAM 600\" },\n    { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,\"DJI\" },\n    { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,\"Matrix\" },\n    {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,\"Foculus\",\"531C\" },\n    {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,\"Generic\" },\n    {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,\"Kodak\",\"DCS200\" },\n    {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\" },\n    {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\",3160 },\n    {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\" },\n    {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\",3160 },\n    {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\" },\n    { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\",31556 },\n    { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"12MP\" },\n    {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,\"Kodak\",\"KAI-0340\" },\n    { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,\"Lenovo\",\"A820\" },\n    {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,\"Micron\",\"2010\",3212 },\n    {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,\"Minolta\",\"RD175\",513 },\n    {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,\"Nikon\",\"E900\" },\n    {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,\"Nikon\",\"E950\" },\n    {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,\"Nikon\",\"E2100\" },\n    {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,\"Nikon\",\"E990\" },\n    {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,\"Nikon\",\"E3700\" },\n    {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E4500\" },\n    {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,\"Nikon\",\"E4300\" },\n    {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E5000\" },\n    {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,\"Nikon\",\"COOLPIX S6\" },\n    {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,\"Olympus\",\"C770UZ\" },\n    {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,\"Pentax\",\"Optio S\" },\n    {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S\" },\n    {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S4\" },\n    { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,\"Pentax\",\"Optio 750Z\" },\n    {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\" },\n    {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\",8 },\n    { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,\"Pixelink\",\"A782\" },\n    {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,\"RoverShot\",\"3320AF\" },\n    {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,\"ST Micro\",\"STV680 VGA\" },\n    { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n    {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n  };\n#ifdef LIBRAW_LIBRARY_BUILD\n    libraw_custom_camera_t\n      table[64 + sizeof(const_table)/sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] =\n    { \"AgfaPhoto\", \"Canon\", \"Casio\", \"Epson\", \"Fujifilm\",\n      \"Mamiya\", \"Minolta\", \"Motorola\", \"Kodak\", \"Konica\", \"Leica\",\n      \"Nikon\", \"Nokia\", \"Olympus\", \"Pentax\", \"Phase One\", \"Ricoh\",\n      \"Samsung\", \"Sigma\", \"Sinar\", \"Sony\" };\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize=1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64,table,imgdata.params.custom_camera_strings);\n  for(int q = 0; q < sizeof(const_table)/sizeof(const_table[0]); q++)\n\tmemmove(&table[q+camera_count],&const_table[q],sizeof(const_table[0]));\n  camera_count += sizeof(const_table)/sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX;\t/* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread (head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread (head, 1, 32, ifp);\n#endif\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (hlen, flen-hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 52, SEEK_SET);\n    switch (get4()) {\n      case  7: iso_speed = 25;  break;\n      case  8: iso_speed = 32;  break;\n      case  9: iso_speed = 40;  break;\n      case 10: iso_speed = 50;  break;\n      case 11: iso_speed = 64;  break;\n      case 12: iso_speed = 80;  break;\n      case 13: iso_speed = 100; break;\n      case 14: iso_speed = 125; break;\n      case 15: iso_speed = 160; break;\n      case 16: iso_speed = 200; break;\n      case 17: iso_speed = 250; break;\n      case 18: iso_speed = 320; break;\n      case 19: iso_speed = 400; break;\n    }\n    shutter = powf64(2.0f, (((float)get4())/8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek (ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek (ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head+0x1c);\n    memcpy(model2, head+0x3c, 4);\n    model2[4]=0;\n#endif\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4())?1:0;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head+4,\"ftypqt   \",9)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_qt (fsize);\n    is_raw = 0;\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i*8 / (width * height)) {\n      case  8: load_raw = &CLASS eight_bit_load_raw;  break;\n      case 10: load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"XPDS\",4)) {\n    order = 0x4949;\n    fseek (ifp, 0x800, SEEK_SET);\n    fread (make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width  = get2();\n    fseek (ifp, 56, SEEK_CUR);\n    fread (model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve (0, 12.25, 1, 1023);\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"Red\");\n    strcpy (model,\"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n  else if (!memcmp (head,\"FOVb\",4))\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n        parse_foveon();\n      else\n#endif\n        parse_x3f();\n#else\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      parse_foveon();\n#endif\n#endif\n    }\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  if(make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize=i=0; i < camera_count; i++)\n#else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\",5))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          }\n#endif\n\tstrcpy (model, table[i].t_model);\n\tflip = table[i].flags >> 2;\n\tzero_is_bad = table[i].flags & 2;\n\tif (table[i].flags & 1)\n\t  parse_external_jpeg();\n\tdata_offset = table[i].offset == 0xffff?0:table[i].offset;\n\traw_width   = table[i].rw;\n\traw_height  = table[i].rh;\n\tleft_margin = table[i].lm;\n\t top_margin = table[i].tm;\n\twidth  = raw_width - left_margin - table[i].rm;\n\theight = raw_height - top_margin - table[i].bm;\n\tfilters = 0x1010101 * table[i].cf;\n\tcolors = 4 - !((filters & filters >> 1) & 0x5555);\n\tload_flags = table[i].lf;\n\tswitch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {\n\t  case 6:\n\t    load_raw = &CLASS minolta_rd175_load_raw;  break;\n\t  case 8:\n\t    load_raw = &CLASS eight_bit_load_raw;  break;\n\t  case 10:\n           if ((fsize-data_offset)/raw_height*3 >= raw_width*4) {\n             load_raw = &CLASS android_loose_load_raw;  break;\n           } else if (load_flags & 1) {\n             load_raw = &CLASS android_tight_load_raw;  break;\n           }\n\t  case 12:\n\t    load_flags |= 128;\n\t    load_raw = &CLASS packed_load_raw;     break;\n\t  case 16:\n\t    order = 0x4949 | 0x404 * (load_flags & 1);\n\t    tiff_bps -= load_flags >> 4;\n\t    tiff_bps -= load_flags = load_flags >> 1 & 7;\n\t    load_raw = table[i].offset == 0xffff ? &CLASS  unpacked_load_raw_reversed : &CLASS  unpacked_load_raw;\n\t}\n\tmaximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model,\"RP_imx219\",9) && sz >= 0x9cb600 &&\n        !fseek (ifp, -0x9cb600, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n\tstrcpy (make, \"Broadcom\");\n\tstrcpy (model, \"RPi IMX219\");\n\tif (raw_height > raw_width) flip = 5;\n\tdata_offset = ftell(ifp) + 0x8000 - 0x20;\n\tparse_broadcom();\n\tblack = 66;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    } else\n      if (!(strncmp(model,\"ov5647\",6) && strncmp(model,\"RP_OV5647\",9)) && sz >= 0x61b800 &&\n        !fseek (ifp, -0x61b800, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n      strcpy (make, \"Broadcom\");\n      if (!strncmp(model,\"ov5647\",6))\n        strcpy (model, \"RPi OV5647 v.1\");\n      else\n        strcpy (model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width) flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n\tblack = 16;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model,\"ov\",2) && strncmp(model,\"RP_OV\",5)) && sz>=6404096 &&\n        !fseek (ifp, -6404096, SEEK_END) &&\n\t  fread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    } else is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr (make, corp[i]))\t/* Simplify company names */\n\t    strcpy (make, corp[i]);\n  if ((!strncmp(make,\"Kodak\",5) || !strncmp(make,\"Leica\",5)) &&\n\t((cp = strcasestr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  if (!strncasecmp(model,\"PENTAX\",6))\n    strcpy (make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make,sizeof(make));\n  remove_trailing_spaces(model,sizeof(model));\n#else\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n#endif\n  i = strbuflen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width == 6080 && !strcmp(model,\"K-70\"))\n     { height  = 4016; top_margin=32; width=6020; left_margin = 60; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 6080 && !strcmp(model,\"K-3 II\")) /* moved back */\n    { left_margin = 4;  width  = 6040; }\n  if (width == 6080 && !strcmp(model,\"K-3\"))\n    { left_margin = 4;  width  = 6040; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw *= tiff_samples;\n    else\t colors  = tiff_samples;\n    switch (tiff_compress) {\n      case 0:  /* Compression not set, assuming uncompressed */\n      case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;\n      case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8:     load_raw = &CLASS  deflate_dng_load_raw;  break;\n#endif\n      case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;\n      default:    load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\",5) && unique_id)\n      {\n        for (i = 0; i < sizeof unique / sizeof *unique; i++)\n          if (unique_id == 0x80000000 + unique[i].id)\n            {\n              strcpy(model, unique[i].t_model);\n              break;\n            }\n      }\n    if (!strncasecmp(make, \"Sony\",4) && unique_id)\n      {\n        for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n          if (unique_id == sonique[i].id)\n            {\n              strcpy(model, sonique[i].t_model);\n              break;\n            }\n      }\n    goto dng_skip;\n  }\n  if (!strncmp(make,\"Canon\",5) && !fsize && tiff_bps != 15) {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i=0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1]) {\n\twidth  = raw_width - (left_margin = canon[i][2]);\n\theight = raw_height - (top_margin = canon[i][3]);\n\twidth  -= canon[i][4];\n\theight -= canon[i][5];\n\tmask[0][1] =  canon[i][6];\n\tmask[0][3] = -canon[i][7];\n\tmask[1][1] =  canon[i][8];\n\tmask[1][3] = -canon[i][9];\n\tif (canon[i][10]) filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000) {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make,\"Canon\",5) && unique_id)\n    {\n      for (i=0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n          {\n            adobe_coeff (\"Canon\", unique[i].t_model);\n            strcpy(model,unique[i].t_model);\n          }\n    }\n\n  if (!strncasecmp(make,\"Sony\",4) && unique_id)\n    {\n      for (i=0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n          {\n            adobe_coeff (\"Sony\", sonique[i].t_model);\n            strcpy(model,sonique[i].t_model);\n          }\n    }\n\n  if (!strncmp(make,\"Nikon\",5)) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model,\"KAI-0340\")\n\t&& find_green (16, 16, 3840, 5120) < 25) {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy (model,\"C603\");\n  }\n\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if(!strncmp(make,\"Pentax\",6))\n  {\n    if(!strncmp(model,\"K-1\",3))\n    {\n  \ttop_margin = 18;\n \theight = raw_height - top_margin;\n\tif(raw_width == 7392)\n\t{\n\t  left_margin = 6;\n\t  width = 7376;\n\t}\n    }\n  }\n  else if (!strncmp(make,\"Canon\",5) && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) {\n      SWAP(height,width);\n      SWAP(raw_height,raw_width);\n    }\n    if (width == 7200 && height == 3888)\n      {\n\traw_width  = width  = 6480;\n\traw_height = height = 4320;\n      }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    filters = 0x1e4b4e1b;\ncanon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\") ||\n\t     !strcmp(model,\"PowerShot G1\")) {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    mask[1][3] = -4;\n    top_margin=16;\n    left_margin = 92;\n  } else if (!strcmp(model,\"PowerShot S120\")) {\n        raw_width = 4192;\n        raw_height = 3062;\n        width = 4022;\n        height = 3016;\n        mask[0][0] = top_margin = 31;\n        mask[0][2] = top_margin + height;\n        left_margin = 120;\n        mask[0][1] = 23;\n        mask[0][3] = 72;\n  } else if (!strcmp(model,\"PowerShot G16\")) {\n      mask[0][0] = 0;\n      mask[0][2] = 80;\n      mask[0][1] = 0;\n      mask[0][3] = 16;\n      top_margin = 29;\n      left_margin = 120;\n      width = raw_width-left_margin-48;\n      height = raw_height-top_margin-14;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin = 17;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\") ||\n\t     !strcmp(model,\"COOLPIX A\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t    !strncmp(model,\"D6\",2)  ||\n\t    !strncmp(model,\"D800\",4)) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\") ||\n\t     !strcmp(model,\"Df\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strncmp(make,\"Nikon\",5) && raw_width == 4032) {\n    if(!strcmp(model,\"COOLPIX P7700\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7700\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else if(!strcmp(model,\"COOLPIX P7800\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7800\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else  if(!strcmp(model,\"COOLPIX P340\"))\n      load_flags=0;\n  } else if (!strncmp(model,\"COOLPIX P\",9) && raw_width != 4032) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed==0) && !strstr(software,\"V1.2\") )\n      black = 255;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  } else if (fsize == 3178560) {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  } else if (fsize == 4771840) {\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (fsize == 2940928) {\n    if (!timestamp && !nikon_e2100())\n      strcpy (model,\"E2500\");\n    if (!strcmp(model,\"E2500\")) {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  } else if (fsize == 4775936) {\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (fsize == 6291456) {\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strncmp(make,\"Fujifilm\",8)) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848 || width == 3664) filters = 0x16161616;\n    if (width == 4032 || width == 4952) left_margin = 0;\n    if (width == 3328 && (width -= 66)) left_margin = 34;\n    if (width == 4936) left_margin = 4;\n    if (width == 6032) left_margin = 0;\n    if (!strcmp(model,\"HS50EXR\") ||\n\t!strcmp(model,\"F900EXR\")) {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if(!strcmp(model,\"S5500\"))\n      {\n        height -= (top_margin=6);\n      }\n    if (fuji_layout) raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36) ((char *)xtrans)[c] =\n\txtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strncasecmp(make,\"Minolta\",7)) {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strncmp(make,\"Samsung\",7) && !strcmp(model,\"NX3000\")) {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_height == 3714) {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5664) {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 6496) {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n    black = 1 << (tiff_bps - 7);\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (strstr(model,\"WB550\")) {\n    strcpy (model, \"WB550\");\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3030;\n    width  = 4040;\n    top_margin = 15;\n    left_margin=24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    black = 16;\n  } else if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"640x480\")) {\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strncmp(make,\"Hasselblad\",10)) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if(!strncasecmp(model,\"H3D\",3))\n        {\n          adobe_coeff(\"Hasselblad\",\"H3DII-39\");\n          strcpy(model,\"H3DII-39\");\n        }\n    } else if (raw_width == 7410 || raw_width == 8282) {\n      height -= 84;\n      width  -= 82;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\",\"H4D-40\");\n      strcpy(model,\"H4D-40\");\n    }\n    else if( raw_width == 8384) // X1D\n    {\n     top_margin  = 96;\n     height -= 96;\n     left_margin = 48;\n     width  -= 106;\n     adobe_coeff(\"Hasselblad\",\"X1D\");\n    }\n    else if (raw_width == 9044) {\n      if(black > 500)\n        {\n          top_margin = 12;\n          left_margin = 44;\n          width = 8956;\n          height = 6708;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H4D-60\");\n          strcpy(model,\"H4D-60\");\n          black = 512;\n        }\n      else\n        {\n          height = 6716;\n          width  = 8964;\n          top_margin  = 8;\n          left_margin = 40;\n          black += load_flags = 256;\n          maximum = 0x8101;\n          strcpy(model,\"H3DII-60\");\n        }\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    } else if (raw_width == 8282 && raw_height == 6240) {\n      if(!strncasecmp(model,\"H5D\",3))\n        {\n          /* H5D 50*/\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          black = 256;\n          strcpy(model,\"H5D-50\");\n        }\n      else if(!strncasecmp(model,\"H3D\",3))\n        {\n          black=0;\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H3D-50\");\n          strcpy(model,\"H3D-50\");\n        }\n    } else if (raw_width == 8374 && raw_height == 6304) {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model,\"H5D-50c\");\n    }\n    if (tiff_samples > 1) {\n      is_raw = tiff_samples+1;\n      if (!shot_select && !half_size) filters = 0;\n    }\n  } else if (!strncmp(make,\"Sinar\",5)) {\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size) filters = 0;\n    maximum = 0x3fff;\n  } else if (!strncmp(make,\"Leaf\",4)) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strncmp(make,\"Leica\",5) || !strncmp(make,\"Panasonic\",9)\n      || !strncasecmp(make,\"YUNEEC\",6)) {\n    if (raw_width > 0&& ((flen - data_offset) / (raw_width*8/7) == raw_height) )\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strncmp(make,\"Olympus\",7)) {\n    height += height & 1;\n    if (exif_cfa) filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (width == 9280) { width -= 6; height -= 6; }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"STYLUS1\")) {\n      width -= 14;\n      maximum = 0xfff;\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"TG-4\")) {\n      width -= 16;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 3984) {\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4288) {\n    width -= 32;\n  }  else if (!strcmp(make, \"Sony\") && raw_width == 4600) {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4928) {\n    if (height < 3280) width -= 8;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 5504) { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 6048) {\n    width -= 24;\n    if (strstr(model,\"RX1\") || strstr(model,\"A99\"))\n      width -= 6;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 7392) {\n    width -= 30;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 8000) {\n    width -= 32;\n    if (!strncmp(model, \"DSC\", 3)) {\n      tiff_bps = 14;\n      load_raw = &CLASS unpacked_load_raw;\n    }\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      height -= 4;\n      width  -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603\") || !strcmp(model,\"C330\")\n\t|| !strcmp(model,\"12MP\")) {\n    order = 0x4949;\n    if (filters && data_offset) {\n      fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw  =  filters   ? &CLASS eight_bit_load_raw :\n      strcmp(model,\"C330\") ? &CLASS kodak_c603_load_raw :\n\t\t\t     &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strncasecmp(make,\"Kodak\",5)) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6) ||\n\t!strncmp(model,\"EOSDCS\",6) ||\n\t!strncmp(model,\"DCS4\",4)) {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ') model[6] = 0;\n      if (!strcmp(model,\"DCS460A\")) goto bw;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      goto bw;\n    } else if (!strcmp(model,\"DCS760M\")) {\nbw:   colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      iso_speed=84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      iso_speed=160;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      iso_speed=140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strncmp(make,\"Rollei\",6) && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(dng_version) /* Override black level by DNG tags */\n  {\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0,\n    (sizeof(cblack)/sizeof(cblack[0])),\n    (sizeof(imgdata.color.dng_levels.dng_cblack)/sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for(int i=0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2) )\n\t&& cmatrix[0][0] > 0.125) {\n    memcpy (rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color) adobe_coeff (make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(imgdata.color.cam_xyz[0][0]<0.01)\n\t  adobe_coeff (make, model,1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum)\n    {\n      maximum = (1 << tiff_bps) - 1;\n      if(maximum < 0x10000 && curve[maximum]>0 &&    load_raw == &CLASS sony_arw2_load_raw)\n        maximum = curve[maximum];\n    }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if(raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX) flip = tiff_flip;\n  if (flip == UINT_MAX) flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if(flip > 89 || flip < -89)\n   {\n     switch ((flip+3600) % 360)\n     {\n       case 270:  flip = 5;  break;\n       case 180:  flip = 3;  break;\n       case  90:  flip = 6;  break;\n     }\n   }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\n\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double aces_rgb[3][3] =\n  { { 0.432996, 0.375380, 0.189317 },\n    { 0.089427, 0.816523, 0.102989 },\n    { 0.019165, 0.118150, 0.941914 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 ||\n\t\toutput_color < 1 || output_color > 6;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (high, wide*sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n\nvoid CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2) {\n    count = strnlen((char *)th + val, count-1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val+c];\n  } else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n  if (full) {\n    tiff_set (th, &th->ntag, 254, 4, 1, 0);\n    tiff_set (th, &th->ntag, 256, 4, 1, width);\n    tiff_set (th, &th->ntag, 257, 4, 1, height);\n    tiff_set (th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (th, &th->ntag, 259, 3, 1, 1);\n    tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (th, &th->ntag, 277, 3, 1, colors);\n    tiff_set (th, &th->ntag, 278, 4, 1, height);\n    tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (th, &th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (th, &th->ntag, 284, 3, 1, 1);\n  tiff_set (th, &th->ntag, 296, 3, 1, 2);\n  tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (th, &th->ngps,  0, 1,  4, 0x202);\n    tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n#endif\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n"], "fixing_code": ["2017-09-13  Alex Tutubalin <lexa@lexa.ru>\n * Fixed possible out of bound access in Kodak 6500 loader\n\n2017-09-12  Alex Tutubalin <lexa@lexa.ru>\n * CVE-2017-14348: Fix for possible heap overrun in Canon makernotes parser\n   Credit: Henri Salo from Nixu Corporation\n * LibRaw 0.18.4\n\n2017-09-09  Alex Tutubalin <lexa@lexa.ru>\n * Fix for CVE-2017-13735\n * CVE-2017-14265: Additional check for X-Trans CFA pattern data\n * LibRaw 0.18.3\n\n2017-03-08  Alex Tutubalin <lexa@lexa.ru>\n * Fixed several errors (Secunia advisory SA75000)\n * ACES colorspace output option included in dcraw_emu help page\n * Avoided possible 32-bit overflows in Sony metadata parser\n * Phase One flat field code called even for half-s\n * LibRaw 0.18.2\n\n2017-02-12  Alex Tutubalin <lexa@lexa.ru>\n * Camera Support: Sigma Quatto H\n * Fixed bug in FujiExpoMidPointShift parser\n * Fixed wrong black level in Sony A350\n * Added standard integer types for VisualStudio 2008 and earlier\n * LibRaw 0.18.1\n \n2016-12-27  Alex Tutubalin <lexa@lexa.ru>\n * Licensing changes:\n    - there is no 'LibRaw Software License 27032010' licensing anymore (and all signed\n      agreements have expired)\n    - LibRaw is now dual-licensed: LGPL 2.1 or CDDL 1.0\n\n * Camera support (+87):\n     Apple: iPad Pro, iPhone SE, iPhone 6s, iPhone 6 plus, iPhone 7, iPhone 7 plus\n     BlackMagic Micro Cinema Camera, URSA, URSA Mini\n     Canon PowerShot G5 X, PowerShot G7 X Mark II, PowerShot G9 X,\n       IXUS 160 (CHDK hack), EOS 5D Mark IV, EOS 80D, EOS 1300D, EOS M10, EOS M5,\n       EOS-1D X Mark II\n     Casio EX-ZR4000/5000\n     DXO One,\n     FujiFilm X-Pro2, X70, X-E2S, X-T2\n     Gione E7\n     GITUP GIT2\n     Google Pixel,Pixel XL\n     Hasselblad X1D, True Zoom\n     HTC MyTouch 4G, One (A9), One (M9), 10\n     Huawei P9\n     Leica M (Typ 262), M-D (Typ 262), S (Typ 007), SL (Typ 601), X-U (Typ 113), TL\n     LG G3, G4\n     Meizy MX4\n     Nikon D5, D500, D3400\n     Olympus E-PL8, E-M10 Mark II, Pen F, SH-3, E-M1-II\n     Panasonic DMC-G8/80/81/85, DMC-GX80/85, DMC-TZ80/81/85/ZS60, DMC-TZ100/101/ZS100,DMC-LX9/10/15, FZ2000/FZ2500\n     Pentax K-1, K-3 II, K-70\n     PhaseOne IQ3 100MP\n     RaspberryPi Camera, Camera V2\n     Ricoh GR II\n     Samsung Galaxy S7, S7 Edge\n     Sigma sd Quattro\n     Sony A7S II, ILCA-68 (A68),ILCE-6300,DSC-RX1R II,DSC-RX10III, DSC-RX100V,ILCA-99M2 (A99-II), a6500\n          IMX214, IMX219, IMX230, IMX298-mipi 16mp, IMX219-mipi 8mp, Xperia L\n     PtGrey GRAS-50S5C\n     YUNEEC CGO4\n     Xiaomi MI3, RedMi Note3 Pro\n\n * Floating point DNG support:\n    - new data fields:\n      imgdata.rawdata.float_image - bayer float data\n      imgdata.rawdata.float3_image - 3-component float data\n      imgdata.rawdata.float4_image - 4-component float data\n      imgdata.color.fmaximum - float data maximum (calculated from real data,\n          rounded to 1.0 if below 1.0)\n   - new raw processing flag\n      LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT - converts float data to 16-bit\n        integer immediately after decoding with default parameters\n   - new API Calls:\n      int LibRaw::is_floating_point() returns non-zero if RAW file contains\n          floating point data\n      int LibRaw::have_fpdata() returns non-zero if rawdata.float*_image is not\n        null (so FP data has been unpacked but not converted to integrer, see below).\n      LibRaw::convertFloatToInt(float dmin=4096.f, float dmax=32767.f, float dtarget = 16383.f)\n        converts float/float3/float4_image to raw_image/color3/color4_image with or without scaling:\n       - if both real data maximum and metadata maximum are within the range ( >= dmin && <=dmax), float\n         data is just converted to integer\n       - if data is out of the range given above, values are scaled so real data maximum becomes dtarget\n       - if data was rescaled (normalized), scale multiplier is stored in imgdata.color.fnorm\n\n * LibRaw can be built with Adobe DNG SDK support to decode exotic DNG formats (e.g. 8 bit).\n   See README.DNGSDK.txt for details\n\n * New API calls\n    unsigned LibRaw::capabilities and C-API libraw_capabilities()\n    allows developers to determine LibRaw compile flags at runtime.\n    Returns ORed bit fields:\n    LIBRAW_CAPS_RAWSPEED - LibRaw was compiled with RawSpeed Support\n    LIBRAW_CAPS_DNGSDK - LibRaw was compiled with Adobe DNG SDK\n    LIBRAW_CAPS_DEMOSAICSGPL2, LIBRAW_CAPS_DEMOSAICSGPL3 - LibRaw was compiled with demosaic packs (GPL2/GPL3)\n\n * More metadata parsed:\n    - White balance coefficients stored in the raw file are extracted into:\n     int imgdata.color.WBCoeffs[256][4] - array indexed by EXIF lightsource type\n        for example, WBCoeffs[21][..] contains coefficients for D65 lightsource\n     float imgdata.color.WBCT_Coeffs[64][5] contains white balance data specified\n       for given color temperature: WBCT_Coeffs[i][0] contains temperature value,\n       and [1]..[4] are WB coefficients.\n    - DNG analog balance, per-channel black/white level, and forward matrix\n    - vendor specific metadata stored in vendor-specific data structures\n\n * new C-API calls:\n    void libraw_set_user_mul(libraw_data_t *lr,int index, float val);\n    void libraw_set_ca_correction(libraw_data_t *lr,int ca_correc, float ca_red, float ca_blue);\n    void libraw_set_cfalinenoise(libraw_data_t *lr,int cfaline, float linenoise);\n    void libraw_set_wf_debanding(libraw_data_t *lr, int wf_debanding, float wfd0, float wfd1, float wfd2, float wfd3);\n    void libraw_set_interpolation_passes(libraw_data_t *lr,int passes);\n\n * Existing API changes:\n    imgdata.params fields (all very specific purpose): sony_arw2_options, sraw_ycc, and params.x3f_flags\n    replaced with single bit-field raw_processing_options\n    See  LIBRAW_PROCESSING_* bits in documentation.\n\n * zlib library is optional\n   Use -DUSE_ZLIB to compile with zlib (to provide deflate DNG support)\n * libjpeg version: jpeg_mem_src() is mandatory, so use libjpeg-turbo\n   or libjpeg 8+\n * Fixes in vng_intepolate to make modern compilers happy\n * Fixed bug in Sony SR2 files black level\n * DNG files with BlackLevel both in vendor makernotes and BlackLevel:\n    BlackLevel tag always takes precedence\n * strlen replaced with strnlen in most cases, added local version of strnlen\n * ChannelBlackLevel added to canon makernotes\n * unpack_thumb() data size/offset check against file size\n\n2015-08-15  Alex Tutubalin <lexa@lexa.ru>\n\n * LibRaw 0.17\n\n * Fixed dcraw.c ljpeg_start possibly buffer overrun\n\n * fixed several bugs detected by using American Fuzzy Lop\n\n * C-API extension to support 3DLut Creator\n\n * More metadata parsing/extraction:\n    - XMP packet extracted (if exists)\n    - DNG Color information parsed\n    - GPS data (partially) parsed\n    - EXIF/Makernotes parsed for used optics (for both RAW files and DNG converted by Adobe convertor).\n\n * Exif/Makernotes parser callback (called for each processed tag)\n\n * Sony ARW2.3 decoder:\n   - params.sony_arw2_hack removed, decoded data are always in 0...17k range (note the difference with dcraw!)\n   - Additional processing options for Sony lossy compression techincal analysis.\n\n * Dcraw 9.26 imported (but some changes not approved because Libraw do it better) with some exceptions:\n    - no Pentax K3-II frame selection code\n    - no built-in JPEG decompressor\n\n * Many improvements in data decoding/processing:\n    - Correct decoding of black level values from metadata for many formats, LibRaw do not rely on hardcoded black levels.\n\n * 224 camera models added to supported camera list.\n   Some of them are new (released since LibRaw 0.16 come out), some was supported before, but missed from the list.\n   Added cameras are:\n\n  Alcatel 5035D\n  BlackMagic Pocket Cinema Camera, Production Camera 4k\n  Canon PowerShot A550, A3300 IS, G1 X Mark II, G7 X, SD950, SX60 HS, EOS 7D Mark II, EOS 20Da, EOS 60Da, EOS 1200D, EOS-1D C, 5DS, 5DS R, 750D, 760D, M2, M3, G3 X\n  Casio EX-FC300S, EX-FC400S, EX-Z1080, EX-ZR700, EX-ZR710, EX-ZR750, EX-ZR800, EX-ZR850, EX-ZR1000, EX-ZR1100, ZR1200, ZR1300, EX-ZR1500, EX-100, EX-10\n  Digital Bolex D16,D16M\n  DJI 4384x3288,\n  Epson R-D1s, R-D1x\n  FujiFilm E505,S1,S205EXR,HS10,HS11,HS22EXR,HS33EXR,HS35EXR,F505EXR,F605EXR,F775EXR,F900EXR,X100T,X30,X-T1,X-T1 Graphite Silver, XQ2, X-A2, X-T10\n  Hasselblad H5D-60, H5D-50,H5D-50c,H5D-40,H4D-60,H4D-50,H4D-40,H4D-31,H3DII-22,H3DII-31,H3DII-39,H3DII-50,H3D-22,H3D-31,H3D-39,H2D-22,H2D-39,CF-22,CF-31,CF-39,Stellar II,HV\n  HTC UltraPixel\n  Imacon Ixpress 96, 96C, 384, 384C (single shot only),132C,  528C (single shot only)\n  ISG 2020x1520\n  Ikonoskop A-Cam dII Panchromatic, A-Cam dII\n  Kinefinity KineMINI, KineRAW Mini, KineRAW S35\n  Kodak DCS460D, S-1\n  Leaf Credo 50\n  Lenovo a820\n  Leica Digital-Modul-R, D-Lux (Typ 109), M (Typ 240), Monochrom (Typ 240), M-E, M-P, R8, S, T (Typ 701), X (Typ 113), X2, X-E (Typ 102), V-Lux (Typ 114), Monochrom (Typ 246), Q\n  Matrix 4608x3288\n  Nikon D4s, D600, D610, D750, D800, D800E, D810, D3300, D5500, Df, 1 J4, 1 S2, 1 V3, Coolpix P340, Coolscan NEF, D7200, 1 J5,D810A\n  Nokia 1200x1600\n  Olympus E-450, E-600, E-PL6, E-PL7, E-M1, E-M10, E-M5 Mark II, SP565UZ, STYLUS1s, SH-2, TG-4, AIR-A01\n  Panasonic DMC-CM1, DMC-FZ7, DMC-FZ70, DMC-FZ1000, DMC-GF7, DMC-GH4, AG-GH4, DMC-GM1s, DMC-GM5, DMC-LX100, DMC-TZ60/61/SZ40, DMC-TZ70, FZ300/330, GX8\n  Pentax GR, K110D, K-01,  K-S1, Q, QS-1, 645Z, K-S2, K3 II\n  PhaseOne IQ250, IQ260, IQ260 Achromatic, IQ280, Achromatic+, P 20+, P 21, P 25+, P 30+, P 40+\n  Ricoh GXR MOUNT A12, GXR MOUNT A16 24-85mm F3.5-5.5, GXR, S10 24-72mm F2.5-4.4 VC, GXR, GR A12 50mm F2.5 MACRO, GXR, GR LENS A12 28mm F2.5, GXR, GXR P10\n  Samsung GX-1L, NX1, NX5, NX1000, NX1100, NX30, NX300, NX300M, NX3000, NX mini, Galaxy S3, Galaxy Nexus, NX500\n  Sigma dp1 Quattro, dp2 Quattro, dp3 Quattro, dp0 Quattro\n  Sinar eMotion 22, eMotion 54, eSpirit 65, eMotion 75, eVolution 75, Sinarback 54\n  Sony A7 II, A7S, ILCA-77M2 (A77-II), ILCE-3000, ILCE-5000, ILCE-5100, ILCE-6000, ILCE-QX1, DSC-RX100III, DSLR-A560, NEX-VG20, NEX-VG30, NEX-VG900, IMX135-mipi 13mp, IMX135-QCOM, IMX072-mipi, RX100-IV, A7R-II, RX10-II\n\n * Fujifilm F700/S20Pro second frame support\n\n2014-02-01  Alex Tutubalin <lexa@lexa.ru>\n   * Updated Oly E-M10 & Panasonic TZ60/61 color data\n   * Updated foveon SD9-14 white level\n   * Support for 1x1 BlackLevelRepeatDim\n\n2014-01-31  Alex Tutubalin <lexa@lexa.ru>\n   * imported dcraw 1.461: fixed error in BlackLevelDim handling\n   * Accurate work with pattern black-level (cblack[6+])\n   * Support for Olympus E-M10 and Fujifilm X-T1\n   * Adjusted possbile maximum value for Sigma SD9 small raws\n\n2014-01-27 Alex Tutubalin <lexa@lexa.ru>\n   * dcraw 1.460:  Nikon D3300, Panasonic DMC-TZ61, Sony  ILCE-5000\n2014-01-25 Alex Tutubalin <lexa@lexa.ru>\n   * PhaseOne IQ250 support (both compressed and uncompressed)\n2014-01-21 Alex Tutubalin <lexa@lexa.ru>\n   * imgdata.params.sony_arw2_hack removed.\n     It always on for ARW2-files.\n   * New imgdata.params.sony_arw2_options processing flags\n     Values:\n       LIBRAW_SONYARW2_NONE - normal processing\n       LIBRAW_SONYARW2_BASEONLY - BASE pixels outputeed, delta pixels set to 0\n       LIBRAW_SONYARW2_DELTAONLY - Delta pixels written to raw data, base pixels zeroed\n       LIBRAW_SONYARW2_DELTAZEROBASE - Only deltas written without base offset\n\n2014-01-20 Alex Tutubalin <lexa@lexa.ru>\n  * Imported dcraw 9.20:\n    - Support for DNG BlackLevelRepeatDim tags\n    - imgdata.color.cblack[] holds variable BlackLevel for DNG files (up to ~4k values)\n    - imgdata.params.use_camera_matrix is now ON by default. Set it to 3 if you want\n      to force use of DNG embedded matrix.\n    - Tone curve for Canon RMF format supported\n    - Color data for Canon C500\n  * Additional camera support:\n     Alcatel 5035D\n     DJI 4384x3288\n     Fujifilm F900EXR\n     Kodak 12MP\n     Matrix 4608x3288\n     Nokia 1200x1600\n     Olympus E-PL6\n     Panasonic DMC-FZ7\n\n2014-01-17 Alex Tutubalin <lexa@lexa.ru>\n  * Camera support:\n     Added: Fujifilm XE2, XQ1\n     Color data updated: Nikon D4 1 AW1/J3, Fuji X-M2\n     Fixes: Nikon D610 visible image area, Canon A3300 bayer\n     pattern\n  * RawSpeed support: enabled processing for cameras,\n    unknown to RawSpeed\n  * Fixed error in LibRaw::unpack_thumb()\n  * little improve performance in my_strcasestr\n  * Fix compiler errors for VS2012/OpenMP\n  * Fixed typo which prevents to use Demosaic Pack GPL2\n  * LibRaw 0.16.0-Release\n\n2013-11-15 Alex Tutubalin <lexa@lexa.ru>\n  * New cameras supported\n     Leica C, X VARIO\n     Nikon D5300, D610, Df, 1 AW1\n     Nokia Lumia 1020, 1520\n     Olympus STYLUS1\n     Pentax K-3\n     Sony RX10, A3000 (ILCE-3000),\n  * Color data updated:\n     Canon S120\n     Nikon P7800, 1 J3\n     Olympus E-M1\n  * Corrected image visible area sizes\n    Canon G16\n    Sigma pre-Merrill cameras: small and medium-sized RAWs\n\n  * Better EXIF parsing:\n     - ISO values for new Nikon cameras (D4, D800)\n     - black level extraction for Nikon D5300\n     - correct Olympus color data conversion\n\n  * Better Visual Studio compatibility (esp. old versions)\n  * Cmake build: added ws2_32 library for MinGW builds\n  * LibRaw 0.16.0-Beta1\n\n2013-10-22 Alex Tutubalin <lexa@lexa.ru>\n  * Support for new cameras:\n    Sony A7, A7R\n    Panasonic GM1\n\n  * Sony RX1R and RX100M2 color data updated.\n\n  * Sony cameras model name is set by SonyModelID EXIF tag\n\n  * Sony ARW2: black level and color matrix extracted from EXIF data\n\n  * Samsung: black level and color matrix extracted from EXIF;\n    Camera multipliers are now extracted correctly even if black is not 0\n\n  * Better source compatibility with Mac OS X compilation\n\n  * Better source compatibility with Win32 compilation\n\n  * DNG without Compression tag assumed uncompressed\n\n  * Better X3F-tools based Foveon support:\n    - new Foveon metadata parser based on X3F-tools. So, if LibRaw compiled\n      without demosaic-pack-GPL2, then no dcraw Foveon code used.\n    - Support for Medium resolution RAWs from DPx Merrill and SD1 cameras.\n      RAW data extracted as is (4800x1600 pixels), aspect ratio is set to\n      0.5, so these RAWs are processed to full-size 4800x3200 RGB.\n    - Support for Foveon thumbnail extraction. Only JPEG and bitmap\n      thumbnails extracted, but 'foveon' (RAW) thumbnails are really not used\n      in production cameras.\n    - New imgdata.params.force_foveon_x3f flag\n      Forces use of x3f-tools based code for Foveon processing if LibRaw\n      compiled with demosaic-pack-GPL2 (and does nothing if LibRaw compiled\n      without this pack).\n      New flag -disadcf added to dcraw_emu sample to use this flag.\n    - LibRaw do not calls exit() on broken Foveon files.\n\n  * API/ABI changed, so all code using LibRaw should be recompiled.\n\n  * LibRaw 0.16.0-Alpha3\n\n\n2013-10-16 Alex Tutubalin <lexa@lexa.ru>\n  * Support for new cameras:\n    Canon S120 (preliminary color data), G16\n    Fujifilm X-A1 (preliminary color data)\n    Hasselblad Lunar, Stellar\n    Nikon P7800 (preliminary color data)\n    Pentax K50, K500, Q7\n    Samsung Galaxy NX (EK-GN120)\n    Sony NEX-5T\n\n  * Updated color data for:\n    Samsung NX300\n    Sony RX1R\n    Sigma SD1, SD1 Merrill, DPxx (only if non-GPL2 foveon decoder used)\n\n  * Image dimensions table for Foveon cameras (only if\n    non-GPL2 foveon decoder used)\n\n  * Fixed memory leak in x3f-tools code (new Foveon decoder)\n  * Fixed DHT-demosaic incompatibility with MS VisualStudio in OpenMP directives\n  * Additional image size checks.\n  * LibRaw 0.16-Alpha2\n\n2013-09-22 Alex Tutubalin <lexa@lexa.ru>\n  * Support for new cameras:\n     Baumer TXG14\n     Blackmagic Cinema\n     Canon EOS 70D, C500\n     Fujifilm X-M1\n     Nikon D5200\n     Olympus E-P5,E-M1\n     OmniVision OV5647 (Raspberry Pi)\n     Panasonic LF1, GX7, GF6\n     Richon GR\n     Samsung NX300, NX1100, NX2000\n     Sony RX100II, RX1R, NEX-3N\n\n  * Support for Foveon sensor based on X3F code by Roland Karlsson\n    BSD-like license, so included in main LibRaw code.\n    No 'foveon intepolation', so no way to get good colors from\n    old Sigma cameras (SD9, SD14, Polaroid x530). For modern Foveon cameras\n    one may try to create ICC profile (not supplied).\n\n    TODO: thumbnail extraction, fast cancelation\n\n    Old foveon_*_load_raw (from dcraw) code is used if compiled with\n    LIBRAW_DEMOSAIC_PACK_GPL2\n\n  * API Changes:\n\n    + New parameters in imgdata.params:\n      - imgdata.params.no_interpolation - disables interpolation step in\n        LibRaw::dcraw_process() call.\n      - imgdata.params.no_auto_scale - disables call to scale_colors() in\n        LibRaw::dcraw_process() call.\n      - imgdata.params.sraw_ycc - disables Canon sRAW YCbCr to RGB conversion\n        in LibRaw::unpack() call (use for RAW analyzers\n\n    + New Fuji X-Trans handling:\n      - imgdata.iparams.filters value is now 9 for Fuji X-Trans (instead of 2)\n      - imgdata.iparams.xtrans[6][6] matrix contains row/col to color mapping\n        for Fuji X-Trans sensor.\n\n    + LibRaw::setCancelFlag() - use for fast decoder termination\n\n    + LibRaw_abstract_datastream::make_byte_buffer() call is not needed more.\n\n    + New demosaic code: DHT Demosaic by Anton Petrusevich\n      Set params.user_qual=11 to use.\n\n    + New demosaic code: Modified AHD Demosaic by Anton Petrusevich\n      Set params.user_qual=12 to use.\n\n    + New C-API call libraw_COLOR(libraw_data_t *t, int row,int col)\n      (so LibRaw::COLOR(row,col) exposed to C-API users)\n\n  * Removed faster lossless jpeg decoder ported from RawSpeed library\n    some years ago. Build LibRaw with RawSpeed to get fast decoding.\n\n  * Fixed decoding error for some Canon sRAW files.\n\n  * Disabled RawSpeed's bad pixel processing if RawSpeed used.\n\n  * EOS M and EOS 70D added to unique Canon ID table\n\n  * Canon EOS model name normalized by unique ID table\n\n  * Backported 0.15.4 input data checks\n\n  * Support for CMake builds\n\n  * Updated RawSpeed supported camera list\n\n  * Internals changed, so all code using LibRaw should be recompiled.\n\n  * LibRaw 0.16.0-Alpha1\n\n2013-05-23 Alex Tutubalin <lexa@lexa.ru>\n\n LibRaw 0.15-Release\n\n New camera/format support:\n  * Adobe DNG:\tfast Load DNG (LightRoom 4.x), support for\n\t\tlossy-compressed DNG (LR 4.x, requires libjpeg 6+)\n  * Canon:\tG1 X, SX220 HS, EOS 5D Mark III, EOS 650D, EOS 1D-X,\n\t\t100D (Rebel SL1), 700D (Rebel T5i), 6D, EOS M, G15, S110, SX50\n  * Casio:\tEX-ZR100,EX-Z8\n  * Fujifilm:\tX-S1, HS30EXR, X1-Pro,X-E1, X20, X100S, SL1000, HS50EXR,\n  \t\tF800EXR, XF1\n  * Leica:\tD-LUX6 and V-LUX4\n  * Nikon:\tD4, D3200, D800, D800E, 1 J2, 1 V2, D600, 1 J3, 1 S1, Coolpix A,\n\t\tCoolpix P330, Coolpix P7700, D7100\n  * Olympus:\tE-M5, XZ-2, XZ-10, E-PL5, E-PM2\n  * Panasonic:\tG5, G6, DMC-GF5, FZ200, GH3, LX7\n  * Pentax:\tMX-1, K-5 II, K-5 IIs, K-30, Q10\n  * Samsung:\tEX2F, NX20, NX210, support for the new firmware for NX100\n  * Sigma:\tSD15, SD1, SD1 Merill, DP1, DP1S, DP1X, DP2, DP2S, DP2X\n\t\t(only with Demosaic-pack-GPL2)\n  * Sony:\tSLT-A58, RX-1, SLT-A99, NEX-5R, NEX-6, NEX-F3, SLT-A37, SLT-A57\n  * Multishot files:\tImacon Ixpress 39Mpix\n\nAPI changes:\n  1. dcraw_process() can now be called several times with different parameters\n     without re-opening and unpacking the file for second and consecutive\n     calls to dcraw_process\n\n  2. deleted (nobody uses those)\n   - LibRaw::dcraw_document_mode_processing  (and respective C-API)\n   - imgdata.color.color_flags data field\n\n  3. LibRaw::unpack() now decodes data into different buffers, the buffer\n     depends on the raw data type\n     - imgdata.rawdata.raw_image - 1 color component per pixel,\n       for b/w and Bayer type sensors\n     - imgdata.rawdata.color3_image - 3 color components per pixel,\n       sRAW/mRAW files, RawSpeed decoding\n     - imgdata.rawdata.color4_image - 4 components per pixel, the 4th\n       component can be void\n\n   4. Support for compiling with RawSpeed library, http://rawstudio.org/blog/?p=800\n      details are in README.RawSpeed\n\n   5. Suppression of banding\n\n   6. New API calls\n     - recycle_datastream(),\n     - open_file(wchar_t*) (Win32)\n\n\n2012-04-05 Alex Tutubalin <lexa@lexa.ru>\n        * Casio EX-Z500 support\n        * (possible) I/O exceptions on file open catched in open_datastream\n        * Fixed possible read-after-buffer in Sony ARW2 decoder\n        * Fixed mingw32 errors when compiling LibRaw_windows_datastream\n        * Makefile.msvc: support of OpenMP and LCMS (uncomment to use)\n        * Fixed decoding of some Leaf Aptus II files\n        * LibRaw 0.14.6-Release\n\n2011-12-24 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug (uninitialized variable) in SMAL format decoding.\n\n        * Imported new dcraw 9.12 (1.446): support for Leica V-LUX 3,\n          updated color data for Canon S100, Fujifilm X10, Nikon 1 J1/V1,\n          Panasonic GX1, Samsung NX200, Sony NEX-7\n\n        * LibRaw 0.14.5-Release\n\n2011-12-12 Alex Tutubalin <lexa@lexa.ru>\n\n        * Fixes to Panasonic/Leica file parser to prevent crash\n          on broken jpegs.\n\n        * Fixes to include order in src/libraw_datastream.cpp to\n          better compile with KDEWIN\n\n        * Floating-point DNGs are rejected on early processing stage.\n\n        * Support for new cameras: Canon S100, Fuji X10, Panasonic GX1,\n          Samsung NX200, Sony NEX-7.\n\n        * LibRaw 0.14.4-Release\n\n\n2011-10-26 Alex Tutubalin <lexa@lexa.ru>\n        * Bug fixes in black level subtraction code for PhaseOne files\n\n        * New API call LibRaw::get_internal_data_pointer() for developers\n           who need access to libraw_internal_data fields (i.e.\n           Fuji SuperCCD layout).\n\n        *  doc/API-overview fixes to reflect 0.14 changes\n\n        * LibRaw 0.14.3-Release\n\n2011-10-19 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in Canon 1D and 1Ds files decoding.\n        * New decoder information bit DECODER_HASRAWCURVE\n        * LibRaw 0.14.2-Release\n\n2011-10-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.11/1.445:\n          + Support for new cameras added: Fujifilm F600EXR, Nikon P7100,\n            Olympus E-PL3 and E-PM1, Panasonic DMC-FZ150, Sony NEX-5N,\n            A65 and A77.\n          + Changed color data for: Olympus E-P3, Panasonic G3 and GF3,\n            PhaseOne H25, P40 and P65, Sony NEX-C3, NEX-5, NEX-3, A35 and A55.\n          + Support for dark frame extraction on Sony cameras.\n\n        * DCB demosaicing: reserving 6 pixels instead of 3 to suppress\n          colored image frame.\n        * LibRaw 0.14.1-Release\n\n2011-09-21 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to make Visual C++/OpenMP more happy\n        * Fix megapixel calculation for postprocessing_benchmark in half mode\n        * Shlib version number increment\n        * LibRaw 0.14.0-Release\n\n2011-09-04 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug with Kodak thumbnail extraction\n        * raw2image_ex() always return value\n        * LibRaw 0.14.0-Beta2\n\n2011-09-02 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic changes to LibRaw_file_datastream interface\n\n        * OpenMP speedup of postprocessing steps (up to 50% for\n          half mode and 4-core machine)\n\n        * LibRaw 0.14.0-Beta1\n\n2011-08-20 Alex Tutubalin <lexa@lexa.ru>\n\n        * Patch to dcraw_emu for SunStudio compiler compatibility\n\n        * Fixed crash in unprocessed_raw sample due to uninitialized\n          timestamp variable.\n\n        * Fixed crash in raw decoding if raw_width/raw_height is\n          less than resulting image width/height.\n\n        * imgdata.sizes.flip is set from user_flip only on\n          postprocessing and/or adjust_sizes_info_only()\n\n        * Fixed buffer overrun for some LJPEG-compressed files\n\n        * Most of LibRaw_datastream function bodies are moved to\n          separate source file\n\n        * LibRaw_windows_datastream is merged to main sourcetree\n\n        * LibRaw 0.14.0-Alpha5\n\n2011-08-11 Alex Tutubalin <lexa@lexa.ru>\n        * Imported dcraw 9.10 (1.444), support for new cameras added:\n          ARRIRAW format, Canon SX30 IS, Leica D-LUX 5 and V-LUX2,\n          Olympus E-P3, Panasonic G3 and GF3, Sony NEX-C3 and SLT-A35\n\n        * Support for RedOne digital movie cameras (R3D format).\n          To enable this support you should:\n           + install libjasper JPEG2000 support library\n\n           + compile LibRaw with -DUSE_JASPER compiler switch (./configure\n             will do it for you)\n\n           + If you use own LibRaw_datastream implementation, you should\n             implement make_jas_stream() call for your datastream. See\n             bottom of src/libraw_cxx.cpp for  implementations in datafile\n             and mem-buffer LibRaw streams.\n\n        * Bugfix: green matching is turned off if output image is shrinked\n          due to wavelet filtering or aberration correction.\n\n        * fixed open_file()/adjust_sizes_info_only() code path\n\n        * Removed imgdata.sizes.bottom_margin and right_margin data fields\n          use imgdata.sizes.raw_width - width - left_margin to get right one,\n          the same with bottom_margin.\n\n        * minor ./configure cleanup\n\n        * Qmake files and Visual Studio Project files are updated.\n\n        * New version check macros:\n          For use at runtime checks:\n           LIBRAW_RUNTIME_CHECK_VERSION_EXACT() - checks  that runtime\n            major/minor version numbers are same with compile-time values.\n\n           LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS() - checks that runtime\n            version is not less that compile-time one.\n\n          For use at compile-time in preprocessor directives:\n           LIBRAW_COMPILE_CHECK_VERSION_EXACT(major,minor) - Compile-time\n            check that LibRaw version is exact major.minor.\n\n           LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major,minor) - Compile-time\n            check that version is not less than major.minor.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha4\n\n2011-07-19 Alex Tutubalin <lexa@lexa.ru>\n        * New sample samples/postprocessing_benchmark.cpp\n          This sample measures postprocessing speed.\n          All demosaic methods, averaged white balance, median\n          filtering, wavelet filtration, highlight recovery, and\n          cropping are supported.\n\n        * Removed LibRaw::rotate_fuji_raw() call and corresponding C-API call.\n\n        * The LibRaw::adjust_sizes_info_only() call may be called repeated\n          and mixed with dcraw_process() call.\n\n        * Postprocessing speedup and optimization, especially if cropping set.\n\n        * Cropping works for FujiCCD raws. For the technical reasons, the position\n          of top-left corner of crop area will be rounded to the nearest\n          multiple of 4 (the corner is shifted top-left).\n\n        * LibRaw 0.14.0-Alpha3\n\n2011-07-15 Alex Tutubalin <lexa@lexa.ru>\n        * imported cropping code from 0.13 branch\n\n2011-07-12 Alex Tutubalin <lexa@lexa.ru>\n        * samples/multirender_test - check for different clip settings\n\n2011-07-11 Alex Tutubalin <lexa@lexa.ru>\n        * New call LibRaw::free_image(), deallocates imgdata.image buffer.\n          Use this call if current postprocessing results are not\n          needed, but it is to early to call recycle() because\n          dcraw_process() may be called later.\n\n        * New C-API calls\n          libraw_raw2image() - C API for LibRaw::raw2image()\n          libraw_free_image() - C API for LibRaw::free_image()\n          libraw_get_decoder_info() - C API for LibRaw::get_decoder_info()\n\n        * Bugfix: change of params.user_flip aftee open()/unpack()\n          calls should work.\n\n        * LibRaw 0.14.0-Alpha2\n\n2011-07-10 Alex Tutubalin <lexa@lexa.ru>\n        * Multiple rendering (LibRaw::dcraw_process() calls) allowed\n          without re-opening RAW file thrfough the sequence of open()/unpack()\n          calls.\n          You should be able to change any processing parameters (except\n          shot_select parameter) between dcraw_process() calls.\n\n          + New sample in samples/multirender_test.cpp: renders data 4 times:\n            in half and full modes with different white balance settings.\n\n          + Unprocessed RAW data is stored in separate data buffer:\n            (2 bytes per pixel for all Bayer-pattern images,\n            8 bytes per pixel for Foveon, sRAW, and other full-color raw\n            formats), so now LibRaw uses 25% more memory for full processing of\n            most common Bayer images; while for just unpack memory is reduced\n            4 times.\n\n          + New call LibRaw::raw2image() fills imgdata.image array\n            with fresh copy of data.\n            There is no need to call raw2image() separately if you use\n            dcraw_process() or dcraw_document_mode_processing() calls.\n\n          + New call LibRaw::get_decoder_info() to determine raw data\n            storage layout. See samples/unprocessed_raw.cpp for an example\n            of how to use it.\n\n        If your code uses usual open()/unpack()/dcraw_process() call\n        sequence, then NOTHING CHANGED: your program should produce same\n        results. For interactive programs you may skip open()/unpack()\n        calls after adjusting processing parameters, so user should see\n        image refreshed much faster.\n\n        If your code uses raw data (open+unpack calls), you need to call\n        LibRaw::raw2image(), and imgdata.image will contain same bitmap\n        as in LibRaw 0.13.x\n\n        If you code uses access to masked borders data, you need to\n        rewrite it. See samples/unprocessed_raw.cpp as a sample.\n\n        Unfortunately, documentation is untouched yet. This problem will be\n        fixed in next Alpha release.\n\n        Other changes:\n\n        * No separate imgdata.masked_pixels buffers, Bayer raw formats are read\n          to buffer with borders. So, no ugly add_masked_border_to_bitmap()\n          call.\n\n        * No filtering_mode parameter. Raw tone curve is applied\n          at unpack() stage; zero pixels removed on postprocesing stage.\n\n        * unprocessed_raw and 4colors samples are adjusted to use\n          new RAW data storage layout.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.14.0-Alpha1\n\n2011-07-03 Alex Tutubalin <lexa@lexa.ru>\n        * Cosmetic cleanup in Libraw_memmgr code\n\n        * Permit OpenMP support on MS VS2008\n\n        * More general mem_image interface:\n          + New call get_mem_image_format returns bitmap size and bit depth\n          + New call copy_mem_image can copy bitmap into buffer with\n            different color order (RGB/BGR) and line stride\n          + dcraw_make_mem_image() uses calls mentioned above\n          + see documentation for info on these function parameters.\n\n        * libraw/librawwindows.h implements LibRaw_datastream class based\n          on Windows memory mapped files.Win32/64-only\n          Thanks to Linc Brookes.\n\n        * Fixed parallel make errors in configure/Makefile.am\n\n        * LibRaw 0.13.6-Release\n\n\n2011-05-18 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.08/1.443:\n           + New color data for Canon 600D and 1100D, Fuji S200EXR\n           + New camera supported: Fuji HS20EXR and F550EXR, Kodak Z990,\n                                   Nikon D5100, Olympus E-PL1s and XZ-1,\n                                   Samsung NX11, Sony A230 and 290.\n        * LibRaw 0.13.5-Release\n\n2011-04-02 Alex Tutubalin <lexa@lexa.ru>\n        * Imported new dcraw 9.07/1.442:\n          + Support for Canon 600D and 1100D, Hasselblad H4D-60,\n            Olympus E-PL2\n        * Color data for Leaf Aptus II and Canon Powershot S2 IS\n        * LibRaw 0.13.4-Release\n\n2011-03-30 Alex Tutubalin <lexa@lexa.ru>\n        * Preliminary support for Leaf Aptus II cameras (no color data yet):\n          Leaf Aptus II 6,7,8,10 and 12 are tested, Aptus II 5 should work.\n        * Preliminary support for Fujifilm X100 camera (again, no color data).\n        * Fixed possible after the end of buffer read when working with\n          in-memory data.\n        * Fixed possible loss of JPEG stream sync marks in LJPEG decoder\n          (this bug was found only for Leaf Aptus II RAWs).\n        * LibRaw 0.13.3-Release\n\n2011-03-08 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed broken camera white balance reading for some Sony cameras\n        * LibRaw 0.13.2-Release\n\n2011-02-25 Alex Tutubalin <lexa@lexa.ru>\n\t* Sony A390 support (colordata from A380)\n\t* Leica D-LUX 4: fixed typo in camera name in colordata\n\n2011-02-15 Alex Tutubalin <lexa@lexa.ru>\n\t* New -mem option for dcraw_emu: I/O via allocated buffer\n\t* Removed debug printf from LibRaw_memory_buffer code\n\t* Preliminary shared library support\n\n2011-02-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Added qmake .pro and Visual Studio 2008 sln/vcproj project files\n2011-02-07 Alex Tutubalin <lexa@lexa.ru>\n        * dcraw_emu documentation updated\n        * ./configure stuff changed for correct linking on some systems\n        * FBDD denoising is disabled for full-color images and 4-color bayer\n          data (including forced 4-color via four_color_rgb option)\n        * LibRaw 0.13.1-Release\n\n2011-02-05 Alex Tutubalin <lexa@lexa.ru>\n        * ./configure fixes for PACKAGE_REQUIRES\n        * Makefile.msvc: correct compiler flags for demosaic packs\n        * dcraw.c 9.06/1.440 imported:\n          + New camera support: Canon S95, Casio EX-Z1080, Panasonic GF2\n            and GH2, Samsung NX100, Sony A-580\n          + New color data for: Canon G12, Nikon D3100, D7000 and P7000,\n            Olympus E-5, Pentax K-r and K-5, Samsung NX10 and WB2000\n        * green_matching() code is disabled for half-size processing\n        * LibRaw 0.13.0-Release\n\n2011-01-15 Alex Tutubalin <lexa@lexa.ru>\n        * Fallback to old huffman decoder for Sony files with unspecified\n          data length (Sony A100)\n        * Fixed incomplete data fields reset in LibRaw::recycle()\n        * LibRaw 0.13.0-Beta3\n\n2011-01-13 Alex Tutubalin <lexa@lexa.ru>\n        * Better parsing of unknown command-line params in dcraw_emu sample\n        * Brigtness table in ahd_demosaic is calculated in reversed order\n          to prevent possible (very unlikely) multithreaded app problem.\n        * New exposure correction code based on linear-cubic root combination.\n          New working correction range is from 0.25 (-2 stops) to 8 (+3 stops)\n        * LibRaw 0.13.0-Beta2\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixed file extension in half_mt.c sample\n\n2011-01-10 Alex Tutubalin <lexa@lexa.ru>\n\t* Three patches provided by Jacques Desmis:\n          - Exposure correction before demosaic (demosaic pack GPL3)\n\t  - OpenMP speed-up in median filters (demosaic pack GPL2)\n\t  - OpenMP speed-up in green equilibration (demosaic pack GPL3)\n\t* Merged 0.12.2-0.12.3 changes:\n          - Patches for ./configure system for better LCMS2 support\n\t  - Patches for ./configure system\n\t  - math.h included before any other includes to make KDE compile\n\t    with Visual C++ happy\n\t  - Fuji FinePix S5500 size adjusted to ignore (rare?) garbage\n\t    at top of frame.\n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.13.0-Beta1\n\n2010-12-22 Alex Tutubalin <lexa@lexa.ru>\n        * Zero copy huffman buffer for LibRaw_buffer_datastream\n        * Fixed memory leak in compressed NEFs handling\n        * LibRaw 0.13.0-Alpha2\n\n2010-12-20 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic-pack-GPL3 changes:\n          + New noise reduction methods before demosaic\n             - Banding suppression\n             - High-frequency noise suppression\n             - Green channel equalization\n          + New chromatic abberration correction.\n          All three methods are written by Emil Martinec for Raw Therapee.\n          Adapted to LibRaw by Jacques Desmis\n\n        * Merged Foveon code fix from LibRaw 0.12.1\n\n        * LJPEG decompressor speed-up (about 1.5 times for Canon cameras\n          and slightly less for others). Some ideas are from RawSpeed library.\n\n        * all client code should be recompiled due to internals change.\n\n        * LibRaw 0.13.0-Alpha1\n\n2010-12-12 Alex Tutubalin <lexa@lexa.ru>\n\t* Thread-safe and demosaic packs support for MinGW build\n\t* Demosaic packs support for MS VC build\n        * LibRaw 0.12.0-Release\n\n2010-12-09 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed bug in add_masked_borders_to_bitmap() call for cameras\n          with odd pixels border.\n        * New command line options for unprocessed_raw sample:\n           -B - subtract black level, -M - add masked pixels to bitmap.\n        * Foveon-sensor cameras added to supported camera list if\n          compiled with demosaic pack GPL2\n        * LibRaw 0.12.0-Beta4\n\n2010-12-05 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic packs support in Makefile.dist\n        * Foveon support in LibRaw demosaic pack GPL2\n        * all client code should be recompiled due to internals change.\n        * LibRaw 0.12.0-Beta3\n\n2010-11-27 Alex Tutubalin <lexa@lexa.ru>\n        * Fixed allocation bug in lmmse_interpolation (demosaic-pack-GPL2)\n\t* In LMMSE and AMaZE interpolators allocation changed to calloc\n\t  to make valgrind happy with uninitialized values\n        * Changes in distribution-making scripts\n        * LibRaw 0.12.0-Beta2\n\n2010-11-21 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes to green_matching code by Sergey Pavlov\n\n2010-11-20 Alex Tutubalin <lexa@lexa.ru>\n        * Update for new demosaic-pack-GPL3\n\t* LibRaw 0.12.0-Beta1\n\n2010-11-19 Alex Tutubalin <lexa@lexa.ru>\n        * Demosaic pack(s) supported via ./configure\n\n2010-11-17 Alex Tutubalin <lexa@lexa.ru>\n\t* LCMS2 support\n\t* afd_interpolate(2,1) instead of (5,0)\n        * dcraw_emu sample command line keys added and reordered\n          to reflect changes in LibRaw 0.12.\n\t* Nikon P7000: color matrix data and black level patch for ISO >=400\n\t  Thanks to Gunnar Thorburn\n        * Support for several industrial cameras based on Sony ICX 625/655\n\t  sensor: JAI BB500CL/GE, SVS625CL, ptGrey GRAS-50S5C\n\t  Thanks to kaare\n\n2010-11-15 Alex Tutubalin <lexa@lexa.ru>\n\n        * Several demosaic algorithms, found in other open-source RAW processing\n          packages are implemented in LibRaw.\n\n          1) DCB demosaic and FBDD denoise by Jacek Gozdz are included in\n             main LibRaw source.\n          2) GPL2 demosaic pack with these demosaic methods:\n             * AFD and LMMSE implementations from PerfectRaw by Manuel Llorens\n             * VCD, Modified AHD, post-demosaic refinemend and median\n               filters by Paul Lee\n          3) GPL3 demosaic pack with AMaZe interpolation  by Emil Martinec\n\n          See more details in README.demosaic-packs\n\n        * Current implementation of dcraw_emu sample allows only selection\n          of demosaic method (via -q) options. All other parameters change\n          will be implemented later.\n\n\t* LibRaw 0.12-alpha1\n\n2010-11-11 Alex Tutubalin <lexa@lexa.ru>\n\t* Imported 0.11(2) version changes:\n\t  + Fixed dcraw_emu command line processing code\n          + OpenMP is completely disabled on MacOS X if compiled with -pthread\n            due to well-known MacOS problem.\n          + dcraw 9.05 (1.439) imported, many new cameras supported:\n              Canon: G12, SX120, 60D,\n              Hasselblad H4D, Nokia X2, Olympus E-5,\n              Nikon: D3100, D7000, P7000,\n              Panasonic: FZ40, FZ100, LX5,\n              Pentax: K-r, K-5, 645D,\n              Samsung GX20, WB2000\n\t* LibRaw 0.12-alpha0\n\n2010-11-08 Alex Tutubalin <lexa@lexa.ru>\n\t* Fixes for Sun Studio compiler compatibility\n\t* Fixes for Visual Studio 2010 compatibility\n\t* All russian-language files are converted to UTF-8\n\t* LibRaw 0.11.0-Release\n\n2010-10-18 Alex Tutubalin <lexa@lexa.ru>\n           * Disabled OpenMP for wavelet_denoise under Mac OS X\n           * More Visual C++ 2003 warnings cleaned in libraw/*h files\n           * LibRaw 0.11-Beta7\n\n2010-10-16 Alex Tutubalin <lexa@lexa.ru>\n           * internal/dcraw_fileio.c can be compiled with -DDCRAW_VERBOSE again\n           * fixed comment style in libraw_datastream.h\n           * LibRaw 0.11-Beta6\n\n2010-10-15 Alex Tutubalin <lexa@lexa.ru>\n\n           * New changes to I/O layer. Three LibRaw_*datastream clasees are\n             exists:\n               + LibRaw_buffer_datastream - buffer reaging\n               + LibRaw_file_datastream - file reading using iostreams\n                 (large files are no supported on some systems)\n               + LibRaw_bigfile_datastream - FILE*-based file I/O\n\n           *  file/bigfile_datastream is selected automatically by\n              LibRaw::open_file based on input file size.\n              By default, files larger than 250Mb are opened using\n              bigfile interface, you may change this behaviour\n              by using second optional parameter of open_file()\n\n           * There is no way to use default parameter values in C API,\n             so new call libraw_open_file_ex added with two parameters\n             (file name and minimal file size for bigfile_datastream use).\n\n           * all client code should be recompiled due to internals change.\n\n           * All LibRaw_abstract_datastream functions are virtual again. You may\n             (again) use your own I/O layer.\n\n           * new -d key for dcraw_emu sample: print timings of processing stages\n\n           * simple_dcraw sample simplified: no mmap code\n\n           * LibRaw 0.11-Beta5\n\n2010-10-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in exception handling in OpenMP sections in\n             AHD interpolation code.\n\n           * LibRaw_datastreams are now C++ iostreams based instead of old\n             plain FILE* calls.\n             LibRaw::open_file() in multithreaded programs are WAY faster\n             on many OSes (Linux, Windows, MacOSX) because of no extra locks.\n\n           * all client code should be recompiled due to internals change.\n\n           * LibRaw 0.11-Beta4\n\n\n2010-10-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in LibRaw::dcraw_process() code: for half_size\n             processing, params.four_color_rgb was set to 1 internally\n             and not returned back after postprocessing.\n\n           * Several Visual Studio 2003 compatibility fixes\n\n            * AHD interpolation refactored. Now it is about 10% faster than\n              dcraw in single-process mode and up to 1.5 times faster on\n              4-core and OpenMP (total execution time counted, not AHD itself)\n              Thanks to Adam Hooper\n           * AHD interpolation refactored. Now it is about 10% faster than\n             dcraw in single-process mode and up to 1.5 times faster on\n             4-core and OpenMP (total execution time counted, not AHD itself)\n             Thanks to Adam Hooper\n\n           * LibRaw 0.11-Beta3\n\n2010-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * Phase One files: LibRaw::unpack() sets colordata.black to\n             approximately correct value.\n\n           * Fixed minor error in setting colordata.maximum value\n             for Phase One files.\n\n           * LibRaw::subtract_black() sets colordata.black and\n             colordata.cblack[] to zero to preserve data integrity.\n\n           * LibRaw 0.11-Beta2\n\n\n2010-09-04 Alex Tutubalin <lexa@lexa.ru>\n\n           * It is now possible to crop output image on postprocessing\n            stage (dcraw_process). Coordinates and size of the output box\n            are set via imgdata.params.cropbox[4] parameter. Look into\n            LibRaw documentation for more details.\n\n              + New fatal error code LIBRAW_BAD_CROP\n\n              + New dcraw_emu sample command line switch: -B x y w h\n                (sets cropbox)\n\n             Thanks to Patrick and Jan.\n\n            * Processing pipeline has changed: the black level is subtracted\n              from data on postprocessing stage either automatically\n              (on dcraw_process() stage) or by special LibRaw API call:\n\n               + New API calls:  LibRaw::subtract_black() (C++ API) and\n                 libraw_subtract_black (C API).\n                 If you use dcraw_process() or dcraw_document_mode_processing()\n                 calls YOU DON'T NEED to call subtract_black() directly.\n\n               + The raw preprocessing mode LIBRAW_FILTERING_NOBLACKS\n                 is deprecated and removed from LibRaw.\n\n             * New ./configure script.\n               Use ./configure -h for usage details.\n               Thanks to Siddhesh Poyarekar\n\n             * New API cals static LibRaw::dcraw_clear_mem() (C++ API)\n               and libraw_dcraw_clear_mem(..) (C API).\n               This calls are used to free memory, allocated by\n               dcraw_make_mem_image() and dcraw_make_mem_thumb() instead\n               of free() call.\n\n               In some cases LibRaw and calling process have different\n               memory managers, so free() of make_mem_image() data\n               results to program crash (especially in Win32/VisualStudio\n               enviroment).\n\n             * LibRaw::free() is now private instead of public (again).\n\n             * Minor changes and bugfixes:\n\n               + Memory allocation exceptions (std::bad_alloc) are caught,\n                 so LibRaw API calls will return reasonable error codes\n                 instead of C++ exception (possibly unhandled).\n                 This problem is very unlikely to see in wild: if application\n                 cannot allocate small data for internal structure, it will\n                 always fail on allocation for RAW image data.\n\n               + WIN32/VisualStudio 2008/2010: fopen,fscanf and sscanf calls\n                 in Libraw_datastream code are changed to *_s (secure) ones.\n\n               + Debug print removed from fatal error handler.\n\n               + Mmaped I/O for dcraw_emu sample is turned on via -E switch\n                 now (because old -B switch is used for settng cropbox).\n\n           * all client code should be recompiled due to structures size change\n\n           * LibRaw 0.11-Beta1\n\n\n2010-07-31 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.04 (1.438) imported: changes in tiff metadata parser,\n            fixed a typo in Canon A720 model name\n           * small patch in Sony ARW2 unpacking code to make valgrind happy\n           * LibRaw 0.10.0-Beta3.\n\n2010-07-05 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.03 (1.437) imported:\n             + New cameras: Canon SX20, Nikon D3s, Olympus E-P2, Panasoni DMC-GF1,\n               Samsung EX1, Sony A450\n             + Color data changed for some cameras\n\n           * LibRaw 0.10.0-Beta2.\n\n2010-06-06 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 9.01 (1.434) imported:\n             + Separate black levels for each color channel.\n             + New cameras: Canon 550D, Casio EX-Z1050, Fuji HS10/HS11,\n               Kodak Z981, Panasonic G2 and G10, Phase One P65,\n               Samsung NX-10 and WB550, Sony NEX-3 and NEX-5.\n             + Fixed file descriptor leak in dark frame subtraction processing\n\n           * Fixed dcraw 9.01's bug in DNG black level processing\n\n           * Preliminary support for Sony A450 camera.\n\n           * New command-line switch -h in mem_image sample (half_size support)\n\n           * Some patches by Johannes Hanika (darktable author):\n              + OpenMP speedup  for PPG-interpolation\n              + green_matching  - suppress of 'color maze' on cameras with\n              different green channel sensitivity. This option is turns on\n              by  filed with same name in imgdata.params\n\n           * all client code should be recompiled due to structures size\n             change\n\n           * LibRaw::free() is now public instead of private.\n\n           * LibRaw 0.10.0-Beta1.\n\n2010-05-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in 8-bit RAW processing code\n           * LibRaw 0.9.1-Release\n\n2010-04-26 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support: OpenMP is possible under MinGW (untested)\n           * LibRaw 0.9.0-Release\n\n2010-04-21 Alex Tutubalin <lexa@lexa.ru>\n           * Finally fixed inconsistency in Fuji files processing\n           * New COLOR(row,col) call to get bayer color index in image[] array\n           * Old FC() call is deprecated and will be removed in future releases\n           * unprocessed_raw sample switched to COLOR() call\n           * LibRaw 0.9.0-Beta5\n\n\n2010-04-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in unpacking DNG files made from Fuji RAFs.\n           * LibRaw 0.9.0-Beta4\n\n2010-04-09 Alex Tutubalin <lexa@lexa.ru>\n\n           * Fixed typecast error (problem reported only on gcc 4.2.1/32bit)\n            in CRW files processing.\n\n           * C++ API call LibRaw::adjust_maximum() is now deprecated and\n             de-documented, use params.adjust_maximum_thr instead (on by default)\n\n           *  C-API call libraw_adjust_maximum() removed.\n\n           * New postprocessing parameter params.adjust_maximum_thr\n             This parameter replaces LibRaw::adjust_maximum(), but more flexible\n             Defaults are reasonable (0.75, same as in old adjust_maximum),\n             look into documentation for more details.\n\n           * Removed last OpenMP warning\n\n           * dcraw_emu's -c parameter now wants numeric (float) argument. This value\n             is assigned to params.adjust_maximum_thr.\n             Use -c 0.0 for dcraw compatibility.\n\n           * all client code should be recompiled due to structures size\n             change\n\n           * LibRaw 0.9.0-Beta3\n\n\n2010-03-29 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug in channel_maximum[] calculation for\n             Panasonic cameras.\n           * channel_maximum[] data now calculated for ALL cameras.\n           * OpenMP warnings suppressed.\n           * Documented the -c command-line switch for dcraw_emu sample.\n           * Removed extra messages from dcraw_emu sample.\n           * LibRaw 0.9.0-Beta2\n\n2010-03-28 Alex Tutubalin <lexa@lexa.ru>\n\n           New licensing:\n\n           * Triple licensing (selected by LibRaw user):\n\n              + LGPL 2.1 (http://www.gnu.org/licenses/lgpl-2.1.html)\n              + CDDL 1.0 (http://www.opensource.org/licenses/cddl1.txt)\n              + LibRaw Software License (27 March 2010 version)\n               (http://www.libraw.org/data/LICENSE.LibRaw.pdf)\n\n           * There is no separate LibRaw-Lite and LibRaw-Commercial versions,\n             only single LibRaw.\n             Current LibRaw-Lite and LibRaw-Commercial users should switch\n             to LibRaw without loss of functionality.\n             It is possible to change licensig too (e.g. from LGPL to CDDL\n             for LibRaw-Lite users and from LibRaw License to LGPL or CDDL\n             for LibRaw-Commercial users).\n\n           * No Foveon support :(\n             It is not possible to get good color from Foveon sensors with\n             *any* converter. So, there is no need to support these cameras.\n             Dcraw's Foveon-processing code is too strict licensed (GPL),\n             so we choose to drop it.\n\n           New Features:\n\n           * New data field  colordata.channel_maximum[4] - per channel data\n            maximum (calculated for most cameras, 0 for others).\n\n           * New call LibRaw::adjust_maximum() (and libraw_adjust_maximum() in C API).\n             This call changes hardcoded colordata.maximum value to calculated\n             at unpack stage. This helps suppress false color in highlights\n             (magenta clouds and so).\n\n           * New command line parameter -c for dcraw_emu sample. Calls adjust_maximum()\n             for each processed file.\n\n           * all client code should be recompiled due to structures size\n             change\n\n           * LibRaw 0.9.0-Beta1\n\n2010-02-06 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed ambiguity in pow/sqrt calls (to make Sun C++ compiler happy)\n           * OpenMP is not supported under MS Visual Studio\n           * Masked a bug in RIFF format parser\n           * LibRaw 0.8.6\n\n2009-12-30 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in simple_dcraw sample parameters processing\n           * Imported dcraw 8.99 (1.432):\n             + New cameras: Canon:  1D mk IV, Canon S90; Casio Z750,\n               Nikon D3S, Pentax K-x, Sony A-500/550, Fuji S200EXR\n             + New color data for Canon G11 and Sony A850\n             + Changes in Canon sRAW processing\n             + Changes in Kodak metadata processing\n             + Changes in uncompressed Fuji files processing (FinePix S5xxx)\n           * LibRaw 0.8.5\n\n2009-11-21 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed a bug in processing of uncompressed Phase One files\n           * LibRaw 0.8.4\n\n2009-10-24 Alex Tutubalin <lexa@lexa.ru>\n           + Imported dcraw 8.98/1.431:\n             * New Cameras: Canon 7D, Panasonic GF1, Sony A850 and A380,\n             Casio Z850, Nikon D300s\n           + changes in libraw_datastream.h to make compilers more happy\n           * LibRaw 0.8.3\n\n2009-09-02 Alex Tutubalin <lexa@lexa.ru>\n           + Fixed bug in Hasselblad .3FR unpacking code\n           * Imported dcraw 8.97/1.428: Nikon D3000 image width fix\n           * LibRaw 0.8.2\n\n2009-08-31 Alex Tutubalin <lexa@lexa.ru>\n           + Enum LibRaw_thumbnail_formats (LIBRAW_IMAGE_*) values changed to\n             match values in  enum LibRaw_image_formats (LIBRAW_THUMBNAIL_*).\n             You need to recompile all sources using these constants.\n\n2009-08-30 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.97/1.427:\n             + new cameras: Canon A470, Canon G11 (without color data),\n                Nikon D3000, Olympus E-P1, Panasonic DMC-FZ35/FZ38\n             + some changes in decoding code.\n            * Fixes for Microsoft Visual C++ 6.0 compatibility\n            * C-API dcraw_make_mem_thumb() call finally exported in API\n           * LibRaw 0.8.1\n\n2009-08-24 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.96/1.426\n             + New cameras: Casio EX-Z60 and EX-Z75, Kodak Z980,\n               Nikon D5000,  Olympus X200, D560Z,C350Z,E620,\n               Pentax K7, Sony A330.\n             + New color data for many cameras\n             + Generalized unpacker code for Canon and Casio P&S cameras\n           * LibRaw 0.8.0-Release\n\n2009-08-13 Alex Tutubalin <lexa@lexa.ru>\n           * RAW files larger than 2Gb are supported on:\n              - Unix (all supported: FreeBSD, MacOS X, Linux)\n              - Windows (with C runtime version  >= 8.0)\n           * bzero replaced with memset to make Solaris users happy\n           * All applications on 32-bit systems should be recompiled\n             due to data structures size changes.\n           * Minor fixes in windows makefile\n           * LibRaw 0.8.0-Beta5\n\n2009-07-21 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.95 (1.425):\n             + new huffman tree code\n             + New cameras supported: AGFAPHOTO DC-833m, Casio EX-S20,\n                Phase One P65, Samsung S850\n             + Removed hardcoded white-balance data for many P&S cameras.\n               It is recommended to set params.use_camera_wb to 1 for\n               safe WB.\n           * Fixes for Nikon D5000 files: no pink stripe at\n             right side of frame\n           * C-wrapper: added missed calls\n               libraw_dcraw_make_mem_image\n               libraw_dcraw_ make_mem_thumb\n           * Minor fixes to make non-gcc compilers more happy\n           * Internal structures changed, full recompilation of all client\n             code is needed.\n           * LibRaw 0.8.0-Beta4\n\n2009-06-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes: gamma  curve processing was not performed in\n              dcraw_write_mem_image()\n           * Fixes: gamma curve processing was not performed for\n              Kodak thumbnails\n           * LibRaw 0.8.0-Beta3\n\n2009-06-05 Alex Tutubalin <lexa@lexa.ru>\n           * Fixes in documentation: params.gamm[] described more precisely\n           * Fixes in version number, 0.8-beta1 was mistakenly 0.0.0-beta1\n           * LibRaw 0.8.0-Beta2\n\n2009-06-04 Alex Tutubalin <lexa@lexa.ru>\n           * Imported dcraw 8.94 (1.423):\n             + New camera support:\n                 Canon: SX1, 500D/Rebel T1i, A570, A590, SX110\n                 Kodak Z1015, Motorola PIXL, Olympus E30, Panasonic DMC-GH1\n             + Improved color data for Nikon D3X\n             + New gamma curve model\n             + Many changes in RAW unpacking code\n             + Canon cameras: black level is not subtracted if set\n               params.document_mode > 1\n\n           * API changed: params.gamma_16bit field removed. Gamma curve is\n             set via params.gamm[0]/gamm[1] values (see documentation and\n             samples for details)\n           * LibRaw::identify() splitted to avoid MS VS2008 bug (too many\n             nested blocks)\n\n           * Samples: dcraw_emu and mem_image samples supports new dcraw\n              16bit/gamma semantics:\n                -6: set 16 bit output\n                -4: set 16 bit output and linear gamma curve and no auto\n                   brighness\n           *  LibRaw 0.8.0-Beta1\n\n2009-04-28 Alex Tutubalin <lexa@lexa.ru>\n           * Identify sample renamed to raw-identify (name conflict\n             with ImageMagic)\n           * Copyright notice changes\n           * Many compiler warnings removed\n\n2009-04-07 Alex Tutubalin <lexa@lexa.ru>\n           * More accurate types conversion in libraw_datastream.h\n           * New postprocessing parameter auto_bright_thr: set portion of\n             clipped pixels for auto brightening code (instead of\n             dcraw-derived hardcoded 1%)\n           * -U  option for dcraw_emu sample sets auto_bright_thr parameter\n           * all client code should be recompiled due to structures size\n             change\n           * LibRaw 0.7.2-Release\n\n2009-03-22 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed typo in OpenMP support code\n           * MinGW support\n           * dcraw source is included in distribution\n           * LibRaw 0.7.1-Release\n\n2009-03-15 Alex Tutubalin <lexa@lexa.ru>\n           * Fuji SuperCCD RAWs: color channels unshuffled on RAW\n             read stage (moved from postprocessing stage)\n\n           * LibRaw 0.7.0-Release\n\n2009-03-13 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.93/1.421 imported:\n             + more accurate pentax dSLR support\n             + fixes in Kodak 620x/720x identification\n             + faster identification procedure for some formats.\n           * LibRaw 0.7.0-Beta5\n\n\n2009-03-08 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.92/1.420 imported:\n             + user-specified gamma curve\n             + Pentax K2000/Km support\n             + Changes in Canon sRAW processing (support for 5D2 fw 1.07)\n\n           * all client code should be recompiled\n\n           * LibRaw 0.7.0-Beta4\n\n2009-02-13 Alex Tutubalin <lexa@lexa.ru>\n           * bugfix: 4channels sample finally subtracts black by default\n           * dcraw 8.91/1.419 imported:\n              + fixes in RIFF files parsing\n\n           * LibRaw 0.7.0-Beta3\n\n2009-02-12 Alex Tutubalin <lexa@lexa.ru>\n           * Black level was not calculated for Canon RAWs in\n             some filtering modes\n\n           * 4channels sample prints calculated black level\n             (scaled if autoscaling used).\n             Also output file names for this sample now includes\n             color channel name (R/G/B/G2 or C/M/Y/G)\n\n           * LibRaw 0.7.0-Beta2\n\n2009-02-09 Alex Tutubalin <lexa@lexa.ru>\n           * New sample 4channels: splits RAW color channels into four\n             separate TIFFs\n\n           * LibRaw 0.7.0-Beta1\n\n2009-02-07 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in external jpeg metadata reading code.\n\n           * Cleaned some C++ warnings\n\n           * dcraw 8.91/1.418 imported\n             + Hasselblad V96C support\n\n           * You need to clean and recompile client code which\n             uses LibRaw_*_datastream classes.\n\n           * LibRaw 0.7.0-Alpha6\n\n2009-01-30  Alex Tutubalin <lexa@lexa.ru>\n\n           * New data input framework is created. It is possible now to\n             easyly implement your own data input interface for LibRaw\n             (e.g. for reading RAW data from network data stream)\n\n           * All older programs using previous LibRaw versions are\n\t     compatible at source code level.\n\n           * LibRaw can read RAW data from memory buffer via\n             new LibRaw::open_buffer() API call (implemented on top of\n             new input framework).\n             This call used in sample application dcraw_emu and simple_dcraw\n             (with -B command-line switch) to test new API.\n\n           * Error handling callback functions now can be called with\n             NULL filename passed (if underlying data stream object\n             does not know file name).\n             So, client error handling callbacks should work with NULL\n             filename.\n\n           * All client code should be recompiled\n\n           * Imported dcraw 8.90/1.417:\n              + Support for loading White Balance data from\n                Sony ARW files edited with Sony IDC software.\n\n           * LibRaw 0.7.0-Alpha5\n\n2009-01-17 Alex Tutubalin <lexa@lexa.ru>\n           * Raw filtering mode LIBRAW_FILTERING_NOPOSTPROCESS has renamed\n            to LIBRAW_FILTERING_NORAWCURVE for better reflect its purpose.\n            This filtering_mode bit turns off tone curve applying on\n            RAW data on bayer-pattern cameras with raw tone curve:\n              + Adobe DNG (only RAW with bayer pattern)\n              + Nikon compressed NEF\n              + Some Kodak cameras\n              + Sony A700/A900 (tone curve applied to 8-bit raws)\n\n           * unprocessed_raw sample: added command-line key -N, this key\n             turns on LIBRAW_FILTERING_NORAWCURVE filtering mode.\n\n           * New scheme of Fuji RAW processing (introduced in 0.7-Alpha3)\n             supports DNG files generated from Fuji RAF.\n\n           * Imported dcraw 8.90/1.416:\n              + better support for Samsung S85\n              + fixed possible integer overflow in wavelet denoising code\n\n           * LibRaw 0.7.0-Alpha4\n\n\n2009-01-14 Alex Tutubalin <lexa@lexa.ru>\n           * Black mask extraction supported for all files with bayer data\n            (one component per pixel). Black mask data not avaliable\n            for multi-component data (Foveon, Canon sRAW, Sinar 4-shot,\n            Kodak YCC/YRGB).\n\n           * Black level subtraction can be turned off for all bayer\n            cameras (added support for PhaseOne backs).\n\n           * Fujifilm camera processing model changed:\n              + RAW data is extracted without 45-degree rotation\n              + dcraw-compatible rotation is performed on postptocessing stage\n              + it is possible to rotate RAW data without postprocessing\n                by LibRaw::rotate_fuji_raw() call.\n\n           * New filtering mode setting: LIBRAW_FILTERING_NOPOSTPROCESS\n             This bits turns off RAW tone curve processing based on tone curve\n             readed from RAW metadata.\n             This mode supported only for PhaseOne backs now (to be supported\n             on all relevant cameras in nearest future releases)\n\n           * Black level data (got from RAW data) are stored for PhaseOne backs.\n\n           * Black level subtraction bug (derived from dcraw) fixed\n             for PhaseOne files.\n\n           * Fixed processing of -s parameter for dcraw_emu sample\n\n           * Parameter  -s N (select shot number) added to\n             unprocessed_raw sample.\n\n           * Imported dcraw 8.90/1.414:\n              + changes in QuickTake 100 metadata processing\n              + changes in external jpeg processing code\n              + Samsung S85 support\n\n           * All client code should be recompiled\n\n           * LibRaw 0.7.0-Alpha3 released\n\n2009-01-10 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in add_masked_borders: crash if output dimensions\n            is already larger than raw dimensions\n            * Fixed out of bounds in samples/unprocessed_raw.cpp for files\n            with non-square pixels\n\n           * LibRaw 0.7.0-Alpha2 released\n\n2009-01-08 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed bug in  0.7.0-a0: black frame size has not reset,\n             so in batch processing there is an error in black frame\n             size for files without black frame.\n\n           * Implemented reading of black/masked pixels data for\n             near all cameras with masked pixels, exclding:\n              + Canon sRAW, Leaf (MOS), Sinar 4-shot - more than one\n                color component in black frame (redesign of black frame\n                data structures required).\n              + Fuji SuperCCD: need to design right methods of extraction\n                (should we rotate and resize black pixels as active ones??)\n\n            * Tested for most dSLR data formats with masked pixels: 7 of 9\n              untested formats are from old P&S cameras.\n\n           * New call LibRaw::unpack_function_name() returns unpack function name\n             (useful for testers only)\n\n           * New identify sample parameters (useful for test-suite builders\n             to check test coverage):\n                  -u - print unpack function name\n                  -f - print masked frame size\n             These parameters works only for identify run without -v parameter\n\n           * Imported dcraw 8.89/1.411\n             + changes in Panasonic FZ50 files parsing\n\n           * LibRaw 0.7.0-Alpha1 released\n\n\n2009-01-05 Alex Tutubalin <lexa@lexa.ru>\n           * It is possible to turn off RAW data filtration (black level\n             subtraction,              zero pixels averaging):\n                + supported on all cameras except Foveon and Phase One\n                + filtraction controlled by new parameter \"filtering_mode\"\n                + it is possible to expand API by filtering procedures\n                  built for specific camera model.\n\n           * Black border (masked pixels) extraction:\n                + API (data structures) for storing black mask.\n                + Black mask extraction supported only for limited list of\n                  data formats:\n                       - Canon .CRW, .CR2 (with exception of sRAW),A600, A5\n                       - Adobe DNG (both converted RAW and native DNG)\n                       - Nikon NEF (compressed only)\n                  this list to be expanded in future LibRaw versions\n           * New call add_masked_borders_to_bitmap makes full bitmap\n             'masked border' + image\n           * Usage sample for functionality listed above:\n              samples/unprocessed_raw\n           * Imported dcraw 8.89/1.410:\n              + fixed bugs in Hasselblad .fff decoding\n              + fixes in Imacon metadata decoding\n           * Documentation changes\n           * All client code should be recompiled\n           * LibRaw 0.7.0-Alpha0\n\n\n2009-01-01 Alex Tutubalin <lexa@lexa.ru>\n           * Fixed a bug (filedescriptor and buffer memory leak)  in thumbnail\n             extraction when called before metadata analysis.\n             Thanks to Albert Astalis Cid.\n           * LibRaw 0.6.4 Release\n\n2008-12-11 Alex Tutubalin <lexa@lexa.ru>\n           * Imported new edition of dcraw 8.89 (version 1.409)\n           * Nikon NEF decoding changed\n           * LibRaw 0.6.3 Release\n\n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * fixed bug in Panasonic .RW2 processing (only for thread-safe version,\n             single-threaded version was not affected)\n           * All client code should be recompiled\n           * LibRaw 0.6.2 Release\n\n2008-12-03 Alex Tutubalin <lexa@lexa.ru>\n           * Imported  dcraw 8.89 (version 1.407)\n           * New cameras:\n               Canon G10 & 5D Mk2, Leaf AFi 7, Leica D-LUX4, Panasonic FX150 & G1,\n               Fujifilm IS Pro,\n           * Changed camera support (color conversion tables):\n               Canon 50D, Nikon D90 & P6000, Panasonic LX3 & FZ28, Sony A900\n           * LibRaw 0.6.2 beta\n\n2008-09-25 Alex Tutubalin <lexa@lexa.ru>\n           * Added new data field  float LibRaw::imgdata.color.cam_xyz[4][3].\n           This field contains constant table (different for each camera) for\n           Camera RGB->XYZ conversion.\n           * All client code should be recompiled\n           * LibRaw 0.6.1 Release\n\n2008-09-18 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 8.88 imported:\n              - new cameras (Canon 50D, Sony A900, Nikon D90 & P6000,\n                Panasonic LX3 FZ28)\n              - new method of black point subtraction for Canon cameras,\n                preliminary banding supression.\n            * Stack memory usage lowered (some thread data moved to dynamic\n            memory)\n            * some patches for MSVC compatibility\n            * LibRaw 0.6.0 Release\n\n2008-09-16 Alex Tutubalin <lexa@lexa.ru>\n           * Enum definitions changed to make gcc -pedantic happy\n           * Compiler/preprocessor flags does not affects LibRaw class field set\n           (i.e. structure for thread local storage is always allocated)\n           * Default library compilation mode (i.e. sources imported in another\n             project) is thread-safe\n\n2008-09-14 Alex Tutubalin <lexa@lexa.ru>\n           * OpenMP support for most CPU consuming steps of processing:\n             ahd_interpolation. wavelet_denoise\n             10-30% speed-up of full processing pipe on 2-core CPU\n             OpenMP supported only on gcc (Linux/FreeBSD and Mac OS X)\n\n           * LibRaw 0.6.0-Beta-1\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           *  All set_**handler accepts additional void* pointer, which should point to\n            callback private data. This pointer passed to user callback when it called.\n\n           * LibRaw 0.6.0-alpha5\n\n           * All client code should be recompiled\n\n2008-09-10 Alex Tutubalin <lexa@lexa.ru>\n           * New processing stages in enum LibRaw_progress:\n             LIBRAW_PROGRESS_BAD_PIXELS LIBRAW_PROGRESS_DARK_FRAME\n            (reserved stages LIBRAW_PROGRESS_RESERVED_PRE1-PRE2 has removed)\n           * libraw_strprogress() - convert progress code into string\n\n           * Added progress/cancellation user callbacks\n             + new fatal error code: CANCELLED_BY_CALLBACK\n             + sample usage in samples/dcraw_emu.cpp (try run it with -v -v -v opts)\n\n           * LibRaw 0.6.0-alpha4\n\n           * All client code should be recompiled\n\n2008-09-08 Alex Tutubalin <lexa@lexa.ru>\n           * ICC-profiles support (same as in dcraw)\n             + input/output profiles (specified as path to 'icc' file or 'embed' for\n               embedded input profile)\n             + additional warnings\n             + LCMS library used\n\n           * support of bad pixel map (caller should specify path to bad pixel file\n              in dcraw-compatible format)\n\n           * dark frame subtraction support (caller should supply path to 16-bit PGM\n              map). samples/simple_dcraw.cpp - -4 option added for dark frame file\n              generation\n\n           * support of bad pixeld map (dcraw-compatible format)\n\n           * the dcraw_emu sample supports all new features (ICC, dark frame, bad\n              pixels)\n\n           * libraw/libraw_version.h, defines, calls and macros for version checks:\n              + LibRaw::version(), LibRaw::versionNumber(), LIBRAW_CHECK_VERSION()\n\n           * List of supported cameras:\n              + LibRaw::cameraCount()\n              + LibRaw::cameraList()\n\n           * fixed error in adjust_sizes_info_only\n\n           * documentation changes\n\n           * LibRaw 0.6.0-alpha3\n\n2008-09-07 Alex Tutubalin <lexa@lexa.ru>\n           * samples/mem_image.c - bitwise equal output with dcraw -4\n             (PPMs outputted with network byte order)\n           * LibRaw 0.6.0-alpha2\n\n2008-09-06 Alex Tutubalin <lexa@lexa.ru>\n           * Added calls dcraw_make_mem_image and dcraw_make_mem_image:\n             + functions (and supporting code)\n             + documentation changed\n             + new sample code samples/mem_image.cpp\n           * Added processing parameter  LibRaw::imgdata.params.gamma_16bit\n              (set to 1 to make gamma correction for 16-bit output)\n           * LibRaw 0.6.0-alpha1\n\n2008-08-28 Alex Tutubalin <lexa@lexa.ru>\n           * dcraw 1.404 (8.87) imported:\n             - 6 new cameras supported (Canon 1000D, A720, SD300;\n                Nikon D700, Oly E-520,Kodak C603)\n           * Licensing changed to GPL v2\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * mmap/malloc+read IO-layer removed due to no performance gain.\n              FILE I/O returned\n\n2008-05-02  Alex Tutubalin <lexa@lexa.ru>\n            * dcraw 1.403 imported\n              - changes in ljpeg decompression (index values cut to 12 bit)\n              - changes in parse_foveon() jpeg thumbnail extraction\n            * LibRaw 0.5.3 released\n\n2008-04-24  Alex Tutubalin <lexa@lexa.ru>\n            * Linux build of samples/identify fixed\n            * documentation editorial\n            * LibRaw 0.5.2 released\n\n2008-04-21  Alex Tutubalin <lexa@lexa.ru>\n            * All documentation translated to English\n            * English changelog started :)\n            * minor bug (include path) fixed in samples/half_mt\n            * LibRaw 0.5.1 released\n", "#ifndef IGNOREALL\n/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2015 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.476 $\n   $Date: 2015/05/25 02:29:14 $\n */\n/*@out DEFINES\n#ifndef USE_JPEG\n#define NO_JPEG\n#endif\n#ifndef USE_JASPER\n#define NO_JASPER\n#endif\n@end DEFINES */\n\n#define NO_LCMS\n#define DCRAW_VERBOSE\n//@out DEFINES\n#define DCRAW_VERSION \"9.26\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _USE_MATH_DEFINES\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n//@end DEFINES\n\n#if defined(DJGPP) || defined(__MINGW32__)\n#define fseeko fseek\n#define ftello ftell\n#else\n#define fgetc getc_unlocked\n#endif\n//@out DEFINES\n#ifdef __CYGWIN__\n#include <io.h>\n#endif\n#if defined WIN32 || defined (__MINGW32__)\n#include <sys/utime.h>\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define snprintf _snprintf\n#define strcasecmp stricmp\n#define strncasecmp strnicmp\n//@end DEFINES\ntypedef __int64 INT64;\ntypedef unsigned __int64 UINT64;\n//@out DEFINES\n#else\n#include <unistd.h>\n#include <utime.h>\n#include <netinet/in.h>\ntypedef long long INT64;\ntypedef unsigned long long UINT64;\n#endif\n\n#ifdef NODEPS\n#define NO_JASPER\n#define NO_JPEG\n#define NO_LCMS\n#endif\n#ifndef NO_JASPER\n#include <jasper/jasper.h>\t/* Decode Red camera movies */\n#endif\n#ifndef NO_JPEG\n#include <jpeglib.h>\t\t/* Decode compressed Kodak DC120 photos */\n#endif\t\t\t\t/* and Adobe Lossy DNGs */\n#ifndef NO_LCMS\n#ifdef USE_LCMS\n#include <lcms.h>\t\t/* Support color profiles */\n#else\n#include <lcms2.h>\t\t/* Support color profiles */\n#endif\n#endif\n#ifdef LOCALEDIR\n#include <libintl.h>\n#define _(String) gettext(String)\n#else\n#define _(String) (String)\n#endif\n\n#ifdef LJPEG_DECODE\n#error Please compile dcraw.c by itself.\n#error Do not link it with ljpeg_decode.\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * sizeof (long))\n#endif\n//@end DEFINES\n\n#if !defined(uchar)\n#define uchar unsigned char\n#endif\n#if !defined(ushort)\n#define ushort unsigned short\n#endif\n\n/*\n   All global variables are defined here, and all functions that\n   access them are prefixed with \"CLASS\".  Note that a thread-safe\n   C++ class cannot have non-const static local variables.\n */\nFILE *ifp, *ofp;\nshort order;\nconst char *ifname;\nchar *meta_data, xtrans[6][6], xtrans_abs[6][6];\nchar cdesc[5], desc[512], make[64], model[64], model2[64], artist[64],software[64];\nfloat flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;\ntime_t timestamp;\noff_t strip_offset, data_offset;\noff_t thumb_offset, meta_offset, profile_offset;\nunsigned shot_order, kodak_cbpp, exif_cfa, unique_id;\nunsigned thumb_length, meta_length, profile_length;\nunsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;\nunsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;\nunsigned black, maximum, mix_green, raw_color, zero_is_bad;\nunsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;\nunsigned tile_width, tile_length, gpsdata[32], load_flags;\nunsigned flip, tiff_flip, filters, colors;\nushort raw_height, raw_width, height, width, top_margin, left_margin;\nushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;\nushort *raw_image, (*image)[4], cblack[4102];\nushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];\ndouble pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };\nfloat bright=1, user_mul[4]={0,0,0,0}, threshold=0;\nint mask[8][4];\nint half_size=0, four_color_rgb=0, document_mode=0, highlight=0;\nint verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=1;\nint output_color=1, output_bps=8, output_tiff=0, med_passes=0;\nint no_auto_bright=0;\nunsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };\nfloat cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];\nconst double xyz_rgb[3][3] = {\t\t\t/* XYZ from RGB */\n  { 0.412453, 0.357580, 0.180423 },\n  { 0.212671, 0.715160, 0.072169 },\n  { 0.019334, 0.119193, 0.950227 } };\nconst float d65_white[3] = { 0.950456, 1, 1.088754 };\nint histogram[4][0x2000];\nvoid (*write_thumb)(), (*write_fun)();\nvoid (*load_raw)(), (*thumb_load_raw)();\njmp_buf failure;\n\nstruct decode {\n  struct decode *branch[2];\n  int leaf;\n} first_decode[2048], *second_decode, *free_decode;\n\nstruct tiff_ifd {\n  int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;\n  int t_tile_width, t_tile_length,sample_format,predictor;\n  float t_shutter;\n} tiff_ifd[10];\n\nstruct ph1 {\n  int format, key_off, tag_21a;\n  int t_black, split_col, black_col, split_row, black_row;\n  float tag_210;\n} ph1;\n\n#define CLASS\n\n//@out DEFINES\n#define FORC(cnt) for (c=0; c < cnt; c++)\n#define FORC3 FORC(3)\n#define FORC4 FORC(4)\n#define FORCC for (c=0; c < colors && c < 4; c++)\n\n#define SQR(x) ((x)*(x))\n#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))\n#define CLIP(x) LIM((int)(x),0,65535)\n#define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }\n\n#define my_swap(type, i, j) {type t = i; i = j; j = t;}\n\nstatic float fMAX(float a, float b)\n{\n  return MAX(a,b);\n}\n\n/*\n   In order to inline this calculation, I make the risky\n   assumption that all filter patterns can be described\n   by a repeating pattern of eight rows and two columns\n\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\n   because its pattern is 16x16, not 2x8.\n\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\n\n\tPowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\n\t0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\n\t1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\n\t2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\n\t3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\n\t\t\t4 C Y C Y C Y\t4 Y C Y C Y C\n\tPowerShot A5\t5 G M G M G M\t5 G M G M G M\n\t0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\n\t\t\t7 M G M G M G\t7 M G M G M G\n\t  0 1 2 3 4 5\n\t0 C Y C Y C Y\n\t1 G M G M G M\n\t2 C Y C Y C Y\n\t3 M G M G M G\n\n   All RGB cameras use one of these Bayer grids:\n\n\t0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\n\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n\t0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\n\t1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\n\t2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\n\t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n */\n\n#define RAW(row,col) \\\n\traw_image[(row)*raw_width+(col)]\n//@end DEFINES\n\n#define FC(row,col) \\\n\t(filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)\n\n//@out DEFINES\n#define BAYER(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]\n\n#define BAYER2(row,col) \\\n\timage[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]\n//@end DEFINES\n\n/* @out COMMON\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end COMMON */\n\n//@out COMMON\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return(p ? p-s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a,b) local_strnlen(a,b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n int r = fp->read(buf,len,1);\n buf[len-1] = 0;\n return r;\n}\n#define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr (char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf,sizeof(buf)-1)\n\n//@end COMMON\n\n\nvoid CLASS merror (void *ptr, const char *where)\n{\n  if (ptr) return;\n  fprintf (stderr,_(\"%s: Out of memory in %s\\n\"), ifname, where);\n  longjmp (failure, 1);\n}\n\nvoid CLASS derror()\n{\n  if (!data_error) {\n    fprintf (stderr, \"%s: \", ifname);\n    if (feof(ifp))\n      fprintf (stderr,_(\"Unexpected end of file\\n\"));\n    else\n      fprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) ftello(ifp));\n  }\n  data_error++;\n}\n\n//@out COMMON\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG\t1\n#define AdobeDNG\t2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords,int maxlen)\n{\n  line[maxlen-1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while(1)\n  {\n    while(isspace(*p)) p++;\n    if(*p == '\\0') return nwords;\n    words[nwords++] = p;\n    while(!isspace(*p) && *p != '\\0') p++;\n    if(*p == '\\0') return nwords;\n    *p++ = '\\0';\n    if(nwords >= maxwords) return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f){\n\tif ((a >> 4) > 9) return 0;\n\telse if ((a & 0x0f) > 9) return 0;\n\telse if ((b >> 4) > 9) return 0;\n\telse if ((b & 0x0f) > 9) return 0;\n\telse if ((c >> 4) > 9) return 0;\n\telse if ((c & 0x0f) > 9) return 0;\n\telse if ((d >> 4) > 9) return 0;\n\telse if ((d & 0x0f) > 9) return 0;\n\telse if ((e >> 4) > 9) return 0;\n\telse if ((e & 0x0f) > 9) return 0;\n\telse if ((f >> 4) > 9) return 0;\n\telse if ((f & 0x0f) > 9) return 0;\nreturn 1;\n}\n\nstatic ushort bcd2dec(uchar data){\n\tif ((data >> 4) > 9) return 0;\n\telse if ((data & 0x0f) > 9) return 0;\n\telse return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] = \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s)\t// specific to some Canon Makernotes fields, where they have endian in reverse\n{\n\tif (order == 0x4d4d)\t\t/* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n\t\treturn s[0] | s[1] << 8;\n\telse\t\t\t\t\t\t/* \"MM\" means big-endian... */\n\t\treturn s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u,v;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:\n      u.d = (unsigned int) get4();\n      v.d = (unsigned int)get4();\n      return u.d / (v.d ? v.d : 1);\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10:\n      u.d = (signed int) get4();\n      v.d = (signed int)get4();\n      return u.d / (v.d?v.d:1);\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS cubic_spline (const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);\n  if (!A) return;\n  A[0] = (float *) (A + 2*len);\n  for (i = 1; i < 2*len; i++)\n    A[i] = A[0] + 2*len*i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));\n  for (i = 0; i < len; i++) {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len-1; i > 0; i--) {\n    b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);\n    d[i-1] = x[i] - x[i-1];\n  }\n  for (i = 1; i < len-1; i++) {\n    A[i][i] = 2 * (d[i-1] + d[i]);\n    if (i > 1) {\n      A[i][i-1] = d[i-1];\n      A[i-1][i] = d[i-1];\n    }\n    A[i][len-1] = 6 * (b[i+1] - b[i]);\n  }\n  for(i = 1; i < len-2; i++) {\n    float v = A[i+1][i] / A[i][i];\n    for(j = 1; j <= len-1; j++)\n      A[i+1][j] -= v * A[i][j];\n  }\n  for(i = len-2; i > 0; i--) {\n    float acc = 0;\n    for(j = i; j <= len-2; j++)\n      acc += A[i][j]*c[j];\n    c[i] = (A[i][len-1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++) {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len-1; j++) {\n      if (x[j] <= x_out && x_out <= x[j+1]) {\n\tfloat v = x_out - x[j];\n\ty_out = y[j] +\n\t  ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v\n\t   + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :\n\t\t(ushort)(y_out * 65535.0 + 0.5));\n  }\n  free (A);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25) return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row+=8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    FORC(2) free (huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free (huff[c]);\n}\n//@end COMMON\n\nstruct jhead {\n  int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];\n  ushort quant[64], idct[64], *huff[20], *free[20], *row;\n};\n\n//@out COMMON\n\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;\n  do {\n    if(feof(ifp)) return 0;\n    if(cnt++ > 1024) return 0; // 1024 tags limit\n    if (!fread (data, 2, 2, ifp)) return 0;\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:        // start of frame; lossless, Huffman\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc1:\n      case 0xffc0:\n\tjh->algo = tag & 0xff;\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:          // define Huffman tables\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && !((c = *dp++) & -20); )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:          // start of scan\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdb:\n\tFORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 ||\n     !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;\n  if (info_only) return 1;\n  if (!jh->huff[0]) return 0;\n  FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n  if(!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row=0, col=0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if(jh.clrs == 4 && jwide >= raw_width*2) jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*raw_height);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*raw_height);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp (failure, 3);\n#endif\n      if ((unsigned) row < raw_height) RAW(row,col) = val;\n      if (++col >= raw_width)\n\tcol = (row++,0);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  ljpeg_end (&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(load_flags & 256)\n  {\n\twidth = raw_width;\n\theight = raw_height;\n  }\n\n  try {\n#endif\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n\t  rp = (short *) ljpeg_row (jrow++, &jh);\n\tif (col >= width) continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC (jh.clrs-2)\n              {\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n                ip[col + (c >> 1)*width + (c & 1)][1] = ip[col + (c >> 1)*width + (c & 1)][2] = 8192;\n              }\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC (jh.clrs-2)\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else\n#endif\n          {\n            FORC (jh.clrs-2)\n              ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n          }\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n    {\n      ljpeg_end (&jh);\n      maximum = 0x3fff;\n      height = saved_h;\n      width = saved_w;\n      return;\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (row & (jh.sraw >> 1))\n    {\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n          {\n\t       ip[col][c] =  ip[col-width][c];\n          }\n          else\n          {\n              ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n          }\n    }\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB) )\n#endif\n    for ( ; rp < ip[0]; rp+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (unique_id == 0x80000218 ||\n          unique_id == 0x80000250 ||\n          unique_id == 0x80000261 ||\n          unique_id == 0x80000281 ||\n          unique_id == 0x80000287) {\n        rp[1] = (rp[1] << 2) + hue;\n        rp[2] = (rp[2] << 2) + hue;\n        pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n        pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n        pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n      } else {\n        if (unique_id < 0x80000218) rp[0] -= 512;\n        pix[0] = rp[0] + rp[2];\n        pix[2] = rp[0] + rp[1];\n        pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n      }\n      FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += tiff_samples;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select) (*rp)--;\n}\n\nvoid CLASS ljpeg_idct (struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = { 0 };\n  static const uchar zigzag[80] =\n  {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,\n    40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,\n    29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,\n    47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;\n  memset (work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];\n  for (i=1; i < 64; i++ ) {\n    len = gethuff (jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15) break;\n    coef = getbits(len);\n    if ((coef & (1 << (len-1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= MIN (is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try {\n#endif\n      switch (jh.algo) {\n      case 0xc1:\n\tjh.vpred[0] = 16384;\n\tgetbits(-1);\n\tfor (jrow=0; jrow+7 < jh.high; jrow += 8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  for (jcol=0; jcol+7 < jh.wide; jcol += 8) {\n\t    ljpeg_idct (&jh);\n\t    rp = jh.idct;\n\t    row = trow + jcol/tile_width + jrow*2;\n\t    col = tcol + jcol%tile_width;\n\t    for (i=0; i < 16; i+=2)\n\t      for (j=0; j < 8; j++)\n\t\tadobe_copy_pixel (row+i, col+j, &rp);\n\t  }\n\t}\n\tbreak;\n      case 0xc3:\n\tfor (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  rp = ljpeg_row (jrow, &jh);\n\t  for (jcol=0; jcol < jwide; jcol++) {\n\t    adobe_copy_pixel (trow+row, tcol+col, &rp);\n\t    if (++col >= tile_width || col >= raw_width)\n\t      row += 1 + (col = 0);\n\t  }\n\t}\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n    }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n    }\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (pixel);\n    throw ;\n  }\n#endif\n  free (pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width*3*tiff_bps/8;\n  if(tiff_bps <= 8)\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n  else\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n  fseek (ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char*)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for(int row = 0; row < raw_height; row++)\n    {\n      int red = fread (buf, 1, bufsize, ifp);\n      unsigned short (*ip)[4] = (unsigned short (*)[4]) image + row*width;\n      if(tiff_bps <= 8)\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[buf[col*3]];\n            ip[col][1] = curve[buf[col*3+1]];\n            ip[col][2] = curve[buf[col*3+2]];\n            ip[col][3]=0;\n          }\n      else\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[ubuf[col*3]];\n            ip[col][1] = curve[ubuf[col*3+1]];\n            ip[col][2] = curve[ubuf[col*3+2]];\n            ip[col][3]=0;\n          }\n    }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (min=row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n      i = gethuff(huff);\n      len = i & 15;\n      shl = i >> 4;\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (huff);\n    throw;\n  }\n#endif\n  free (huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col=0; col < raw_width; col++) {\n      if (!(b = col & 1)) {\n\tbitbuf = 0;\n\tFORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;\n\tFORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705*yuv[3];\n      rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];\n      rgb[2] = yuv[b] + 1.732446*yuv[2];\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"Pentax\",  \"Optio 33WR\" },\n    { 0x03, \"Nikon\",   \"E3200\" },\n    { 0x32, \"Nikon\",   \"E3700\" },\n    { 0x33, \"Olympus\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n//@end COMMON\n\nvoid CLASS jpeg_thumb();\n\n//@out COMMON\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length, 2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0) return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < high; y++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5];\n\t row < raw_height && row < rend &&\n\t row < head[1]+head[3]-head[5]; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4];\n\t     col < raw_width &&\n\t     col < cend && col < head[0]+head[2]-head[4]; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  /* static */ const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2]={NULL,NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!meta_length)\n#else\n  if (half_size || !meta_length)\n#endif\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  while (entries--) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n      }\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131 || type == 137)\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    } else if (tag == 0x41f && !qlin_applied) { /* Quadrant linearization */\n      ushort lc[2][2][16], ref[16];\n      int qr, qc;\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 16; i++)\n\t    lc[qr][qc][i] = get4();\n      for (i = 0; i < 16; i++) {\n\tint v = 0;\n\tfor (qr = 0; qr < 2; qr++)\n\t  for (qc = 0; qc < 2; qc++)\n\t    v += lc[qr][qc][i];\n\tref[i] = (v + 2) >> 2;\n      }\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[19], cf[19];\n\t  for (i = 0; i < 16; i++) {\n\t    cx[1+i] = lc[qr][qc][i];\n\t    cf[1+i] = ref[i];\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n          cf[18] = cx[18] = 65535;\n\t  cubic_spline(cx, cf, 19);\n\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n\t}\n      }\n      qlin_applied = 1;\n    } else if (tag == 0x41e && !qmult_applied) { /* Quadrant multipliers */\n      float qmult[2][2] = { { 1, 1 }, { 1, 1 } };\n      get4(); get4(); get4(); get4();\n      qmult[0][0] = 1.0 + getreal(11);\n      get4(); get4(); get4(); get4(); get4();\n      qmult[0][1] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][0] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][1] = 1.0 + getreal(11);\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col=0; col < raw_width; col++) {\n\t  i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);\n\t  RAW(row,col) = LIM(i,0,65535);\n\t}\n      }\n      qmult_applied = 1;\n    } else if (tag == 0x431 && !qmult_applied) { /* Quadrant combined */\n      ushort lc[2][2][7], ref[7];\n      int qr, qc;\n      for (i = 0; i < 7; i++)\n\tref[i] = get4();\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 7; i++)\n\t    lc[qr][qc][i] = get4();\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[9], cf[9];\n\t  for (i = 0; i < 7; i++) {\n\t    cx[1+i] = ref[i];\n\t    cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[8] = cf[8] = 65535;\n\t  cubic_spline(cx, cf, 9);\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n        }\n      }\n      qmult_applied = 1;\n      qlin_applied = 1;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    }\n    free (yval[0]);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if(yval[0]) free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw()\");\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw()\");\n      if (ph1.black_col)\n        {\n          fseek (ifp, ph1.black_col, SEEK_SET);\n          read_shorts ((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height*2);\n        }\n      if (ph1.black_row)\n        {\n          fseek (ifp, ph1.black_row, SEEK_SET);\n          read_shorts ((ushort *) imgdata.rawdata.ph1_rblack[0], raw_width*2);\n        }\n      }\n#endif\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short (*)[2]) (offset + raw_height);\n  fseek (ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n      read_shorts ((ushort *) c_black[0], raw_height*2);\n  r_black = c_black + raw_height;\n  fseek (ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n      read_shorts ((ushort *) r_black[0], raw_width*2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_cblack,(ushort*)c_black[0],raw_height*2*sizeof(ushort));\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_rblack,(ushort*)r_black[0],raw_width*2*sizeof(ushort));\n    }\n#endif\n\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (col=0; col < raw_width; col++) {\n      int shift = ph1.format == 8? 0: 2;\n      i = (pixel[col] << shift) - ph1.t_black\n\t+ c_black[row][col >= ph1.split_col]\n\t+ r_black[col][row >= ph1.split_row];\n      if (i > 0) RAW(row,col) = i;\n    }\n#else\n    if(ph1.format == 8)\n      memmove(&RAW(row,0),&pixel[0],raw_width*2);\n    else\n      for (col=0; col < raw_width; col++)\n      \tRAW(row,col) = pixel[col] << 2;\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  back[4] = (int *) calloc (raw_width, 3*sizeof **back);\n  merror (back[4], \"hasselblad_load_raw()\");\n  FORC3 back[c] = back[4] + c*raw_width;\n  cblack[6] >>= sh = tiff_samples > 1;\n  shot = LIM(shot_select, 1, tiff_samples) - 1;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC4 back[(c+3) & 3] = back[c];\n    for (col=0; col < raw_width; col+=2) {\n      for (s=0; s < tiff_samples*2; s+=2) {\n\tFORC(2) len[c] = ph1_huff(jh.huff[0]);\n\tFORC(2) {\n\t  diff[s+c] = ph1_bits(len[c]);\n\t  if ((diff[s+c] & (1 << (len[c]-1))) == 0)\n\t    diff[s+c] -= (1 << len[c]) - 1;\n\t  if (diff[s+c] == 65535) diff[s+c] = -32768;\n\t}\n      }\n      for (s=col; s < col+2; s++) {\n\tpred = 0x8000 + load_flags;\n\tif (col) pred = back[2][s-2];\n\tif (col && row > 1) switch (jh.psv) {\n\t  case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;\n\t}\n\tf = (row & 1)*3 ^ ((col+s) & 1);\n\tFORC (tiff_samples) {\n\t  pred += diff[(s & 1)*tiff_samples+c];\n\t  upix = pred >> sh & 0xffff;\n\t  if (raw_image && c == shot)\n\t    RAW(row,s) = upix;\n\t  if (image) {\n\t    urow = row-top_margin  + (c & 1);\n\t    ucol = col-left_margin - ((c >> 1) & 1);\n\t    ip = &image[urow*width+ucol][f];\n\t    if (urow < height && ucol < width)\n\t      *ip = c < 4 ? upix : (*ip + upix) >> 1;\n\t  }\n\t}\n\tback[2][s] = pred;\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (back[4]);\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  free (back[4]);\n  ljpeg_end (&jh);\n  if (image) mix_green = 1;\n}\n\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n  }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n    int row, col, bits=0;\n    while (1 << ++bits < maximum);\n    for (row=raw_height-1; row >= 0; row--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcheckCancel();\n#endif\n\tread_shorts (&raw_image[row*raw_width], raw_width);\n\tfor (col=0; col < raw_width; col++)\n\t\tif ((RAW(row,col) >>= load_flags) >> bits\n\t\t\t&& (unsigned) (row-top_margin) < height\n\t\t\t&& (unsigned) (col-left_margin) < width) derror();\n    }\n}\n\n\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image) return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width*3*sizeof(unsigned short));\n  merror(buf,\"imacon_full_load_raw\");\n#endif\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf,width*3);\n    unsigned short (*rowp)[4] = &image[row*width];\n    for (col=0; col < width; col++)\n      {\n        rowp[col][0]=buf[col*3];\n        rowp[col][1]=buf[col*3+1];\n        rowp[col][2]=buf[col*3+2];\n        rowp[col][3]=0;\n      }\n#else\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < raw_width; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&\n\trow < height+top_margin && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom () {\n\n/* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek (ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread (&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right)*5)+3)>>2) + 0x1f)&(~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616;  /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order) {\n    case 0: /* RGGB */\n      filters = 0x94949494;\n      break;\n    case 1: /* GBRG */\n      filters = 0x49494949;\n      break;\n    case 3: /* GRBG */\n      filters = 0x61616161;\n      break;\n  }\n}\n\nvoid CLASS broadcom_load_raw() {\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *) malloc (raw_stride*2);\n  merror (data, \"broadcom_load_raw()\");\n\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+raw_stride, 1, raw_stride, ifp) < raw_stride) derror();\n    FORC(raw_stride) data[c] = data[raw_stride+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n  double sum[]={0,0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (data);\n    throw;\n  }\n#endif\n  free (data);\n  maximum = 0x3ff;\n  if (strncmp(make,\"OmniVision\",10)) return;\n  row = raw_height/2;\n  FORC(width-1) {\n    sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));\n    sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));\n  }\n  if (sum[1] > sum[0]) filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5*raw_width >> 5) << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_tight_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n}\n  free (data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf=0;\n\n  bwide = (raw_width+5)/6 << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_loose_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=8, col+=6) {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c^7];\n      FORC(6) RAW(row,col+c) = (bitbuf >> c*10) & 0x3ff;\n    }\n  }\n  free (data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int*)malloc(sizeof(int)*(raw_width/3+1));\n  merror(words,\"canon_rmf_load_raw\");\n#endif\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words,sizeof(int),raw_width/3,ifp);\n    for (col=0; col < raw_width-2; col+=3)\n      {\n        bits = words[col/3];\n        FORC3 {\n          orow = row;\n          if ((ocol = col+c-4) < 0)\n            {\n              ocol += raw_width;\n              if ((orow -= 2) < 0)\n                orow += raw_height;\n            }\n          RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n        }\n      }\n#else\n    for (col=0; col < raw_width-2; col+=3) {\n      bits = get4();\n      FORC3 {\n\torow = row;\n\tif ((ocol = col+c-4) < 0) {\n\t  ocol += raw_width;\n\t  if ((orow -= 2) < 0)\n\t    orow += raw_height;\n\t}\n\tRAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress (&cinfo);\n    longjmp (failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n    ((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager {\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit (j_common_ptr cinfo)\n{\n  jpegErrorManager* myerr = (jpegErrorManager*) cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if(data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf,\"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char*) malloc(width*3);\n  jpeg_create_decompress (&cinfo);\n  merror(pixel_buf,\"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf,data_size,1,ifp);\n  swab ((char*)jpg_buf, (char*)jpg_buf, data_size);\n  try\n    {\n      jpeg_mem_src(&cinfo, jpg_buf, data_size);\n      int rc = jpeg_read_header(&cinfo, TRUE);\n      if(rc!=1)\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n      jpeg_start_decompress (&cinfo);\n      if ((cinfo.output_width      != width  ) ||\n          (cinfo.output_height*2   != height ) ||\n          (cinfo.output_components != 3      ))\n        {\n          throw LIBRAW_EXCEPTION_DECODE_JPEG;\n        }\n\n      unsigned char *buf[1];\n      buf[0] = pixel_buf;\n\n      while (cinfo.output_scanline < cinfo.output_height)\n        {\n          checkCancel();\n          row = cinfo.output_scanline * 2;\n          jpeg_read_scanlines (&cinfo, buf, 1);\n          unsigned char (*pixel)[3] = (unsigned char (*)[3]) buf[0];\n          for (col=0; col < width; col+=2) {\n            RAW(row+0,col+0) = pixel[col+0][1] << 1;\n            RAW(row+1,col+1) = pixel[col+1][1] << 1;\n            RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n            RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n          }\n        }\n    }\n  catch (...)\n        {\n          jpeg_finish_decompress (&cinfo);\n          jpeg_destroy_decompress (&cinfo);\n          free(jpg_buf);\n          free(pixel_buf);\n          throw;\n        }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--) {\n      opcode = get4(); get4(); get4();\n      if (opcode != 8)\n      { fseek (ifp, get4(), SEEK_CUR); continue; }\n      fseek (ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2) break;\n      fseek (ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8) break;\n      for (i=0; i <= deg && i < 9; i++)\n\tcoeff[i] = getreal(12);\n      for (i=0; i < 256; i++) {\n\tfor (tot=j=0; j <= deg; j++)\n\t  tot += coeff[j] * pow(i/255.0, (int)j);\n\tcur[c][i] = tot*0xffff;\n      }\n    }\n    order = sorder;\n  } else {\n    gamma_curve (1/2.4, 12.92, 1, 255);\n    FORC3 memcpy (cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    jpeg_destroy_decompress (&cinfo);\n    throw;\n  }\n#endif\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n      {\n\tint idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n\tif(idx >=0 && idx <= 0xffff)\n\t {\n\t   if ((RAW(row,col+i) = curve[idx]) >> 12) derror();\n         }\n\t else\n\t   derror();\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;\n    }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, sum=0;\n\n  huff[0] = 15;\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--; )\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width+1);\n  merror (data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      /* flag checks if outside of loop */\n      if(! (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n         || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n         )\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else pix[i]=0;\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i=0; i < 16; i++, col+=2)\n            {\n              unsigned slope = pix[i] < 1001? 2 : curve[pix[i]<<1]-curve[(pix[i]<<1)-2];\n              unsigned step = 1 << sh;\n              RAW(row,col)=curve[pix[i]<<1]>black+imgdata.params.sony_arw2_posterization_thr?\n                LIM(((slope*step*1000)/(curve[pix[i]<<1]-black)),0,10000):0;\n            }\n        }\n      else\n        {\n          for (i=0; i < 16; i++, col+=2)\n            RAW(row,col) = curve[pix[i] << 1];\n        }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (data);\n    throw;\n  }\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum=10000;\n#endif\n  free (data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, strip_offset+row*4, SEEK_SET);\n    fseek (ifp, data_offset+get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7:4;\n    for (col=0; col < raw_width; col+=16) {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c]) {\n\tcase 3: len[c] = ph1_bits(4);\tbreak;\n\tcase 2: len[c]--;\t\tbreak;\n\tcase 1: len[c]++;\n      }\n      for (c=0; c < 16; c+=2) {\n\ti = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n\tif (c == 14) c = -1;\n      }\n    }\n  }\n  for (row=0; row < raw_height-1; row+=2)\n    for (col=0; col < raw_width-1; col+=2)\n      SWAP (RAW(row,col+1), RAW(row+1,col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] =\n  { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,\n    0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };\n  ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n=i=0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek (ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(),get2());\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0; pmode = 7;\n    FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;\n    prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1));\t// green\n    prow[~row & 1] = &RAW(row-2,0);\t\t\t// red and blue\n    for (tab=0; tab+15 < raw_width; tab+=16) {\n      if (~opt & 4 && !(tab & 63)) {\n\ti = ph1_bits(2);\n\tmag = i < 3 ? mag-'2'+\"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n\tpmode = 7 - 4*ph1_bits(1);\n      else if (!ph1_bits(1))\n\tpmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1)) {\n\tFORC4 len[c] = ph1_bits(2);\n\tFORC4 {\n\t  i = ((row & 1) << 1 | (c & 1)) % 3;\n\t  len[c] = len[c] < 3 ? lent[i][0]-'1'+\"120\"[len[c]] : ph1_bits(4);\n\t  lent[i][0] = lent[i][1];\n\t  lent[i][1] = len[c];\n\t}\n      }\n      FORC(16) {\n\tcol = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));\n\tpred = (pmode == 7 || row < 2)\n\t     ? (tab ? RAW(row,tab-2+(col & 1)) : init)\n\t     : (prow[col & 1][col-'4'+\"0224468\"[pmode]] +\n\t\tprow[col & 1][col-'4'+\"0244668\"[pmode]] + 1) >> 1;\n\tdiff = ph1_bits (i = len[c >> 2]);\n\tif (diff >> (i-1)) diff -= 1 << i;\n\tdiff = diff * (mag*2+1) + mag;\n\tRAW(row,col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width*raw_height)\n       seg[1][0] = raw_width*raw_height;\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n            ((data + (((data & (1 << (nbits-1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(pix>=raw_width*raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar) fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n    {\n      jas_stream_close (in);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n    }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2), (width+2)*2);\n  merror (img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try {\n#endif\n  FORC4 {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    fastexitflag=true;\n  }\n#endif\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\n//@end COMMON\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder (unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code) {\n    for (i=0; i < size; i++)\n      huff[i] = get4();\n    memset (first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode+2048) {\n    fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp (failure, 2);\n  }\n  if (code)\n    for (i=0; i < size; i++)\n      if (huff[i] == code) {\n\tcur->leaf = i;\n\treturn;\n      }\n  if ((len = code >> 27) > 26) return;\n  code = (len+1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder (size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder (size, code+1);\n}\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff (ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i=0; i < 13; i++) {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j=0; j < 256 >> clen; )\n      huff[code+ ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n\t}\n      }\n    }\n  }\n#ifdef DCRAW_VERBOSE\n   else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n#endif\n}\n\nconst char * CLASS foveon_camf_param (const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'P') continue;\n    if (strcmp (block, pos+sget4(pos+12))) continue;\n    cp = pos + sget4(pos+16);\n    num = sget4(cp);\n    dp = pos + sget4(cp+4);\n    while (num--) {\n      cp += 8;\n      if (!strcmp (param, dp+sget4(cp)))\n\treturn dp+sget4(cp+4);\n    }\n  }\n  return 0;\n}\n\nvoid * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'M') continue;\n    if (strcmp (name, pos+sget4(pos+12))) continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos+16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp+4)) > 3) break;\n    dp = pos + sget4(cp+8);\n    for (i=ndim; i--; ) {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;\n    mat = (unsigned *) malloc ((size = dsize) * 4);\n    merror (mat, \"foveon_camf_matrix()\");\n    for (i=0; i < size; i++)\n      if (type && type != 6)\n\tmat[i] = sget4(dp + i*4);\n      else\n\tmat[i] = sget4(dp + i*2) & 0xffff;\n    return mat;\n  }\n#ifdef DCRAW_VERBOSE\n  fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n#endif\n  return 0;\n}\n\nint CLASS foveon_fixed (void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name) return 0;\n  dp = foveon_camf_matrix (dim, name);\n  if (!dp) return 0;\n  memcpy (ptr, dp, size*4);\n  free (dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg (short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;\n\n  for (i=range[0]; i <= range[1]; i++) {\n    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\n    if (min > val) min = val;\n    if (max < val) max = val;\n  }\n  if (range[1] - range[0] == 1) return sum/2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort * CLASS foveon_make_curve (double max, double mul, double filt)\n{\n  short *curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt) filt = 0.8;\n  size = 4*M_PI*max / filt;\n  if (size == UINT_MAX) size--;\n  curve = (short *) calloc (size+1, sizeof *curve);\n  merror (curve, \"foveon_make_curve()\");\n  curve[0] = size;\n  for (i=0; i < size; i++) {\n    x = i*filt/max/4;\n    curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;\n  }\n  return curve;\n}\n\nvoid CLASS foveon_make_curves\n\t(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max=0;\n  int c;\n\n  FORC3 mul[c] = dq[c]/div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve (short *curve, int i)\n{\n  if (abs(i) >= curve[0]) return 0;\n  return i < 0 ? -curve[1-i] : curve[1+i];\n}\n\n#define image ((short (*)[4]) image)\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\n  short *pix, prev[3], *curve[8], (*shrink)[3];\n  float cfilt=0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float (*black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p=0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum=0, trsum[3];\n  char str[128];\n  const char* cp;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Foveon interpolation...\\n\"));\n#endif\n\n  foveon_load_camf();\n  foveon_fixed (dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed (satlev, 3, \"SaturationLevel\");\n  foveon_fixed (keep, 4, \"KeepImageArea\");\n  foveon_fixed (active, 4, \"ActiveImageArea\");\n  foveon_fixed (chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed (color_dq, 3,\n\tfoveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))\n\t\t foveon_fixed (&cfilt, 1, \"ColumnFilter\");\n\n  memset (ddft, 0, sizeof ddft);\n  if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")\n\t || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))\n    for (i=0; i < 2; i++) {\n      foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n\tfor (col = dstb[0]; col <= dstb[2]; col++)\n\t  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];\n      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\n    }\n\n  if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n#endif\n    return; }\n  foveon_fixed (cam_xyz, 9, cp);\n  foveon_fixed (correct, 9,\n\tfoveon_camf_param (\"WhiteBalanceCorrections\", model2));\n  memset (last, 0, sizeof last);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n  #define LAST(x,y) last[(i+x)%3][(c+y)%3]\n  for (i=0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\n  #undef LAST\n  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;\n  sprintf (str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param (\"IncludeBlocks\", str))\n    foveon_fixed (div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\n  for (i=0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves (curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves (curve+3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  curve[6] = foveon_make_curve (dsum, dsum, cfilt);\n  curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);\n\n  sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");\n  if (!sgain) return;\n  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\n  sgx = (width + dim[1]-2) / (dim[1]-1);\n\n  black = (float (*)[3]) calloc (height, sizeof *black);\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +\n\trow / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    FORC3 black[row][c] =\n\t( foveon_avg (image[row*width]+c, dscr[0], cfilt) +\n\t  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3\n\t  - ddft[0][c][0] ) / 4 - ddft[0][c][1];\n  }\n  memcpy (black, black+8, sizeof *black*8);\n  memcpy (black+height-11, black+height-22, 11*sizeof *black);\n  memcpy (last, black, sizeof last);\n\n  for (row=1; row < height-1; row++) {\n    FORC3 if (last[1][c] > last[0][c]) {\n\tif (last[1][c] > last[2][c])\n\t  black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\n      } else\n\tif (last[1][c] < last[2][c])\n\t  black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\n    memmove (last, last+1, 2*sizeof last[0]);\n    memcpy (last[2], black[row+1], sizeof last[2]);\n  }\n  FORC3 black[row][c] = (last[0][c] + last[1][c])/2;\n  FORC3 black[0][c] = (black[1][c] + black[3][c])/2;\n\n  val = 1 - exp(-1/24.0);\n  memcpy (fsum, black, sizeof fsum);\n  for (row=1; row < height; row++)\n    FORC3 fsum[c] += black[row][c] =\n\t(black[row][c] - black[row-1][c])*val + black[row-1][c];\n  memcpy (last[0], black[height-1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--; )\n    FORC3 last[0][c] = black[row][c] =\n\t(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\n\n  memset (total, 0, sizeof total);\n  for (row=2; row < height; row+=4)\n    for (col=2; col < width; col+=4) {\n      FORC3 total[c] += (short) image[row*width+col][c];\n      total[3]++;\n    }\n  for (row=0; row < height; row++)\n    FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);\n\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +\n\trow / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    pix = image[row*width];\n    memcpy (prev, pix, sizeof prev);\n    frow = row / (height-1.0) * (dim[2]-1);\n    if ((irow = frow) == dim[2]-1) irow--;\n    frow -= irow;\n    for (i=0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\n\t\t\t  sgain[(irow+1)*dim[1]+i][c] *    frow;\n    for (col=0; col < width; col++) {\n      FORC3 {\n\tdiff = pix[c] - prev[c];\n\tprev[c] = pix[c];\n\tipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\n\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)\n\t\t- black[row][c] );\n      }\n      FORC3 {\n\twork[0][c] = ipix[c] * ipix[c] >> 14;\n\twork[2][c] = ipix[c] * work[0][c] >> 14;\n\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\n      }\n      FORC3 {\n\tfor (val=i=0; i < 3; i++)\n\t  for (  j=0; j < 3; j++)\n\t    val += ppm[c][i][j] * work[i][j];\n\tipix[c] = floor ((ipix[c] + floor(val)) *\n\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\n\t\t  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);\n\tif (ipix[c] > 32000) ipix[c] = 32000;\n\tpix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free (black);\n  free (sgrow);\n  free (sgain);\n\n  if ((badpix = (unsigned *) foveon_camf_matrix (dim, \"BadPixels\"))) {\n    for (i=0; i < dim[0]; i++) {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20       ) - keep[1];\n      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)\n\tcontinue;\n      memset (fsum, 0, sizeof fsum);\n      for (sum=j=0; j < 8; j++)\n\tif (badpix[i] & (1 << j)) {\n\t  FORC3 fsum[c] += (short)\n\t\timage[(row+hood[j*2])*width+col+hood[j*2+1]][c];\n\t  sum++;\n\t}\n      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;\n    }\n    free (badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);\n  merror (smrow[6], \"foveon_interpolate()\");\n  for (i=0; i < 5; i++)\n    smrow[i] = smrow[6] + i*width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tsmrow[4][col][0] =\n\t  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      smred = ( 6 *  smrow[2][col][0]\n\t      + 4 * (smrow[1][col][0] + smrow[3][col][0])\n\t      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\n      if (col == 2)\n\tsmred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\n      if (i > 32000) i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3 {\n    i = satlev[c] / div[c];\n    if (min > i) min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c=1; c < 3; c++) {\n      if (min > pix[c]) min = pix[c];\n      if (max < pix[c]) max = pix[c];\n    }\n    if (min >= limit*2) {\n      pix[0] = pix[1] = pix[2] = max;\n    } else {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i*i >> 14);\n      i = i*i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n/*\n   Because photons that miss one detector often hit another,\n   the sum R+G+B is much less noisy than the individual colors.\n   So smooth the hues without smoothing the total.\n */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -\n\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] =\n\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      for (total[3]=375, sum=60, c=0; c < 3; c++) {\n\tfor (total[c]=i=0; i < 5; i++)\n\t  total[c] += smrow[i][col][c];\n\ttotal[3] += total[c];\n\tsum += pix[c];\n      }\n      if (sum < 0) sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve (curve[6],\n\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);\n    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);\n    FORC3 {\n      for (dsum=i=0; i < 3; i++)\n\tdsum += trans[c][i] * pix[i];\n      if (dsum < 0)  dsum = 0;\n      if (dsum > 24000) dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  shrink = (short (*)[3]) calloc ((height/4), (width/4)*sizeof *shrink);\n  merror (shrink, \"foveon_interpolate()\");\n  for (row = height/4; row--; )\n    for (col=0; col < width/4; col++) {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i=0; i < 4; i++)\n\tfor (j=0; j < 4; j++)\n\t  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];\n      FORC3\n\tif (row+2 > height/4)\n\t  shrink[row*(width/4)+col][c] = ipix[c] >> 4;\n\telse\n\t  shrink[row*(width/4)+col][c] =\n\t    (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row=0; row < (height & ~3); row++) {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3 ; col--; )\n\tFORC3 smrow[0][col][c] = ipix[c] =\n\t  (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col=0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] =\n\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy (smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col=0; col < (width & ~3); col++)\n\tFORC3 smrow[2][col][c] =\n\t  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\n\n  /* Adjust the chroma toward the smooth values */\n    for (col=0; col < (width & ~3); col++) {\n      for (i=j=30, c=0; c < 3; c++) {\n\ti += smrow[2][col][c];\n\tj += image[row*width+col][c];\n      }\n      j = (j << 16) / i;\n      for (sum=c=0; c < 3; c++) {\n\tipix[c] = foveon_apply_curve (curve[c+3],\n\t  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);\n\tsum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3 {\n\ti = image[row*width+col][c] + ipix[c] - sum;\n\tif (i < 0) i = 0;\n\timage[row*width+col][c] = i;\n      }\n    }\n  }\n  free (shrink);\n  free (smrow[6]);\n  for (i=0; i < 8; i++)\n    free (curve[i]);\n\n  /* Trim off the black border */\n  active[1] -= keep[1];\n  active[3] -= 2;\n  i = active[2] - active[0];\n  for (row=0; row < active[3]-active[1]; row++)\n    memcpy (image[row*i], image[(row+active[1])*width+active[0]],\n\t i * sizeof *image);\n  width = i;\n  height = row;\n}\n#undef image\n\n/* RESTRICTED code ends here */\n\n//@out COMMON\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n    c, m, mblack[8], zero, val;\n#else\n    c, m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3] > 0) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)\n      for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n//@end COMMON\n\n/* @out FILEIO\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end FILEIO */\n\n\n// @out FILEIO\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n// @end FILEIO\n  else {\n    for (len=32 ; ; len *= 2) {\n      fname = (char *) malloc (len);\n      if (!fname) return;\n      if (getcwd (fname, len-16)) break;\n      free (fname);\n      if (errno != ERANGE) return;\n    }\n#if defined(WIN32) || defined(DJGPP)\n    if (fname[1] == ':')\n      memmove (fname, fname+2, len-2);\n    for (cp=fname; *cp; cp++)\n      if (*cp == '\\\\') *cp = '/';\n#endif\n    cp = fname + strlen(fname);\n    if (cp[-1] == '/') cp--;\n    while (*fname == '/') {\n      strcpy (cp, \"/.badpixels\");\n      if ((fp = fopen (fname, \"r\"))) break;\n      if (cp == fname) break;\n      while (*--cp != '/');\n    }\n    free (fname);\n  }\n// @out FILEIO\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}\n\nvoid CLASS subtract (const char *fname)\n{\n  FILE *fp;\n  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,0,2);\n#endif\n\n  if (!(fp = fopen (fname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n    perror (fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\n    if (c == '#')  comment = 1;\n    if (c == '\\n') comment = 0;\n    if (comment) continue;\n    if (isdigit(c)) number = 1;\n    if (number) {\n      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\n      else if (isspace(c)) {\n\tnumber = 0;  nd++;\n      } else error = 1;\n    }\n  }\n  if (error || nd < 3) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose (fp);  return;\n  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {\n#ifdef DCRAW_VERBOSE\n      fprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose (fp);  return;\n  }\n  pixel = (ushort *) calloc (width, sizeof *pixel);\n  merror (pixel, \"subtract()\");\n  for (row=0; row < height; row++) {\n    fread (pixel, 2, width, fp);\n    for (col=0; col < width; col++)\n      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\n  }\n  free (pixel);\n  fclose (fp);\n  memset (cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n#endif\n}\n//@end FILEIO\n\n//@out COMMON\n\nstatic const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if(num > 0.00001)\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] /= num;\n        pre_mul[i] = 1 / num;\n      }\n    else\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] = 0.0;\n        pre_mul[i] = 1.0;\n      }\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER2(row,col);\n\tBAYER2(row,col) = black + (BAYER2(row,col)-black)/2;\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (pass=0; pass < 2; pass++) {\n    for (raw_color = i=0; i < colors; i++)\n      for (j=0; j < 3; j++)\n\tfor (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\t  cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff (rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq=0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)\n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(load_raw == &LibRaw::nikon_load_sraw)\n      {\n        // Nikon sRAW: camera WB already applied:\n        pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;\n      }\n    else\n#endif\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw\n      && !use_camera_wb && !use_auto_wb\n      && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )\n    {\n      for(c=0;c<3;c++)\n        pre_mul[c]/=cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0) pre_mul[1] = 1;\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {\n    FORC4 cblack[FC(c/2,c%2)] +=\n\tcblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    if (!(val = ((ushort *)image)[i])) continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +\n\t\t\ti/4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n      if (filters == 9) {\n\tfor (row=0; row < 3; row++)\n\t  for (col=1; col < 4; col++)\n\t    if (!(image[row*width+col][0] | image[row*width+col][2]))\n\t      goto break2;  break2:\n\tfor ( ; row < height; row+=3)\n\t  for (col=(col-1)%3+1; col < width-1; col+=3) {\n\t    img = image + row*width+col;\n\t    for (c=0; c < 3; c+=2)\n\t      img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n\t  }\n      }\n    } else {\n      img = (ushort (*)[4]) calloc (height, width*sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size) colors++;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 9) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = sum[c]>0?256 / sum[c]:0;\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,-128, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,-120, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,-128, +0,-1,+0,+1,1,-120, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,-128,\n    +1,-1,+1,+1,0,-120, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 9) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab (ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb) {\n#ifndef LIBRAW_NOTHREADS\n    if(cbrt[0] < -1.0f)\n#endif\n    for (i=0; i < 0x10000; i++) {\n      r = i / 65535.0;\n      cbrt[i] = r > 0.008856 ? pow(r,1.f/3.0f) : 7.787f*r + 16.f/116.0f;\n    }\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (xyz_cam[i][j] = k=0; k < 3; k++)\n\t  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int) xyz[0])];\n  xyz[1] = cbrt[CLIP((int) xyz[1])];\n  xyz[2] = cbrt[CLIP((int) xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512\t\t/* Tile Size */\n#define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate (int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int cstat[4]={0,0,0,0};\n#endif\n\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },\n\tpatt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },\n\t\t\t{ 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },\n\tdir[4] = { 1,TS,TS+1,TS-1 };\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)    [TS][3], (*lix)[3];\n   float (*drv)[TS][TS], diff[6], tr;\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/* Check against right pattern */\n  for (row = 0; row < 6; row++)\n         for (col = 0; col < 6; col++)\n                 cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16 \n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n         throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n\n  cielab (0,0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *) malloc (TS*TS*(ndir*11+6));\n  merror (buffer, \"xtrans_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));\n  drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));\n  homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));\n\n/* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row=0; row < 3; row++)\n    for (col=0; col < 3; col++)\n      for (ng=d=0; d < 10; d+=2) {\n\tg = fcol(row,col) == 1;\n\tif (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;\n\tif (ng == 4) { sgrow = row; sgcol = col; }\n\tif (ng == g+1) FORC(8) {\n\t  v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];\n\t  h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];\n\t  allhex[row][col][0][c^(g*2 & d)] = h + v*width;\n\t  allhex[row][col][1][c^(g*2 & d)] = h + v*TS;\n\t}\n      }\n\n/* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row=2; row < height-2; row++)\n    for (min=~(max=0), col=2; col < width-2; col++) {\n      if (fcol(row,col) == 1 && (min=~(max=0))) continue;\n      pix = image + row*width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max) FORC(6) {\n\tval = pix[hex[c]][1];\n\tif (min > val) min = val;\n\tif (max < val) max = val;\n      }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row-sgrow) % 3) {\n\tcase 1: if (row < height-3) { row++; col--; } break;\n\tcase 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;\n      }\n    }\n\n  for (top=3; top < height-19; top += TS-16)\n    for (left=3; left < width-19; left += TS-16) {\n      mrow = MIN (top+TS, height-3);\n      mcol = MIN (left+TS, width-3);\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++)\n\t  memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);\n      FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);\n\n/* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++) {\n\t  if ((f = fcol(row,col)) == 1) continue;\n\t  pix = image + row*width + col;\n\t  hex = allhex[row % 3][col % 3][0];\n\t  color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -\n\t\t\t 46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);\n\t  color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +\n\t\t\t 92 * (pix[      0 ][f] - pix[ -hex[2]][f]);\n\t  FORC(2) color[1][2+c] =\n\t\t164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *\n\t\t(2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);\n\t  FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =\n\t\tLIM(color[1][c] >> 8,pix[0][1],pix[0][3]);\n\t}\n\n      for (pass=0; pass < passes; pass++) {\n\tif (pass == 1)\n\t  memcpy (rgb+=4, buffer, 4*sizeof *rgb);\n\n/* Recalculate green from interpolated values of closer pixels:\t*/\n\tif (pass) {\n\t  for (row=top+2; row < mrow-2; row++)\n\t    for (col=left+2; col < mcol-2; col++) {\n\t      if ((f = fcol(row,col)) == 1) continue;\n\t      pix = image + row*width + col;\n\t      hex = allhex[row % 3][col % 3][1];\n\t      for (d=3; d < 6; d++) {\n\t\trix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];\n\t\tval = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]\n\t\t    - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];\n\t\trix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);\n\t      }\n\t    }\n\t}\n\n/* Interpolate red and blue values for solitary green pixels:\t*/\n\tfor (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)\n\t  for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    h = fcol(row,col+1);\n\t    memset (diff, 0, sizeof diff);\n\t    for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {\n\t      for (c=0; c < 2; c++, h^=2) {\n\t\tg = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];\n\t\tcolor[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];\n\t\tif (d > 1)\n\t\t  diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]\n\t\t\t\t- rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);\n\t      }\n\t      if (d > 1 && (d & 1))\n\t\tif (diff[d-1] < diff[d])\n\t\t  FORC(2) color[c*2][d] = color[c*2][d-1];\n\t      if (d < 2 || (d & 1)) {\n\t\tFORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);\n\t\trix += TS*TS;\n\t      }\n\t    }\n\t  }\n\n/* Interpolate red for blue pixels and vice versa:\t\t*/\n\tfor (row=top+3; row < mrow-3; row++)\n\t  for (col=left+3; col < mcol-3; col++) {\n\t    if ((f = 2-fcol(row,col)) == 1) continue;\n\t    rix = &rgb[0][row-top][col-left];\n\t    c = (row-sgrow) % 3 ? TS:1;\n\t    h = 3 * (c ^ TS ^ 1);\n\t    for (d=0; d < 4; d++, rix += TS*TS) {\n\t      i = d > 1 || ((d ^ c) & 1) ||\n\t\t ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <\n\t\t2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;\n\t      rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +\n\t\t  2*rix[0][1] - rix[i][1] - rix[-i][1])/2);\n\t    }\n\t  }\n\n/* Fill in red and blue for 2x2 blocks of green:\t\t*/\n\tfor (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)\n\t  for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    hex = allhex[row % 3][col % 3][1];\n\t    for (d=0; d < ndir; d+=2, rix += TS*TS)\n\t      if (hex[d] + hex[d+1]) {\n\t\tg = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);\n\t      } else {\n\t\tg = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);\n\t      }\n\t  }\n      }\n      rgb = (ushort(*)[TS][TS][3]) buffer;\n      mrow -= top;\n      mcol -= left;\n\n/* Convert to CIELab and differentiate in all directions:\t*/\n      for (d=0; d < ndir; d++) {\n\tfor (row=2; row < mrow-2; row++)\n\t  for (col=2; col < mcol-2; col++)\n\t    cielab (rgb[d][row][col], lab[row][col]);\n\tfor (f=dir[d & 3],row=3; row < mrow-3; row++)\n\t  for (col=3; col < mcol-3; col++) {\n\t    lix = &lab[row][col];\n\t    g = 2*lix[0][0] - lix[f][0] - lix[-f][0];\n\t    drv[d][row][col] = SQR(g)\n\t      + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))\n\t      + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));\n\t  }\n      }\n\n/* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir*TS*TS);\n      for (row=4; row < mrow-4; row++)\n\tfor (col=4; col < mcol-4; col++) {\n\t  for (tr=FLT_MAX, d=0; d < ndir; d++)\n\t    if (tr > drv[d][row][col])\n\t\ttr = drv[d][row][col];\n\t  tr *= 8;\n\t  for (d=0; d < ndir; d++)\n\t    for (v=-1; v <= 1; v++)\n\t      for (h=-1; h <= 1; h++)\n\t\tif (drv[d][row+v][col+h] <= tr)\n\t\t  homo[d][row][col]++;\n\t}\n\n/* Average the most homogenous pixels for the final result:\t*/\n      if (height-top < TS+4) mrow = height-top+2;\n      if (width-left < TS+4) mcol = width-left+2;\n      for (row = MIN(top,8); row < mrow-8; row++)\n\tfor (col = MIN(left,8); col < mcol-8; col++) {\n\t  for (d=0; d < ndir; d++)\n\t    for (hm[d]=0, v=-2; v <= 2; v++)\n\t      for (h=-2; h <= 2; h++)\n\t\thm[d] += homo[d][row+v][col+h];\n\t  for (d=0; d < ndir-4; d++)\n\t    if (hm[d] < hm[d+4]) hm[d  ] = 0; else\n\t    if (hm[d] > hm[d+4]) hm[d+4] = 0;\n\t  for (max=hm[0],d=1; d < ndir; d++)\n\t    if (max < hm[d]) max = hm[d];\n\t  max -= max >> 3;\n\t  memset (avg, 0, sizeof avg);\n\t  for (d=0; d < ndir; d++)\n\t    if (hm[d] >= max) {\n\t      FORC3 avg[c] += rgb[d][row][col][c];\n\t      avg[3]++;\n\t    }\n\t  FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];\n\t}\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0],lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n\n  cielab(0,0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {\n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab (0,0);\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row=top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    cielab (rix[0],lix[0]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high, wide*sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nint CLASS parse_tiff_ifd (int base);\n\n//@out COMMON\n\nstatic float powf_lim(float a, float b, float limup)\n{\n  return (b>limup || b < -limup)?0.f:powf(a,b);\n}\nstatic float powf64(float a, float b)\n{\n  return powf_lim(a,b,64.f);\n}\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x) {\n  float t;\n  if (x >= 0.0) {\n    t = ceilf(x);\n    if (t - x > 0.5) t -= 1.0;\n    return t;\n  } else {\n    t = ceilf(-x);\n    if (t + x > 0.5) t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff)) return 0.0f;\n  return powf64(2.0, in/64.0);\n}\n\nstatic float _CanonConvertEV (short in)\n{\n\tshort EV, Sign, Frac;\n\tfloat Frac_f;\n\tEV = in;\n\tif (EV < 0) {\n\t  EV = -EV;\n\t  Sign = -1;\n\t} else {\n\t  Sign = 1;\n\t}\n\tFrac = EV & 0x1f;\n\tEV -= Frac;\t\t\t// remove fraction\n\n\tif (Frac == 0x0c) {\t\t// convert 1/3 and 2/3 codes\n\t  Frac_f = 32.0f / 3.0f;\n\t} else if (Frac == 0x14) {\n\t  Frac_f = 64.0f / 3.0f;\n\t} else Frac_f = (float) Frac;\n\n\treturn ((float)Sign * ((float)EV + Frac_f))/32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures (unsigned id)\n      {\n      imgdata.lens.makernotes.CamID = id;\n\tif (\n            (id == 0x80000001) ||\t// 1D\n            (id == 0x80000174) ||\t// 1D2\n            (id == 0x80000232) ||\t// 1D2N\n            (id == 0x80000169) ||\t// 1D3\n            (id == 0x80000281)\t\t// 1D4\n            )\n          {\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n          }\n        else\n          if (\n              (id == 0x80000167) ||\t// 1Ds\n              (id == 0x80000188) ||\t// 1Ds2\n              (id == 0x80000215) ||\t// 1Ds3\n              (id == 0x80000269) ||\t// 1DX\n              (id == 0x80000328) ||\t// 1DX2\n              (id == 0x80000324) ||\t// 1DC\n              (id == 0x80000213) ||\t// 5D\n              (id == 0x80000218) ||\t// 5D2\n              (id == 0x80000285) ||\t// 5D3\n              (id == 0x80000349) ||\t// 5D4\n              (id == 0x80000382) ||\t// 5DS\n              (id == 0x80000401) ||\t// 5DS R\n              (id == 0x80000302) \t// 6D\n              )\n            {\n              imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n            }\n          else\n            if (\n                (id == 0x80000331) ||\t// M\n                (id == 0x80000355) ||\t// M2\n                (id == 0x80000374) || \t// M3\n                (id == 0x80000384) || \t// M10\n                (id == 0x80000394)  \t// M5\n                )\n              {\n                imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n              }\n            else\n              if (\n                  (id == 0x01140000) ||\t// D30\n                  (id == 0x01668000) ||\t// D60\n                  (id > 0x80000000)\n                  )\n                {\n                  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n                }\n              else\n                {\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                }\n\n\treturn;\n      }\n\nvoid CLASS processCanonCameraInfo (unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0;\n  if(maxlen<16) return; // too short, so broken\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id) {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal  = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12)) iCanonLensID = 151;\n    else iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n    {\n      if(iCanonFocalType>=maxlen) return; // broken;\n      imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n      if (!imgdata.lens.makernotes.FocalType)\t// zero means 'fixed' here, replacing with standard '1'\n        imgdata.lens.makernotes.FocalType = 1;\n    }\n  if (!imgdata.lens.makernotes.CurFocal)\n    {\n      if(iCanonCurFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n    }\n  if (!imgdata.lens.makernotes.LensID)\n    {\n      if(iCanonLensID>=maxlen) return; // broken;\n      imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n    }\n  if (!imgdata.lens.makernotes.MinFocal)\n    {\n      if(iCanonMinFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n    }\n  if (!imgdata.lens.makernotes.MaxFocal)\n    {\n      if(iCanonMaxFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n    }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens) {\n    if(iCanonLens+64>=maxlen) return; // broken;\n    if (CameraInfo[iCanonLens] < 65)\t\t\t\t\t\t\t\t// non-Canon lens\n      {\n        memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n      }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n      {\n        memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n        memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n        memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings ()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2(); get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2(); get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2(); get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets (int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2) fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets (short WBCTversion)\n{\n\tif (WBCTversion == 0)\n\t  for (int i=0; i<15; i++)// tint, as shot R, as shot B, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if (WBCTversion == 1)\n\t  for (int i=0; i<15; i++)\t// as shot R, as shot B, tint, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n\t\t((unique_id == 0x80000374) ||\t// M3\n\t\t (unique_id == 0x80000384) ||\t// M10\n\t\t (unique_id == 0x80000394) ||\t// M5\n\t\t (unique_id == 0x03970000)))\t// G7 X Mark II\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n                ((unique_id == 0x03950000) || (unique_id == 0x03930000)))\t// G5 X, G9 X\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\treturn;\n}\n\nvoid CLASS processNikonLensData (uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n  else\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n    {\n      if (imgdata.lens.nikon.NikonLensType & 0x04)\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n      else\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n      imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n    {\n      imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n      imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20) {\n    switch (len) {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n      {\n        if ((LensData[i - 1]) &&\n            (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n          imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n        if (LensData[i + 7]) imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n      }\n    imgdata.lens.makernotes.LensID =\n      (unsigned long long) LensData[i] << 56 |\n      (unsigned long long) LensData[i + 1] << 48 |\n      (unsigned long long) LensData[i + 2] << 40 |\n      (unsigned long long) LensData[i + 3] << 32 |\n      (unsigned long long) LensData[i + 4] << 24 |\n      (unsigned long long) LensData[i + 5] << 16 |\n      (unsigned long long) LensData[i + 6] << 8 |\n      (unsigned long long) imgdata.lens.nikon.NikonLensType;\n\n  }\n  else if ((len == 459) || (len == 590))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n    }\n  else if (len == 509)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n    }\n  else if (len == 879)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n    }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures (unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) ||\t// E-1\n      (id == 0x4434303431ULL) ||\t// E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n\t  if ((id == 0x4434303430ULL) ||\t// E-1\n      \t  (id == 0x4434303431ULL) ||\t// E-330\n      \t  ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n      \t  (id == 0x5330303233ULL) ||\t// E-620\n      \t  (id == 0x5330303239ULL) ||\t// E-450\n      \t  (id == 0x5330303330ULL) ||\t// E-600\n      \t  (id == 0x5330303333ULL))\t\t// E-5\n      {\n      \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n      }\n  \telse\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n      }\n  }\n  else\n  {\n      imgdata.lens.makernotes.LensMount =\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes (unsigned tag, unsigned type, unsigned len) {\n\nif (tag == 0x0001) Canon_CameraSettings();\n        else if (tag == 0x0002)\t\t\t// focal length\n          {\n            imgdata.lens.makernotes.FocalType = get2();\n            imgdata.lens.makernotes.CurFocal = get2();\n            if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n              {\n                imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n              }\n          }\n\n        else if (tag == 0x0004)\t\t\t// shot info\n          {\n            short tempAp;\n            fseek(ifp, 30, SEEK_CUR);\n            imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n            fseek(ifp, 8-32, SEEK_CUR);\n            if ((tempAp = get2()) != 0x7fff)\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n            if (imgdata.lens.makernotes.CurAp < 0.7f)\n            {\n              fseek(ifp, 32, SEEK_CUR);\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n            }\n            if (!aperture) aperture = imgdata.lens.makernotes.CurAp;\n          }\n\n        else if (tag == 0x0095 &&\t\t// lens model tag\n                 !imgdata.lens.makernotes.Lens[0])\n          {\n            fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            if (imgdata.lens.makernotes.Lens[0] < 65)\t\t\t\t\t// non-Canon lens\n              fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n            else\n              {\n                char efs[2];\n                imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n                imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n                fread(efs, 2, 1, ifp);\n                if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n                  {\t// \"EF-S, TS-E, MP-E, EF-M\" lenses\n                    imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n                    imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n                    imgdata.lens.makernotes.Lens[4] = 32;\n                    if (efs[1] == 83)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n                        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n                      }\n                    else if (efs[1] == 77)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n                      }\n                  }\n                else\n                  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \"EF\" lenses\n                    imgdata.lens.makernotes.Lens[2] = 32;\n                    imgdata.lens.makernotes.Lens[3] = efs[0];\n                    imgdata.lens.makernotes.Lens[4] = efs[1];\n                  }\n                fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n              }\n          }\n\n        else if (tag == 0x00a9)\n          {\n            long int save1 = ftell(ifp);\n            fseek (ifp, save1+(0x5<<1), SEEK_SET);\n            Canon_WBpresets(0,0);\n            fseek (ifp, save1, SEEK_SET);\n          }\n\n        else if (tag == 0x00e0)\t\t\t// sensor info\n          {\n            imgdata.makernotes.canon.SensorWidth           = (get2(),get2());\n            imgdata.makernotes.canon.SensorHeight          = get2();\n            imgdata.makernotes.canon.SensorLeftBorder      = (get2(),get2(),get2());\n            imgdata.makernotes.canon.SensorTopBorder       = get2();\n            imgdata.makernotes.canon.SensorRightBorder     = get2();\n            imgdata.makernotes.canon.SensorBottomBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskLeftBorder   = get2();\n            imgdata.makernotes.canon.BlackMaskTopBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskRightBorder  = get2();\n            imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n          }\n\n    else if (tag == 0x4001 && len > 500)\n      {\n        int c;\n        long int save1 = ftell(ifp);\n        switch (len)\n          {\n          case 582:\n            imgdata.makernotes.canon.CanonColorDataVer = 1;\t// 20D / 350D\n            {\n            \tfseek (ifp, save1+(0x23<<1), SEEK_SET);\n            \tCanon_WBpresets(2,2);\n            \tfseek (ifp, save1+(0x4b<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 653:\n            imgdata.makernotes.canon.CanonColorDataVer = 2;\t// 1Dmk2 / 1DsMK2\n            {\n            \tfseek (ifp, save1+(0x27<<1), SEEK_SET);\n            \tCanon_WBpresets(2,12);\n            \tfseek (ifp, save1+(0xa4<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 796:\n            imgdata.makernotes.canon.CanonColorDataVer = 3;\t// 1DmkIIN / 5D / 30D / 400D\n\t    imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n\t    {\n\t      fseek (ifp, save1+(0x4e<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0x85<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n\t      fseek (ifp, save1+(0x0c4<<1), SEEK_SET); // offset 196 short\n\t      int bls=0;\n\t      FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n\t      imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n\t    }\n\t    break;\n            // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n            // 7D / 40D / 50D / 60D / 450D / 500D\n            // 550D / 1000D / 1100D\n          case 674: case 692: case 702: case 1227: case 1250:\n          case 1251: case 1337: case 1338: case 1346:\n            imgdata.makernotes.canon.CanonColorDataVer = 4;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n\t      fseek (ifp, save1+(0x53<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0xa8<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0e7<<1), SEEK_SET); // offset 231 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4)\n                || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n              {\n                fseek (ifp, save1+(0x2b9<<1), SEEK_SET);\t\t// offset 697 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n                     (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n              {\n                fseek (ifp, save1+(0x2d0<<1), SEEK_SET);\t\t// offset 720 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n              {\n                fseek (ifp, save1+(0x2d4<<1), SEEK_SET);\t\t// offset 724 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n          case 5120:\n            imgdata.makernotes.canon.CanonColorDataVer = 5;\t// PowerSot G10, G12, G5 X, EOS M3, EOS M5\n            {\n              fseek (ifp, save1+(0x56<<1), SEEK_SET);\n              if ((unique_id == 0x03970000) || // G7 X Mark II\n                  (unique_id == 0x80000394))   // EOS M5\n              {\n                fseek(ifp, 18, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                fseek(ifp, 8, SEEK_CUR);\n                Canon_WBpresets(8,24);\n                fseek(ifp, 168, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n                fseek(ifp, 24, SEEK_CUR);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek(ifp, 6, SEEK_CUR);\n              }\n              else\n              {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                get2();\n                Canon_WBpresets(2,12);\n                fseek (ifp, save1+(0xba<<1), SEEK_SET);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek (ifp, save1+(0x108<<1), SEEK_SET);  // offset 264 short\n              }\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            break;\n\n          case 1273: case 1275:\n            imgdata.makernotes.canon.CanonColorDataVer = 6;\t// 600D / 1200D\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x67<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xbc<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0fb<<1), SEEK_SET);\t\t\t// offset 251 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            fseek (ifp, save1+(0x1e4<<1), SEEK_SET);\t\t\t// offset 484 shorts\n            imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n            FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n            break;\n\n            // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n          case 1312: case 1313: case 1316: case 1506:\n            imgdata.makernotes.canon.CanonColorDataVer = 7;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x80<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xd5<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x114<<1), SEEK_SET);\t\t\t// offset 276 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n              {\n                fseek (ifp, save1+(0x1fd<<1), SEEK_SET);\t\t// offset 509 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              } else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n              {\n                fseek (ifp, save1+(0x2dd<<1), SEEK_SET);\t\t// offset 733 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n            // 5DS / 5DS R / 80D / 1300D / 5D4\n          case 1560: case 1592: case 1353:\n            imgdata.makernotes.canon.CanonColorDataVer = 8;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x85<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0x107<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x146<<1), SEEK_SET);\t\t\t// offset 326 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n              if (imgdata.makernotes.canon.CanonColorDataSubVer == 14)  // 1300D\n                {\n                  fseek (ifp, save1+(0x231<<1), SEEK_SET);\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n              else\n                {\n                  fseek (ifp, save1+(0x30f<<1), SEEK_SET);\t\t// offset 783 shorts\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n            break;\n\n          }\n        fseek (ifp, save1, SEEK_SET);\n      }\n}\n\nvoid CLASS setPentaxBodyFeatures (unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id) {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO (ushort c)\n{\n  int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};\n  double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};\n#define numel (sizeof(code)/sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++) {\n    if (code[i] == c) {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel) iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo (unsigned id, unsigned len)\t// tag 0x0207\n{\n\tushort iLensData = 0;\n\tuchar *table_buf;\n\ttable_buf = (uchar*)malloc(MAX(len,128));\n\tfread(table_buf, len, 1, ifp);\n\tif ((id < 0x12b9c)  ||\n        (((id == 0x12b9c)   ||  // K100D\n          (id == 0x12b9d)   ||  // K110D\n          (id == 0x12ba2)) &&   // K100D Super\n\t\t ((!table_buf[20] ||\n\t\t  (table_buf[20] == 0xff)))))\n\t  {\n\t\tiLensData = 3;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t(((unsigned)table_buf[0]) << 8) + table_buf[1];\n\t  }\n\telse switch (len)\n\t  {\n\t  case 90:\t\t\t\t\t\t\t// LensInfo3\n\t\tiLensData = 13;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 91:\t\t\t\t\t\t\t// LensInfo4\n\t\tiLensData = 12;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 80:\t\t\t\t\t\t\t// LensInfo5\n\t  case 128:\n\t\tiLensData = 15;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) <<8) + table_buf[5];\n\t\tbreak;\n\t  default:\n\t\tif (id >= 0x12b9c)\t\t\t\t// LensInfo2\n\t\t  {\n\t\t\tiLensData = 4;\n\t\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t\t((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) <<8) + table_buf[3];\n\t\t  }\n\t  }\n\tif (iLensData)\n\t  {\n\t\tif (table_buf[iLensData+9] &&\n\t\t\t(fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n\t\t  imgdata.lens.makernotes.CurFocal =\n\t\t\t10*(table_buf[iLensData+9]>>2) * powf64(4, (table_buf[iLensData+9] & 0x03)-2);\n\t\tif (table_buf[iLensData+10] & 0xf0)\n\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0xf0) >>4)/4.0f);\n\t\tif (table_buf[iLensData+10] & 0x0f)\n\t\t  imgdata.lens.makernotes.MinAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0x0f) + 10)/4.0f);\n\n\t\tif (iLensData != 12)\n\t\t  {\n\t\t\tswitch (table_buf[iLensData] & 0x06)\n\t\t\t  {\n\t\t\t  case 0: imgdata.lens.makernotes.MinAp4MinFocal = 22.0f; break;\n\t\t\t  case 2: imgdata.lens.makernotes.MinAp4MinFocal = 32.0f; break;\n\t\t\t  case 4: imgdata.lens.makernotes.MinAp4MinFocal = 45.0f; break;\n\t\t\t  case 6: imgdata.lens.makernotes.MinAp4MinFocal = 16.0f; break;\n\t\t\t  }\n\t\t\tif (table_buf[iLensData] & 0x70)\n\t\t\t  imgdata.lens.makernotes.LensFStops =\n\t\t\t\t((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n\t\t\timgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData+3] & 0xf8);\n\t\t\timgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData+3] & 0x07);\n\n\t\t\tif ((table_buf[iLensData+14] > 1) &&\n\t\t\t\t(fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+14] & 0x7f) -1)/32.0f);\n\t\t  }\n\t\telse if ((id != 0x12e76) &&\t// K-5\n\t\t\t\t (table_buf[iLensData+15] > 1) &&\n\t\t\t\t (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t  {\n\t\t\timgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t  powf64(2.0f, (float)((table_buf[iLensData+15] & 0x7f) -1)/32.0f);\n\t\t  }\n\t  }\n\tfree(table_buf);\n\treturn;\n}\n\nvoid CLASS setPhaseOneFeatures (unsigned id) {\n\n  ushort i;\n  static const struct {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n    // Phase One section:\n    {1, \"Hasselblad V\"},\n    {10, \"PhaseOne/Mamiya\"},\n    {12, \"Contax 645\"},\n    {16, \"Hasselblad V\"},\n    {17, \"Hasselblad V\"},\n    {18, \"Contax 645\"},\n    {19, \"PhaseOne/Mamiya\"},\n    {20, \"Hasselblad V\"},\n    {21, \"Contax 645\"},\n    {22, \"PhaseOne/Mamiya\"},\n    {23, \"Hasselblad V\"},\n    {24, \"Hasselblad H\"},\n    {25, \"PhaseOne/Mamiya\"},\n    {32, \"Contax 645\"},\n    {34, \"Hasselblad V\"},\n    {35, \"Hasselblad V\"},\n    {36, \"Hasselblad H\"},\n    {37, \"Contax 645\"},\n    {38, \"PhaseOne/Mamiya\"},\n    {39, \"Hasselblad V\"},\n    {40, \"Hasselblad H\"},\n    {41, \"Contax 645\"},\n    {42, \"PhaseOne/Mamiya\"},\n    {44, \"Hasselblad V\"},\n    {45, \"Hasselblad H\"},\n    {46, \"Contax 645\"},\n    {47, \"PhaseOne/Mamiya\"},\n    {48, \"Hasselblad V\"},\n    {49, \"Hasselblad H\"},\n    {50, \"Contax 645\"},\n    {51, \"PhaseOne/Mamiya\"},\n    {52, \"Hasselblad V\"},\n    {53, \"Hasselblad H\"},\n    {54, \"Contax 645\"},\n    {55, \"PhaseOne/Mamiya\"},\n    {67, \"Hasselblad V\"},\n    {68, \"Hasselblad H\"},\n    {69, \"Contax 645\"},\n    {70, \"PhaseOne/Mamiya\"},\n    {71, \"Hasselblad V\"},\n    {72, \"Hasselblad H\"},\n    {73, \"Contax 645\"},\n    {74, \"PhaseOne/Mamiya\"},\n    {76, \"Hasselblad V\"},\n    {77, \"Hasselblad H\"},\n    {78, \"Contax 645\"},\n    {79, \"PhaseOne/Mamiya\"},\n    {80, \"Hasselblad V\"},\n    {81, \"Hasselblad H\"},\n    {82, \"Contax 645\"},\n    {83, \"PhaseOne/Mamiya\"},\n    {84, \"Hasselblad V\"},\n    {85, \"Hasselblad H\"},\n    {86, \"Contax 645\"},\n    {87, \"PhaseOne/Mamiya\"},\n    {99, \"Hasselblad V\"},\n    {100, \"Hasselblad H\"},\n    {101, \"Contax 645\"},\n    {102, \"PhaseOne/Mamiya\"},\n    {103, \"Hasselblad V\"},\n    {104, \"Hasselblad H\"},\n    {105, \"PhaseOne/Mamiya\"},\n    {106, \"Contax 645\"},\n    {112, \"Hasselblad V\"},\n    {113, \"Hasselblad H\"},\n    {114, \"Contax 645\"},\n    {115, \"PhaseOne/Mamiya\"},\n    {131, \"Hasselblad V\"},\n    {132, \"Hasselblad H\"},\n    {133, \"Contax 645\"},\n    {134, \"PhaseOne/Mamiya\"},\n    {135, \"Hasselblad V\"},\n    {136, \"Hasselblad H\"},\n    {137, \"Contax 645\"},\n    {138, \"PhaseOne/Mamiya\"},\n    {140, \"Hasselblad V\"},\n    {141, \"Hasselblad H\"},\n    {142, \"Contax 645\"},\n    {143, \"PhaseOne/Mamiya\"},\n    {148, \"Hasselblad V\"},\n    {149, \"Hasselblad H\"},\n    {150, \"Contax 645\"},\n    {151, \"PhaseOne/Mamiya\"},\n    {160, \"A-250\"},\n    {161, \"A-260\"},\n    {162, \"A-280\"},\n    {167, \"Hasselblad V\"},\n    {168, \"Hasselblad H\"},\n    {169, \"Contax 645\"},\n    {170, \"PhaseOne/Mamiya\"},\n    {172, \"Hasselblad V\"},\n    {173, \"Hasselblad H\"},\n    {174, \"Contax 645\"},\n    {175, \"PhaseOne/Mamiya\"},\n    {176, \"Hasselblad V\"},\n    {177, \"Hasselblad H\"},\n    {178, \"Contax 645\"},\n    {179, \"PhaseOne/Mamiya\"},\n    {180, \"Hasselblad V\"},\n    {181, \"Hasselblad H\"},\n    {182, \"Contax 645\"},\n    {183, \"PhaseOne/Mamiya\"},\n    {208, \"Hasselblad V\"},\n    {211, \"PhaseOne/Mamiya\"},\n    {448, \"Phase One 645AF\"},\n    {457, \"Phase One 645DF\"},\n    {471, \"Phase One 645DF+\"},\n    {704, \"Phase One iXA\"},\n    {705, \"Phase One iXA - R\"},\n    {706, \"Phase One iXU 150\"},\n    {707, \"Phase One iXU 150 - NIR\"},\n    {708, \"Phase One iXU 180\"},\n    {721, \"Phase One iXR\"},\n    // Leaf section:\n    {333,\"Mamiya\"},\n    {329,\"Universal\"},\n    {330,\"Hasselblad H1/H2\"},\n    {332,\"Contax\"},\n    {336,\"AFi\"},\n    {327,\"Mamiya\"},\n    {324,\"Universal\"},\n    {325,\"Hasselblad H1/H2\"},\n    {326,\"Contax\"},\n    {335,\"AFi\"},\n    {340,\"Mamiya\"},\n    {337,\"Universal\"},\n    {338,\"Hasselblad H1/H2\"},\n    {339,\"Contax\"},\n    {323,\"Mamiya\"},\n    {320,\"Universal\"},\n    {322,\"Hasselblad H1/H2\"},\n    {321,\"Contax\"},\n    {334,\"AFi\"},\n    {369,\"Universal\"},\n    {370,\"Mamiya\"},\n    {371,\"Hasselblad H1/H2\"},\n    {372,\"Contax\"},\n    {373,\"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0]) {\n    for (i=0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id) {\n        strcpy(imgdata.lens.makernotes.body,p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes (unsigned tag, unsigned type) {\n      switch (tag) {\n      case 0x1002: imgdata.makernotes.fuji.WB_Preset = get2(); break;\n      case 0x1011: imgdata.other.FlashEC = getreal(type); break;\n      case 0x1020: imgdata.makernotes.fuji.Macro = get2(); break;\n      case 0x1021: imgdata.makernotes.fuji.FocusMode = get2(); break;\n      case 0x1022: imgdata.makernotes.fuji.AFMode = get2(); break;\n      case 0x1023: imgdata.makernotes.fuji.FocusPixel[0] = get2();\n                   imgdata.makernotes.fuji.FocusPixel[1] = get2();\n      break;\n      case 0x1034: imgdata.makernotes.fuji.ExrMode = get2(); break;\n      case 0x1050: imgdata.makernotes.fuji.ShutterType = get2(); break;\n      case 0x1400: imgdata.makernotes.fuji.FujiDynamicRange = get2(); break;\n      case 0x1401: imgdata.makernotes.fuji.FujiFilmMode = get2(); break;\n      case 0x1402: imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2(); break;\n      case 0x1403: imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2(); break;\n      case 0x140b: imgdata.makernotes.fuji.FujiAutoDynamicRange = get2(); break;\n      case 0x1404: imgdata.lens.makernotes.MinFocal = getreal(type); break;\n      case 0x1405: imgdata.lens.makernotes.MaxFocal = getreal(type); break;\n      case 0x1406: imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type); break;\n      case 0x1407: imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type); break;\n      case 0x1422: imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n                   imgdata.shootinginfo.ImageStabilization = (imgdata.makernotes.fuji.ImageStabilization[0]<<9) + imgdata.makernotes.fuji.ImageStabilization[1];\n      break;\n      case 0x1431: imgdata.makernotes.fuji.Rating = get4(); break;\n      case 0x3820: imgdata.makernotes.fuji.FrameRate = get2(); break;\n      case 0x3821: imgdata.makernotes.fuji.FrameWidth = get2(); break;\n      case 0x3822: imgdata.makernotes.fuji.FrameHeight = get2(); break;\n      }\nreturn;\n}\n\nvoid CLASS setSonyBodyFeatures (unsigned id) {\n\n  imgdata.lens.makernotes.CamID = id;\n  if (\t// FF cameras\n      (id == 257) ||\t\t// a900\n      (id == 269) ||\t\t// a850\n      (id == 340) ||\t\t// ILCE-7M2\n      (id == 318) ||\t\t// ILCE-7S\n      (id == 350) ||\t\t// ILCE-7SM2\n      (id == 311) ||\t\t// ILCE-7R\n      (id == 347) ||\t\t// ILCE-7RM2\n      (id == 306) ||\t\t// ILCE-7\n      (id == 298) ||\t\t// DSC-RX1\n      (id == 299) ||\t\t// NEX-VG900\n      (id == 310) ||\t\t// DSC-RX1R\n      (id == 344) ||\t\t// DSC-RX1RM2\n      (id == 354) ||\t\t// ILCA-99M2\n      (id == 294)\t\t// SLT-99, Hasselblad HV\n      )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n  else if ((id == 297) ||  // DSC-RX100\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n         )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n    }\n\n  else if (id != 002)     // DSC-R1\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    }\n\n  if      (               // E-mount cameras, ILCE series\n           (id == 302) ||\n           (id == 306) ||\n           (id == 311) ||\n           (id == 312) ||\n           (id == 313) ||\n           (id == 318) ||\n           (id == 339) ||\n           (id == 340) ||\n           (id == 346) ||\n           (id == 347) ||\n           (id == 350) ||\n           (id == 360)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n    }\n  else if (               // E-mount cameras, NEX series\n           (id == 278) ||\n           (id == 279) ||\n           (id == 284) ||\n           (id == 288) ||\n           (id == 289) ||\n           (id == 290) ||\n           (id == 293) ||\n           (id == 295) ||\n           (id == 296) ||\n           (id == 299) ||\n           (id == 300) ||\n           (id == 305) ||\n           (id == 307)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n    }\n\n  else if (\t// A-mount cameras, DSLR series\n           (id == 256) ||\n           (id == 257) ||\n           (id == 258) ||\n           (id == 259) ||\n           (id == 260) ||\n           (id == 261) ||\n           (id == 262) ||\n           (id == 263) ||\n           (id == 264) ||\n           (id == 265) ||\n           (id == 266) ||\n           (id == 269) ||\n           (id == 270) ||\n           (id == 273) ||\n           (id == 274) ||\n           (id == 275) ||\n           (id == 282) ||\n           (id == 283)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n    }\n  else if (\t// A-mount cameras, SLT series\n           (id == 280) ||\n           (id == 281) ||\n           (id == 285) ||\n           (id == 286) ||\n           (id == 287) ||\n           (id == 291) ||\n           (id == 292) ||\n           (id == 294) ||\n           (id == 303)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n    }\n  else if (\t// A-mount cameras, ILCA series\n           (id == 319)  ||\n           (id == 353)  ||\n           (id == 354)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n    }\n\n  else if (\t// DSC\n           (id == 002) ||  // DSC-R1\n           (id == 297) ||  // DSC-RX100\n           (id == 298) ||  // DSC-RX1\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 310) ||  // DSC-RX1R\n           (id == 344) ||  // DSC-RX1RM2\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n           )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n    }\n  return;\n}\n\nvoid CLASS parseSonyLensType2 (uchar a, uchar b) {\n  ushort lid2;\n  lid2 = (((ushort)a)<<8) | ((ushort)b);\n  if (!lid2) return;\n  if (lid2 < 0x100)\n    {\n      if ((imgdata.lens.makernotes.AdapterID != 0x4900) &&\n          (imgdata.lens.makernotes.AdapterID != 0xEF00))\n      {\n        imgdata.lens.makernotes.AdapterID = lid2;\n        switch (lid2) {\n        case 1:\n        case 2:\n        case 3:\n        case 6:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n        case 44:\n        case 78:\n        case 239:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n        }\n      }\n    }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n    {\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n    }\n  return;\n}\n\n#define strnXcat(buf,string) strncat(buf,string,LIM(sizeof(buf)-strbuflen(buf)-1,0,sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures (uchar a, uchar b) {\n\n  ushort features;\n  features = (((ushort)a)<<8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) ||\n      !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100)) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n    {\n  \t  imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n  \t  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n  \t  if ((features & 0x0200) && (features & 0x0100)) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0200) {\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0100) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t  }\n    }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\" );\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf+1,\n\t    strbuflen(imgdata.lens.makernotes.LensFeatures_suf)-1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c (uchar * buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n    {\n      switch (SonySubstitution[buf[0x0008]]) {\n      case 1:\n      case 5:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 4:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n        break;\n      }\n    }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |\n    ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2 (SonySubstitution[buf[0x000a]],\t// LensType2 - Sony lens ids\n                        SonySubstitution[buf[0x0009]]);\n  return;\n}\n\n\nvoid CLASS process_Sony_0x9050 (uchar * buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n    {\n      if (buf[0])\n        imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n\n      if (buf[1])\n        imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n    }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    {\n      if (buf[0x3d] | buf[0x3c])\n        {\n          lid = SonySubstitution[buf[0x3d]] << 8 |\n            SonySubstitution[buf[0x3c]];\n          imgdata.lens.makernotes.CurAp =\n            powf64(2.0f, ((float)lid/256.0f - 16.0f) / 2.0f);\n        }\n      if (buf[0x105] &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n        imgdata.lens.makernotes.LensMount =\n          SonySubstitution[buf[0x105]];\n      if (buf[0x106])\n        imgdata.lens.makernotes.LensFormat =\n          SonySubstitution[buf[0x106]];\n    }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n    {\n      parseSonyLensType2 (SonySubstitution[buf[0x0108]],\t\t// LensType2 - Sony lens ids\n                          SonySubstitution[buf[0x0107]]);\n    }\n  if ((imgdata.lens.makernotes.LensID == -1) &&\n      (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n    {\n      imgdata.lens.makernotes.LensID =\t\t // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 |\n        SonySubstitution[buf[0x0109]];\n\n      if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n          (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n      else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n          (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n          (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n    }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures (SonySubstitution[buf[0x115]],\n                           SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long long b88 = SonySubstitution[buf[0x88]];\n    unsigned long long b89 = SonySubstitution[buf[0x89]];\n    unsigned long long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06llx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05llx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") ||\n           !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG))) {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) ||\n           !strcmp(buf, \"Panasonic\")) {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8)) {\n    base = ftell(ifp) - 10;\n  nf: order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") ||\n           !strcmp(buf, \"LEICA\") ||\n           !strcmp(buf, \"Ricoh\") ||\n           !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") ||\n           !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) &&\n\t\t\t\t(dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if(len > 8 && pos+len > 2* fsize) continue;\n    tag |= uptag << 16;\n    if(len > 100*1024*1024) goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000) // camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t // Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes (tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len,ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n      {\n        if (tag == 0x1d)\t\t\t\t\t\t\t// serial number\n          while ((c = fgetc(ifp)) && c != EOF)\n          {\n            if ((!custom_serial) && (!isdigit(c)))\n            {\n              if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n              {\n                custom_serial = 34;\n              }\n              else\n              {\n                custom_serial = 96;\n              }\n            }\n            serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n          }\n        else if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0097)\n          {\n            for (i=0; i < 4; i++)\n\t            ver97 = ver97 * 10 + fgetc(ifp)-'0';\n\t          if (ver97 == 601)  // Coolpix A\n\t          {\n\t            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n\t          }\n\t        }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n\n        else if (tag == 0xa7)\t\t\t\t\t// shutter count\n          {\n            NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n            if ((NikonLensDataVersion > 200) && lenNikonLensData)\n            {\n              if (custom_serial)\n              {\n                ci = xlat[0][custom_serial];\n              }\n              else\n              {\n                ci = xlat[0][serial & 0xff];\n              }\n              cj = xlat[1][NikonKey];\n              ck = 0x60;\n              for (i = 0; i < lenNikonLensData; i++)\n                table_buf[i] ^= (cj += ci * ck++);\n              processNikonLensData(table_buf, lenNikonLensData);\n              lenNikonLensData = 0;\n              free(table_buf);\n            }\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n\n        else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n          {\n            unsigned char cc;\n            fread(&cc, 1, 1, ifp);\n            iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n            break;\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        int SubDirOffsetValid =\n              strncmp (model, \"E-300\", 5) &&\n              strncmp (model, \"E-330\", 5) &&\n              strncmp (model, \"E-400\", 5) &&\n              strncmp (model, \"E-500\", 5) &&\n              strncmp (model, \"E-1\", 3);\n\n        if ((tag == 0x2010) || (tag == 0x2020))\n          {\n            fseek(ifp, save - 4, SEEK_SET);\n            fseek(ifp, base + get4(), SEEK_SET);\n            parse_makernote_0xc634(base, tag, dng_writer);\n          }\n        if (!SubDirOffsetValid &&\n            ((len > 4) ||\n             ( ((type == 3) || (type == 8)) && (len > 2))  ||\n             ( ((type == 4) || (type == 9)) && (len > 1))  || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n        switch (tag) {\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20100102:\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x20100201:\n          imgdata.lens.makernotes.LensID =\n            (unsigned long long)fgetc(ifp)<<16 |\n            (unsigned long long)(fgetc(ifp), fgetc(ifp))<<8 |\n            (unsigned long long)fgetc(ifp);\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          if ((!imgdata.lens.LensSerial[0]))\n              stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens,len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment,len, ifp);\n          break;\n        case 0x20200401:\n\t      imgdata.other.FlashEC = getreal(type);\n\t      break;\n        }\n        skip_Oly_broken_tags:;\n      }\n\n    else if (!strncmp(make, \"PENTAX\", 6) ||\n             !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n               PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t     for (int i = 0; i < nWB; i++)\n\t       {\n\t\t imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\t fseek(ifp, 2, SEEK_CUR);\n\t\t imgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\t imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\t imgdata.color.WBCT_Coeffs[i][3] = get2();\n        \t}\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 12, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) &&\n             (dng_writer == AdobeDNG))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            imgdata.lens.makernotes.CamID = unique_id = get4();\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n          {\n            unique_id = get2();\n            setSonyBodyFeatures(unique_id);\n            if (table_buf_0x9050_present)\n              {\n                process_Sony_0x9050(table_buf_0x9050, unique_id);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n            if (table_buf_0x940c_present)\n              {\n                if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                  {\n                    process_Sony_0x940c(table_buf_0x940c);\n                  }\n                free (table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n\n                  // a450, a500, a550, a560, a580\n                  // a33, a35, a55\n                  // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len) {\n                case 368:\n                case 5478:\n                  // a700, a850, a900: CameraInfo\n                  if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n                    {\n                      if (table_buf[0] | table_buf[3])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                      if (table_buf[2] | table_buf[5])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    }\n                  break;\n                default:\n                  // CameraInfo2 & 3\n                  if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n                    {\n                      if (table_buf[1] | table_buf[2])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                      if (table_buf[3] | table_buf[4])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                      if (table_buf[5])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                      if (table_buf[6])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                    }\n                }\n              }\n            free(table_buf);\n          }\n\n\t\telse if (tag == 0x0104)\n\t\t  {\n\t\t    imgdata.other.FlashEC = getreal(type);\n\t\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 65535)\t\t\t\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len < 256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n              {\n                if (table_buf[1] | table_buf[2])\n                  imgdata.lens.makernotes.MinFocal =\n                    bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                if (table_buf[3] | table_buf[4])\n                  imgdata.lens.makernotes.MaxFocal =\n                    bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                if (table_buf[5])\n                  imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                if (table_buf[6])\n                  imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                parseSonyLensFeatures(table_buf[0], table_buf[7]);\n              }\n            free(table_buf);\n          }\n      }\n  next:\n    fseek (ifp, save, SEEK_SET);\n  }\n quit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  /*placeholder */\n}\n#endif\n\n\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strncmp(make,\"Nokia\",5)) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\") ||\n             !strcmp (buf,\"PENTAX \")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n             !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\n\tnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n             !strcmp (buf,\"LEICA\") ||\n             !strcmp (buf,\"Ricoh\") ||\n             !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n           !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (!strncmp(model, \"M8\", 2) ||\n          !strncasecmp(model, \"Leica M8\", 8) ||\n          !strncasecmp(model, \"LEICA X\", 7))\n        {\n          base = ftell(ifp)-8;\n        }\n      else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n        {\n          base = 0;\n        }\n      else if (!strncmp(model, \"M9\", 2) ||\n               !strncasecmp(model, \"Leica M9\", 8) ||\n               !strncasecmp(model, \"M Monochrom\", 11) ||\n               !strncasecmp(model, \"Leica M Monochrom\", 11))\n        {\n          if (!uptag)\n            {\n              base = ftell(ifp) - 10;\n              fseek (ifp, 8, SEEK_CUR);\n            }\n          else if (uptag == 0x3400)\n            {\n              fseek (ifp, 10, SEEK_CUR);\n              base += 10;\n            }\n        }\n      else if (!strncasecmp(model, \"LEICA T\", 7))\n      \t{\n      \t  base = ftell(ifp)-8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n      \t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (!strncasecmp(model, \"LEICA SL\", 8))\n      \t{\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      \t  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n      \t}\n#endif\n    }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if(len > 8 && _pos+len > 2* fsize) continue;\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000)\t// camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t// Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4)) {\n      if (tag == 0x0010) {\n         char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n         char *words[4];\n         char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n         int year, nwords, ynum_len;\n         unsigned c;\n         stmread(FujiSerial, len, ifp);\n         nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n         for (int i = 0; i < nwords; i++) {\n           mm[2] = dd[2] = 0;\n           if (strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1) < 18)\n              if (i == 0)\n\t         strncpy (imgdata.shootinginfo.InternalBodySerial,\n\t\t \twords[0],\n\t\t\tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n              else\n\t      {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t       snprintf (tbuf, sizeof(tbuf), \"%s %s\",\n\t            imgdata.shootinginfo.InternalBodySerial, words[i]);\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n\t       }\n           else\n           {\n             strncpy (dd, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-14, 2);\n             strncpy (mm, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-16, 2);\n             strncpy (yy, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18, 2);\n             year = (yy[0]-'0')*10 + (yy[1]-'0');\n             if (year <70) year += 2000; else year += 1900;\n\n             ynum_len = (int)strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18;\n             strncpy(ynum, words[i], ynum_len);\n             ynum[ynum_len] = 0;\n             for ( int j = 0; ynum[j] && ynum[j+1] && sscanf(ynum+j, \"%2x\", &c); j += 2) ystr[j/2] = c;\n             ystr[ynum_len / 2 + 1] = 0;\n             strcpy (model2, ystr);\n\n             if (i == 0) {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n               if (nwords == 1)\n\t\t   snprintf (tbuf,sizeof(tbuf),\n\t\t\t   \"%s %s %d:%s:%s\",\n\t\t\t   words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12,\n\t\t\t\tystr, year, mm, dd);\n\n               else\n\t\t snprintf (tbuf,sizeof(tbuf),\n\t\t\t    \"%s %d:%s:%s %s\",\n\t\t\t    ystr, year, mm, dd,\n\t\t\t    words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n             } else {\n\t\tchar tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t        snprintf (tbuf, sizeof(tbuf),\n\t\t\"%s %s %d:%s:%s %s\",\n\t\timgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,\n\t\t words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\t\t strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t\t \tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n      \t     }\n           }\n         }\n      }\n      else\n\tparseFujiMakernotes (tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                 )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\",5))\n      {\n        if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0012)\n          {\n            char a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c) imgdata.other.FlashEC = (float)(a*b)/(float)c;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData>0)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n        else if (tag == 0x00a0)\n          {\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        switch (tag) {\n        case 0x0404:\n        case 0x101a:\n        case 0x20100101:\n          if (!imgdata.shootinginfo.BodySerial[0])\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n        case 0x20100102:\n          if (!imgdata.shootinginfo.InternalBodySerial[0])\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20401112:\n          imgdata.makernotes.olympus.OlympusCropID = get2();\n          break;\n        case 0x20401113:\n          FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n          break;\n        case 0x20100201:\n          {\n            unsigned long long oly_lensid [3];\n            oly_lensid[0] = fgetc(ifp);\n            fgetc(ifp);\n            oly_lensid[1] = fgetc(ifp);\n            oly_lensid[2] = fgetc(ifp);\n            imgdata.lens.makernotes.LensID =\n              (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n          }\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          break;\n        }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) &&\n             !strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n    \t  {\n    \t     char buffer[17];\n    \t     int count=0;\n    \t     fread(buffer, 16, 1, ifp);\n    \t     buffer[16] = 0;\n    \t     for (int i=0; i<16; i++)\n    \t     {\n//    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n    \t        if ((isspace(buffer[i])) ||\n    \t            (buffer[i] == 0x2D) ||\n    \t            (isalnum(buffer[i])))\n    \t        count++;\n    \t     }\n    \t     if (count == 16)\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%8s\", buffer+8);\n    \t        buffer[8] = 0;\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t     }\n    \t     else\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10], buffer[11]);\n    \t     }\n    \t  }\n        else if ((tag == 0x1001) && (type == 3))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            imgdata.lens.makernotes.LensID = -1;\n            imgdata.lens.makernotes.FocalType = 1;\n          }\n\n        else if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n        else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n      }\n\n    else if (!strncmp(make, \"RICOH\", 5) &&\n             strncmp(model, \"PENTAX\", 6))\n      {\n    \tif ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n    \t  {\n    \t     char buffer[9];\n    \t     buffer[8] = 0;\n    \t     fread(buffer, 8, 1, ifp);\n    \t     sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t  }\n\n    \telse if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n          else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n\n        else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n          {\n            short ntags, cur_tag;\n            fseek(ifp, 20, SEEK_CUR);\n            ntags = get2();\n            cur_tag = get2();\n            while (cur_tag != 0x002c)\n              {\n                fseek(ifp, 10, SEEK_CUR);\n                cur_tag = get2();\n              }\n            fseek(ifp, 6, SEEK_CUR);\n            fseek(ifp, get4()+20, SEEK_SET);\n            stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n            get2();\n            imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n            switch(imgdata.lens.makernotes.LensID) {\n              case 1:\n              case 2:\n              case 3:\n              case 5:\n              case 6:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            \timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n              break;\n              case 8:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            \timgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            \timgdata.lens.makernotes.LensID = -1;\n              break;\n              default:\n            \timgdata.lens.makernotes.LensID = -1;\n            }\n            fseek(ifp, 17, SEEK_CUR);\n            stread(imgdata.lens.LensSerial, 12, ifp);\n          }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) ||\n              !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n            \tPentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t    for (int i = 0; i < nWB; i++)\n\t      {\n\t\timgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\tfseek(ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\timgdata.color.WBCT_Coeffs[i][3] = get2();\n\t      }\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 2, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            unique_id = imgdata.lens.makernotes.CamID = get4();\n          }\n         else if (tag == 0xa002)\n          {\n             stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n        {\n          unique_id = get2();\n          setSonyBodyFeatures(unique_id);\n          if (table_buf_0x9050_present)\n            {\n              process_Sony_0x9050(table_buf_0x9050, unique_id);\n              free (table_buf_0x9050);\n              table_buf_0x9050_present = 0;\n            }\n          if (table_buf_0x940c_present)\n            {\n              if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                {\n                  process_Sony_0x940c(table_buf_0x940c);\n                }\n              free (table_buf_0x940c);\n              table_buf_0x940c_present = 0;\n            }\n        }\n\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n                  \t\t\t\t// a450, a500, a550, a560, a580\n                  \t\t\t\t// a33, a35, a55\n                  \t\t\t\t// NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len)\n                  {\n                  case 368:\n                  case 5478:\n                    // a700, a850, a900: CameraInfo\n                    if (table_buf[0] | table_buf[3])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                    if (table_buf[2] | table_buf[5])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    break;\n                  default:\n                    // CameraInfo2 & 3\n                    if (table_buf[1] | table_buf[2])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                    if (table_buf[3] | table_buf[4])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                    if (table_buf[5])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                    if (table_buf[6])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                }\n              }\n            free(table_buf);\n          }\n\n        else if ((tag == 0x0020) &&\t\t\t\t// WBInfoA100, needs 0xb028 processing\n                 !strncasecmp(model, \"DSLR-A100\", 9))\n\t  {\n\t    fseek(ifp,0x49dc,SEEK_CUR);\n\t    stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n\t  }\n\n\telse if (tag == 0x0104)\n\t  {\n\t    imgdata.other.FlashEC = getreal(type);\n\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 256000)\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len <256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal =\n                bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal =\n                bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            free(table_buf);\n          }\n      }\n\n    fseek(ifp,_pos,SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 37 && strstr(make,\"NIKON\") && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc,1,1,ifp);\n        iso_speed = int(100.0 * powf64(2.0f,float(cc)/12.0-5.0));\n      }\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n\tiso_speed = 50 * powf64(2.0, i/32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = powf64(2.0, i/64.0);\n#endif\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = powf64(2.0, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make,\"Canon\",5))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4) unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n\tif (!strncasecmp(make,\"Olympus\",7))\n\t{\n\t  short nWB, tWB;\n\t  if ((tag == 0x20300108) || (tag == 0x20310109))\n\t      imgdata.makernotes.olympus.ColorSpace = get2();\n\n\t  if ((tag == 0x20400102) && (len == 2) &&\n\t      (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n\t    {\n\t      int i;\n\t      for (i=0; i<64; i++)\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] =\n\t\t  imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t      for (i=64; i<256; i++)\n\t\timgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t    }\n\t  if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n\t    {\n\t      ushort CT;\n\t      nWB = tag-0x20400102;\n\t      switch (nWB)\n\t\t{\n                case 0 : CT = 3000; tWB = LIBRAW_WBI_Tungsten; break;\n\t\tcase 1 : CT = 3300; tWB = 0x100; break;\n\t\tcase 2 : CT = 3600; tWB = 0x100; break;\n\t\tcase 3 : CT = 3900; tWB = 0x100; break;\n                case 4 : CT = 4000; tWB = LIBRAW_WBI_FL_W; break;\n\t\tcase 5 : CT = 4300; tWB = 0x100; break;\n                case 6 : CT = 4500; tWB = LIBRAW_WBI_FL_D; break;\n\t\tcase 7 : CT = 4800; tWB = 0x100; break;\n                case 8 : CT = 5300; tWB = LIBRAW_WBI_FineWeather; break;\n                case 9 : CT = 6000; tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: CT = 6600; tWB = LIBRAW_WBI_FL_N; break;\n                case 11: CT = 7500; tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: CT = 0; tWB = 0x100;\n\t\t}\n\t      if (CT)\n\t\t{\n\t\t  imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n\t\t  imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n\t\t  imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n\t\t  if (len == 4)\n\t\t    {\n\t\t      imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n\t\t      imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t\t    }\n\t\t}\n\t      if (tWB != 0x100)\n\t\tFORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c+1];\n\t    }\n\t  if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n\t    {\n\t      nWB = tag-0x20400113;\n\t      imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t      switch (nWB)\n\t\t{\n                case 0:  tWB = LIBRAW_WBI_Tungsten; break;\n                case 4:  tWB = LIBRAW_WBI_FL_W; break;\n                case 6:  tWB = LIBRAW_WBI_FL_D; break;\n                case 8:  tWB = LIBRAW_WBI_FineWeather; break;\n                case 9:  tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: tWB = LIBRAW_WBI_FL_N; break;\n                case 11: tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: tWB = 0x100;\n\t\t}\n\t      if (tWB != 0x100)\n\t\timgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] =\n\t\t  imgdata.color.WBCT_Coeffs[nWB][2];\n\t    }\n\n\t  if (tag == 0x20400121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n\t      if (len == 4)\n\t\t{\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t\t}\n\t    }\n\t  if (tag == 0x2040011f)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t    }\n\t  if (tag == 0x30000120)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n\t      if (len == 2)\n\t\t{\n\t\t  for (int i=0; i<256; i++)\n\t\t    imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t\t}\n\t    }\n\t  if (tag == 0x30000121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n\t    }\n\t  if (tag == 0x30000122)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n\t    }\n\t  if (tag == 0x30000123)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n\t    }\n\t  if (tag == 0x30000124)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n\t    }\n\t  if (tag == 0x30000130)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n\t    }\n\t  if (tag == 0x30000131)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n\t    }\n\t  if (tag == 0x30000132)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n\t    }\n\t  if (tag == 0x30000133)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n\t    }\n\n\t  if((tag == 0x20400805) && (len == 2))\n\t    {\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[0]=getreal(type);\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[1]=getreal(type);\n\t      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n\t    }\n\t  if (tag == 0x20200401)\n\t    {\n\t      imgdata.other.FlashEC = getreal(type);\n\t    }\n\t}\n    fseek(ifp,_pos2,SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d) {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1) {  // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  FORC4 cam_mul[c ^ (c >> 1)] = get2();\n\t  break;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7) {\t// shutter count\n      NikonKey = fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp);\n        if ( (unsigned) (ver97-200) < 17) {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i=0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n          sget2 (buf97 + (i & -2) + c*2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601)  // Coolpix A\n    \t{\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    \t}\n#endif\n    }\n\n    if(tag == 0xb001 && type == 3)\t// Sony ModelID\n      {\n        unique_id = get2();\n      }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n         FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make,\"NIKON\") && len == 4)\n      {\n        FORC4 cblack[c ^ c >> 1] = get2();\n        i = cblack[3];\n        FORC3 if(i>cblack[c]) i = cblack[c];\n        FORC4 cblack[c]-=i;\n        black += i;\n      }\n#endif\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tint loopc = 0;\n#endif\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(loopc++>1024)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n          for (i=0; i < 3; i++)\n\t  {\n#ifdef LIBRAW_LIBRARY_BUILD\n           if (!imgdata.makernotes.olympus.ColorSpace)\n\t   {\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n\t   }\n           else\n\t   {\n            FORC3 imgdata.color.ccm[i][c] = ((short) get2()) / 256.0;\n\t   }\n#else\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n#endif\n          }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek (ifp, get4()+base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    if (tag == 0x2010)\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, 0x2010);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n\n    if (\n         ((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) &&\n         ((type == 7) || (type == 13)) &&\n         !strncasecmp(make,\"Olympus\",7)\n       )\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, tag);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf,\"OLYMP\",5))\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i+=18; i <= len; i+=10) {\n      \tget2();\n      \tFORC4 sraw_mul[c ^ (c >> 1)] = get2();\n      \tif (sraw_mul[1] == 1170) break;\n      }\n    }\n    if(!strncasecmp(make,\"Samsung\",7))\n      {\n        if (tag == 0xa020) // get the full Samsung encryption key\n            for (i=0; i<11; i++) SamsungKey[i] = get4();\n        if (tag == 0xa021) // get and decode Samsung cam_mul array\n            FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 0xa023)\n          {\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n              }\n          }\n        if (tag == 0xa024)\n          {\n            FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c+1];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n              }\n          }\n        if (tag == 0xa025)\n           imgdata.color.linear_max[0]=\n             imgdata.color.linear_max[1]=\n             imgdata.color.linear_max[2]=\n             imgdata.color.linear_max[3]= get4() - SamsungKey[0];\n        if (tag == 0xa030 && len == 9)\n            for (i=0; i < 3; i++)\n              FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n#endif\n        if (tag == 0xa031 && len == 9)\t// get and decode Samsung color matrix\n            for (i=0; i < 3; i++)\n              FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n\n        if (tag == 0xa028)\n          FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n      }\n    else\n      {\n        // Somebody else use 0xa021 and 0xa028?\n        if (tag == 0xa021)\n          FORC4 cam_mul[c ^ (c >> 1)] = get4();\n        if (tag == 0xa028)\n          FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n      }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo,ape;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && savepos + len > fsize*2) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n    switch (tag) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n      case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t   shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;  // 0x829d FNumber\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 34866:\n        if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\",4) || !strncasecmp(make, \"CANON\",5)))\n          iso_speed = getreal(type);\n        break;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)\n\t\t     tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t\tshutter = powf64(2.0, expo);\n\t\tbreak;\n      case 37378:                                       // 0x9202 ApertureValue\n        if ((fabs(ape = getreal(type))<256.0) && (!aperture))\n          aperture = powf64(2.0, ape/2);\n        break;\n      case 37385:  flash_used = getreal(type);          break;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  \t                         // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n       if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n         char mn_text[512];\n         char* pos;\n         char ccms[512];\n         ushort l;\n         float num;\n\n         fgets(mn_text, len, ifp);\n         pos = strstr(mn_text, \"gain_r=\");\n         if (pos) cam_mul[0] = atof(pos+7);\n         pos = strstr(mn_text, \"gain_b=\");\n         if (pos) cam_mul[2] = atof(pos+7);\n         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n         else cam_mul[0] = cam_mul[2] = 0.0f;\n\n         pos = strstr(mn_text, \"ccm=\") + 4;\n         l = strstr(pos, \" \") - pos;\n         memcpy (ccms, pos, l);\n         ccms[l] = '\\0';\n\n         pos = strtok (ccms, \",\");\n         for (l=0; l<4; l++) {\n           num = 0.0;\n           for (c=0; c<3; c++) {\n             imgdata.color.ccm[l][c] = (float)atoi(pos);\n             num += imgdata.color.ccm[l][c];\n             pos = strtok (NULL, \",\");\n           }\n           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n         }\n       }\n       else\n#endif\n        parse_makernote (base, 0);\n       break;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n  \treturn;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--) {\n    tiff_get(base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n    case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;\n    case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;\n    case 5:  imgdata.other.parsed_gps.altref = getc(ifp); break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9: imgdata.other.parsed_gps.gpsstatus = getc(ifp); break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"AFi-II 7\",\"Aptus-II 7\",\"\",\"Aptus-II 6\",\"\",\"\",\"Aptus-II 10\",\"Aptus-II 5\",\n    \"\",\"\",\"\",\"\",\"Aptus-II 10R\",\"Aptus-II 8\",\"\",\"Aptus-II 12\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data,\"CameraObj_camera_type\")) {\n\tstmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data,\"back_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.BodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));\n       strcpy (imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data,\"CaptProf_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n       strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n// IB end\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\t((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x10000) len = 0x10000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x10000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[len<0x1000?0xfff:len-1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags (int wb, unsigned type)\n{\n\tfloat mul[3]={1,1,1}, num, mul2;\n\tint c;\n\tFORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n\timgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n\tmul2 = mul[1] * mul[1];\n\timgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n\timgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n\treturn;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  INT64 fsize = ifp->size();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > 2*fsize) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n    if (tag == 1011) imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());\n      wbi = -2;\n    }\n\n    if (tag == 0x0848) Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849) Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a) Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b) Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93) imgdata.color.linear_max[0] =\n                         imgdata.color.linear_max[1] =\n                         imgdata.color.linear_max[2] =\n                         imgdata.color.linear_max[3] = get2();\n        if (tag == 0x09ce)\n\t\tstmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);\n        if (tag == 0xfa00)\n\t\tstmread(imgdata.shootinginfo.BodySerial, len, ifp);\n\tif (tag == 0xfa27)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\t  }\n\tif (tag == 0xfa28)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\t  }\n\tif (tag == 0xfa29)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\t  }\n\tif (tag == 0xfa2a)\n\t  {\n            FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\t  }\n\n    if (tag == 2120 + wbi ||\n        (wbi<0 && tag == 2125))  /* use Auto WB if illuminant index is not set */\n      {\n        FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n        FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 0x903) iso_speed = getreal(type);\n    //if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#endif\n//@end COMMON\n\nvoid CLASS parse_minolta (int base);\nint CLASS parse_tiff (int base);\n\n//@out COMMON\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!strncasecmp(make, \"SONY\", 4) ||\n      (!strncasecmp(make, \"Hasselblad\", 10) &&\n        (!strncasecmp(model, \"Stellar\", 7) ||\n         !strncasecmp(model, \"Lunar\", 5) ||\n         !strncasecmp(model, \"HV\",2))))\n  {\n  \tswitch (tag) {\n\tcase 0x7300: // SR2 black level\n\t    for (int i = 0; i < 4 && i < len; i++)\n\t      cblack[i] = get2();\n\t  break;\n\tcase 0x7480:\n\tcase 0x7820:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\tbreak;\n\tcase 0x7481:\n\tcase 0x7821:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n\tbreak;\n\tcase 0x7482:\n\tcase 0x7822:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\tbreak;\n\tcase 0x7483:\n\tcase 0x7823:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n\tbreak;\n\tcase 0x7484:\n\tcase 0x7824:\n\t    imgdata.color.WBCT_Coeffs[0][0] = 4500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[0][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n\tbreak;\n\tcase 0x7486:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\tbreak;\n\tcase 0x7825:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\tbreak;\n\tcase 0x7826:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n\tbreak;\n\tcase 0x7827:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n\tbreak;\n\tcase 0x7828:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n\tbreak;\n\tcase 0x7829:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n\tbreak;\n\tcase 0x782a:\n\t    imgdata.color.WBCT_Coeffs[1][0] = 8500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[1][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n\tbreak;\n\tcase 0x782b:\n\t    imgdata.color.WBCT_Coeffs[2][0] = 6000;\n\t    FORC3 imgdata.color.WBCT_Coeffs[2][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n\tbreak;\n\tcase 0x782c:\n\t    imgdata.color.WBCT_Coeffs[3][0] = 3200;\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c+1] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] = imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n\tbreak;\n\tcase 0x782d:\n\t    imgdata.color.WBCT_Coeffs[4][0] = 2500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[4][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n\tbreak;\n\tcase 0x787f:\n\t    FORC3 imgdata.color.linear_max[c] = get2();\n\t    imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n\tbreak;\n\t}\n  }\n#endif\n\n\n    switch (tag) {\n      case 1:   if(len==4) pana_raw = get4(); break;\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:   if ((i = get2())) filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=i;\n#endif\n      break;\n      case 8:\n      case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=get2();\n#endif\n      break;\n      case 14: case 15: case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw) {\n          imgdata.color.linear_max[tag-14] = get2();\n          if (tag == 15 ) imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        }\n#endif\n      break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 19:\n\tif(pana_raw) {\n\t  ushort nWB, cnt, tWB;\n\t  nWB = get2();\n\t  if (nWB > 0x100) break;\n\t  for (cnt=0; cnt<nWB; cnt++) {\n\t    tWB = get2();\n\t    if (tWB < 0x100) {\n\t      imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n\t    } else get4();\n\t  }\n\t}\n      break;\n#endif\n      case 23:\n\tif (type == 3) iso_speed = get2();\n      break;\n      case 28: case 29: case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          {\n            pana_black[tag-28] = get2();\n          }\n        else\n#endif\n          {\n\t     cblack[tag-28] = get2();\n\t     cblack[3] = cblack[1];\n          }\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-36] = get2();\n\tbreak;\n      case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(pana_raw) {\n\t    ushort nWB, cnt, tWB;\n\t    nWB = get2();\n\t    if (nWB > 0x100) break;\n\t    for (cnt=0; cnt<nWB; cnt++) {\n\t        tWB = get2();\n\t        if (tWB < 0x100) {\n\t            imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t        } else fseek(ifp, 6, SEEK_CUR);\n\t    }\n\t}\n\tbreak;\n#endif\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tif (tiff_bps < tiff_ifd[ifd].bps)\n\t    tiff_bps = tiff_ifd[ifd].bps;\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tif (tiff_ifd[ifd].bps > 12) break;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 278:\n\ttiff_ifd[ifd].rows_per_strip = getint(type);\n\tbreak;\n#endif\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_offsets = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_offsets_count = len;\n\t    for(int i=0; i< len; i++)\n\t      tiff_ifd[ifd].strip_offsets[i]=get4()+base;\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    if ((tiff_ifd[ifd].t_width > 4*tiff_ifd[ifd].t_height) & ~jh.clrs) {\n\t      tiff_ifd[ifd].t_width  /= 2;\n\t      tiff_ifd[ifd].t_height *= 2;\n\t    }\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_byte_counts = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_byte_counts_count = len;\n\t    for(int i=0; i< len; i++)\n\t\ttiff_ifd[ifd].strip_byte_counts[i]=get4();\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 317:\n\ttiff_ifd[ifd].predictor = getint(type);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 1)\n\t  tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n      case 325:\n\ttiff_ifd[ifd].bytes = len > 1 ? ftell(ifp): get4();\n\tbreak;\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n         \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif  \n\t  break;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {\n          fseek (ifp, ftell(ifp)+4, SEEK_SET);\n          fseek (ifp, get4()+base, SEEK_SET);\n          parse_tiff_ifd (base);\n          break;\n\t}\n#endif\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 339:\n\ttiff_ifd[ifd].sample_format = getint(type);\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 700:\n        if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n          {\n            xmpdata = (char*)malloc(xmplen = len+1);\n            fread(xmpdata,len,1,ifp);\n            xmpdata[len]=0;\n          }\n        break;\n#endif\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i=0; i < 3; i++) {\n        float num = 0.0;\n        for (c=0; c<3; c++) {\n          imgdata.color.ccm[i][c] = (float) ((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01) FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n\t  FORC4 cblack[c ^ c >> 1] = get2();\n\t  i = cblack[3];\n\t  FORC3 if(i>cblack[c]) i = cblack[c];\n\t  FORC4 cblack[c]-=i;\n\t  black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);\n#endif\n      break;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33421:\t\t\t/* CFARepeatPatternDim */\n\tif (get2() == 6 && get2() == 6)\n\t  filters = 9;\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n\tif (filters == 9) {\n\t  FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;\n\t  break;\n\t}\n      case 64777:\t\t\t/* Kodak P-series */\n        if(len == 36)\n          {\n            filters = 9;\n            colors = 3;\n            FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n          }\n        else if(len > 0)\n          {\n            if ((plen=len) > 16) plen = 16;\n            fread (cfa_pat, 1, plen, ifp);\n            for (colors=cfa=i=0; i < plen && colors < 4; i++) {\n              colors += !(cfa & (1 << cfa_pat[i]));\n              cfa |= 1 << cfa_pat[i];\n            }\n            if (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n            if (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n            goto guess_cfa_pc;\n          }\n        break;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\ttiff_ifd[ifd].t_shutter = shutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= MAX(1,num);\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n        {\n          unsigned pos;\n          fseek(ifp, pos = (get4() + base), SEEK_SET);\n          parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n          fseek(ifp, pos, SEEK_SET);\n          parse_gps_libraw(base);\n#endif\n        }\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 40976:\n\tstrip_offset = get4();\n\tswitch (tiff_ifd[ifd].comp) {\n\t  case 32770: load_raw = &CLASS samsung_load_raw;   break;\n\t  case 32772: load_raw = &CLASS samsung2_load_raw;  break;\n\t  case 32773: load_raw = &CLASS samsung3_load_raw;  break;\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (len < 1 || len > 2560000 || !(cbuf = (char *) malloc(len))) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfread (cbuf, 1, len, ifp);\n#else\n\tif(fread (cbuf, 1, len, ifp) != len)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n        cbuf[len-1] = 0;\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag=1;\n#endif\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50708:\t\t\t/* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n        stmread(imgdata.color.UniqueCameraModel, len, ifp);\n        imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;\n#endif\n\tif (model[0]) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfgets (make, 64, ifp);\n#else\n        strncpy (make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n\tif ((cp = strchr(make,' '))) {\n\t  strcpy(model,cp+1);\n\t  *cp = 0;\n\t}\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (filters == 9) break;\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n        FORCC tab[cfa_pc[c]] = c;\n        cdesc[c] = 0;\n        for (i=16; i--; )\n          filters = filters << 2 | tab[cfa_pat[i % plen]];\n        filters -= !filters;\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) fuji_width = 1;\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[4] = \n#endif\n\tcblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[5] = \n#endif\n\tcblack[5] = get2();\n\tif (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof (cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.color.dng_levels.dng_cblack[4]=\n\t    imgdata.color.dng_levels.dng_cblack[5]= \n#endif\n\t    cblack[4] = cblack[5] = 1;\n\tbreak;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcase 0xf00c: {\n    \tunsigned fwb[4];\n    \tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t  if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n\t\t  {\n\t\t    long long f_save = ftell(ifp);\n\t\t    int fj, found = 0;\n\t\t    ushort *rafdata = (ushort*) malloc (sizeof(ushort)*libraw_internal_data.unpacker_data.lenRAFData);\n\t\t    fseek (ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n\t\t    fread (rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n\t\t    fseek(ifp, f_save, SEEK_SET);\n\t\t    for (int fi=0; fi<(libraw_internal_data.unpacker_data.lenRAFData-3); fi++)\n\t\t\t{\n\t\t\t  if ((fwb[0]==rafdata[fi]) && (fwb[1]==rafdata[fi+1]) && (fwb[2]==rafdata[fi+2]))\n\t\t\t  {\n\t\t\t    if (rafdata[fi-15] != fwb[0]) continue;\n\t\t\t    fi = fi - 15;\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] = rafdata[fi];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi+1];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi+2];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = rafdata[fi+3];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi+4];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi+5];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = rafdata[fi+6];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi+7];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi+8];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = rafdata[fi+9];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi+10];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi+11];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = rafdata[fi+12];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi+13];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi+14];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = rafdata[fi+15];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi+16];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi+17];\n\n                fi += 111;\n                for (fj = fi; fj<(fi+15); fj+=3)\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    found = 1;\n                    break;\n                  }\n                if (found)\n                {\n                  int FujiCCT_K [31] = {2500,2550,2650,2700,2800,2850,2950,3000,3100,3200,3300,3400,3600,3700,3800,4000,4200,4300,4500,4800,5000,5300,5600,5900,6300,6700,7100,7700,8300,9100,10000};\n                  fj = fj - 93;\n                  for (int iCCT=0; iCCT < 31; iCCT++)\n                  {\n                    imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                    imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT*3+1+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT*3+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT*3+2+fj];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t    free (rafdata);\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\t\tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t}\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50709:\n        stmread(imgdata.color.LocalizedCameraModel,len, ifp);\n      break;\n#endif\n\n      case 61450:\n\tcblack[4] = cblack[5] = MIN(sqrt((double)len),64);\n      case 50714:\t\t\t/* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1  && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n\t  {\n\t    for(i=0; i < colors && i < 4 && i < len; i++)\n\t      imgdata.color.dng_levels.dng_cblack[i]=\n\t        cblack[i]=\n\t\t  getreal(type)+0.5;\n\n\t    imgdata.color.dng_levels.dng_black= black = 0;\n\t  }\n\telse\n#endif\n\t  if((cblack[4] * cblack[5] < 2) && len == 1)\n\t    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t      imgdata.color.dng_levels.dng_black= \n#endif\n\t        black =\n\t\t  getreal(type);\n\t    }\n\t  else if(cblack[4] * cblack[5] <= len)\n\t    {\n\t      FORC (cblack[4] * cblack[5])\n\t\tcblack[6+c] = getreal(type);\n\t      black = 0;\n\t      FORC4\n\t\tcblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n              if(tag == 50714)\n\t      {\n\t        FORC (cblack[4] * cblack[5])\n\t          imgdata.color.dng_levels.dng_cblack[6+c]= cblack[6+c];\n\t        imgdata.color.dng_levels.dng_black=0;\n\t        FORC4\n\t          imgdata.color.dng_levels.dng_cblack[c]= 0;\n\t      }\n#endif\n\t    }\n      break;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_black += num/len + 0.5;\n#endif\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_whitelevel[0]=\n#endif\n\tmaximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1 ) // Linear DNG case\n\t\tfor(i=1; i < colors && i < 4 && i < len; i++)\n\t\t\timgdata.color.dng_levels.dng_whitelevel[i]=getint(type);\n#endif\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tif(pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50778:\n        imgdata.color.dng_color[0].illuminant = get2();\n        break;\n      case 50779:\n        imgdata.color.dng_color[1].illuminant = get2();\n        break;\n#endif\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 50721?0:1;\n#endif\n\tFORCC for (j=0; j < 3; j++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.dng_color[i].colormatrix[c][j]=\n#endif\n\t  cm[c][j] = getreal(type);\n          }\n\tuse_cm = 1;\n\tbreak;\n\n\tcase 0xc714:\t\t\t/* ForwardMatrix1 */\n        case 0xc715:\t\t\t/* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 0xc714?0:1;\n#endif\n\tfor (j=0; j < 3; j++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[i].forwardmatrix[j][c]=\n#endif\n              fm[j][c] = getreal(type);\n            }\n\tbreak;\n\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        j = tag == 50723?0:1;\n#endif\n\tfor (i=0; i < colors; i++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[j].calibration[i][c]=\n#endif\n              cc[i][c] = getreal(type);\n            }\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC{\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_levels.analogbalance[c]=\n#endif\n\t      ab[c] = getreal(type);\n\t}\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50730:\t\t\t/* DNG: Baseline Exposure */\n        baseline_exposure = getreal(type);\n        break;\n#endif\n\t\t  // IB start\n    case 50740:\t\t\t/* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        char mbuf[64];\n        unsigned short makernote_found = 0;\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n          {\n            order = 0x4d4d;\t\t\t\t// Adobe header is always in \"MM\" / big endian\n            curr_pos = start_pos + 6;\n            while (curr_pos + 8 - start_pos <= len)\n              {\n                fread(mbuf, 1, 4, ifp);\n                curr_pos += 8;\n                if (!strncmp(mbuf, \"MakN\", 4)) {\n                  makernote_found = 1;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n                parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n                break;\n                }\n              }\n          }\n        else\n          {\n            fread(mbuf + 6, 1, 2, ifp);\n            if (!strcmp(mbuf, \"PENTAX \") ||\n                !strcmp(mbuf, \"SAMSUNG\"))\n              {\n                makernote_found = 1;\n                fseek(ifp, start_pos, SEEK_SET);\n                parse_makernote_0xc634(base, 0, CameraDNG);\n              }\n          }\n\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      // IB end\n#endif\n      if (dng_version) break;\n      parse_minolta (j = get4()+base);\n      fseek (ifp, j, SEEK_SET);\n      parse_tiff_ifd (base);\n      break;\n    case 50752:\n      read_shorts (cr2_slice, 3);\n      break;\n    case 50829:\t\t\t/* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830:\t\t\t/* MaskedAreas */\n      for (i=0; i < len && i < 32; i++)\n        ((int*)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009:\t\t\t/* OpcodeList2 */\n      meta_offset = ftell(ifp);\n      break;\n    case 64772:\t\t\t/* Kodak P-series */\n      if (len < 13) break;\n      fseek (ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek (ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cmatrix, cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n        {\n          thumb_misc   = jh.bits;\n          thumb_width  = jh.wide;\n          thumb_height = jh.high;\n        }\n    }\n  }\n  for (i=tiff_nifds; i--; ) {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    os = raw_width*raw_height;\n    ns = tiff_ifd[i].t_width*tiff_ifd[i].t_height;\n    if (tiff_bps) {\n        os *= tiff_bps;\n        ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n\tunsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n\t ns && ((ns > os && (ties = 1)) ||\n\t\t(ns == os && shot_select == ties++))) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tiff_ifd[i].bytes;\n#endif\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n      shutter       = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties) is_raw = ties;\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2) {\n\t  tiff_bps = 14;\n\t  load_raw = &CLASS unpacked_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n\t// Sony 14-bit uncompressed\n        if(!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2)\n          {\n\t    tiff_bps = 14;\n            load_raw = &CLASS unpacked_load_raw;\n            break;\n\t  }\n        if(!strncasecmp(make,\"Nikon\",5) && !strncmp(software,\"Nikon Scan\",10))\n          {\n            load_raw = &CLASS nikon_coolscan_load_raw;\n            raw_color = 1;\n            filters = 0;\n            break;\n          }\n#endif\n\tif (!strncmp(make,\"OLYMPUS\",7) &&\n\t\ttiff_ifd[raw].bytes*2 == raw_width*raw_height*3)\n\t  load_flags = 24;\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\n\t\t   if (!strncmp(make,\"OLYMPUS\",7) &&\n\t\t\ttiff_ifd[raw].bytes*7 > raw_width*raw_height)\n\t\t     load_raw = &CLASS olympus_load_raw;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  if (model[0] == 'N') load_flags = 80;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS nikon_yuv_load_raw;\n\t  gamma_curve (1/2.4, 12.92, 1, 4095);\n\t  memset (cblack, 0, sizeof cblack);\n\t  filters = 0;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if(raw_width*raw_height*3 == tiff_ifd[raw].bytes*2)\n            {\n              load_raw = &CLASS packed_load_raw;\n              load_flags=80;\n            }\n          else if(tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n\t\t  tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n\t    {\n\t      int fit = 1;\n\t      for(int i = 0; i < tiff_ifd[raw].strip_byte_counts_count-1; i++) // all but last\n\t\tif(tiff_ifd[raw].strip_byte_counts[i]*2 != tiff_ifd[raw].rows_per_strip*raw_width*3)\n\t\t  {\n\t\t    fit = 0;\n\t\t    break;\n\t\t  }\n\t      if(fit)\n\t\tload_raw = &CLASS nikon_load_striped_packed_raw;\n\t      else\n\t\tload_raw = &CLASS nikon_load_raw; // fallback\n\t    }\n\telse\n#endif\n            load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: case 34892: break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8: break;\n#endif\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( ((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&\n\t  (tiff_compress & -16) != 32768)\n          || (tiff_bps == 8 && strncmp(make,\"Phase\",5) &&\n\t  !strcasestr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n         && strncmp(software,\"Nikon Scan\",10))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw\n        && (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33\n\t&& tiff_ifd[i].phint != 32803\n\t&& tiff_ifd[i].phint != 34892\n        && unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps)+1) >\n\t      thumb_width *       thumb_height / (SQR(thumb_misc)+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strncmp(make,\"Imacon\",6))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x524946:\t\t\t\t/* RIF */\n    if (!strncasecmp(model,\"DSLR-A100\", 9))\n    {\n      fseek(ifp, 8, SEEK_CUR);\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n      get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n    }\n\tbreak;\n#endif\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname))\n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff (int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38) {\n      parse_ciff (ftell(ifp), len, depth+1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004) parse_ciff (ftell(ifp), len, depth+1);\n#endif\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = powf64(2.0f, -int_to_float((get4(),get4())));\n      aperture = powf64(2.0f, int_to_float(get4())/2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a) {\n//      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(),get2()) + get2())/32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture  = _CanonConvertAperture((get2(),get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture  = powf64(2.0, (get2(),(short)get2())/64.0);\n#endif\n      shutter   = powf64(2.0,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n      {\n\tINT64 o = ftell(ifp);\n\tfseek (ifp, (0x5<<1), SEEK_CUR);\n\tCanon_WBpresets(0,0);\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x102d)\n      {\n\tINT64 o = ftell(ifp);\n\tCanon_CameraSettings();\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x580b)\n      {\n        if (strcmp(model,\"Canon EOS D30\")) sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n        else sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len>>16, len&0xffff);\n      }\n#endif\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[LIM(0,wbi,17)]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[LIM(0,wbi,17)]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[LIM(0,wbi,9)]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi>=0 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c) {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal  = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2) {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n\tif(imgdata.lens.makernotes.CanonFocalUnits>1)\n\t  imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834)\n      {\n         unique_id  = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n         setCanonBodyFeatures(unique_id);\n#endif\n      }\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      } else {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4) imgdata.lens.makernotes.CurAp =  powf64(2.0f, (int_to_float(data)/2.0f));\n      else imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type)/2.0f));\n      break;\n    case 0x0403:\n      if (type == 4) imgdata.lens.makernotes.CurFocal =  int_to_float(data);\n      else imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4) {\n        imgdata.lens.makernotes.MinFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n        {\n          imgdata.lens.makernotes.MinFocal = 0.0f;\n        }\n      break;\n    case 0x0417:\n      if (type == 4) {\n        imgdata.lens.makernotes.MaxFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.P1_color[0].romm_cam[i]=\n#endif\n\t  ((float *)romm_cam)[i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_col = data+base;\t\tbreak;\n      case 0x224:  ph1.split_row = data;\t\tbreak;\n      case 0x225:  ph1.black_row = data+base;\t\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x226:\n\tfor (i=0; i < 9; i++)\n\t  imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n\tbreak;\n#endif\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0]) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek (ifp, 6, SEEK_CUR);\n    fseek (ifp, meta_offset+get4(), SEEK_SET);\n    entries = get4();  get4();\n    while (entries--) {\n      tag  = get4();\n      len  = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek (ifp, meta_offset+data, SEEK_SET);\n      if (tag == 0x0407) {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        } else {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x131) {\n      filters = 9;\n      FORC(36)\n        {\n           int q = fgetc(ifp);\n           xtrans_abs[0][35 - c] = MAX(0,MIN(q,2)); /* & 3;*/\n        }\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    }\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b =fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    } else if (tag == 0x2100) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    } else if (tag == 0x2200) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    } else if (tag == 0x2300) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    } else if (tag == 0x2301) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    } else if (tag == 0x2302) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    } else if (tag == 0x2310) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    } else if (tag == 0x2400) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n    }\n#endif\n// IB end\n    else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000) tag = get4();\n      if (tag > 10000) tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len>>1);\n#endif\n\t  order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n    )\t\t/* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (save+hlen, len-hlen, 0);\n    }\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp)+7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n//@end COMMON\n\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t  is_foveon = 1;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  ((int *)poff)[i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  if (!strcmp (name, \"CAMSERIAL\"))\n\t    strcpy (imgdata.shootinginfo.BodySerial, value);\n\t  if (!strcmp (name, \"FLEQ35MM\"))\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n          if (!strcmp (name, \"LENSARANGE\"))\n            {\n              char *sp;\n              imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n              sp = strrchr (value, ' ');\n              if (sp)\n                {\n                  imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n                  if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n                    my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n                }\n            }\n          if (!strcmp (name, \"LENSFRANGE\"))\n            {\n              char *sp;\n              imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n              sp = strrchr (value, ' ');\n              if (sp)\n                {\n                  imgdata.lens.makernotes.MaxFocal = atof(sp);\n                  if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n                    my_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n                }\n            }\n          if (!strcmp (name, \"LENSMODEL\"))\n            {\n              char *sp;\n              imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);\n              if (imgdata.lens.makernotes.LensID)\n                imgdata.lens.makernotes.LensMount = Sigma_X3F;\n            }\n        }\n#endif\n    }\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n//@out COMMON\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n\t,int internal_only\n#endif\n)\n{\n  static const struct {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0,\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0, \n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp, same as sd Quattro */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if(colors>4 || colors < 1) return;\n\n  int bl4=(cblack[0]+cblack[1]+cblack[2]+cblack[3])/4,bl64=0;\n  if(cblack[4]*cblack[5]>0)\n  {\n\t  for (unsigned c = 0; c < 4096 && c < cblack[4]*cblack[5]; c++)\n\t\t  bl64+=cblack[c+6];\n\t  bl64 /= cblack[4]*cblack[5];\n  }\n  int rblack  = black+bl4+bl64;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix))) {\n      if(!dng_version)\n\t{\n\t  if (table[i].t_black>0)\n\t    {\n\t      black   = (ushort) table[i].t_black;\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  else if(table[i].t_black <0 && rblack == 0 )\n\t    {\n\t      black   = (ushort) (-table[i].t_black);\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  if (table[i].t_maximum)\n\t      maximum = (ushort) table[i].t_maximum;\n\t}\n      if (table[i].trans[0]) {\n\tfor (raw_color = j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\t\tif(internal_only)\n\t\t\timgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\t\telse\n                  imgdata.color.cam_xyz[0][j] =\n#endif\n                    ((double*)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(!internal_only)\n#endif\n          cam_xyz_coeff (rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n  string[len-1]=0;\n  if(len<3) return; // also not needed\n  len = strnlen(string,len-1);\n  for(int i=len-1; i>=0; i--)\n  {\n    if(isspace(string[i]))\n      string[i]=0;\n    else\n      break;\n  }\n}\n\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 },\n  };\n  static const ushort canon[][11] = {\n    { 1944, 1416,   0,  0, 48,  0 },\n    { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },\n    { 2224, 1456,  48,  6,  0,  2 },\n    { 2376, 1728,  12,  6, 52,  2 },\n    { 2672, 1968,  12,  6, 44,  2 },\n    { 3152, 2068,  64, 12,  0,  0, 16 },\n    { 3160, 2344,  44, 12,  4,  4 },\n    { 3344, 2484,   4,  6, 52,  6 },\n    { 3516, 2328,  42, 14,  0,  0 },\n    { 3596, 2360,  74, 12,  0,  0 },\n    { 3744, 2784,  52, 12,  8, 12 },\n    { 3944, 2622,  30, 18,  6,  2 },\n    { 3948, 2622,  42, 18,  0,  2 },\n    { 3984, 2622,  76, 20,  0,  2, 14 },\n    { 4104, 3048,  48, 12, 24, 12 },\n    { 4116, 2178,   4,  2,  0,  0 },\n    { 4152, 2772, 192, 12,  0,  0 },\n    { 4160, 3124, 104, 11,  8, 65 },\n    { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },\n    { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },\n    { 4312, 2876,  22, 18,  0,  2 },\n    { 4352, 2874,  62, 18,  0,  0 },\n    { 4476, 2954,  90, 34,  0,  0 },\n    { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },\n    { 4480, 3366,  80, 50,  0,  0 },\n    { 4496, 3366,  80, 50, 12,  0 },\n    { 4768, 3516,  96, 16,  0,  0, 0, 16 },\n    { 4832, 3204,  62, 26,  0,  0 },\n    { 4832, 3228,  62, 51,  0,  0 },\n    { 5108, 3349,  98, 13,  0,  0 },\n    { 5120, 3318, 142, 45, 62,  0 },\n    { 5280, 3528,  72, 52,  0,  0 },  /* EOS M */\n    { 5344, 3516, 142, 51,  0,  0 },\n    { 5344, 3584, 126,100,  0,  2 },\n    { 5360, 3516, 158, 51,  0,  0 },\n    { 5568, 3708,  72, 38,  0,  0 },\n    { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },\n    { 5712, 3774,  62, 20, 10,  2 },\n    { 5792, 3804, 158, 51,  0,  0 },\n    { 5920, 3950, 122, 80,  2,  0 },\n    { 6096, 4056, 72, 34,  0,  0 },     /* EOS M3 */\n    { 6288, 4056, 266, 36,  0,  0 },     /* EOS 80D */\n    { 6880, 4544, 136, 42,  0,  0 },     /* EOS 5D4 */\n    { 8896, 5920, 160, 64,  0,  0 },\n  };\n  static const struct {\n    ushort id;\n    char t_model[20];\n  } unique[] = {\n    { 0x001, \"EOS-1D\" },\n    { 0x167, \"EOS-1DS\" },\n    { 0x168, \"EOS 10D\" },\n    { 0x169, \"EOS-1D Mark III\" },\n    { 0x170, \"EOS 300D\" },\n    { 0x174, \"EOS-1D Mark II\" },\n    { 0x175, \"EOS 20D\" },\n    { 0x176, \"EOS 450D\" },\n    { 0x188, \"EOS-1Ds Mark II\" },\n    { 0x189, \"EOS 350D\" },\n    { 0x190, \"EOS 40D\" },\n    { 0x213, \"EOS 5D\" },\n    { 0x215, \"EOS-1Ds Mark III\" },\n    { 0x218, \"EOS 5D Mark II\" },\n    { 0x232, \"EOS-1D Mark II N\" },\n    { 0x234, \"EOS 30D\" },\n    { 0x236, \"EOS 400D\" },\n    { 0x250, \"EOS 7D\" },\n    { 0x252, \"EOS 500D\" },\n    { 0x254, \"EOS 1000D\" },\n    { 0x261, \"EOS 50D\" },\n    { 0x269, \"EOS-1D X\" },\n    { 0x270, \"EOS 550D\" },\n    { 0x281, \"EOS-1D Mark IV\" },\n    { 0x285, \"EOS 5D Mark III\" },\n    { 0x286, \"EOS 600D\" },\n    { 0x287, \"EOS 60D\" },\n    { 0x288, \"EOS 1100D\" },\n    { 0x289, \"EOS 7D Mark II\" },\n    { 0x301, \"EOS 650D\" },\n    { 0x302, \"EOS 6D\" },\n    { 0x324, \"EOS-1D C\" },\n    { 0x325, \"EOS 70D\" },\n    { 0x326, \"EOS 700D\" },\n    { 0x327, \"EOS 1200D\" },\n    { 0x328, \"EOS-1D X Mark II\" },\n    { 0x331, \"EOS M\" },\n    { 0x335, \"EOS M2\" },\n    { 0x374, \"EOS M3\"},   /* temp */\n    { 0x384, \"EOS M10\"},  /* temp */\n    { 0x394, \"EOS M5\"},   /* temp */\n    { 0x346, \"EOS 100D\" },\n    { 0x347, \"EOS 760D\" },\n    { 0x349, \"EOS 5D Mark IV\" },\n    { 0x350, \"EOS 80D\"},\n    { 0x382, \"EOS 5DS\" },\n    { 0x393, \"EOS 750D\" },\n    { 0x401, \"EOS 5DS R\" },\n    { 0x404, \"EOS 1300D\" },\n  }, sonique[] = {\n    { 0x002, \"DSC-R1\" },\n    { 0x100, \"DSLR-A100\" },\n    { 0x101, \"DSLR-A900\" },\n    { 0x102, \"DSLR-A700\" },\n    { 0x103, \"DSLR-A200\" },\n    { 0x104, \"DSLR-A350\" },\n    { 0x105, \"DSLR-A300\" },\n    { 0x106, \"DSLR-A900\" },\n    { 0x107, \"DSLR-A380\" },\n    { 0x108, \"DSLR-A330\" },\n    { 0x109, \"DSLR-A230\" },\n    { 0x10a, \"DSLR-A290\" },\n    { 0x10d, \"DSLR-A850\" },\n    { 0x10e, \"DSLR-A850\" },\n    { 0x111, \"DSLR-A550\" },\n    { 0x112, \"DSLR-A500\" },\n    { 0x113, \"DSLR-A450\" },\n    { 0x116, \"NEX-5\" },\n    { 0x117, \"NEX-3\" },\n    { 0x118, \"SLT-A33\" },\n    { 0x119, \"SLT-A55V\" },\n    { 0x11a, \"DSLR-A560\" },\n    { 0x11b, \"DSLR-A580\" },\n    { 0x11c, \"NEX-C3\" },\n    { 0x11d, \"SLT-A35\" },\n    { 0x11e, \"SLT-A65V\" },\n    { 0x11f, \"SLT-A77V\" },\n    { 0x120, \"NEX-5N\" },\n    { 0x121, \"NEX-7\" },\n    { 0x122, \"NEX-VG20E\"},\n    { 0x123, \"SLT-A37\" },\n    { 0x124, \"SLT-A57\" },\n    { 0x125, \"NEX-F3\" },\n    { 0x126, \"SLT-A99V\" },\n    { 0x127, \"NEX-6\" },\n    { 0x128, \"NEX-5R\" },\n    { 0x129, \"DSC-RX100\" },\n    { 0x12a, \"DSC-RX1\" },\n    { 0x12b, \"NEX-VG900\" },\n    { 0x12c, \"NEX-VG30E\" },\n    { 0x12e, \"ILCE-3000\" },\n    { 0x12f, \"SLT-A58\" },\n    { 0x131, \"NEX-3N\" },\n    { 0x132, \"ILCE-7\" },\n    { 0x133, \"NEX-5T\" },\n    { 0x134, \"DSC-RX100M2\" },\n    { 0x135, \"DSC-RX10\" },\n    { 0x136, \"DSC-RX1R\" },\n    { 0x137, \"ILCE-7R\" },\n    { 0x138, \"ILCE-6000\" },\n    { 0x139, \"ILCE-5000\" },\n    { 0x13d, \"DSC-RX100M3\" },\n    { 0x13e, \"ILCE-7S\" },\n    { 0x13f, \"ILCA-77M2\" },\n    { 0x153, \"ILCE-5100\" },\n    { 0x154, \"ILCE-7M2\" },\n    { 0x155, \"DSC-RX100M4\" },\n    { 0x156, \"DSC-RX10M2\" },\n    { 0x158, \"DSC-RX1RM2\" },\n    { 0x15a, \"ILCE-QX1\" },\n    { 0x15b, \"ILCE-7RM2\" },\n    { 0x15e, \"ILCE-7SM2\" },\n    { 0x161, \"ILCA-68\" },\n    { 0x162, \"ILCA-99M2\" },\n    { 0x163, \"DSC-RX10M3\" },\n    { 0x164, \"DSC-RX100M5\"},\n    { 0x165, \"ILCE-6300\" },\n    { 0x168, \"ILCE-6500\"},\n  };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t\n    const_table[]\n#else\n  static const struct {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  }\n  table[]\n#endif\n   = {\n    {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-080C\" },\n    {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-145C\" },\n    {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-201C\" },\n    {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\" },\n    {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\" },\n    { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-810C\" },\n    { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,\"AgfaPhoto\",\"DC-833m\" },\n    {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,\"Alcatel\",\"5035D\" },\n    {  31850496,4608,3456, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 4:3\" },\n    {  23887872,4608,2592, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 16:9\" },\n//   Android Raw dumps id start\n//   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n    {  1540857,2688,1520, 0, 0, 0, 0, 1,0x61,0,0,\"Samsung\",\"S3\" },\n    {  2658304,1212,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontMipi\" },\n    {  2842624,1296,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontQCOM\" },\n    {  2969600,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wMipi\" },\n    {  3170304,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wQCOM\" },\n    {  3763584,1584,1184, 0, 0, 0, 0, 96,0x61,0,0,\"I_Mobile\",\"I_StyleQ6\" },\n    {  5107712,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel1\" },\n    {  5382640,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel2\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5364240,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  6299648,2592,1944, 0, 0, 0, 0, 1 ,0x16,0,0,\"OmniVisi\",\"OV5648\" },\n    {  6721536,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"OmniVisi\",\"OV56482\" },\n    {  6746112,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"OneSV\" },\n    {  9631728,2532,1902, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"5mp\" },\n    {  9830400,2560,1920, 0, 0, 0, 0, 96,0x61,0,0,\"NGM\",\"ForwardArt\" },\n    { 10186752,3264,2448, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX219-mipi 8mp\" },\n    { 10223360,2608,1944, 0, 0, 0, 0, 96,0x16,0,0,\"Sony\",\"IMX\" },\n    { 10782464,3282,2448, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"MyTouch4GSlide\" },\n    { 10788864,3282,2448, 0, 0, 0, 0, 0, 0x16,0,0,\"Xperia\",\"L\" },\n    { 15967488,3264,2446, 0, 0, 0, 0, 96,0x16,0,0,\"OmniVison\",\"OV8850\" },\n    { 16224256,4208,3082, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3MipiL\" },\n    { 16424960,4208,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"IMX135\",\"MipiL\" },\n    { 17326080,4164,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3LQCom\" },\n    { 17522688,4212,3120, 0, 0, 0, 0, 0,0x16,0,0,\"Sony\",\"IMX135-QCOM\" },\n    { 19906560,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7mipi\" },\n    { 19976192,5312,2988, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G4\" },\n    { 20389888,4632,3480, 0, 0, 0, 0, 1, 0x16,0,0,\"Xiaomi\",\"RedmiNote3Pro\" },\n    { 20500480,4656,3496, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX298-mipi 16mp\" },\n    { 21233664,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7qcom\" },\n    { 26023936,4192,3104, 0, 0, 0, 0, 96,0x94,0,0,\"THL\",\"5000\" },\n    { 26257920,4208,3120, 0, 0, 0, 0, 96,0x94,0,0,\"Sony\",\"IMX214\" },\n    { 26357760,4224,3120, 0, 0, 0, 0, 96,0x61,0,0,\"OV\",\"13860\" },\n    { 41312256,5248,3936, 0, 0, 0, 0, 96,0x61,0,0,\"Meizu\",\"MX4\" },\n    { 42923008,5344,4016, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"IMX230\" },\n    //   Android Raw dumps id end\n    {  20137344,3664,2748,0, 0, 0, 0,0x40,0x49,0,0,\"Aptina\",\"MT9J003\",0xffff },\n    {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,\"Baumer\",\"TXG14\",1078 },\n    {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,\"Canon\",\"PowerShot SD300\" },\n    {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,\"Canon\",\"PowerShot A460\" },\n    {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,\"Canon\",\"PowerShot A610\" },\n    {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,\"Canon\",\"PowerShot A530\" },\n    {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot S3 IS\" },\n    {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot A620\" },\n    {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,\"Canon\",\"PowerShot A470\" },\n    { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,\"Canon\",\"PowerShot A720 IS\" },\n    { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,\"Canon\",\"PowerShot A630\" },\n    { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,\"Canon\",\"PowerShot A640\" },\n    { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot A650\" },\n    { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,\"Canon\",\"PowerShot SX110 IS\" },\n    { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,\"Canon\",\"PowerShot SX120 IS\" },\n    { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot SX20 IS\" },\n    { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,\"Canon\",\"PowerShot SX220 HS\" },\n    { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,\"Canon\",\"PowerShot SX30 IS\" },\n    { 24724224,4704,3504, 8,16,56, 8,40,0x49,0,2,\"Canon\",\"PowerShot A3300 IS\" },\n    { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,\"Canon\",\"IXUS 160\" },\n    {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,\"Casio\",\"QV-2000UX\" },\n    {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,\"Casio\",\"QV-3*00EX\" },\n    {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,\"Casio\",\"QV-5700\" },\n    {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,\"Casio\",\"EX-Z60\" },\n    {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,\"Casio\",\"EX-S20\" },\n    {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,\"Casio\",\"EX-S100\" },\n    {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,\"Casio\",\"QV-R41\" },\n    {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,\"Casio\",\"EX-P505\" },\n    {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,\"Casio\",\"QV-R51\" },\n    {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,\"Casio\",\"EX-Z50\" },\n    {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,\"Casio\",\"EX-Z500\" },\n    {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,\"Casio\",\"EX-Z55\" },\n    {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,\"Casio\",\"EX-P600\" },\n    { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,\"Casio\",\"EX-Z750\" },\n    { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,\"Casio\",\"EX-Z75\" },\n    { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,\"Casio\",\"EX-P700\" },\n    { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,\"Casio\",\"EX-Z850\" },\n    { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,\"Casio\",\"EX-Z8\" },\n    { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,\"Casio\",\"EX-Z1050\" },\n    { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,\"Casio\",\"EX-ZR100\" },\n    {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,\"Casio\",\"QV-4000\" },\n    {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,\"Creative\",\"PC-CAM 600\" },\n    { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,\"DJI\" },\n    { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,\"Matrix\" },\n    {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,\"Foculus\",\"531C\" },\n    {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,\"Generic\" },\n    {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,\"Kodak\",\"DCS200\" },\n    {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\" },\n    {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\",3160 },\n    {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\" },\n    {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\",3160 },\n    {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\" },\n    { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\",31556 },\n    { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"12MP\" },\n    {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,\"Kodak\",\"KAI-0340\" },\n    { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,\"Lenovo\",\"A820\" },\n    {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,\"Micron\",\"2010\",3212 },\n    {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,\"Minolta\",\"RD175\",513 },\n    {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,\"Nikon\",\"E900\" },\n    {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,\"Nikon\",\"E950\" },\n    {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,\"Nikon\",\"E2100\" },\n    {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,\"Nikon\",\"E990\" },\n    {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,\"Nikon\",\"E3700\" },\n    {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E4500\" },\n    {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,\"Nikon\",\"E4300\" },\n    {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E5000\" },\n    {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,\"Nikon\",\"COOLPIX S6\" },\n    {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,\"Olympus\",\"C770UZ\" },\n    {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,\"Pentax\",\"Optio S\" },\n    {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S\" },\n    {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S4\" },\n    { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,\"Pentax\",\"Optio 750Z\" },\n    {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\" },\n    {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\",8 },\n    { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,\"Pixelink\",\"A782\" },\n    {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,\"RoverShot\",\"3320AF\" },\n    {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,\"ST Micro\",\"STV680 VGA\" },\n    { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n    {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n  };\n#ifdef LIBRAW_LIBRARY_BUILD\n    libraw_custom_camera_t\n      table[64 + sizeof(const_table)/sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] =\n    { \"AgfaPhoto\", \"Canon\", \"Casio\", \"Epson\", \"Fujifilm\",\n      \"Mamiya\", \"Minolta\", \"Motorola\", \"Kodak\", \"Konica\", \"Leica\",\n      \"Nikon\", \"Nokia\", \"Olympus\", \"Pentax\", \"Phase One\", \"Ricoh\",\n      \"Samsung\", \"Sigma\", \"Sinar\", \"Sony\" };\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize=1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64,table,imgdata.params.custom_camera_strings);\n  for(int q = 0; q < sizeof(const_table)/sizeof(const_table[0]); q++)\n\tmemmove(&table[q+camera_count],&const_table[q],sizeof(const_table[0]));\n  camera_count += sizeof(const_table)/sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX;\t/* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread (head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread (head, 1, 32, ifp);\n#endif\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (hlen, flen-hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 52, SEEK_SET);\n    switch (get4()) {\n      case  7: iso_speed = 25;  break;\n      case  8: iso_speed = 32;  break;\n      case  9: iso_speed = 40;  break;\n      case 10: iso_speed = 50;  break;\n      case 11: iso_speed = 64;  break;\n      case 12: iso_speed = 80;  break;\n      case 13: iso_speed = 100; break;\n      case 14: iso_speed = 125; break;\n      case 15: iso_speed = 160; break;\n      case 16: iso_speed = 200; break;\n      case 17: iso_speed = 250; break;\n      case 18: iso_speed = 320; break;\n      case 19: iso_speed = 400; break;\n    }\n    shutter = powf64(2.0f, (((float)get4())/8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek (ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek (ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head+0x1c);\n    memcpy(model2, head+0x3c, 4);\n    model2[4]=0;\n#endif\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4())?1:0;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head+4,\"ftypqt   \",9)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_qt (fsize);\n    is_raw = 0;\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i*8 / (width * height)) {\n      case  8: load_raw = &CLASS eight_bit_load_raw;  break;\n      case 10: load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"XPDS\",4)) {\n    order = 0x4949;\n    fseek (ifp, 0x800, SEEK_SET);\n    fread (make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width  = get2();\n    fseek (ifp, 56, SEEK_CUR);\n    fread (model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve (0, 12.25, 1, 1023);\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"Red\");\n    strcpy (model,\"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n  else if (!memcmp (head,\"FOVb\",4))\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n        parse_foveon();\n      else\n#endif\n        parse_x3f();\n#else\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      parse_foveon();\n#endif\n#endif\n    }\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  if(make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize=i=0; i < camera_count; i++)\n#else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\",5))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          }\n#endif\n\tstrcpy (model, table[i].t_model);\n\tflip = table[i].flags >> 2;\n\tzero_is_bad = table[i].flags & 2;\n\tif (table[i].flags & 1)\n\t  parse_external_jpeg();\n\tdata_offset = table[i].offset == 0xffff?0:table[i].offset;\n\traw_width   = table[i].rw;\n\traw_height  = table[i].rh;\n\tleft_margin = table[i].lm;\n\t top_margin = table[i].tm;\n\twidth  = raw_width - left_margin - table[i].rm;\n\theight = raw_height - top_margin - table[i].bm;\n\tfilters = 0x1010101 * table[i].cf;\n\tcolors = 4 - !((filters & filters >> 1) & 0x5555);\n\tload_flags = table[i].lf;\n\tswitch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {\n\t  case 6:\n\t    load_raw = &CLASS minolta_rd175_load_raw;  break;\n\t  case 8:\n\t    load_raw = &CLASS eight_bit_load_raw;  break;\n\t  case 10:\n           if ((fsize-data_offset)/raw_height*3 >= raw_width*4) {\n             load_raw = &CLASS android_loose_load_raw;  break;\n           } else if (load_flags & 1) {\n             load_raw = &CLASS android_tight_load_raw;  break;\n           }\n\t  case 12:\n\t    load_flags |= 128;\n\t    load_raw = &CLASS packed_load_raw;     break;\n\t  case 16:\n\t    order = 0x4949 | 0x404 * (load_flags & 1);\n\t    tiff_bps -= load_flags >> 4;\n\t    tiff_bps -= load_flags = load_flags >> 1 & 7;\n\t    load_raw = table[i].offset == 0xffff ? &CLASS  unpacked_load_raw_reversed : &CLASS  unpacked_load_raw;\n\t}\n\tmaximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model,\"RP_imx219\",9) && sz >= 0x9cb600 &&\n        !fseek (ifp, -0x9cb600, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n\tstrcpy (make, \"Broadcom\");\n\tstrcpy (model, \"RPi IMX219\");\n\tif (raw_height > raw_width) flip = 5;\n\tdata_offset = ftell(ifp) + 0x8000 - 0x20;\n\tparse_broadcom();\n\tblack = 66;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    } else\n      if (!(strncmp(model,\"ov5647\",6) && strncmp(model,\"RP_OV5647\",9)) && sz >= 0x61b800 &&\n        !fseek (ifp, -0x61b800, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n      strcpy (make, \"Broadcom\");\n      if (!strncmp(model,\"ov5647\",6))\n        strcpy (model, \"RPi OV5647 v.1\");\n      else\n        strcpy (model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width) flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n\tblack = 16;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model,\"ov\",2) && strncmp(model,\"RP_OV\",5)) && sz>=6404096 &&\n        !fseek (ifp, -6404096, SEEK_END) &&\n\t  fread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    } else is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr (make, corp[i]))\t/* Simplify company names */\n\t    strcpy (make, corp[i]);\n  if ((!strncmp(make,\"Kodak\",5) || !strncmp(make,\"Leica\",5)) &&\n\t((cp = strcasestr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  if (!strncasecmp(model,\"PENTAX\",6))\n    strcpy (make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make,sizeof(make));\n  remove_trailing_spaces(model,sizeof(model));\n#else\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n#endif\n  i = strbuflen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width == 6080 && !strcmp(model,\"K-70\"))\n     { height  = 4016; top_margin=32; width=6020; left_margin = 60; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 6080 && !strcmp(model,\"K-3 II\")) /* moved back */\n    { left_margin = 4;  width  = 6040; }\n  if (width == 6080 && !strcmp(model,\"K-3\"))\n    { left_margin = 4;  width  = 6040; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw *= tiff_samples;\n    else\t colors  = tiff_samples;\n    switch (tiff_compress) {\n      case 0:  /* Compression not set, assuming uncompressed */\n      case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;\n      case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8:     load_raw = &CLASS  deflate_dng_load_raw;  break;\n#endif\n      case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;\n      default:    load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\",5) && unique_id)\n      {\n        for (i = 0; i < sizeof unique / sizeof *unique; i++)\n          if (unique_id == 0x80000000 + unique[i].id)\n            {\n              strcpy(model, unique[i].t_model);\n              break;\n            }\n      }\n    if (!strncasecmp(make, \"Sony\",4) && unique_id)\n      {\n        for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n          if (unique_id == sonique[i].id)\n            {\n              strcpy(model, sonique[i].t_model);\n              break;\n            }\n      }\n    goto dng_skip;\n  }\n  if (!strncmp(make,\"Canon\",5) && !fsize && tiff_bps != 15) {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i=0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1]) {\n\twidth  = raw_width - (left_margin = canon[i][2]);\n\theight = raw_height - (top_margin = canon[i][3]);\n\twidth  -= canon[i][4];\n\theight -= canon[i][5];\n\tmask[0][1] =  canon[i][6];\n\tmask[0][3] = -canon[i][7];\n\tmask[1][1] =  canon[i][8];\n\tmask[1][3] = -canon[i][9];\n\tif (canon[i][10]) filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000) {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make,\"Canon\",5) && unique_id)\n    {\n      for (i=0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n          {\n            adobe_coeff (\"Canon\", unique[i].t_model);\n            strcpy(model,unique[i].t_model);\n          }\n    }\n\n  if (!strncasecmp(make,\"Sony\",4) && unique_id)\n    {\n      for (i=0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n          {\n            adobe_coeff (\"Sony\", sonique[i].t_model);\n            strcpy(model,sonique[i].t_model);\n          }\n    }\n\n  if (!strncmp(make,\"Nikon\",5)) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model,\"KAI-0340\")\n\t&& find_green (16, 16, 3840, 5120) < 25) {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy (model,\"C603\");\n  }\n\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if(!strncmp(make,\"Pentax\",6))\n  {\n    if(!strncmp(model,\"K-1\",3))\n    {\n  \ttop_margin = 18;\n \theight = raw_height - top_margin;\n\tif(raw_width == 7392)\n\t{\n\t  left_margin = 6;\n\t  width = 7376;\n\t}\n    }\n  }\n  else if (!strncmp(make,\"Canon\",5) && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) {\n      SWAP(height,width);\n      SWAP(raw_height,raw_width);\n    }\n    if (width == 7200 && height == 3888)\n      {\n\traw_width  = width  = 6480;\n\traw_height = height = 4320;\n      }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    filters = 0x1e4b4e1b;\ncanon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\") ||\n\t     !strcmp(model,\"PowerShot G1\")) {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    mask[1][3] = -4;\n    top_margin=16;\n    left_margin = 92;\n  } else if (!strcmp(model,\"PowerShot S120\")) {\n        raw_width = 4192;\n        raw_height = 3062;\n        width = 4022;\n        height = 3016;\n        mask[0][0] = top_margin = 31;\n        mask[0][2] = top_margin + height;\n        left_margin = 120;\n        mask[0][1] = 23;\n        mask[0][3] = 72;\n  } else if (!strcmp(model,\"PowerShot G16\")) {\n      mask[0][0] = 0;\n      mask[0][2] = 80;\n      mask[0][1] = 0;\n      mask[0][3] = 16;\n      top_margin = 29;\n      left_margin = 120;\n      width = raw_width-left_margin-48;\n      height = raw_height-top_margin-14;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin = 17;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\") ||\n\t     !strcmp(model,\"COOLPIX A\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t    !strncmp(model,\"D6\",2)  ||\n\t    !strncmp(model,\"D800\",4)) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\") ||\n\t     !strcmp(model,\"Df\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strncmp(make,\"Nikon\",5) && raw_width == 4032) {\n    if(!strcmp(model,\"COOLPIX P7700\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7700\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else if(!strcmp(model,\"COOLPIX P7800\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7800\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else  if(!strcmp(model,\"COOLPIX P340\"))\n      load_flags=0;\n  } else if (!strncmp(model,\"COOLPIX P\",9) && raw_width != 4032) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed==0) && !strstr(software,\"V1.2\") )\n      black = 255;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  } else if (fsize == 3178560) {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  } else if (fsize == 4771840) {\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (fsize == 2940928) {\n    if (!timestamp && !nikon_e2100())\n      strcpy (model,\"E2500\");\n    if (!strcmp(model,\"E2500\")) {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  } else if (fsize == 4775936) {\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (fsize == 6291456) {\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strncmp(make,\"Fujifilm\",8)) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848 || width == 3664) filters = 0x16161616;\n    if (width == 4032 || width == 4952) left_margin = 0;\n    if (width == 3328 && (width -= 66)) left_margin = 34;\n    if (width == 4936) left_margin = 4;\n    if (width == 6032) left_margin = 0;\n    if (!strcmp(model,\"HS50EXR\") ||\n\t!strcmp(model,\"F900EXR\")) {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if(!strcmp(model,\"S5500\"))\n      {\n        height -= (top_margin=6);\n      }\n    if (fuji_layout) raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36) ((char *)xtrans)[c] =\n\txtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strncasecmp(make,\"Minolta\",7)) {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strncmp(make,\"Samsung\",7) && !strcmp(model,\"NX3000\")) {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_height == 3714) {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5664) {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 6496) {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n    black = 1 << (tiff_bps - 7);\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (strstr(model,\"WB550\")) {\n    strcpy (model, \"WB550\");\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3030;\n    width  = 4040;\n    top_margin = 15;\n    left_margin=24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    black = 16;\n  } else if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"640x480\")) {\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strncmp(make,\"Hasselblad\",10)) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if(!strncasecmp(model,\"H3D\",3))\n        {\n          adobe_coeff(\"Hasselblad\",\"H3DII-39\");\n          strcpy(model,\"H3DII-39\");\n        }\n    } else if (raw_width == 7410 || raw_width == 8282) {\n      height -= 84;\n      width  -= 82;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\",\"H4D-40\");\n      strcpy(model,\"H4D-40\");\n    }\n    else if( raw_width == 8384) // X1D\n    {\n     top_margin  = 96;\n     height -= 96;\n     left_margin = 48;\n     width  -= 106;\n     adobe_coeff(\"Hasselblad\",\"X1D\");\n    }\n    else if (raw_width == 9044) {\n      if(black > 500)\n        {\n          top_margin = 12;\n          left_margin = 44;\n          width = 8956;\n          height = 6708;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H4D-60\");\n          strcpy(model,\"H4D-60\");\n          black = 512;\n        }\n      else\n        {\n          height = 6716;\n          width  = 8964;\n          top_margin  = 8;\n          left_margin = 40;\n          black += load_flags = 256;\n          maximum = 0x8101;\n          strcpy(model,\"H3DII-60\");\n        }\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    } else if (raw_width == 8282 && raw_height == 6240) {\n      if(!strncasecmp(model,\"H5D\",3))\n        {\n          /* H5D 50*/\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          black = 256;\n          strcpy(model,\"H5D-50\");\n        }\n      else if(!strncasecmp(model,\"H3D\",3))\n        {\n          black=0;\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H3D-50\");\n          strcpy(model,\"H3D-50\");\n        }\n    } else if (raw_width == 8374 && raw_height == 6304) {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model,\"H5D-50c\");\n    }\n    if (tiff_samples > 1) {\n      is_raw = tiff_samples+1;\n      if (!shot_select && !half_size) filters = 0;\n    }\n  } else if (!strncmp(make,\"Sinar\",5)) {\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size) filters = 0;\n    maximum = 0x3fff;\n  } else if (!strncmp(make,\"Leaf\",4)) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strncmp(make,\"Leica\",5) || !strncmp(make,\"Panasonic\",9)\n      || !strncasecmp(make,\"YUNEEC\",6)) {\n    if (raw_width > 0&& ((flen - data_offset) / (raw_width*8/7) == raw_height) )\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strncmp(make,\"Olympus\",7)) {\n    height += height & 1;\n    if (exif_cfa) filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (width == 9280) { width -= 6; height -= 6; }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"STYLUS1\")) {\n      width -= 14;\n      maximum = 0xfff;\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"TG-4\")) {\n      width -= 16;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 3984) {\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4288) {\n    width -= 32;\n  }  else if (!strcmp(make, \"Sony\") && raw_width == 4600) {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4928) {\n    if (height < 3280) width -= 8;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 5504) { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 6048) {\n    width -= 24;\n    if (strstr(model,\"RX1\") || strstr(model,\"A99\"))\n      width -= 6;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 7392) {\n    width -= 30;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 8000) {\n    width -= 32;\n    if (!strncmp(model, \"DSC\", 3)) {\n      tiff_bps = 14;\n      load_raw = &CLASS unpacked_load_raw;\n    }\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      height -= 4;\n      width  -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603\") || !strcmp(model,\"C330\")\n\t|| !strcmp(model,\"12MP\")) {\n    order = 0x4949;\n    if (filters && data_offset) {\n      fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw  =  filters   ? &CLASS eight_bit_load_raw :\n      strcmp(model,\"C330\") ? &CLASS kodak_c603_load_raw :\n\t\t\t     &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strncasecmp(make,\"Kodak\",5)) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6) ||\n\t!strncmp(model,\"EOSDCS\",6) ||\n\t!strncmp(model,\"DCS4\",4)) {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ') model[6] = 0;\n      if (!strcmp(model,\"DCS460A\")) goto bw;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      goto bw;\n    } else if (!strcmp(model,\"DCS760M\")) {\nbw:   colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      iso_speed=84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      iso_speed=160;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      iso_speed=140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strncmp(make,\"Rollei\",6) && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(dng_version) /* Override black level by DNG tags */\n  {\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0,\n    (sizeof(cblack)/sizeof(cblack[0])),\n    (sizeof(imgdata.color.dng_levels.dng_cblack)/sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for(int i=0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2) )\n\t&& cmatrix[0][0] > 0.125) {\n    memcpy (rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color) adobe_coeff (make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(imgdata.color.cam_xyz[0][0]<0.01)\n\t  adobe_coeff (make, model,1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum)\n    {\n      maximum = (1 << tiff_bps) - 1;\n      if(maximum < 0x10000 && curve[maximum]>0 &&    load_raw == &CLASS sony_arw2_load_raw)\n        maximum = curve[maximum];\n    }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if(raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX) flip = tiff_flip;\n  if (flip == UINT_MAX) flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if(flip > 89 || flip < -89)\n   {\n     switch ((flip+3600) % 360)\n     {\n       case 270:  flip = 5;  break;\n       case 180:  flip = 3;  break;\n       case  90:  flip = 6;  break;\n     }\n   }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\n\n//@end COMMON\n\n//@out FILEIO\n#ifndef NO_LCMS\nvoid CLASS apply_profile (const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile=0, hOutProfile=0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n  if (strcmp (input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile (input, \"r\");\n  else if (profile_length) {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *) malloc (profile_length);\n    merror (prof, \"apply_profile()\");\n    fseek (ifp, profile_offset, SEEK_SET);\n    fread (prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem (prof, profile_length);\n    free (prof);\n#else\n    hInProfile = cmsOpenProfileFromMem (imgdata.color.profile, profile_length);\n#endif\n  } else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n    }\n  if (!hInProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n          return;\n      }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen (output, \"rb\"))) {\n    fread (&size, 4, 1, fp);\n    fseek (fp, 0, SEEK_SET);\n    oprof = (unsigned *) malloc (size = ntohl(size));\n    merror (oprof, \"apply_profile()\");\n    fread (oprof, 1, size, fp);\n    fclose (fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {\n      free (oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n else\n    fprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n          goto quit;\n      }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,0,2);\n#endif\n  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\n\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform (hTransform, image, image, width*height);\n  raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\n  cmsDeleteTransform (hTransform);\n  cmsCloseProfile (hOutProfile);\nquit:\n  cmsCloseProfile (hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE,1,2);\n#endif\n}\n#endif\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double aces_rgb[3][3] =\n  { { 0.432996, 0.375380, 0.189317 },\n    { 0.089427, 0.816523, 0.102989 },\n    { 0.019165, 0.118150, 0.941914 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 ||\n\t\toutput_color < 1 || output_color > 6;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (high, wide*sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n//@end COMMON\n\n\nstruct tiff_tag {\n  ushort tag, type;\n  int count;\n  union { char c[4]; short s[2]; int i; } val;\n};\n\nstruct tiff_hdr {\n  ushort t_order, magic;\n  int ifd;\n  ushort pad, ntag;\n  struct tiff_tag tag[23];\n  int nextifd;\n  ushort pad2, nexif;\n  struct tiff_tag exif[4];\n  ushort pad3, ngps;\n  struct tiff_tag gpst[10];\n  short bps[4];\n  int rat[10];\n  unsigned gps[26];\n  char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];\n};\n\n//@out COMMON\n\nvoid CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2) {\n    count = strnlen((char *)th + val, count-1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val+c];\n  } else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n  if (full) {\n    tiff_set (th, &th->ntag, 254, 4, 1, 0);\n    tiff_set (th, &th->ntag, 256, 4, 1, width);\n    tiff_set (th, &th->ntag, 257, 4, 1, height);\n    tiff_set (th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (th, &th->ntag, 259, 3, 1, 1);\n    tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (th, &th->ntag, 277, 3, 1, colors);\n    tiff_set (th, &th->ntag, 278, 4, 1, height);\n    tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (th, &th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (th, &th->ntag, 284, 3, 1, 1);\n  tiff_set (th, &th->ntag, 296, 3, 1, 2);\n  tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (th, &th->ngps,  0, 1,  4, 0x202);\n    tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n#endif\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n//@end COMMON\n\nint CLASS main (int argc, const char **argv)\n{\n  int arg, status=0, quality, i, c;\n  int timestamp_only=0, thumbnail_only=0, identify_only=0;\n  int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;\n  int use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;\n  const char *sp, *bpfile=0, *dark_frame=0, *write_ext;\n  char opm, opt, *ofname, *cp;\n  struct utimbuf ut;\n#ifndef NO_LCMS\n  const char *cam_profile=0, *out_profile=0;\n#endif\n\n#ifndef LOCALTIME\n  putenv ((char *) \"TZ=UTC\");\n#endif\n#ifdef LOCALEDIR\n  setlocale (LC_CTYPE, \"\");\n  setlocale (LC_MESSAGES, \"\");\n  bindtextdomain (\"dcraw\", LOCALEDIR);\n  textdomain (\"dcraw\");\n#endif\n\n  if (argc == 1) {\n    printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\n    puts(_(\"-v        Print verbose messages\"));\n    puts(_(\"-c        Write image data to standard output\"));\n    puts(_(\"-e        Extract embedded thumbnail image\"));\n    puts(_(\"-i        Identify files without decoding them\"));\n    puts(_(\"-i -v     Identify files and show metadata\"));\n    puts(_(\"-z        Change file dates to camera timestamp\"));\n    puts(_(\"-w        Use camera white balance, if possible\"));\n    puts(_(\"-a        Average the whole image for white balance\"));\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\n    puts(_(\"-r <r g b g> Set custom white balance\"));\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\n    puts(_(\"-k <num>  Set the darkness level\"));\n    puts(_(\"-S <num>  Set the saturation level\"));\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\n#ifndef NO_LCMS\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\n#endif\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\n    puts(_(\"-W        Don't automatically brighten the image\"));\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\n    puts(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\n    puts(_(\"-6        Write 16-bit instead of 8-bit\"));\n    puts(_(\"-4        Linear 16-bit, same as \\\"-6 -W -g 1 1\\\"\"));\n    puts(_(\"-T        Write TIFF instead of PPM\"));\n    puts(\"\");\n    return 1;\n  }\n  argv[argc] = \"\";\n  for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {\n    opt = argv[arg++][1];\n    if ((cp = (char *) strchr (sp=\"nbrkStqmHACg\", opt)))\n      for (i=0; i < \"114111111422\"[cp-sp]-'0'; i++)\n\tif (!isdigit(argv[arg+i][0])) {\n\t  fprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\n\t  return 1;\n\t}\n    switch (opt) {\n      case 'n':  threshold   = atof(argv[arg++]);  break;\n      case 'b':  bright      = atof(argv[arg++]);  break;\n      case 'r':\n\t   FORC4 user_mul[c] = atof(argv[arg++]);  break;\n      case 'C':  aber[0] = 1 / atof(argv[arg++]);\n\t\t aber[2] = 1 / atof(argv[arg++]);  break;\n      case 'g':  gamm[0] =     atof(argv[arg++]);\n\t\t gamm[1] =     atof(argv[arg++]);\n\t\t if (gamm[0]) gamm[0] = 1/gamm[0]; break;\n      case 'k':  user_black  = atoi(argv[arg++]);  break;\n      case 'S':  user_sat    = atoi(argv[arg++]);  break;\n      case 't':  user_flip   = atoi(argv[arg++]);  break;\n      case 'q':  user_qual   = atoi(argv[arg++]);  break;\n      case 'm':  med_passes  = atoi(argv[arg++]);  break;\n      case 'H':  highlight   = atoi(argv[arg++]);  break;\n      case 's':\n\tshot_select = abs(atoi(argv[arg]));\n\tmulti_out = !strcmp(argv[arg++],\"all\");\n\tbreak;\n      case 'o':\n\tif (isdigit(argv[arg][0]) && !argv[arg][1])\n\t  output_color = atoi(argv[arg++]);\n#ifndef NO_LCMS\n\telse     out_profile = argv[arg++];\n\tbreak;\n      case 'p':  cam_profile = argv[arg++];\n#endif\n\tbreak;\n      case 'P':  bpfile     = argv[arg++];  break;\n      case 'K':  dark_frame = argv[arg++];  break;\n      case 'z':  timestamp_only    = 1;  break;\n      case 'e':  thumbnail_only    = 1;  break;\n      case 'i':  identify_only     = 1;  break;\n      case 'c':  write_to_stdout   = 1;  break;\n      case 'v':  verbose           = 1;  break;\n      case 'h':  half_size         = 1;  break;\n      case 'f':  four_color_rgb    = 1;  break;\n      case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);\n      case 'a':  use_auto_wb       = 1;  break;\n      case 'w':  use_camera_wb     = 1;  break;\n      case 'M':  use_camera_matrix = 3 * (opm == '+');  break;\n      case 'I':  read_from_stdin   = 1;  break;\n      case 'E':  document_mode++;\n      case 'D':  document_mode++;\n      case 'd':  document_mode++;\n      case 'j':  use_fuji_rotate   = 0;  break;\n      case 'W':  no_auto_bright    = 1;  break;\n      case 'T':  output_tiff       = 1;  break;\n      case '4':  gamm[0] = gamm[1] =\n\t\t no_auto_bright    = 1;\n      case '6':  output_bps       = 16;  break;\n      default:\n\tfprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);\n\treturn 1;\n    }\n  }\n  if (arg == argc) {\n    fprintf (stderr,_(\"No files to process.\\n\"));\n    return 1;\n  }\n  if (write_to_stdout) {\n    if (isatty(1)) {\n      fprintf (stderr,_(\"Will not write an image to the terminal!\\n\"));\n      return 1;\n    }\n#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)\n    if (setmode(1,O_BINARY) < 0) {\n      perror (\"setmode()\");\n      return 1;\n    }\n#endif\n  }\n  for ( ; arg < argc; arg++) {\n    status = 1;\n    raw_image = 0;\n    image = 0;\n    oprof = 0;\n    meta_data = ofname = 0;\n    ofp = stdout;\n    if (setjmp (failure)) {\n      if (fileno(ifp) > 2) fclose(ifp);\n      if (fileno(ofp) > 2) fclose(ofp);\n      status = 1;\n      goto cleanup;\n    }\n    ifname = argv[arg];\n    if (!(ifp = fopen (ifname, \"rb\"))) {\n      perror (ifname);\n      continue;\n    }\n    status = (identify(),!is_raw);\n    if (user_flip >= 0)\n      flip = user_flip;\n    switch ((flip+3600) % 360) {\n      case 270:  flip = 5;  break;\n      case 180:  flip = 3;  break;\n      case  90:  flip = 6;\n    }\n    if (timestamp_only) {\n      if ((status = !timestamp))\n\tfprintf (stderr,_(\"%s has no timestamp.\\n\"), ifname);\n      else if (identify_only)\n\tprintf (\"%10ld%10d %s\\n\", (long) timestamp, shot_order, ifname);\n      else {\n\tif (verbose)\n\t  fprintf (stderr,_(\"%s time set to %d.\\n\"), ifname, (int) timestamp);\n\tut.actime = ut.modtime = timestamp;\n\tutime (ifname, &ut);\n      }\n      goto next;\n    }\n    write_fun = &CLASS write_ppm_tiff;\n    if (thumbnail_only) {\n      if ((status = !thumb_offset)) {\n\tfprintf (stderr,_(\"%s has no thumbnail.\\n\"), ifname);\n\tgoto next;\n      } else if (thumb_load_raw) {\n\tload_raw = thumb_load_raw;\n\tdata_offset = thumb_offset;\n\theight = thumb_height;\n\twidth  = thumb_width;\n\tfilters = 0;\n\tcolors = 3;\n      } else {\n\tfseek (ifp, thumb_offset, SEEK_SET);\n\twrite_fun = write_thumb;\n\tgoto thumbnail;\n      }\n    }\n    if (load_raw == &CLASS kodak_ycbcr_load_raw) {\n      height += height & 1;\n      width  += width  & 1;\n    }\n\n    if (identify_only && verbose && make[0]) {\n      printf (_(\"\\nFilename: %s\\n\"), ifname);\n      printf (_(\"Timestamp: %s\"), ctime(&timestamp));\n      printf (_(\"Camera: %s %s\\n\"), make, model);\n      if (artist[0])\n\tprintf (_(\"Owner: %s\\n\"), artist);\n      if (dng_version) {\n\tprintf (_(\"DNG Version: \"));\n\tfor (i=24; i >= 0; i -= 8)\n\t  printf (\"%d%c\", dng_version >> i & 255, i ? '.':'\\n');\n      }\n      printf (_(\"ISO speed: %d\\n\"), (int) iso_speed);\n      printf (_(\"Shutter: \"));\n      if (shutter > 0 && shutter < 1)\n\tshutter = (printf (\"1/\"), 1 / shutter);\n      printf (_(\"%0.1f sec\\n\"), shutter);\n      printf (_(\"Aperture: f/%0.1f\\n\"), aperture);\n      printf (_(\"Focal length: %0.1f mm\\n\"), focal_len);\n      printf (_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\"):_(\"no\"));\n      printf (_(\"Number of raw images: %d\\n\"), is_raw);\n      if (pixel_aspect != 1)\n\tprintf (_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);\n      if (thumb_offset)\n\tprintf (_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);\n      printf (_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);\n    } else if (!is_raw)\n      fprintf (stderr,_(\"Cannot decode file %s\\n\"), ifname);\n    if (!is_raw) goto next;\n    shrink = filters && (half_size || (!identify_only &&\n\t(threshold || aber[0] != 1 || aber[2] != 1)));\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (identify_only) {\n      if (verbose) {\n\tif (document_mode == 3) {\n\t  top_margin = left_margin = fuji_width = 0;\n\t  height = raw_height;\n\t  width  = raw_width;\n\t}\n\tiheight = (height + shrink) >> shrink;\n\tiwidth  = (width  + shrink) >> shrink;\n\tif (use_fuji_rotate) {\n\t  if (fuji_width) {\n\t    fuji_width = (fuji_width - 1 + shrink) >> shrink;\n\t    iwidth = fuji_width / sqrt(0.5);\n\t    iheight = (iheight - fuji_width) / sqrt(0.5);\n\t  } else {\n\t    if (pixel_aspect < 1) iheight = iheight / pixel_aspect + 0.5;\n\t    if (pixel_aspect > 1) iwidth  = iwidth  * pixel_aspect + 0.5;\n\t  }\n\t}\n\tif (flip & 4)\n\t  SWAP(iheight,iwidth);\n\tprintf (_(\"Image size:  %4d x %d\\n\"), width, height);\n\tprintf (_(\"Output size: %4d x %d\\n\"), iwidth, iheight);\n\tprintf (_(\"Raw colors: %d\"), colors);\n\tif (filters) {\n\t  int fhigh = 2, fwide = 2;\n\t  if ((filters ^ (filters >>  8)) & 0xff)   fhigh = 4;\n\t  if ((filters ^ (filters >> 16)) & 0xffff) fhigh = 8;\n\t  if (filters == 1) fhigh = fwide = 16;\n\t  if (filters == 9) fhigh = fwide = 6;\n\t  printf (_(\"\\nFilter pattern: \"));\n\t  for (i=0; i < fhigh; i++)\n\t    for (c = i && putchar('/') && 0; c < fwide; c++)\n\t      putchar (cdesc[fcol(i,c)]);\n\t}\n\tprintf (_(\"\\nDaylight multipliers:\"));\n\tFORCC printf (\" %f\", pre_mul[c]);\n\tif (cam_mul[0] > 0) {\n\t  printf (_(\"\\nCamera multipliers:\"));\n\t  FORC4 printf (\" %f\", cam_mul[c]);\n\t}\n\tputchar ('\\n');\n      } else\n\tprintf (_(\"%s is a %s %s image.\\n\"), ifname, make, model);\nnext:\n      fclose(ifp);\n      continue;\n    }\n    if (meta_length) {\n      meta_data = (char *) malloc (meta_length);\n      merror (meta_data, \"main()\");\n    }\n    if (filters || colors == 1) {\n      raw_image = (ushort *) calloc ((raw_height+7), raw_width*2);\n      merror (raw_image, \"main()\");\n    } else {\n      image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);\n      merror (image, \"main()\");\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Loading %s %s image from %s ...\\n\"),\n\tmake, model, ifname);\n    if (shot_select >= is_raw)\n      fprintf (stderr,_(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"),\n\tifname, shot_select);\n    fseeko (ifp, data_offset, SEEK_SET);\n    if (raw_image && read_from_stdin)\n      fread (raw_image, 2, raw_height*raw_width, stdin);\n    else (*load_raw)();\n    if (document_mode == 3) {\n      top_margin = left_margin = fuji_width = 0;\n      height = raw_height;\n      width  = raw_width;\n    }\n    iheight = (height + shrink) >> shrink;\n    iwidth  = (width  + shrink) >> shrink;\n    if (raw_image) {\n      image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);\n      merror (image, \"main()\");\n      crop_masked_pixels();\n      free (raw_image);\n    }\n    if (zero_is_bad) remove_zeroes();\n    bad_pixels (bpfile);\n    if (dark_frame) subtract (dark_frame);\n    quality = 2 + !fuji_width;\n    if (user_qual >= 0) quality = user_qual;\n    i = cblack[3];\n    FORC3 if (i > cblack[c]) i = cblack[c];\n    FORC4 cblack[c] -= i;\n    black += i;\n    i = cblack[6];\n    FORC (cblack[4] * cblack[5])\n      if (i > cblack[6+c]) i = cblack[6+c];\n    FORC (cblack[4] * cblack[5])\n      cblack[6+c] -= i;\n    black += i;\n    if (user_black >= 0) black = user_black;\n    FORC4 cblack[c] += black;\n    if (user_sat > 0) maximum = user_sat;\n#ifdef COLORCHECK\n    colorcheck();\n#endif\n    if (is_foveon) {\n      if (document_mode || load_raw == &CLASS foveon_dp_load_raw) {\n\tfor (i=0; i < height*width*4; i++)\n\t  if ((short) image[0][i] < 0) image[0][i] = 0;\n      } else foveon_interpolate();\n    } else if (document_mode < 2)\n      scale_colors();\n    pre_interpolate();\n    if (filters && !document_mode) {\n      if (quality == 0)\n\tlin_interpolate();\n      else if (quality == 1 || colors > 3)\n\tvng_interpolate();\n      else if (quality == 2 && filters > 1000)\n\tppg_interpolate();\n      else if (filters == 9)\n\txtrans_interpolate (quality*2-3);\n      else\n\tahd_interpolate();\n    }\n    if (mix_green)\n      for (colors=3, i=0; i < height*width; i++)\n\timage[i][1] = (image[i][1] + image[i][3]) >> 1;\n    if (!is_foveon && colors == 3) median_filter();\n    if (!is_foveon && highlight == 2) blend_highlights();\n    if (!is_foveon && highlight > 2) recover_highlights();\n    if (use_fuji_rotate) fuji_rotate();\n#ifndef NO_LCMS\n    if (cam_profile) apply_profile (cam_profile, out_profile);\n#endif\n    convert_to_rgb();\n    if (use_fuji_rotate) stretch();\nthumbnail:\n    if (write_fun == &CLASS jpeg_thumb)\n      write_ext = \".jpg\";\n    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)\n      write_ext = \".tiff\";\n    else\n      write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors*5-5;\n    ofname = (char *) malloc (strlen(ifname) + 64);\n    merror (ofname, \"main()\");\n    if (write_to_stdout)\n      strcpy (ofname,_(\"standard output\"));\n    else {\n      strcpy (ofname, ifname);\n      if ((cp = strrchr (ofname, '.'))) *cp = 0;\n      if (multi_out)\n\tsprintf (ofname+strlen(ofname), \"_%0*d\",\n\t\tsnprintf(0,0,\"%d\",is_raw-1), shot_select);\n      if (thumbnail_only)\n\tstrcat (ofname, \".thumb\");\n      strcat (ofname, write_ext);\n      ofp = fopen (ofname, \"wb\");\n      if (!ofp) {\n\tstatus = 1;\n\tperror (ofname);\n\tgoto cleanup;\n      }\n    }\n    if (verbose)\n      fprintf (stderr,_(\"Writing data to %s ...\\n\"), ofname);\n    (*write_fun)();\n    fclose(ifp);\n    if (ofp != stdout) fclose(ofp);\ncleanup:\n    if (meta_data) free (meta_data);\n    if (ofname) free (ofname);\n    if (oprof) free (oprof);\n    if (image) free (image);\n    if (multi_out) {\n      if (++shot_select < is_raw) arg--;\n      else shot_select = 0;\n    }\n  }\n  return status;\n}\n#endif\n", "/* \n  Copyright 2008-2017 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\nint CLASS fcol (int row, int col)\n{\n  static const char filter[16][16] =\n  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\n    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\n    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\n    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\n    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\n    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\n    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\n    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\n    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\n    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\n    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\n    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\n    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\n    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\n    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\n    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\n\n  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];\n  if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];\n  return FC(row,col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return(p ? p-s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a,b) local_strnlen(a,b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n int r = fp->read(buf,len,1);\n buf[len-1] = 0;\n return r;\n}\n#define stmread(buf,maxlen,fp) stread(buf,MIN(maxlen,sizeof(buf)),fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem (char *haystack, size_t haystacklen,\n\t      char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp (c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr (char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf,sizeof(buf)-1)\n\nushort CLASS sget2 (uchar *s)\n{\n  if (order == 0x4949)\t\t/* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else\t\t\t\t/* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG\t1\n#define AdobeDNG\t2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords,int maxlen)\n{\n  line[maxlen-1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while(1)\n  {\n    while(isspace(*p)) p++;\n    if(*p == '\\0') return nwords;\n    words[nwords++] = p;\n    while(!isspace(*p) && *p != '\\0') p++;\n    if(*p == '\\0') return nwords;\n    *p++ = '\\0';\n    if(nwords >= maxwords) return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f){\n\tif ((a >> 4) > 9) return 0;\n\telse if ((a & 0x0f) > 9) return 0;\n\telse if ((b >> 4) > 9) return 0;\n\telse if ((b & 0x0f) > 9) return 0;\n\telse if ((c >> 4) > 9) return 0;\n\telse if ((c & 0x0f) > 9) return 0;\n\telse if ((d >> 4) > 9) return 0;\n\telse if ((d & 0x0f) > 9) return 0;\n\telse if ((e >> 4) > 9) return 0;\n\telse if ((e & 0x0f) > 9) return 0;\n\telse if ((f >> 4) > 9) return 0;\n\telse if ((f & 0x0f) > 9) return 0;\nreturn 1;\n}\n\nstatic ushort bcd2dec(uchar data){\n\tif ((data >> 4) > 9) return 0;\n\telse if ((data & 0x0f) > 9) return 0;\n\telse return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] = \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s)\t// specific to some Canon Makernotes fields, where they have endian in reverse\n{\n\tif (order == 0x4d4d)\t\t/* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n\t\treturn s[0] | s[1] << 8;\n\telse\t\t\t\t\t\t/* \"MM\" means big-endian... */\n\t\treturn s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = { 0xff,0xff };\n  fread (str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4 (uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint (int type)\n{\n  return type == 3 ? get2() : get4();\n}\n\nfloat CLASS int_to_float (int i)\n{\n  union { int i; float f; } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal (int type)\n{\n  union { char c[8]; double d; } u,v;\n  int i, rev;\n\n  switch (type) {\n    case 3: return (unsigned short) get2();\n    case 4: return (unsigned int) get4();\n    case 5:\n      u.d = (unsigned int) get4();\n      v.d = (unsigned int)get4();\n      return u.d / (v.d ? v.d : 1);\n    case 8: return (signed short) get2();\n    case 9: return (signed int) get4();\n    case 10:\n      u.d = (signed int) get4();\n      v.d = (signed int)get4();\n      return u.d / (v.d?v.d:1);\n    case 11: return int_to_float (get4());\n    case 12:\n      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n      for (i=0; i < 8; i++)\n\tu.c[i ^ rev] = fgetc(ifp);\n      return u.d;\n    default: return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts (ushort *pixel, int count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((char*)pixel, (char*)pixel, count*2);\n}\n\nvoid CLASS cubic_spline (const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);\n  if (!A) return;\n  A[0] = (float *) (A + 2*len);\n  for (i = 1; i < 2*len; i++)\n    A[i] = A[0] + 2*len*i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));\n  for (i = 0; i < len; i++) {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len-1; i > 0; i--) {\n    b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);\n    d[i-1] = x[i] - x[i-1];\n  }\n  for (i = 1; i < len-1; i++) {\n    A[i][i] = 2 * (d[i-1] + d[i]);\n    if (i > 1) {\n      A[i][i-1] = d[i-1];\n      A[i-1][i] = d[i-1];\n    }\n    A[i][len-1] = 6 * (b[i+1] - b[i]);\n  }\n  for(i = 1; i < len-2; i++) {\n    float v = A[i+1][i] / A[i][i];\n    for(j = 1; j <= len-1; j++)\n      A[i+1][j] -= v * A[i][j];\n  }\n  for(i = len-2; i > 0; i--) {\n    float acc = 0;\n    for(j = i; j <= len-2; j++)\n      acc += A[i][j]*c[j];\n    c[i] = (A[i][len-1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++) {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len-1; j++) {\n      if (x[j] <= x_out && x_out <= x[j+1]) {\n\tfloat v = x_out - x[j];\n\ty_out = y[j] +\n\t  ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v\n\t   + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :\n\t\t(ushort)(y_out * 65535.0 + 0.5));\n  }\n  free (A);\n}\n\nvoid CLASS canon_600_fixed_wb (int temp)\n{\n  static const short mul[4][5] = {\n    {  667, 358,397,565,452 },\n    {  731, 390,367,499,517 },\n    { 1119, 396,348,448,537 },\n    { 1399, 485,431,508,688 } };\n  int lo, hi, i;\n  float frac=0;\n\n  for (lo=4; --lo; )\n    if (*mul[lo] <= temp) break;\n  for (hi=0; hi < 3; hi++)\n    if (*mul[hi] >= temp) break;\n  if (lo != hi)\n    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i=1; i < 5; i++)\n    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color (int ratio[2], int mar)\n{\n  int clipped=0, target, miss;\n\n  if (flash_used) {\n    if (ratio[1] < -104)\n      { ratio[1] = -104; clipped = 1; }\n    if (ratio[1] >   12)\n      { ratio[1] =   12; clipped = 1; }\n  } else {\n    if (ratio[1] < -264 || ratio[1] > 461) return 2;\n    if (ratio[1] < -50)\n      { ratio[1] = -50; clipped = 1; }\n    if (ratio[1] > 307)\n      { ratio[1] = 307; clipped = 1; }\n  }\n  target = flash_used || ratio[1] < 197\n\t? -38 - (398 * ratio[1] >> 10)\n\t: -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] &&\n      target + 20  >= ratio[0] && !clipped) return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar*4) return 2;\n  if (miss < -20) miss = -20;\n  if (miss > mar) miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = { 0,0 };\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset (&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if      (i < 10) mar = 150;\n  else if (i > 12) mar = 20;\n  else mar = 280 - 20 * i;\n  if (flash_used) mar = 80;\n  for (row=14; row < height-14; row+=4)\n    for (col=10; col < width; col+=2) {\n      for (i=0; i < 8; i++)\n\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\n\t\t    BAYER(row+(i >> 1),col+(i & 1));\n      for (i=0; i < 8; i++)\n\tif (test[i] < 150 || test[i] > 1500) goto next;\n      for (i=0; i < 4; i++)\n\tif (abs(test[i] - test[i+4]) > 50) goto next;\n      for (i=0; i < 2; i++) {\n\tfor (j=0; j < 4; j+=2)\n\t  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\n\tstat[i] = canon_600_color (ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1) goto next;\n      for (i=0; i < 2; i++)\n\tif (stat[i])\n\t  for (j=0; j < 2; j++)\n\t    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\n      for (i=0; i < 8; i++)\n\ttotal[st][i] += test[i];\n      count[st]++;\nnext: ;\n    }\n  if (count[0] | count[1]) {\n    st = count[0]*200 < count[1];\n    for (i=0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\n    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\n    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\n    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\n    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\n  int t=0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\n  if (mc > 1.28 && mc <= 2) {\n    if  (yc < 0.8789) t=3;\n    else if (yc <= 2) t=4;\n  }\n  if (flash_used) t=5;\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar  data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow=row=0; irow < height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data, 1, 1120, ifp) < 1120) derror();\n    pix = raw_image + row*raw_width;\n    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1]      & 3);\n      pix[4] = (dp[5] << 2) + (dp[9]      & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );\n    }\n    if ((row+=2) > height) row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] =\n  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\n\n  for (row=0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++) {\n      if ((val = BAYER(row,col) - black) < 0) val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row,col) = val;\n    }\n    }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row=0; row < 100; row++) {\n    fseek (ifp, row*3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15) return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff (int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf=0;\n  static int vbits=0, reset=0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits  tls->getbits.vbits\n#define reset  tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25) return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0) return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&\n    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {\n    bitbuf = (bitbuf << 8) + (uchar) c;\n    vbits += 8;\n  }\n  c = bitbuf << (32-vbits) >> (32-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    c = (uchar) huff[c];\n  } else\n    vbits -= nbits;\n  if (vbits < 0) derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n,0)\n#define gethuff(h) getbithuff(*h,h+1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n\t00\t\t0x04\n\t010\t\t0x03\n\t011\t\t0x05\n\t100\t\t0x06\n\t101\t\t0x02\n\t1100\t\t0x07\n\t1101\t\t0x01\n\t11100\t\t0x08\n\t11101\t\t0x09\n\t11110\t\t0x00\n\t111110\t\t0x0a\n\t1111110\t\t0x0b\n\t1111111\t\t0xff\n */\nushort * CLASS make_decoder_ref (const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max=16; max && !count[max]; max--);\n  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);\n  merror (huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h=len=1; len <= max; len++)\n    for (i=0; i < count[len]; i++, ++*source)\n      for (j=0; j < 1 << (max-len); j++)\n\tif (h <= 1 << max)\n\t  huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort * CLASS make_decoder (const uchar *source)\n{\n  return make_decoder_ref (&source);\n}\n\nvoid CLASS crw_init_tables (unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\n      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\n    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\n      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\n  };\n  static const uchar second_tree[3][180] = {\n    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\n      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\n      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\n      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\n      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\n      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\n      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\n      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\n      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\n      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\n      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\n      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\n      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\n      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\n      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\n    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\n      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\n      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\n      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\n      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\n      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\n      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\n      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\n      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\n      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\n      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\n      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\n      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\n      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\n      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\n    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\n      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\n      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\n      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\n      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\n      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\n      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\n      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\n      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\n      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\n      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\n      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\n      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\n      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\n      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\n  };\n  if (table > 2) table = 2;\n  huff[0] = make_decoder ( first_tree[table]);\n  huff[1] = make_decoder (second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret=1, i;\n\n  fseek (ifp, 0, SEEK_SET);\n  fread (test, 1, sizeof test, ifp);\n  for (i=540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff) {\n      if (test[i+1]) return 1;\n      ret=0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\n\n  crw_init_tables (tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits) maximum = 0x3ff;\n  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row+=8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    nblocks = MIN (8, raw_height-row) * raw_width >> 6;\n    for (block=0; block < nblocks; block++) {\n      memset (diffbuf, 0, sizeof diffbuf);\n      for (i=0; i < 64; i++ ) {\n\tleaf = gethuff(huff[i > 0]);\n\tif (leaf == 0 && i) break;\n\tif (leaf == 0xff) continue;\n\ti  += leaf >> 4;\n\tlen = leaf & 15;\n\tif (len == 0) continue;\n\tdiff = getbits(len);\n\tif ((diff & (1 << (len-1))) == 0)\n\t  diff -= (1 << len) - 1;\n\tif (i < 64) diffbuf[i] = diff;\n      }\n      diffbuf[0] += carry;\n      carry = diffbuf[0];\n      for (i=0; i < 64; i++ ) {\n\tif (pnum++ % raw_width == 0)\n\t  base[0] = base[1] = 512;\n\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n\t  derror();\n      }\n    }\n    if (lowbits) {\n      save = ftell(ifp);\n      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);\n      for (prow=pixel, i=0; i < raw_width*2; i++) {\n\tc = fgetc(ifp);\n\tfor (r=0; r < 8; r+=2, prow++) {\n\t  val = (*prow << 2) + ((c >> r) & 3);\n\t  if (raw_width == 2672 && val < 512) val += 2;\n\t  *prow = val;\n\t}\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    FORC(2) free (huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free (huff[c]);\n}\n\nint CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;\n  do {\n    if(feof(ifp)) return 0;\n    if(cnt++ > 1024) return 0; // 1024 tags limit\n    if (!fread (data, 2, 2, ifp)) return 0;\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:        // start of frame; lossless, Huffman\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc1:\n      case 0xffc0:\n\tjh->algo = tag & 0xff;\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:          // define Huffman tables\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && !((c = *dp++) & -20); )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:          // start of scan\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdb:\n\tFORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 ||\n     !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;\n  if (info_only) return 1;\n  if (!jh->huff[0]) return 0;\n  FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end (struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free (jh->free[c]);\n  free (jh->row);\n}\n\nint CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n  if(!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort * CLASS ljpeg_row (int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred=0;\n  ushort mark=0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0) {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);\n    if (jrow) {\n      fseek (ifp, -2, SEEK_CUR);\n      do mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\n  for (col=0; col < jh->wide; col++)\n    FORC(jh->clrs) {\n      diff = ljpeg_diff (jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n\t\t    pred = spred;\n      else if (col) pred = row[0][-jh->clrs];\n      else\t    pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col) switch (jh->psv) {\n\tcase 1:\tbreak;\n\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\n\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\n\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\n\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\n\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\n\tdefault: pred = 0;\n      }\n      if ((**row = pred + diff) >> jh->bits) derror();\n      if (c <= jh->sraw) spred = **row;\n      row[0]++; row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row=0, col=0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n\n  if(jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits <1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp (failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if(jh.clrs == 4 && jwide >= raw_width*2) jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*raw_height);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*raw_height);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if(row>raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp (failure, 3);\n#endif\n      if ((unsigned) row < raw_height) RAW(row,col) = val;\n      if (++col >= raw_width)\n\tcol = (row++,0);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  ljpeg_end (&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp=0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\n  int v[3]={0,0,0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(load_flags & 256)\n  {\n\twidth = raw_width;\n\theight = raw_height;\n  }\n\n  try {\n#endif\n  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {\n    scol = ecol;\n    ecol += cr2_slice[1] * 2 / jh.clrs;\n    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;\n    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      ip = (short (*)[4]) image + row*width;\n      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\n\tif ((jcol %= jwide) == 0)\n\t  rp = (short *) ljpeg_row (jrow++, &jh);\n\tif (col >= width) continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC (jh.clrs-2)\n              {\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n                ip[col + (c >> 1)*width + (c & 1)][1] = ip[col + (c >> 1)*width + (c & 1)][2] = 8192;\n              }\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC (jh.clrs-2)\n                ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 8192;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 8192;\n          }\n        else\n#endif\n          {\n            FORC (jh.clrs-2)\n              ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];\n            ip[col][1] = rp[jcol+jh.clrs-2] - 16384;\n            ip[col][2] = rp[jcol+jh.clrs-1] - 16384;\n          }\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n    {\n      ljpeg_end (&jh);\n      maximum = 0x3fff;\n      height = saved_h;\n      width = saved_w;\n      return;\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (cp=model2; *cp && !isdigit(*cp); cp++);\n  sscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\n  ver = (v[0]*1000 + v[1])*1000 + v[2];\n  hue = (jh.sraw+1) << 2;\n  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n    hue = jh.sraw << 1;\n  ip = (short (*)[4]) image;\n  rp = ip[0];\n  for (row=0; row < height; row++, ip+=width) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (row & (jh.sraw >> 1))\n    {\n      for (col=0; col < width; col+=2)\n\tfor (c=1; c < 3; c++)\n\t  if (row == height-1)\n          {\n\t       ip[col][c] =  ip[col-width][c];\n          }\n          else\n          {\n              ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;\n          }\n    }\n    for (col=1; col < width; col+=2)\n      for (c=1; c < 3; c++)\n\tif (col == width-1)\n\t     ip[col][c] =  ip[col-1][c];\n\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB) )\n#endif\n    for ( ; rp < ip[0]; rp+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (unique_id == 0x80000218 ||\n          unique_id == 0x80000250 ||\n          unique_id == 0x80000261 ||\n          unique_id == 0x80000281 ||\n          unique_id == 0x80000287) {\n        rp[1] = (rp[1] << 2) + hue;\n        rp[2] = (rp[2] << 2) + hue;\n        pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);\n        pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\n        pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\n      } else {\n        if (unique_id < 0x80000218) rp[0] -= 512;\n        pix[0] = rp[0] + rp[2];\n        pix[2] = rp[0] + rp[1];\n        pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);\n      }\n      FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end (&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select) (*rp)++;\n  if (raw_image) {\n    if (row < raw_height && col < raw_width)\n      RAW(row,col) = curve[**rp];\n    *rp += tiff_samples;\n  } else {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n\timage[row*width+col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select) (*rp)--;\n}\n\nvoid CLASS ljpeg_idct (struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = { 0 };\n  static const uchar zigzag[80] =\n  {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,\n    40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,\n    29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,\n    47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;\n  memset (work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];\n  for (i=1; i < 64; i++ ) {\n    len = gethuff (jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15) break;\n    coef = getbits(len);\n    if ((coef & (1 << (len-1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];\n  for (i=0; i < 8; i++)\n    for (j=0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n    if (!ljpeg_start (&jh, 0)) break;\n    jwide = jh.wide;\n    if (filters) jwide *= jh.clrs;\n    jwide /= MIN (is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try {\n#endif\n      switch (jh.algo) {\n      case 0xc1:\n\tjh.vpred[0] = 16384;\n\tgetbits(-1);\n\tfor (jrow=0; jrow+7 < jh.high; jrow += 8) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  for (jcol=0; jcol+7 < jh.wide; jcol += 8) {\n\t    ljpeg_idct (&jh);\n\t    rp = jh.idct;\n\t    row = trow + jcol/tile_width + jrow*2;\n\t    col = tcol + jcol%tile_width;\n\t    for (i=0; i < 16; i+=2)\n\t      for (j=0; j < 8; j++)\n\t\tadobe_copy_pixel (row+i, col+j, &rp);\n\t  }\n\t}\n\tbreak;\n      case 0xc3:\n\tfor (row=col=jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  checkCancel();\n#endif\n\t  rp = ljpeg_row (jrow, &jh);\n\t  for (jcol=0; jcol < jwide; jcol++) {\n\t    adobe_copy_pixel (trow+row, tcol+col, &rp);\n\t    if (++col >= tile_width || col >= raw_width)\n\t      row += 1 + (col = 0);\n\t  }\n\t}\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    } catch (...) {\n      ljpeg_end (&jh);\n      throw ;\n    }\n#endif\n    fseek (ifp, save+4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end (&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);\n  merror (pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (tiff_bps == 16)\n      read_shorts (pixel, raw_width * tiff_samples);\n    else {\n      getbits(-1);\n      for (col=0; col < raw_width * tiff_samples; col++)\n\tpixel[col] = getbits(tiff_bps);\n    }\n    for (rp=pixel, col=0; col < raw_width; col++)\n      adobe_copy_pixel (row, col, &rp);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (pixel);\n    throw ;\n  }\n#endif\n  free (pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek (ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )\n      huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width*3*tiff_bps/8;\n  if(tiff_bps <= 8)\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,255);\n  else\n    gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n  fseek (ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char*)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for(int row = 0; row < raw_height; row++)\n    {\n      int red = fread (buf, 1, bufsize, ifp);\n      unsigned short (*ip)[4] = (unsigned short (*)[4]) image + row*width;\n      if(tiff_bps <= 8)\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[buf[col*3]];\n            ip[col][1] = curve[buf[col*3+1]];\n            ip[col][2] = curve[buf[col*3+2]];\n            ip[col][3]=0;\n          }\n      else\n        for(int col=0; col<width;col++)\n          {\n            ip[col][0] = curve[ubuf[col*3]];\n            ip[col][1] = curve[ubuf[col*3+1]];\n            ip[col][2] = curve[ubuf[col*3+2]];\n            ip[col][3]=0;\n          }\n    }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\n      5,4,3,6,2,7,1,0,8,9,11,10,12 },\n    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\n      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\n      5,4,6,3,7,2,8,1,9,0,10,11,12 },\n    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\n      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\n    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\n      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\n    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\n      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek (ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46) tree = 2;\n  if (tiff_bps == 14) tree += 3;\n  read_shorts (vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize-1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\n    for (i=0; i < csize; i++)\n      curve[i*step] = get2();\n    for (i=0; i < max; i++)\n      curve[i] = ( curve[i-i%step]*(step-i%step) +\n\t\t   curve[i-i%step+step]*(i%step) ) / step;\n    fseek (ifp, meta_offset+562, SEEK_SET);\n    split = get2();\n  } else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts (curve, max=csize);\n  while (curve[max-2] == curve[max-1]) max--;\n  huff = make_decoder (nikon_tree[tree]);\n  fseek (ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (min=row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (split && row == split) {\n      free (huff);\n      huff = make_decoder (nikon_tree[tree+1]);\n      max += (min = 16) << 1;\n    }\n    for (col=0; col < raw_width; col++) {\n      i = gethuff(huff);\n      len = i & 15;\n      shl = i >> 4;\n      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;\n      if ((diff & (1 << (len-1))) == 0)\n\tdiff -= (1 << len) - !shl;\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      if ((ushort)(hpred[col & 1] + min) >= max) derror();\n      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free (huff);\n    throw;\n  }\n#endif\n  free (huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col=0; col < raw_width; col++) {\n      if (!(b = col & 1)) {\n\tbitbuf = 0;\n\tFORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;\n\tFORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705*yuv[3];\n      rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];\n      rgb[2] = yuv[b] + 1.732446*yuv[2];\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\n\n  memset (histo, 0, sizeof histo);\n  fseek (ifp, -2000, SEEK_END);\n  for (i=0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i=0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek (ifp, 0, SEEK_SET);\n  for (i=0; i < 1024; i++) {\n    fread (t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4\n\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n    { 0x00, \"Pentax\",  \"Optio 33WR\" },\n    { 0x03, \"Nikon\",   \"E3200\" },\n    { 0x32, \"Nikon\",   \"E3700\" },\n    { 0x33, \"Olympus\", \"C740UZ\" } };\n\n  fseek (ifp, 3072, SEEK_SET);\n  fread (dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits) {\n      strcpy (make,  table[i].t_make );\n      strcpy (model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"ppm_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread  (thumb, 1, thumb_length, ifp);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width*thumb_height*3;\n  thumb = (char *) calloc (thumb_length, 2);\n  merror (thumb, \"ppm16_thumb()\");\n  read_shorts ((ushort *) thumb, thumb_length);\n  for (i=0; i < thumb_length; i++)\n    thumb[i] = ((ushort *) thumb)[i] >> 8;\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite (thumb, 1, thumb_length, ofp);\n  free (thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = { \"012\",\"102\" };\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width*thumb_height;\n  thumb = (char *) calloc (colors, thumb_length);\n  merror (thumb, \"layer_thumb()\");\n  fprintf (ofp, \"P%d\\n%d %d\\n255\\n\",\n\t5 + (colors >> 1), thumb_width, thumb_height);\n  fread (thumb, thumb_length, colors, ifp);\n  for (i=0; i < thumb_length; i++)\n    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);\n  free (thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *) calloc (thumb_length, 2);\n  merror (thumb, \"rollei_thumb()\");\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts (thumb, thumb_length);\n  for (i=0; i < thumb_length; i++) {\n    putc (thumb[i] << 3, ofp);\n    putc (thumb[i] >> 5  << 2, ofp);\n    putc (thumb[i] >> 11 << 3, ofp);\n  }\n  free (thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten=0, isix, i, buffer=0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i=0; i < 16; i+=2)\n      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw (unsigned row, unsigned col)\n{\n  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;\n}\n\nvoid CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0) return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"phase_one_flat_field()\");\n  for (y=0; y < high; y++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5];\n\t row < raw_height && row < rend &&\n\t row < head[1]+head[3]-head[5]; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4];\n\t     col < raw_width &&\n\t     col < cend && col < head[0]+head[2]-head[4]; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff=INT_MAX, off_412=0;\n  /* static */ const signed char dir[12][2] =\n    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\n      {-2,-2}, {-2,2}, {2,-2}, {2,2} };\n  float poly[8], num, cfrac, frac, mult[2], *yval[2]={NULL,NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!meta_length)\n#else\n  if (half_size || !meta_length)\n#endif\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\n#endif\n  fseek (ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek (ifp, 6, SEEK_CUR);\n  fseek (ifp, meta_offset+get4(), SEEK_SET);\n  entries = get4();  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  while (entries--) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    tag  = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, meta_offset+data, SEEK_SET);\n    if (tag == 0x419) {\t\t\t\t/* Polynomial curve */\n      for (get4(), i=0; i < 8; i++)\n\tpoly[i] = getreal(11);\n      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n      for (i=0; i < 0x10000; i++) {\n\tnum = (poly[5]*i + poly[3])*i + poly[1];\n\tcurve[i] = LIM(num,0,65535);\n      } goto apply;\t\t\t\t/* apply to right half */\n    } else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\n      for (i=0; i < 4; i++)\n\tpoly[i] = getreal(11);\n      for (i=0; i < 0x10000; i++) {\n\tfor (num=0, j=4; j--; )\n\t  num = num * i + poly[j];\n\tcurve[i] = LIM(num+i,0,65535);\n      } apply:\t\t\t\t\t/* apply to whole image */\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col = (tag & 1)*ph1.split_col; col < raw_width; col++)\n\t  RAW(row,col) = curve[RAW(row,col)];\n      }\n    } else if (tag == 0x400) {\t\t\t/* Sensor defects */\n      while ((len -= 8) >= 0) {\n\tcol  = get2();\n\trow  = get2();\n\ttype = get2(); get2();\n\tif (col >= raw_width) continue;\n\tif (type == 131 || type == 137)\t\t/* Bad column */\n\t  for (row=0; row < raw_height; row++)\n\t    if (FC(row-top_margin,col-left_margin) == 1) {\n\t      for (sum=i=0; i < 4; i++)\n\t\tsum += val[i] = raw (row+dir[i][0], col+dir[i][1]);\n\t      for (max=i=0; i < 4; i++) {\n\t\tdev[i] = abs((val[i] << 2) - sum);\n\t\tif (dev[max] < dev[i]) max = i;\n\t      }\n\t      RAW(row,col) = (sum - val[max])/3.0 + 0.5;\n\t    } else {\n\t      for (sum=0, i=8; i < 12; i++)\n\t\tsum += raw (row+dir[i][0], col+dir[i][1]);\n\t      RAW(row,col) = 0.5 + sum * 0.0732233 +\n\t\t(raw(row,col-2) + raw(row,col+2)) * 0.3535534;\n\t    }\n\telse if (type == 129) {\t\t\t/* Bad pixel */\n\t  if (row >= raw_height) continue;\n\t  j = (FC(row-top_margin,col-left_margin) != 1) * 4;\n\t  for (sum=0, i=j; i < j+8; i++)\n\t    sum += raw (row+dir[i][0], col+dir[i][1]);\n\t  RAW(row,col) = (sum + 4) >> 3;\n\t}\n      }\n    } else if (tag == 0x401) {\t\t\t/* All-color flat fields */\n      phase_one_flat_field (1, 2);\n    } else if (tag == 0x416 || tag == 0x410) {\n      phase_one_flat_field (0, 2);\n    } else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\n      phase_one_flat_field (0, 4);\n    } else if (tag == 0x412) {\n      fseek (ifp, 36, SEEK_CUR);\n      diff = abs (get2() - ph1.tag_21a);\n      if (mindiff > diff) {\n\tmindiff = diff;\n\toff_412 = ftell(ifp) - 38;\n      }\n    } else if (tag == 0x41f && !qlin_applied) { /* Quadrant linearization */\n      ushort lc[2][2][16], ref[16];\n      int qr, qc;\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 16; i++)\n\t    lc[qr][qc][i] = get4();\n      for (i = 0; i < 16; i++) {\n\tint v = 0;\n\tfor (qr = 0; qr < 2; qr++)\n\t  for (qc = 0; qc < 2; qc++)\n\t    v += lc[qr][qc][i];\n\tref[i] = (v + 2) >> 2;\n      }\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[19], cf[19];\n\t  for (i = 0; i < 16; i++) {\n\t    cx[1+i] = lc[qr][qc][i];\n\t    cf[1+i] = ref[i];\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n          cf[18] = cx[18] = 65535;\n\t  cubic_spline(cx, cf, 19);\n\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n\t}\n      }\n      qlin_applied = 1;\n    } else if (tag == 0x41e && !qmult_applied) { /* Quadrant multipliers */\n      float qmult[2][2] = { { 1, 1 }, { 1, 1 } };\n      get4(); get4(); get4(); get4();\n      qmult[0][0] = 1.0 + getreal(11);\n      get4(); get4(); get4(); get4(); get4();\n      qmult[0][1] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][0] = 1.0 + getreal(11);\n      get4(); get4(); get4();\n      qmult[1][1] = 1.0 + getreal(11);\n      for (row=0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n\tfor (col=0; col < raw_width; col++) {\n\t  i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);\n\t  RAW(row,col) = LIM(i,0,65535);\n\t}\n      }\n      qmult_applied = 1;\n    } else if (tag == 0x431 && !qmult_applied) { /* Quadrant combined */\n      ushort lc[2][2][7], ref[7];\n      int qr, qc;\n      for (i = 0; i < 7; i++)\n\tref[i] = get4();\n      for (qr = 0; qr < 2; qr++)\n\tfor (qc = 0; qc < 2; qc++)\n\t  for (i = 0; i < 7; i++)\n\t    lc[qr][qc][i] = get4();\n      for (qr = 0; qr < 2; qr++) {\n\tfor (qc = 0; qc < 2; qc++) {\n\t  int cx[9], cf[9];\n\t  for (i = 0; i < 7; i++) {\n\t    cx[1+i] = ref[i];\n\t    cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;\n\t  }\n\t  cx[0] = cf[0] = 0;\n\t  cx[8] = cf[8] = 65535;\n\t  cubic_spline(cx, cf, 9);\n\t  for (row = (qr ? ph1.split_row : 0);\n\t       row < (qr ? raw_height : ph1.split_row); row++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n            checkCancel();\n#endif\n\t    for (col = (qc ? ph1.split_col : 0);\n\t\t col < (qc ? raw_width : ph1.split_col); col++)\n\t      RAW(row,col) = curve[RAW(row,col)];\n          }\n        }\n      }\n      qmult_applied = 1;\n      qlin_applied = 1;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (off_412) {\n    fseek (ifp, off_412, SEEK_SET);\n    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;\n    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\n    merror (yval[0], \"phase_one_correct()\");\n    yval[1] = (float  *) (yval[0] + head[1]*head[3]);\n    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);\n    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);\n    get2();\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\tyval[i][j] = getreal(11);\n    for (i=0; i < 2; i++)\n      for (j=0; j < head[i+1]*head[i+3]; j++)\n\txval[i][j] = get2();\n    for (row=0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col=0; col < raw_width; col++) {\n\tcfrac = (float) col * head[3] / raw_width;\n\tcfrac -= cip = cfrac;\n\tnum = RAW(row,col) * 0.5;\n\tfor (i=cip; i < cip+2; i++) {\n\t  for (k=j=0; j < head[1]; j++)\n\t    if (num < xval[0][k = head[1]*i+j]) break;\n\t  frac = (j == 0 || j == head[1]) ? 0 :\n\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\n\t  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\n\t}\n\ti = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;\n\tRAW(row,col) = LIM(i,0,65535);\n      }\n    }\n    free (yval[0]);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if(yval[0]) free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek (ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555:0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw()\");\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw()\");\n      if (ph1.black_col)\n        {\n          fseek (ifp, ph1.black_col, SEEK_SET);\n          read_shorts ((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height*2);\n        }\n      if (ph1.black_row)\n        {\n          fseek (ifp, ph1.black_row, SEEK_SET);\n          read_shorts ((ushort *) imgdata.rawdata.ph1_rblack[0], raw_width*2);\n        }\n      }\n#endif\n  fseek (ifp, data_offset, SEEK_SET);\n  read_shorts (raw_image, raw_width*raw_height);\n  if (ph1.format)\n    for (i=0; i < raw_width*raw_height; i+=2) {\n      a = raw_image[i+0] ^ akey;\n      b = raw_image[i+1] ^ bkey;\n      raw_image[i+0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i+1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff (int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits  tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf=0;\n  static int vbits=0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0) return 0;\n  if (vbits < nbits) {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64-vbits) >> (64-nbits);\n  if (huff) {\n    vbits -= huff[c] >> 8;\n    return (uchar) huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n,0)\n#define ph1_huff(h) ph1_bithuff(*h,h+1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short (*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);\n  merror (pixel, \"phase_one_load_raw_c()\");\n  offset = (int *) (pixel + raw_width);\n  fseek (ifp, strip_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short (*)[2]) (offset + raw_height);\n  fseek (ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n      read_shorts ((ushort *) c_black[0], raw_height*2);\n  r_black = c_black + raw_height;\n  fseek (ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n      read_shorts ((ushort *) r_black[0], raw_width*2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row )\n    {\n      imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_cblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_cblack,(ushort*)c_black[0],raw_height*2*sizeof(ushort));\n      imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width*2,sizeof(ushort));\n      merror(imgdata.rawdata.ph1_rblack,\"phase_one_load_raw_c()\");\n      memmove(imgdata.rawdata.ph1_rblack,(ushort*)r_black[0],raw_width*2*sizeof(ushort));\n    }\n#endif\n\n  for (i=0; i < 256; i++)\n    curve[i] = i*i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + offset[row], SEEK_SET);\n    ph1_bits(-1);\n    pred[0] = pred[1] = 0;\n    for (col=0; col < raw_width; col++) {\n      if (col >= (raw_width & -8))\n\tlen[0] = len[1] = 14;\n      else if ((col & 7) == 0)\n\tfor (i=0; i < 2; i++) {\n\t  for (j=0; j < 5 && !ph1_bits(1); j++);\n\t  if (j--) len[i] = length[j*2 + ph1_bits(1)];\n\t}\n      if ((i = len[col & 1]) == 14)\n\tpixel[col] = pred[col & 1] = ph1_bits(16);\n      else\n\tpixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n      if (pred[col & 1] >> 16) derror();\n      if (ph1.format == 5 && pixel[col] < 256)\n\tpixel[col] = curve[pixel[col]];\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    for (col=0; col < raw_width; col++) {\n      int shift = ph1.format == 8? 0: 2;\n      i = (pixel[col] << shift) - ph1.t_black\n\t+ c_black[row][col >= ph1.split_col]\n\t+ r_black[col][row >= ph1.split_row];\n      if (i > 0) RAW(row,col) = i;\n    }\n#else\n    if(ph1.format == 8)\n      memmove(&RAW(row,0),&pixel[0],raw_width*2);\n    else\n      for (col=0; col < raw_width; col++)\n      \tRAW(row,col) = pixel[col] << 2;\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  back[4] = (int *) calloc (raw_width, 3*sizeof **back);\n  merror (back[4], \"hasselblad_load_raw()\");\n  FORC3 back[c] = back[4] + c*raw_width;\n  cblack[6] >>= sh = tiff_samples > 1;\n  shot = LIM(shot_select, 1, tiff_samples) - 1;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC4 back[(c+3) & 3] = back[c];\n    for (col=0; col < raw_width; col+=2) {\n      for (s=0; s < tiff_samples*2; s+=2) {\n\tFORC(2) len[c] = ph1_huff(jh.huff[0]);\n\tFORC(2) {\n\t  diff[s+c] = ph1_bits(len[c]);\n\t  if ((diff[s+c] & (1 << (len[c]-1))) == 0)\n\t    diff[s+c] -= (1 << len[c]) - 1;\n\t  if (diff[s+c] == 65535) diff[s+c] = -32768;\n\t}\n      }\n      for (s=col; s < col+2; s++) {\n\tpred = 0x8000 + load_flags;\n\tif (col) pred = back[2][s-2];\n\tif (col && row > 1) switch (jh.psv) {\n\t  case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;\n\t}\n\tf = (row & 1)*3 ^ ((col+s) & 1);\n\tFORC (tiff_samples) {\n\t  pred += diff[(s & 1)*tiff_samples+c];\n\t  upix = pred >> sh & 0xffff;\n\t  if (raw_image && c == shot)\n\t    RAW(row,s) = upix;\n\t  if (image) {\n\t    urow = row-top_margin  + (c & 1);\n\t    ucol = col-left_margin - ((c >> 1) & 1);\n\t    ip = &image[urow*width+ucol][f];\n\t    if (urow < height && ucol < width)\n\t      *ip = c < 4 ? upix : (*ip + upix) >> 1;\n\t  }\n\t}\n\tback[2][s] = pred;\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (back[4]);\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  free (back[4]);\n  ljpeg_end (&jh);\n  if (image) mix_green = 1;\n}\n\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n  }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n    int row, col, bits=0;\n    while (1 << ++bits < maximum);\n    for (row=raw_height-1; row >= 0; row--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcheckCancel();\n#endif\n\tread_shorts (&raw_image[row*raw_width], raw_width);\n\tfor (col=0; col < raw_width; col++)\n\t\tif ((RAW(row,col) >>= load_flags) >> bits\n\t\t\t&& (unsigned) (row-top_margin) < height\n\t\t\t&& (unsigned) (col-left_margin) < width) derror();\n    }\n}\n\n\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image) return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width*3*sizeof(unsigned short));\n  merror(buf,\"imacon_full_load_raw\");\n#endif\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf,width*3);\n    unsigned short (*rowp)[4] = &image[row*width];\n    for (col=0; col < width; col++)\n      {\n        rowp[col][0]=buf[col*3];\n        rowp[col][1]=buf[col*3+1];\n        rowp[col][2]=buf[col*3+2];\n        rowp[col][3]=0;\n      }\n#else\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf=0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1) bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height+1) >> 1;\n  for (irow=0; irow < raw_height; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 &&\n\t(row = irow % half * 2 + irow / half) == 1 &&\n\tload_flags & 4) {\n      if (vbits=0, tiff_compress)\n\tfseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);\n      else {\n\tfseek (ifp, 0, SEEK_END);\n\tfseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col=0; col < raw_width; col++) {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n      RAW(row,col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&\n\trow < height+top_margin && col < width+left_margin) derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom () {\n\n/* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek (ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread (&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right)*5)+3)>>2) + 0x1f)&(~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616;  /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order) {\n    case 0: /* RGGB */\n      filters = 0x94949494;\n      break;\n    case 1: /* GBRG */\n      filters = 0x49494949;\n      break;\n    case 3: /* GRBG */\n      filters = 0x61616161;\n      break;\n  }\n}\n\nvoid CLASS broadcom_load_raw() {\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *) malloc (raw_stride*2);\n  merror (data, \"broadcom_load_raw()\");\n\n  for (row=0; row < raw_height; row++) {\n    if (fread (data+raw_stride, 1, raw_stride, ifp) < raw_stride) derror();\n    FORC(raw_stride) data[c] = data[raw_stride+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free (data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar  *data,  *dp;\n  int rev, dwide, row, col, c;\n  double sum[]={0,0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *) malloc (dwide*2);\n  merror (data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();\n    FORC(dwide) data[c] = data[dwide+(c ^ rev)];\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...){\n    free (data);\n    throw;\n  }\n#endif\n  free (data);\n  maximum = 0x3ff;\n  if (strncmp(make,\"OmniVision\",10)) return;\n  row = raw_height/2;\n  FORC(width-1) {\n    sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));\n    sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));\n  }\n  if (sum[1] > sum[0]) filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5*raw_width >> 5) << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_tight_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)\n      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n}\n  free (data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf=0;\n\n  bwide = (raw_width+5)/6 << 3;\n  data = (uchar *) malloc (bwide);\n  merror (data, \"android_loose_load_raw()\");\n  for (row=0; row < raw_height; row++) {\n    if (fread (data, 1, bwide, ifp) < bwide) derror();\n    for (dp=data, col=0; col < raw_width; dp+=8, col+=6) {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c^7];\n      FORC(6) RAW(row,col+c) = (bitbuf >> c*10) & 0x3ff;\n    }\n  }\n  free (data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int*)malloc(sizeof(int)*(raw_width/3+1));\n  merror(words,\"canon_rmf_load_raw\");\n#endif\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words,sizeof(int),raw_width/3,ifp);\n    for (col=0; col < raw_width-2; col+=3)\n      {\n        bits = words[col/3];\n        FORC3 {\n          orow = row;\n          if ((ocol = col+c-4) < 0)\n            {\n              ocol += raw_width;\n              if ((orow -= 2) < 0)\n                orow += raw_height;\n            }\n          RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n        }\n      }\n#else\n    for (col=0; col < raw_width-2; col+=3) {\n      bits = get4();\n      FORC3 {\n\torow = row;\n\tif ((ocol = col+c-4) < 0) {\n\t  ocol += raw_width;\n\t  if ((orow -= 2) < 0)\n\t    orow += raw_height;\n\t}\n\tRAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits (int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits) return vbits=0;\n  if (!vbits) {\n    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);\n    fread (buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh=0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      if ((i = col % 14) == 0)\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1]) {\n\tif ((j = pana_bits(8))) {\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n\t  pred[i & 1] += j << sh;\n\t}\n      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n\tpred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n=0] = 0xc0c;\n  for (i=12; i--; )\n    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;\n  fseek (ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (acarry, 0, sizeof acarry);\n    for (col=0; col < raw_width; col++) {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12,huff)) == 12)\n\thigh = getbits(16-nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff*3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;\n      if (col >= width) continue;\n      if (row < 2 && col < 2) pred = 0;\n      else if (row < 2) pred = RAW(row,col-2);\n      else if (col < 2) pred = RAW(row-2,col);\n      else {\n\tw  = RAW(row,col-2);\n\tn  = RAW(row-2,col);\n\tnw = RAW(row-2,col-2);\n\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\n\t  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)\n\t    pred = w + n - nw;\n\t  else pred = (w + n) >> 1;\n\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\n      }\n      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))\n\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\n\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\n\n#ifdef __GNUC__\n# if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n# pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n# endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }\n  for (i=0; i < height*width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer (j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread (jpeg_buffer, 1, 4096, ifp);\n  swab (jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  jpeg_stdio_src (&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header (&cinfo, TRUE);\n  jpeg_start_decompress (&cinfo);\n  if ((cinfo.output_width      != width  ) ||\n      (cinfo.output_height*2   != height ) ||\n      (cinfo.output_components != 3      )) {\n    fprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress (&cinfo);\n    longjmp (failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)\n    ((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines (&cinfo, buf, 1);\n    pixel = (JSAMPLE (*)[3]) buf[0];\n    for (col=0; col < width; col+=2) {\n      RAW(row+0,col+0) = pixel[col+0][1] << 1;\n      RAW(row+1,col+1) = pixel[col+1][1] << 1;\n      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n    }\n  }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager {\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit (j_common_ptr cinfo)\n{\n  jpegErrorManager* myerr = (jpegErrorManager*) cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if(data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf,\"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char*) malloc(width*3);\n  jpeg_create_decompress (&cinfo);\n  merror(pixel_buf,\"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf,data_size,1,ifp);\n  swab ((char*)jpg_buf, (char*)jpg_buf, data_size);\n  try\n    {\n      jpeg_mem_src(&cinfo, jpg_buf, data_size);\n      int rc = jpeg_read_header(&cinfo, TRUE);\n      if(rc!=1)\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n      jpeg_start_decompress (&cinfo);\n      if ((cinfo.output_width      != width  ) ||\n          (cinfo.output_height*2   != height ) ||\n          (cinfo.output_components != 3      ))\n        {\n          throw LIBRAW_EXCEPTION_DECODE_JPEG;\n        }\n\n      unsigned char *buf[1];\n      buf[0] = pixel_buf;\n\n      while (cinfo.output_scanline < cinfo.output_height)\n        {\n          checkCancel();\n          row = cinfo.output_scanline * 2;\n          jpeg_read_scanlines (&cinfo, buf, 1);\n          unsigned char (*pixel)[3] = (unsigned char (*)[3]) buf[0];\n          for (col=0; col < width; col+=2) {\n            RAW(row+0,col+0) = pixel[col+0][1] << 1;\n            RAW(row+1,col+1) = pixel[col+1][1] << 1;\n            RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\n            RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\n          }\n        }\n    }\n  catch (...)\n        {\n          jpeg_finish_decompress (&cinfo);\n          jpeg_destroy_decompress (&cinfo);\n          free(jpg_buf);\n          free(pixel_buf);\n          throw;\n        }\n  jpeg_finish_decompress (&cinfo);\n  jpeg_destroy_decompress (&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE (*pixel)[3];\n  unsigned sorder=order, ntags, opcode, deg, i, j, c;\n  unsigned save=data_offset-4, trow=0, tcol=0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--) {\n      opcode = get4(); get4(); get4();\n      if (opcode != 8)\n      { fseek (ifp, get4(), SEEK_CUR); continue; }\n      fseek (ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2) break;\n      fseek (ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8) break;\n      for (i=0; i <= deg && i < 9; i++)\n\tcoeff[i] = getreal(12);\n      for (i=0; i < 256; i++) {\n\tfor (tot=j=0; j <= deg; j++)\n\t  tot += coeff[j] * pow(i/255.0, (int)j);\n\tcur[c][i] = tot*0xffff;\n      }\n    }\n    order = sorder;\n  } else {\n    gamma_curve (1/2.4, 12.92, 1, 255);\n    FORC3 memcpy (cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_decompress (&cinfo);\n  while (trow < raw_height) {\n    fseek (ifp, save+=4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek (ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n      {\n        jpeg_destroy_decompress(&cinfo);\n        throw LIBRAW_EXCEPTION_DECODE_JPEG;\n      }\n#else\n    jpeg_stdio_src (&cinfo, ifp);\n#endif\n    jpeg_read_header (&cinfo, TRUE);\n    jpeg_start_decompress (&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)\n\t((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n    while (cinfo.output_scanline < cinfo.output_height &&\n\t(row = trow + cinfo.output_scanline) < height) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      jpeg_read_scanlines (&cinfo, buf, 1);\n      pixel = (JSAMPLE (*)[3]) buf[0];\n      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {\n\tFORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    jpeg_destroy_decompress (&cinfo);\n    throw;\n  }\n#endif\n    jpeg_abort_decompress (&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress (&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = { 162, 192, 187,  92 };\n  static const int add[4] = {   0, 636, 424, 212 };\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, 848, ifp) < 848) derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col=0; col < width; col++)\n      RAW(row,col) = (ushort) pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();\n    for (col=0; col < raw_width; col++)\n      RAW(row,col) = curve[pixel[col]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] =\n  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder (kodak_tree[c]);\n  ns = (raw_height+63) >> 5;\n  pixel = (uchar *) malloc (raw_width*32 + ns*4);\n  merror (pixel, \"kodak_262_load_raw()\");\n  strip = (int *) (pixel + raw_width*32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if ((row & 31) == 0) {\n      fseek (ifp, strip[row >> 5], SEEK_SET);\n      getbits(-1);\n      pi = 0;\n    }\n    for (col=0; col < raw_width; col++) {\n      chess = (row + col) & 1;\n      pi1 = chess ? pi-2           : pi-raw_width-1;\n      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;\n      if (col <= chess) pi1 = -1;\n      if (pi1 < 0) pi1 = pi2;\n      if (pi2 < 0) pi2 = pi1;\n      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\n      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);\n      if (val >> 8) derror();\n      val = curve[pixel[pi++]];\n      RAW(row,col) = val;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  FORC(2) free (huff[c]);\n}\n\nint CLASS kodak_65000_decode (short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf=0;\n  int save, bits=0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i=0; i < bsize; i+=2) {\n    c = fgetc(ifp);\n    if ((blen[i  ] = c & 15) > 12 ||\n\t(blen[i+1] = c >> 4) > 12 ) {\n      fseek (ifp, save, SEEK_SET);\n      for (i=0; i < bsize; i+=8) {\n\tread_shorts (raw, 6);\n\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n\tfor (j=0; j < 6; j++)\n\t  out[i+2+j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4) {\n    bitbuf  = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i=0; i < bsize; i++) {\n    len = blen[i];\n    if (bits < len) {\n      for (j=0; j < 32; j+=8)\n\tbitbuf += (INT64) fgetc(ifp) << (bits+(j^8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16-len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len-1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n      {\n\tint idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n\tif(idx >=0 && idx <= 0xffff)\n\t {\n\t   if ((RAW(row,col+i) = curve[idx]) >> 12) derror();\n         }\n\t else\n\t   derror();\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;\n    }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek (ifp, 200896, SEEK_SET);\n  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek (ifp, 164600, SEEK_SET);\n  fread (head, 1, 40, ifp);\n  sony_decrypt ((unsigned *) head, 10, 1, key);\n  for (i=26; i-- > 22; )\n    key = key << 8 | head[i];\n  fseek (ifp, data_offset, SEEK_SET);\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row*raw_width;\n    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();\n    sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);\n    for (col=0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] =\n  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,\n    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };\n  int i, c, n, col, row, sum=0;\n\n  huff[0] = 15;\n  for (n=i=0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--; )\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row=0; row < raw_height+1; row+=2) {\n      if (row == raw_height) row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12) derror();\n      if (row < height) RAW(row,col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *) malloc (raw_width+1);\n  merror (data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fread (data, 1, raw_width, ifp);\n    for (dp=data, col=0; col < raw_width-30; dp+=16) {\n      max = 0x7ff & (val = sget4(dp));\n      min = 0x7ff & val >> 11;\n      imax = 0x0f & val >> 22;\n      imin = 0x0f & val >> 26;\n      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\n#ifdef LIBRAW_LIBRARY_BUILD\n      /* flag checks if outside of loop */\n      if(! (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n         || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n         )\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = max;\n            else if (i == imin) pix[i] = min;\n            else pix[i]=0;\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n      else if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit=30, i=0; i < 16; i++)\n            if      (i == imax) pix[i] = 0;\n            else if (i == imin) pix[i] = 0;\n            else {\n              pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit=30, i=0; i < 16; i++)\n\tif      (i == imax) pix[i] = max;\n\telse if (i == imin) pix[i] = min;\n\telse {\n\t  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n\t  if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n\t  bit += 7;\n\t}\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i=0; i < 16; i++, col+=2)\n            {\n              unsigned slope = pix[i] < 1001? 2 : curve[pix[i]<<1]-curve[(pix[i]<<1)-2];\n              unsigned step = 1 << sh;\n              RAW(row,col)=curve[pix[i]<<1]>black+imgdata.params.sony_arw2_posterization_thr?\n                LIM(((slope*step*1000)/(curve[pix[i]<<1]-black)),0,10000):0;\n            }\n        }\n      else\n        {\n          for (i=0; i < 16; i++, col+=2)\n            RAW(row,col) = curve[pix[i] << 1];\n        }\n#else\n      for (i=0; i < 16; i++, col+=2)\n\tRAW(row,col) = curve[pix[i] << 1] >> 2;\n#endif\n      col -= col & 1 ? 1:31;\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (data);\n    throw;\n  }\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum=10000;\n#endif\n  free (data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, strip_offset+row*4, SEEK_SET);\n    fseek (ifp, data_offset+get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7:4;\n    for (col=0; col < raw_width; col+=16) {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c]) {\n\tcase 3: len[c] = ph1_bits(4);\tbreak;\n\tcase 2: len[c]--;\t\tbreak;\n\tcase 1: len[c]++;\n      }\n      for (c=0; c < 16; c+=2) {\n\ti = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n\tif (c == 14) c = -1;\n      }\n    }\n  }\n  for (row=0; row < raw_height-1; row+=2)\n    for (col=0; col < raw_width-1; col+=2)\n      SWAP (RAW(row,col+1), RAW(row+1,col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] =\n  { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,\n    0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };\n  ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n=i=0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row=0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < raw_width; col++) {\n      diff = ljpeg_diff (huff);\n      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n      else\t   hpred[col & 1] += diff;\n      RAW(row,col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps) derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek (ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(),get2());\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0; pmode = 7;\n    FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;\n    prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1));\t// green\n    prow[~row & 1] = &RAW(row-2,0);\t\t\t// red and blue\n    for (tab=0; tab+15 < raw_width; tab+=16) {\n      if (~opt & 4 && !(tab & 63)) {\n\ti = ph1_bits(2);\n\tmag = i < 3 ? mag-'2'+\"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n\tpmode = 7 - 4*ph1_bits(1);\n      else if (!ph1_bits(1))\n\tpmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1)) {\n\tFORC4 len[c] = ph1_bits(2);\n\tFORC4 {\n\t  i = ((row & 1) << 1 | (c & 1)) % 3;\n\t  len[c] = len[c] < 3 ? lent[i][0]-'1'+\"120\"[len[c]] : ph1_bits(4);\n\t  lent[i][0] = lent[i][1];\n\t  lent[i][1] = len[c];\n\t}\n      }\n      FORC(16) {\n\tcol = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));\n\tpred = (pmode == 7 || row < 2)\n\t     ? (tab ? RAW(row,tab-2+(col & 1)) : init)\n\t     : (prow[col & 1][col-'4'+\"0224468\"[pmode]] +\n\t\tprow[col & 1][col-'4'+\"0244668\"[pmode]] + 1) >> 1;\n\tdiff = ph1_bits (i = len[c >> 2]);\n\tif (diff >> (i-1)) diff -= 1 << i;\n\tdiff = diff * (mag*2+1) + mag;\n\tRAW(row,col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment (unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\n    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\n  int low, high=0xff, carry=0, nbits=8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[]={0,0};\n  ushort data=0, range=0;\n\n  fseek (ifp, seg[0][1]+1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width*raw_height)\n       seg[1][0] = raw_width*raw_height;\n  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {\n    for (s=0; s < 3; s++) {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\n      while (--nbits >= 0)\n\tif ((data >> nbits & 0xff) == 0xff) break;\n      if (nbits > 0)\n\t  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |\n            ((data + (((data & (1 << (nbits-1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0) {\n\tdata += getbits(1);\n\tcarry = nbits - 8;\n      }\n      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin=0; hist[s][bin+5] > count; bin++);\n\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\n      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits=0; high << nbits < 128; nbits++);\n      range = (range+low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3]) {\n\tnext = (next+1) & hist[s][0];\n\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\n\thist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\n\tif (bin < hist[s][1])\n\t  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\n\telse if (next <= bin)\n\t  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(pix>=raw_width*raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek (ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment (seg, 0);\n}\n\nint CLASS median4 (int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i=1; i < 4; i++) {\n    sum += p[i];\n    if (min > p[i]) min = p[i];\n    if (max < p[i]) max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes (int holes)\n{\n  int row, col, val[4];\n\n  for (row=2; row < height-2; row++) {\n    if (!HOLE(row)) continue;\n    for (col=1; col < width-1; col+=4) {\n      val[0] = RAW(row-1,col-1);\n      val[1] = RAW(row-1,col+1);\n      val[2] = RAW(row+1,col-1);\n      val[3] = RAW(row+1,col+1);\n      RAW(row,col) = median4(val);\n    }\n    for (col=2; col < width-2; col+=4)\n      if (HOLE(row-2) || HOLE(row+2))\n\tRAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;\n      else {\n\tval[0] = RAW(row,col-2);\n\tval[1] = RAW(row,col+2);\n\tval[2] = RAW(row-2,col);\n\tval[3] = RAW(row+2,col);\n\tRAW(row,col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek (ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar) fgetc(ifp);\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < nseg*2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);\n  fseek (ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek (ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i=0; i < nseg; i++)\n    smal_decode_segment (seg+i, holes);\n  if (holes) fill_holes (holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen (ifname, \"rb\");\n#else\n  in = (jas_stream_t*)ifp->make_jas_stream();\n  if(!in)\n          throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek (in, data_offset+20, SEEK_SET);\n  jimg = jas_image_decode (in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg) longjmp (failure, 3);\n#else\n  if(!jimg)\n    {\n      jas_stream_close (in);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n    }\n#endif\n  jmat = jas_matrix_create (height/2, width/2);\n  merror (jmat, \"redcine_load_raw()\");\n  img = (ushort *) calloc ((height+2), (width+2)*2);\n  merror (img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try {\n#endif\n  FORC4 {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);\n    data = jas_matrix_getref (jmat, 0, 0);\n    for (row = c >> 1; row < height; row+=2)\n      for (col = c & 1; col < width; col+=2)\n\timg[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];\n  }\n  for (col=1; col <= width; col++) {\n    img[col] = img[2*(width+2)+col];\n    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];\n  }\n  for (row=0; row < height+2; row++) {\n    img[row*(width+2)] = img[row*(width+2)+2];\n    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];\n  }\n  for (row=1; row <= height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));\n    for (   ; col <= width; col+=2, pix+=2) {\n      c = (((pix[0] - 0x800) << 3) +\n\tpix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;\n      pix[0] = LIM(c,0,4095);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    fastexitflag=true;\n  }\n#endif\n  free (img);\n  jas_matrix_destroy (jmat);\n  jas_image_destroy (jimg);\n  jas_stream_close (in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n    r, raw_pitch = raw_width*2,\n    c, m, mblack[8], zero, val;\n#else\n    c, m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw ||\n      load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width) {\n    for (row=0; row < raw_height-top_margin*2; row++) {\n      for (col=0; col < fuji_width << !fuji_layout; col++) {\n\tif (fuji_layout) {\n\t  r = fuji_width - 1 - col + (row >> 1);\n\t  c = col + ((row+1) >> 1);\n\t} else {\n\t  r = fuji_width - 1 + row - (col >> 1);\n\t  c = row + ((col+1) >> 1);\n\t}\n\tif (r < height && c < width)\n\t  BAYER(r,c) = RAW(row+top_margin,col+left_margin);\n      }\n    }\n  } else {\n    for (row=0; row < height; row++)\n      for (col=0; col < width; col++)\n\tBAYER2(row,col) = RAW(row+top_margin,col+left_margin);\n  }\n#endif\n  if (mask[0][3] > 0) goto mask_set;\n  if (load_raw == &CLASS canon_load_raw ||\n      load_raw == &CLASS lossless_jpeg_load_raw) {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw ||\n      load_raw == &CLASS sony_load_raw ||\n     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,\"DC2\",3)) ||\n      load_raw == &CLASS kodak_262_load_raw ||\n     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {\nsides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin+height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin+width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw) {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset (mblack, 0, sizeof mblack);\n  for (zero=m=0; m < 8; m++)\n    for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)\n      for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {\n\tc = FC(row-top_margin,col-left_margin);\n\tmblack[c] += val = raw_image[(row)*raw_pitch/2+(col)];\n\tmblack[4+c]++;\n\tzero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {\n    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /\n\t    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {\n    FORC4 cblack[c] = mblack[c] / mblack[4+c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,0,2);\n#endif\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      if (BAYER(row,col) == 0) {\n\ttot = n = 0;\n\tfor (r = row-2; r <= row+2; r++)\n\t  for (c = col-2; c <= col+2; c++)\n\t    if (r < height && c < width &&\n\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\n\t      tot += (n++,BAYER(r,c));\n\tif (n) BAYER(row,col) = tot/n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n#endif\n}\n\nstatic const uchar xlat[2][256] = {\n  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\n    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\n    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\n    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\n    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\n    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\n    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\n    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\n    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\n    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\n    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\n    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\n    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\n    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\n    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\n    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\n  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\n    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\n    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\n    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\n    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\n    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\n    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\n    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\n    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\n    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\n    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\n    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\n    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\n    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\n    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\n    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\n\nvoid CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2]={0,0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {\n    for (i=0; i < 48; i++) {\n      g[2] = (bnd[0] + bnd[1])/2;\n      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];\n      else\tbnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0]) g[4] = g[2] * (1/g[0] - 1);\n  }\n  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +\n\t\t(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;\n  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1\n\t\t- g[2] - g[3] -\tg[2]*g[3]*(log(g[3]) - 1)) - 1;\n  if (!mode--) {\n    memcpy (gamm, g, sizeof gamm);\n    return;\n  }\n  for (i=0; i < 0x10000; i++) {\n    curve[i] = 0xffff;\n    if ((r = (double) i / imax) < 1)\n      curve[i] = 0x10000 * ( mode\n\t? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))\n\t: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i=0; i < 3; i++) {\n    for (j=0; j < 6; j++)\n      work[i][j] = j == i+3;\n    for (j=0; j < 3; j++)\n      for (k=0; k < size; k++)\n\twork[i][j] += in[k][i] * in[k][j];\n  }\n  for (i=0; i < 3; i++) {\n    num = work[i][i];\n    for (j=0; j < 6; j++)\n      work[i][j] /= num;\n    for (k=0; k < 3; k++) {\n      if (k==i) continue;\n      num = work[k][i];\n      for (j=0; j < 6; j++)\n\twork[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i=0; i < size; i++)\n    for (j=0; j < 3; j++)\n      for (out[i][j]=k=0; k < 3; k++)\n\tout[i][j] += work[j][k+3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff (float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i=0; i < colors; i++)\t\t/* Multiply out XYZ colorspace */\n    for (j=0; j < 3; j++)\n      for (cam_rgb[i][j] = k=0; k < 3; k++)\n\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i=0; i < colors; i++) {\t\t/* Normalize cam_rgb so that */\n    for (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if(num > 0.00001)\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] /= num;\n        pre_mul[i] = 1 / num;\n      }\n    else\n      {\n        for (j=0; j < 3; j++)\n          cam_rgb[i][j] = 0.0;\n        pre_mul[i] = 1.0;\n      }\n  }\n  pseudoinverse (cam_rgb, inverse, colors);\n  for (i=0; i < 3; i++)\n    for (j=0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n// Coordinates of the GretagMacbeth ColorChecker squares\n// width, height, 1st_column, 1st_row\n  int cut[NSQ][4];\t\t\t// you must set these\n// ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {\n    { 0.400, 0.350, 10.1 },\t\t// Dark Skin\n    { 0.377, 0.345, 35.8 },\t\t// Light Skin\n    { 0.247, 0.251, 19.3 },\t\t// Blue Sky\n    { 0.337, 0.422, 13.3 },\t\t// Foliage\n    { 0.265, 0.240, 24.3 },\t\t// Blue Flower\n    { 0.261, 0.343, 43.1 },\t\t// Bluish Green\n    { 0.506, 0.407, 30.1 },\t\t// Orange\n    { 0.211, 0.175, 12.0 },\t\t// Purplish Blue\n    { 0.453, 0.306, 19.8 },\t\t// Moderate Red\n    { 0.285, 0.202, 6.6 },\t\t// Purple\n    { 0.380, 0.489, 44.3 },\t\t// Yellow Green\n    { 0.473, 0.438, 43.1 },\t\t// Orange Yellow\n    { 0.187, 0.129, 6.1 },\t\t// Blue\n    { 0.305, 0.478, 23.4 },\t\t// Green\n    { 0.539, 0.313, 12.0 },\t\t// Red\n    { 0.448, 0.470, 59.1 },\t\t// Yellow\n    { 0.364, 0.233, 19.8 },\t\t// Magenta\n    { 0.196, 0.252, 19.8 },\t\t// Cyan\n    { 0.310, 0.316, 90.0 },\t\t// White\n    { 0.310, 0.316, 59.1 },\t\t// Neutral 8\n    { 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\n    { 0.310, 0.316, 19.8 },\t\t// Neutral 5\n    { 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\n    { 0.310, 0.316, 3.1 } };\t\t// Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset (gmb_cam, 0, sizeof gmb_cam);\n  for (sq=0; sq < NSQ; sq++) {\n    FORCC count[c] = 0;\n    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\n      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\n\tc = FC(row,col);\n\tif (c >= colors) c -= 2;\n\tgmb_cam[sq][c] += BAYER2(row,col);\n\tBAYER2(row,col) = black + (BAYER2(row,col)-black)/2;\n\tcount[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] *\n\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse (gmb_xyz, inverse, NSQ);\n  for (pass=0; pass < 2; pass++) {\n    for (raw_color = i=0; i < colors; i++)\n      for (j=0; j < 3; j++)\n\tfor (cam_xyz[i][j] = k=0; k < NSQ; k++)\n\t  cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff (rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq=0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose) {\n    printf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j=0; j < 3; j++)\n      printf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\n    puts (\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i=0; i < sc; i++)\n    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\n  for (; i+sc < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\n  for (; i < size; i++)\n    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n  FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n    for (i=0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass=lev=0; lev < 5; lev++) {\n      lpass = size*((lev & 1)+1);\n      for (row=0; row < iheight; row++) {\n\that_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\tfor (col=0; col < iwidth; col++)\n\t  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n      }\n      for (col=0; col < iwidth; col++) {\n\that_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\tfor (row=0; row < iheight; row++)\n\t  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i=0; i < size; i++) {\n\tfimg[hpass+i] -= fimg[lpass+i];\n\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\telse\t fimg[hpass+i] = 0;\n\tif (hpass) fimg[i] += fimg[hpass+i];\n      }\n      hpass = lpass;\n    }\n    for (i=0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n  }\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n    for (row=0; row < 2; row++) {\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n    }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg=0, *temp, thold, mul[2], avg, diff;\n   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] =\n  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000) scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight*iwidth) < 0x15550000)\n    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);\n  merror (fimg, \"wavelet_denoise()\");\n  temp = fimg + size*3;\n  if ((nc = colors) == 3 && filters) nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)\n#endif\n  {\n      temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);\n    FORC(nc) {\t\t\t/* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass=lev=0; lev < 5; lev++) {\n\tlpass = size*((lev & 1)+1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (row=0; row < iheight; row++) {\n\t  hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);\n\t  for (col=0; col < iwidth; col++)\n\t    fimg[lpass + row*iwidth + col] = temp[col] * 0.25;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (col=0; col < iwidth; col++) {\n\t  hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);\n\t  for (row=0; row < iheight; row++)\n\t    fimg[lpass + row*iwidth + col] = temp[row] * 0.25;\n\t}\n\tthold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n\tfor (i=0; i < size; i++) {\n\t  fimg[hpass+i] -= fimg[lpass+i];\n\t  if\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\n\t  else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\n\t  else\t fimg[hpass+i] = 0;\n\t  if (hpass) fimg[i] += fimg[hpass+i];\n\t}\n\thpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i=0; i < size; i++)\n\timage[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n/* the following loops are hard to parallize, no idea yes,\n * problem is wlast which is carrying dependency\n * second part should be easyer, but did not yet get it right.\n */\n  if (filters && colors == 3) {  /* pull G1 and G3 closer together */\n   for (row=0; row < 2; row++){\n      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];\n      blk[row] = cblack[FC(row,0) | 1];\n   }\n    for (i=0; i < 4; i++)\n      window[i] = (ushort *) fimg + width*i;\n    for (wlast=-1, row=1; row < height-1; row++) {\n      while (wlast < row+1) {\n\tfor (wlast++, i=0; i < 4; i++)\n\t  window[(i+3) & 3] = window[i];\n\tfor (col = FC(wlast,1) & 1; col < width; col+=2)\n\t  window[2][col] = BAYER(wlast,col);\n      }\n      thold = threshold/512;\n      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {\n\tavg = ( window[0][col-1] + window[0][col+1] +\n\t\twindow[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )\n\t      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;\n\tavg = avg < 0 ? 0 : sqrt(avg);\n\tdiff = sqrt((double)BAYER(row,col)) - avg;\n\tif      (diff < -thold) diff += thold;\n\telse if (diff >  thold) diff -= thold;\n\telse diff = 0;\n\tBAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);\n      }\n    }\n  }\n  free (fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i,j;\n  double m1,m2,c1,c2;\n  int o1_1,o1_2,o1_3,o1_4;\n  int o2_1,o2_2,o2_3,o2_4;\n  ushort (*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if(half_size || shrink) return;\n  if(FC(oj, oi) != 3) oj++;\n  if(FC(oj, oi) != 3) oi++;\n  if(FC(oj, oi) != 3) oj--;\n\n  img = (ushort (*)[4]) calloc (height*width, sizeof *image);\n  merror (img, \"green_matching()\");\n  memcpy(img,image,height*width*sizeof *image);\n\n  for(j=oj;j<height-margin;j+=2)\n    for(i=oi;i<width-margin;i+=2){\n      o1_1=img[(j-1)*width+i-1][1];\n      o1_2=img[(j-1)*width+i+1][1];\n      o1_3=img[(j+1)*width+i-1][1];\n      o1_4=img[(j+1)*width+i+1][1];\n      o2_1=img[(j-2)*width+i][3];\n      o2_2=img[(j+2)*width+i][3];\n      o2_3=img[j*width+i-2][3];\n      o2_4=img[j*width+i+2][3];\n\n      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;\n      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;\n\n      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;\n      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;\n      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))\n      {\n        f = image[j*width+i][3]*m1/m2;\n        image[j*width+i][3]=f>0xffff?0xffff:f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img=0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);\n#endif\n\n  if (user_mul[0])\n    memcpy (pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {\n    memset (dsum, 0, sizeof dsum);\n    bottom = MIN (greybox[1]+greybox[3], height);\n    right  = MIN (greybox[0]+greybox[2], width);\n    for (row=greybox[1]; row < bottom; row += 8)\n      for (col=greybox[0]; col < right; col += 8) {\n\tmemset (sum, 0, sizeof sum);\n\tfor (y=row; y < row+8 && y < bottom; y++)\n\t  for (x=col; x < col+8 && x < right; x++)\n\t    FORC4 {\n\t      if (filters) {\n\t\tc = fcol(y,x);\n\t\tval = BAYER2(y,x);\n\t      } else\n\t\tval = image[y*width+x][c];\n\t      if (val > maximum-25) goto skip_block;\n\t      if ((val -= cblack[c]) < 0) val = 0;\n\t      sum[c] += val;\n\t      sum[c+4]++;\n\t      if (filters) break;\n\t    }\n\tFORC(8) dsum[c] += sum[c];\nskip_block: ;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1) {\n    memset (sum, 0, sizeof sum);\n    for (row=0; row < 8; row++)\n      for (col=0; col < 8; col++) {\n\tc = FC(row,col);\n\tif ((val = white[row][col] - cblack[c]) > 0)\n\t  sum[c] += val;\n\tsum[c+4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(load_raw == &LibRaw::nikon_load_sraw)\n      {\n        // Nikon sRAW: camera WB already applied:\n        pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;\n      }\n    else\n#endif\n    if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy (pre_mul, cam_mul, sizeof pre_mul);\n    else\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n            fprintf (stderr,_(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n      }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw\n      && !use_camera_wb && !use_auto_wb\n      && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )\n    {\n      for(c=0;c<3;c++)\n        pre_mul[c]/=cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0) pre_mul[1] = 1;\n  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold) wavelet_denoise();\n  maximum -= black;\n  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\n    if (dmin > pre_mul[c])\n\tdmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n\tdmax = pre_mul[c];\n  }\n  if (!highlight) dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose) {\n    fprintf (stderr,\n      _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf (stderr, \" %f\", pre_mul[c]);\n    fputc ('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {\n    FORC4 cblack[FC(c/2,c%2)] +=\n\tcblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight*iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i=0; i < size*4; i++) {\n    if (!(val = ((ushort *)image)[i])) continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +\n\t\t\ti/4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c=0; c < 4; c+=2) {\n      if (aber[c] == 1) continue;\n      img = (ushort *) malloc (size * sizeof *img);\n      merror (img, \"scale_colors()\");\n      for (i=0; i < size; i++)\n\timg[i] = image[i][c];\n      for (row=0; row < iheight; row++) {\n\tur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;\n\tif (ur > iheight-2) continue;\n\tfr -= ur;\n\tfor (col=0; col < iwidth; col++) {\n\t  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;\n\t  if (uc > iwidth-2) continue;\n\t  fc -= uc;\n\t  pix = img + ur*iwidth + uc;\n\t  image[row*iwidth+col][c] =\n\t    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\n\t    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;\n\t}\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,1,2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort (*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,0,2);\n#endif\n  if (shrink) {\n    if (half_size) {\n      height = iheight;\n      width  = iwidth;\n      if (filters == 9) {\n\tfor (row=0; row < 3; row++)\n\t  for (col=1; col < 4; col++)\n\t    if (!(image[row*width+col][0] | image[row*width+col][2]))\n\t      goto break2;  break2:\n\tfor ( ; row < height; row+=3)\n\t  for (col=(col-1)%3+1; col < width-1; col+=3) {\n\t    img = image + row*width+col;\n\t    for (c=0; c < 3; c+=2)\n\t      img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n\t  }\n      }\n    } else {\n      img = (ushort (*)[4]) calloc (height, width*sizeof *img);\n      merror (img, \"pre_interpolate()\");\n      for (row=0; row < height; row++)\n\tfor (col=0; col < width; col++) {\n\t  c = fcol(row,col);\n\t  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];\n\t}\n      free (image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3) {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size) colors++;\n    else {\n      for (row = FC(1,0) >> 1; row < height; row+=2)\n\tfor (col = FC(row,1) & 1; col < width; col+=2)\n\t  image[row*width+col][1] = image[row*width+col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size) filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE,1,2);\n#endif\n}\n\nvoid CLASS border_interpolate (int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      if (col==border && row >= border && row < height-border)\n\tcol = width-border;\n      memset (sum, 0, sizeof sum);\n      for (y=row-1; y != row+2; y++)\n\tfor (x=col-1; x != col+2; x++)\n\t  if (y < height && x < width) {\n\t    f = fcol(y,x);\n\t    sum[f] += image[y*width+x][f];\n\t    sum[f+4]++;\n\t  }\n      f = fcol(row,col);\n      FORCC if (c != f && sum[c+4])\n\timage[row*width+col][c] = sum[c] / sum[c+4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32],int size)\n{\n  int row;\n  for (row=1; row < height-1; row++)\n    {\n      int col,*ip;\n      ushort *pix;\n      for (col=1; col < width-1; col++) {\n        int i;\n        int sum[4];\n        pix = image[row*width+col];\n        ip = code[row % size][col % size];\n        memset (sum, 0, sizeof sum);\n        for (i=*ip++; i--; ip+=3)\n          sum[ip[2]] += pix[ip[0]] << ip[1];\n        for (i=colors; --i; ip+=2)\n          pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n      }\n    }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size=16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#endif\n\n  if (filters == 9) size = 6;\n  border_interpolate(1);\n  for (row=0; row < size; row++)\n    for (col=0; col < size; col++) {\n      ip = code[row][col]+1;\n      f = fcol(row,col);\n      memset (sum, 0, sizeof sum);\n      for (y=-1; y <= 1; y++)\n\tfor (x=-1; x <= 1; x++) {\n\t  shift = (y==0) + (x==0);\n\t  color = fcol(row+y,col+x);\n\t  if (color == f) continue;\n\t  *ip++ = (width*y + x)*4 + color;\n\t  *ip++ = shift;\n\t  *ip++ = color;\n\t  sum[color] += 1 << shift;\n\t}\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n\tif (c != f) {\n\t  *ip++ = c;\n\t  *ip++ = sum[c]>0?256 / sum[c]:0;\n\t}\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#endif\n  lin_interpolate_loop(code,size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp, terms[] = {\n    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\n    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\n    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\n    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\n    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\n    -1,-2,-1,+0,0,-128, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\n    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,-120, -1,-1,+1,-2,0,0x40,\n    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\n    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\n    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\n    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\n    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\n    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\n    +0,-2,+0,+0,1,-128, +0,-1,+0,+1,1,-120, +0,-1,+1,-2,0,0x40,\n    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\n    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\n    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\n    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\n    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\n    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,-128,\n    +1,-1,+1,+1,0,-120, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\n    +1,+0,+2,+1,0,0x10\n  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\n  ushort (*brow[5])[4], *pix;\n  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1) prow = pcol = 16;\n  if (filters == 9) prow = pcol =  6;\n  ip = (int *) calloc (prow*pcol, 1280);\n  merror (ip, \"vng_interpolate()\");\n  for (row=0; row < prow; row++)\t\t/* Precalculate for VNG */\n    for (col=0; col < pcol; col++) {\n      code[row][col] = ip;\n      for (cp=terms, t=0; t < 64; t++) {\n\ty1 = *cp++;  x1 = *cp++;\n\ty2 = *cp++;  x2 = *cp++;\n\tweight = *cp++;\n\tgrads = *cp++;\n\tcolor = fcol(row+y1,col+x1);\n\tif (fcol(row+y2,col+x2) != color) continue;\n\tdiag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;\n\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\n\t*ip++ = (y1*width + x1)*4 + color;\n\t*ip++ = (y2*width + x2)*4 + color;\n\t*ip++ = weight;\n\tfor (g=0; g < 8; g++)\n\t  if (grads & 1<<g) *ip++ = g;\n\t*ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp=chood, g=0; g < 8; g++) {\n\ty = *cp++;  x = *cp++;\n\t*ip++ = (y*width + x) * 4;\n\tcolor = fcol(row,col);\n\tif (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)\n\t  *ip++ = (y*width + x) * 8 + color;\n\telse\n\t  *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);\n  merror (brow[4], \"vng_interpolate()\");\n  for (row=0; row < 3; row++)\n    brow[row] = brow[4] + row*width;\n  for (row=2; row < height-2; row++) {\t\t/* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if(!((row-2)%256))RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,(row-2)/256+1,((height-3)/256)+1);\n#endif\n    for (col=2; col < width-2; col++) {\n      pix = image[row*width+col];\n      ip = code[row % prow][col % pcol];\n      memset (gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\n\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n\tgval[ip[3]] += diff;\n\tip += 5;\n\tif ((g = ip[-1]) == -1) continue;\n\tgval[g] += diff;\n\twhile ((g = *ip++) != -1)\n\t  gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0];\t\t\t/* Choose a threshold */\n      for (g=1; g < 8; g++) {\n\tif (gmin > gval[g]) gmin = gval[g];\n\tif (gmax < gval[g]) gmax = gval[g];\n      }\n      if (gmax == 0) {\n\tmemcpy (brow[2][col], pix, sizeof *image);\n\tcontinue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset (sum, 0, sizeof sum);\n      color = fcol(row,col);\n      for (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\n\tif (gval[g] <= thold) {\n\t  FORCC\n\t    if (c == color && ip[1])\n\t      sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n\t    else\n\t      sum[c] += pix[ip[0] + c];\n\t  num++;\n\t}\n      }\n      FORCC {\t\t\t\t\t/* Save to buffer */\n\tt = pix[color];\n\tif (c != color)\n\t  t += (sum[c] - sum[color]) / num;\n\tbrow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3)\t\t\t\t/* Write buffer to image */\n      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n    for (g=0; g < 4; g++)\n      brow[(g-1) & 3] = brow[g];\n  }\n  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);\n  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);\n  free (brow[4]);\n  free (code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = { 1, width, -1, -width, 1 };\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort (*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=3; row < height-3; row++)\n    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; i++) {\n\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\n\t\t      - pix[-2*d][c] - pix[2*d][c];\n\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[ 2*d][c] - pix[ 0][c]) +\n\t\t    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\n\t\t  ( ABS(pix[ 3*d][1] - pix[ d][1]) +\n\t\t    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]) > 0; c=2-c, i++)\n\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row=1; row < height-1; row++)\n    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {\n      pix = image + row*width+col;\n      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\n\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\n\t\t  ABS(pix[-d][1] - pix[0][1]) +\n\t\t  ABS(pix[ d][1] - pix[0][1]);\n\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\n\t\t - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab (ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb) {\n#ifndef LIBRAW_NOTHREADS\n    if(cbrt[0] < -1.0f)\n#endif\n    for (i=0; i < 0x10000; i++) {\n      r = i / 65535.0;\n      cbrt[i] = r > 0.008856 ? pow(r,1.f/3.0f) : 7.787f*r + 16.f/116.0f;\n    }\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (xyz_cam[i][j] = k=0; k < 3; k++)\n\t  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int) xyz[0])];\n  xyz[1] = cbrt[CLIP((int) xyz[1])];\n  xyz[2] = cbrt[CLIP((int) xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512\t\t/* Tile Size */\n#define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate (int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int cstat[4]={0,0,0,0};\n#endif\n\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },\n\tpatt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },\n\t\t\t{ 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },\n\tdir[4] = { 1,TS,TS+1,TS-1 };\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)    [TS][3], (*lix)[3];\n   float (*drv)[TS][TS], diff[6], tr;\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/* Check against right pattern */\n  for (row = 0; row < 6; row++)\n         for (col = 0; col < 6; col++)\n                 cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16 \n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n         throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n\n  cielab (0,0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *) malloc (TS*TS*(ndir*11+6));\n  merror (buffer, \"xtrans_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));\n  drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));\n  homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));\n\n/* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row=0; row < 3; row++)\n    for (col=0; col < 3; col++)\n      for (ng=d=0; d < 10; d+=2) {\n\tg = fcol(row,col) == 1;\n\tif (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;\n\tif (ng == 4) { sgrow = row; sgcol = col; }\n\tif (ng == g+1) FORC(8) {\n\t  v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];\n\t  h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];\n\t  allhex[row][col][0][c^(g*2 & d)] = h + v*width;\n\t  allhex[row][col][1][c^(g*2 & d)] = h + v*TS;\n\t}\n      }\n\n/* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row=2; row < height-2; row++)\n    for (min=~(max=0), col=2; col < width-2; col++) {\n      if (fcol(row,col) == 1 && (min=~(max=0))) continue;\n      pix = image + row*width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max) FORC(6) {\n\tval = pix[hex[c]][1];\n\tif (min > val) min = val;\n\tif (max < val) max = val;\n      }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row-sgrow) % 3) {\n\tcase 1: if (row < height-3) { row++; col--; } break;\n\tcase 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;\n      }\n    }\n\n  for (top=3; top < height-19; top += TS-16)\n    for (left=3; left < width-19; left += TS-16) {\n      mrow = MIN (top+TS, height-3);\n      mcol = MIN (left+TS, width-3);\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++)\n\t  memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);\n      FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);\n\n/* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row=top; row < mrow; row++)\n\tfor (col=left; col < mcol; col++) {\n\t  if ((f = fcol(row,col)) == 1) continue;\n\t  pix = image + row*width + col;\n\t  hex = allhex[row % 3][col % 3][0];\n\t  color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -\n\t\t\t 46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);\n\t  color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +\n\t\t\t 92 * (pix[      0 ][f] - pix[ -hex[2]][f]);\n\t  FORC(2) color[1][2+c] =\n\t\t164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *\n\t\t(2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);\n\t  FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =\n\t\tLIM(color[1][c] >> 8,pix[0][1],pix[0][3]);\n\t}\n\n      for (pass=0; pass < passes; pass++) {\n\tif (pass == 1)\n\t  memcpy (rgb+=4, buffer, 4*sizeof *rgb);\n\n/* Recalculate green from interpolated values of closer pixels:\t*/\n\tif (pass) {\n\t  for (row=top+2; row < mrow-2; row++)\n\t    for (col=left+2; col < mcol-2; col++) {\n\t      if ((f = fcol(row,col)) == 1) continue;\n\t      pix = image + row*width + col;\n\t      hex = allhex[row % 3][col % 3][1];\n\t      for (d=3; d < 6; d++) {\n\t\trix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];\n\t\tval = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]\n\t\t    - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];\n\t\trix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);\n\t      }\n\t    }\n\t}\n\n/* Interpolate red and blue values for solitary green pixels:\t*/\n\tfor (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)\n\t  for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    h = fcol(row,col+1);\n\t    memset (diff, 0, sizeof diff);\n\t    for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {\n\t      for (c=0; c < 2; c++, h^=2) {\n\t\tg = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];\n\t\tcolor[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];\n\t\tif (d > 1)\n\t\t  diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]\n\t\t\t\t- rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);\n\t      }\n\t      if (d > 1 && (d & 1))\n\t\tif (diff[d-1] < diff[d])\n\t\t  FORC(2) color[c*2][d] = color[c*2][d-1];\n\t      if (d < 2 || (d & 1)) {\n\t\tFORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);\n\t\trix += TS*TS;\n\t      }\n\t    }\n\t  }\n\n/* Interpolate red for blue pixels and vice versa:\t\t*/\n\tfor (row=top+3; row < mrow-3; row++)\n\t  for (col=left+3; col < mcol-3; col++) {\n\t    if ((f = 2-fcol(row,col)) == 1) continue;\n\t    rix = &rgb[0][row-top][col-left];\n\t    c = (row-sgrow) % 3 ? TS:1;\n\t    h = 3 * (c ^ TS ^ 1);\n\t    for (d=0; d < 4; d++, rix += TS*TS) {\n\t      i = d > 1 || ((d ^ c) & 1) ||\n\t\t ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <\n\t\t2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;\n\t      rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +\n\t\t  2*rix[0][1] - rix[i][1] - rix[-i][1])/2);\n\t    }\n\t  }\n\n/* Fill in red and blue for 2x2 blocks of green:\t\t*/\n\tfor (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)\n\t  for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {\n\t    rix = &rgb[0][row-top][col-left];\n\t    hex = allhex[row % 3][col % 3][1];\n\t    for (d=0; d < ndir; d+=2, rix += TS*TS)\n\t      if (hex[d] + hex[d+1]) {\n\t\tg = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);\n\t      } else {\n\t\tg = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];\n\t\tfor (c=0; c < 4; c+=2) rix[0][c] =\n\t\t\tCLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);\n\t      }\n\t  }\n      }\n      rgb = (ushort(*)[TS][TS][3]) buffer;\n      mrow -= top;\n      mcol -= left;\n\n/* Convert to CIELab and differentiate in all directions:\t*/\n      for (d=0; d < ndir; d++) {\n\tfor (row=2; row < mrow-2; row++)\n\t  for (col=2; col < mcol-2; col++)\n\t    cielab (rgb[d][row][col], lab[row][col]);\n\tfor (f=dir[d & 3],row=3; row < mrow-3; row++)\n\t  for (col=3; col < mcol-3; col++) {\n\t    lix = &lab[row][col];\n\t    g = 2*lix[0][0] - lix[f][0] - lix[-f][0];\n\t    drv[d][row][col] = SQR(g)\n\t      + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))\n\t      + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));\n\t  }\n      }\n\n/* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir*TS*TS);\n      for (row=4; row < mrow-4; row++)\n\tfor (col=4; col < mcol-4; col++) {\n\t  for (tr=FLT_MAX, d=0; d < ndir; d++)\n\t    if (tr > drv[d][row][col])\n\t\ttr = drv[d][row][col];\n\t  tr *= 8;\n\t  for (d=0; d < ndir; d++)\n\t    for (v=-1; v <= 1; v++)\n\t      for (h=-1; h <= 1; h++)\n\t\tif (drv[d][row+v][col+h] <= tr)\n\t\t  homo[d][row][col]++;\n\t}\n\n/* Average the most homogenous pixels for the final result:\t*/\n      if (height-top < TS+4) mrow = height-top+2;\n      if (width-left < TS+4) mcol = width-left+2;\n      for (row = MIN(top,8); row < mrow-8; row++)\n\tfor (col = MIN(left,8); col < mcol-8; col++) {\n\t  for (d=0; d < ndir; d++)\n\t    for (hm[d]=0, v=-2; v <= 2; v++)\n\t      for (h=-2; h <= 2; h++)\n\t\thm[d] += homo[d][row+v][col+h];\n\t  for (d=0; d < ndir-4; d++)\n\t    if (hm[d] < hm[d+4]) hm[d  ] = 0; else\n\t    if (hm[d] > hm[d+4]) hm[d+4] = 0;\n\t  for (max=hm[0],d=1; d < ndir; d++)\n\t    if (max < hm[d]) max = hm[d];\n\t  max -= max >> 3;\n\t  memset (avg, 0, sizeof avg);\n\t  for (d=0; d < ndir; d++)\n\t    if (hm[d] >= max) {\n\t      FORC3 avg[c] += rgb[d][row][col][c];\n\t      avg[3]++;\n\t    }\n\t  FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];\n\t}\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort (*pix)[4];\n  const int rowlimit = MIN(top+TS, height-2);\n  const int collimit = MIN(left+TS, width-2);\n\n  for (row = top; row < rowlimit; row++) {\n    col = left + (FC(row,left) & 1);\n    for (c = FC(row,col); col < collimit; col+=2) {\n      pix = image + row*width+col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n            - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n            - pix[-2*width][c] - pix[2*width][c]) >> 2;\n      out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort (*pix)[4];\n  ushort (*rix)[3];\n  short (*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4*width;\n  const unsigned rowlimit = MIN(top+TS-1, height-3);\n  const unsigned collimit = MIN(left+TS-1, width-3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top+1; row < rowlimit; row++) {\n    pix = image + row*width + left;\n    rix = &inout_rgb[row-top][0];\n    lix = &out_lab[row-top][0];\n\n    for (col = left+1; col < collimit; col++) {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1) {\n        c = FC(row+1,col);\n\tt1 = 2-c;\n        val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]\n              - rix[-1][1] - rix[1][1] ) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + (( pix_above[c] + pix_below[c]\n              - rix[-TS][1] - rix[TS][1] ) >> 1);\n      } else {\n\tt1 = -4+c; /* -4+c: pixel of color c to the left */\n\tt2 = 4+c; /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + (( pix_above[t1] + pix_above[t2]\n              + pix_below[t1] + pix_below[t2]\n              - rix[-TS-1][1] - rix[-TS+1][1]\n              - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row,col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0],lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++) {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short (*lix)[3];\n  short (*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = { -1, 1, -TS, TS };\n  const int rowlimit = MIN(top+TS-2, height-4);\n  const int collimit = MIN(left+TS-2, width-4);\n  int homogeneity;\n  char (*homogeneity_map_p)[2];\n\n  memset (out_homogeneity_map, 0, 2*TS*TS);\n\n  for (row=top+2; row < rowlimit; row++) {\n    tr = row-top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction=0; direction < 2; direction++) {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col=left+2; col < collimit; col++) {\n      tc = col-left;\n      homogeneity_map_p++;\n\n      for (direction=0; direction < 2; direction++) {\n        lix = ++lixs[direction];\n        for (i=0; i < 4; i++) {\n\t  adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])\n            + SQR(lix[0][2]-adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n          MAX(ldiff[1][2],ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n          MAX(abdiff[1][2],abdiff[1][3]));\n      for (direction=0; direction < 2; direction++) {\n\thomogeneity = 0;\n        for (i=0; i < 4; i++) {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {\n\t    homogeneity++;\n\t  }\n\t}\n\thomogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top+TS-3, height-5);\n  const int collimit = MIN(left+TS-3, width-5);\n\n  ushort (*pix)[4];\n  ushort (*rix[2])[3];\n\n  for (row=top+3; row < rowlimit; row++) {\n    tr = row-top;\n    pix = &image[row*width+left+2];\n    for (direction = 0; direction < 2; direction++) {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col=left+3; col < collimit; col++) {\n      tc = col-left;\n      pix++;\n      for (direction = 0; direction < 2; direction++) {\n        rix[direction]++;\n      }\n\n      for (direction=0; direction < 2; direction++) {\n        hm[direction] = 0;\n        for (i=tr-1; i <= tr+1; i++) {\n          for (j=tc-1; j <= tc+1; j++) {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1]) {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      } else {\n        FORC3 {\n          pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;\n        }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4],r;\n  char *buffer;\n  ushort (*rgb)[TS][TS][3];\n  short (*lab)[TS][TS][3];\n  char (*homo)[TS][2];\n  int terminate_flag = 0;\n\n\n  cielab(0,0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\n    merror (buffer, \"ahd_interpolate()\");\n    rgb  = (ushort(*)[TS][TS][3]) buffer;\n    lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n    homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top=2; top < height-5; top += TS-6){\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n        if(0== omp_get_thread_num())\n#endif\n           if(callbacks.progress_cb) {\n               int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);\n               if(rr)\n                   terminate_flag = 1;\n           }\n#endif\n        for (left=2; !terminate_flag && (left < width-5); left += TS-6) {\n            ahd_interpolate_green_h_and_v(top, left, rgb);\n            ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n            ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n            ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free (buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(terminate_flag)\n      throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = { -1, 1, -TS, TS };\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n   short (*lab)[TS][TS][3], (*lix)[3];\n   char (*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab (0,0);\n  border_interpolate(5);\n  buffer = (char *) malloc (26*TS*TS);\n  merror (buffer, \"ahd_interpolate()\");\n  rgb  = (ushort(*)[TS][TS][3]) buffer;\n  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\n  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\n\n  for (top=2; top < height-5; top += TS-6)\n    for (left=2; left < width-5; left += TS-6) {\n\n/*  Interpolate green horizontally and vertically:\t\t*/\n      for (row=top; row < top+TS && row < height-2; row++) {\n\tcol = left + (FC(row,left) & 1);\n\tfor (c = FC(row,col); col < left+TS && col < width-2; col+=2) {\n\t  pix = image + row*width+col;\n\t  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\n\t\t- pix[-2][c] - pix[2][c]) >> 2;\n\t  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\n\t  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2\n\t\t- pix[-2*width][c] - pix[2*width][c]) >> 2;\n\t  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);\n\t}\n      }\n\n/*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d=0; d < 2; d++)\n\tfor (row=top+1; row < top+TS-1 && row < height-3; row++)\n\t  for (col=left+1; col < left+TS-1 && col < width-3; col++) {\n\t    pix = image + row*width+col;\n\t    rix = &rgb[d][row-top][col-left];\n\t    lix = &lab[d][row-top][col-left];\n\t    if ((c = 2 - FC(row,col)) == 1) {\n\t      c = FC(row+1,col);\n\t      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\n\t\t\t\t - rix[-1][1] - rix[1][1] ) >> 1);\n\t      rix[0][2-c] = CLIP(val);\n\t      val = pix[0][1] + (( pix[-width][c] + pix[width][c]\n\t\t\t\t - rix[-TS][1] - rix[TS][1] ) >> 1);\n\t    } else\n\t      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]\n\t\t\t\t + pix[+width-1][c] + pix[+width+1][c]\n\t\t\t\t - rix[-TS-1][1] - rix[-TS+1][1]\n\t\t\t\t - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\n\t    rix[0][c] = CLIP(val);\n\t    c = FC(row,col);\n\t    rix[0][c] = pix[0][c];\n\t    cielab (rix[0],lix[0]);\n\t  }\n/*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset (homo, 0, 2*TS*TS);\n      for (row=top+2; row < top+TS-2 && row < height-4; row++) {\n\ttr = row-top;\n\tfor (col=left+2; col < left+TS-2 && col < width-4; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++) {\n\t    lix = &lab[d][tr][tc];\n\t    for (i=0; i < 4; i++) {\n\t       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\n\t      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\n\t\t\t   + SQR(lix[0][2]-lix[dir[i]][2]);\n\t    }\n\t  }\n\t  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\n\t\t     MAX(ldiff[1][2],ldiff[1][3]));\n\t  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\n\t\t      MAX(abdiff[1][2],abdiff[1][3]));\n\t  for (d=0; d < 2; d++)\n\t    for (i=0; i < 4; i++)\n\t      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n\t\thomo[d][tr][tc]++;\n\t}\n      }\n/*  Combine the most homogenous pixels for the final result:\t*/\n      for (row=top+3; row < top+TS-3 && row < height-5; row++) {\n\ttr = row-top;\n\tfor (col=left+3; col < left+TS-3 && col < width-5; col++) {\n\t  tc = col-left;\n\t  for (d=0; d < 2; d++)\n\t    for (hm[d]=0, i=tr-1; i <= tr+1; i++)\n\t      for (j=tc-1; j <= tc+1; j++)\n\t\thm[d] += homo[d][i][j];\n\t  if (hm[0] != hm[1])\n\t    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n\t  else\n\t    FORC3 image[row*width+col][c] =\n\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n\t}\n      }\n    }\n  free (buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort (*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] =\t/* Optimal 9-element median search */\n  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\n\n  for (pass=1; pass <= med_passes; pass++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER,pass-1,med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c=0; c < 3; c+=2) {\n      for (pix = image; pix < image+width*height; pix++)\n\tpix[0][3] = pix[0][c];\n      for (pix = image+width; pix < image+width*(height-1); pix++) {\n\tif ((pix-image+1) % width < 2) continue;\n\tfor (k=0, i = -width; i <= width; i += width)\n\t  for (j = i-1; j <= i+1; j++)\n\t    med[k++] = pix[j][3] - pix[j][1];\n\tfor (i=0; i < sizeof opt; i+=2)\n\t  if     (med[opt[i]] > med[opt[i+1]])\n\t    SWAP (med[opt[i]] , med[opt[i+1]]);\n\tpix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip=INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] =\n  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  static const float itrans[2][4][4] =\n  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned) (colors-3) > 1) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,0,2);\n#endif\n  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++) {\n      FORCC if (image[row*width+col][c] > clip) break;\n      if (c == colors) continue;\n      FORCC {\n\tcam[0][c] = image[row*width+col][c];\n\tcam[1][c] = MIN(cam[0][c],clip);\n      }\n      for (i=0; i < 2; i++) {\n\tFORCC for (lab[i][c]=j=0; j < colors; j++)\n\t  lab[i][c] += trans[colors-3][c][j] * cam[i][j];\n\tfor (sum[i]=0,c=1; c < colors; c++)\n\t  sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1]/sum[0]);\n      for (c=1; c < colors; c++)\n\tlab[0][c] *= chratio;\n      FORCC for (cam[0][c]=j=0; j < colors; j++)\n\tcam[0][c] += itrans[colors-3][c][j] * lab[0][j];\n      FORCC image[row*width+col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,1,2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] =\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\n\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow (2.0, 4-highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc=0, c=1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c]) kc = c;\n  high = height / SCALE;\n  wide =  width / SCALE;\n  map = (float *) calloc (high, wide*sizeof *map);\n  merror (map, \"recover_highlights()\");\n  FORCC if (c != kc) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS,c-1,colors-1);\n#endif\n    memset (map, 0, high*wide*sizeof *map);\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tsum = wgt = count = 0;\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\n\t      sum += pixel[c];\n\t      wgt += pixel[kc];\n\t      count++;\n\t    }\n\t  }\n\tif (count == SCALE*SCALE)\n\t  map[mrow*wide+mcol] = sum / wgt;\n      }\n    for (spread = 32/grow; spread--; ) {\n      for (mrow=0; mrow < high; mrow++)\n\tfor (mcol=0; mcol < wide; mcol++) {\n\t  if (map[mrow*wide+mcol]) continue;\n\t  sum = count = 0;\n\t  for (d=0; d < 8; d++) {\n\t    y = mrow + dir[d][0];\n\t    x = mcol + dir[d][1];\n\t    if (y < high && x < wide && map[y*wide+x] > 0) {\n\t      sum  += (1 + (d & 1)) * map[y*wide+x];\n\t      count += 1 + (d & 1);\n\t    }\n\t  }\n\t  if (count > 3)\n\t    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);\n\t}\n      for (change=i=0; i < high*wide; i++)\n\tif (map[i] < 0) {\n\t  map[i] = -map[i];\n\t  change = 1;\n\t}\n      if (!change) break;\n    }\n    for (i=0; i < high*wide; i++)\n      if (map[i] == 0) map[i] = 1;\n    for (mrow=0; mrow < high; mrow++)\n      for (mcol=0; mcol < wide; mcol++) {\n\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\n\t  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\n\t    pixel = image[row*width+col];\n\t    if (pixel[c] / hsat[c] > 1) {\n\t      val = pixel[kc] * map[mrow*wide+mcol];\n\t      if (pixel[c] < val) pixel[c] = CLIP(val);\n\t    }\n\t  }\n      }\n  }\n  free (map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get (unsigned base,\n\tunsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag  = get2();\n  *type = get2();\n  *len  = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type:0]-'0') > 4)\n    fseek (ifp, get4()+base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == toff) thumb_offset = get4()+base;\n    if (tag == tlen) thumb_length = get4();\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nstatic float powf_lim(float a, float b, float limup)\n{\n  return (b>limup || b < -limup)?0.f:powf(a,b);\n}\nstatic float powf64(float a, float b)\n{\n  return powf_lim(a,b,64.f);\n}\n\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x) {\n  float t;\n  if (x >= 0.0) {\n    t = ceilf(x);\n    if (t - x > 0.5) t -= 1.0;\n    return t;\n  } else {\n    t = ceilf(-x);\n    if (t + x > 0.5) t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff)) return 0.0f;\n  return powf64(2.0, in/64.0);\n}\n\nstatic float _CanonConvertEV (short in)\n{\n\tshort EV, Sign, Frac;\n\tfloat Frac_f;\n\tEV = in;\n\tif (EV < 0) {\n\t  EV = -EV;\n\t  Sign = -1;\n\t} else {\n\t  Sign = 1;\n\t}\n\tFrac = EV & 0x1f;\n\tEV -= Frac;\t\t\t// remove fraction\n\n\tif (Frac == 0x0c) {\t\t// convert 1/3 and 2/3 codes\n\t  Frac_f = 32.0f / 3.0f;\n\t} else if (Frac == 0x14) {\n\t  Frac_f = 64.0f / 3.0f;\n\t} else Frac_f = (float) Frac;\n\n\treturn ((float)Sign * ((float)EV + Frac_f))/32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures (unsigned id)\n      {\n      imgdata.lens.makernotes.CamID = id;\n\tif (\n            (id == 0x80000001) ||\t// 1D\n            (id == 0x80000174) ||\t// 1D2\n            (id == 0x80000232) ||\t// 1D2N\n            (id == 0x80000169) ||\t// 1D3\n            (id == 0x80000281)\t\t// 1D4\n            )\n          {\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n          }\n        else\n          if (\n              (id == 0x80000167) ||\t// 1Ds\n              (id == 0x80000188) ||\t// 1Ds2\n              (id == 0x80000215) ||\t// 1Ds3\n              (id == 0x80000269) ||\t// 1DX\n              (id == 0x80000328) ||\t// 1DX2\n              (id == 0x80000324) ||\t// 1DC\n              (id == 0x80000213) ||\t// 5D\n              (id == 0x80000218) ||\t// 5D2\n              (id == 0x80000285) ||\t// 5D3\n              (id == 0x80000349) ||\t// 5D4\n              (id == 0x80000382) ||\t// 5DS\n              (id == 0x80000401) ||\t// 5DS R\n              (id == 0x80000302) \t// 6D\n              )\n            {\n              imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n            }\n          else\n            if (\n                (id == 0x80000331) ||\t// M\n                (id == 0x80000355) ||\t// M2\n                (id == 0x80000374) || \t// M3\n                (id == 0x80000384) || \t// M10\n                (id == 0x80000394)  \t// M5\n                )\n              {\n                imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n              }\n            else\n              if (\n                  (id == 0x01140000) ||\t// D30\n                  (id == 0x01668000) ||\t// D60\n                  (id > 0x80000000)\n                  )\n                {\n                  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n                }\n              else\n                {\n                  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                }\n\n\treturn;\n      }\n\nvoid CLASS processCanonCameraInfo (unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0;\n  if(maxlen<16) return; // too short, so broken\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id) {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal  = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12)) iCanonLensID = 151;\n    else iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n    {\n      if(iCanonFocalType>=maxlen) return; // broken;\n      imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n      if (!imgdata.lens.makernotes.FocalType)\t// zero means 'fixed' here, replacing with standard '1'\n        imgdata.lens.makernotes.FocalType = 1;\n    }\n  if (!imgdata.lens.makernotes.CurFocal)\n    {\n      if(iCanonCurFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n    }\n  if (!imgdata.lens.makernotes.LensID)\n    {\n      if(iCanonLensID>=maxlen) return; // broken;\n      imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n    }\n  if (!imgdata.lens.makernotes.MinFocal)\n    {\n      if(iCanonMinFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n    }\n  if (!imgdata.lens.makernotes.MaxFocal)\n    {\n      if(iCanonMaxFocal>=maxlen) return; // broken;\n      imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n    }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens) {\n    if(iCanonLens+64>=maxlen) return; // broken;\n    if (CameraInfo[iCanonLens] < 65)\t\t\t\t\t\t\t\t// non-Canon lens\n      {\n        memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n      }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n      {\n        memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n        memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n        memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4)) {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings ()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2(); get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2(); get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2(); get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets (int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1) fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2) fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets (short WBCTversion)\n{\n\tif (WBCTversion == 0)\n\t  for (int i=0; i<15; i++)// tint, as shot R, as shot B, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f /fMAX(get2(),1.f) ;\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f /fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if (WBCTversion == 1)\n\t  for (int i=0; i<15; i++)\t// as shot R, as shot B, tint, C\u0421T\n\t    {\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(),1.f);\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(),1.f);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n\t\t((unique_id == 0x80000374) ||\t// M3\n\t\t (unique_id == 0x80000384) ||\t// M10\n\t\t (unique_id == 0x80000394) ||\t// M5\n\t\t (unique_id == 0x03970000)))\t// G7 X Mark II\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f,get2());\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\telse if ((WBCTversion == 2) &&\n                ((unique_id == 0x03950000) || (unique_id == 0x03930000)))\t// G5 X, G9 X\n\t  for (int i=0; i<15; i++)\t// tint, offset, as shot R, as shot B, C\u0421T\n\t    {\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\tfseek (ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n\t\timgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n\t\timgdata.color.WBCT_Coeffs[i][0] = get2();\n\t    }\n\treturn;\n}\n\nvoid CLASS processNikonLensData (uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n  else\n    {\n      imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n      imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n    {\n      if (imgdata.lens.nikon.NikonLensType & 0x04)\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n      else\n        imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n      imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n    {\n      imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n      imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n    }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20) {\n    switch (len) {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n      {\n        if ((LensData[i - 1]) &&\n            (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n          imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n        if (LensData[i + 7]) imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n      }\n    imgdata.lens.makernotes.LensID =\n      (unsigned long long) LensData[i] << 56 |\n      (unsigned long long) LensData[i + 1] << 48 |\n      (unsigned long long) LensData[i + 2] << 40 |\n      (unsigned long long) LensData[i + 3] << 32 |\n      (unsigned long long) LensData[i + 4] << 24 |\n      (unsigned long long) LensData[i + 5] << 16 |\n      (unsigned long long) LensData[i + 6] << 8 |\n      (unsigned long long) imgdata.lens.nikon.NikonLensType;\n\n  }\n  else if ((len == 459) || (len == 590))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n    }\n  else if (len == 509)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n    }\n  else if (len == 879)\n    {\n      memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n    }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures (unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) ||\t// E-1\n      (id == 0x4434303431ULL) ||\t// E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n\t  if ((id == 0x4434303430ULL) ||\t// E-1\n      \t  (id == 0x4434303431ULL) ||\t// E-330\n      \t  ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n      \t  (id == 0x5330303233ULL) ||\t// E-620\n      \t  (id == 0x5330303239ULL) ||\t// E-450\n      \t  (id == 0x5330303330ULL) ||\t// E-600\n      \t  (id == 0x5330303333ULL))\t\t// E-5\n      {\n      \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n      }\n  \telse\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n      }\n  }\n  else\n  {\n      imgdata.lens.makernotes.LensMount =\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes (unsigned tag, unsigned type, unsigned len) {\n\nif (tag == 0x0001) Canon_CameraSettings();\n        else if (tag == 0x0002)\t\t\t// focal length\n          {\n            imgdata.lens.makernotes.FocalType = get2();\n            imgdata.lens.makernotes.CurFocal = get2();\n            if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n              {\n                imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n              }\n          }\n\n        else if (tag == 0x0004)\t\t\t// shot info\n          {\n            short tempAp;\n            fseek(ifp, 30, SEEK_CUR);\n            imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n            fseek(ifp, 8-32, SEEK_CUR);\n            if ((tempAp = get2()) != 0x7fff)\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n            if (imgdata.lens.makernotes.CurAp < 0.7f)\n            {\n              fseek(ifp, 32, SEEK_CUR);\n              imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n            }\n            if (!aperture) aperture = imgdata.lens.makernotes.CurAp;\n          }\n\n        else if (tag == 0x0095 &&\t\t// lens model tag\n                 !imgdata.lens.makernotes.Lens[0])\n          {\n            fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            if (imgdata.lens.makernotes.Lens[0] < 65)\t\t\t\t\t// non-Canon lens\n              fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n            else\n              {\n                char efs[2];\n                imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n                imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n                fread(efs, 2, 1, ifp);\n                if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n                  {\t// \"EF-S, TS-E, MP-E, EF-M\" lenses\n                    imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n                    imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n                    imgdata.lens.makernotes.Lens[4] = 32;\n                    if (efs[1] == 83)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n                        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n                      }\n                    else if (efs[1] == 77)\n                      {\n                        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n                      }\n                  }\n                else\n                  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// \"EF\" lenses\n                    imgdata.lens.makernotes.Lens[2] = 32;\n                    imgdata.lens.makernotes.Lens[3] = efs[0];\n                    imgdata.lens.makernotes.Lens[4] = efs[1];\n                  }\n                fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n              }\n          }\n\n        else if (tag == 0x00a9)\n          {\n            long int save1 = ftell(ifp);\n            fseek (ifp, save1+(0x5<<1), SEEK_SET);\n            Canon_WBpresets(0,0);\n            fseek (ifp, save1, SEEK_SET);\n          }\n\n        else if (tag == 0x00e0)\t\t\t// sensor info\n          {\n            imgdata.makernotes.canon.SensorWidth           = (get2(),get2());\n            imgdata.makernotes.canon.SensorHeight          = get2();\n            imgdata.makernotes.canon.SensorLeftBorder      = (get2(),get2(),get2());\n            imgdata.makernotes.canon.SensorTopBorder       = get2();\n            imgdata.makernotes.canon.SensorRightBorder     = get2();\n            imgdata.makernotes.canon.SensorBottomBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskLeftBorder   = get2();\n            imgdata.makernotes.canon.BlackMaskTopBorder    = get2();\n            imgdata.makernotes.canon.BlackMaskRightBorder  = get2();\n            imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n          }\n\n    else if (tag == 0x4001 && len > 500)\n      {\n        int c;\n        long int save1 = ftell(ifp);\n        switch (len)\n          {\n          case 582:\n            imgdata.makernotes.canon.CanonColorDataVer = 1;\t// 20D / 350D\n            {\n            \tfseek (ifp, save1+(0x23<<1), SEEK_SET);\n            \tCanon_WBpresets(2,2);\n            \tfseek (ifp, save1+(0x4b<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 653:\n            imgdata.makernotes.canon.CanonColorDataVer = 2;\t// 1Dmk2 / 1DsMK2\n            {\n            \tfseek (ifp, save1+(0x27<<1), SEEK_SET);\n            \tCanon_WBpresets(2,12);\n            \tfseek (ifp, save1+(0xa4<<1), SEEK_SET);\n              \tCanon_WBCTpresets (1);\t// ABCT\n            }\n            break;\n          case 796:\n            imgdata.makernotes.canon.CanonColorDataVer = 3;\t// 1DmkIIN / 5D / 30D / 400D\n\t    imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n\t    {\n\t      fseek (ifp, save1+(0x4e<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0x85<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n\t      fseek (ifp, save1+(0x0c4<<1), SEEK_SET); // offset 196 short\n\t      int bls=0;\n\t      FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n\t      imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n\t    }\n\t    break;\n            // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n            // 7D / 40D / 50D / 60D / 450D / 500D\n            // 550D / 1000D / 1100D\n          case 674: case 692: case 702: case 1227: case 1250:\n          case 1251: case 1337: case 1338: case 1346:\n            imgdata.makernotes.canon.CanonColorDataVer = 4;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n\t      fseek (ifp, save1+(0x53<<1), SEEK_SET);\n\t      Canon_WBpresets(2,12);\n\t      fseek (ifp, save1+(0xa8<<1), SEEK_SET);\n\t      Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0e7<<1), SEEK_SET); // offset 231 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4)\n                || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n              {\n                fseek (ifp, save1+(0x2b9<<1), SEEK_SET);\t\t// offset 697 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n                     (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n              {\n                fseek (ifp, save1+(0x2d0<<1), SEEK_SET);\t\t// offset 720 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n              {\n                fseek (ifp, save1+(0x2d4<<1), SEEK_SET);\t\t// offset 724 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n          case 5120:\n            imgdata.makernotes.canon.CanonColorDataVer = 5;\t// PowerSot G10, G12, G5 X, EOS M3, EOS M5\n            {\n              fseek (ifp, save1+(0x56<<1), SEEK_SET);\n              if ((unique_id == 0x03970000) || // G7 X Mark II\n                  (unique_id == 0x80000394))   // EOS M5\n              {\n                fseek(ifp, 18, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                fseek(ifp, 8, SEEK_CUR);\n                Canon_WBpresets(8,24);\n                fseek(ifp, 168, SEEK_CUR);\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n                fseek(ifp, 24, SEEK_CUR);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek(ifp, 6, SEEK_CUR);\n              }\n              else\n              {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n                get2();\n                Canon_WBpresets(2,12);\n                fseek (ifp, save1+(0xba<<1), SEEK_SET);\n                Canon_WBCTpresets (2);  // BCADT\n                fseek (ifp, save1+(0x108<<1), SEEK_SET);  // offset 264 short\n              }\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            break;\n\n          case 1273: case 1275:\n            imgdata.makernotes.canon.CanonColorDataVer = 6;\t// 600D / 1200D\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x67<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xbc<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x0fb<<1), SEEK_SET);\t\t\t// offset 251 short\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            fseek (ifp, save1+(0x1e4<<1), SEEK_SET);\t\t\t// offset 484 shorts\n            imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n            FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n            break;\n\n            // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n          case 1312: case 1313: case 1316: case 1506:\n            imgdata.makernotes.canon.CanonColorDataVer = 7;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x80<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0xd5<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x114<<1), SEEK_SET);\t\t\t// offset 276 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n            if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n              {\n                fseek (ifp, save1+(0x1fd<<1), SEEK_SET);\t\t// offset 509 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              } else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n              {\n                fseek (ifp, save1+(0x2dd<<1), SEEK_SET);\t\t// offset 733 shorts\n                imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n              }\n            break;\n\n            // 5DS / 5DS R / 80D / 1300D / 5D4\n          case 1560: case 1592: case 1353:\n            imgdata.makernotes.canon.CanonColorDataVer = 8;\n            imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n            {\n              fseek (ifp, save1+(0x85<<1), SEEK_SET);\n              Canon_WBpresets(2,12);\n              fseek (ifp, save1+(0x107<<1), SEEK_SET);\n              Canon_WBCTpresets (0);\t// BCAT\n              fseek (ifp, save1+(0x146<<1), SEEK_SET);\t\t\t// offset 326 shorts\n              int bls=0;\n              FORC4\n\t\tbls+= (imgdata.makernotes.canon.ChannelBlackLevel[c]=get2());\n              imgdata.makernotes.canon.AverageBlackLevel = bls/4;\n            }\n              if (imgdata.makernotes.canon.CanonColorDataSubVer == 14)  // 1300D\n                {\n                  fseek (ifp, save1+(0x231<<1), SEEK_SET);\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n              else\n                {\n                  fseek (ifp, save1+(0x30f<<1), SEEK_SET);\t\t// offset 783 shorts\n                  imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n                  FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n                }\n            break;\n\n          }\n        fseek (ifp, save1, SEEK_SET);\n      }\n}\n\nvoid CLASS setPentaxBodyFeatures (unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id) {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO (ushort c)\n{\n  int code [] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 50, 100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278};\n  double value []  = {50, 64, 80, 100, 125, 160, 200, 250, 320, 400, 500, 640, 800, 1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000, 10000, 12800, 16000, 20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50, 100, 200, 400, 800, 1600, 3200, 50, 70, 100, 140, 200, 280, 400, 560, 800, 1100, 1600, 2200, 3200, 4500, 6400, 9000, 12800, 18000, 25600, 36000, 51200};\n#define numel (sizeof(code)/sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++) {\n    if (code[i] == c) {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel) iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo (unsigned id, unsigned len)\t// tag 0x0207\n{\n\tushort iLensData = 0;\n\tuchar *table_buf;\n\ttable_buf = (uchar*)malloc(MAX(len,128));\n\tfread(table_buf, len, 1, ifp);\n\tif ((id < 0x12b9c)  ||\n        (((id == 0x12b9c)   ||  // K100D\n          (id == 0x12b9d)   ||  // K110D\n          (id == 0x12ba2)) &&   // K100D Super\n\t\t ((!table_buf[20] ||\n\t\t  (table_buf[20] == 0xff)))))\n\t  {\n\t\tiLensData = 3;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t(((unsigned)table_buf[0]) << 8) + table_buf[1];\n\t  }\n\telse switch (len)\n\t  {\n\t  case 90:\t\t\t\t\t\t\t// LensInfo3\n\t\tiLensData = 13;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 91:\t\t\t\t\t\t\t// LensInfo4\n\t\tiLensData = 12;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) <<8) + table_buf[4];\n\t\tbreak;\n\t  case 80:\t\t\t\t\t\t\t// LensInfo5\n\t  case 128:\n\t\tiLensData = 15;\n\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) <<8) + table_buf[5];\n\t\tbreak;\n\t  default:\n\t\tif (id >= 0x12b9c)\t\t\t\t// LensInfo2\n\t\t  {\n\t\t\tiLensData = 4;\n\t\t\tif (imgdata.lens.makernotes.LensID == -1)\n\t\t\t  imgdata.lens.makernotes.LensID =\n\t\t\t\t((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) <<8) + table_buf[3];\n\t\t  }\n\t  }\n\tif (iLensData)\n\t  {\n\t\tif (table_buf[iLensData+9] &&\n\t\t\t(fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n\t\t  imgdata.lens.makernotes.CurFocal =\n\t\t\t10*(table_buf[iLensData+9]>>2) * powf64(4, (table_buf[iLensData+9] & 0x03)-2);\n\t\tif (table_buf[iLensData+10] & 0xf0)\n\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0xf0) >>4)/4.0f);\n\t\tif (table_buf[iLensData+10] & 0x0f)\n\t\t  imgdata.lens.makernotes.MinAp4CurFocal =\n\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+10] & 0x0f) + 10)/4.0f);\n\n\t\tif (iLensData != 12)\n\t\t  {\n\t\t\tswitch (table_buf[iLensData] & 0x06)\n\t\t\t  {\n\t\t\t  case 0: imgdata.lens.makernotes.MinAp4MinFocal = 22.0f; break;\n\t\t\t  case 2: imgdata.lens.makernotes.MinAp4MinFocal = 32.0f; break;\n\t\t\t  case 4: imgdata.lens.makernotes.MinAp4MinFocal = 45.0f; break;\n\t\t\t  case 6: imgdata.lens.makernotes.MinAp4MinFocal = 16.0f; break;\n\t\t\t  }\n\t\t\tif (table_buf[iLensData] & 0x70)\n\t\t\t  imgdata.lens.makernotes.LensFStops =\n\t\t\t\t((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n\t\t\timgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData+3] & 0xf8);\n\t\t\timgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData+3] & 0x07);\n\n\t\t\tif ((table_buf[iLensData+14] > 1) &&\n\t\t\t\t(fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t\t  imgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t\tpowf64(2.0f, (float)((table_buf[iLensData+14] & 0x7f) -1)/32.0f);\n\t\t  }\n\t\telse if ((id != 0x12e76) &&\t// K-5\n\t\t\t\t (table_buf[iLensData+15] > 1) &&\n\t\t\t\t (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n\t\t  {\n\t\t\timgdata.lens.makernotes.MaxAp4CurFocal =\n\t\t\t  powf64(2.0f, (float)((table_buf[iLensData+15] & 0x7f) -1)/32.0f);\n\t\t  }\n\t  }\n\tfree(table_buf);\n\treturn;\n}\n\nvoid CLASS setPhaseOneFeatures (unsigned id) {\n\n  ushort i;\n  static const struct {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n    // Phase One section:\n    {1, \"Hasselblad V\"},\n    {10, \"PhaseOne/Mamiya\"},\n    {12, \"Contax 645\"},\n    {16, \"Hasselblad V\"},\n    {17, \"Hasselblad V\"},\n    {18, \"Contax 645\"},\n    {19, \"PhaseOne/Mamiya\"},\n    {20, \"Hasselblad V\"},\n    {21, \"Contax 645\"},\n    {22, \"PhaseOne/Mamiya\"},\n    {23, \"Hasselblad V\"},\n    {24, \"Hasselblad H\"},\n    {25, \"PhaseOne/Mamiya\"},\n    {32, \"Contax 645\"},\n    {34, \"Hasselblad V\"},\n    {35, \"Hasselblad V\"},\n    {36, \"Hasselblad H\"},\n    {37, \"Contax 645\"},\n    {38, \"PhaseOne/Mamiya\"},\n    {39, \"Hasselblad V\"},\n    {40, \"Hasselblad H\"},\n    {41, \"Contax 645\"},\n    {42, \"PhaseOne/Mamiya\"},\n    {44, \"Hasselblad V\"},\n    {45, \"Hasselblad H\"},\n    {46, \"Contax 645\"},\n    {47, \"PhaseOne/Mamiya\"},\n    {48, \"Hasselblad V\"},\n    {49, \"Hasselblad H\"},\n    {50, \"Contax 645\"},\n    {51, \"PhaseOne/Mamiya\"},\n    {52, \"Hasselblad V\"},\n    {53, \"Hasselblad H\"},\n    {54, \"Contax 645\"},\n    {55, \"PhaseOne/Mamiya\"},\n    {67, \"Hasselblad V\"},\n    {68, \"Hasselblad H\"},\n    {69, \"Contax 645\"},\n    {70, \"PhaseOne/Mamiya\"},\n    {71, \"Hasselblad V\"},\n    {72, \"Hasselblad H\"},\n    {73, \"Contax 645\"},\n    {74, \"PhaseOne/Mamiya\"},\n    {76, \"Hasselblad V\"},\n    {77, \"Hasselblad H\"},\n    {78, \"Contax 645\"},\n    {79, \"PhaseOne/Mamiya\"},\n    {80, \"Hasselblad V\"},\n    {81, \"Hasselblad H\"},\n    {82, \"Contax 645\"},\n    {83, \"PhaseOne/Mamiya\"},\n    {84, \"Hasselblad V\"},\n    {85, \"Hasselblad H\"},\n    {86, \"Contax 645\"},\n    {87, \"PhaseOne/Mamiya\"},\n    {99, \"Hasselblad V\"},\n    {100, \"Hasselblad H\"},\n    {101, \"Contax 645\"},\n    {102, \"PhaseOne/Mamiya\"},\n    {103, \"Hasselblad V\"},\n    {104, \"Hasselblad H\"},\n    {105, \"PhaseOne/Mamiya\"},\n    {106, \"Contax 645\"},\n    {112, \"Hasselblad V\"},\n    {113, \"Hasselblad H\"},\n    {114, \"Contax 645\"},\n    {115, \"PhaseOne/Mamiya\"},\n    {131, \"Hasselblad V\"},\n    {132, \"Hasselblad H\"},\n    {133, \"Contax 645\"},\n    {134, \"PhaseOne/Mamiya\"},\n    {135, \"Hasselblad V\"},\n    {136, \"Hasselblad H\"},\n    {137, \"Contax 645\"},\n    {138, \"PhaseOne/Mamiya\"},\n    {140, \"Hasselblad V\"},\n    {141, \"Hasselblad H\"},\n    {142, \"Contax 645\"},\n    {143, \"PhaseOne/Mamiya\"},\n    {148, \"Hasselblad V\"},\n    {149, \"Hasselblad H\"},\n    {150, \"Contax 645\"},\n    {151, \"PhaseOne/Mamiya\"},\n    {160, \"A-250\"},\n    {161, \"A-260\"},\n    {162, \"A-280\"},\n    {167, \"Hasselblad V\"},\n    {168, \"Hasselblad H\"},\n    {169, \"Contax 645\"},\n    {170, \"PhaseOne/Mamiya\"},\n    {172, \"Hasselblad V\"},\n    {173, \"Hasselblad H\"},\n    {174, \"Contax 645\"},\n    {175, \"PhaseOne/Mamiya\"},\n    {176, \"Hasselblad V\"},\n    {177, \"Hasselblad H\"},\n    {178, \"Contax 645\"},\n    {179, \"PhaseOne/Mamiya\"},\n    {180, \"Hasselblad V\"},\n    {181, \"Hasselblad H\"},\n    {182, \"Contax 645\"},\n    {183, \"PhaseOne/Mamiya\"},\n    {208, \"Hasselblad V\"},\n    {211, \"PhaseOne/Mamiya\"},\n    {448, \"Phase One 645AF\"},\n    {457, \"Phase One 645DF\"},\n    {471, \"Phase One 645DF+\"},\n    {704, \"Phase One iXA\"},\n    {705, \"Phase One iXA - R\"},\n    {706, \"Phase One iXU 150\"},\n    {707, \"Phase One iXU 150 - NIR\"},\n    {708, \"Phase One iXU 180\"},\n    {721, \"Phase One iXR\"},\n    // Leaf section:\n    {333,\"Mamiya\"},\n    {329,\"Universal\"},\n    {330,\"Hasselblad H1/H2\"},\n    {332,\"Contax\"},\n    {336,\"AFi\"},\n    {327,\"Mamiya\"},\n    {324,\"Universal\"},\n    {325,\"Hasselblad H1/H2\"},\n    {326,\"Contax\"},\n    {335,\"AFi\"},\n    {340,\"Mamiya\"},\n    {337,\"Universal\"},\n    {338,\"Hasselblad H1/H2\"},\n    {339,\"Contax\"},\n    {323,\"Mamiya\"},\n    {320,\"Universal\"},\n    {322,\"Hasselblad H1/H2\"},\n    {321,\"Contax\"},\n    {334,\"AFi\"},\n    {369,\"Universal\"},\n    {370,\"Mamiya\"},\n    {371,\"Hasselblad H1/H2\"},\n    {372,\"Contax\"},\n    {373,\"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0]) {\n    for (i=0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id) {\n        strcpy(imgdata.lens.makernotes.body,p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes (unsigned tag, unsigned type) {\n      switch (tag) {\n      case 0x1002: imgdata.makernotes.fuji.WB_Preset = get2(); break;\n      case 0x1011: imgdata.other.FlashEC = getreal(type); break;\n      case 0x1020: imgdata.makernotes.fuji.Macro = get2(); break;\n      case 0x1021: imgdata.makernotes.fuji.FocusMode = get2(); break;\n      case 0x1022: imgdata.makernotes.fuji.AFMode = get2(); break;\n      case 0x1023: imgdata.makernotes.fuji.FocusPixel[0] = get2();\n                   imgdata.makernotes.fuji.FocusPixel[1] = get2();\n      break;\n      case 0x1034: imgdata.makernotes.fuji.ExrMode = get2(); break;\n      case 0x1050: imgdata.makernotes.fuji.ShutterType = get2(); break;\n      case 0x1400: imgdata.makernotes.fuji.FujiDynamicRange = get2(); break;\n      case 0x1401: imgdata.makernotes.fuji.FujiFilmMode = get2(); break;\n      case 0x1402: imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2(); break;\n      case 0x1403: imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2(); break;\n      case 0x140b: imgdata.makernotes.fuji.FujiAutoDynamicRange = get2(); break;\n      case 0x1404: imgdata.lens.makernotes.MinFocal = getreal(type); break;\n      case 0x1405: imgdata.lens.makernotes.MaxFocal = getreal(type); break;\n      case 0x1406: imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type); break;\n      case 0x1407: imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type); break;\n      case 0x1422: imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n                   imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n                   imgdata.shootinginfo.ImageStabilization = (imgdata.makernotes.fuji.ImageStabilization[0]<<9) + imgdata.makernotes.fuji.ImageStabilization[1];\n      break;\n      case 0x1431: imgdata.makernotes.fuji.Rating = get4(); break;\n      case 0x3820: imgdata.makernotes.fuji.FrameRate = get2(); break;\n      case 0x3821: imgdata.makernotes.fuji.FrameWidth = get2(); break;\n      case 0x3822: imgdata.makernotes.fuji.FrameHeight = get2(); break;\n      }\nreturn;\n}\n\nvoid CLASS setSonyBodyFeatures (unsigned id) {\n\n  imgdata.lens.makernotes.CamID = id;\n  if (\t// FF cameras\n      (id == 257) ||\t\t// a900\n      (id == 269) ||\t\t// a850\n      (id == 340) ||\t\t// ILCE-7M2\n      (id == 318) ||\t\t// ILCE-7S\n      (id == 350) ||\t\t// ILCE-7SM2\n      (id == 311) ||\t\t// ILCE-7R\n      (id == 347) ||\t\t// ILCE-7RM2\n      (id == 306) ||\t\t// ILCE-7\n      (id == 298) ||\t\t// DSC-RX1\n      (id == 299) ||\t\t// NEX-VG900\n      (id == 310) ||\t\t// DSC-RX1R\n      (id == 344) ||\t\t// DSC-RX1RM2\n      (id == 354) ||\t\t// ILCA-99M2\n      (id == 294)\t\t// SLT-99, Hasselblad HV\n      )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n  else if ((id == 297) ||  // DSC-RX100\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n         )\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n    }\n\n  else if (id != 002)     // DSC-R1\n    {\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    }\n\n  if      (               // E-mount cameras, ILCE series\n           (id == 302) ||\n           (id == 306) ||\n           (id == 311) ||\n           (id == 312) ||\n           (id == 313) ||\n           (id == 318) ||\n           (id == 339) ||\n           (id == 340) ||\n           (id == 346) ||\n           (id == 347) ||\n           (id == 350) ||\n           (id == 360)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n    }\n  else if (               // E-mount cameras, NEX series\n           (id == 278) ||\n           (id == 279) ||\n           (id == 284) ||\n           (id == 288) ||\n           (id == 289) ||\n           (id == 290) ||\n           (id == 293) ||\n           (id == 295) ||\n           (id == 296) ||\n           (id == 299) ||\n           (id == 300) ||\n           (id == 305) ||\n           (id == 307)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n    }\n\n  else if (\t// A-mount cameras, DSLR series\n           (id == 256) ||\n           (id == 257) ||\n           (id == 258) ||\n           (id == 259) ||\n           (id == 260) ||\n           (id == 261) ||\n           (id == 262) ||\n           (id == 263) ||\n           (id == 264) ||\n           (id == 265) ||\n           (id == 266) ||\n           (id == 269) ||\n           (id == 270) ||\n           (id == 273) ||\n           (id == 274) ||\n           (id == 275) ||\n           (id == 282) ||\n           (id == 283)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n    }\n  else if (\t// A-mount cameras, SLT series\n           (id == 280) ||\n           (id == 281) ||\n           (id == 285) ||\n           (id == 286) ||\n           (id == 287) ||\n           (id == 291) ||\n           (id == 292) ||\n           (id == 294) ||\n           (id == 303)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n    }\n  else if (\t// A-mount cameras, ILCA series\n           (id == 319)  ||\n           (id == 353)  ||\n           (id == 354)\n          )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n    }\n\n  else if (\t// DSC\n           (id == 002) ||  // DSC-R1\n           (id == 297) ||  // DSC-RX100\n           (id == 298) ||  // DSC-RX1\n           (id == 308) ||  // DSC-RX100M2\n           (id == 309) ||  // DSC-RX10\n           (id == 310) ||  // DSC-RX1R\n           (id == 344) ||  // DSC-RX1RM2\n           (id == 317) ||  // DSC-RX100M3\n           (id == 341) ||  // DSC-RX100M4\n           (id == 342) ||  // DSC-RX10M2\n           (id == 355) ||  // DSC-RX10M3\n           (id == 356)     // DSC-RX100M5\n           )\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n    }\n  return;\n}\n\nvoid CLASS parseSonyLensType2 (uchar a, uchar b) {\n  ushort lid2;\n  lid2 = (((ushort)a)<<8) | ((ushort)b);\n  if (!lid2) return;\n  if (lid2 < 0x100)\n    {\n      if ((imgdata.lens.makernotes.AdapterID != 0x4900) &&\n          (imgdata.lens.makernotes.AdapterID != 0xEF00))\n      {\n        imgdata.lens.makernotes.AdapterID = lid2;\n        switch (lid2) {\n        case 1:\n        case 2:\n        case 3:\n        case 6:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n        case 44:\n        case 78:\n        case 239:\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n        }\n      }\n    }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n    {\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n    }\n  return;\n}\n\n#define strnXcat(buf,string) strncat(buf,string,LIM(sizeof(buf)-strbuflen(buf)-1,0,sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures (uchar a, uchar b) {\n\n  ushort features;\n  features = (((ushort)a)<<8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) ||\n      !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100)) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100) strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n    {\n  \t  imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n  \t  imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n  \t  if ((features & 0x0200) && (features & 0x0100)) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0200) {\n  \t\timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n  \t  } else if (features & 0x0100) {\n  \t\timgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n  \t  }\n    }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\" );\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf+1,\n\t    strbuflen(imgdata.lens.makernotes.LensFeatures_suf)-1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c (uchar * buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n    {\n      switch (SonySubstitution[buf[0x0008]]) {\n      case 1:\n      case 5:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 4:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n        break;\n      }\n    }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |\n    ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2 (SonySubstitution[buf[0x000a]],\t// LensType2 - Sony lens ids\n                        SonySubstitution[buf[0x0009]]);\n  return;\n}\n\n\nvoid CLASS process_Sony_0x9050 (uchar * buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n    {\n      if (buf[0])\n        imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n\n      if (buf[1])\n        imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f)*10.0f) / 10.0f;\n    }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    {\n      if (buf[0x3d] | buf[0x3c])\n        {\n          lid = SonySubstitution[buf[0x3d]] << 8 |\n            SonySubstitution[buf[0x3c]];\n          imgdata.lens.makernotes.CurAp =\n            powf64(2.0f, ((float)lid/256.0f - 16.0f) / 2.0f);\n        }\n      if (buf[0x105] &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n          (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n        imgdata.lens.makernotes.LensMount =\n          SonySubstitution[buf[0x105]];\n      if (buf[0x106])\n        imgdata.lens.makernotes.LensFormat =\n          SonySubstitution[buf[0x106]];\n    }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n    {\n      parseSonyLensType2 (SonySubstitution[buf[0x0108]],\t\t// LensType2 - Sony lens ids\n                          SonySubstitution[buf[0x0107]]);\n    }\n  if ((imgdata.lens.makernotes.LensID == -1) &&\n      (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n    {\n      imgdata.lens.makernotes.LensID =\t\t // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 |\n        SonySubstitution[buf[0x0109]];\n\n      if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n          (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n      else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n          (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n          (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n    }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures (SonySubstitution[buf[0x115]],\n                           SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long long b88 = SonySubstitution[buf[0x88]];\n    unsigned long long b89 = SonySubstitution[buf[0x89]];\n    unsigned long long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06llx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05llx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") ||\n           !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG))) {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) ||\n           !strcmp(buf, \"Panasonic\")) {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8)) {\n    base = ftell(ifp) - 10;\n  nf: order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") ||\n           !strcmp(buf, \"LEICA\") ||\n           !strcmp(buf, \"Ricoh\") ||\n           !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") ||\n           !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) &&\n\t\t\t\t(dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if(len > 8 && pos+len > 2* fsize) continue;\n    tag |= uptag << 16;\n    if(len > 100*1024*1024) goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000) // camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t // Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes (tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len,ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n      {\n        if (tag == 0x1d)\t\t\t\t\t\t\t// serial number\n          while ((c = fgetc(ifp)) && c != EOF)\n          {\n            if ((!custom_serial) && (!isdigit(c)))\n            {\n              if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n              {\n                custom_serial = 34;\n              }\n              else\n              {\n                custom_serial = 96;\n              }\n            }\n            serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n          }\n        else if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0097)\n          {\n            for (i=0; i < 4; i++)\n\t            ver97 = ver97 * 10 + fgetc(ifp)-'0';\n\t          if (ver97 == 601)  // Coolpix A\n\t          {\n\t            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n\t          }\n\t        }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n\n        else if (tag == 0xa7)\t\t\t\t\t// shutter count\n          {\n            NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n            if ((NikonLensDataVersion > 200) && lenNikonLensData)\n            {\n              if (custom_serial)\n              {\n                ci = xlat[0][custom_serial];\n              }\n              else\n              {\n                ci = xlat[0][serial & 0xff];\n              }\n              cj = xlat[1][NikonKey];\n              ck = 0x60;\n              for (i = 0; i < lenNikonLensData; i++)\n                table_buf[i] ^= (cj += ci * ck++);\n              processNikonLensData(table_buf, lenNikonLensData);\n              lenNikonLensData = 0;\n              free(table_buf);\n            }\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n\n        else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n          {\n            unsigned char cc;\n            fread(&cc, 1, 1, ifp);\n            iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n            break;\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        int SubDirOffsetValid =\n              strncmp (model, \"E-300\", 5) &&\n              strncmp (model, \"E-330\", 5) &&\n              strncmp (model, \"E-400\", 5) &&\n              strncmp (model, \"E-500\", 5) &&\n              strncmp (model, \"E-1\", 3);\n\n        if ((tag == 0x2010) || (tag == 0x2020))\n          {\n            fseek(ifp, save - 4, SEEK_SET);\n            fseek(ifp, base + get4(), SEEK_SET);\n            parse_makernote_0xc634(base, tag, dng_writer);\n          }\n        if (!SubDirOffsetValid &&\n            ((len > 4) ||\n             ( ((type == 3) || (type == 8)) && (len > 2))  ||\n             ( ((type == 4) || (type == 9)) && (len > 1))  || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n        switch (tag) {\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20100102:\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x20100201:\n          imgdata.lens.makernotes.LensID =\n            (unsigned long long)fgetc(ifp)<<16 |\n            (unsigned long long)(fgetc(ifp), fgetc(ifp))<<8 |\n            (unsigned long long)fgetc(ifp);\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          if ((!imgdata.lens.LensSerial[0]))\n              stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens,len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment,len, ifp);\n          break;\n        case 0x20200401:\n\t      imgdata.other.FlashEC = getreal(type);\n\t      break;\n        }\n        skip_Oly_broken_tags:;\n      }\n\n    else if (!strncmp(make, \"PENTAX\", 6) ||\n             !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n               PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n                FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t     for (int i = 0; i < nWB; i++)\n\t       {\n\t\t imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\t fseek(ifp, 2, SEEK_CUR);\n\t\t imgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\t imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\t imgdata.color.WBCT_Coeffs[i][3] = get2();\n        \t}\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 12, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) &&\n             (dng_writer == AdobeDNG))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            imgdata.lens.makernotes.CamID = unique_id = get4();\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n          {\n            unique_id = get2();\n            setSonyBodyFeatures(unique_id);\n            if (table_buf_0x9050_present)\n              {\n                process_Sony_0x9050(table_buf_0x9050, unique_id);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n            if (table_buf_0x940c_present)\n              {\n                if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                  {\n                    process_Sony_0x940c(table_buf_0x940c);\n                  }\n                free (table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n\n                  // a450, a500, a550, a560, a580\n                  // a33, a35, a55\n                  // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len) {\n                case 368:\n                case 5478:\n                  // a700, a850, a900: CameraInfo\n                  if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n                    {\n                      if (table_buf[0] | table_buf[3])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                      if (table_buf[2] | table_buf[5])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                      if (table_buf[4])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    }\n                  break;\n                default:\n                  // CameraInfo2 & 3\n                  if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n                    {\n                      if (table_buf[1] | table_buf[2])\n                        imgdata.lens.makernotes.MinFocal =\n                          bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                      if (table_buf[3] | table_buf[4])\n                        imgdata.lens.makernotes.MaxFocal =\n                          bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                      if (table_buf[5])\n                        imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                      if (table_buf[6])\n                        imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                      parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                    }\n                }\n              }\n            free(table_buf);\n          }\n\n\t\telse if (tag == 0x0104)\n\t\t  {\n\t\t    imgdata.other.FlashEC = getreal(type);\n\t\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 65535)\t\t\t\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len < 256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n              {\n                if (table_buf[1] | table_buf[2])\n                  imgdata.lens.makernotes.MinFocal =\n                    bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                if (table_buf[3] | table_buf[4])\n                  imgdata.lens.makernotes.MaxFocal =\n                    bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                if (table_buf[5])\n                  imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                if (table_buf[6])\n                  imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                parseSonyLensFeatures(table_buf[0], table_buf[7]);\n              }\n            free(table_buf);\n          }\n      }\n  next:\n    fseek (ifp, save, SEEK_SET);\n  }\n quit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  /*placeholder */\n}\n#endif\n\n\nvoid CLASS parse_makernote (int base, int uptag)\n{\n  unsigned offset=0, entries, tag, type, len, save, c;\n  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder=order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n/*\n   The MakerNote might have its own TIFF header (possibly with\n   its own byte-order!), or it might just be a table.\n */\n  if (!strncmp(make,\"Nokia\",5)) return;\n  fread (buf, 1, 10, ifp);\n  if (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\n      !strncmp (buf,\"VER\" ,3) ||\n      !strncmp (buf,\"IIII\",4) ||\n      !strncmp (buf,\"MMMM\",4)) return;\n  if (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\n      !strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i=ftell(ifp)) < data_offset && i < 16384) {\n      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 &&\n\t  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n\tFORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp (buf,\"Nikon\")) {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42) goto quit;\n    offset = get4();\n    fseek (ifp, offset-8, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMPUS\") ||\n             !strcmp (buf,\"PENTAX \")) {\n    base = ftell(ifp)-10;\n    fseek (ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O') get2();\n  } else if (!strncmp (buf,\"SONY\",4) ||\n             !strcmp  (buf,\"Panasonic\")) {\n    goto nf;\n  } else if (!strncmp (buf,\"FUJIFILM\",8)) {\n    base = ftell(ifp)-10;\n\tnf: order = 0x4949;\n    fseek (ifp,  2, SEEK_CUR);\n  } else if (!strcmp (buf,\"OLYMP\") ||\n             !strcmp (buf,\"LEICA\") ||\n             !strcmp (buf,\"Ricoh\") ||\n             !strcmp (buf,\"EPSON\"))\n    fseek (ifp, -2, SEEK_CUR);\n  else if (!strcmp (buf,\"AOC\") ||\n           !strcmp (buf,\"QVC\"))\n    fseek (ifp, -4, SEEK_CUR);\n  else {\n    fseek (ifp, -10, SEEK_CUR);\n    if (!strncmp(make,\"SAMSUNG\",7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (!strncmp(model, \"M8\", 2) ||\n          !strncasecmp(model, \"Leica M8\", 8) ||\n          !strncasecmp(model, \"LEICA X\", 7))\n        {\n          base = ftell(ifp)-8;\n        }\n      else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n        {\n          base = 0;\n        }\n      else if (!strncmp(model, \"M9\", 2) ||\n               !strncasecmp(model, \"Leica M9\", 8) ||\n               !strncasecmp(model, \"M Monochrom\", 11) ||\n               !strncasecmp(model, \"Leica M Monochrom\", 11))\n        {\n          if (!uptag)\n            {\n              base = ftell(ifp) - 10;\n              fseek (ifp, 8, SEEK_CUR);\n            }\n          else if (uptag == 0x3400)\n            {\n              fseek (ifp, 10, SEEK_CUR);\n              base += 10;\n            }\n        }\n      else if (!strncasecmp(model, \"LEICA T\", 7))\n      \t{\n      \t  base = ftell(ifp)-8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n      \t}\n#ifdef LIBRAW_LIBRARY_BUILD\n      else if (!strncasecmp(model, \"LEICA SL\", 8))\n      \t{\n      \t  imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      \t  imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n      \t}\n#endif\n    }\n\n  entries = get2();\n  if (entries > 1000) return;\n  morder = order;\n\n  while (entries--) {\n    order = morder;\n    tiff_get (base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if(len > 8 && _pos+len > 2* fsize) continue;\n    if (!strncmp(make, \"Canon\",5))\n      {\n        if (tag == 0x000d && len < 256000)\t// camera info\n          {\n            CanonCameraInfo = (uchar*)malloc(MAX(16,len));\n            fread(CanonCameraInfo, len, 1, ifp);\n            lenCanonCameraInfo = len;\n          }\n\n        else if (tag == 0x10)\t// Canon ModelID\n          {\n            unique_id = get4();\n            if (unique_id == 0x03740000) unique_id = 0x80000374;\t// M3\n            if (unique_id == 0x03840000) unique_id = 0x80000384;\t// M10\n            if (unique_id == 0x03940000) unique_id = 0x80000394;\t// M5\n            setCanonBodyFeatures(unique_id);\n            if (lenCanonCameraInfo)\n              {\n                processCanonCameraInfo(unique_id, CanonCameraInfo,lenCanonCameraInfo);\n                free(CanonCameraInfo);\n                CanonCameraInfo = 0;\n                lenCanonCameraInfo = 0;\n              }\n          }\n\n        else parseCanonMakernotes (tag, type, len);\n      }\n\n    else if (!strncmp(make, \"FUJI\", 4)) {\n      if (tag == 0x0010) {\n         char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n         char *words[4];\n         char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n         int year, nwords, ynum_len;\n         unsigned c;\n         stmread(FujiSerial, len, ifp);\n         nwords = getwords(FujiSerial, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n         for (int i = 0; i < nwords; i++) {\n           mm[2] = dd[2] = 0;\n           if (strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1) < 18)\n              if (i == 0)\n\t         strncpy (imgdata.shootinginfo.InternalBodySerial,\n\t\t \twords[0],\n\t\t\tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n              else\n\t      {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t       snprintf (tbuf, sizeof(tbuf), \"%s %s\",\n\t            imgdata.shootinginfo.InternalBodySerial, words[i]);\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n\t       }\n           else\n           {\n             strncpy (dd, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-14, 2);\n             strncpy (mm, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-16, 2);\n             strncpy (yy, words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18, 2);\n             year = (yy[0]-'0')*10 + (yy[1]-'0');\n             if (year <70) year += 2000; else year += 1900;\n\n             ynum_len = (int)strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-18;\n             strncpy(ynum, words[i], ynum_len);\n             ynum[ynum_len] = 0;\n             for ( int j = 0; ynum[j] && ynum[j+1] && sscanf(ynum+j, \"%2x\", &c); j += 2) ystr[j/2] = c;\n             ystr[ynum_len / 2 + 1] = 0;\n             strcpy (model2, ystr);\n\n             if (i == 0) {\n\t       char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n               if (nwords == 1)\n\t\t   snprintf (tbuf,sizeof(tbuf),\n\t\t\t   \"%s %s %d:%s:%s\",\n\t\t\t   words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12,\n\t\t\t\tystr, year, mm, dd);\n\n               else\n\t\t snprintf (tbuf,sizeof(tbuf),\n\t\t\t    \"%s %d:%s:%s %s\",\n\t\t\t    ystr, year, mm, dd,\n\t\t\t    words[0]+strnlen(words[0],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\n\t       strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t            sizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n             } else {\n\t\tchar tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\t        snprintf (tbuf, sizeof(tbuf),\n\t\t\"%s %s %d:%s:%s %s\",\n\t\timgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,\n\t\t words[i]+strnlen(words[i],sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);\n\t\t strncpy(imgdata.shootinginfo.InternalBodySerial,tbuf,\n\t\t \tsizeof(imgdata.shootinginfo.InternalBodySerial)-1);\n      \t     }\n           }\n         }\n      }\n      else\n\tparseFujiMakernotes (tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n      {\n        if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n        {\n          int ind = tag == 0x035e?0:1;\n\t      for (int j=0; j < 3; j++)\n\t       FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c]= getreal(type);\n        }\n\n        if ((tag == 0x0303) && (type != 4))\n          {\n            stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          }\n\n        if ((tag == 0x3405) ||\n            (tag == 0x0310) ||\n            (tag == 0x34003405))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            imgdata.lens.makernotes.LensID =\n              ((imgdata.lens.makernotes.LensID>>2)<<8) |\n              (imgdata.lens.makernotes.LensID & 0x3);\n            if (imgdata.lens.makernotes.LensID != -1)\n              {\n                if ((model[0] == 'M') ||\n                    !strncasecmp (model, \"LEICA M\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n                    if (imgdata.lens.makernotes.LensID)\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n                  }\n                else if ((model[0] == 'S') ||\n                         !strncasecmp (model, \"LEICA S\", 7))\n                  {\n                    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n                    if (imgdata.lens.makernotes.Lens[0])\n                    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n                  }\n              }\n          }\n\n        else if (\n                 ((tag == 0x0313) || (tag == 0x34003406)) &&\n                 (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n                 ((type == 10) || (type == 5))\n                 )\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n            if (imgdata.lens.makernotes.CurAp > 126.3)\n              imgdata.lens.makernotes.CurAp = 0.0f;\n          }\n\n        else if (tag == 0x3400)\n          {\n            parse_makernote (base, 0x3400);\n          }\n      }\n\n    else if (!strncmp(make, \"NIKON\",5))\n      {\n        if (tag == 0x000a)\n          {\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          }\n        else if (tag == 0x0012)\n          {\n            char a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c) imgdata.other.FlashEC = (float)(a*b)/(float)c;\n          }\n        else if (tag == 0x0082)\t\t\t\t// lens attachment\n          {\n            stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          }\n        else if (tag == 0x0083)\t\t\t\t// lens type\n          {\n            imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n          }\n        else if (tag == 0x0084)\t\t\t\t// lens\n          {\n            imgdata.lens.makernotes.MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n            imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n          }\n        else if (tag == 0x008b)\t\t\t\t// lens f-stops\n          {\n            uchar a, b, c;\n            a = fgetc(ifp);\n            b = fgetc(ifp);\n            c = fgetc(ifp);\n            if (c)\n              {\n                imgdata.lens.nikon.NikonLensFStops = a*b*(12/c);\n                imgdata.lens.makernotes.LensFStops =\n                  (float)imgdata.lens.nikon.NikonLensFStops /12.0f;\n              }\n          }\n        else if (tag == 0x0093)\n          {\n            i = get2();\n            if ((i == 7) || (i == 9))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            }\n          }\n        else if (tag == 0x0098)\t\t\t\t// contains lens data\n          {\n            for (i = 0; i < 4; i++)\n              {\n                NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n              }\n            switch (NikonLensDataVersion)\n              {\n              case 100: lenNikonLensData = 9; break;\n              case 101:\n              case 201:\t// encrypted, starting from v.201\n              case 202:\n              case 203: lenNikonLensData = 15; break;\n              case 204: lenNikonLensData = 16; break;\n              case 400: lenNikonLensData = 459; break;\n              case 401: lenNikonLensData = 590; break;\n              case 402: lenNikonLensData = 509; break;\n              case 403: lenNikonLensData = 879; break;\n              }\n            if(lenNikonLensData>0)\n              {\n                table_buf = (uchar*)malloc(lenNikonLensData);\n                fread(table_buf, lenNikonLensData, 1, ifp);\n                if ((NikonLensDataVersion < 201) && lenNikonLensData)\n                  {\n                    processNikonLensData(table_buf, lenNikonLensData);\n                    free(table_buf);\n                    lenNikonLensData = 0;\n                  }\n              }\n          }\n        else if (tag == 0x00a0)\n          {\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0x00a8)\t\t// contains flash data\n          {\n          \tfor (i = 0; i < 4; i++)\n              {\n                NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n              }\n          }\n      }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n      {\n        switch (tag) {\n        case 0x0404:\n        case 0x101a:\n        case 0x20100101:\n          if (!imgdata.shootinginfo.BodySerial[0])\n            stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n        case 0x20100102:\n          if (!imgdata.shootinginfo.InternalBodySerial[0])\n            stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n        case 0x0207:\n        case 0x20100100:\n          {\n            uchar sOlyID[8];\n            unsigned long long OlyID;\n            fread (sOlyID, MIN(len,7), 1, ifp);\n\t    sOlyID[7] = 0;\n            OlyID = sOlyID[0];\n            i = 1;\n            while (i < 7 && sOlyID[i])\n              {\n                OlyID = OlyID << 8 | sOlyID[i];\n                i++;\n              }\n            setOlympusBodyFeatures(OlyID);\n          }\n          break;\n        case 0x1002:\n          imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type)/2);\n          break;\n        case 0x20401112:\n          imgdata.makernotes.olympus.OlympusCropID = get2();\n          break;\n        case 0x20401113:\n          FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n          break;\n        case 0x20100201:\n          {\n            unsigned long long oly_lensid [3];\n            oly_lensid[0] = fgetc(ifp);\n            fgetc(ifp);\n            oly_lensid[1] = fgetc(ifp);\n            oly_lensid[2] = fgetc(ifp);\n            imgdata.lens.makernotes.LensID =\n              (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n          }\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n          if (((imgdata.lens.makernotes.LensID < 0x20000) ||\n               (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n              (imgdata.lens.makernotes.LensID & 0x10))\n            {\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n            }\n          break;\n        case 0x20100202:\n          stmread(imgdata.lens.LensSerial, len, ifp);\n          break;\n        case 0x20100203:\n          stmread(imgdata.lens.makernotes.Lens, len, ifp);\n          break;\n        case 0x20100205:\n          imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100206:\n          imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100207:\n          imgdata.lens.makernotes.MinFocal = (float)get2();\n          break;\n        case 0x20100208:\n          imgdata.lens.makernotes.MaxFocal = (float)get2();\n          if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n            imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n          break;\n        case 0x2010020a:\n          imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n          break;\n        case 0x20100301:\n          imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n          fgetc(ifp);\n          imgdata.lens.makernotes.TeleconverterID =\n            imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n          break;\n        case 0x20100303:\n          stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n          break;\n        case 0x20100403:\n          stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n          break;\n        }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) &&\n             !strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n    \t  {\n    \t     char buffer[17];\n    \t     int count=0;\n    \t     fread(buffer, 16, 1, ifp);\n    \t     buffer[16] = 0;\n    \t     for (int i=0; i<16; i++)\n    \t     {\n//    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n    \t        if ((isspace(buffer[i])) ||\n    \t            (buffer[i] == 0x2D) ||\n    \t            (isalnum(buffer[i])))\n    \t        count++;\n    \t     }\n    \t     if (count == 16)\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%8s\", buffer+8);\n    \t        buffer[8] = 0;\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t     }\n    \t     else\n    \t     {\n    \t        sprintf (imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n    \t        sprintf (imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10], buffer[11]);\n    \t     }\n    \t  }\n        else if ((tag == 0x1001) && (type == 3))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            imgdata.lens.makernotes.LensID = -1;\n            imgdata.lens.makernotes.FocalType = 1;\n          }\n\n        else if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n        else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n      }\n\n    else if (!strncmp(make, \"RICOH\", 5) &&\n             strncmp(model, \"PENTAX\", 6))\n      {\n    \tif ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n    \t  {\n    \t     char buffer[9];\n    \t     buffer[8] = 0;\n    \t     fread(buffer, 8, 1, ifp);\n    \t     sprintf (imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n    \t  }\n\n    \telse if ((tag == 0x100b) && (type == 10))\n          {\n            imgdata.other.FlashEC = getreal(type);\n          }\n\n          else if ((tag == 0x1017) && (get2() == 2))\n          {\n            strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n          }\n\n        else if (tag == 0x1500)\n          {\n            imgdata.lens.makernotes.CurFocal = getreal(type);\n          }\n\n        else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n          {\n            short ntags, cur_tag;\n            fseek(ifp, 20, SEEK_CUR);\n            ntags = get2();\n            cur_tag = get2();\n            while (cur_tag != 0x002c)\n              {\n                fseek(ifp, 10, SEEK_CUR);\n                cur_tag = get2();\n              }\n            fseek(ifp, 6, SEEK_CUR);\n            fseek(ifp, get4()+20, SEEK_SET);\n            stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n            get2();\n            imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n            switch(imgdata.lens.makernotes.LensID) {\n              case 1:\n              case 2:\n              case 3:\n              case 5:\n              case 6:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            \timgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n              break;\n              case 8:\n            \timgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            \timgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n            \timgdata.lens.makernotes.LensID = -1;\n              break;\n              default:\n            \timgdata.lens.makernotes.LensID = -1;\n            }\n            fseek(ifp, 17, SEEK_CUR);\n            stread(imgdata.lens.LensSerial, 12, ifp);\n          }\n      }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) ||\n              !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n      {\n        if (tag == 0x0005)\n          {\n            unique_id = get4();\n            setPentaxBodyFeatures(unique_id);\n          }\n        else if (tag == 0x0013)\n          {\n            imgdata.lens.makernotes.CurAp = (float)get2()/10.0f;\n          }\n        else if (tag == 0x0014)\n          {\n            PentaxISO(get2());\n          }\n        else if (tag == 0x001d)\n          {\n            imgdata.lens.makernotes.CurFocal = (float)get4()/100.0f;\n          }\n        else if (tag == 0x003f)\n          {\n            imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n          }\n        else if (tag == 0x004d)\n          {\n            if (type == 9) imgdata.other.FlashEC = getreal(type) / 256.0f;\n            else imgdata.other.FlashEC = (float) ((signed short) fgetc(ifp)) / 6.0f;\n          }\n         else if (tag == 0x007e)\n           {\n             imgdata.color.linear_max[0] =\n             imgdata.color.linear_max[1] =\n             imgdata.color.linear_max[2] =\n             imgdata.color.linear_max[3] = (long)(-1) * get4();\n           }\n        else if (tag == 0x0207)\n          {\n\t    if(len < 65535) // Safety belt\n            \tPentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n          }\n        else if (tag == 0x020d)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020e)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x020f)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0210)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0211)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0212)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0213)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0214)\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0221)\n        {\n\t  int nWB = get2();\n\t  if(nWB<=sizeof(imgdata.color.WBCT_Coeffs)/sizeof(imgdata.color.WBCT_Coeffs[0]))\n\t    for (int i = 0; i < nWB; i++)\n\t      {\n\t\timgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n\t\tfseek(ifp, 2, SEEK_CUR);\n\t\timgdata.color.WBCT_Coeffs[i][1] = get2();\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n\t\timgdata.color.WBCT_Coeffs[i][3] = get2();\n\t      }\n        }\n        else if (tag == 0x0215)\n        {\n          fseek (ifp, 16, SEEK_CUR);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n        }\n        else if (tag == 0x0229)\n        {\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        }\n        else if (tag == 0x022d)\n        {\n\t  fseek (ifp,2,SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n\t  getc(ifp);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n        }\n        else if (tag == 0x0239)\t\t// Q-series lens info (LensInfoQ)\n          {\n            char LensInfo [20];\n            fseek (ifp, 2, SEEK_CUR);\n            stread(imgdata.lens.makernotes.Lens, 30, ifp);\n            strcat(imgdata.lens.makernotes.Lens, \" \");\n            stread(LensInfo, 20, ifp);\n            strcat(imgdata.lens.makernotes.Lens, LensInfo);\n          }\n      }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n      {\n        if (tag == 0x0002)\n          {\n            if(get4() == 0x2000)\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n              }\n            else if (!strncmp(model, \"NX mini\", 7))\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n              }\n            else\n              {\n                imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n                imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n              }\n          }\n        else if (tag == 0x0003)\n          {\n            unique_id = imgdata.lens.makernotes.CamID = get4();\n          }\n         else if (tag == 0xa002)\n          {\n             stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n          }\n        else if (tag == 0xa003)\n          {\n            imgdata.lens.makernotes.LensID = get2();\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n          }\n        else if (tag == 0xa005)\n          {\n            stmread(imgdata.lens.InternalLensSerial, len, ifp);\n          }\n        else if (tag == 0xa019)\n          {\n            imgdata.lens.makernotes.CurAp = getreal(type);\n          }\n        else if (tag == 0xa01a)\n          {\n            imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n            if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n              imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n          }\n      }\n\n    else if (!strncasecmp(make, \"SONY\", 4) ||\n             !strncasecmp(make, \"Konica\", 6) ||\n             !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) ||\n               !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) ||\n               !strncasecmp(model, \"HV\",2))))\n      {\n        ushort lid;\n        if (tag == 0xb001)\t\t\t// Sony ModelID\n        {\n          unique_id = get2();\n          setSonyBodyFeatures(unique_id);\n          if (table_buf_0x9050_present)\n            {\n              process_Sony_0x9050(table_buf_0x9050, unique_id);\n              free (table_buf_0x9050);\n              table_buf_0x9050_present = 0;\n            }\n          if (table_buf_0x940c_present)\n            {\n              if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n                {\n                  process_Sony_0x940c(table_buf_0x940c);\n                }\n              free (table_buf_0x940c);\n              table_buf_0x940c_present = 0;\n            }\n        }\n\n        else if ((tag == 0x0010) &&\t\t\t\t\t// CameraInfo\n                 strncasecmp(model, \"DSLR-A100\", 9) &&\n                 strncasecmp(model, \"NEX-5C\", 6) &&\n                 !strncasecmp(make, \"SONY\", 4) &&\n                 ((len == 368) ||\t\t// a700\n                  (len == 5478) ||\t\t// a850, a900\n                  (len == 5506) ||\t\t// a200, a300, a350\n                  (len == 6118) ||\t\t// a230, a290, a330, a380, a390\n                  \t\t\t\t// a450, a500, a550, a560, a580\n                  \t\t\t\t// a33, a35, a55\n                  \t\t\t\t// NEX3, NEX5, NEX5C, NEXC3, VG10E\n                  (len == 15360))\n                 )\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n                memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n              {\n                switch (len)\n                  {\n                  case 368:\n                  case 5478:\n                    // a700, a850, a900: CameraInfo\n                    if (table_buf[0] | table_buf[3])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n                    if (table_buf[2] | table_buf[5])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n                    if (table_buf[4])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[1], table_buf[6]);\n                    break;\n                  default:\n                    // CameraInfo2 & 3\n                    if (table_buf[1] | table_buf[2])\n                      imgdata.lens.makernotes.MinFocal =\n                        bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n                    if (table_buf[3] | table_buf[4])\n                      imgdata.lens.makernotes.MaxFocal =\n                        bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n                    if (table_buf[5])\n                      imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n                    if (table_buf[6])\n                      imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n                    parseSonyLensFeatures(table_buf[0], table_buf[7]);\n                }\n              }\n            free(table_buf);\n          }\n\n        else if ((tag == 0x0020) &&\t\t\t\t// WBInfoA100, needs 0xb028 processing\n                 !strncasecmp(model, \"DSLR-A100\", 9))\n\t  {\n\t    fseek(ifp,0x49dc,SEEK_CUR);\n\t    stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n\t  }\n\n\telse if (tag == 0x0104)\n\t  {\n\t    imgdata.other.FlashEC = getreal(type);\n\t  }\n\n        else if (tag == 0x0105)\t\t\t\t\t// Teleconverter\n          {\n            imgdata.lens.makernotes.TeleconverterID = get2();\n          }\n\n        else if (tag == 0x0114 && len < 256000)\t\t// CameraSettings\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            switch (len) {\n            case 280:\n            case 364:\n            case 332:\n              // CameraSettings and CameraSettings2 are big endian\n              if (table_buf[2] | table_buf[3])\n                {\n                  lid = (((ushort)table_buf[2])<<8) |\n                    ((ushort)table_buf[3]);\n                  imgdata.lens.makernotes.CurAp =\n                    powf64(2.0f, ((float)lid/8.0f-1.0f)/2.0f);\n                }\n              break;\n            case 1536:\n            case 2048:\n              // CameraSettings3 are little endian\n              parseSonyLensType2(table_buf[1016], table_buf[1015]);\n              if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n                {\n                  switch (table_buf[153]) {\n                  case 16: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A; break;\n                  case 17: imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E; break;\n                  }\n                }\n              break;\n            }\n            free(table_buf);\n          }\n\n        else if (tag == 0x9050 && len < 256000)\t\t// little endian\n          {\n            table_buf_0x9050 = (uchar*)malloc(len);\n            table_buf_0x9050_present = 1;\n            fread(table_buf_0x9050, len, 1, ifp);\n\n            if (imgdata.lens.makernotes.CamID)\n              {\n                process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n                free (table_buf_0x9050);\n                table_buf_0x9050_present = 0;\n              }\n          }\n\n        else if (tag == 0x940c && len <256000)\n          {\n            table_buf_0x940c = (uchar*)malloc(len);\n            table_buf_0x940c_present = 1;\n            fread(table_buf_0x940c, len, 1, ifp);\n            if ((imgdata.lens.makernotes.CamID) &&\n                (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n              {\n                process_Sony_0x940c(table_buf_0x940c);\n                free(table_buf_0x940c);\n                table_buf_0x940c_present = 0;\n              }\n          }\n\n        else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n          {\n            imgdata.lens.makernotes.LensID = get4();\n            if ((imgdata.lens.makernotes.LensID > 0x4900) &&\n                (imgdata.lens.makernotes.LensID <= 0x5900))\n            {\n              imgdata.lens.makernotes.AdapterID = 0x4900;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n              strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n            }\n\n            else if ((imgdata.lens.makernotes.LensID > 0xEF00) &&\n                (imgdata.lens.makernotes.LensID < 0xFFFF)      &&\n                (imgdata.lens.makernotes.LensID != 0xFF00))\n            {\n              imgdata.lens.makernotes.AdapterID = 0xEF00;\n              imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n            }\n            if (tag == 0x010c) imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n          }\n\n        else if (tag == 0xb02a && len < 256000)\t// Sony LensSpec\n          {\n            table_buf = (uchar*)malloc(len);\n            fread(table_buf, len, 1, ifp);\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal =\n                bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal =\n                bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            free(table_buf);\n          }\n      }\n\n    fseek(ifp,_pos,SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make,\"NIKON\") && !iso_speed)\n      iso_speed = (get2(),get2());\n    if (tag == 37 && strstr(make,\"NIKON\") && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc,1,1,ifp);\n        iso_speed = int(100.0 * powf64(2.0f,float(cc)/12.0-5.0));\n      }\n    if (tag == 4 && len > 26 && len < 35) {\n      if ((i=(get4(),get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n\tiso_speed = 50 * powf64(2.0, i/32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i=(get2(),get2())) != 0x7fff && !aperture)\n\taperture = powf64(2.0, i/64.0);\n#endif\n      if ((i=get2()) != 0xffff && !shutter)\n\tshutter = powf64(2.0, (short) i/-32.0);\n      wbi = (get2(),get2());\n      shot_order = (get2(),get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make,\"KONICA\",6)) {\n      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);\n      switch (get2()) {\n\tcase 72:  flip = 0;  break;\n\tcase 76:  flip = 6;  break;\n\tcase 82:  flip = 5;  break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets (model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make,\"Canon\",5))\n      fread (artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {\n      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)\n\tc = c << 8 | fgetc(ifp);\n      while ((i+=4) < len-5)\n\tif (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)\n\t  flip = \"065\"[c]-'0';\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4) unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n\tif (!strncasecmp(make,\"Olympus\",7))\n\t{\n\t  short nWB, tWB;\n\t  if ((tag == 0x20300108) || (tag == 0x20310109))\n\t      imgdata.makernotes.olympus.ColorSpace = get2();\n\n\t  if ((tag == 0x20400102) && (len == 2) &&\n\t      (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n\t    {\n\t      int i;\n\t      for (i=0; i<64; i++)\n\t\timgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] =\n\t\t  imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t      for (i=64; i<256; i++)\n\t\timgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t    }\n\t  if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n\t    {\n\t      ushort CT;\n\t      nWB = tag-0x20400102;\n\t      switch (nWB)\n\t\t{\n                case 0 : CT = 3000; tWB = LIBRAW_WBI_Tungsten; break;\n\t\tcase 1 : CT = 3300; tWB = 0x100; break;\n\t\tcase 2 : CT = 3600; tWB = 0x100; break;\n\t\tcase 3 : CT = 3900; tWB = 0x100; break;\n                case 4 : CT = 4000; tWB = LIBRAW_WBI_FL_W; break;\n\t\tcase 5 : CT = 4300; tWB = 0x100; break;\n                case 6 : CT = 4500; tWB = LIBRAW_WBI_FL_D; break;\n\t\tcase 7 : CT = 4800; tWB = 0x100; break;\n                case 8 : CT = 5300; tWB = LIBRAW_WBI_FineWeather; break;\n                case 9 : CT = 6000; tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: CT = 6600; tWB = LIBRAW_WBI_FL_N; break;\n                case 11: CT = 7500; tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: CT = 0; tWB = 0x100;\n\t\t}\n\t      if (CT)\n\t\t{\n\t\t  imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n\t\t  imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n\t\t  imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n\t\t  if (len == 4)\n\t\t    {\n\t\t      imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n\t\t      imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t\t    }\n\t\t}\n\t      if (tWB != 0x100)\n\t\tFORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c+1];\n\t    }\n\t  if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n\t    {\n\t      nWB = tag-0x20400113;\n\t      imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n\t      switch (nWB)\n\t\t{\n                case 0:  tWB = LIBRAW_WBI_Tungsten; break;\n                case 4:  tWB = LIBRAW_WBI_FL_W; break;\n                case 6:  tWB = LIBRAW_WBI_FL_D; break;\n                case 8:  tWB = LIBRAW_WBI_FineWeather; break;\n                case 9:  tWB = LIBRAW_WBI_Cloudy; break;\n                case 10: tWB = LIBRAW_WBI_FL_N; break;\n                case 11: tWB = LIBRAW_WBI_Shade; break;\n\t\tdefault: tWB = 0x100;\n\t\t}\n\t      if (tWB != 0x100)\n\t\timgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] =\n\t\t  imgdata.color.WBCT_Coeffs[nWB][2];\n\t    }\n\n\t  if (tag == 0x20400121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n\t      if (len == 4)\n\t\t{\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n                  imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t\t}\n\t    }\n\t  if (tag == 0x2040011f)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n\t    }\n\t  if (tag == 0x30000120)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n\t      if (len == 2)\n\t\t{\n\t\t  for (int i=0; i<256; i++)\n\t\t    imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n\t\t}\n\t    }\n\t  if (tag == 0x30000121)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n\t    }\n\t  if (tag == 0x30000122)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n\t    }\n\t  if (tag == 0x30000123)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n\t    }\n\t  if (tag == 0x30000124)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n\t    }\n\t  if (tag == 0x30000130)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n\t    }\n\t  if (tag == 0x30000131)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n\t    }\n\t  if (tag == 0x30000132)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n\t    }\n\t  if (tag == 0x30000133)\n\t    {\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n\t    }\n\n\t  if((tag == 0x20400805) && (len == 2))\n\t    {\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[0]=getreal(type);\n\t      imgdata.makernotes.olympus.OlympusSensorCalibration[1]=getreal(type);\n\t      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n\t    }\n\t  if (tag == 0x20200401)\n\t    {\n\t      imgdata.other.FlashEC = getreal(type);\n\t    }\n\t}\n    fseek(ifp,_pos2,SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make,\"NIKON\",5)) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_tiff_ifd (base);\n    }\n    if (tag == 0x14 && type == 7) {\n      if (len == 2560) {\n\tfseek (ifp, 1248, SEEK_CUR);\n\tgoto get2_256;\n      }\n      fread (buf, 1, 10, ifp);\n      if (!strncmp(buf,\"NRW \",4)) {\n\tfseek (ifp, strcmp(buf+4,\"0100\") ? 46:1546, SEEK_CUR);\n\tcam_mul[0] = get4() << 2;\n\tcam_mul[1] = get4() + get4();\n\tcam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread (model, 64, 1, ifp);\n    if (strstr(make,\"PENTAX\")) {\n      if (tag == 0x1b) tag = 0x1018;\n      if (tag == 0x1c) tag = 0x1017;\n    }\n    if (tag == 0x1d) {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model,\"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1) {  // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\n      fseek (ifp, 8 + c*32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4) {\n      data_offset = get4();\n      fseek (ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width  = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81  && type == 7) ||\n\t(tag == 0x100 && type == 7) ||\n\t(tag == 0x280 && type == 1)) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97) {\n      for (i=0; i < 4; i++)\n\tver97 = ver97 * 10 + fgetc(ifp)-'0';\n      switch (ver97) {\n\tcase 100:\n\t  fseek (ifp, 68, SEEK_CUR);\n\t  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n\t  break;\n\tcase 102:\n\t  fseek (ifp, 6, SEEK_CUR);\n\t  FORC4 cam_mul[c ^ (c >> 1)] = get2();\n\t  break;\n\tcase 103:\n\t  fseek (ifp, 16, SEEK_CUR);\n\t  FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200) {\n\tif (ver97 != 205) fseek (ifp, 280, SEEK_CUR);\n\tfread (buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7) {\n      order = 0x4949;\n      fseek (ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3) {\n      fseek (ifp, wbi*48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7) {\t// shutter count\n      NikonKey = fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp);\n        if ( (unsigned) (ver97-200) < 17) {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i=0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97-200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =\n          sget2 (buf97 + (i & -2) + c*2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601)  // Coolpix A\n    \t{\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    \t}\n#endif\n    }\n\n    if(tag == 0xb001 && type == 3)\t// Sony ModelID\n      {\n        unique_id = get2();\n      }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(),get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n         FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make,\"NIKON\") && len == 4)\n      {\n        FORC4 cblack[c ^ c >> 1] = get2();\n        i = cblack[3];\n        FORC3 if(i>cblack[c]) i = cblack[c];\n        FORC4 cblack[c]-=i;\n        black += i;\n      }\n#endif\n    if (tag == 0xe01) {\t\t/* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tint loopc = 0;\n#endif\n      order = 0x4949;\n      fseek (ifp, 22, SEEK_CUR);\n      for (offset=22; offset+22 < len; offset += 22+i) {\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(loopc++>1024)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\ttag = get4();\n\tfseek (ifp, 14, SEEK_CUR);\n\ti = get4()-4;\n\tif (tag == 0x76a43207) flip = get2();\n\telse fseek (ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7) {\n      fseek (ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7) {\n      if (len == 614)\n\tfseek (ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n\tfseek (ifp, 148, SEEK_CUR);\n      else goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n          for (i=0; i < 3; i++)\n\t  {\n#ifdef LIBRAW_LIBRARY_BUILD\n           if (!imgdata.makernotes.olympus.ColorSpace)\n\t   {\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n\t   }\n           else\n\t   {\n            FORC3 imgdata.color.ccm[i][c] = ((short) get2()) / 256.0;\n\t   }\n#else\n            FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;\n#endif\n          }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2) {\nget2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek (ifp, get4()+base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    if (tag == 0x2010)\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, 0x2010);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n\n    if (\n         ((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) &&\n         ((type == 7) || (type == 13)) &&\n         !strncasecmp(make,\"Olympus\",7)\n       )\n      {\n        INT64 _pos3 = ftell(ifp);\n        parse_makernote(base, tag);\n        fseek(ifp,_pos3,SEEK_SET);\n      }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf,\"OLYMP\",5))\n      parse_thumb_note (base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote (base, 0x2040);\n    if (tag == 0xb028) {\n      fseek (ifp, get4()+base, SEEK_SET);\n      parse_thumb_note (base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000) {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek (ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i+=18; i <= len; i+=10) {\n      \tget2();\n      \tFORC4 sraw_mul[c ^ (c >> 1)] = get2();\n      \tif (sraw_mul[1] == 1170) break;\n      }\n    }\n    if(!strncasecmp(make,\"Samsung\",7))\n      {\n        if (tag == 0xa020) // get the full Samsung encryption key\n            for (i=0; i<11; i++) SamsungKey[i] = get4();\n        if (tag == 0xa021) // get and decode Samsung cam_mul array\n            FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 0xa023)\n          {\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n              }\n          }\n        if (tag == 0xa024)\n          {\n            FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c+1];\n            if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1]>>1))\n              {\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n              }\n          }\n        if (tag == 0xa025)\n           imgdata.color.linear_max[0]=\n             imgdata.color.linear_max[1]=\n             imgdata.color.linear_max[2]=\n             imgdata.color.linear_max[3]= get4() - SamsungKey[0];\n        if (tag == 0xa030 && len == 9)\n            for (i=0; i < 3; i++)\n              FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n#endif\n        if (tag == 0xa031 && len == 9)\t// get and decode Samsung color matrix\n            for (i=0; i < 3; i++)\n              FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i*3+c])))/256.0;\n\n        if (tag == 0xa028)\n          FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n      }\n    else\n      {\n        // Somebody else use 0xa021 and 0xa028?\n        if (tag == 0xa021)\n          FORC4 cam_mul[c ^ (c >> 1)] = get4();\n        if (tag == 0xa028)\n          FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n      }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\nnext:\n    fseek (ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp (int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i=19; i--; ) str[i] = fgetc(ifp);\n  else\n    fread (str, 19, 1, ifp);\n  memset (&t, 0, sizeof t);\n  if (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\n\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif (int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo,ape;\n\n  kodak = !strncmp(make,\"EASTMAN\",7) && tiff_nifds < 3;\n  entries = get2();\n  if(!strncmp(make,\"Hasselblad\",10) && (tiff_nifds > 3) && (entries > 512)) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && savepos + len > fsize*2) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n    switch (tag) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n      case 33434:  tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t   shutter = getreal(type);\t\tbreak;\n      case 33437:  aperture = getreal(type);\t\tbreak;  // 0x829d FNumber\n      case 34855:  iso_speed = get2();\t\t\tbreak;\n      case 34866:\n        if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\",4) || !strncasecmp(make, \"CANON\",5)))\n          iso_speed = getreal(type);\n        break;\n      case 36867:\n      case 36868:  get_timestamp(0);\t\t\tbreak;\n      case 37377:  if ((expo = -getreal(type)) < 128 && shutter == 0.)\n\t\t     tiff_ifd[tiff_nifds-1].t_shutter =\n\t\t\tshutter = powf64(2.0, expo);\n\t\tbreak;\n      case 37378:                                       // 0x9202 ApertureValue\n        if ((fabs(ape = getreal(type))<256.0) && (!aperture))\n          aperture = powf64(2.0, ape/2);\n        break;\n      case 37385:  flash_used = getreal(type);          break;\n      case 37386:  focal_len = getreal(type);\t\tbreak;\n      case 37500:  \t                         // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n       if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n           ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n         char mn_text[512];\n         char* pos;\n         char ccms[512];\n         ushort l;\n         float num;\n\n         fgets(mn_text, len, ifp);\n         pos = strstr(mn_text, \"gain_r=\");\n         if (pos) cam_mul[0] = atof(pos+7);\n         pos = strstr(mn_text, \"gain_b=\");\n         if (pos) cam_mul[2] = atof(pos+7);\n         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n         else cam_mul[0] = cam_mul[2] = 0.0f;\n\n         pos = strstr(mn_text, \"ccm=\") + 4;\n         l = strstr(pos, \" \") - pos;\n         memcpy (ccms, pos, l);\n         ccms[l] = '\\0';\n\n         pos = strtok (ccms, \",\");\n         for (l=0; l<4; l++) {\n           num = 0.0;\n           for (c=0; c<3; c++) {\n             imgdata.color.ccm[l][c] = (float)atoi(pos);\n             num += imgdata.color.ccm[l][c];\n             pos = strtok (NULL, \",\");\n           }\n           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n         }\n       }\n       else\n#endif\n        parse_makernote (base, 0);\n       break;\n      case 40962:  if (kodak) raw_width  = get4();\tbreak;\n      case 40963:  if (kodak) raw_height = get4();\tbreak;\n      case 41730:\n\tif (get4() == 0x20002)\n\t  for (exif_cfa=c=0; c < 8; c+=2)\n\t    exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n  \treturn;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--) {\n    tiff_get(base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n    case 1:  imgdata.other.parsed_gps.latref = getc(ifp); break;\n    case 3:  imgdata.other.parsed_gps.longref = getc(ifp); break;\n    case 5:  imgdata.other.parsed_gps.altref = getc(ifp); break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9: imgdata.other.parsed_gps.gpsstatus = getc(ifp); break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps (int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if(len > 1024) continue; // no GPS tags are 1k or larger\n    switch (tag) {\n      case 1: case 3: case 5:\n\tgpsdata[29+tag/2] = getc(ifp);\t\t\tbreak;\n      case 2: case 4: case 7:\n\tFORC(6) gpsdata[tag/3*6+c] = get4();\t\tbreak;\n      case 6:\n\tFORC(2) gpsdata[18+c] = get4();\t\t\tbreak;\n      case 18: case 29:\n\tfgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff (float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\n  { {  2.034193, -0.727420, -0.306766 },\n    { -0.228811,  1.231729, -0.002922 },\n    { -0.008565, -0.153273,  1.161839 } };\n  int i, j, k;\n\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      for (cmatrix[i][j] = k=0; k < 3; k++)\n\tcmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"AFi-II 7\",\"Aptus-II 7\",\"\",\"Aptus-II 6\",\"\",\"\",\"Aptus-II 10\",\"Aptus-II 5\",\n    \"\",\"\",\"\",\"\",\"Aptus-II 10R\",\"Aptus-II 8\",\"\",\"Aptus-II 12\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data,\"CameraObj_camera_type\")) {\n\tstmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data,\"back_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.BodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.BodySerial));\n       strcpy (imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data,\"CaptProf_serial_number\")) {\n       char buffer [sizeof(imgdata.shootinginfo.InternalBodySerial)];\n       char *words[4];\n       int nwords;\n       stmread(buffer, skip, ifp);\n       nwords = getwords(buffer, words, 4,sizeof(imgdata.shootinginfo.InternalBodySerial));\n       strcpy (imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n// IB end\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\t((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n\nvoid CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x10000) len = 0x10000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x10000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[len<0x1000?0xfff:len-1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags (int wb, unsigned type)\n{\n\tfloat mul[3]={1,1,1}, num, mul2;\n\tint c;\n\tFORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n\timgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n\tmul2 = mul[1] * mul[1];\n\timgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n\timgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n\treturn;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  INT64 fsize = ifp->size();\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > 2*fsize) continue;\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag | 0x20000,type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n    if (tag == 1011) imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f,get2());\n      wbi = -2;\n    }\n\n    if (tag == 0x0848) Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849) Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a) Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b) Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93) imgdata.color.linear_max[0] =\n                         imgdata.color.linear_max[1] =\n                         imgdata.color.linear_max[2] =\n                         imgdata.color.linear_max[3] = get2();\n        if (tag == 0x09ce)\n\t\tstmread(imgdata.shootinginfo.InternalBodySerial,len, ifp);\n        if (tag == 0xfa00)\n\t\tstmread(imgdata.shootinginfo.BodySerial, len, ifp);\n\tif (tag == 0xfa27)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\t  }\n\tif (tag == 0xfa28)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\t  }\n\tif (tag == 0xfa29)\n\t  {\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\t  }\n\tif (tag == 0xfa2a)\n\t  {\n            FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\t  }\n\n    if (tag == 2120 + wbi ||\n        (wbi<0 && tag == 2125))  /* use Auto WB if illuminant index is not set */\n      {\n        FORC3 mul[c] = (num=getreal(type))==0 ? 1 : num;\n        FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 0x903) iso_speed = getreal(type);\n    //if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,get2());\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0,getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / fMAX(1.0,(num * mul[c]));\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#endif\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if(len > 8 && len + savepos > fsize*2) continue; // skip tag pointing out of 2xfile\n    if(callbacks.exif_cb)\n      {\n        callbacks.exif_cb(callbacks.exifparser_data,tag|(pana_raw?0x30000:0),type,len,order,ifp);\n        fseek(ifp,savepos,SEEK_SET);\n      }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!strncasecmp(make, \"SONY\", 4) ||\n      (!strncasecmp(make, \"Hasselblad\", 10) &&\n        (!strncasecmp(model, \"Stellar\", 7) ||\n         !strncasecmp(model, \"Lunar\", 5) ||\n         !strncasecmp(model, \"HV\",2))))\n  {\n  \tswitch (tag) {\n\tcase 0x7300: // SR2 black level\n\t    for (int i = 0; i < 4 && i < len; i++)\n\t      cblack[i] = get2();\n\t  break;\n\tcase 0x7480:\n\tcase 0x7820:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n\tbreak;\n\tcase 0x7481:\n\tcase 0x7821:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n\tbreak;\n\tcase 0x7482:\n\tcase 0x7822:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n\tbreak;\n\tcase 0x7483:\n\tcase 0x7823:\n\t    FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n\t    imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n\tbreak;\n\tcase 0x7484:\n\tcase 0x7824:\n\t    imgdata.color.WBCT_Coeffs[0][0] = 4500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[0][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n\tbreak;\n\tcase 0x7486:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n\tbreak;\n\tcase 0x7825:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n\tbreak;\n\tcase 0x7826:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n\tbreak;\n\tcase 0x7827:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n\tbreak;\n\tcase 0x7828:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n\tbreak;\n\tcase 0x7829:\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n\tbreak;\n\tcase 0x782a:\n\t    imgdata.color.WBCT_Coeffs[1][0] = 8500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[1][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n\tbreak;\n\tcase 0x782b:\n\t    imgdata.color.WBCT_Coeffs[2][0] = 6000;\n\t    FORC3 imgdata.color.WBCT_Coeffs[2][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n\tbreak;\n\tcase 0x782c:\n\t    imgdata.color.WBCT_Coeffs[3][0] = 3200;\n                FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c+1] = get2();\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] = imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n\tbreak;\n\tcase 0x782d:\n\t    imgdata.color.WBCT_Coeffs[4][0] = 2500;\n\t    FORC3 imgdata.color.WBCT_Coeffs[4][c+1] = get2();\n\t    imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n\tbreak;\n\tcase 0x787f:\n\t    FORC3 imgdata.color.linear_max[c] = get2();\n\t    imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n\tbreak;\n\t}\n  }\n#endif\n\n\n    switch (tag) {\n      case 1:   if(len==4) pana_raw = get4(); break;\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:   if ((i = get2())) filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=i;\n#endif\n      break;\n      case 8:\n      case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          pana_black[3]+=get2();\n#endif\n      break;\n      case 14: case 15: case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw) {\n          imgdata.color.linear_max[tag-14] = get2();\n          if (tag == 15 ) imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        }\n#endif\n      break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 19:\n\tif(pana_raw) {\n\t  ushort nWB, cnt, tWB;\n\t  nWB = get2();\n\t  if (nWB > 0x100) break;\n\t  for (cnt=0; cnt<nWB; cnt++) {\n\t    tWB = get2();\n\t    if (tWB < 0x100) {\n\t      imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t      imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n\t    } else get4();\n\t  }\n\t}\n      break;\n#endif\n      case 23:\n\tif (type == 3) iso_speed = get2();\n      break;\n      case 28: case 29: case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(pana_raw && len == 1 && type ==3)\n          {\n            pana_black[tag-28] = get2();\n          }\n        else\n#endif\n          {\n\t     cblack[tag-28] = get2();\n\t     cblack[3] = cblack[1];\n          }\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-36] = get2();\n\tbreak;\n      case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(pana_raw) {\n\t    ushort nWB, cnt, tWB;\n\t    nWB = get2();\n\t    if (nWB > 0x100) break;\n\t    for (cnt=0; cnt<nWB; cnt++) {\n\t        tWB = get2();\n\t        if (tWB < 0x100) {\n\t            imgdata.color.WB_Coeffs[tWB][0] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n\t            imgdata.color.WB_Coeffs[tWB][2] = get2();\n\t        } else fseek(ifp, 6, SEEK_CUR);\n\t    }\n\t}\n\tbreak;\n#endif\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tif (tiff_bps < tiff_ifd[ifd].bps)\n\t    tiff_bps = tiff_ifd[ifd].bps;\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tif (tiff_ifd[ifd].bps > 12) break;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 278:\n\ttiff_ifd[ifd].rows_per_strip = getint(type);\n\tbreak;\n#endif\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_offsets = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_offsets_count = len;\n\t    for(int i=0; i< len; i++)\n\t      tiff_ifd[ifd].strip_offsets[i]=get4()+base;\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    if ((tiff_ifd[ifd].t_width > 4*tiff_ifd[ifd].t_height) & ~jh.clrs) {\n\t      tiff_ifd[ifd].t_width  /= 2;\n\t      tiff_ifd[ifd].t_height *= 2;\n\t    }\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(len > 1 && len < 16384)\n\t  {\n\t    off_t sav = ftell(ifp);\n\t    tiff_ifd[ifd].strip_byte_counts = (int*)calloc(len,sizeof(int));\n\t    tiff_ifd[ifd].strip_byte_counts_count = len;\n\t    for(int i=0; i< len; i++)\n\t\ttiff_ifd[ifd].strip_byte_counts[i]=get4();\n\t    fseek(ifp,sav,SEEK_SET); // restore position\n\t  }\n\t/* fallback */\n#endif\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 317:\n\ttiff_ifd[ifd].predictor = getint(type);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 1)\n\t  tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n      case 325:\n\ttiff_ifd[ifd].bytes = len > 1 ? ftell(ifp): get4();\n\tbreak;\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n         \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif  \n\t  break;\n\t}\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (!strncmp(make,\"Hasselblad\",10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag) {\n          fseek (ifp, ftell(ifp)+4, SEEK_SET);\n          fseek (ifp, get4()+base, SEEK_SET);\n          parse_tiff_ifd (base);\n          break;\n\t}\n#endif\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 339:\n\ttiff_ifd[ifd].sample_format = getint(type);\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 700:\n        if((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n          {\n            xmpdata = (char*)malloc(xmplen = len+1);\n            fread(xmpdata,len,1,ifp);\n            xmpdata[len]=0;\n          }\n        break;\n#endif\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i=0; i < 3; i++) {\n        float num = 0.0;\n        for (c=0; c<3; c++) {\n          imgdata.color.ccm[i][c] = (float) ((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01) FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n\t  FORC4 cblack[c ^ c >> 1] = get2();\n\t  i = cblack[3];\n\t  FORC3 if(i>cblack[c]) i = cblack[c];\n\t  FORC4 cblack[c]-=i;\n\t  black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);\n#endif\n      break;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33421:\t\t\t/* CFARepeatPatternDim */\n\tif (get2() == 6 && get2() == 6)\n\t  filters = 9;\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n\tif (filters == 9) {\n\t  FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;\n\t  break;\n\t}\n      case 64777:\t\t\t/* Kodak P-series */\n        if(len == 36)\n          {\n            filters = 9;\n            colors = 3;\n            FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n          }\n        else if(len > 0)\n          {\n            if ((plen=len) > 16) plen = 16;\n            fread (cfa_pat, 1, plen, ifp);\n            for (colors=cfa=i=0; i < plen && colors < 4; i++) {\n              colors += !(cfa & (1 << cfa_pat[i]));\n              cfa |= 1 << cfa_pat[i];\n            }\n            if (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n            if (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n            goto guess_cfa_pc;\n          }\n        break;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\ttiff_ifd[ifd].t_shutter = shutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n// IB start\n    case 0xa405:\t\t// FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431:\t\t// BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432:\t\t// LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435:\t\t// LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630:\t\t// DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433:\t\t// LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434:\t\t// LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= MAX(1,num);\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n        {\n          unsigned pos;\n          fseek(ifp, pos = (get4() + base), SEEK_SET);\n          parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n          fseek(ifp, pos, SEEK_SET);\n          parse_gps_libraw(base);\n#endif\n        }\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 40976:\n\tstrip_offset = get4();\n\tswitch (tiff_ifd[ifd].comp) {\n\t  case 32770: load_raw = &CLASS samsung_load_raw;   break;\n\t  case 32772: load_raw = &CLASS samsung2_load_raw;  break;\n\t  case 32773: load_raw = &CLASS samsung3_load_raw;  break;\n\t}\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (len < 1 || len > 2560000 || !(cbuf = (char *) malloc(len))) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfread (cbuf, 1, len, ifp);\n#else\n\tif(fread (cbuf, 1, len, ifp) != len)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n        cbuf[len-1] = 0;\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n        libraw_internal_data.unpacker_data.hasselblad_parser_flag=1;\n#endif\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50708:\t\t\t/* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n        stmread(imgdata.color.UniqueCameraModel, len, ifp);\n        imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel)-1] = 0;\n#endif\n\tif (model[0]) break;\n#ifndef LIBRAW_LIBRARY_BUILD\n\tfgets (make, 64, ifp);\n#else\n        strncpy (make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n\tif ((cp = strchr(make,' '))) {\n\t  strcpy(model,cp+1);\n\t  *cp = 0;\n\t}\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (filters == 9) break;\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n        FORCC tab[cfa_pc[c]] = c;\n        cdesc[c] = 0;\n        for (i=16; i--; )\n          filters = filters << 2 | tab[cfa_pat[i % plen]];\n        filters -= !filters;\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) fuji_width = 1;\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[4] = \n#endif\n\tcblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.dng_levels.dng_cblack[5] = \n#endif\n\tcblack[5] = get2();\n\tif (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof (cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n            imgdata.color.dng_levels.dng_cblack[4]=\n\t    imgdata.color.dng_levels.dng_cblack[5]= \n#endif\n\t    cblack[4] = cblack[5] = 1;\n\tbreak;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\tcase 0xf00c: {\n    \tunsigned fwb[4];\n    \tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t  if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData>3 && libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n\t\t  {\n\t\t    long long f_save = ftell(ifp);\n\t\t    int fj, found = 0;\n\t\t    ushort *rafdata = (ushort*) malloc (sizeof(ushort)*libraw_internal_data.unpacker_data.lenRAFData);\n\t\t    fseek (ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n\t\t    fread (rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n\t\t    fseek(ifp, f_save, SEEK_SET);\n\t\t    for (int fi=0; fi<(libraw_internal_data.unpacker_data.lenRAFData-3); fi++)\n\t\t\t{\n\t\t\t  if ((fwb[0]==rafdata[fi]) && (fwb[1]==rafdata[fi+1]) && (fwb[2]==rafdata[fi+2]))\n\t\t\t  {\n\t\t\t    if (rafdata[fi-15] != fwb[0]) continue;\n\t\t\t    fi = fi - 15;\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] = rafdata[fi];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi+1];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi+2];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = rafdata[fi+3];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi+4];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi+5];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = rafdata[fi+6];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi+7];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi+8];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = rafdata[fi+9];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi+10];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi+11];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = rafdata[fi+12];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi+13];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi+14];\n\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = rafdata[fi+15];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi+16];\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi+17];\n\n                fi += 111;\n                for (fj = fi; fj<(fi+15); fj+=3)\n                  if (rafdata[fj] != rafdata[fi])\n                  {\n                    found = 1;\n                    break;\n                  }\n                if (found)\n                {\n                  int FujiCCT_K [31] = {2500,2550,2650,2700,2800,2850,2950,3000,3100,3200,3300,3400,3600,3700,3800,4000,4200,4300,4500,4800,5000,5300,5600,5900,6300,6700,7100,7700,8300,9100,10000};\n                  fj = fj - 93;\n                  for (int iCCT=0; iCCT < 31; iCCT++)\n                  {\n                    imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                    imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT*3+1+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT*3+fj];\n                    imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT*3+2+fj];\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t    free (rafdata);\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\t\tFORC4 fwb[c] = get4();\n\t\tif (fwb[3] < 0x100)\n\t\t{\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n\t\t  imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n\t\t}\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50709:\n        stmread(imgdata.color.LocalizedCameraModel,len, ifp);\n      break;\n#endif\n\n      case 61450:\n\tcblack[4] = cblack[5] = MIN(sqrt((double)len),64);\n      case 50714:\t\t\t/* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1  && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n\t  {\n\t    for(i=0; i < colors && i < 4 && i < len; i++)\n\t      imgdata.color.dng_levels.dng_cblack[i]=\n\t        cblack[i]=\n\t\t  getreal(type)+0.5;\n\n\t    imgdata.color.dng_levels.dng_black= black = 0;\n\t  }\n\telse\n#endif\n\t  if((cblack[4] * cblack[5] < 2) && len == 1)\n\t    {\n#ifdef LIBRAW_LIBRARY_BUILD\n\t      imgdata.color.dng_levels.dng_black= \n#endif\n\t        black =\n\t\t  getreal(type);\n\t    }\n\t  else if(cblack[4] * cblack[5] <= len)\n\t    {\n\t      FORC (cblack[4] * cblack[5])\n\t\tcblack[6+c] = getreal(type);\n\t      black = 0;\n\t      FORC4\n\t\tcblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n              if(tag == 50714)\n\t      {\n\t        FORC (cblack[4] * cblack[5])\n\t          imgdata.color.dng_levels.dng_cblack[6+c]= cblack[6+c];\n\t        imgdata.color.dng_levels.dng_black=0;\n\t        FORC4\n\t          imgdata.color.dng_levels.dng_cblack[c]= 0;\n\t      }\n#endif\n\t    }\n      break;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_black += num/len + 0.5;\n#endif\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.dng_levels.dng_whitelevel[0]=\n#endif\n\tmaximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(tiff_ifd[ifd].samples > 1 ) // Linear DNG case\n\t\tfor(i=1; i < colors && i < 4 && i < len; i++)\n\t\t\timgdata.color.dng_levels.dng_whitelevel[i]=getint(type);\n#endif\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tif(pixel_aspect > 0.995 && pixel_aspect < 1.005)\n          pixel_aspect = 1.0;\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50778:\n        imgdata.color.dng_color[0].illuminant = get2();\n        break;\n      case 50779:\n        imgdata.color.dng_color[1].illuminant = get2();\n        break;\n#endif\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 50721?0:1;\n#endif\n\tFORCC for (j=0; j < 3; j++)\n          {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.color.dng_color[i].colormatrix[c][j]=\n#endif\n\t  cm[c][j] = getreal(type);\n          }\n\tuse_cm = 1;\n\tbreak;\n\n\tcase 0xc714:\t\t\t/* ForwardMatrix1 */\n        case 0xc715:\t\t\t/* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        i = tag == 0xc714?0:1;\n#endif\n\tfor (j=0; j < 3; j++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[i].forwardmatrix[j][c]=\n#endif\n              fm[j][c] = getreal(type);\n            }\n\tbreak;\n\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n        j = tag == 50723?0:1;\n#endif\n\tfor (i=0; i < colors; i++)\n\t  FORCC\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_color[j].calibration[i][c]=\n#endif\n              cc[i][c] = getreal(type);\n            }\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC{\n#ifdef LIBRAW_LIBRARY_BUILD\n              imgdata.color.dng_levels.analogbalance[c]=\n#endif\n\t      ab[c] = getreal(type);\n\t}\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 50730:\t\t\t/* DNG: Baseline Exposure */\n        baseline_exposure = getreal(type);\n        break;\n#endif\n\t\t  // IB start\n    case 50740:\t\t\t/* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        char mbuf[64];\n        unsigned short makernote_found = 0;\n        INT64 curr_pos, start_pos = ftell(ifp);\n        unsigned MakN_order, m_sorder = order;\n        unsigned MakN_length;\n        unsigned pos_in_original_raw;\n        fread(mbuf, 1, 6, ifp);\n\n        if (!strcmp(mbuf, \"Adobe\"))\n          {\n            order = 0x4d4d;\t\t\t\t// Adobe header is always in \"MM\" / big endian\n            curr_pos = start_pos + 6;\n            while (curr_pos + 8 - start_pos <= len)\n              {\n                fread(mbuf, 1, 4, ifp);\n                curr_pos += 8;\n                if (!strncmp(mbuf, \"MakN\", 4)) {\n                  makernote_found = 1;\n                MakN_length = get4();\n                MakN_order = get2();\n                pos_in_original_raw = get4();\n                order = MakN_order;\n                parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n                break;\n                }\n              }\n          }\n        else\n          {\n            fread(mbuf + 6, 1, 2, ifp);\n            if (!strcmp(mbuf, \"PENTAX \") ||\n                !strcmp(mbuf, \"SAMSUNG\"))\n              {\n                makernote_found = 1;\n                fseek(ifp, start_pos, SEEK_SET);\n                parse_makernote_0xc634(base, 0, CameraDNG);\n              }\n          }\n\n        fseek(ifp, start_pos, SEEK_SET);\n        order = m_sorder;\n      }\n      // IB end\n#endif\n      if (dng_version) break;\n      parse_minolta (j = get4()+base);\n      fseek (ifp, j, SEEK_SET);\n      parse_tiff_ifd (base);\n      break;\n    case 50752:\n      read_shorts (cr2_slice, 3);\n      break;\n    case 50829:\t\t\t/* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830:\t\t\t/* MaskedAreas */\n      for (i=0; i < len && i < 32; i++)\n        ((int*)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009:\t\t\t/* OpcodeList2 */\n      meta_offset = ftell(ifp);\n      break;\n    case 64772:\t\t\t/* Kodak P-series */\n      if (len < 13) break;\n      fseek (ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek (ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2) fgets (model2, 64, ifp);\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *) malloc(sony_length))) {\n    fseek (ifp, sony_offset, SEEK_SET);\n    fread (buf, sony_length, 1, ifp);\n    sony_decrypt (buf, sony_length/4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile())) {\n      fwrite (buf, sony_length, 1, ifp);\n      fseek (ifp, 0, SEEK_SET);\n      parse_tiff_ifd (-sony_offset);\n      fclose (ifp);\n    }\n    ifp = sfp;\n#else\n    if( !ifp->tempbuffer_open(buf,sony_length))\n        {\n            parse_tiff_ifd(-sony_offset);\n            ifp->tempbuffer_close();\n        }\n#endif\n    free (buf);\n  }\n  for (i=0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm) {\n    FORCC for (i=0; i < 3; i++)\n      for (cam_xyz[c][i]=j=0; j < colors; j++)\n\tcam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff (cmatrix, cam_xyz);\n  }\n  if (asn[0]) {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff (int base)\n{\n  int doff;\n  fseek (ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d) return 0;\n  get2();\n  while ((doff = get4())) {\n    fseek (ifp, doff+base, SEEK_SET);\n    if (parse_tiff_ifd (base)) break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      if((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n        {\n          thumb_misc   = jh.bits;\n          thumb_width  = jh.wide;\n          thumb_height = jh.high;\n        }\n    }\n  }\n  for (i=tiff_nifds; i--; ) {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i=0; i < tiff_nifds; i++) {\n    if (max_samp < tiff_ifd[i].samples)\n\tmax_samp = tiff_ifd[i].samples;\n    if (max_samp > 3) max_samp = 3;\n    os = raw_width*raw_height;\n    ns = tiff_ifd[i].t_width*tiff_ifd[i].t_height;\n    if (tiff_bps) {\n        os *= tiff_bps;\n        ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n\tunsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        (unsigned)tiff_ifd[i].bps < 33 && (unsigned)tiff_ifd[i].samples < 13 &&\n\t ns && ((ns > os && (ties = 1)) ||\n\t\t(ns == os && shot_select == ties++))) {\n      raw_width     = tiff_ifd[i].t_width;\n      raw_height    = tiff_ifd[i].t_height;\n      tiff_bps      = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset   = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size     = tiff_ifd[i].bytes;\n#endif\n      tiff_flip     = tiff_ifd[i].t_flip;\n      tiff_samples  = tiff_ifd[i].samples;\n      tile_width    = tiff_ifd[i].t_tile_width;\n      tile_length   = tiff_ifd[i].t_tile_length;\n      shutter       = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties) is_raw = ties;\n  if (!tile_width ) tile_width  = INT_MAX;\n  if (!tile_length) tile_length = INT_MAX;\n  for (i=tiff_nifds; i--; )\n    if (tiff_ifd[i].t_flip) tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress) {\n      case 32767:\n\tif (tiff_ifd[raw].bytes == raw_width*raw_height) {\n\t  tiff_bps = 12;\n\t  load_raw = &CLASS sony_arw2_load_raw;\t\t\tbreak;\n\t}\n\tif (!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2) {\n\t  tiff_bps = 14;\n\t  load_raw = &CLASS unpacked_load_raw;\t\t\tbreak;\n\t}\n\tif (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {\n\t  raw_height += 8;\n\t  load_raw = &CLASS sony_arw_load_raw;\t\t\tbreak;\n\t}\n\tload_flags = 79;\n      case 32769:\n\tload_flags++;\n      case 32770:\n      case 32773: goto slr;\n      case 0:  case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n\t// Sony 14-bit uncompressed\n        if(!strncasecmp(make,\"Sony\",4) &&\n\t    tiff_ifd[raw].bytes == raw_width*raw_height*2)\n          {\n\t    tiff_bps = 14;\n            load_raw = &CLASS unpacked_load_raw;\n            break;\n\t  }\n        if(!strncasecmp(make,\"Nikon\",5) && !strncmp(software,\"Nikon Scan\",10))\n          {\n            load_raw = &CLASS nikon_coolscan_load_raw;\n            raw_color = 1;\n            filters = 0;\n            break;\n          }\n#endif\n\tif (!strncmp(make,\"OLYMPUS\",7) &&\n\t\ttiff_ifd[raw].bytes*2 == raw_width*raw_height*3)\n\t  load_flags = 24;\n\tif (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {\n\t  load_flags = 81;\n\t  tiff_bps = 12;\n\t} slr:\n\tswitch (tiff_bps) {\n\t  case  8: load_raw = &CLASS eight_bit_load_raw;\tbreak;\n\t  case 12: if (tiff_ifd[raw].phint == 2)\n\t\t     load_flags = 6;\n\t\t   load_raw = &CLASS packed_load_raw;\t\tbreak;\n\t  case 14: load_flags = 0;\n\t  case 16: load_raw = &CLASS unpacked_load_raw;\n\t\t   if (!strncmp(make,\"OLYMPUS\",7) &&\n\t\t\ttiff_ifd[raw].bytes*7 > raw_width*raw_height)\n\t\t     load_raw = &CLASS olympus_load_raw;\n\t}\n\tbreak;\n      case 6:  case 7:  case 99:\n\tload_raw = &CLASS lossless_jpeg_load_raw;\t\tbreak;\n      case 262:\n\tload_raw = &CLASS kodak_262_load_raw;\t\t\tbreak;\n      case 34713:\n\tif ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  load_flags = 1;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {\n\t  load_raw = &CLASS packed_load_raw;\n\t  if (model[0] == 'N') load_flags = 80;\n\t} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS nikon_yuv_load_raw;\n\t  gamma_curve (1/2.4, 12.92, 1, 4095);\n\t  memset (cblack, 0, sizeof cblack);\n\t  filters = 0;\n\t} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {\n\t  load_raw = &CLASS unpacked_load_raw;\n\t  load_flags = 4;\n\t  order = 0x4d4d;\n\t} else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if(raw_width*raw_height*3 == tiff_ifd[raw].bytes*2)\n            {\n              load_raw = &CLASS packed_load_raw;\n              load_flags=80;\n            }\n          else if(tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n\t\t  tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n\t    {\n\t      int fit = 1;\n\t      for(int i = 0; i < tiff_ifd[raw].strip_byte_counts_count-1; i++) // all but last\n\t\tif(tiff_ifd[raw].strip_byte_counts[i]*2 != tiff_ifd[raw].rows_per_strip*raw_width*3)\n\t\t  {\n\t\t    fit = 0;\n\t\t    break;\n\t\t  }\n\t      if(fit)\n\t\tload_raw = &CLASS nikon_load_striped_packed_raw;\n\t      else\n\t\tload_raw = &CLASS nikon_load_raw; // fallback\n\t    }\n\telse\n#endif\n            load_raw = &CLASS nikon_load_raw;\t\t\tbreak;\n      case 65535:\n\tload_raw = &CLASS pentax_load_raw;\t\t\tbreak;\n      case 65000:\n\tswitch (tiff_ifd[raw].phint) {\n\t  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;\n\t  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;\n\t  case 32803: load_raw = &CLASS kodak_65000_load_raw;\n\t}\n      case 32867: case 34892: break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8: break;\n#endif\n      default: is_raw = 0;\n    }\n  if (!dng_version)\n    if ( ((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&\n\t  (tiff_compress & -16) != 32768)\n          || (tiff_bps == 8 && strncmp(make,\"Phase\",5) &&\n\t  !strcasestr(make,\"Kodak\") &&\n\t  !strstr(model2,\"DEBUG RAW\")))\n         && strncmp(software,\"Nikon Scan\",10))\n      is_raw = 0;\n  for (i=0; i < tiff_nifds; i++)\n    if (i != raw\n        && (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps>0 && tiff_ifd[i].bps < 33\n\t&& tiff_ifd[i].phint != 32803\n\t&& tiff_ifd[i].phint != 34892\n        && unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n\ttiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps)+1) >\n\t      thumb_width *       thumb_height / (SQR(thumb_misc)+1)\n\t&& tiff_ifd[i].comp != 34892) {\n      thumb_width  = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc   = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0) {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp) {\n      case 0:\n\twrite_thumb = &CLASS layer_thumb;\n\tbreak;\n      case 1:\n\tif (tiff_ifd[thm].bps <= 8)\n\t  write_thumb = &CLASS ppm_thumb;\n\telse if (!strncmp(make,\"Imacon\",6))\n\t  write_thumb = &CLASS ppm16_thumb;\n\telse\n\t  thumb_load_raw = &CLASS kodak_thumb_load_raw;\n\tbreak;\n      case 65000:\n\tthumb_load_raw = tiff_ifd[thm].phint == 6 ?\n\t\t&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta (int base)\n{\n  int save, tag, len, offset, high=0, wide=0, i, c;\n  short sorder=order;\n\n  fseek (ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save=ftell(ifp)) < offset) {\n    for (tag=i=0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag) {\n      case 0x505244:\t\t\t\t/* PRD */\n\tfseek (ifp, 8, SEEK_CUR);\n\thigh = get2();\n\twide = get2();\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x524946:\t\t\t\t/* RIF */\n    if (!strncasecmp(model,\"DSLR-A100\", 9))\n    {\n      fseek(ifp, 8, SEEK_CUR);\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n      get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n    }\n\tbreak;\n#endif\n      case 0x574247:\t\t\t\t/* WBG */\n\tget4();\n\ti = strcmp(model,\"DiMAGE A200\") ? 0:3;\n\tFORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n\tbreak;\n      case 0x545457:\t\t\t\t/* TTW */\n\tparse_tiff (ftell(ifp));\n\tdata_offset = offset;\n    }\n    fseek (ifp, save+len+8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width  = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save=ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if(ifp->wfname())\n  {\n\t  std::wstring rawfile(ifp->wfname());\n\t  rawfile.replace(rawfile.length()-3,3,L\"JPG\");\n\t  if(!ifp->subfile_open(rawfile.c_str()))\n\t  {\n\t\t  parse_tiff (12);\n\t\t  thumb_offset = 0;\n\t\t  is_raw = 1;\n\t\t  ifp->subfile_close();\n\t  }\n\t  else\n\t\t  imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n\t return;\n  }\n#endif\n  if(!ifp->fname())\n      {\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n          return;\n      }\n#endif\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file) file = ifname-1;\n#else\n  if (!file) file = (char*)ifname-1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n#else\n  if (strcmp (jname, ifname))\n      {\n          if(!ifp->subfile_open(jname))\n              {\n                  parse_tiff (12);\n                  thumb_offset = 0;\n                  is_raw = 1;\n                  ifp->subfile_close();\n              }\n          else\n              imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n      }\n#endif\n  if (!timestamp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA ;\n#endif\n#ifdef DCRAW_VERBOSE\n          fprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n      }\n  free (jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = { 0x410, 0x45f3 };\n  int i, bpp, row, col, vbits=0;\n  unsigned long bitbuf=0;\n\n  if ((get2(),get4()) != 0x80008 || !get4()) return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12) return;\n  for (i=row=0; row < 8; row++)\n    for (col=0; col < 8; col++) {\n      if (vbits < bpp) {\n\tbitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n\tvbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff (int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi=-1;\n  ushort key[] = { 0x410, 0x45f3 };\n\n  fseek (ifp, offset+length-4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek (ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127) return;\n  while (nrecs--) {\n    type = get2();\n    len  = get4();\n    save = ftell(ifp) + 4;\n    fseek (ifp, offset+get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38) {\n      parse_ciff (ftell(ifp), len, depth+1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004) parse_ciff (ftell(ifp), len, depth+1);\n#endif\n    if (type == 0x0810)\n      fread (artist, 64, 1, ifp);\n    if (type == 0x080a) {\n      fread (make, 64, 1, ifp);\n      fseek (ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread (model, 64, 1, ifp);\n    }\n    if (type == 0x1810) {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835)\t\t\t/* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007) {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818) {\n      shutter = powf64(2.0f, -int_to_float((get4(),get4())));\n      aperture = powf64(2.0f, int_to_float(get4())/2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a) {\n//      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(),get2()) + get2())/32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture  = _CanonConvertAperture((get2(),get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture  = powf64(2.0, (get2(),(short)get2())/64.0);\n#endif\n      shutter   = powf64(2.0,-((short)get2())/32.0);\n      wbi = (get2(),get2());\n      if (wbi > 17) wbi = 0;\n      fseek (ifp, 32, SEEK_CUR);\n      if (shutter > 1e6) shutter = get2()/10.0;\n    }\n    if (type == 0x102c) {\n      if (get2() > 512) {\t\t/* Pro90, G1 */\n\tfseek (ifp, 118, SEEK_CUR);\n\tFORC4 cam_mul[c ^ 2] = get2();\n      } else {\t\t\t\t/* G2, S30, S40 */\n\tfseek (ifp, 98, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n      {\n\tINT64 o = ftell(ifp);\n\tfseek (ifp, (0x5<<1), SEEK_CUR);\n\tCanon_WBpresets(0,0);\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x102d)\n      {\n\tINT64 o = ftell(ifp);\n\tCanon_CameraSettings();\n\tfseek(ifp,o,SEEK_SET);\n      }\n    if (type == 0x580b)\n      {\n        if (strcmp(model,\"Canon EOS D30\")) sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n        else sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len>>16, len&0xffff);\n      }\n#endif\n    if (type == 0x0032) {\n      if (len == 768) {\t\t\t/* EOS D30 */\n\tfseek (ifp, 72, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n\tif (!wbi) cam_mul[0] = -1;\t/* use my auto white balance */\n      } else if (!cam_mul[0]) {\n\tif (get2() == key[0])\t\t/* Pro1, G6, S60, S70 */\n\t  c = (strstr(model,\"Pro1\") ?\n\t      \"012346000000000000\":\"01345:000000006008\")[LIM(0,wbi,17)]-'0'+ 2;\n\telse {\t\t\t\t/* G3, G5, S45, S50 */\n\t  c = \"023457000000006000\"[LIM(0,wbi,17)]-'0';\n\t  key[0] = key[1] = 0;\n\t}\n\tfseek (ifp, 78 + c*8, SEEK_CUR);\n\tFORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n\tif (!wbi) cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\n      if (len > 66) wbi = \"0134567028\"[LIM(0,wbi,9)]-'0';\n      fseek (ifp, 2 + wbi*8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi>=0 && (0x18040 >> wbi & 1))\n      ciff_block_1030();\t\t/* all that don't have 0x10a9 */\n    if (type == 0x1031) {\n      raw_width = (get2(),get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c) {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal  = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2) {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n\tif(imgdata.lens.makernotes.CanonFocalUnits>1)\n\t  imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2) focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813) flash_used = int_to_float(len);\n    if (type == 0x5814) canon_ev   = int_to_float(len);\n    if (type == 0x5817) shot_order = len;\n    if (type == 0x5834)\n      {\n         unique_id  = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n         setCanonBodyFeatures(unique_id);\n#endif\n      }\n    if (type == 0x580e) timestamp  = len;\n    if (type == 0x180e) timestamp  = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime (gmtime (&timestamp));\n#endif\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek (ifp, 0, SEEK_SET);\n  memset (&t, 0, sizeof t);\n  do {\n    fgets (line, 128, ifp);\n    if ((val = strchr(line,'=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line,\"DAT\"))\n      sscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line,\"TIM\"))\n      sscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line,\"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line,\"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line,\"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line,\"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line,\"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line,\"EOHD\",4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy (make, \"Rollei\");\n  strcpy (model,\"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek (ifp, get4(), SEEK_SET);\n  while (entries--) {\n    off = get4(); get4();\n    fread (str, 8, 1, ifp);\n    if (!strcmp(str,\"META\"))   meta_offset = off;\n    if (!strcmp(str,\"THUMB\")) thumb_offset = off;\n    if (!strcmp(str,\"RAW0\"))   data_offset = off;\n  }\n  fseek (ifp, meta_offset+20, SEEK_SET);\n  fread (make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make,' '))) {\n    strcpy (model, cp+1);\n    *cp = 0;\n  }\n  raw_width  = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(),get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one (int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset (&ph1, 0, sizeof ph1);\n  fseek (ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177) return;\t\t/* \"Raw\" */\n  fseek (ifp, get4()+base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--) {\n    tag  = get4();\n    type = get4();\n    len  = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek (ifp, base+data, SEEK_SET);\n    switch (tag) {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      } else {\n        unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4) imgdata.lens.makernotes.CurAp =  powf64(2.0f, (int_to_float(data)/2.0f));\n      else imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type)/2.0f));\n      break;\n    case 0x0403:\n      if (type == 4) imgdata.lens.makernotes.CurFocal =  int_to_float(data);\n      else imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4) {\n      \timgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data)/2.0f));\n      } else {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4) {\n        imgdata.lens.makernotes.MinFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n        {\n          imgdata.lens.makernotes.MinFocal = 0.0f;\n        }\n      break;\n    case 0x0417:\n      if (type == 4) {\n        imgdata.lens.makernotes.MaxFocal =  int_to_float(data);\n      } else {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n      case 0x100:  flip = \"0653\"[data & 3]-'0';  break;\n      case 0x106:\n\tfor (i=0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\timgdata.color.P1_color[0].romm_cam[i]=\n#endif\n\t  ((float *)romm_cam)[i] = getreal(11);\n\tromm_coeff (romm_cam);\n\tbreak;\n      case 0x107:\n\tFORC3 cam_mul[c] = getreal(11);\n\tbreak;\n      case 0x108:  raw_width     = data;\tbreak;\n      case 0x109:  raw_height    = data;\tbreak;\n      case 0x10a:  left_margin   = data;\tbreak;\n      case 0x10b:  top_margin    = data;\tbreak;\n      case 0x10c:  width         = data;\tbreak;\n      case 0x10d:  height        = data;\tbreak;\n      case 0x10e:  ph1.format    = data;\tbreak;\n      case 0x10f:  data_offset   = data+base;\tbreak;\n      case 0x110:  meta_offset   = data+base;\n\t\t   meta_length   = len;\t\t\tbreak;\n      case 0x112:  ph1.key_off   = save - 4;\t\tbreak;\n      case 0x210:  ph1.tag_210   = int_to_float(data);\tbreak;\n      case 0x21a:  ph1.tag_21a   = data;\t\tbreak;\n      case 0x21c:  strip_offset  = data+base;\t\tbreak;\n      case 0x21d:  ph1.t_black     = data;\t\tbreak;\n      case 0x222:  ph1.split_col = data;\t\tbreak;\n      case 0x223:  ph1.black_col = data+base;\t\tbreak;\n      case 0x224:  ph1.split_row = data;\t\tbreak;\n      case 0x225:  ph1.black_row = data+base;\t\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 0x226:\n\tfor (i=0; i < 9; i++)\n\t  imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n\tbreak;\n#endif\n      case 0x301:\n\tmodel[63] = 0;\n\tfread (model, 1, 63, ifp);\n\tif ((cp = strstr(model,\" camera\"))) *cp = 0;\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0]) {\n    fseek (ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek (ifp, 6, SEEK_CUR);\n    fseek (ifp, meta_offset+get4(), SEEK_SET);\n    entries = get4();  get4();\n    while (entries--) {\n      tag  = get4();\n      len  = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek (ifp, meta_offset+data, SEEK_SET);\n      if (tag == 0x0407) {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49)) {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        } else {\n          unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek (ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ?\n\t&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy (make, \"Phase One\");\n  if (model[0]) return;\n  switch (raw_height) {\n    case 2060: strcpy (model,\"LightPhase\");\tbreak;\n    case 2682: strcpy (model,\"H 10\");\t\tbreak;\n    case 4128: strcpy (model,\"H 20\");\t\tbreak;\n    case 5488: strcpy (model,\"H 25\");\t\tbreak;\n  }\n}\n\nvoid CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    } else if (tag == 0x131) {\n      filters = 9;\n      FORC(36)\n        {\n           int q = fgetc(ifp);\n           xtrans_abs[0][35 - c] = MAX(0,MIN(q,2)); /* & 3;*/\n        }\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    }\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b =fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    } else if (tag == 0x2100) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    } else if (tag == 0x2200) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    } else if (tag == 0x2300) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    } else if (tag == 0x2301) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    } else if (tag == 0x2302) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    } else if (tag == 0x2310) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    } else if (tag == 0x2400) {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n    }\n#endif\n// IB end\n    else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000) tag = get4();\n      if (tag > 10000) tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len>>1);\n#endif\n\t  order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}\n\nint CLASS parse_jpeg (int offset)\n{\n  int len, save, hlen, mark;\n  fseek (ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {\n    order = 0x4d4d;\n    len   = get2() - 2;\n    save  = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width  = get2();\n    }\n    order = get2();\n    hlen  = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n    )\t\t/* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (save+hlen, len-hlen, 0);\n    }\n    if (parse_tiff (save+6)) apply_tiff();\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] =\n  { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n  struct tm t;\n\n  order = 0x4949;\n  fread (tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp)+7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  } else if (!memcmp(tag,\"nctg\",4)) {\n    while (ftell(ifp)+7 < end) {\n      i = get2();\n      size = get2();\n      if ((i+1) >> 1 == 10 && size == 20)\n\tget_timestamp(0);\n      else fseek (ifp, size, SEEK_CUR);\n    }\n  } else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n    fread (date, 64, 1, ifp);\n    date[size] = 0;\n    memset (&t, 0, sizeof t);\n    if (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n\ttimestamp = mktime(&t);\n    }\n  } else\n    fseek (ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal (int offset, int fsize)\n{\n  int ver;\n\n  fseek (ifp, offset+2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek (ifp, 5, SEEK_CUR);\n  if (get4() != fsize) return;\n  if (ver > 6) data_offset = get4();\n  raw_height = height = get2();\n  raw_width  = width  = get2();\n  strcpy (make, \"SMaL\");\n  sprintf (model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek (ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek (ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4())) timestamp = i;\n  fseek (ifp, off_head+4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(),get2()) {\n    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;\n    case 16:  load_raw = &CLASS  unpacked_load_raw;\n  }\n  fseek (ifp, off_setup+792, SEEK_SET);\n  strcpy (make, \"CINE\");\n  sprintf (model, \"%d\", get4());\n  fseek (ifp, 12, SEEK_CUR);\n  switch ((i=get4()) & 0xffffff) {\n    case  3:  filters = 0x94949494;  break;\n    case  4:  filters = 0x49494949;  break;\n    default:  is_raw = 0;\n  }\n  fseek (ifp, 72, SEEK_CUR);\n  switch ((get4()+3600) % 360) {\n    case 270:  flip = 4;  break;\n    case 180:  flip = 1;  break;\n    case  90:  flip = 7;  break;\n    case   0:  flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek (ifp, 668, SEEK_CUR);\n  shutter = get4()/1000000000.0;\n  fseek (ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek (ifp, shot_select*8, SEEK_CUR);\n  data_offset  = (INT64) get4() + 8;\n  data_offset += (INT64) get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek (ifp, 52, SEEK_SET);\n  width  = get4();\n  height = get4();\n  fseek (ifp, 0, SEEK_END);\n  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek (ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF) {\n      if (get4() == 0x52454456)\n\tif (is_raw++ == shot_select)\n\t  data_offset = ftello(ifp) - 8;\n      fseek (ifp, len-8, SEEK_CUR);\n    }\n  } else {\n    rdvo = get4();\n    fseek (ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff (const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n\t,int internal_only\n#endif\n)\n{\n  static const struct {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0,\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0, \n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp, same as sd Quattro */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if(colors>4 || colors < 1) return;\n\n  int bl4=(cblack[0]+cblack[1]+cblack[2]+cblack[3])/4,bl64=0;\n  if(cblack[4]*cblack[5]>0)\n  {\n\t  for (unsigned c = 0; c < 4096 && c < cblack[4]*cblack[5]; c++)\n\t\t  bl64+=cblack[c+6];\n\t  bl64 /= cblack[4]*cblack[5];\n  }\n  int rblack  = black+bl4+bl64;\n\n  sprintf (name, \"%s %s\", t_make, t_model);\n  for (i=0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix))) {\n      if(!dng_version)\n\t{\n\t  if (table[i].t_black>0)\n\t    {\n\t      black   = (ushort) table[i].t_black;\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  else if(table[i].t_black <0 && rblack == 0 )\n\t    {\n\t      black   = (ushort) (-table[i].t_black);\n\t      memset(cblack,0,sizeof(cblack));\n\t    }\n\t  if (table[i].t_maximum)\n\t      maximum = (ushort) table[i].t_maximum;\n\t}\n      if (table[i].trans[0]) {\n\tfor (raw_color = j=0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n\t\tif(internal_only)\n\t\t\timgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n\t\telse\n                  imgdata.color.cam_xyz[0][j] =\n#endif\n                    ((double*)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif(!internal_only)\n#endif\n          cam_xyz_coeff (rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff (int index)\n{\n  static const float table[][12] = {\n  /* index 0 -- all Foveon cameras */\n  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },\n  /* index 1 -- Kodak DC20 and DC25 */\n  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },\n  /* index 2 -- Logitech Fotoman Pixtura */\n  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },\n  /* index 3 -- Nikon E880, E900, and E990 */\n  { -1.936280,  1.800443, -1.448486,  2.584324,\n     1.405365, -0.524955, -0.289090,  0.408680,\n    -1.204965,  1.082304,  2.941367, -1.818705 }\n  };\n  int i, c;\n\n  for (raw_color = i=0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i*colors+c];\n}\n\nshort CLASS guess_byte_order (int words)\n{\n  uchar test[4][2];\n  int t=2, msb;\n  double diff, sum[2] = {0,0};\n\n  fread (test[0], 2, 2, ifp);\n  for (words-=2; words--; ) {\n    fread (test[t], 2, 1, ifp);\n    for (msb=0; msb < 2; msb++) {\n      diff = (test[t^2][msb] << 8 | test[t^2][!msb])\n\t   - (test[t  ][msb] << 8 | test[t  ][!msb]);\n      sum[msb] += diff*diff;\n    }\n    t = (t+1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green (int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf=0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[]={0,0};\n\n  FORC(2) {\n    fseek (ifp, c ? off1:off0, SEEK_SET);\n    for (vbits=col=0; col < width; col++) {\n      for (vbits -= bps; vbits < 0; vbits += bite) {\n\tbitbuf <<= bite;\n\tfor (i=0; i < bite; i+=8)\n\t  bitbuf |= (unsigned) (fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);\n    }\n  }\n  FORC(width-1) {\n    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);\n    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);\n  }\n  return 100 * log(sum[0]/sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if(len<1) return; // not needed, b/c sizeof of make/model is 64\n  string[len-1]=0;\n  if(len<3) return; // also not needed\n  len = strnlen(string,len-1);\n  for(int i=len-1; i>=0; i--)\n  {\n    if(isspace(string[i]))\n      string[i]=0;\n    else\n      break;\n  }\n}\n\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n    { 3130, 1743,  4,  0, -6,  0 },\n    { 3130, 2055,  4,  0, -6,  0 },\n    { 3130, 2319,  4,  0, -6,  0 },\n    { 3170, 2103, 18,  0,-42, 20 },\n    { 3170, 2367, 18, 13,-42,-21 },\n    { 3177, 2367,  0,  0, -1,  0 },\n    { 3304, 2458,  0,  0, -1,  0 },\n    { 3330, 2463,  9,  0, -5,  0 },\n    { 3330, 2479,  9,  0,-17,  4 },\n    { 3370, 1899, 15,  0,-44, 20 },\n    { 3370, 2235, 15,  0,-44, 20 },\n    { 3370, 2511, 15, 10,-44,-21 },\n    { 3690, 2751,  3,  0, -8, -3 },\n    { 3710, 2751,  0,  0, -3,  0 },\n    { 3724, 2450,  0,  0,  0, -2 },\n    { 3770, 2487, 17,  0,-44, 19 },\n    { 3770, 2799, 17, 15,-44,-19 },\n    { 3880, 2170,  6,  0, -6,  0 },\n    { 4060, 3018,  0,  0,  0, -2 },\n    { 4290, 2391,  3,  0, -8, -1 },\n    { 4330, 2439, 17, 15,-44,-19 },\n    { 4508, 2962,  0,  0, -3, -4 },\n    { 4508, 3330,  0,  0, -3, -6 },\n  };\n  static const ushort canon[][11] = {\n    { 1944, 1416,   0,  0, 48,  0 },\n    { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },\n    { 2224, 1456,  48,  6,  0,  2 },\n    { 2376, 1728,  12,  6, 52,  2 },\n    { 2672, 1968,  12,  6, 44,  2 },\n    { 3152, 2068,  64, 12,  0,  0, 16 },\n    { 3160, 2344,  44, 12,  4,  4 },\n    { 3344, 2484,   4,  6, 52,  6 },\n    { 3516, 2328,  42, 14,  0,  0 },\n    { 3596, 2360,  74, 12,  0,  0 },\n    { 3744, 2784,  52, 12,  8, 12 },\n    { 3944, 2622,  30, 18,  6,  2 },\n    { 3948, 2622,  42, 18,  0,  2 },\n    { 3984, 2622,  76, 20,  0,  2, 14 },\n    { 4104, 3048,  48, 12, 24, 12 },\n    { 4116, 2178,   4,  2,  0,  0 },\n    { 4152, 2772, 192, 12,  0,  0 },\n    { 4160, 3124, 104, 11,  8, 65 },\n    { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },\n    { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },\n    { 4312, 2876,  22, 18,  0,  2 },\n    { 4352, 2874,  62, 18,  0,  0 },\n    { 4476, 2954,  90, 34,  0,  0 },\n    { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },\n    { 4480, 3366,  80, 50,  0,  0 },\n    { 4496, 3366,  80, 50, 12,  0 },\n    { 4768, 3516,  96, 16,  0,  0, 0, 16 },\n    { 4832, 3204,  62, 26,  0,  0 },\n    { 4832, 3228,  62, 51,  0,  0 },\n    { 5108, 3349,  98, 13,  0,  0 },\n    { 5120, 3318, 142, 45, 62,  0 },\n    { 5280, 3528,  72, 52,  0,  0 },  /* EOS M */\n    { 5344, 3516, 142, 51,  0,  0 },\n    { 5344, 3584, 126,100,  0,  2 },\n    { 5360, 3516, 158, 51,  0,  0 },\n    { 5568, 3708,  72, 38,  0,  0 },\n    { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },\n    { 5712, 3774,  62, 20, 10,  2 },\n    { 5792, 3804, 158, 51,  0,  0 },\n    { 5920, 3950, 122, 80,  2,  0 },\n    { 6096, 4056, 72, 34,  0,  0 },     /* EOS M3 */\n    { 6288, 4056, 266, 36,  0,  0 },     /* EOS 80D */\n    { 6880, 4544, 136, 42,  0,  0 },     /* EOS 5D4 */\n    { 8896, 5920, 160, 64,  0,  0 },\n  };\n  static const struct {\n    ushort id;\n    char t_model[20];\n  } unique[] = {\n    { 0x001, \"EOS-1D\" },\n    { 0x167, \"EOS-1DS\" },\n    { 0x168, \"EOS 10D\" },\n    { 0x169, \"EOS-1D Mark III\" },\n    { 0x170, \"EOS 300D\" },\n    { 0x174, \"EOS-1D Mark II\" },\n    { 0x175, \"EOS 20D\" },\n    { 0x176, \"EOS 450D\" },\n    { 0x188, \"EOS-1Ds Mark II\" },\n    { 0x189, \"EOS 350D\" },\n    { 0x190, \"EOS 40D\" },\n    { 0x213, \"EOS 5D\" },\n    { 0x215, \"EOS-1Ds Mark III\" },\n    { 0x218, \"EOS 5D Mark II\" },\n    { 0x232, \"EOS-1D Mark II N\" },\n    { 0x234, \"EOS 30D\" },\n    { 0x236, \"EOS 400D\" },\n    { 0x250, \"EOS 7D\" },\n    { 0x252, \"EOS 500D\" },\n    { 0x254, \"EOS 1000D\" },\n    { 0x261, \"EOS 50D\" },\n    { 0x269, \"EOS-1D X\" },\n    { 0x270, \"EOS 550D\" },\n    { 0x281, \"EOS-1D Mark IV\" },\n    { 0x285, \"EOS 5D Mark III\" },\n    { 0x286, \"EOS 600D\" },\n    { 0x287, \"EOS 60D\" },\n    { 0x288, \"EOS 1100D\" },\n    { 0x289, \"EOS 7D Mark II\" },\n    { 0x301, \"EOS 650D\" },\n    { 0x302, \"EOS 6D\" },\n    { 0x324, \"EOS-1D C\" },\n    { 0x325, \"EOS 70D\" },\n    { 0x326, \"EOS 700D\" },\n    { 0x327, \"EOS 1200D\" },\n    { 0x328, \"EOS-1D X Mark II\" },\n    { 0x331, \"EOS M\" },\n    { 0x335, \"EOS M2\" },\n    { 0x374, \"EOS M3\"},   /* temp */\n    { 0x384, \"EOS M10\"},  /* temp */\n    { 0x394, \"EOS M5\"},   /* temp */\n    { 0x346, \"EOS 100D\" },\n    { 0x347, \"EOS 760D\" },\n    { 0x349, \"EOS 5D Mark IV\" },\n    { 0x350, \"EOS 80D\"},\n    { 0x382, \"EOS 5DS\" },\n    { 0x393, \"EOS 750D\" },\n    { 0x401, \"EOS 5DS R\" },\n    { 0x404, \"EOS 1300D\" },\n  }, sonique[] = {\n    { 0x002, \"DSC-R1\" },\n    { 0x100, \"DSLR-A100\" },\n    { 0x101, \"DSLR-A900\" },\n    { 0x102, \"DSLR-A700\" },\n    { 0x103, \"DSLR-A200\" },\n    { 0x104, \"DSLR-A350\" },\n    { 0x105, \"DSLR-A300\" },\n    { 0x106, \"DSLR-A900\" },\n    { 0x107, \"DSLR-A380\" },\n    { 0x108, \"DSLR-A330\" },\n    { 0x109, \"DSLR-A230\" },\n    { 0x10a, \"DSLR-A290\" },\n    { 0x10d, \"DSLR-A850\" },\n    { 0x10e, \"DSLR-A850\" },\n    { 0x111, \"DSLR-A550\" },\n    { 0x112, \"DSLR-A500\" },\n    { 0x113, \"DSLR-A450\" },\n    { 0x116, \"NEX-5\" },\n    { 0x117, \"NEX-3\" },\n    { 0x118, \"SLT-A33\" },\n    { 0x119, \"SLT-A55V\" },\n    { 0x11a, \"DSLR-A560\" },\n    { 0x11b, \"DSLR-A580\" },\n    { 0x11c, \"NEX-C3\" },\n    { 0x11d, \"SLT-A35\" },\n    { 0x11e, \"SLT-A65V\" },\n    { 0x11f, \"SLT-A77V\" },\n    { 0x120, \"NEX-5N\" },\n    { 0x121, \"NEX-7\" },\n    { 0x122, \"NEX-VG20E\"},\n    { 0x123, \"SLT-A37\" },\n    { 0x124, \"SLT-A57\" },\n    { 0x125, \"NEX-F3\" },\n    { 0x126, \"SLT-A99V\" },\n    { 0x127, \"NEX-6\" },\n    { 0x128, \"NEX-5R\" },\n    { 0x129, \"DSC-RX100\" },\n    { 0x12a, \"DSC-RX1\" },\n    { 0x12b, \"NEX-VG900\" },\n    { 0x12c, \"NEX-VG30E\" },\n    { 0x12e, \"ILCE-3000\" },\n    { 0x12f, \"SLT-A58\" },\n    { 0x131, \"NEX-3N\" },\n    { 0x132, \"ILCE-7\" },\n    { 0x133, \"NEX-5T\" },\n    { 0x134, \"DSC-RX100M2\" },\n    { 0x135, \"DSC-RX10\" },\n    { 0x136, \"DSC-RX1R\" },\n    { 0x137, \"ILCE-7R\" },\n    { 0x138, \"ILCE-6000\" },\n    { 0x139, \"ILCE-5000\" },\n    { 0x13d, \"DSC-RX100M3\" },\n    { 0x13e, \"ILCE-7S\" },\n    { 0x13f, \"ILCA-77M2\" },\n    { 0x153, \"ILCE-5100\" },\n    { 0x154, \"ILCE-7M2\" },\n    { 0x155, \"DSC-RX100M4\" },\n    { 0x156, \"DSC-RX10M2\" },\n    { 0x158, \"DSC-RX1RM2\" },\n    { 0x15a, \"ILCE-QX1\" },\n    { 0x15b, \"ILCE-7RM2\" },\n    { 0x15e, \"ILCE-7SM2\" },\n    { 0x161, \"ILCA-68\" },\n    { 0x162, \"ILCA-99M2\" },\n    { 0x163, \"DSC-RX10M3\" },\n    { 0x164, \"DSC-RX100M5\"},\n    { 0x165, \"ILCE-6300\" },\n    { 0x168, \"ILCE-6500\"},\n  };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t\n    const_table[]\n#else\n  static const struct {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  }\n  table[]\n#endif\n   = {\n    {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-080C\" },\n    {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-145C\" },\n    {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-201C\" },\n    {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\" },\n    {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\" },\n    { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-510C\",12 },\n    { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,\"AVT\",\"F-810C\" },\n    { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,\"AgfaPhoto\",\"DC-833m\" },\n    {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,\"Alcatel\",\"5035D\" },\n    {  31850496,4608,3456, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 4:3\" },\n    {  23887872,4608,2592, 0, 0, 0, 0,0,0x94,0,0,\"GITUP\",\"GIT2 16:9\" },\n//   Android Raw dumps id start\n//   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n    {  1540857,2688,1520, 0, 0, 0, 0, 1,0x61,0,0,\"Samsung\",\"S3\" },\n    {  2658304,1212,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontMipi\" },\n    {  2842624,1296,1096, 0, 0, 0, 0, 1 ,0x16,0,0,\"LG\",\"G3FrontQCOM\" },\n    {  2969600,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wMipi\" },\n    {  3170304,1976,1200, 0, 0, 0, 0, 1 ,0x16,0,0,\"Xiaomi\",\"MI3wQCOM\" },\n    {  3763584,1584,1184, 0, 0, 0, 0, 96,0x61,0,0,\"I_Mobile\",\"I_StyleQ6\" },\n    {  5107712,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel1\" },\n    {  5382640,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"UltraPixel2\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5664912,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  5364240,2688,1520, 0, 0, 0, 0, 1 ,0x61,0,0,\"OmniVisi\",\"4688\" },\n    {  6299648,2592,1944, 0, 0, 0, 0, 1 ,0x16,0,0,\"OmniVisi\",\"OV5648\" },\n    {  6721536,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"OmniVisi\",\"OV56482\" },\n    {  6746112,2592,1944, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"OneSV\" },\n    {  9631728,2532,1902, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"5mp\" },\n    {  9830400,2560,1920, 0, 0, 0, 0, 96,0x61,0,0,\"NGM\",\"ForwardArt\" },\n    { 10186752,3264,2448, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX219-mipi 8mp\" },\n    { 10223360,2608,1944, 0, 0, 0, 0, 96,0x16,0,0,\"Sony\",\"IMX\" },\n    { 10782464,3282,2448, 0, 0, 0, 0, 0 ,0x16,0,0,\"HTC\",\"MyTouch4GSlide\" },\n    { 10788864,3282,2448, 0, 0, 0, 0, 0, 0x16,0,0,\"Xperia\",\"L\" },\n    { 15967488,3264,2446, 0, 0, 0, 0, 96,0x16,0,0,\"OmniVison\",\"OV8850\" },\n    { 16224256,4208,3082, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3MipiL\" },\n    { 16424960,4208,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"IMX135\",\"MipiL\" },\n    { 17326080,4164,3120, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G3LQCom\" },\n    { 17522688,4212,3120, 0, 0, 0, 0, 0,0x16,0,0,\"Sony\",\"IMX135-QCOM\" },\n    { 19906560,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7mipi\" },\n    { 19976192,5312,2988, 0, 0, 0, 0, 1, 0x16,0,0,\"LG\",\"G4\" },\n    { 20389888,4632,3480, 0, 0, 0, 0, 1, 0x16,0,0,\"Xiaomi\",\"RedmiNote3Pro\" },\n    { 20500480,4656,3496, 0, 0, 0, 0, 1,0x94,0,0,\"Sony\",\"IMX298-mipi 16mp\" },\n    { 21233664,4608,3456, 0, 0, 0, 0, 1, 0x16,0,0,\"Gione\",\"E7qcom\" },\n    { 26023936,4192,3104, 0, 0, 0, 0, 96,0x94,0,0,\"THL\",\"5000\" },\n    { 26257920,4208,3120, 0, 0, 0, 0, 96,0x94,0,0,\"Sony\",\"IMX214\" },\n    { 26357760,4224,3120, 0, 0, 0, 0, 96,0x61,0,0,\"OV\",\"13860\" },\n    { 41312256,5248,3936, 0, 0, 0, 0, 96,0x61,0,0,\"Meizu\",\"MX4\" },\n    { 42923008,5344,4016, 0, 0, 0, 0, 96,0x61,0,0,\"Sony\",\"IMX230\" },\n    //   Android Raw dumps id end\n    {  20137344,3664,2748,0, 0, 0, 0,0x40,0x49,0,0,\"Aptina\",\"MT9J003\",0xffff },\n    {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,\"Baumer\",\"TXG14\",1078 },\n    {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,\"Canon\",\"PowerShot SD300\" },\n    {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,\"Canon\",\"PowerShot A460\" },\n    {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,\"Canon\",\"PowerShot A610\" },\n    {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,\"Canon\",\"PowerShot A530\" },\n    {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot S3 IS\" },\n    {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,\"Canon\",\"PowerShot A620\" },\n    {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,\"Canon\",\"PowerShot A470\" },\n    { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,\"Canon\",\"PowerShot A720 IS\" },\n    { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,\"Canon\",\"PowerShot A630\" },\n    { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,\"Canon\",\"PowerShot A640\" },\n    { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot A650\" },\n    { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,\"Canon\",\"PowerShot SX110 IS\" },\n    { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,\"Canon\",\"PowerShot SX120 IS\" },\n    { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,\"Canon\",\"PowerShot SX20 IS\" },\n    { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,\"Canon\",\"PowerShot SX220 HS\" },\n    { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,\"Canon\",\"PowerShot SX30 IS\" },\n    { 24724224,4704,3504, 8,16,56, 8,40,0x49,0,2,\"Canon\",\"PowerShot A3300 IS\" },\n    { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,\"Canon\",\"IXUS 160\" },\n    {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,\"Casio\",\"QV-2000UX\" },\n    {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,\"Casio\",\"QV-3*00EX\" },\n    {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,\"Casio\",\"QV-5700\" },\n    {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,\"Casio\",\"EX-Z60\" },\n    {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,\"Casio\",\"EX-S20\" },\n    {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,\"Casio\",\"EX-S100\" },\n    {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,\"Casio\",\"QV-R41\" },\n    {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,\"Casio\",\"EX-P505\" },\n    {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,\"Casio\",\"QV-R51\" },\n    {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,\"Casio\",\"EX-Z50\" },\n    {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,\"Casio\",\"EX-Z500\" },\n    {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,\"Casio\",\"EX-Z55\" },\n    {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,\"Casio\",\"EX-P600\" },\n    { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,\"Casio\",\"EX-Z750\" },\n    { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,\"Casio\",\"EX-Z75\" },\n    { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,\"Casio\",\"EX-P700\" },\n    { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,\"Casio\",\"EX-Z850\" },\n    { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,\"Casio\",\"EX-Z8\" },\n    { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,\"Casio\",\"EX-Z1050\" },\n    { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,\"Casio\",\"EX-ZR100\" },\n    {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,\"Casio\",\"QV-4000\" },\n    {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,\"Creative\",\"PC-CAM 600\" },\n    { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,\"DJI\" },\n    { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,\"Matrix\" },\n    {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,\"Foculus\",\"531C\" },\n    {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,\"Generic\" },\n    {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,\"Kodak\",\"DC20\" },\n    {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,\"Kodak\",\"DCS200\" },\n    {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\" },\n    {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,\"Kodak\",\"C330\",3160 },\n    {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,\"Kodak\",\"C330\" },\n    {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\" },\n    {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,\"Kodak\",\"C603\",3160 },\n    {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"C603\" },\n    { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\" },\n    { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,\"Kodak\",\"12MP\",31556 },\n    { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,\"Kodak\",\"12MP\" },\n    {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,\"Kodak\",\"KAI-0340\" },\n    { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,\"Lenovo\",\"A820\" },\n    {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,\"Micron\",\"2010\",3212 },\n    {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,\"Minolta\",\"RD175\",513 },\n    {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,\"Nikon\",\"E900\" },\n    {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,\"Nikon\",\"E950\" },\n    {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,\"Nikon\",\"E2100\" },\n    {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,\"Nikon\",\"E990\" },\n    {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,\"Nikon\",\"E3700\" },\n    {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E4500\" },\n    {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,\"Nikon\",\"E4300\" },\n    {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,\"Nikon\",\"E5000\" },\n    {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,\"Nikon\",\"COOLPIX S6\" },\n    {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,\"Olympus\",\"C770UZ\" },\n    {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,\"Pentax\",\"Optio S\" },\n    {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S\" },\n    {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,\"Pentax\",\"Optio S4\" },\n    { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,\"Pentax\",\"Optio 750Z\" },\n    {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\" },\n    {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,\"Photron\",\"BC2-HD\",8 },\n    { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,\"Pixelink\",\"A782\" },\n    {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,\"RoverShot\",\"3320AF\" },\n    {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,\"ST Micro\",\"STV680 VGA\" },\n    { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,\"Samsung\",\"S85\" },\n    { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,\"Samsung\",\"WB550\" },\n    { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,\"Sinar\",\"\",68 },\n    {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n    {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,\"Sony\",\"XCD-SX910CR\" },\n  };\n#ifdef LIBRAW_LIBRARY_BUILD\n    libraw_custom_camera_t\n      table[64 + sizeof(const_table)/sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] =\n    { \"AgfaPhoto\", \"Canon\", \"Casio\", \"Epson\", \"Fujifilm\",\n      \"Mamiya\", \"Minolta\", \"Motorola\", \"Kodak\", \"Konica\", \"Leica\",\n      \"Nikon\", \"Nokia\", \"Olympus\", \"Pentax\", \"Phase One\", \"Ricoh\",\n      \"Samsung\", \"Sigma\", \"Sinar\", \"Sony\" };\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize=1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64,table,imgdata.params.custom_camera_strings);\n  for(int q = 0; q < sizeof(const_table)/sizeof(const_table[0]); q++)\n\tmemmove(&table[q+camera_count],&const_table[q],sizeof(const_table[0]));\n  camera_count += sizeof(const_table)/sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX;\t/* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset (tiff_ifd, 0, sizeof tiff_ifd);\n  memset (gpsdata, 0, sizeof gpsdata);\n  memset (cblack, 0, sizeof cblack);\n  memset (white, 0, sizeof white);\n  memset (mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n\n  for (i=0; i < 4; i++) {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i=0; i < 0x10000; i++) curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek (ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread (head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread (head, 1, 32, ifp);\n#endif\n  fseek (ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *) memmem (head, 32, (char*)\"MMMM\", 4)) ||\n      (cp = (char *) memmem (head, 32, (char*)\"IIII\", 4))) {\n    parse_phase_one (cp-head);\n    if (cp-head && parse_tiff(0)) apply_tiff();\n  } else if (order == 0x4949 || order == 0x4d4d) {\n    if (!memcmp (head+6,\"HEAPCCDR\",8)) {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff (hlen, flen-hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    } else if (parse_tiff(0)) apply_tiff();\n  } else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\n\t     !memcmp (head+6,\"Exif\",4)) {\n    fseek (ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek (ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  } else if (!memcmp (head+25,\"ARECOYK\",7)) {\n    strcpy (make, \"Contax\");\n    strcpy (model,\"N Digital\");\n    fseek (ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek (ifp, 52, SEEK_SET);\n    switch (get4()) {\n      case  7: iso_speed = 25;  break;\n      case  8: iso_speed = 32;  break;\n      case  9: iso_speed = 40;  break;\n      case 10: iso_speed = 50;  break;\n      case 11: iso_speed = 64;  break;\n      case 12: iso_speed = 80;  break;\n      case 13: iso_speed = 100; break;\n      case 14: iso_speed = 125; break;\n      case 15: iso_speed = 160; break;\n      case 16: iso_speed = 200; break;\n      case 17: iso_speed = 250; break;\n      case 18: iso_speed = 320; break;\n      case 19: iso_speed = 400; break;\n    }\n    shutter = powf64(2.0f, (((float)get4())/8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek (ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek (ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4())/16.0f);\n    fseek (ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  } else if (!strcmp (head, \"PXN\")) {\n    strcpy (make, \"Logitech\");\n    strcpy (model,\"Fotoman Pixtura\");\n  } else if (!strcmp (head, \"qktk\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  } else if (!strcmp (head, \"qktn\")) {\n    strcpy (make, \"Apple\");\n    strcpy (model,\"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  } else if (!memcmp (head,\"FUJIFILM\",8)) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head+0x1c);\n    memcpy(model2, head+0x3c, 4);\n    model2[4]=0;\n#endif\n    fseek (ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek (ifp, 92, SEEK_SET);\n    parse_fuji (get4());\n    if (thumb_offset > 120) {\n      fseek (ifp, 120, SEEK_SET);\n      is_raw += (i = get4())?1:0;\n      if (is_raw == 2 && shot_select)\n\tparse_fuji (i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);\n    parse_tiff (data_offset = get4());\n    parse_tiff (thumb_offset+12);\n    apply_tiff();\n  } else if (!memcmp (head,\"RIFF\",4)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_riff();\n  } else if (!memcmp (head+4,\"ftypqt   \",9)) {\n    fseek (ifp, 0, SEEK_SET);\n    parse_qt (fsize);\n    is_raw = 0;\n  } else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\n    fseek (ifp, 6, SEEK_SET);\n    fread (make, 1, 8, ifp);\n    fread (model, 1, 8, ifp);\n    fread (model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"NOKIARAW\",8)) {\n    strcpy (make, \"NOKIA\");\n    order = 0x4949;\n    fseek (ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i*8 / (width * height)) {\n      case  8: load_raw = &CLASS eight_bit_load_raw;  break;\n      case 10: load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"ARRI\",4)) {\n    order = 0x4949;\n    fseek (ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy (make, \"ARRI\");\n    fseek (ifp, 668, SEEK_SET);\n    fread (model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  } else if (!memcmp (head,\"XPDS\",4)) {\n    order = 0x4949;\n    fseek (ifp, 0x800, SEEK_SET);\n    fread (make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width  = get2();\n    fseek (ifp, 56, SEEK_CUR);\n    fread (model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve (0, 12.25, 1, 1023);\n  } else if (!memcmp (head+4,\"RED1\",4)) {\n    strcpy (make, \"Red\");\n    strcpy (model,\"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve (1/2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  } else if (!memcmp (head,\"DSC-Image\",9))\n    parse_rollei();\n  else if (!memcmp (head,\"PWAD\",4))\n    parse_sinar_ia();\n  else if (!memcmp (head,\"\\0MRM\",4))\n    parse_minolta(0);\n  else if (!memcmp (head,\"FOVb\",4))\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n        parse_foveon();\n      else\n#endif\n        parse_x3f();\n#else\n#ifdef  LIBRAW_DEMOSAIC_PACK_GPL2\n      parse_foveon();\n#endif\n#endif\n    }\n  else if (!memcmp (head,\"CI\",2))\n    parse_cine();\n  if(make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize=i=0; i < camera_count; i++)\n#else\n    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize) {\n\tstrcpy (make,  table[i].t_make );\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\",5))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n            imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          }\n#endif\n\tstrcpy (model, table[i].t_model);\n\tflip = table[i].flags >> 2;\n\tzero_is_bad = table[i].flags & 2;\n\tif (table[i].flags & 1)\n\t  parse_external_jpeg();\n\tdata_offset = table[i].offset == 0xffff?0:table[i].offset;\n\traw_width   = table[i].rw;\n\traw_height  = table[i].rh;\n\tleft_margin = table[i].lm;\n\t top_margin = table[i].tm;\n\twidth  = raw_width - left_margin - table[i].rm;\n\theight = raw_height - top_margin - table[i].bm;\n\tfilters = 0x1010101 * table[i].cf;\n\tcolors = 4 - !((filters & filters >> 1) & 0x5555);\n\tload_flags = table[i].lf;\n\tswitch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {\n\t  case 6:\n\t    load_raw = &CLASS minolta_rd175_load_raw;  break;\n\t  case 8:\n\t    load_raw = &CLASS eight_bit_load_raw;  break;\n\t  case 10:\n           if ((fsize-data_offset)/raw_height*3 >= raw_width*4) {\n             load_raw = &CLASS android_loose_load_raw;  break;\n           } else if (load_flags & 1) {\n             load_raw = &CLASS android_tight_load_raw;  break;\n           }\n\t  case 12:\n\t    load_flags |= 128;\n\t    load_raw = &CLASS packed_load_raw;     break;\n\t  case 16:\n\t    order = 0x4949 | 0x404 * (load_flags & 1);\n\t    tiff_bps -= load_flags >> 4;\n\t    tiff_bps -= load_flags = load_flags >> 1 & 7;\n\t    load_raw = table[i].offset == 0xffff ? &CLASS  unpacked_load_raw_reversed : &CLASS  unpacked_load_raw;\n\t}\n\tmaximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize) fsize = 0;\n  if (make[0] == 0) parse_smal (0, flen);\n  if (make[0] == 0) {\n    parse_jpeg(0);\n    fseek(ifp,0,SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model,\"RP_imx219\",9) && sz >= 0x9cb600 &&\n        !fseek (ifp, -0x9cb600, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n\tstrcpy (make, \"Broadcom\");\n\tstrcpy (model, \"RPi IMX219\");\n\tif (raw_height > raw_width) flip = 5;\n\tdata_offset = ftell(ifp) + 0x8000 - 0x20;\n\tparse_broadcom();\n\tblack = 66;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    } else\n      if (!(strncmp(model,\"ov5647\",6) && strncmp(model,\"RP_OV5647\",9)) && sz >= 0x61b800 &&\n        !fseek (ifp, -0x61b800, SEEK_END) &&\n\t  fread (head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4)) {\n      strcpy (make, \"Broadcom\");\n      if (!strncmp(model,\"ov5647\",6))\n        strcpy (model, \"RPi OV5647 v.1\");\n      else\n        strcpy (model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width) flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n\tblack = 16;\n\tmaximum = 0x3ff;\n\tload_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model,\"ov\",2) && strncmp(model,\"RP_OV\",5)) && sz>=6404096 &&\n        !fseek (ifp, -6404096, SEEK_END) &&\n\t  fread (head, 1, 32, ifp) && !strcmp(head,\"BRCMn\")) {\n      strcpy (make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000-32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    } else is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i=0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr (make, corp[i]))\t/* Simplify company names */\n\t    strcpy (make, corp[i]);\n  if ((!strncmp(make,\"Kodak\",5) || !strncmp(make,\"Leica\",5)) &&\n\t((cp = strcasestr(model,\" DIGITAL CAMERA\")) ||\n\t (cp = strstr(model,\"FILE VERSION\"))))\n     *cp = 0;\n  if (!strncasecmp(model,\"PENTAX\",6))\n    strcpy (make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make,sizeof(make));\n  remove_trailing_spaces(model,sizeof(model));\n#else\n  cp = make + strlen(make);\t\t/* Remove trailing spaces */\n  while (*--cp == ' ') *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ') *cp = 0;\n#endif\n  i = strbuflen(make);\t\t\t/* Remove make from model */\n  if (!strncasecmp (model, make, i) && model[i++] == ' ')\n    memmove (model, model+i, 64-i);\n  if (!strncmp (model,\"FinePix \",8))\n    strcpy (model, model+8);\n  if (!strncmp (model,\"Digital Camera \",15))\n    strcpy (model, model+15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw) goto notraw;\n\n  if (!height) height = raw_height;\n  if (!width)  width  = raw_width;\n  if (height == 2624 && width == 3936)\t/* Pentax K10D and Samsung GX10 */\n    { height  = 2616;   width  = 3896; }\n  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */\n    { height  = 3124;   width  = 4688; filters = 0x16161616; }\n  if (width == 4352 && (!strcmp(model,\"K-r\") || !strcmp(model,\"K-x\")))\n    {\t\t\twidth  = 4309; filters = 0x16161616; }\n  if (width >= 4960 && !strncmp(model,\"K-5\",3))\n    { left_margin = 10; width  = 4950; filters = 0x16161616; }\n  if (width == 6080 && !strcmp(model,\"K-70\"))\n     { height  = 4016; top_margin=32; width=6020; left_margin = 60; }\n  if (width == 4736 && !strcmp(model,\"K-7\"))\n    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }\n  if (width == 6080 && !strcmp(model,\"K-3 II\")) /* moved back */\n    { left_margin = 4;  width  = 6040; }\n  if (width == 6080 && !strcmp(model,\"K-3\"))\n    { left_margin = 4;  width  = 6040; }\n  if (width == 7424 && !strcmp(model,\"645D\"))\n    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;\n      left_margin = 48; }\n  if (height == 3014 && width == 4096)\t/* Ricoh GX200 */\n\t\t\twidth  = 4014;\n  if (dng_version) {\n    if (filters == UINT_MAX) filters = 0;\n    if (filters) is_raw *= tiff_samples;\n    else\t colors  = tiff_samples;\n    switch (tiff_compress) {\n      case 0:  /* Compression not set, assuming uncompressed */\n      case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;\n      case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 8:     load_raw = &CLASS  deflate_dng_load_raw;  break;\n#endif\n      case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;\n      default:    load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\",5) && unique_id)\n      {\n        for (i = 0; i < sizeof unique / sizeof *unique; i++)\n          if (unique_id == 0x80000000 + unique[i].id)\n            {\n              strcpy(model, unique[i].t_model);\n              break;\n            }\n      }\n    if (!strncasecmp(make, \"Sony\",4) && unique_id)\n      {\n        for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n          if (unique_id == sonique[i].id)\n            {\n              strcpy(model, sonique[i].t_model);\n              break;\n            }\n      }\n    goto dng_skip;\n  }\n  if (!strncmp(make,\"Canon\",5) && !fsize && tiff_bps != 15) {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i=0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1]) {\n\twidth  = raw_width - (left_margin = canon[i][2]);\n\theight = raw_height - (top_margin = canon[i][3]);\n\twidth  -= canon[i][4];\n\theight -= canon[i][5];\n\tmask[0][1] =  canon[i][6];\n\tmask[0][3] = -canon[i][7];\n\tmask[1][1] =  canon[i][8];\n\tmask[1][3] = -canon[i][9];\n\tif (canon[i][10]) filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000) {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make,\"Canon\",5) && unique_id)\n    {\n      for (i=0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n          {\n            adobe_coeff (\"Canon\", unique[i].t_model);\n            strcpy(model,unique[i].t_model);\n          }\n    }\n\n  if (!strncasecmp(make,\"Sony\",4) && unique_id)\n    {\n      for (i=0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n          {\n            adobe_coeff (\"Sony\", sonique[i].t_model);\n            strcpy(model,sonique[i].t_model);\n          }\n    }\n\n  if (!strncmp(make,\"Nikon\",5)) {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n/* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model,\"KAI-0340\")\n\t&& find_green (16, 16, 3840, 5120) < 25) {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy (model,\"C603\");\n  }\n\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n\n  if (is_foveon) {\n    if (height*2 < width) pixel_aspect = 0.5;\n    if (height   > width) pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if(!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if(!strncmp(make,\"Pentax\",6))\n  {\n    if(!strncmp(model,\"K-1\",3))\n    {\n  \ttop_margin = 18;\n \theight = raw_height - top_margin;\n\tif(raw_width == 7392)\n\t{\n\t  left_margin = 6;\n\t  width = 7376;\n\t}\n    }\n  }\n  else if (!strncmp(make,\"Canon\",5) && tiff_bps == 15) {\n    switch (width) {\n      case 3344: width -= 66;\n      case 3872: width -= 6;\n    }\n    if (height > width) {\n      SWAP(height,width);\n      SWAP(raw_height,raw_width);\n    }\n    if (width == 7200 && height == 3888)\n      {\n\traw_width  = width  = 6480;\n\traw_height = height = 4320;\n      }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  } else if (!strcmp(model,\"PowerShot 600\")) {\n    height = 613;\n    width  = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  } else if (!strcmp(model,\"PowerShot A5\") ||\n\t     !strcmp(model,\"PowerShot A5 Zoom\")) {\n    height = 773;\n    width  = 960;\n    raw_width = 992;\n    pixel_aspect = 256/235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot A50\")) {\n    height =  968;\n    width  = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  } else if (!strcmp(model,\"PowerShot Pro70\")) {\n    height = 1024;\n    width  = 1552;\n    filters = 0x1e4b4e1b;\ncanon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  } else if (!strcmp(model,\"PowerShot Pro90 IS\") ||\n\t     !strcmp(model,\"PowerShot G1\")) {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  } else if (!strcmp(model,\"PowerShot A610\")) {\n    if (canon_s2is()) strcpy (model+10, \"S2 IS\");\n  } else if (!strcmp(model,\"PowerShot SX220 HS\")) {\n    mask[1][3] = -4;\n    top_margin=16;\n    left_margin = 92;\n  } else if (!strcmp(model,\"PowerShot S120\")) {\n        raw_width = 4192;\n        raw_height = 3062;\n        width = 4022;\n        height = 3016;\n        mask[0][0] = top_margin = 31;\n        mask[0][2] = top_margin + height;\n        left_margin = 120;\n        mask[0][1] = 23;\n        mask[0][3] = 72;\n  } else if (!strcmp(model,\"PowerShot G16\")) {\n      mask[0][0] = 0;\n      mask[0][2] = 80;\n      mask[0][1] = 0;\n      mask[0][3] = 16;\n      top_margin = 29;\n      left_margin = 120;\n      width = raw_width-left_margin-48;\n      height = raw_height-top_margin-14;\n  } else if (!strcmp(model,\"PowerShot SX50 HS\")) {\n    top_margin = 17;\n  } else if (!strcmp(model,\"EOS D2000C\")) {\n    filters = 0x61616161;\n    black = curve[200];\n  } else if (!strcmp(model,\"D1\")) {\n    cam_mul[0] *= 256/527.0;\n    cam_mul[2] *= 256/317.0;\n  } else if (!strcmp(model,\"D1X\")) {\n    width -= 4;\n    pixel_aspect = 0.5;\n  } else if (!strcmp(model,\"D40X\") ||\n\t     !strcmp(model,\"D60\")  ||\n\t     !strcmp(model,\"D80\")  ||\n\t     !strcmp(model,\"D3000\")) {\n    height -= 3;\n    width  -= 4;\n  } else if (!strcmp(model,\"D3\")   ||\n\t     !strcmp(model,\"D3S\")  ||\n\t     !strcmp(model,\"D700\")) {\n    width -= 4;\n    left_margin = 2;\n  } else if (!strcmp(model,\"D3100\")) {\n    width -= 28;\n    left_margin = 6;\n  } else if (!strcmp(model,\"D5000\") ||\n\t     !strcmp(model,\"D90\")) {\n    width -= 42;\n  } else if (!strcmp(model,\"D5100\") ||\n\t     !strcmp(model,\"D7000\") ||\n\t     !strcmp(model,\"COOLPIX A\")) {\n    width -= 44;\n  } else if (!strcmp(model,\"D3200\") ||\n\t    !strncmp(model,\"D6\",2)  ||\n\t    !strncmp(model,\"D800\",4)) {\n    width -= 46;\n  } else if (!strcmp(model,\"D4\") ||\n\t     !strcmp(model,\"Df\")) {\n    width -= 52;\n    left_margin = 2;\n  } else if (!strncmp(model,\"D40\",3) ||\n\t     !strncmp(model,\"D50\",3) ||\n\t     !strncmp(model,\"D70\",3)) {\n    width--;\n  } else if (!strcmp(model,\"D100\")) {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  } else if (!strcmp(model,\"D200\")) {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  } else if (!strncmp(model,\"D2H\",3)) {\n    left_margin = 6;\n    width -= 14;\n  } else if (!strncmp(model,\"D2X\",3)) {\n    if (width == 3264) width -= 32;\n    else width -= 8;\n  } else if (!strncmp(model,\"D300\",4)) {\n    width -= 32;\n  } else if (!strncmp(make,\"Nikon\",5) && raw_width == 4032) {\n    if(!strcmp(model,\"COOLPIX P7700\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7700\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else if(!strcmp(model,\"COOLPIX P7800\"))\n      {\n        adobe_coeff (\"Nikon\",\"COOLPIX P7800\");\n        maximum = 65504;\n        load_flags = 0;\n      }\n    else  if(!strcmp(model,\"COOLPIX P340\"))\n      load_flags=0;\n  } else if (!strncmp(model,\"COOLPIX P\",9) && raw_width != 4032) {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed==0) && !strstr(software,\"V1.2\") )\n      black = 255;\n  } else if (!strncmp(model,\"1 \",2)) {\n    height -= 2;\n  } else if (fsize == 1581060) {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  } else if (fsize == 3178560) {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  } else if (fsize == 4771840) {\n    if (!timestamp && nikon_e995())\n      strcpy (model, \"E995\");\n    if (strcmp(model,\"E995\")) {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  } else if (fsize == 2940928) {\n    if (!timestamp && !nikon_e2100())\n      strcpy (model,\"E2500\");\n    if (!strcmp(model,\"E2500\")) {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  } else if (fsize == 4775936) {\n    if (!timestamp) nikon_3700();\n    if (model[0] == 'E' && atoi(model+1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model,\"Optio 33WR\")) {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O') {\n      i = find_green (12, 32, 1188864, 3576832);\n      c = find_green (12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c)) {\n\tSWAP(i,c);\n\tload_flags = 24;\n      }\n      if (i < 0) filters = 0x61616161;\n    }\n  } else if (fsize == 5869568) {\n    if (!timestamp && minolta_z2()) {\n      strcpy (make, \"Minolta\");\n      strcpy (model,\"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24*(make[0] == 'M');\n  } else if (fsize == 6291456) {\n    fseek (ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy (make, \"ISG\");\n      model[0] = 0;\n    }\n  } else if (!strncmp(make,\"Fujifilm\",8)) {\n    if (!strcmp(model+7,\"S2Pro\")) {\n      strcpy (model,\"S2Pro\");\n      height = 2144;\n      width  = 2880;\n      flip = 6;\n    } else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width ) >> 2 << 1;\n    if (width == 2848 || width == 3664) filters = 0x16161616;\n    if (width == 4032 || width == 4952) left_margin = 0;\n    if (width == 3328 && (width -= 66)) left_margin = 34;\n    if (width == 4936) left_margin = 4;\n    if (width == 6032) left_margin = 0;\n    if (!strcmp(model,\"HS50EXR\") ||\n\t!strcmp(model,\"F900EXR\")) {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if(!strcmp(model,\"S5500\"))\n      {\n        height -= (top_margin=6);\n      }\n    if (fuji_layout) raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36) ((char *)xtrans)[c] =\n\txtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];\n  } else if (!strcmp(model,\"KD-400Z\")) {\n    height = 1712;\n    width  = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  } else if (!strcmp(model,\"KD-510Z\")) {\n    goto konica_510z;\n  } else if (!strncasecmp(make,\"Minolta\",7)) {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model,\"DiMAGE A\",8)) {\n      if (!strcmp(model,\"DiMAGE A200\"))\n\tfilters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"ALPHA\",5) ||\n\t       !strncmp(model,\"DYNAX\",5) ||\n\t       !strncmp(model,\"MAXXUM\",6)) {\n      sprintf (model+20, \"DYNAX %-10s\", model+6+(model[0]=='M'));\n      adobe_coeff (make, model+20);\n      load_raw = &CLASS packed_load_raw;\n    } else if (!strncmp(model,\"DiMAGE G\",8)) {\n      if (model[8] == '4') {\n\theight = 1716;\n\twidth  = 2304;\n      } else if (model[8] == '5') {\nkonica_510z:\n\theight = 1956;\n\twidth  = 2607;\n\traw_width = 2624;\n      } else if (model[8] == '6') {\n\theight = 2136;\n\twidth  = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\nkonica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  } else if (!strcmp(model,\"*ist D\")) {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  } else if (!strcmp(model,\"*ist DS\")) {\n    height -= 2;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 4704) {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  } else if (!strncmp(make,\"Samsung\",7) && !strcmp(model,\"NX3000\")) {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_height == 3714) {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5632) {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width  = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12) load_flags = 80;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 5664) {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  } else if (!strncmp(make,\"Samsung\",7) && raw_width == 6496) {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n    black = 1 << (tiff_bps - 7);\n  } else if (!strcmp(model,\"EX1\")) {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682) {\n      height -= 10;\n      width  -= 46;\n      top_margin = 8;\n    }\n  } else if (!strcmp(model,\"WB2000\")) {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718) {\n      height -= 28;\n      width  -= 56;\n      top_margin = 8;\n    }\n  } else if (strstr(model,\"WB550\")) {\n    strcpy (model, \"WB550\");\n  } else if (!strcmp(model,\"EX2F\")) {\n    height = 3030;\n    width  = 4040;\n    top_margin = 15;\n    left_margin=24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  } else if (!strcmp(model,\"STV680 VGA\")) {\n    black = 16;\n  } else if (!strcmp(model,\"N95\")) {\n    height = raw_height - (top_margin = 2);\n  } else if (!strcmp(model,\"640x480\")) {\n    gamma_curve (0.45, 4.5, 1, 255);\n  } else if (!strncmp(make,\"Hasselblad\",10)) {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262) {\n      height = 5444;\n      width  = 7248;\n      top_margin  = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if(!strncasecmp(model,\"H3D\",3))\n        {\n          adobe_coeff(\"Hasselblad\",\"H3DII-39\");\n          strcpy(model,\"H3DII-39\");\n        }\n    } else if (raw_width == 7410 || raw_width == 8282) {\n      height -= 84;\n      width  -= 82;\n      top_margin  = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\",\"H4D-40\");\n      strcpy(model,\"H4D-40\");\n    }\n    else if( raw_width == 8384) // X1D\n    {\n     top_margin  = 96;\n     height -= 96;\n     left_margin = 48;\n     width  -= 106;\n     adobe_coeff(\"Hasselblad\",\"X1D\");\n    }\n    else if (raw_width == 9044) {\n      if(black > 500)\n        {\n          top_margin = 12;\n          left_margin = 44;\n          width = 8956;\n          height = 6708;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H4D-60\");\n          strcpy(model,\"H4D-60\");\n          black = 512;\n        }\n      else\n        {\n          height = 6716;\n          width  = 8964;\n          top_margin  = 8;\n          left_margin = 40;\n          black += load_flags = 256;\n          maximum = 0x8101;\n          strcpy(model,\"H3DII-60\");\n        }\n    } else if (raw_width == 4090) {\n      strcpy (model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    } else if (raw_width == 8282 && raw_height == 6240) {\n      if(!strncasecmp(model,\"H5D\",3))\n        {\n          /* H5D 50*/\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          black = 256;\n          strcpy(model,\"H5D-50\");\n        }\n      else if(!strncasecmp(model,\"H3D\",3))\n        {\n          black=0;\n          left_margin = 54;\n          top_margin = 16;\n          width = 8176;\n          height = 6132;\n          memset(cblack,0,sizeof(cblack));\n          adobe_coeff(\"Hasselblad\",\"H3D-50\");\n          strcpy(model,\"H3D-50\");\n        }\n    } else if (raw_width == 8374 && raw_height == 6304) {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model,\"H5D-50c\");\n    }\n    if (tiff_samples > 1) {\n      is_raw = tiff_samples+1;\n      if (!shot_select && !half_size) filters = 0;\n    }\n  } else if (!strncmp(make,\"Sinar\",5)) {\n    if (!load_raw) load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size) filters = 0;\n    maximum = 0x3fff;\n  } else if (!strncmp(make,\"Leaf\",4)) {\n    maximum = 0x3fff;\n    fseek (ifp, data_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1) filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height) {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048) {\n      if (tiff_samples == 1) {\n\tfilters = 1;\n\tstrcpy (cdesc, \"RBTG\");\n\tstrcpy (model, \"CatchLight\");\n\ttop_margin =  8; left_margin = 18; height = 2032; width = 2016;\n      } else {\n\tstrcpy (model, \"DCB2\");\n\ttop_margin = 10; left_margin = 16; height = 2028; width = 2022;\n      }\n    } else if (width+height == 3144+2060) {\n      if (!model[0]) strcpy (model, \"Cantare\");\n      if (width > height) {\n\t top_margin = 6; left_margin = 32; height = 2048;  width = 3072;\n\tfilters = 0x61616161;\n      } else {\n\tleft_margin = 6;  top_margin = 32;  width = 2048; height = 3072;\n\tfilters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V') filters = 0;\n      else is_raw = tiff_samples;\n    } else if (width == 2116) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    } else if (width == 3171) {\n      strcpy (model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  } else if (!strncmp(make,\"Leica\",5) || !strncmp(make,\"Panasonic\",9)\n      || !strncasecmp(make,\"YUNEEC\",6)) {\n    if (raw_width > 0&& ((flen - data_offset) / (raw_width*8/7) == raw_height) )\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw) {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height) height = raw_height;\n    for (i=0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {\n\tleft_margin = pana[i][2];\n\t top_margin = pana[i][3];\n\t     width += pana[i][4];\n\t    height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"\n\t[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  } else if (!strcmp(model,\"C770UZ\")) {\n    height = 1718;\n    width  = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  } else if (!strncmp(make,\"Olympus\",7)) {\n    height += height & 1;\n    if (exif_cfa) filters = exif_cfa;\n    if (width == 4100) width -= 4;\n    if (width == 4080) width -= 24;\n    if (width == 9280) { width -= 6; height -= 6; }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model,\"E-300\") ||\n\t!strcmp(model,\"E-500\")) {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw) {\n\tmaximum = 0xfc3;\n\tmemset (cblack, 0, sizeof cblack);\n      }\n    } else if (!strcmp(model,\"STYLUS1\")) {\n      width -= 14;\n      maximum = 0xfff;\n    } else if (!strcmp(model,\"E-330\")) {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n\tmaximum = 0xf79;\n    } else if (!strcmp(model,\"SP550UZ\")) {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width  = 640;\n    } else if (!strcmp(model,\"TG-4\")) {\n      width -= 16;\n    }\n  } else if (!strcmp(model,\"N Digital\")) {\n    height = 2047;\n    width  = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strcmp(model,\"DSC-F828\")) {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy (cdesc, \"RGBE\");\n  } else if (!strcmp(model,\"DSC-V3\")) {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 3984) {\n    width = 3925;\n    order = 0x4d4d;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4288) {\n    width -= 32;\n  }  else if (!strcmp(make, \"Sony\") && raw_width == 4600) {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 4928) {\n    if (height < 3280) width -= 8;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 5504) { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 6048) {\n    width -= 24;\n    if (strstr(model,\"RX1\") || strstr(model,\"A99\"))\n      width -= 6;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 7392) {\n    width -= 30;\n  } else if (!strncmp(make,\"Sony\",4) && raw_width == 8000) {\n    width -= 32;\n    if (!strncmp(model, \"DSC\", 3)) {\n      tiff_bps = 14;\n      load_raw = &CLASS unpacked_load_raw;\n    }\n  } else if (!strcmp(model,\"DSLR-A100\")) {\n    if (width == 3880) {\n      height--;\n      width = ++raw_width;\n    } else {\n      height -= 4;\n      width  -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  } else if (!strcmp(model,\"PIXL\")) {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve (0, 7, 1, 255);\n  } else if (!strcmp(model,\"C603\") || !strcmp(model,\"C330\")\n\t|| !strcmp(model,\"12MP\")) {\n    order = 0x4949;\n    if (filters && data_offset) {\n      fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts (curve, 256);\n    } else gamma_curve (0, 3.875, 1, 255);\n    load_raw  =  filters   ? &CLASS eight_bit_load_raw :\n      strcmp(model,\"C330\") ? &CLASS kodak_c603_load_raw :\n\t\t\t     &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  } else if (!strncasecmp(model,\"EasyShare\",9)) {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  } else if (!strncasecmp(make,\"Kodak\",5)) {\n    if (filters == UINT_MAX) filters = 0x61616161;\n    if (!strncmp(model,\"NC2000\",6) ||\n\t!strncmp(model,\"EOSDCS\",6) ||\n\t!strncmp(model,\"DCS4\",4)) {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ') model[6] = 0;\n      if (!strcmp(model,\"DCS460A\")) goto bw;\n    } else if (!strcmp(model,\"DCS660M\")) {\n      black = 214;\n      goto bw;\n    } else if (!strcmp(model,\"DCS760M\")) {\nbw:   colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model+4,\"20X\"))\n      strcpy (cdesc, \"MYCY\");\n    if (strstr(model,\"DC25\")) {\n      strcpy (model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model,\"DC2\",3)) {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000) {\n\traw_width = 256; width = 249;\n\tpixel_aspect = (4.0*height) / (3.0*width);\n      } else {\n\traw_width = 512; width = 501;\n\tpixel_aspect = (493.0*height) / (373.0*width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    } else if (!strcmp(model,\"40\")) {\n      strcpy (model, \"DC40\");\n      height = 512;\n      width  = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    } else if (strstr(model,\"DC50\")) {\n      strcpy (model, \"DC50\");\n      height = 512;\n      width  = 768;\n      iso_speed=84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    } else if (strstr(model,\"DC120\")) {\n      strcpy (model, \"DC120\");\n      height = 976;\n      width  = 848;\n      iso_speed=160;\n      pixel_aspect = height/0.75/width;\n      load_raw = tiff_compress == 7 ?\n\t&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    } else if (!strcmp(model,\"DCS200\")) {\n      thumb_height = 128;\n      thumb_width  = 192;\n      thumb_offset = 6144;\n      thumb_misc   = 360;\n      iso_speed=140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  } else if (!strcmp(model,\"Fotoman Pixtura\")) {\n    height = 512;\n    width  = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  } else if (!strncmp(model,\"QuickTake\",9)) {\n    if (head[5]) strcpy (model+10, \"200\");\n    fseek (ifp, 544, SEEK_SET);\n    height = get2();\n    width  = get2();\n    data_offset = (get4(),get2()) == 30 ? 738:736;\n    if (height > width) {\n      SWAP(height,width);\n      fseek (ifp, data_offset-6, SEEK_SET);\n      flip = ~get2() & 3 ? 5:6;\n    }\n    filters = 0x61616161;\n  } else if (!strncmp(make,\"Rollei\",6) && !load_raw) {\n    switch (raw_width) {\n      case 1316:\n\theight = 1030;\n\twidth  = 1300;\n\ttop_margin  = 1;\n\tleft_margin = 6;\n\tbreak;\n      case 2568:\n\theight = 1960;\n\twidth  = 2560;\n\ttop_margin  = 2;\n\tleft_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model,\"GRAS-50S5C\")) {\n   height = 2048;\n   width = 2440;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x49494949;\n   order = 0x4949;\n   maximum = 0xfffC;\n  } else if (!strcmp(model,\"BB-500CL\")) {\n   height = 2058;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"BB-500GE\")) {\n   height = 2058;\n   width = 2456;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x3fff;\n  } else if (!strcmp(model,\"SVS625CL\")) {\n   height = 2050;\n   width = 2448;\n   load_raw = &CLASS unpacked_load_raw;\n   data_offset = 0;\n   filters = 0x94949494;\n   order = 0x4949;\n   maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if (!model[0])\n    sprintf (model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX) filters = 0x94949494;\n  if (thumb_offset && !thumb_height) {\n    fseek (ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start (&jh, 1)) {\n      thumb_width  = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(dng_version) /* Override black level by DNG tags */\n  {\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0,\n    (sizeof(cblack)/sizeof(cblack[0])),\n    (sizeof(imgdata.color.dng_levels.dng_cblack)/sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for(int i=0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n    {\n      is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n      RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n      return;\n    }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2) )\n\t&& cmatrix[0][0] > 0.125) {\n    memcpy (rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color) adobe_coeff (make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(imgdata.color.cam_xyz[0][0]<0.01)\n\t  adobe_coeff (make, model,1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color) adobe_coeff (\"Apple\",\"Quicktake\");\n\n  if (fuji_width) {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  } else {\n    if (raw_height < height) raw_height = height;\n    if (raw_width  < width ) raw_width  = width;\n  }\n  if (!tiff_bps) tiff_bps = 12;\n  if (!maximum)\n    {\n      maximum = (1 << tiff_bps) - 1;\n      if(maximum < 0x10000 && curve[maximum]>0 &&    load_raw == &CLASS sony_arw2_load_raw)\n        maximum = curve[maximum];\n    }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n\ttiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if(raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw ||\n      load_raw == &CLASS lossy_dng_load_raw) {\n#ifdef DCRAW_VERBOSE\n    fprintf (stderr,_(\"%s: You must link dcraw with %s!!\\n\"),\n\tifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy (cdesc, colors == 3 ? \"RGBG\":\"GMCY\");\n  if (!raw_height) raw_height = height;\n  if (!raw_width ) raw_width  = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) |\n\t\t(filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX) flip = tiff_flip;\n  if (flip == UINT_MAX) flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if(flip > 89 || flip < -89)\n   {\n     switch ((flip+3600) % 360)\n     {\n       case 270:  flip = 5;  break;\n       case 180:  flip = 3;  break;\n       case  90:  flip = 6;  break;\n     }\n   }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);\n#endif\n}\n\n\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int  i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] =\n  { { 0.436083, 0.385083, 0.143055 },\n    { 0.222507, 0.716888, 0.060608 },\n    { 0.013930, 0.097097, 0.714022 } };\n  static const double rgb_rgb[3][3] =\n  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\n  static const double adobe_rgb[3][3] =\n  { { 0.715146, 0.284856, 0.000000 },\n    { 0.000000, 1.000000, 0.000000 },\n    { 0.000000, 0.041166, 0.958839 } };\n  static const double wide_rgb[3][3] =\n  { { 0.593087, 0.404710, 0.002206 },\n    { 0.095413, 0.843149, 0.061439 },\n    { 0.011621, 0.069091, 0.919288 } };\n  static const double prophoto_rgb[3][3] =\n  { { 0.529317, 0.330092, 0.140588 },\n    { 0.098368, 0.873465, 0.028169 },\n    { 0.016879, 0.117663, 0.865457 } };\n  static const double aces_rgb[3][3] =\n  { { 0.432996, 0.375380, 0.189317 },\n    { 0.089427, 0.816523, 0.102989 },\n    { 0.019165, 0.118150, 0.941914 } };\n  static const double (*out_rgb[])[3] =\n  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };\n  static const char *name[] =\n  { \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\" };\n  static const unsigned phead[] =\n  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\n  unsigned pbody[] =\n  { 10, 0x63707274, 0, 36,\t/* cprt */\n\t0x64657363, 0, 40,\t/* desc */\n\t0x77747074, 0, 20,\t/* wtpt */\n\t0x626b7074, 0, 20,\t/* bkpt */\n\t0x72545243, 0, 14,\t/* rTRC */\n\t0x67545243, 0, 14,\t/* gTRC */\n\t0x62545243, 0, 14,\t/* bTRC */\n\t0x7258595a, 0, 20,\t/* rXYZ */\n\t0x6758595a, 0, 20,\t/* gXYZ */\n\t0x6258595a, 0, 20 };\t/* bXYZ */\n  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\n  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,0,2);\n#endif\n  gamma_curve (gamm[0], gamm[1], 0, 0);\n  memcpy (out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode ||\n\t\toutput_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 ||\n\t\toutput_color < 1 || output_color > 6;\n#endif\n  if (!raw_color) {\n    oprof = (unsigned *) calloc (phead[0], 1);\n    merror (oprof, \"convert_to_rgb()\");\n    memcpy (oprof, phead, sizeof phead);\n    if (output_color == 5) oprof[4] = oprof[5];\n    oprof[0] = 132 + 12*pbody[0];\n    for (i=0; i < pbody[0]; i++) {\n      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i*3+2] = oprof[0];\n      oprof[0] += (pbody[i*3+3] + 3) & -4;\n    }\n    memcpy (oprof+32, pbody, sizeof pbody);\n    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;\n    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;\n    for (i=4; i < 7; i++)\n      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);\n    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);\n    for (i=0; i < 3; i++)\n      for (j=0; j < 3; j++) {\n\tfor (num = k=0; k < 3; k++)\n\t  num += xyzd50_srgb[i][k] * inverse[j][k];\n\toprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;\n      }\n    for (i=0; i < phead[0]/4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy ((char *)oprof+pbody[2]+8, \"auto-generated by dcraw\");\n    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);\n    for (i=0; i < 3; i++)\n      for (j=0; j < colors; j++)\n\tfor (out_cam[i][j] = k=0; k < 3; k++)\n\t  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr, raw_color ? _(\"Building histograms...\\n\") :\n\t_(\"Converting to %s colorspace...\\n\"), name[output_color-1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset (histogram, 0, sizeof histogram);\n  for (img=image[0], row=0; row < height; row++)\n    for (col=0; col < width; col++, img+=4) {\n      if (!raw_color) {\n\tout[0] = out[1] = out[2] = 0;\n\tFORCC {\n\t  out[0] += out_cam[0][c] * img[c];\n\t  out[1] += out_cam[1][c] * img[c];\n\t  out[2] += out_cam[2][c] * img[c];\n\t}\n\tFORC3 img[c] = CLIP((int) out[c]);\n      }\n      else if (document_mode)\n\timg[0] = img[fcol(row,col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color) colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters) colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB,1,2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width) return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort (*)[4]) calloc (high, wide*sizeof *img);\n  merror (img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,0,2);\n#endif\n\n  for (row=0; row < high; row++)\n    for (col=0; col < wide; col++) {\n      ur = r = fuji_width + (row-col)*step;\n      uc = c = (row+col)*step;\n      if (ur > height-2 || uc > width-2) continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur*width + uc;\n      for (i=0; i < colors; i++)\n\timg[row*wide+col][i] =\n\t  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\n\t  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;\n    }\n\n  free (image);\n  width  = wide;\n  height = high;\n  image  = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE,1,2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,0,2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1) {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c*width];\n      if (c+1 < height) pix1 += width*4;\n      for (col=0; col < width; col++, pix0+=4, pix1+=4)\n\tFORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    height = newdim;\n  } else {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);\n    merror (img, \"stretch()\");\n    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c+1 < width) pix1 += 4;\n      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)\n\tFORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;\n    }\n    width = newdim;\n  }\n  free (image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH,1,2);\n#endif\n}\n\nint CLASS flip_index (int row, int col)\n{\n  if (flip & 4) SWAP(row,col);\n  if (flip & 2) row = iheight - 1 - row;\n  if (flip & 1) col = iwidth  - 1 - col;\n  return row * iwidth + col;\n}\n\nvoid CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,\n\tushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2) {\n    count = strnlen((char *)th + val, count-1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val+c];\n  } else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head (struct tiff_hdr *th, int full)\n{\n  int c, psize=0;\n  struct tm *t;\n\n  memset (th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4+c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy (th->t_desc, desc, 512);\n  strncpy (th->t_make, make, 64);\n  strncpy (th->t_model, model, 64);\n  strcpy (th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime (&timestamp);\n  sprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\n      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n  strncpy (th->t_artist, artist, 64);\n  if (full) {\n    tiff_set (th, &th->ntag, 254, 4, 1, 0);\n    tiff_set (th, &th->ntag, 256, 4, 1, width);\n    tiff_set (th, &th->ntag, 257, 4, 1, height);\n    tiff_set (th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag-1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set (th, &th->ntag, 259, 3, 1, 1);\n    tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full) {\n    if (oprof) psize = ntohl(oprof[0]);\n    tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set (th, &th->ntag, 277, 3, 1, colors);\n    tiff_set (th, &th->ntag, 278, 4, 1, height);\n    tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);\n  } else\n    tiff_set (th, &th->ntag, 274, 3, 1, \"12435867\"[flip]-'0');\n  tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set (th, &th->ntag, 284, 3, 1, 1);\n  tiff_set (th, &th->ntag, 296, 3, 1, 2);\n  tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1]) {\n    tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set (th, &th->ngps,  0, 1,  4, 0x202);\n    tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);\n    tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));\n    tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);\n    tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));\n    tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);\n    tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));\n    tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));\n    tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy (th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp,thumb,thumb_length);\n  free (thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *) malloc (thumb_length);\n  merror (thumb, \"jpeg_thumb()\");\n  fread (thumb, 1, thumb_length, ifp);\n  fputc (0xff, ofp);\n  fputc (0xd8, ofp);\n  if (strcmp (thumb+6, \"Exif\")) {\n    memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, ofp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, ofp);\n  }\n  fwrite (thumb+2, 1, thumb_length-2, ofp);\n  free (thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white=0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01;\t\t/* 99th percentile white level */\n#endif\n  if (fuji_width) perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white=c=0; c < colors; c++) {\n      for (val=0x2000, total=0; --val > 32; )\n\tif ((total += histogram[c][val]) > perc) break;\n      if (t_white < val) t_white = val;\n    }\n  gamma_curve (gamm[0], gamm[1], 2, (t_white << 3)/bright);\n  iheight = height;\n  iwidth  = width;\n  if (flip & 4) SWAP(height,width);\n  ppm = (uchar *) calloc (width, colors*output_bps/8);\n  ppm2 = (ushort *) ppm;\n  merror (ppm, \"write_ppm_tiff()\");\n  if (output_tiff) {\n    tiff_head (&th, 1);\n    fwrite (&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite (oprof, ntohl(oprof[0]), 1, ofp);\n  } else if (colors > 3)\n    fprintf (ofp,\n      \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\n\twidth, height, colors, (1 << output_bps)-1, cdesc);\n  else\n    fprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\n\tcolors/2+5, width, height, (1 << output_bps)-1);\n  soff  = flip_index (0, 0);\n  cstep = flip_index (0, 1) - soff;\n  rstep = flip_index (1, 0) - flip_index (0, width);\n  for (row=0; row < height; row++, soff += rstep) {\n    for (col=0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n\t   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;\n      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab ((char*)ppm2, (char*)ppm2, width*colors*2);\n    fwrite (ppm, colors*output_bps/8, width, ofp);\n  }\n  free (ppm);\n}\n"], "filenames": ["Changelog.txt", "dcraw/dcraw.c", "internal/dcraw_common.cpp"], "buggy_code_start_loc": [0, 3531, 3243], "buggy_code_end_loc": [3, 3533, 3245], "fixing_code_start_loc": [1, 3531, 3243], "fixing_code_end_loc": [7, 3540, 3252], "type": "CWE-125", "message": "In LibRaw through 0.18.4, an out of bounds read flaw related to kodak_65000_load_raw has been reported in dcraw/dcraw.c and internal/dcraw_common.cpp. An attacker could possibly exploit this flaw to disclose potentially sensitive memory or cause an application crash.", "other": {"cve": {"id": "CVE-2017-14608", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-20T17:29:00.510", "lastModified": "2017-09-27T15:57:23.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In LibRaw through 0.18.4, an out of bounds read flaw related to kodak_65000_load_raw has been reported in dcraw/dcraw.c and internal/dcraw_common.cpp. An attacker could possibly exploit this flaw to disclose potentially sensitive memory or cause an application crash."}, {"lang": "es", "value": "En LibRaw hasta la versi\u00f3n 0.18.4, un error de lectura fuera de l\u00edmites relacionado con kodak_65000_load_raw se ha detectado en dcraw/dcraw.c e internal/dcraw_common.cpp. Un atacante podr\u00eda explotar esta vulnerabilidad para divulgar memoria potencialmente sensible o provocar el cierre inesperado de la aplicaci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.18.4", "matchCriteriaId": "DA58125A-903F-4BC1-8B3D-2ECD63761144"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/d13e8f6d1e987b7491182040a188c16a395f1d21", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/101", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/d13e8f6d1e987b7491182040a188c16a395f1d21"}}