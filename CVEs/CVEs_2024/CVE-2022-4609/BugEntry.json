{"buggy_code": ["package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = (32 * 8) << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t\tCreatorID: userID,\n\t\t}\n\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"resource created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Not find resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindResource(ctx, resourceFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tID:        resourceID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = (32 * 8) << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tif strings.HasSuffix(filename, \".html\") {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"html file is not allowed\")\n\t\t}\n\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t\tCreatorID: userID,\n\t\t}\n\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"resource created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Not find resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindResource(ctx, resourceFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tID:        resourceID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n"], "filenames": ["server/resource.go"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [44], "fixing_code_start_loc": [10], "fixing_code_end_loc": [50], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository usememos/memos prior to 0.9.0.", "other": {"cve": {"id": "CVE-2022-4609", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-19T12:15:11.123", "lastModified": "2022-12-23T18:44:47.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository usememos/memos prior to 0.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "9E9BB4B3-BBB1-406D-96EE-69114B828CF0"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/726285e63467820f94cbf872abe71025a161c212", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5b3115c5-776c-43d3-a7be-c8dc13ab81ce", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/726285e63467820f94cbf872abe71025a161c212"}}