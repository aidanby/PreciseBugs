{"buggy_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nsource vim9.vim\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def script#OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  CheckScriptFailure(lines, 'E128:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  CheckScriptFailure(lines, 'E128:')\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def scriptX#Function()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  CheckScriptFailure(lines, 'E746:', 2)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  ReturnString()->assert_equal('string')\n  ReturnNumber()->assert_equal(123)\n  assert_fails('ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  CheckScriptFailure(lines, 'E1010:')\n  CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\nfunc Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  MyDefaultArgs()->assert_equal('string')\n  MyDefaultArgs(v:none)->assert_equal('string')\n  MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      s:Funcy()\n  END\n  CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is found without g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n    delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', Func())\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  CheckDefFailure(['TakesOneArg()'], 'E119:')\n  CheckDefFailure(['TakesOneArg(11, 22)'], 'E118:')\n  CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo nr\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  CheckDefFailure(lines, 'E1167:')\n  CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo FilterWithCond('foo', (v) => v .. '^b')\n  END\n  CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(f: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(f: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func s:Getit()\n        return 'it'\n      endfunc\n      var Fn = s:Getit\n      assert_equal('it', Fn())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  MyDefVarargs('one')->assert_equal('one,foo')\n  MyDefVarargs('one', 'two')->assert_equal('one,two')\n  MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  CheckDefFailure(['MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  CheckDefFailure(['MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  MyVarargsOnly()->assert_equal('')\n  MyVarargsOnly('one')->assert_equal('one')\n  MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  CheckDefFailure(['MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  CheckDefFailure(['MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  writefile(['def Func(x: number)',  'var x = 234', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1006:', '', 1, 'Func')\n  delete('Xdef')\nenddef\n\ndef DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_functin_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')\nenddef\n\ndef Test_return_type_wrong()\n  CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = FuncNoArgNoRet\n  RefVoid = FuncOneArgNoRet\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = FuncNoArgRetNumber\n  RefAny = FuncNoArgRetString\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = FuncNoArgRetNumber\n  RefNr = FuncOneArgRetNumber\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  CheckDefFailure(['var str: string', 'str = FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call MultiLine('text')->assert_equal('text1234')\n  call MultiLine('text', 777)->assert_equal('text777')\n  call MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def s:func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], Shadowed())\nenddef\n\ndef Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  CheckScriptFailure(lines, 'E1235:')\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  WaitForAssert(() => assert_match('E684: list index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(g: func): dict<func>\n        return {f: g}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  lines[2] = 'var l: list<any>'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = []'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = [11]'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: 2 arguments too many', 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: One argument too many', 1)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  call CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\nif has('python3')\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\n\" This messes up syntax highlight, keep near the end.\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic char *e_funcdict = N_(\"E717: Dictionary entry already exists\");\nstatic char *e_funcref = N_(\"E718: Funcref required\");\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(e_illegal_argument_str), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t    evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(\"E853: Duplicate argument name: %s\"), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    char_u *theline;\n\n\t    // End of the line, get the next one.\n\t    theline = eap->getline(':', eap->cookie, 0, TRUE);\n\t    if (theline == NULL)\n\t\tbreak;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invarg2), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(\"E989: Non-default argument follows default argument\"));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tchar_u\t    **line_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    if (eap->getline == NULL)\n\t\ttheline = getcmdline(':', 0L, indent, getline_options);\n\t    else\n\t\ttheline = eap->getline(':', eap->cookie, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t    if (*eap->cmdlinep == *line_to_free)\n\t\t*eap->cmdlinep = theline;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_enddef_str), p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\".\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (*line_to_free != NULL\n\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n\t\t\t{\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = *line_to_free;\n\t\t\t    *line_to_free = NULL;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    char_u\t*line_to_free = NULL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_arg), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n    {\n\tvim_free(cmdline);\n\tgoto erret;\n    }\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t    if (cmdline == line_to_free)\n\t\tline_to_free = NULL;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    vim_free(line_to_free);\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n\n    if (equal_arrow && !in_vim9script())\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(\"E451: Expected }: %s\"), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, (int)sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t   in_vim9script() && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !in_vim9script() || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\tfp->uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len + 1;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, NULL);\n\n\t// imported variable from another script\n\tif (import != NULL)\n\t{\n\t    if (import->imp_funcname != NULL)\n\t    {\n\t\ts = import->imp_funcname;\n\t\t*lenp = (int)STRLEN(s);\n\t\treturn s;\n\t    }\n\t    if (import->imp_flags & IMP_FLAGS_STAR)\n\t    {\n\t\tname[len] = NUL;\n\t\tsemsg(_(e_cannot_use_str_itself_it_is_imported_with_star),\n\t\t\t\t\t\t\t\t\t name);\n\t\tname[len] = cc;\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    else\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t    + import->imp_var_vals_idx;\n\t\ttv = sv->sv_tv;\n\t\tif (type != NULL)\n\t\t    *type = sv->sv_type;\n\t\tdid_type = TRUE;\n\t    }\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p;\n\n    if (*name == K_SPECIAL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    else\n\tp = name;\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, (int)sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (in_vim9script() && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting())\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(N_(\"E740: Too many arguments for function %s\"), name);\n\telse\n\t    emsg_funcname(e_invalid_arguments_for_function_str, name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (in_vim9script())\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t*hi;\n    char_u\tbuffer[200];\n\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, sizeof(buffer) - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"is_global\" is true don't find script-local or imported functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int is_global, cctx_T *cctx)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n    imported_T\t*imported;\n\n    if (!is_global)\n    {\n\tchar_u\t*after_script = NULL;\n\tlong\tsid = 0;\n\tint\tfind_script_local = in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's');\n\n\tif (find_script_local)\n\t{\n\t    // Find script-local function before global one.\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n\n\tif (name[0] == K_SPECIAL\n\t\t&& name[1] == KS_EXTRA\n\t\t&& name[2] == KE_SNR)\n\t{\n\t    // Caller changes s: to <SNR>99_name.\n\n\t    after_script = name + 3;\n\t    sid = getdigits(&after_script);\n\t    if (*after_script == '_')\n\t\t++after_script;\n\t    else\n\t\tafter_script = NULL;\n\t}\n\tif (find_script_local || after_script != NULL)\n\t{\n\t    // Find imported function before global one.\n\t    if (after_script != NULL && sid != current_sctx.sc_sid)\n\t\timported = find_imported_in_script(after_script, 0, sid);\n\t    else\n\t\timported = find_imported(after_script == NULL\n\t\t\t\t\t       ? name : after_script, 0, cctx);\n\t    if (imported != NULL && imported->imp_funcname != NULL)\n\t    {\n\t\thi = hash_find(&func_hashtab, imported->imp_funcname);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    return HI2UF(hi);\n\t    }\n\t}\n    }\n\n    hi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global, cctx_T *cctx)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global, cctx);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def\n * 2. numbered functions and lambdas\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || *name == '<';\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE, NULL);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_function_str_already_exists_add_excl_to_replace), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n            vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(e_function_call_depth_is_higher_than_macfuncdepth));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    char_u *p;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    return p == NULL || (len > 0 && p > name + len);\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(\"E699: Too many arguments\"));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, 0, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    semsg(_(e_not_callable_type_str), name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(\n\t\t\tN_(\"E276: Cannot use function as a method: %s\"), name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(e_func_deleted, name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname((char *)e_too_many_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname((char *)e_not_enough_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(\n\t\t    e_using_sid_not_in_script_context_str, name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(\n\t\t      N_(\"E725: Calling dict function without Dictionary: %s\"),\n\t\t\tname);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type, argvars, argcount,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t\tfp = find_func(rfname, is_global, NULL);\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global, NULL);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n#ifdef FEAT_LUA\n\t    else if (fp != NULL && (fp->uf_flags & FC_CFUNC))\n\t    {\n\t\tcfunc_T cb = fp->uf_cb;\n\n\t\terror = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n\t    }\n#endif\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n    {\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n    }\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    lval_T\tlv;\n    int\t\tvim9script;\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invarg2), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (is_global != NULL && lv.ll_name[0] == 'g')\n\t\t*is_global = TRUE;\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9script = ASCII_ISUPPER(*start) && in_vim9script();\n    if (vim9script)\n    {\n\tchar_u *p;\n\n\t// SomeScript#func() is a global function.\n\tfor (p = start; *p != NUL && *p != '('; ++p)\n\t    if (*p == AUTOLOAD_CHAR)\n\t\tvim9script = FALSE;\n    }\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9script)\n    {\n\tif (!vim9script)\n\t    lead = 3;\n\tif (vim9script || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9script)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (in_vim9script() && *lv.ll_name == '_')))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_or_s_str), start);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(\"E884: Function name cannot contain a colon: %s\"), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9script))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9script || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n\t// The function name is not a script-local function name\n\treturn NULL;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    off = *funcname == 's' ? 2 : 5;\n    newname = alloc(STRLEN(sid_buf) + STRLEN(funcname + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, funcname + off);\n\n    return newname;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(\"E454: function list was modified\"));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_dictkey), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_arg), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_nobang));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname((char *)e_invarg2, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), NULL, NULL,\n\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(\"E862: Cannot use g: here\"));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_arg), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_funcdict));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_excl_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),\n\t\t\t\t\t\t\t\t\tname);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_excl_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_funcdict));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(\"E746: Function name does not match script file name: %s\"), name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled.  Except dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap UNUSED)\n{\n    long\ttodo = (long)func_hashtab.ht_used;\n    int\t\tchanged = func_hashtab.ht_changed;\n    hashitem_T\t*hi;\n    ufunc_T\t*ufunc;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ufunc = HI2UF(hi);\n\t    if (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t    && ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t    && (ufunc->uf_flags & FC_DEAD) == 0)\n\t    {\n\t\t(void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\tif (func_hashtab.ht_changed != changed)\n\t\t{\n\t\t    // a function has been added or removed, need to start over\n\t\t    todo = (long)func_hashtab.ht_used;\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    hi = func_hashtab.ht_array;\n\t\t    --hi;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global, NULL) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_arg), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invarg2), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global, NULL);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_unknown_function_str), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(e_cannot_delete_function_str_it_is_in_use), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(e_return_not_inside_function));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, in_vim9script() ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_dictkey), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t    in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (in_vim9script() && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_arg), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*tofree = NULL;\n    ufunc_T\t*fp;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\t// Translate \"s:func\" to the stored function name.\n\tfname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n\tvim_free(tofree);\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nsource vim9.vim\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def script#OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  CheckScriptFailure(lines, 'E128:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  CheckScriptFailure(lines, 'E128:')\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def scriptX#Function()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  CheckScriptFailure(lines, 'E746:', 2)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  ReturnString()->assert_equal('string')\n  ReturnNumber()->assert_equal(123)\n  assert_fails('ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  CheckScriptFailure(lines, 'E1010:')\n  CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\nfunc Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  MyDefaultArgs()->assert_equal('string')\n  MyDefaultArgs(v:none)->assert_equal('string')\n  MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      s:Funcy()\n  END\n  CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is found without g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n    delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', Func())\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  CheckDefFailure(['TakesOneArg()'], 'E119:')\n  CheckDefFailure(['TakesOneArg(11, 22)'], 'E118:')\n  CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo nr\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  CheckDefFailure(lines, 'E1167:')\n  CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo FilterWithCond('foo', (v) => v .. '^b')\n  END\n  CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(f: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(f: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func s:Getit()\n        return 'it'\n      endfunc\n      var Fn = s:Getit\n      assert_equal('it', Fn())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  MyDefVarargs('one')->assert_equal('one,foo')\n  MyDefVarargs('one', 'two')->assert_equal('one,two')\n  MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  CheckDefFailure(['MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  CheckDefFailure(['MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  MyVarargsOnly()->assert_equal('')\n  MyVarargsOnly('one')->assert_equal('one')\n  MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  CheckDefFailure(['MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  CheckDefFailure(['MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  writefile(['def Func(x: number)',  'var x = 234', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1006:', '', 1, 'Func')\n  delete('Xdef')\nenddef\n\ndef DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  # FIXME: this should fail on the BBBB\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_return_type_wrong()\n  CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = FuncNoArgNoRet\n  RefVoid = FuncOneArgNoRet\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = FuncNoArgRetNumber\n  RefAny = FuncNoArgRetString\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = FuncNoArgRetNumber\n  RefNr = FuncOneArgRetNumber\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  CheckDefFailure(['var str: string', 'str = FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call MultiLine('text')->assert_equal('text1234')\n  call MultiLine('text', 777)->assert_equal('text777')\n  call MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def s:func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], Shadowed())\nenddef\n\ndef Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  CheckScriptFailure(lines, 'E1235:')\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  WaitForAssert(() => assert_match('E684: list index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(g: func): dict<func>\n        return {f: g}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  lines[2] = 'var l: list<any>'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = []'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = [11]'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: 2 arguments too many', 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: One argument too many', 1)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  call CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\nif has('python3')\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\n\" This messes up syntax highlight, keep near the end.\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic char *e_funcdict = N_(\"E717: Dictionary entry already exists\");\nstatic char *e_funcref = N_(\"E718: Funcref required\");\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(e_illegal_argument_str), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t    evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(\"E853: Duplicate argument name: %s\"), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    char_u *theline;\n\n\t    // End of the line, get the next one.\n\t    theline = eap->getline(':', eap->cookie, 0, TRUE);\n\t    if (theline == NULL)\n\t\tbreak;\n\t    vim_free(*line_to_free);\n\t    if (*eap->cmdlinep == *line_to_free)\n\t\t*eap->cmdlinep = theline;\n\t    *line_to_free = theline;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invarg2), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(\"E989: Non-default argument follows default argument\"));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tchar_u\t    **line_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    if (eap->getline == NULL)\n\t\ttheline = getcmdline(':', 0L, indent, getline_options);\n\t    else\n\t\ttheline = eap->getline(':', eap->cookie, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t    if (*eap->cmdlinep == *line_to_free)\n\t\t*eap->cmdlinep = theline;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_enddef_str), p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\".\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (*line_to_free != NULL\n\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n\t\t\t{\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = *line_to_free;\n\t\t\t    *line_to_free = NULL;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    char_u\t*line_to_free = NULL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_arg), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n    {\n\tvim_free(cmdline);\n\tgoto erret;\n    }\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t    if (cmdline == line_to_free)\n\t\tline_to_free = NULL;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    vim_free(line_to_free);\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n\n    if (equal_arrow && !in_vim9script())\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(\"E451: Expected }: %s\"), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, (int)sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t   in_vim9script() && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !in_vim9script() || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\tfp->uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len + 1;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, NULL);\n\n\t// imported variable from another script\n\tif (import != NULL)\n\t{\n\t    if (import->imp_funcname != NULL)\n\t    {\n\t\ts = import->imp_funcname;\n\t\t*lenp = (int)STRLEN(s);\n\t\treturn s;\n\t    }\n\t    if (import->imp_flags & IMP_FLAGS_STAR)\n\t    {\n\t\tname[len] = NUL;\n\t\tsemsg(_(e_cannot_use_str_itself_it_is_imported_with_star),\n\t\t\t\t\t\t\t\t\t name);\n\t\tname[len] = cc;\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    else\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t    + import->imp_var_vals_idx;\n\t\ttv = sv->sv_tv;\n\t\tif (type != NULL)\n\t\t    *type = sv->sv_type;\n\t\tdid_type = TRUE;\n\t    }\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p;\n\n    if (*name == K_SPECIAL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    else\n\tp = name;\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, (int)sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (in_vim9script() && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting())\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(N_(\"E740: Too many arguments for function %s\"), name);\n\telse\n\t    emsg_funcname(e_invalid_arguments_for_function_str, name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (in_vim9script())\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t*hi;\n    char_u\tbuffer[200];\n\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, sizeof(buffer) - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"is_global\" is true don't find script-local or imported functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int is_global, cctx_T *cctx)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n    imported_T\t*imported;\n\n    if (!is_global)\n    {\n\tchar_u\t*after_script = NULL;\n\tlong\tsid = 0;\n\tint\tfind_script_local = in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's');\n\n\tif (find_script_local)\n\t{\n\t    // Find script-local function before global one.\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n\n\tif (name[0] == K_SPECIAL\n\t\t&& name[1] == KS_EXTRA\n\t\t&& name[2] == KE_SNR)\n\t{\n\t    // Caller changes s: to <SNR>99_name.\n\n\t    after_script = name + 3;\n\t    sid = getdigits(&after_script);\n\t    if (*after_script == '_')\n\t\t++after_script;\n\t    else\n\t\tafter_script = NULL;\n\t}\n\tif (find_script_local || after_script != NULL)\n\t{\n\t    // Find imported function before global one.\n\t    if (after_script != NULL && sid != current_sctx.sc_sid)\n\t\timported = find_imported_in_script(after_script, 0, sid);\n\t    else\n\t\timported = find_imported(after_script == NULL\n\t\t\t\t\t       ? name : after_script, 0, cctx);\n\t    if (imported != NULL && imported->imp_funcname != NULL)\n\t    {\n\t\thi = hash_find(&func_hashtab, imported->imp_funcname);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    return HI2UF(hi);\n\t    }\n\t}\n    }\n\n    hi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global, cctx_T *cctx)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global, cctx);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def\n * 2. numbered functions and lambdas\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || *name == '<';\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE, NULL);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_function_str_already_exists_add_excl_to_replace), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n            vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(e_function_call_depth_is_higher_than_macfuncdepth));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    char_u *p;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    return p == NULL || (len > 0 && p > name + len);\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(\"E699: Too many arguments\"));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, 0, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    semsg(_(e_not_callable_type_str), name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(\n\t\t\tN_(\"E276: Cannot use function as a method: %s\"), name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(e_func_deleted, name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname((char *)e_too_many_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname((char *)e_not_enough_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(\n\t\t    e_using_sid_not_in_script_context_str, name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(\n\t\t      N_(\"E725: Calling dict function without Dictionary: %s\"),\n\t\t\tname);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type, argvars, argcount,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t\tfp = find_func(rfname, is_global, NULL);\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global, NULL);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n#ifdef FEAT_LUA\n\t    else if (fp != NULL && (fp->uf_flags & FC_CFUNC))\n\t    {\n\t\tcfunc_T cb = fp->uf_cb;\n\n\t\terror = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n\t    }\n#endif\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n    {\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n    }\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    lval_T\tlv;\n    int\t\tvim9script;\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invarg2), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (is_global != NULL && lv.ll_name[0] == 'g')\n\t\t*is_global = TRUE;\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9script = ASCII_ISUPPER(*start) && in_vim9script();\n    if (vim9script)\n    {\n\tchar_u *p;\n\n\t// SomeScript#func() is a global function.\n\tfor (p = start; *p != NUL && *p != '('; ++p)\n\t    if (*p == AUTOLOAD_CHAR)\n\t\tvim9script = FALSE;\n    }\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9script)\n    {\n\tif (!vim9script)\n\t    lead = 3;\n\tif (vim9script || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9script)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (in_vim9script() && *lv.ll_name == '_')))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_or_s_str), start);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(\"E884: Function name cannot contain a colon: %s\"), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9script))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9script || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n\t// The function name is not a script-local function name\n\treturn NULL;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    off = *funcname == 's' ? 2 : 5;\n    newname = alloc(STRLEN(sid_buf) + STRLEN(funcname + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, funcname + off);\n\n    return newname;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(\"E454: function list was modified\"));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_dictkey), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_arg), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_nobang));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname((char *)e_invarg2, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), NULL, NULL,\n\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(\"E862: Cannot use g: here\"));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_arg), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_funcdict));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_excl_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),\n\t\t\t\t\t\t\t\t\tname);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_excl_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_funcdict));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(\"E746: Function name does not match script file name: %s\"), name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled.  Except dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap UNUSED)\n{\n    long\ttodo = (long)func_hashtab.ht_used;\n    int\t\tchanged = func_hashtab.ht_changed;\n    hashitem_T\t*hi;\n    ufunc_T\t*ufunc;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ufunc = HI2UF(hi);\n\t    if (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t    && ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t    && (ufunc->uf_flags & FC_DEAD) == 0)\n\t    {\n\t\t(void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\tif (func_hashtab.ht_changed != changed)\n\t\t{\n\t\t    // a function has been added or removed, need to start over\n\t\t    todo = (long)func_hashtab.ht_used;\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    hi = func_hashtab.ht_array;\n\t\t    --hi;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global, NULL) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_arg), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invarg2), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global, NULL);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_unknown_function_str), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(e_cannot_delete_function_str_it_is_in_use), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(e_return_not_inside_function));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, in_vim9script() ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_dictkey), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t    in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (in_vim9script() && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_arg), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*tofree = NULL;\n    ufunc_T\t*fp;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\t// Translate \"s:func\" to the stored function name.\n\tfname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n\tvim_free(tofree);\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/testdir/test_vim9_func.vim", "src/userfunc.c", "src/version.c"], "buggy_code_start_loc": [1672, 221, 751], "buggy_code_end_loc": [1689, 221, 751], "fixing_code_start_loc": [1672, 222, 752], "fixing_code_end_loc": [1708, 224, 754], "type": "CWE-416", "message": "vim is vulnerable to Use After Free", "other": {"cve": {"id": "CVE-2021-4187", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-29T17:15:07.630", "lastModified": "2022-11-02T13:18:35.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Use After Free"}, {"lang": "es", "value": "vim es vulnerable a un Uso de Memoria Previamente Liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.2.3912", "matchCriteriaId": "81DB6767-8F89-48AB-BB3F-D81A9B7C7079"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:*:*:*:*:*:*:*", "matchCriteriaId": "89161D20-EB9C-4EC0-8D82-75B27CE49264"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2020-001:*:*:*:*:*:*", "matchCriteriaId": "F1F4BF7F-90D4-4668-B4E6-B06F4070F448"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-001:*:*:*:*:*:*", "matchCriteriaId": "0F441A43-1669-478D-9EC8-E96882DE4F9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-002:*:*:*:*:*:*", "matchCriteriaId": "D425C653-37A2-448C-BF2F-B684ADB08A26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-003:*:*:*:*:*:*", "matchCriteriaId": "A54D63B7-B92B-47C3-B1C5-9892E5873A98"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-004:*:*:*:*:*:*", "matchCriteriaId": "3456176F-9185-4EE2-A8CE-3D989D674AB7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-005:*:*:*:*:*:*", "matchCriteriaId": "D337EE21-2F00-484D-9285-F2B0248D7A19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-006:*:*:*:*:*:*", "matchCriteriaId": "012052B5-9AA7-4FD3-9C80-5F615330039D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-007:*:*:*:*:*:*", "matchCriteriaId": "50F21A3C-0AC3-48C5-A4F8-5A7B478875B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-008:*:*:*:*:*:*", "matchCriteriaId": "8E974DC6-F7D9-4389-9AF9-863F6E419CE6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-001:*:*:*:*:*:*", "matchCriteriaId": "156A6382-2BD3-4882-90B2-8E7CF6659E17"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-002:*:*:*:*:*:*", "matchCriteriaId": "20A2FDB2-6712-406A-9896-C0B44508B07D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-003:*:*:*:*:*:*", "matchCriteriaId": "49F537A0-DC42-4176-B22F-C80D179DD99D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.3", "matchCriteriaId": "9060C1B6-F101-46AE-8B08-6D6951304916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.6.6", "matchCriteriaId": "09A6345C-D813-43BA-B12E-789C80653F86"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:10.15.7:security_update_2022-004:*:*:*:*:*:*", "matchCriteriaId": "D99ACC65-B867-44CC-A6DD-53C7399CA344"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Jul/14", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/29", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/35", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/4bf1006cae7e87259ccd5219128c3dba75774441", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a8bee03a-6e2e-43bf-bee3-4968c5386a2e", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2EY2VFBU3YGGWI5BW4XKT3F37MYGEQUD/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213183", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213256", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213343", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/4bf1006cae7e87259ccd5219128c3dba75774441"}}