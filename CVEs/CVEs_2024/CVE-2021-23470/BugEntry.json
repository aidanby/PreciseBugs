{"buggy_code": ["/* putil-merge\n ------------------------\n (c) 2017-present Panates\n This file may be freely distributed under the MIT license.\n */\n\nconst isObjectOrClass = (v) => v && (\n    (typeof v === 'object' && !Array.isArray(v)) ||\n    (typeof v === 'function' && v.prototype && v.prototype.constructor));\n\n/**\n *\n * @param {Object} target\n * @param {Object} source\n * @param {Object} options\n * @param {boolean} [options.deep]\n * @param {boolean} [options.clone]\n * @param {boolean} [options.combine]\n * @param {boolean} [options.descriptor]\n * @param {Function} [options.filter]\n * @param {Function|Boolean} [options.arrayMerge]\n * @return {Object}\n */\nfunction merge(target, source, options = {}) {\n  if (!isObjectOrClass(target))\n    throw new TypeError('Property \"target\" requires object type');\n  if (!source)\n    return target;\n  if (!isObjectOrClass(source))\n    throw new TypeError('Property \"source\" requires object type');\n\n  if (source === target) return target;\n  const keys = Object.getOwnPropertyNames(source);\n  keys.push(...Object.getOwnPropertySymbols(source));\n  for (const key of keys) {\n    if (key === '__proto__')\n      continue;\n    if (options.filter && !options.filter(source, key))\n      continue;\n    if ((options.combine || options.adjunct) && target.hasOwnProperty(key))\n      continue;\n\n    const descriptor = Object.getOwnPropertyDescriptor(source, key);\n\n    if (options.descriptor && (descriptor.get || descriptor.set)) {\n      Object.defineProperty(target, key, descriptor);\n      continue;\n    }\n    let srcVal = source[key];\n    if (srcVal === undefined)\n      continue;\n\n    delete descriptor.get;\n    delete descriptor.set;\n    if (!options.descriptor) {\n      descriptor.enumerable = true;\n      descriptor.configurable = true;\n      descriptor.writable = true;\n    }\n\n    let trgVal = target[key];\n    if (isObjectOrClass(srcVal)) {\n      if (options.deep) {\n        if (!isObjectOrClass(trgVal)) {\n          descriptor.value = trgVal = {};\n          Object.defineProperty(target, key, descriptor);\n        }\n        merge(trgVal, srcVal, options);\n        continue;\n      }\n      if (options.clone)\n        srcVal = merge({}, srcVal, options);\n    } else if (Array.isArray(srcVal)) {\n      if (options.arrayMerge && Array.isArray(trgVal)) {\n        if (typeof options.arrayMerge === 'function')\n          srcVal = options.arrayMerge(trgVal, srcVal);\n        else\n          srcVal = merge.arrayCombine(trgVal, srcVal);\n      } else if (options.clone)\n        srcVal = srcVal.slice();\n    }\n    descriptor.value = srcVal;\n    Object.defineProperty(target, key, descriptor);\n  }\n  return target;\n}\n\nmerge.all = function all(objects, options = {}) {\n  const target = objects[0];\n  for (const [i, o] of objects.entries()) {\n    if (i > 0)\n      merge(target, o, options);\n  }\n  return target;\n};\n\nmerge.arrayCombine = function(target, source) {\n  return target.concat(source.filter((v) => !target.includes(v)));\n};\n\nmodule.exports = merge;\n", "{\n  \"name\": \"putil-merge\",\n  \"description\": \"Lightweight solution for merging multiple objects into one. Also it supports deep merge and deep clone\",\n  \"version\": \"3.7.0\",\n  \"author\": \"Panates Ltd.\",\n  \"contributors\": [\n    \"Eray Hanoglu <e.hanoglu@panates.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/panates/putil-merge.git\"\n  },\n  \"main\": \"lib/merge.js\",\n  \"types\": \"lib/merge\",\n  \"keywords\": [\n    \"javascript\",\n    \"merge\",\n    \"object\"\n  ],\n  \"devDependencies\": {\n    \"eslint\": \"^7.19.0\",\n    \"eslint-config-google\": \"^0.14.0\",\n    \"mocha\": \"^9.0.2\",\n    \"nyc\": \"^15.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 10.0\"\n  },\n  \"directories\": {\n    \"lib\": \"./lib\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"lib/\"\n  ],\n  \"nyc\": {\n    \"temp-dir\": \"./coverage/.nyc_output\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha --require ./test/support/env --reporter spec --bail --check-leaks test/\",\n    \"cover\": \"nyc --reporter html --reporter text npm run test\",\n    \"travis-cover\": \"nyc --reporter lcovonly npm run test\"\n  }\n}\n", "/* eslint-disable */\nconst assert = require('assert');\nconst merge = require('../');\n\ndescribe('merge', function() {\n\n  it('should throw if target is not an object', function() {\n    assert.throws(() => {\n      merge([], {});\n    });\n  });\n\n  it('should throw if source is not an object', function() {\n    assert.throws(() => {\n      merge({}, []);\n    });\n  });\n\n  it('should ignore if source is null', function() {\n    const a = {};\n    const b = merge(a);\n    assert.strictEqual(b, a);\n  });\n\n  it('should copy regular values to target', function() {\n    const a = {a: 1, b: '2', e: 5};\n    const b = {a: 2, c: 3, d: null, e: undefined};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, {\n          a: 2,\n          b: '2',\n          c: 3,\n          d: null,\n          e: 5\n        }\n    );\n  });\n\n  it('should copy object values to target', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {foo: 1}\n        }\n    );\n    b.c.foo = 2;\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {foo: 2}\n        }\n    );\n  });\n\n  it('should clone object values to target', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b, {clone: true});\n    b.c.foo = 2;\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {foo: 1}\n        }\n    );\n  });\n\n  it('should deep clone object values to target', function() {\n    const a = {a: 1, b: '2', c: {fop: 1}};\n    const b = {a: '1', c: {foo: {bar: {baz: 1}}}};\n    let o = merge(a, b, {deep: true, clone: true});\n    b.c.foo.bar = 2;\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {fop: 1, foo: {bar: {baz: 1}}}\n        }\n    );\n  });\n\n  it('should copy array values to target', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, b);\n    assert.strictEqual(o.foo, b.foo);\n  });\n\n  it('should clone array values to target', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b, {clone: true});\n    assert.deepStrictEqual(o, b);\n    assert.notStrictEqual(o.foo, b.foo);\n  });\n\n  it('should merge array values to target', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b, {arrayMerge: true});\n    assert.deepStrictEqual(o, {foo: [1, 2, 3, 4]});\n    assert.notStrictEqual(o.foo, b.foo);\n  });\n\n  it('should perform custom array merge function', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b, {\n      arrayMerge: () => {\n        return ['a', 'b'];\n      }\n    });\n    assert.deepStrictEqual(o, {foo: ['a', 'b']});\n  });\n\n  it('should copy symbol values to target', function() {\n    const foo = Symbol.for('sym');\n    const a = {};\n    const b = {foo};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, b);\n    assert.strictEqual(o.foo, b.foo);\n  });\n\n  it('should copy descriptors', function() {\n    const a = {};\n    Object.defineProperty(a, 'foo', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: 1\n    });\n    let o = merge({}, a, {descriptor: true});\n    assert.deepStrictEqual(Object.getOwnPropertyDescriptor(o, 'foo'), {\n          configurable: true,\n          enumerable: false,\n          writable: false,\n          value: 1\n        }\n    );\n  });\n\n  it('should copy getters and setters and bind to target', function() {\n    const a = {\n      bar: 0,\n      get foo() {\n        return ++this.bar;\n      },\n      set foo(v) {\n        this.bar = v;\n      }\n    };\n    let o = merge({}, a, {descriptor: true});\n    assert.strictEqual(a.foo, 1);\n    assert.strictEqual(o.foo, 1);\n    assert.strictEqual(o.foo, 2);\n    o.foo = 5;\n    assert.strictEqual(o.foo, 6);\n  });\n\n  it('should only copy properties if options.combine is true', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: 2, c: 3};\n    let o = merge(a, b, {combine: true});\n    assert.deepStrictEqual(o, {\n          a: 1,\n          b: '2',\n          c: 3\n        }\n    );\n  });\n\n  it('should copy functions', function() {\n    const a = {\n      bar: 0,\n      getFoo() {\n        return ++this.bar;\n      }\n    };\n    let o = merge({}, a);\n    assert.strictEqual(a.getFoo(), 1);\n    assert.strictEqual(o.getFoo(), 1);\n    assert.strictEqual(o.getFoo(), 2);\n  });\n\n  it('should do nothing if source = target', function() {\n    const a = {};\n    const o = merge(a, a);\n    assert.strictEqual(o, a);\n  });\n\n  it('should perform filter before merge', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b, {\n      filter: (src, key) => {\n        return key !== 'c';\n      }\n    });\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2'\n        }\n    );\n  });\n\n  it('should perform deep filter before merge', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b, {\n      deep: true,\n      filter: (src, key) => {\n        return key !== 'foo';\n      }\n    });\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {}\n        }\n    );\n  });\n\n  it('should merge.all() perform bulk merge', function() {\n    const a = {a: 1};\n    const b = {b: 2};\n    const c = {c: 3};\n    let o = merge.all([a, b, c]);\n    assert.deepStrictEqual(o, {\n          a: 1,\n          b: 2,\n          c: 3\n        }\n    );\n  });\n\n  it('should prevent Prototype Pollution vulnerability', function() {\n    const payload = JSON.parse('{\"__proto__\":{\"polluted\":\"Yes! Its Polluted\"}}');\n    const obj = {};\n    merge(obj, payload, {deep: true});\n    assert.strictEqual(obj.polluted, undefined);\n  });\n\n});\n"], "fixing_code": ["/* putil-merge\n ------------------------\n (c) 2017-present Panates\n This file may be freely distributed under the MIT license.\n */\n\nconst isObjectOrClass = (v) => v && (\n    (typeof v === 'object' && !Array.isArray(v)) ||\n    (typeof v === 'function' && v.prototype && v.prototype.constructor));\n\n/**\n *\n * @param {Object} target\n * @param {Object} source\n * @param {Object} options\n * @param {boolean} [options.deep]\n * @param {boolean} [options.clone]\n * @param {boolean} [options.combine]\n * @param {boolean} [options.descriptor]\n * @param {Function} [options.filter]\n * @param {Function|Boolean} [options.arrayMerge]\n * @return {Object}\n */\nfunction merge(target, source, options = {}) {\n  if (!isObjectOrClass(target))\n    throw new TypeError('Property \"target\" requires object type');\n  if (!source)\n    return target;\n  if (!isObjectOrClass(source))\n    throw new TypeError('Property \"source\" requires object type');\n\n  if (source === target) return target;\n  const keys = Object.getOwnPropertyNames(source);\n  keys.push(...Object.getOwnPropertySymbols(source));\n  for (const key of keys) {\n    if (key === '__proto__' || key === 'constructor')\n      continue;\n    if (options.filter && !options.filter(source, key))\n      continue;\n    if ((options.combine || options.adjunct) && target.hasOwnProperty(key))\n      continue;\n\n    const descriptor = Object.getOwnPropertyDescriptor(source, key);\n\n    if (options.descriptor && (descriptor.get || descriptor.set)) {\n      Object.defineProperty(target, key, descriptor);\n      continue;\n    }\n    let srcVal = source[key];\n    if (srcVal === undefined)\n      continue;\n\n    delete descriptor.get;\n    delete descriptor.set;\n    if (!options.descriptor) {\n      descriptor.enumerable = true;\n      descriptor.configurable = true;\n      descriptor.writable = true;\n    }\n\n    let trgVal = target[key];\n    if (isObjectOrClass(srcVal)) {\n      if (options.deep) {\n        if (!isObjectOrClass(trgVal)) {\n          descriptor.value = trgVal = {};\n          Object.defineProperty(target, key, descriptor);\n        }\n        merge(trgVal, srcVal, options);\n        continue;\n      }\n      if (options.clone)\n        srcVal = merge({}, srcVal, options);\n    } else if (Array.isArray(srcVal)) {\n      if (options.arrayMerge && Array.isArray(trgVal)) {\n        if (typeof options.arrayMerge === 'function')\n          srcVal = options.arrayMerge(trgVal, srcVal);\n        else\n          srcVal = merge.arrayCombine(trgVal, srcVal);\n      } else if (options.clone)\n        srcVal = srcVal.slice();\n    }\n    descriptor.value = srcVal;\n    Object.defineProperty(target, key, descriptor);\n  }\n  return target;\n}\n\nmerge.all = function all(objects, options = {}) {\n  const target = objects[0];\n  for (const [i, o] of objects.entries()) {\n    if (i > 0)\n      merge(target, o, options);\n  }\n  return target;\n};\n\nmerge.arrayCombine = function(target, source) {\n  return target.concat(source.filter((v) => !target.includes(v)));\n};\n\nmodule.exports = merge;\n", "{\n  \"name\": \"putil-merge\",\n  \"description\": \"Lightweight solution for merging multiple objects into one. Also it supports deep merge and deep clone\",\n  \"version\": \"3.7.0\",\n  \"author\": \"Panates Ltd.\",\n  \"contributors\": [\n    \"Eray Hanoglu <e.hanoglu@panates.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/panates/putil-merge.git\"\n  },\n  \"main\": \"lib/merge.js\",\n  \"types\": \"lib/merge\",\n  \"keywords\": [\n    \"javascript\",\n    \"merge\",\n    \"object\"\n  ],\n  \"devDependencies\": {\n    \"eslint\": \"^8.8.0\",\n    \"eslint-config-google\": \"^0.14.0\",\n    \"mocha\": \"^9.2.0\",\n    \"nyc\": \"^15.1.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 10.0\"\n  },\n  \"directories\": {\n    \"lib\": \"./lib\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"lib/\"\n  ],\n  \"nyc\": {\n    \"temp-dir\": \"./coverage/.nyc_output\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha --require ./test/support/env --reporter spec --bail --check-leaks test/\",\n    \"cover\": \"nyc --reporter html --reporter text npm run test\",\n    \"travis-cover\": \"nyc --reporter lcovonly npm run test\"\n  }\n}\n", "/* eslint-disable */\nconst assert = require('assert');\nconst merge = require('../');\n\ndescribe('merge', function() {\n\n  it('should throw if target is not an object', function() {\n    assert.throws(() => {\n      merge([], {});\n    });\n  });\n\n  it('should throw if source is not an object', function() {\n    assert.throws(() => {\n      merge({}, []);\n    });\n  });\n\n  it('should ignore if source is null', function() {\n    const a = {};\n    const b = merge(a);\n    assert.strictEqual(b, a);\n  });\n\n  it('should copy regular values to target', function() {\n    const a = {a: 1, b: '2', e: 5};\n    const b = {a: 2, c: 3, d: null, e: undefined};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, {\n          a: 2,\n          b: '2',\n          c: 3,\n          d: null,\n          e: 5\n        }\n    );\n  });\n\n  it('should copy object values to target', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {foo: 1}\n        }\n    );\n    b.c.foo = 2;\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {foo: 2}\n        }\n    );\n  });\n\n  it('should clone object values to target', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b, {clone: true});\n    b.c.foo = 2;\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {foo: 1}\n        }\n    );\n  });\n\n  it('should deep clone object values to target', function() {\n    const a = {a: 1, b: '2', c: {fop: 1}};\n    const b = {a: '1', c: {foo: {bar: {baz: 1}}}};\n    let o = merge(a, b, {deep: true, clone: true});\n    b.c.foo.bar = 2;\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {fop: 1, foo: {bar: {baz: 1}}}\n        }\n    );\n  });\n\n  it('should copy array values to target', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, b);\n    assert.strictEqual(o.foo, b.foo);\n  });\n\n  it('should clone array values to target', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b, {clone: true});\n    assert.deepStrictEqual(o, b);\n    assert.notStrictEqual(o.foo, b.foo);\n  });\n\n  it('should merge array values to target', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b, {arrayMerge: true});\n    assert.deepStrictEqual(o, {foo: [1, 2, 3, 4]});\n    assert.notStrictEqual(o.foo, b.foo);\n  });\n\n  it('should perform custom array merge function', function() {\n    const a = {foo: [1, 2]};\n    const b = {foo: [2, 3, 4]};\n    let o = merge(a, b, {\n      arrayMerge: () => {\n        return ['a', 'b'];\n      }\n    });\n    assert.deepStrictEqual(o, {foo: ['a', 'b']});\n  });\n\n  it('should copy symbol values to target', function() {\n    const foo = Symbol.for('sym');\n    const a = {};\n    const b = {foo};\n    let o = merge(a, b);\n    assert.deepStrictEqual(o, b);\n    assert.strictEqual(o.foo, b.foo);\n  });\n\n  it('should copy descriptors', function() {\n    const a = {};\n    Object.defineProperty(a, 'foo', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: 1\n    });\n    let o = merge({}, a, {descriptor: true});\n    assert.deepStrictEqual(Object.getOwnPropertyDescriptor(o, 'foo'), {\n          configurable: true,\n          enumerable: false,\n          writable: false,\n          value: 1\n        }\n    );\n  });\n\n  it('should copy getters and setters and bind to target', function() {\n    const a = {\n      bar: 0,\n      get foo() {\n        return ++this.bar;\n      },\n      set foo(v) {\n        this.bar = v;\n      }\n    };\n    let o = merge({}, a, {descriptor: true});\n    assert.strictEqual(a.foo, 1);\n    assert.strictEqual(o.foo, 1);\n    assert.strictEqual(o.foo, 2);\n    o.foo = 5;\n    assert.strictEqual(o.foo, 6);\n  });\n\n  it('should only copy properties if options.combine is true', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: 2, c: 3};\n    let o = merge(a, b, {combine: true});\n    assert.deepStrictEqual(o, {\n          a: 1,\n          b: '2',\n          c: 3\n        }\n    );\n  });\n\n  it('should copy functions', function() {\n    const a = {\n      bar: 0,\n      getFoo() {\n        return ++this.bar;\n      }\n    };\n    let o = merge({}, a);\n    assert.strictEqual(a.getFoo(), 1);\n    assert.strictEqual(o.getFoo(), 1);\n    assert.strictEqual(o.getFoo(), 2);\n  });\n\n  it('should do nothing if source = target', function() {\n    const a = {};\n    const o = merge(a, a);\n    assert.strictEqual(o, a);\n  });\n\n  it('should perform filter before merge', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b, {\n      filter: (src, key) => {\n        return key !== 'c';\n      }\n    });\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2'\n        }\n    );\n  });\n\n  it('should perform deep filter before merge', function() {\n    const a = {a: 1, b: '2'};\n    const b = {a: '1', c: {foo: 1}};\n    let o = merge(a, b, {\n      deep: true,\n      filter: (src, key) => {\n        return key !== 'foo';\n      }\n    });\n    assert.deepStrictEqual(o, {\n          a: '1',\n          b: '2',\n          c: {}\n        }\n    );\n  });\n\n  it('should merge.all() perform bulk merge', function() {\n    const a = {a: 1};\n    const b = {b: 2};\n    const c = {c: 3};\n    let o = merge.all([a, b, c]);\n    assert.deepStrictEqual(o, {\n          a: 1,\n          b: 2,\n          c: 3\n        }\n    );\n  });\n\n  it('should prevent Prototype Pollution vulnerability (__proto__)', function() {\n    const payload = JSON.parse('{\"__proto__\":{\"polluted\":\"Yes! Its Polluted\"}}');\n    const obj = {};\n    merge(obj, payload, {deep: true});\n    assert.strictEqual(obj.polluted, undefined);\n  });\n\n  it('should prevent Prototype Pollution vulnerability (constructor)', function() {\n    const payload = JSON.parse('{\"constructor\": {\"prototype\": {\"polluted\": \"yes\"}}}');\n    let obj = {};\n    merge(obj, payload, {deep: true});\n    assert.strictEqual(obj.polluted, undefined);\n  });\n\n});\n"], "filenames": ["lib/merge.js", "package.json", "test/merge.js"], "buggy_code_start_loc": [36, 22, 240], "buggy_code_end_loc": [37, 25, 246], "fixing_code_start_loc": [36, 22, 240], "fixing_code_end_loc": [37, 25, 254], "type": "CWE-1321", "message": "This affects the package putil-merge before 3.8.0. The merge() function does not check the values passed into the argument. An attacker can supply a malicious value by adjusting the value to include the constructor property. Note: This vulnerability derives from an incomplete fix in https://security.snyk.io/vuln/SNYK-JS-PUTILMERGE-1317077", "other": {"cve": {"id": "CVE-2021-23470", "sourceIdentifier": "report@snyk.io", "published": "2022-02-04T20:15:08.363", "lastModified": "2022-02-09T02:07:00.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package putil-merge before 3.8.0. The merge() function does not check the values passed into the argument. An attacker can supply a malicious value by adjusting the value to include the constructor property. Note: This vulnerability derives from an incomplete fix in https://security.snyk.io/vuln/SNYK-JS-PUTILMERGE-1317077"}, {"lang": "es", "value": "Esto afecta al paquete putil-merge versiones anteriores a 3.8.0. La funci\u00f3n merge() no comprueba los valores pasados en el argumento. Un atacante puede suministrar un valor malicioso al ajustar el valor para incluir la propiedad del constructor. Nota: Esta vulnerabilidad deriva de una correcci\u00f3n incompleta en https://security.snyk.io/vuln/SNYK-JS-PUTILMERGE-1317077"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:putil-merge_project:putil-merge:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.8.0", "matchCriteriaId": "BF1896F1-FFFF-4C4F-8853-1AF03BA41262"}]}]}], "references": [{"url": "https://github.com/panates/putil-merge/commit/476d00078dfb2827d7c9ee0f2392c81b864f7bc5", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-PUTILMERGE-2391487", "source": "report@snyk.io", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/panates/putil-merge/commit/476d00078dfb2827d7c9ee0f2392c81b864f7bc5"}}