{"buggy_code": ["namespace Xmpp.Xep.MessageArchiveManagement {\n\npublic const string NS_URI = \"urn:xmpp:mam:2\";\npublic const string NS_URI_1 = \"urn:xmpp:mam:1\";\n\nprivate static string NS_VER(XmppStream stream) {\n    return stream.get_flag(Flag.IDENTITY).ns_ver;\n}\n\npublic class Module : XmppStreamModule {\n    public static ModuleIdentity<Module> IDENTITY = new ModuleIdentity<Module>(NS_URI, \"0313_message_archive_management\");\n\n    public signal void feature_available(XmppStream stream);\n\n    private ReceivedPipelineListener received_pipeline_listener = new ReceivedPipelineListener();\n\n    public delegate void OnFinished(XmppStream stream);\n    public void query_archive(XmppStream stream, string? jid, DateTime? start, DateTime? end, owned OnFinished? on_finished = null) {\n        if (stream.get_flag(Flag.IDENTITY) == null) return;\n\n        DataForms.DataForm data_form = new DataForms.DataForm();\n        DataForms.DataForm.HiddenField form_type_field = new DataForms.DataForm.HiddenField() { var=\"FORM_TYPE\" };\n        form_type_field.set_value_string(NS_VER(stream));\n        data_form.add_field(form_type_field);\n        if (jid != null) {\n            DataForms.DataForm.Field field = new DataForms.DataForm.Field() { var=\"with\" };\n            field.set_value_string(jid);\n            data_form.add_field(field);\n        }\n        if (start != null) {\n            DataForms.DataForm.Field field = new DataForms.DataForm.Field() { var=\"start\" };\n            field.set_value_string(DateTimeProfiles.to_datetime(start));\n            data_form.add_field(field);\n        }\n        if (end != null) {\n            DataForms.DataForm.Field field = new DataForms.DataForm.Field() { var=\"end\" };\n            field.set_value_string(DateTimeProfiles.to_datetime(end));\n            data_form.add_field(field);\n        }\n        StanzaNode query_node = new StanzaNode.build(\"query\", NS_VER(stream)).add_self_xmlns().put_node(data_form.get_submit_node());\n        Iq.Stanza iq = new Iq.Stanza.set(query_node);\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq, (stream, iq) => { page_through_results(stream, iq, (owned)on_finished); });\n    }\n\n    public override void attach(XmppStream stream) {\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.connect(received_pipeline_listener);\n        stream.stream_negotiated.connect(query_availability);\n    }\n\n    public override void detach(XmppStream stream) {\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.disconnect(received_pipeline_listener);\n    }\n\n    public override string get_ns() { return NS_URI; }\n    public override string get_id() { return IDENTITY.id; }\n\n    private static void page_through_results(XmppStream stream, Iq.Stanza iq, owned OnFinished? on_finished = null) {\n        string? last = iq.stanza.get_deep_string_content(NS_VER(stream) + \":fin\", \"http://jabber.org/protocol/rsm\" + \":set\", \"last\");\n        if (last == null) {\n            stream.get_flag(Flag.IDENTITY).cought_up = true;\n            if (on_finished != null) on_finished(stream);\n            return;\n        }\n\n        Iq.Stanza paging_iq = new Iq.Stanza.set(\n                new StanzaNode.build(\"query\", NS_VER(stream)).add_self_xmlns().put_node(\n                    new StanzaNode.build(\"set\", \"http://jabber.org/protocol/rsm\").add_self_xmlns().put_node(\n                        new StanzaNode.build(\"after\", \"http://jabber.org/protocol/rsm\").put_node(new StanzaNode.text(last))\n                    )\n                )\n            );\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, paging_iq, (stream, iq) => { page_through_results(stream, iq, (owned)on_finished); });\n    }\n\n    private void query_availability(XmppStream stream) {\n        stream.get_module(Xep.ServiceDiscovery.Module.IDENTITY).request_info(stream, stream.get_flag(Bind.Flag.IDENTITY).my_jid.bare_jid, (stream, info_result) => {\n            if (info_result == null) return;\n            if (info_result.features.contains(NS_URI)) {\n                stream.add_flag(new Flag(NS_URI));\n                feature_available(stream);\n            } else if (info_result.features.contains(NS_URI_1)) {\n                stream.add_flag(new Flag(NS_URI_1));\n                feature_available(stream);\n            }\n        });\n    }\n}\n\npublic class ReceivedPipelineListener : StanzaListener<MessageStanza> {\n\n    private const string[] after_actions_const = {};\n\n    public override string action_group { get { return \"EXTRACT_MESSAGE_1\"; } }\n    public override string[] after_actions { get { return after_actions_const; } }\n\n    public override async bool run(XmppStream stream, MessageStanza message) {\n        //        if (message.from != stream.remote_name) return;\n        if (stream.get_flag(Flag.IDENTITY) == null) return false;\n\n        StanzaNode? message_node = message.stanza.get_deep_subnode(NS_VER(stream) + \":result\", \"urn:xmpp:forward:0:forwarded\", Xmpp.NS_URI + \":message\");\n        if (message_node != null) {\n            StanzaNode? forward_node = message.stanza.get_deep_subnode(NS_VER(stream) + \":result\", \"urn:xmpp:forward:0:forwarded\", DelayedDelivery.NS_URI + \":delay\");\n            DateTime? datetime = DelayedDelivery.Module.get_time_for_node(forward_node);\n            message.add_flag(new MessageFlag(datetime));\n\n            message.stanza = message_node;\n            message.rerun_parsing = true;\n        }\n        return false;\n    }\n}\n\npublic class Flag : XmppStreamFlag {\n    public static FlagIdentity<Flag> IDENTITY = new FlagIdentity<Flag>(NS_URI, \"message_archive_management\");\n    public bool cought_up { get; set; default=false; }\n    public string ns_ver;\n\n    public Flag(string ns_ver) {\n        this.ns_ver = ns_ver;\n    }\n\n    public override string get_ns() { return NS_URI; }\n    public override string get_id() { return IDENTITY.id; }\n}\n\npublic class MessageFlag : Xmpp.MessageFlag {\n    public const string ID = \"message_archive_management\";\n\n    public DateTime? server_time { get; private set; }\n\n    public MessageFlag(DateTime? server_time) {\n        this.server_time = server_time;\n    }\n\n    public static MessageFlag? get_flag(MessageStanza message) { return (MessageFlag) message.get_flag(NS_URI, ID); }\n\n    public override string get_ns() { return NS_URI; }\n    public override string get_id() { return ID; }\n}\n\n}\n"], "fixing_code": ["namespace Xmpp.Xep.MessageArchiveManagement {\n\npublic const string NS_URI = \"urn:xmpp:mam:2\";\npublic const string NS_URI_1 = \"urn:xmpp:mam:1\";\n\nprivate static string NS_VER(XmppStream stream) {\n    return stream.get_flag(Flag.IDENTITY).ns_ver;\n}\n\npublic class Module : XmppStreamModule {\n    public static ModuleIdentity<Module> IDENTITY = new ModuleIdentity<Module>(NS_URI, \"0313_message_archive_management\");\n\n    public signal void feature_available(XmppStream stream);\n\n    private ReceivedPipelineListener received_pipeline_listener = new ReceivedPipelineListener();\n\n    public delegate void OnFinished(XmppStream stream);\n    public void query_archive(XmppStream stream, string? jid, DateTime? start, DateTime? end, owned OnFinished? on_finished = null) {\n        if (stream.get_flag(Flag.IDENTITY) == null) return;\n\n        DataForms.DataForm data_form = new DataForms.DataForm();\n        DataForms.DataForm.HiddenField form_type_field = new DataForms.DataForm.HiddenField() { var=\"FORM_TYPE\" };\n        form_type_field.set_value_string(NS_VER(stream));\n        data_form.add_field(form_type_field);\n        if (jid != null) {\n            DataForms.DataForm.Field field = new DataForms.DataForm.Field() { var=\"with\" };\n            field.set_value_string(jid);\n            data_form.add_field(field);\n        }\n        if (start != null) {\n            DataForms.DataForm.Field field = new DataForms.DataForm.Field() { var=\"start\" };\n            field.set_value_string(DateTimeProfiles.to_datetime(start));\n            data_form.add_field(field);\n        }\n        if (end != null) {\n            DataForms.DataForm.Field field = new DataForms.DataForm.Field() { var=\"end\" };\n            field.set_value_string(DateTimeProfiles.to_datetime(end));\n            data_form.add_field(field);\n        }\n        StanzaNode query_node = new StanzaNode.build(\"query\", NS_VER(stream)).add_self_xmlns().put_node(data_form.get_submit_node());\n        Iq.Stanza iq = new Iq.Stanza.set(query_node);\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, iq, (stream, iq) => { page_through_results(stream, iq, (owned)on_finished); });\n    }\n\n    public override void attach(XmppStream stream) {\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.connect(received_pipeline_listener);\n        stream.stream_negotiated.connect(query_availability);\n    }\n\n    public override void detach(XmppStream stream) {\n        stream.get_module(MessageModule.IDENTITY).received_pipeline.disconnect(received_pipeline_listener);\n    }\n\n    public override string get_ns() { return NS_URI; }\n    public override string get_id() { return IDENTITY.id; }\n\n    private static void page_through_results(XmppStream stream, Iq.Stanza iq, owned OnFinished? on_finished = null) {\n        string? last = iq.stanza.get_deep_string_content(NS_VER(stream) + \":fin\", \"http://jabber.org/protocol/rsm\" + \":set\", \"last\");\n        if (last == null) {\n            stream.get_flag(Flag.IDENTITY).cought_up = true;\n            if (on_finished != null) on_finished(stream);\n            return;\n        }\n\n        Iq.Stanza paging_iq = new Iq.Stanza.set(\n                new StanzaNode.build(\"query\", NS_VER(stream)).add_self_xmlns().put_node(\n                    new StanzaNode.build(\"set\", \"http://jabber.org/protocol/rsm\").add_self_xmlns().put_node(\n                        new StanzaNode.build(\"after\", \"http://jabber.org/protocol/rsm\").put_node(new StanzaNode.text(last))\n                    )\n                )\n            );\n        stream.get_module(Iq.Module.IDENTITY).send_iq(stream, paging_iq, (stream, iq) => { page_through_results(stream, iq, (owned)on_finished); });\n    }\n\n    private void query_availability(XmppStream stream) {\n        stream.get_module(Xep.ServiceDiscovery.Module.IDENTITY).request_info(stream, stream.get_flag(Bind.Flag.IDENTITY).my_jid.bare_jid, (stream, info_result) => {\n            if (info_result == null) return;\n            if (info_result.features.contains(NS_URI)) {\n                stream.add_flag(new Flag(NS_URI));\n                feature_available(stream);\n            } else if (info_result.features.contains(NS_URI_1)) {\n                stream.add_flag(new Flag(NS_URI_1));\n                feature_available(stream);\n            }\n        });\n    }\n}\n\npublic class ReceivedPipelineListener : StanzaListener<MessageStanza> {\n\n    private const string[] after_actions_const = {};\n\n    public override string action_group { get { return \"EXTRACT_MESSAGE_1\"; } }\n    public override string[] after_actions { get { return after_actions_const; } }\n\n    public override async bool run(XmppStream stream, MessageStanza message) {\n        if (stream.get_flag(Flag.IDENTITY) == null) return false;\n\n        StanzaNode? message_node = message.stanza.get_deep_subnode(NS_VER(stream) + \":result\", \"urn:xmpp:forward:0:forwarded\", Xmpp.NS_URI + \":message\");\n        if (message_node != null) {\n            // MAM messages must come from our server // TODO or a MUC server\n            if (!message.from.equals(stream.get_flag(Bind.Flag.IDENTITY).my_jid.bare_jid)) {\n                warning(\"Received alledged MAM message from %s, ignoring\", message.from.to_string());\n                return true;\n            }\n\n            StanzaNode? forward_node = message.stanza.get_deep_subnode(NS_VER(stream) + \":result\", \"urn:xmpp:forward:0:forwarded\", DelayedDelivery.NS_URI + \":delay\");\n            DateTime? datetime = DelayedDelivery.Module.get_time_for_node(forward_node);\n            message.add_flag(new MessageFlag(datetime));\n\n            message.stanza = message_node;\n            message.rerun_parsing = true;\n        }\n        return false;\n    }\n}\n\npublic class Flag : XmppStreamFlag {\n    public static FlagIdentity<Flag> IDENTITY = new FlagIdentity<Flag>(NS_URI, \"message_archive_management\");\n    public bool cought_up { get; set; default=false; }\n    public string ns_ver;\n\n    public Flag(string ns_ver) {\n        this.ns_ver = ns_ver;\n    }\n\n    public override string get_ns() { return NS_URI; }\n    public override string get_id() { return IDENTITY.id; }\n}\n\npublic class MessageFlag : Xmpp.MessageFlag {\n    public const string ID = \"message_archive_management\";\n\n    public DateTime? server_time { get; private set; }\n\n    public MessageFlag(DateTime? server_time) {\n        this.server_time = server_time;\n    }\n\n    public static MessageFlag? get_flag(MessageStanza message) { return (MessageFlag) message.get_flag(NS_URI, ID); }\n\n    public override string get_ns() { return NS_URI; }\n    public override string get_id() { return ID; }\n}\n\n}\n"], "filenames": ["xmpp-vala/src/module/xep/0313_message_archive_management.vala"], "buggy_code_start_loc": [97], "buggy_code_end_loc": [101], "fixing_code_start_loc": [96], "fixing_code_end_loc": [107], "type": "CWE-346", "message": "Dino before 2019-09-10 does not properly check the source of an MAM message in module/xep/0313_message_archive_management.vala.", "other": {"cve": {"id": "CVE-2019-16237", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-11T19:15:11.907", "lastModified": "2020-09-14T14:27:16.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dino before 2019-09-10 does not properly check the source of an MAM message in module/xep/0313_message_archive_management.vala."}, {"lang": "es", "value": "Dino antes del 10-09-2019, no comprueba correctamente la fuente de un mensaje MAM en el archivo module/xep/0313_message_archive_management.vala."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dino:dino:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.0", "matchCriteriaId": "01FE0CAC-943E-461D-93F3-734FFCE3BC79"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/09/12/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dino/dino/commit/307f16cc86dd2b95aa02ab8a85110e4a2d5e7363", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gultsch.de/dino_multiple.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5TMGQ5Q6QMIFG4NVUWMOWW3GIPGWQZVF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WZBNQAOBWTIOKNO4PIYNX624ACGUXSXQ/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YUBM7GDZBB6MZZALDWYRAPNV6HJNLNMC/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Sep/31", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4306-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4524", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dino/dino/commit/307f16cc86dd2b95aa02ab8a85110e4a2d5e7363"}}