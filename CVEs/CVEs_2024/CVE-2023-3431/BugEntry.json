{"buggy_code": ["# Warning, \"version\" should be the same in gradle.properties and Version.java\n# Any idea anyone how to magically synchronize those :-) ?\nversion = 1.2023.9beta4\norg.gradle.workers.max = 3", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n *\n */\npackage net.sourceforge.plantuml;\n\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport net.sourceforge.plantuml.core.Diagram;\nimport net.sourceforge.plantuml.dot.GraphvizUtils;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.utils.Log;\n\npublic class OptionFlags {\n\t// ::remove file when __HAXE__\n\n\tprivate static final OptionFlags singleton = new OptionFlags();\n\tstatic public final boolean STRICT_SELFMESSAGE_POSITION = true;\n\tstatic public final boolean USE_INTERFACE_EYE1 = false;\n\tstatic public final boolean USE_INTERFACE_EYE2 = false;\n\tstatic public final boolean FORCE_TEOZ = false;\n\n\tprivate boolean replaceWhiteBackgroundByTransparent;\n\n\tpublic static OptionFlags getInstance() {\n\t\treturn singleton;\n\t}\n\n\tpublic final boolean isReplaceWhiteBackgroundByTransparent() {\n\t\treturn replaceWhiteBackgroundByTransparent;\n\t}\n\n\tpublic final void setReplaceWhiteBackgroundByTransparent(boolean replaceWhiteBackgroundByTransparent) {\n\t\tthis.replaceWhiteBackgroundByTransparent = replaceWhiteBackgroundByTransparent;\n\t}\n\n\t// ::comment when __CORE__\n\t// static public final boolean PBBACK = false;\n\t// static public boolean GRAPHVIZCACHE = false;\n\t// static public final boolean TRACE_DOT = false;\n\n\tstatic public boolean ALLOW_INCLUDE = true;\n\n\tstatic public void setAllowIncludeFalse() {\n\t\tALLOW_INCLUDE = false;\n\t}\n\n\tstatic public void setMaxPixel(int max) {\n\t}\n\n\tstatic public final boolean USE_HECTOR = false;\n\tstatic public boolean ADD_NICE_FOR_DOT = false;\n\n\t// static public final boolean USE_IF_VERTICAL = true;\n\t// static public final boolean SWI2 = false;\n\t// static public final boolean USE_COMPOUND = false;\n\t// static public final boolean OMEGA_CROSSING = false;\n\n\t// static public final boolean LINK_BETWEEN_FIELDS = true;\n\n\tpublic void reset() {\n\t\treset(false);\n\t\tGraphvizUtils.setDotExecutable(null);\n\t}\n\n\tpublic final void setDotExecutable(String dotExecutable) {\n\t\tGraphvizUtils.setDotExecutable(dotExecutable);\n\t}\n\n\tprivate OptionFlags() {\n\t\treset(true);\n\t}\n\n\tprivate void reset(boolean exit) {\n\t\tverbose = false;\n\t\textractFromMetadata = false;\n\t\tword = false;\n\t\tsystemExit = exit;\n\t\tgui = false;\n\t\tquiet = false;\n\t\tcheckDotError = false;\n\t\tprintFonts = false;\n\t\t// failOnError = false;\n\t\tencodesprite = false;\n\t\t// PIC_LINE = false;\n\t}\n\n\tpublic boolean useJavaInsteadOfDot() {\n\t\treturn false;\n\t}\n\n\tprivate boolean verbose;\n\tprivate boolean extractFromMetadata;\n\tprivate boolean word;\n\tprivate boolean systemExit;\n\tprivate boolean gui;\n\tprivate boolean quiet;\n\tprivate boolean checkDotError;\n\tprivate boolean printFonts;\n\tprivate boolean encodesprite;\n\tprivate boolean dumpHtmlStats;\n\tprivate boolean dumpStats;\n\tprivate boolean loopStats;\n\tprivate boolean overwrite;\n\tprivate boolean enableStats = defaultForStats();\n\tprivate boolean stdLib;\n\tprivate boolean silentlyCompletelyIgnoreErrors;\n\tprivate boolean extractStdLib;\n\tprivate boolean clipboardLoop;\n\tprivate boolean clipboard;\n\tprivate String fileSeparator = \"_\";\n\tprivate long timeoutMs = 15 * 60 * 1000L; // 15 minutes\n\tprivate SFile logData;\n\n\tpublic final boolean isVerbose() {\n\t\treturn verbose;\n\t}\n\n\tpublic final void setVerbose(boolean verbose) {\n\t\tthis.verbose = verbose;\n\t}\n\n\tpublic final boolean isExtractFromMetadata() {\n\t\treturn extractFromMetadata;\n\t}\n\n\tpublic final void setExtractFromMetadata(boolean extractFromMetadata) {\n\t\tthis.extractFromMetadata = extractFromMetadata;\n\t}\n\n\tpublic final boolean isWord() {\n\t\treturn word;\n\t}\n\n\tpublic final void setWord(boolean word) {\n\t\tthis.word = word;\n\t}\n\n\tpublic final boolean isSystemExit() {\n\t\treturn systemExit;\n\t}\n\n\tpublic final void setSystemExit(boolean systemExit) {\n\t\tthis.systemExit = systemExit;\n\t}\n\n\tpublic final boolean isGui() {\n\t\treturn gui;\n\t}\n\n\tpublic final void setGui(boolean gui) {\n\t\tthis.gui = gui;\n\t}\n\n\tpublic final boolean isQuiet() {\n\t\treturn quiet;\n\t}\n\n\tpublic final void setQuiet(boolean quiet) {\n\t\tthis.quiet = quiet;\n\t}\n\n\tpublic final boolean isCheckDotError() {\n\t\treturn checkDotError;\n\t}\n\n\tpublic final void setCheckDotError(boolean checkDotError) {\n\t\tthis.checkDotError = checkDotError;\n\t}\n\n\tprivate final AtomicBoolean logDataInitized = new AtomicBoolean(false);\n\n\tpublic void logData(final SFile file, Diagram system) {\n\t\tfinal String warnOrError = system.getWarningOrError();\n\t\tif (warnOrError == null) {\n\t\t\treturn;\n\t\t}\n\t\tsynchronized (logDataInitized) {\n\t\t\tif (logData == null && logDataInitized.get() == false) {\n\t\t\t\tfinal String s = GraphvizUtils.getenvLogData();\n\t\t\t\tif (s != null) {\n\t\t\t\t\tsetLogData(new SFile(s));\n\t\t\t\t}\n\t\t\t\tlogDataInitized.set(true);\n\t\t\t}\n\n\t\t\tif (logData == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// final PSystemError systemError = (PSystemError) system;\n\t\t\ttry (PrintStream ps = SecurityUtils.createPrintStream(logData.createFileOutputStream(true))) {\n\t\t\t\tps.println(\"Start of \" + file.getName());\n\t\t\t\tps.println(warnOrError);\n\t\t\t\tps.println(\"End of \" + file.getName());\n\t\t\t\tps.println();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLog.error(\"Cannot open \" + logData);\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic final void setLogData(SFile logData) {\n\t\tthis.logData = logData;\n\t\tlogData.delete();\n\t\ttry (PrintStream ps = SecurityUtils.createPrintStream(logData.createFileOutputStream())) {\n\t\t\tps.println();\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLog.error(\"Cannot open \" + logData);\n\t\t\tLogme.error(e);\n\t\t}\n\t}\n\n\tpublic final boolean isPrintFonts() {\n\t\treturn printFonts;\n\t}\n\n\tpublic final void setPrintFonts(boolean printFonts) {\n\t\tthis.printFonts = printFonts;\n\t}\n\n\tpublic final boolean isUseSuggestEngine2() {\n\t\treturn false;\n\t}\n\n\tpublic final boolean isEncodesprite() {\n\t\treturn encodesprite;\n\t}\n\n\tpublic final void setEncodesprite(boolean encodesprite) {\n\t\tthis.encodesprite = encodesprite;\n\t}\n\n\tpublic final boolean isOverwrite() {\n\t\treturn overwrite;\n\t}\n\n\tpublic final void setOverwrite(boolean overwrite) {\n\t\tthis.overwrite = overwrite;\n\t}\n\n\tpublic final String getFileSeparator() {\n\t\treturn fileSeparator;\n\t}\n\n\tpublic final void setFileSeparator(String fileSeparator) {\n\t\tthis.fileSeparator = fileSeparator;\n\t}\n\n\tpublic final boolean isDumpHtmlStats() {\n\t\treturn dumpHtmlStats;\n\t}\n\n\tpublic final void setDumpHtmlStats(boolean value) {\n\t\tthis.dumpHtmlStats = value;\n\t}\n\n\tpublic final boolean isDumpStats() {\n\t\treturn dumpStats;\n\t}\n\n\tpublic final void setDumpStats(boolean dumpStats) {\n\t\tthis.dumpStats = dumpStats;\n\t}\n\n\tpublic final boolean isLoopStats() {\n\t\treturn loopStats;\n\t}\n\n\tpublic final void setLoopStats(boolean loopStats) {\n\t\tthis.loopStats = loopStats;\n\t}\n\n\tprivate static boolean defaultForStats() {\n\t\treturn isTrue(System.getProperty(\"PLANTUML_STATS\")) || isTrue(System.getenv(\"PLANTUML_STATS\"));\n\t}\n\n\tprivate static boolean isTrue(final String value) {\n\t\treturn \"on\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value);\n\t}\n\n\tpublic boolean isEnableStats() {\n\t\treturn enableStats;\n\t}\n\n\tpublic void setEnableStats(boolean enableStats) {\n\t\tthis.enableStats = enableStats;\n\t}\n\n\tpublic final long getTimeoutMs() {\n\t\treturn timeoutMs;\n\t}\n\n\tpublic final void setTimeoutMs(long timeoutMs) {\n\t\tthis.timeoutMs = timeoutMs;\n\t}\n\n\tpublic void setExtractStdLib(boolean extractStdLib) {\n\t\tthis.extractStdLib = extractStdLib;\n\t}\n\n\tpublic boolean isExtractStdLib() {\n\t\treturn extractStdLib;\n\t}\n\n\tpublic final boolean isClipboardLoop() {\n\t\treturn clipboardLoop;\n\t}\n\n\tpublic final void setClipboardLoop(boolean clipboardLoop) {\n\t\tthis.clipboardLoop = clipboardLoop;\n\t}\n\n\tpublic final boolean isClipboard() {\n\t\treturn clipboard;\n\t}\n\n\tpublic final void setClipboard(boolean clipboard) {\n\t\tthis.clipboard = clipboard;\n\t}\n\n\tpublic final boolean isStdLib() {\n\t\treturn stdLib;\n\t}\n\n\tpublic final void setStdLib(boolean stdLib) {\n\t\tthis.stdLib = stdLib;\n\t}\n\n\tpublic final boolean isSilentlyCompletelyIgnoreErrors() {\n\t\treturn silentlyCompletelyIgnoreErrors;\n\t}\n\n\tpublic final void setSilentlyCompletelyIgnoreErrors(boolean silentlyCompletelyIgnoreErrors) {\n\t\tthis.silentlyCompletelyIgnoreErrors = silentlyCompletelyIgnoreErrors;\n\t}\n\n\t// ::done\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * Modified by: Nicolas Jouanin\n * \n *\n */\npackage net.sourceforge.plantuml.preproc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.file.AFile;\nimport net.sourceforge.plantuml.file.AFileRegular;\nimport net.sourceforge.plantuml.file.AFileZipEntry;\nimport net.sourceforge.plantuml.file.AParentFolder;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.utils.Log;\n// ::uncomment when __CORE__\n//import java.util.Collections;\n//  ::done\n\npublic class ImportedFiles {\n\n\tprivate final List<SFile> imported;\n\tprivate final AParentFolder currentDir;\n\n\tprivate ImportedFiles(List<SFile> imported, AParentFolder currentDir) {\n\t\tthis.imported = imported;\n\t\tthis.currentDir = currentDir;\n\t}\n\n\tpublic ImportedFiles withCurrentDir(AParentFolder newCurrentDir) {\n\t\tif (newCurrentDir == null) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new ImportedFiles(imported, newCurrentDir);\n\t}\n\n\tpublic static ImportedFiles createImportedFiles(AParentFolder newCurrentDir) {\n\t\treturn new ImportedFiles(new ArrayList<SFile>(), newCurrentDir);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ImportedFiles=\" + imported + \" currentDir=\" + currentDir;\n\t}\n\n\tpublic AFile getAFile(String nameOrPath) throws IOException {\n\t\t// Log.info(\"ImportedFiles::getAFile nameOrPath = \" + nameOrPath);\n\t\t// Log.info(\"ImportedFiles::getAFile currentDir = \" + currentDir);\n\t\tfinal AParentFolder dir = currentDir;\n\t\tif (dir == null || isAbsolute(nameOrPath)) {\n\t\t\treturn new AFileRegular(new SFile(nameOrPath).getCanonicalFile());\n\t\t}\n\t\t// final File filecurrent = SecurityUtils.File(dir.getAbsoluteFile(),\n\t\t// nameOrPath);\n\t\tfinal AFile filecurrent = dir.getAFile(nameOrPath);\n\t\tLog.info(\"ImportedFiles::getAFile filecurrent = \" + filecurrent);\n\t\tif (filecurrent != null && filecurrent.isOk()) {\n\t\t\treturn filecurrent;\n\t\t}\n\t\tfor (SFile d : getPath()) {\n\t\t\tif (d.isDirectory()) {\n\t\t\t\tfinal SFile file = d.file(nameOrPath);\n\t\t\t\tif (file.exists()) {\n\t\t\t\t\treturn new AFileRegular(file.getCanonicalFile());\n\t\t\t\t}\n\t\t\t} else if (d.isFile()) {\n\t\t\t\tfinal AFileZipEntry zipEntry = new AFileZipEntry(d, nameOrPath);\n\t\t\t\tif (zipEntry.isOk()) {\n\t\t\t\t\treturn zipEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filecurrent;\n\t}\n\n\tpublic List<SFile> getPath() {\n\t\tfinal List<SFile> result = new ArrayList<>(imported);\n\t\t// ::comment when __CORE__\n\t\tresult.addAll(includePath());\n\t\tresult.addAll(SecurityUtils.getPath(SecurityUtils.PATHS_CLASSES));\n\t\t// ::done\n\t\treturn result;\n\t}\n\n\tprivate List<SFile> includePath() {\n\t\t// ::comment when __CORE__\n\t\treturn SecurityUtils.getPath(SecurityUtils.PATHS_INCLUDES);\n\t\t// ::done\n\t\t// ::uncomment when __CORE__\n\t\t// return Collections.emptyList();\n\t\t// ::done\n\t}\n\n\tprivate boolean isAbsolute(String nameOrPath) {\n\t\tfinal SFile f = new SFile(nameOrPath);\n\t\treturn f.isAbsolute();\n\t}\n\n\tpublic void add(SFile file) {\n\t\tthis.imported.add(file);\n\t}\n\n\tpublic AParentFolder getCurrentDir() {\n\t\treturn currentDir;\n\t}\n\n\tpublic FileWithSuffix getFile(String filename, String suffix) throws IOException {\n\t\tfinal int idx = filename.indexOf('~');\n\t\tfinal AFile file;\n\t\tfinal String entry;\n\t\tif (idx == -1) {\n\t\t\tfile = getAFile(filename);\n\t\t\tentry = null;\n\t\t} else {\n\t\t\tfile = getAFile(filename.substring(0, idx));\n\t\t\tentry = filename.substring(idx + 1);\n\t\t}\n\t\tif (isAllowed(file) == false)\n\t\t\treturn FileWithSuffix.none();\n\n\t\treturn new FileWithSuffix(filename, suffix, file, entry);\n\t}\n\n\tprivate boolean isAllowed(AFile file) throws IOException {\n\t\t// ::comment when __CORE__\n\t\tif (OptionFlags.ALLOW_INCLUDE)\n\t\t\treturn true;\n\n\t\tif (file != null) {\n\t\t\tfinal SFile folder = file.getSystemFolder();\n\t\t\t// System.err.println(\"canonicalPath=\" + path + \" \" + folder + \" \" +\n\t\t\t// INCLUDE_PATH);\n\t\t\tif (includePath().contains(folder))\n\t\t\t\treturn true;\n\n\t\t}\n\t\t// ::done\n\t\treturn false;\n\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.security;\n\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.imageio.stream.ImageInputStream;\nimport javax.swing.ImageIcon;\n\nimport net.sourceforge.plantuml.log.Logme;\n\n/**\n * Secure replacement for java.io.File.\n * <p>\n * This class should be used instead of java.io.File. There are few exceptions\n * (mainly in the Swing part and in the ANT task)\n * <p>\n * This class does some control access and in secure mode hide the real path of\n * file, so that it cannot be printed to end users.\n *\n */\npublic class SFile implements Comparable<SFile> {\n\n\tpublic static String separator = File.separator;\n\n\tpublic static String pathSeparator = File.pathSeparator;\n\n\tpublic static char separatorChar = File.separatorChar;\n\n\tprivate final File internal;\n\n\t@Override\n\tpublic String toString() {\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET\n\t\t\t\t|| SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)\n\t\t\treturn super.toString();\n\t\ttry {\n\t\t\treturn internal.getCanonicalPath();\n\t\t} catch (IOException e) {\n\t\t\treturn internal.getAbsolutePath();\n\t\t}\n\t}\n\n\tpublic SFile(String nameOrPath) {\n\t\tthis(new File(nameOrPath));\n\t}\n\n\tpublic SFile(String dirname, String name) {\n\t\tthis(new File(dirname, name));\n\t}\n\n\tpublic SFile(SFile basedir, String name) {\n\t\tthis(new File(basedir.internal, name));\n\t}\n\n\tpublic SFile(URI uri) {\n\t\tthis(new File(uri));\n\t}\n\n\tprivate SFile(File internal) {\n\t\tthis.internal = internal;\n\t}\n\n\tpublic static SFile fromFile(File internal) {\n\t\tif (internal == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new SFile(internal);\n\t}\n\n\tpublic SFile file(String name) {\n\t\treturn new SFile(this, name);\n\t}\n\n\tpublic boolean exists() {\n\t\tif (internal != null && isFileOk())\n\t\t\treturn internal.exists();\n\t\treturn false;\n\t}\n\n\tpublic SFile getCanonicalFile() throws IOException {\n\t\treturn new SFile(internal.getCanonicalFile());\n\t}\n\n\tpublic boolean isAbsolute() {\n\t\treturn internal != null && internal.isAbsolute();\n\t}\n\n\tpublic boolean isDirectory() {\n\t\treturn internal != null && internal.exists() && internal.isDirectory();\n\t}\n\n\tpublic String getName() {\n\t\treturn internal.getName();\n\t}\n\n\tpublic boolean isFile() {\n\t\treturn internal != null && internal.isFile();\n\t}\n\n\tpublic long lastModified() {\n\t\treturn internal.lastModified();\n\t}\n\n\tpublic int compareTo(SFile other) {\n\t\treturn this.internal.compareTo(other.internal);\n\t}\n\n\tpublic String getPath() {\n\t\treturn internal.getPath();\n\t}\n\n\tpublic long length() {\n\t\treturn internal.length();\n\t}\n\n\tpublic boolean canWrite() {\n\t\treturn internal.canWrite();\n\t}\n\n\tpublic void setWritable(boolean b) {\n\t\tinternal.setWritable(b);\n\t}\n\n\tpublic void delete() {\n\t\tinternal.delete();\n\t}\n\n\tpublic Collection<SFile> listFiles() {\n\t\tfinal File[] tmp = internal.listFiles();\n\t\tif (tmp == null)\n\t\t\treturn Collections.emptyList();\n\n\t\tfinal List<SFile> result = new ArrayList<>(tmp.length);\n\t\tfor (File f : tmp)\n\t\t\tresult.add(new SFile(f));\n\n\t\treturn Collections.unmodifiableCollection(result);\n\t}\n\n\tpublic String[] list() {\n\t\treturn internal.list();\n\t}\n\n\tpublic SFile getAbsoluteFile() {\n\t\treturn new SFile(internal.getAbsoluteFile());\n\t}\n\n\tpublic SFile getParentFile() {\n\t\treturn new SFile(internal.getParentFile());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn internal.hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn internal.equals(((SFile) obj).internal);\n\t}\n\n\tpublic String getAbsolutePath() {\n\t\treturn internal.getAbsolutePath();\n\t}\n\n\tpublic String getPrintablePath() {\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE) {\n\t\t\ttry {\n\t\t\t\treturn internal.getCanonicalPath();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic boolean canRead() {\n\t\treturn internal.canRead();\n\t}\n\n\tpublic void deleteOnExit() {\n\t\tinternal.deleteOnExit();\n\t}\n\n\tpublic void mkdirs() {\n\t\tinternal.mkdirs();\n\t}\n\n\tpublic static SFile createTempFile(String prefix, String suffix) throws IOException {\n\t\treturn new SFile(File.createTempFile(prefix, suffix));\n\t}\n\n\tpublic URI toURI() {\n\t\treturn internal.toURI();\n\t}\n\n\tpublic boolean renameTo(SFile dest) {\n\t\treturn internal.renameTo(dest.internal);\n\t}\n\n\t/**\n\t * Check SecurityProfile to see if this file can be open.\n\t */\n\tprivate boolean isFileOk() {\n\t\t// ::comment when __CORE__\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)\n\t\t\t// In SANDBOX, we cannot read any files\n\t\t\treturn false;\n\n\t\t// In any case SFile should not access the security folders\n\t\t// (the files must be handled internally)\n\t\ttry {\n\t\t\tif (isDenied())\n\t\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\t// Files in \"plantuml.include.path\" and \"plantuml.allowlist.path\" are ok.\n\t\tif (isInAllowList(SecurityUtils.getPath(SecurityUtils.PATHS_INCLUDES)))\n\t\t\treturn true;\n\n\t\tif (isInAllowList(SecurityUtils.getPath(SecurityUtils.ALLOWLIST_LOCAL_PATHS)))\n\t\t\treturn true;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET)\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() != SecurityProfile.UNSECURE) {\n\t\t\t// For UNSECURE, we did not do those checks\n\t\t\tfinal String path = getCleanPathSecure();\n\t\t\tif (path.startsWith(\"/etc/\") || path.startsWith(\"/dev/\") || path.startsWith(\"/boot/\")\n\t\t\t\t\t|| path.startsWith(\"/proc/\") || path.startsWith(\"/sys/\"))\n\t\t\t\treturn false;\n\n\t\t\tif (path.startsWith(\"//\"))\n\t\t\t\treturn false;\n\n\t\t}\n\t\t// ::done\n\t\treturn true;\n\t}\n\n\tprivate boolean isInAllowList(List<SFile> allowlist) {\n\t\tfinal String path = getCleanPathSecure();\n\t\tfor (SFile allow : allowlist)\n\t\t\tif (path.startsWith(allow.getCleanPathSecure()))\n\t\t\t\t// File directory is in the allowlist\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks, if the SFile is inside the folder (-structure) of the security area.\n\t *\n\t * @return true, if the file is not allowed to read/write\n\t * @throws IOException If an I/O error occurs, which is possible because the\n\t *                     check the pathname may require filesystem queries\n\t */\n\t// ::comment when __CORE__\n\tprivate boolean isDenied() throws IOException {\n\t\tSFile securityPath = SecurityUtils.getSecurityPath();\n\t\tif (securityPath == null)\n\t\t\treturn false;\n\t\treturn getSanitizedPath().startsWith(securityPath.getSanitizedPath());\n\t}\n\t// ::done\n\n\t/**\n\t * Returns a sanitized, canonical and normalized Path to a file.\n\t *\n\t * @return the Path\n\t * @throws IOException If an I/O error occurs, which is possible because the\n\t *                     construction of the canonical pathname may require\n\t *                     filesystem queries\n\t * @see #getCleanPathSecure()\n\t * @see File#getCanonicalPath()\n\t * @see Path#normalize()\n\t */\n\tprivate Path getSanitizedPath() throws IOException {\n\t\treturn Paths.get(new File(getCleanPathSecure()).getCanonicalPath()).normalize();\n\t}\n\n\tprivate String getCleanPathSecure() {\n\t\tString result = internal.getAbsolutePath();\n\t\tresult = result.replace(\"\\0\", \"\");\n\t\tresult = result.replace(\"\\\\\\\\\", \"/\");\n\t\treturn result;\n\t}\n\n\t// Reading\n\t// http://forum.plantuml.net/9048/img-tag-for-sequence-diagram-participants-does-always-render\n\tpublic BufferedImage readRasterImageFromFile() {\n\t\t// https://www.experts-exchange.com/questions/26171948/Why-are-ImageIO-read-images-losing-their-transparency.html\n\t\t// https://stackoverflow.com/questions/18743790/can-java-load-images-with-transparency\n\t\tif (isFileOk())\n\t\t\ttry {\n\t\t\t\t// ::comment when __CORE__\n\t\t\t\tif (internal.getName().endsWith(\".webp\"))\n\t\t\t\t\treturn readWebp();\n\t\t\t\telse\n\t\t\t\t\t// ::done\n\t\t\t\t\treturn SecurityUtils.readRasterImage(new ImageIcon(this.getAbsolutePath()));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t// ::comment when __CORE__\n\tprivate BufferedImage readWebp() throws IOException {\n\t\ttry (InputStream is = openFile()) {\n\t\t\tfinal int riff = read32(is);\n\t\t\tif (riff != 0x46464952)\n\t\t\t\treturn null;\n\t\t\tfinal int len1 = read32(is);\n\t\t\tfinal int webp = read32(is);\n\t\t\tif (webp != 0x50424557)\n\t\t\t\treturn null;\n\t\t\tfinal int vp8_ = read32(is);\n\t\t\tif (vp8_ != 0x20385056)\n\t\t\t\treturn null;\n\t\t\tfinal int len2 = read32(is);\n\t\t\tif (len1 != len2 + 12)\n\t\t\t\treturn null;\n\n\t\t\treturn getBufferedImageFromWebpButHeader(is);\n\t\t}\n\t}\n\n\tprivate int read32(InputStream is) throws IOException {\n\t\treturn (is.read() << 0) + (is.read() << 8) + (is.read() << 16) + (is.read() << 24);\n\t}\n\n\tpublic static BufferedImage getBufferedImageFromWebpButHeader(InputStream is) {\n\t\tif (is == null)\n\t\t\treturn null;\n\t\ttry {\n\t\t\tfinal Class<?> clVP8Decoder = Class.forName(\"net.sourceforge.plantuml.webp.VP8Decoder\");\n\t\t\tfinal Object vp8Decoder = clVP8Decoder.getDeclaredConstructor().newInstance();\n\t\t\t// final VP8Decoder vp8Decoder = new VP8Decoder();\n\t\t\tfinal Method decodeFrame = clVP8Decoder.getMethod(\"decodeFrame\", ImageInputStream.class);\n\t\t\tfinal ImageInputStream iis = SImageIO.createImageInputStream(is);\n\t\t\tdecodeFrame.invoke(vp8Decoder, iis);\n\t\t\t// vp8Decoder.decodeFrame(iis);\n\t\t\tiis.close();\n\t\t\tfinal Object frame = clVP8Decoder.getMethod(\"getFrame\").invoke(vp8Decoder);\n\t\t\treturn (BufferedImage) frame.getClass().getMethod(\"getBufferedImage\").invoke(frame);\n\t\t\t// final VP8Frame frame = vp8Decoder.getFrame();\n\t\t\t// return frame.getBufferedImage();\n\t\t} catch (Exception e) {\n\t\t\tLogme.error(e);\n\t\t\treturn null;\n\t\t}\n\t}\n\t// ::done\n\n\tpublic BufferedReader openBufferedReader() {\n\t\tif (isFileOk()) {\n\t\t\ttry {\n\t\t\t\treturn new BufferedReader(new FileReader(internal));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic File conv() {\n\t\treturn internal;\n\t}\n\n\tpublic InputStream openFile() {\n\t\tif (isFileOk())\n\t\t\ttry {\n\t\t\t\treturn new BufferedInputStream(new FileInputStream(internal));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t// ::comment when __CORE__\n\t// Writing\n\tpublic BufferedOutputStream createBufferedOutputStream() throws FileNotFoundException {\n\t\treturn new BufferedOutputStream(new FileOutputStream(internal));\n\t}\n\n\tpublic PrintWriter createPrintWriter() throws FileNotFoundException {\n\t\treturn new PrintWriter(internal);\n\t}\n\n\tpublic PrintWriter createPrintWriter(String charset) throws FileNotFoundException, UnsupportedEncodingException {\n\t\treturn new PrintWriter(internal, charset);\n\t}\n\n\tpublic FileOutputStream createFileOutputStream() throws FileNotFoundException {\n\t\treturn new FileOutputStream(internal);\n\t}\n\n\tpublic FileOutputStream createFileOutputStream(boolean append) throws FileNotFoundException {\n\t\treturn new FileOutputStream(internal, append);\n\t}\n\n\tpublic PrintStream createPrintStream() throws FileNotFoundException {\n\t\treturn new PrintStream(internal);\n\t}\n\n\tpublic PrintStream createPrintStream(String charset) throws FileNotFoundException, UnsupportedEncodingException {\n\t\treturn new PrintStream(internal, charset);\n\t}\n\n\tpublic PrintStream createPrintStream(Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n\t\treturn new PrintStream(internal, charset.name());\n\t}\n\t// ::done\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.security;\n\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.swing.ImageIcon;\n\nimport net.sourceforge.plantuml.StringUtils;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.authentication.SecurityAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.SecurityAuthentication;\nimport net.sourceforge.plantuml.security.authentication.SecurityCredentials;\n//::uncomment when __CORE__\n//import net.sourceforge.plantuml.FileUtils;\n//::done\n\n/**\n * Secure replacement for java.net.URL.\n * <p>\n * This class should be used instead of java.net.URL.\n * <p>\n * This class does some control access and manages access-tokens via URL. If a\n * URL contains a access-token, similar to a user prefix, SURL loads the\n * authorization config for this user-token and passes the credentials to the\n * host.\n * <p>\n * Example:<br/>\n * \n * <pre>\n *     SURL url = SURL.create (\"https://jenkins-access@jenkins.mycompany.com/api/json\")\n * </pre>\n * \n * The {@code jenkins-access} will checked against the Security context access\n * token configuration. If a configuration exists for this token name, the token\n * will be removed from the URL and the credentials will be added to the\n * headers. If the token is not found, the URL remains as it is and no separate\n * authentication will be performed.\n * <p>\n * TODO: Some methods should be moved to a HttpClient implementation, because\n * SURL is not the valid class to manage it. <br/>\n * TODO: BAD_HOSTS implementation should be reviewed and moved to HttpClient\n * implementation with a circuit-breaker. <br/>\n * TODO: Token expiration with refresh should be implemented in future. <br/>\n */\npublic class SURL {\n\n\t/**\n\t * Indicates, that we have no authentication to access the URL.\n\t */\n\tpublic static final String WITHOUT_AUTHENTICATION = SecurityUtils.NO_CREDENTIALS;\n\n\t/**\n\t * Internal URL, maybe cleaned from user-token.\n\t */\n\tprivate final URL internal;\n\n\t/**\n\t * Assigned credentials to this URL.\n\t */\n\tprivate final String securityIdentifier;\n\n\tprivate SURL(URL url, String securityIdentifier) {\n\t\tthis.internal = Objects.requireNonNull(url);\n\t\tthis.securityIdentifier = Objects.requireNonNull(securityIdentifier);\n\t}\n\n\t/**\n\t * Create a secure URL from a String.\n\t * <p>\n\t * The url must be http or https. Return null in case of error or if\n\t * <code>url</code> is null\n\t * \n\t * @param url plain url starting by http:// or https//\n\t * @return the secure URL or null\n\t */\n\tpublic static SURL create(String url) {\n\t\tif (url == null)\n\t\t\treturn null;\n\n\t\tif (url.startsWith(\"http://\") || url.startsWith(\"https://\"))\n\t\t\ttry {\n\t\t\t\treturn create(new URL(url));\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create a secure URL from a <code>java.net.URL</code> object.\n\t * <p>\n\t * It takes into account credentials.\n\t * \n\t * @param url\n\t * @return the secure URL\n\t * @throws MalformedURLException if <code>url</code> is null\n\t */\n\tpublic static SURL create(URL url) throws MalformedURLException {\n\t\tif (url == null)\n\t\t\tthrow new MalformedURLException(\"URL cannot be null\");\n\n\t\t// ::comment when __CORE__\n\t\tfinal String credentialId = url.getUserInfo();\n\n\t\tif (credentialId == null || credentialId.indexOf(':') > 0)\n\t\t\t// No user info at all, or a user with password (This is a legacy BasicAuth\n\t\t\t// access, and we bypass it):\n\t\t\treturn new SURL(url, WITHOUT_AUTHENTICATION);\n\t\telse if (SecurityUtils.existsSecurityCredentials(credentialId))\n\t\t\t// Given userInfo, but without a password. We try to find SecurityCredentials\n\t\t\treturn new SURL(removeUserInfo(url), credentialId);\n\t\telse\n\t\t\t// ::done\n\t\t\treturn new SURL(url, WITHOUT_AUTHENTICATION);\n\t}\n\n\t// ::uncomment when __CORE__\n//\tpublic InputStream openStream() {\n//\ttry {\n//\t\treturn internal.openStream();\n//\t} catch (IOException e) {\n//\t\tSystem.err.println(\"SURL::openStream \" + e);\n//\t\treturn null;\n//\t}\n//}\n//public byte[] getBytes() {\n//\tfinal InputStream is = openStream();\n//\tif (is != null)\n//\t\ttry {\n//\t\t\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n//\t\t\tFileUtils.copyInternal(is, baos, true);\n//\t\t\treturn baos.toByteArray();\n//\t\t} catch (IOException e) {\n//\t\t\tSystem.err.println(\"SURL::getBytes \" + e);\n//\t\t}\n//\treturn null;\n//}\n\t// ::done\n\n\tpublic BufferedImage readRasterImageFromURL() {\n\t\tif (isUrlOk())\n\t\t\ttry {\n\t\t\t\tfinal byte[] bytes = getBytes();\n\t\t\t\tif (bytes == null || bytes.length == 0)\n\t\t\t\t\treturn null;\n\t\t\t\tfinal ImageIcon tmp = new ImageIcon(bytes);\n\t\t\t\treturn SecurityUtils.readRasterImage(tmp);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check SecurityProfile to see if this URL can be opened.\n\t */\n\tprivate boolean isUrlOk() {\n\t\t// ::comment when __CORE__\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)\n\t\t\t// In SANDBOX, we cannot read any URL\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.LEGACY)\n\t\t\treturn true;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE)\n\t\t\t// We are UNSECURE anyway\n\t\t\treturn true;\n\n\t\tif (isInUrlAllowList())\n\t\t\t// ::done\n\t\t\treturn true;\n\t\t// ::comment when __CORE__\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET) {\n\t\t\tif (forbiddenURL(cleanPath(internal.toString())))\n\t\t\t\treturn false;\n\n\t\t\tfinal int port = internal.getPort();\n\t\t\t// Using INTERNET profile, port 80 and 443 are ok\n\t\t\treturn port == 80 || port == 443 || port == -1;\n\t\t}\n\t\treturn false;\n\t\t// ::done\n\t}\n\n\t// ::comment when __CORE__\n\t/**\n\t * Regex to remove the UserInfo part from a URL.\n\t */\n\tprivate static final Pattern PATTERN_USERINFO = Pattern.compile(\"(^https?://)([-_0-9a-zA-Z]+@)([^@]*)$\");\n\n\tprivate static final ExecutorService EXE = Executors.newCachedThreadPool(new ThreadFactory() {\n\t\tpublic Thread newThread(Runnable r) {\n\t\t\tfinal Thread t = Executors.defaultThreadFactory().newThread(r);\n\t\t\tt.setDaemon(true);\n\t\t\treturn t;\n\t\t}\n\t});\n\n\tprivate static final Map<String, Long> BAD_HOSTS = new ConcurrentHashMap<String, Long>();\n\n\t/**\n\t * Creates a URL without UserInfo part and without SecurityCredentials.\n\t *\n\t * @param url plain URL\n\t * @return SURL without any user credential information.\n\t * @throws MalformedURLException\n\t */\n\tstatic SURL createWithoutUser(URL url) throws MalformedURLException {\n\t\treturn new SURL(removeUserInfo(url), WITHOUT_AUTHENTICATION);\n\t}\n\n\t/**\n\t * Clears the bad hosts cache.\n\t * <p>\n\t * In some test cases (and maybe also needed for other functionality) the bad\n\t * hosts cache must be cleared.<br/>\n\t * E.g., in a test we check the failure on missing credentials and then a test\n\t * with existing credentials. With a bad host cache the second test will fail,\n\t * or we have unpredicted results.\n\t */\n\tstatic void resetBadHosts() {\n\t\tBAD_HOSTS.clear();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn internal.toString();\n\t}\n\n\tprivate boolean forbiddenURL(String full) {\n\t\t// Thanks to Agasthya Kasturi\n\t\tif (full.contains(\"@\"))\n\t\t\treturn true;\n\t\tif (full.startsWith(\"https://\") == false && full.startsWith(\"http://\") == false)\n\t\t\treturn true;\n\t\tif (full.matches(\"^https?://[-#.0-9:\\\\[\\\\]+]+/.*\"))\n\t\t\treturn true;\n\t\tif (full.matches(\"^https?://[^.]+/.*\"))\n\t\t\treturn true;\n\t\tif (full.matches(\"^https?://[^.]+$\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate boolean isInUrlAllowList() {\n\t\tfinal String full = cleanPath(internal.toString());\n\t\t// Thanks to Agasthya Kasturi\n\t\tif (full.contains(\"@\"))\n\t\t\treturn false;\n\t\tfor (String allow : getUrlAllowList())\n\t\t\tif (full.startsWith(cleanPath(allow)))\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tprivate String cleanPath(String path) {\n\t\t// Remove user information, because we don't like to store user/password or\n\t\t// userTokens in allow-list\n\t\tpath = removeUserInfoFromUrlPath(path);\n\t\tpath = path.trim().toLowerCase(Locale.US);\n\t\t// We simplify/normalize the url, removing default ports\n\t\tpath = path.replace(\":80/\", \"\");\n\t\tpath = path.replace(\":443/\", \"\");\n\t\treturn path;\n\t}\n\n\tprivate List<String> getUrlAllowList() {\n\t\tfinal String env = SecurityUtils.getenv(SecurityUtils.ALLOWLIST_URL);\n\t\tif (env == null)\n\t\t\treturn Collections.emptyList();\n\n\t\treturn Arrays.asList(StringUtils.eventuallyRemoveStartingAndEndingDoubleQuote(env).split(\";\"));\n\t}\n\n\t/**\n\t * Reads from an endpoint (with configured credentials and proxy) the response\n\t * as blob.\n\t * <p>\n\t * This method allows access to an endpoint, with a configured\n\t * SecurityCredentials object. The credentials will load on the fly and\n\t * authentication fetched from an authentication-manager. Caching of tokens is\n\t * not supported.\n\t * <p>\n\t * authors: Alain Corbiere, Aljoscha Rittner\n\t *\n\t * @return data loaded data from endpoint\n\t */\n\tpublic byte[] getBytes() {\n\t\tif (isUrlOk() == false)\n\t\t\treturn null;\n\n\t\tfinal SecurityCredentials credentials = SecurityUtils.loadSecurityCredentials(securityIdentifier);\n\t\tfinal SecurityAuthentication authentication = SecurityUtils.getAuthenticationManager(credentials)\n\t\t\t\t.create(credentials);\n\t\ttry {\n\t\t\tfinal String host = internal.getHost();\n\t\t\tfinal Long bad = BAD_HOSTS.get(host);\n\t\t\tif (bad != null) {\n\t\t\t\tif ((System.currentTimeMillis() - bad) < 1000L * 60)\n\t\t\t\t\treturn null;\n\t\t\t\tBAD_HOSTS.remove(host);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfinal Future<byte[]> result = EXE\n\t\t\t\t\t\t.submit(requestWithGetAndResponse(internal, credentials.getProxy(), authentication, null));\n\t\t\t\tfinal byte[] data = result.get(SecurityUtils.getSecurityProfile().getTimeout(), TimeUnit.MILLISECONDS);\n\t\t\t\tif (data != null)\n\t\t\t\t\treturn data;\n\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(\"issue \" + host + \" \" + e);\n\t\t\t}\n\n\t\t\tBAD_HOSTS.put(host, System.currentTimeMillis());\n\t\t\treturn null;\n\t\t} finally {\n\t\t\t// clean up. We don't cache tokens, no expire handling. All time a re-request.\n\t\t\tcredentials.eraseCredentials();\n\t\t\tauthentication.eraseCredentials();\n\t\t}\n\t}\n\n\t/**\n\t * Reads from an endpoint with a given authentication and proxy the response as\n\t * blob.\n\t * <p>\n\t * This method allows a parametrized access to an endpoint, without a configured\n\t * SecurityCredentials object. This is useful to access internally identity\n\t * providers (IDP), or authorization servers (to request access tokens).\n\t * <p>\n\t * This method don't use the \"bad-host\" functionality, because the access to\n\t * infrastructure services should not be obfuscated by some internal management.\n\t * <p>\n\t * <strong>Please don't use this method directly from DSL scripts.</strong>\n\t *\n\t * @param authentication authentication object data. Caller is responsible to\n\t *                       erase credentials\n\t * @param proxy          proxy configuration\n\t * @param headers        additional headers, if needed\n\t * @return loaded data from endpoint\n\t */\n\tprivate byte[] getBytes(Proxy proxy, SecurityAuthentication authentication, Map<String, Object> headers) {\n\t\tif (isUrlOk() == false)\n\t\t\treturn null;\n\n\t\tfinal Future<byte[]> result = EXE.submit(requestWithGetAndResponse(internal, proxy, authentication, headers));\n\n\t\ttry {\n\t\t\treturn result.get(SecurityUtils.getSecurityProfile().getTimeout(), TimeUnit.MILLISECONDS);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"SURL response issue to \" + internal.getHost() + \" \" + e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Post to an endpoint with a given authentication and proxy the response as\n\t * blob.\n\t * <p>\n\t * This method allows a parametrized access to an endpoint, without a configured\n\t * SecurityCredentials object. This is useful to access internally identity\n\t * providers (IDP), or authorization servers (to request access tokens).\n\t * <p>\n\t * This method don't use the \"bad-host\" functionality, because the access to\n\t * infrastructure services should not be obfuscated by some internal management.\n\t * <p>\n\t * <strong>Please don't use this method directly from DSL scripts.</strong>\n\t *\n\t * @param authentication authentication object data. Caller is responsible to\n\t *                       erase credentials\n\t * @param proxy          proxy configuration\n\t * @param data           content to post\n\t * @param headers        headers, if needed\n\t * @return loaded data from endpoint\n\t */\n\tpublic byte[] getBytesOnPost(Proxy proxy, SecurityAuthentication authentication, String data,\n\t\t\tMap<String, Object> headers) {\n\t\tif (isUrlOk() == false)\n\t\t\treturn null;\n\n\t\tfinal Future<byte[]> result = EXE\n\t\t\t\t.submit(requestWithPostAndResponse(internal, proxy, authentication, data, headers));\n\n\t\ttry {\n\t\t\treturn result.get(SecurityUtils.getSecurityProfile().getTimeout(), TimeUnit.MILLISECONDS);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"SURL response issue to \" + internal.getHost() + \" \" + e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a GET request and response handler\n\t * \n\t * @param url            URL to request\n\t * @param proxy          proxy to apply\n\t * @param authentication the authentication to use\n\t * @param headers        additional headers, if needed\n\t * @return the callable handler.\n\t */\n\tprivate static Callable<byte[]> requestWithGetAndResponse(final URL url, final Proxy proxy,\n\t\t\tfinal SecurityAuthentication authentication, final Map<String, Object> headers) {\n\t\treturn new Callable<byte[]>() {\n\n\t\t\tprivate HttpURLConnection openConnection(final URL url) throws IOException {\n\t\t\t\t// Add proxy, if passed throw parameters\n\t\t\t\tfinal URLConnection connection = proxy == null ? url.openConnection() : url.openConnection(proxy);\n\t\t\t\tif (connection == null)\n\t\t\t\t\treturn null;\n\n\t\t\t\tfinal HttpURLConnection http = (HttpURLConnection) connection;\n\n\t\t\t\tapplyEndpointAccessAuthentication(http, authentication);\n\t\t\t\tapplyAdditionalHeaders(http, headers);\n\t\t\t\treturn http;\n\t\t\t}\n\n\t\t\tpublic byte[] call() throws IOException {\n\t\t\t\tHttpURLConnection http = openConnection(url);\n\t\t\t\tfinal int responseCode = http.getResponseCode();\n\n\t\t\t\tif (responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n\t\t\t\t\t\t|| responseCode == HttpURLConnection.HTTP_MOVED_PERM) {\n\t\t\t\t\tfinal String newUrl = http.getHeaderField(\"Location\");\n\t\t\t\t\thttp = openConnection(new URL(newUrl));\n\t\t\t\t}\n\n\t\t\t\treturn retrieveResponseAsBytes(http);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Creates a POST request and response handler with a simple String content. The\n\t * content will be identified as form or JSON data. The charset encoding can be\n\t * set by header parameters or will be set to UTF-8. The method to some fancy\n\t * logic to simplify it for the user.\n\t * \n\t * @param url            URL to request via POST method\n\t * @param proxy          proxy to apply\n\t * @param authentication the authentication to use\n\t * @param headers        additional headers, if needed\n\t * @return the callable handler.\n\t */\n\tprivate static Callable<byte[]> requestWithPostAndResponse(final URL url, final Proxy proxy,\n\t\t\tfinal SecurityAuthentication authentication, final String data, final Map<String, Object> headers) {\n\t\treturn new Callable<byte[]>() {\n\t\t\tpublic byte[] call() throws IOException {\n\t\t\t\t// Add proxy, if passed throw parameters\n\t\t\t\tfinal URLConnection connection = proxy == null ? url.openConnection() : url.openConnection(proxy);\n\t\t\t\tif (connection == null)\n\t\t\t\t\treturn null;\n\n\t\t\t\tfinal boolean withContent = StringUtils.isNotEmpty(data);\n\n\t\t\t\tfinal HttpURLConnection http = (HttpURLConnection) connection;\n\t\t\t\thttp.setRequestMethod(\"POST\");\n\t\t\t\tif (withContent)\n\t\t\t\t\thttp.setDoOutput(true);\n\n\t\t\t\tapplyEndpointAccessAuthentication(http, authentication);\n\t\t\t\tapplyAdditionalHeaders(http, headers);\n\n\t\t\t\tfinal Charset charSet = extractCharset(http.getRequestProperty(\"Content-Type\"));\n\n\t\t\t\tif (withContent)\n\t\t\t\t\tsendRequestAsBytes(http, data.getBytes(charSet != null ? charSet : StandardCharsets.UTF_8));\n\n\t\t\t\treturn retrieveResponseAsBytes(http);\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate static Charset extractCharset(String contentType) {\n\t\tif (StringUtils.isEmpty(contentType))\n\t\t\treturn null;\n\n\t\tfinal Matcher matcher = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\").matcher(contentType);\n\t\tif (matcher.find())\n\t\t\ttry {\n\t\t\t\treturn Charset.forName(matcher.group(1));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Loads a response from an endpoint as a byte[] array.\n\t *\n\t * @param connection the URL connection\n\t * @return the loaded byte arrays\n\t * @throws IOException an exception, if the connection cannot establish or the\n\t *                     download was broken\n\t */\n\tprivate static byte[] retrieveResponseAsBytes(HttpURLConnection connection) throws IOException {\n\t\tfinal int responseCode = connection.getResponseCode();\n\t\tif (responseCode < HttpURLConnection.HTTP_BAD_REQUEST) {\n\t\t\ttry (InputStream input = connection.getInputStream()) {\n\t\t\t\treturn retrieveData(input);\n\t\t\t}\n\t\t} else {\n\t\t\ttry (InputStream error = connection.getErrorStream()) {\n\t\t\t\tfinal byte[] bytes = retrieveData(error);\n\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\"HTTP error \" + responseCode + \" with \" + new String(bytes, StandardCharsets.UTF_8));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reads data in a byte[] array.\n\t * \n\t * @param input input stream\n\t * @return byte data\n\t * @throws IOException if something went wrong\n\t */\n\tprivate static byte[] retrieveData(InputStream input) throws IOException {\n\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tfinal byte[] buffer = new byte[1024];\n\t\tint read;\n\t\twhile ((read = input.read(buffer)) > 0) {\n\t\t\tout.write(buffer, 0, read);\n\t\t}\n\t\tout.close();\n\t\treturn out.toByteArray();\n\t}\n\n\t/**\n\t * Sends a request content payload to an endpoint.\n\t * \n\t * @param connection HTTP connection\n\t * @param data       data as byte array\n\t * @throws IOException if something went wrong\n\t */\n\tprivate static void sendRequestAsBytes(HttpURLConnection connection, byte[] data) throws IOException {\n\t\tconnection.setFixedLengthStreamingMode(data.length);\n\t\ttry (OutputStream os = connection.getOutputStream()) {\n\t\t\tos.write(data);\n\t\t}\n\t}\n\n\tpublic InputStream openStream() {\n\t\tif (isUrlOk()) {\n\t\t\tfinal byte[] data = getBytes();\n\t\t\tif (data != null)\n\t\t\t\treturn new ByteArrayInputStream(data);\n\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Informs, if SecurityCredentials are configured for this connection.\n\t *\n\t * @return true, if credentials will be used for a connection\n\t */\n\tpublic boolean isAuthorizationConfigured() {\n\t\treturn WITHOUT_AUTHENTICATION.equals(securityIdentifier) == false;\n\t}\n\n\t/**\n\t * Applies the given authentication data to the http connection.\n\t *\n\t * @param http           HTTP URL connection (must be an encrypted https-TLS/SSL\n\t *                       connection, or http must be activated with a property)\n\t * @param authentication the data to request the access\n\t * @see SecurityUtils#getAccessInterceptor(SecurityAuthentication)\n\t * @see SecurityUtils#isNonSSLAuthenticationAllowed()\n\t */\n\tprivate static void applyEndpointAccessAuthentication(URLConnection http, SecurityAuthentication authentication) {\n\t\tif (authentication.isPublic())\n\t\t\t// Shortcut: No need to apply authentication.\n\t\t\treturn;\n\n\t\tif (http instanceof HttpsURLConnection || SecurityUtils.isNonSSLAuthenticationAllowed()) {\n\t\t\tSecurityAccessInterceptor accessInterceptor = SecurityUtils.getAccessInterceptor(authentication);\n\t\t\taccessInterceptor.apply(authentication, http);\n\t\t} else {\n\t\t\t// We cannot allow applying secret tokens on plain connections. Everyone can\n\t\t\t// read the data.\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"The transport of authentication data over an unencrypted http connection is not allowed\");\n\t\t}\n\t}\n\n\t/**\n\t * Set the headers for a URL connection\n\t * \n\t * @param headers map Keys with values (can be String or list of String)\n\t */\n\tprivate static void applyAdditionalHeaders(URLConnection http, Map<String, Object> headers) {\n\t\tif (headers == null || headers.isEmpty())\n\t\t\treturn;\n\n\t\tfor (Map.Entry<String, Object> header : headers.entrySet()) {\n\t\t\tfinal Object value = header.getValue();\n\t\t\tif (value instanceof String)\n\t\t\t\thttp.setRequestProperty(header.getKey(), (String) value);\n\t\t\telse if (value instanceof List)\n\t\t\t\tfor (Object item : (List<?>) value)\n\t\t\t\t\tif (item != null)\n\t\t\t\t\t\thttp.addRequestProperty(header.getKey(), item.toString());\n\n\t\t}\n\t}\n\n\t/**\n\t * Removes the userInfo part from the URL, because we want to use the\n\t * SecurityCredentials instead.\n\t * \n\t * @param url URL with UserInfo part\n\t * @return url without UserInfo part\n\t * @throws MalformedURLException\n\t */\n\tprivate static URL removeUserInfo(URL url) throws MalformedURLException {\n\t\treturn new URL(removeUserInfoFromUrlPath(url.toExternalForm()));\n\t}\n\n\t/**\n\t * Removes the userInfo part from the URL, because we want to use the\n\t * SecurityCredentials instead.\n\t * \n\t * @param url URL with UserInfo part\n\t * @return url without UserInfo part\n\t */\n\tprivate static String removeUserInfoFromUrlPath(String url) {\n\t\t// Simple solution:\n\t\tfinal Matcher matcher = PATTERN_USERINFO.matcher(url);\n\t\tif (matcher.find())\n\t\t\treturn matcher.replaceFirst(\"$1$3\");\n\n\t\treturn url;\n\t}\n\t// ::done\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.security;\n\n/**\n * There are 4 different security profile defined.\n * <p>\n * The security profile to be used is set at the launch of PlantUML and cannot\n * be changed by users. The security profile defines what an instance of\n * PlantUML is allowed to do:<br>\n * - access some local file <br>\n * - connection to some remote URL <br>\n * - print some technical information to the users.\n * <p>\n * <p>\n * The security profile is defined: <br>\n * - either by an environment variable<br>\n * - or an option at command line\n * <p>\n * There is also a default value, which is LEGACY in this current\n * implementation.\n * \n */\npublic enum SecurityProfile {\n    // ::remove folder when __HAXE__\n\n\t/**\n\t * Running in SANDBOX mode is completely secure. No local file can be read\n\t * (except dot executable) No remote URL access can be used No technical\n\t * information are print to users.\n\t * <p>\n\t * This mode is defined for test and debug, since it's not very useful for\n\t * users. However, you can use it if you need to.\n\t */\n\tSANDBOX,\n\n\t/**\n\t * \n\t */\n\tALLOWLIST,\n\n\t/**\n\t * This mode is designed for PlantUML running in a web server.\n\t * \n\t */\n\tINTERNET,\n\n\t/**\n\t * This mode reproduce old PlantUML version behaviour.\n\t * <p>\n\t * Right now, this is the default Security Profile but this will be removed from\n\t * future version because it is now full secure, especially on Internet server.\n\t */\n\tLEGACY,\n\n\t/**\n\t * Running in UNSECURE mode means that PlantUML can access to any local file and\n\t * can connect to any URL.\n\t * <p>\n\t * Some technical information (file path, Java version) are also printed in some\n\t * error messages. This is not an issue if you are running PlantUML locally. But\n\t * you should not use this mode if PlantUML is running on some server,\n\t * especially if the server is accessible from Internet.\n\t */\n\tUNSECURE;\n\n\t/**\n\t * Initialize the default value.\n\t * <p>\n\t * It search in some config variable if the user has defined a some default\n\t * value.\n\t * \n\t * @return the value\n\t */\n\tstatic SecurityProfile init() {\n\t\t// ::comment when __CORE__\n\t\tfinal String env = SecurityUtils.getenv(\"PLANTUML_SECURITY_PROFILE\");\n\t\tif (\"SANDBOX\".equalsIgnoreCase(env))\n\t\t\treturn SANDBOX;\n\t\telse if (\"ALLOWLIST\".equalsIgnoreCase(env))\n\t\t\treturn ALLOWLIST;\n\t\telse if (\"INTERNET\".equalsIgnoreCase(env))\n\t\t\treturn INTERNET;\n\t\telse if (\"UNSECURE\".equalsIgnoreCase(env))\n\t\t\t// ::done\n\t\t\treturn UNSECURE;\n\t\t// ::comment when __CORE__\n\n\t\treturn LEGACY;\n\t\t// ::done\n\t}\n\n\t/**\n\t * A Human understandable description.\n\t */\n\tpublic String longDescription() {\n\t\tswitch (this) {\n\t\tcase SANDBOX:\n\t\t\treturn \"This is completely safe: no access to local files or to distant URL.\";\n\t\tcase ALLOWLIST:\n\t\t\treturn \"Some local resource may be accessible.\";\n\t\tcase INTERNET:\n\t\t\treturn \"<i>Mode designed for server connected to Internet.\";\n\t\tcase LEGACY:\n\t\t\treturn \"<b>Warning: this mode will be removed in future version\";\n\t\tcase UNSECURE:\n\t\t\treturn \"<b>Make sure that this server is not accessible from Internet\";\n\t\t}\n\t\treturn \"<i>This is completely safe: no access on local files or on distant URL.\";\n\t}\n\n\t/**\n\t * Retrieve the timeout for URL.\n\t */\n\tpublic long getTimeout() {\n\t\tswitch (this) {\n\t\tcase SANDBOX:\n\t\t\treturn 1000L;\n\t\tcase ALLOWLIST:\n\t\t\treturn 1000L * 60 * 5;\n\t\tcase INTERNET:\n\t\t\treturn 1000L * 10;\n\t\tcase LEGACY:\n\t\t\treturn 1000L * 60;\n\t\tcase UNSECURE:\n\t\t\treturn 1000L * 60 * 5;\n\t\t}\n\t\tthrow new AssertionError();\n\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n *\n */\npackage net.sourceforge.plantuml.security;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\nimport javax.swing.ImageIcon;\n\nimport net.sourceforge.plantuml.StringUtils;\nimport net.sourceforge.plantuml.json.Json;\nimport net.sourceforge.plantuml.json.JsonValue;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.authentication.SecurityAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.SecurityAuthentication;\nimport net.sourceforge.plantuml.security.authentication.SecurityAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.SecurityCredentials;\nimport net.sourceforge.plantuml.security.authentication.SecurityDefaultNoopAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.SecurityDefaultNoopAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.basicauth.BasicAuthAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.basicauth.BasicAuthAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.oauth.OAuth2AccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.oauth.OAuth2ClientAccessAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.oauth.OAuth2ResourceOwnerAccessAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.token.TokenAuthAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.token.TokenAuthAuthorizeManager;\nimport net.sourceforge.plantuml.utils.Log;\n\npublic class SecurityUtils {\n\n\t// ::uncomment when __CORE__\n//\tpublic static SecurityProfile getSecurityProfile() {\n//\t\treturn SecurityProfile.UNSECURE;\n//\t}\n\t// ::done\n\n\tpublic static boolean ignoreThisLink(String url) {\n\t\t// ::comment when __CORE__\n\t\tif (allowJavascriptInLink() == false && isJavascriptLink(url))\n\t\t\treturn true;\n\t\t// ::done\n\t\treturn false;\n\t}\n\n\t/**\n\t * Indicates, that we have no authentication and credentials to access the URL.\n\t */\n\tpublic static final String NO_CREDENTIALS = \"<none>\";\n\n\tpublic synchronized static BufferedImage readRasterImage(final ImageIcon imageIcon) {\n\t\tfinal Image tmpImage = imageIcon.getImage();\n\t\tif (imageIcon.getIconWidth() == -1)\n\t\t\treturn null;\n\n\t\tfinal BufferedImage image = new BufferedImage(imageIcon.getIconWidth(), imageIcon.getIconHeight(),\n\t\t\t\tBufferedImage.TYPE_INT_ARGB);\n\t\timage.getGraphics().drawImage(tmpImage, 0, 0, null);\n\t\ttmpImage.flush();\n\t\treturn image;\n\t}\n\n\t// ::comment when __CORE__\n\t/**\n\t * Java class paths to import files from.\n\t */\n\tpublic static final String PATHS_CLASSES = \"java.class.path\";\n\n\t/**\n\t * Paths to include files.\n\t */\n\tpublic static final String PATHS_INCLUDES = \"plantuml.include.path\";\n\n\t/**\n\t * Whitelist of paths from where scripts can load data.\n\t */\n\tpublic static final String ALLOWLIST_LOCAL_PATHS = \"plantuml.allowlist.path\";\n\n\t/**\n\t * Whitelist of urls\n\t */\n\tpublic static final String ALLOWLIST_URL = \"plantuml.allowlist.url\";\n\n\t/**\n\t * Paths to folders with security specific content (not allowed to read via\n\t * SFile).\n\t */\n\tpublic static final String PATHS_SECURITY = \"plantuml.security.credentials.path\";\n\n\tpublic static final String SECURITY_ALLOW_NONSSL_AUTH = \"plantuml.security.allowNonSSLAuth\";\n\n\t/**\n\t * Standard BasicAuth authentication interceptor, to generate a\n\t * SecurityAuthentication from credentials.\n\t */\n\tprivate static final SecurityAuthorizeManager PUBLIC_AUTH_MANAGER = new SecurityDefaultNoopAuthorizeManager();\n\n\t/**\n\t * Standard interceptor for public endpoint access.\n\t */\n\tprivate static final SecurityAccessInterceptor PUBLIC_ACCESS_INTERCEPTOR = new SecurityDefaultNoopAccessInterceptor();\n\n\t/**\n\t * Standard TokenAuth authorize manager, to generate a SecurityAuthentication\n\t * from credentials.\n\t */\n\tprivate static final SecurityAuthorizeManager TOKEN_AUTH_MANAGER = new TokenAuthAuthorizeManager();\n\n\t/**\n\t * Standard token access interceptor.\n\t */\n\tprivate static final SecurityAccessInterceptor TOKEN_ACCESS_INTERCEPTOR = new TokenAuthAccessInterceptor();\n\n\t/**\n\t * Standard BasicAuth authorize manager, to generate a SecurityAuthentication\n\t * from credentials.\n\t */\n\tprivate static final SecurityAuthorizeManager BASICAUTH_AUTH_MANAGER = new BasicAuthAuthorizeManager();\n\n\t/**\n\t * Standard BasicAuth access interceptor.\n\t */\n\tprivate static final SecurityAccessInterceptor BASICAUTH_ACCESS_INTERCEPTOR = new BasicAuthAccessInterceptor();\n\n\t/**\n\t * OAuth2 client credentials authorization manager.\n\t */\n\tprivate static final SecurityAuthorizeManager OAUTH2_CLIENT_AUTH_MANAGER = new OAuth2ClientAccessAuthorizeManager();\n\n\t/**\n\t * OAuth2 resource owner authorization manager.\n\t */\n\tprivate static final SecurityAuthorizeManager OAUTH2_RESOURCEOWNER_AUTH_MANAGER = new OAuth2ResourceOwnerAccessAuthorizeManager();\n\n\t/**\n\t * Standard 'bearer' OAuth2 access interceptor.\n\t */\n\tprivate static final SecurityAccessInterceptor OAUTH2_ACCESS_INTERCEPTOR = new OAuth2AccessInterceptor();\n\n\t/**\n\t * Filesystem-save characters.\n\t */\n\tprivate static final Pattern SECURE_CHARS = Pattern.compile(\"^[a-zA-Z0-9\\\\-]+$\");\n\n\tstatic private SecurityProfile current = null;\n\n\tpublic static synchronized SecurityProfile getSecurityProfile() {\n\t\tif (current == null)\n\t\t\tcurrent = SecurityProfile.init();\n\n\t\treturn current;\n\t}\n\n\tprivate static boolean isJavascriptLink(String url) {\n\t\treturn url.toLowerCase().replaceAll(\"[^a-z]\", \"\").startsWith(\"javascript\");\n\t}\n\n\tprivate static boolean allowJavascriptInLink() {\n\t\tfinal String env = getenv(\"PLANTUML_ALLOW_JAVASCRIPT_IN_LINK\");\n\t\treturn \"true\".equalsIgnoreCase(env);\n\t}\n\n\tpublic static String getenv(String name) {\n\t\tString result = System.getProperty(name);\n\t\tif (StringUtils.isNotEmpty(result))\n\t\t\treturn result;\n\n\t\tresult = System.getenv(name);\n\t\tif (StringUtils.isNotEmpty(result))\n\t\t\treturn result;\n\n\t\tfinal String alternateName = name.replace(\".\", \"_\").toUpperCase();\n\t\treturn System.getenv(alternateName);\n\t}\n\n\t/**\n\t * Checks the environment variable and returns true if the variable is used in\n\t * security context. In this case, the value should not be displayed in scripts.\n\t *\n\t * @param name Environment variable to check\n\t * @return true, if this is a secret variable\n\t */\n\tpublic static boolean isSecurityEnv(String name) {\n\t\treturn name != null && name.toLowerCase().startsWith(\"plantuml.security.\");\n\t}\n\n\t/**\n\t * Configuration for Non-SSL authentication methods.\n\t *\n\t * @return true, if plantUML should allow authentication in plain connections\n\t *         (without encryption).\n\t * @see #SECURITY_ALLOW_NONSSL_AUTH\n\t */\n\tpublic static boolean isNonSSLAuthenticationAllowed() {\n\t\treturn Boolean.parseBoolean(getenv(SECURITY_ALLOW_NONSSL_AUTH));\n\t}\n\n\tpublic static List<SFile> getPath(String prop) {\n\t\tfinal List<SFile> result = new ArrayList<>();\n\t\tString paths = getenv(prop);\n\t\tif (paths == null) {\n\t\t\treturn Collections.unmodifiableList(result);\n\t\t}\n\t\tpaths = StringUtils.eventuallyRemoveStartingAndEndingDoubleQuote(paths);\n\t\tfinal StringTokenizer st = new StringTokenizer(paths, System.getProperty(\"path.separator\"));\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tfinal String tmp = st.nextToken();\n\t\t\ttry {\n\t\t\t\tfinal SFile f = new SFile(tmp).getCanonicalFile();\n\t\t\t\tif (f.isDirectory())\n\t\t\t\t\tresult.add(f);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.info(\"Cannot access to \" + tmp + \". \" + e);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(result);\n\t}\n\n\tpublic static boolean allowSvgText() {\n\t\treturn true;\n\t}\n\n\tpublic static java.io.PrintWriter createPrintWriter(OutputStream os) {\n\t\treturn new PrintWriter(os);\n\t}\n\n\tpublic static java.io.PrintWriter createPrintWriter(OutputStream os, boolean append) {\n\t\treturn new PrintWriter(os, append);\n\t}\n\n\tpublic static PrintStream createPrintStream(OutputStream os) {\n\t\treturn new PrintStream(os);\n\t}\n\n\tpublic static PrintStream createPrintStream(OutputStream os, boolean autoFlush, String charset)\n\t\t\tthrows UnsupportedEncodingException {\n\t\treturn new PrintStream(os, autoFlush, charset);\n\t}\n\n\tpublic static PrintStream createPrintStream(OutputStream os, boolean autoFlush, Charset charset)\n\t\t\tthrows UnsupportedEncodingException {\n\t\treturn new PrintStream(os, autoFlush, charset.name());\n\t}\n\n\t// ----\n\tpublic static FileReader createFileReader(String path) throws FileNotFoundException {\n\t\treturn new FileReader(path);\n\t}\n\n\tpublic static java.io.PrintWriter createPrintWriter(String path) throws FileNotFoundException {\n\t\treturn new PrintWriter(path);\n\t}\n\n\tpublic static FileOutputStream createFileOutputStream(String path) throws FileNotFoundException {\n\t\treturn new FileOutputStream(path);\n\t}\n\n\t/**\n\t * Returns the authorize-manager for a security credentials configuration.\n\t *\n\t * @param credentialConfiguration the credentials\n\t * @return the manager.\n\t */\n\tpublic static SecurityAuthorizeManager getAuthenticationManager(SecurityCredentials credentialConfiguration) {\n\t\tif (credentialConfiguration == SecurityCredentials.NONE) {\n\t\t\treturn PUBLIC_AUTH_MANAGER;\n\t\t} else if (\"tokenauth\".equalsIgnoreCase(credentialConfiguration.getType())) {\n\t\t\treturn TOKEN_AUTH_MANAGER;\n\t\t} else if (\"basicauth\".equalsIgnoreCase(credentialConfiguration.getType())) {\n\t\t\treturn BASICAUTH_AUTH_MANAGER;\n\t\t} else if (\"oauth2\".equalsIgnoreCase(credentialConfiguration.getType())) {\n\t\t\tString grantType = credentialConfiguration.getPropertyStr(\"grantType\");\n\t\t\tif (\"client_credentials\".equalsIgnoreCase(grantType)) {\n\t\t\t\treturn OAUTH2_CLIENT_AUTH_MANAGER;\n\t\t\t} else if (\"password\".equalsIgnoreCase(grantType)) {\n\t\t\t\treturn OAUTH2_RESOURCEOWNER_AUTH_MANAGER;\n\t\t\t}\n\t\t}\n\t\treturn PUBLIC_AUTH_MANAGER;\n\t}\n\n\t/**\n\t * Returns the authentication interceptor for a {@link SecurityAuthentication}.\n\t *\n\t * @param authentication the authentication data\n\t * @return the interceptor.\n\t */\n\tpublic static SecurityAccessInterceptor getAccessInterceptor(SecurityAuthentication authentication) {\n\t\tif (authentication != null) {\n\t\t\tString type = authentication.getType();\n\t\t\tif (\"public\".equals(type)) {\n\t\t\t\treturn PUBLIC_ACCESS_INTERCEPTOR;\n\t\t\t} else if (\"tokenauth\".equalsIgnoreCase(type)) {\n\t\t\t\treturn TOKEN_ACCESS_INTERCEPTOR;\n\t\t\t} else if (\"basicauth\".equalsIgnoreCase(type)) {\n\t\t\t\treturn BASICAUTH_ACCESS_INTERCEPTOR;\n\t\t\t} else if (\"oauth2\".equalsIgnoreCase(type)) {\n\t\t\t\treturn OAUTH2_ACCESS_INTERCEPTOR;\n\t\t\t}\n\t\t}\n\t\t// Unknown? Fall back to public:\n\t\treturn PUBLIC_ACCESS_INTERCEPTOR;\n\t}\n\n\t/**\n\t * Checks if user credentials existing.\n\t *\n\t * @param userToken name of the credential file\n\t * @return boolean, if exists\n\t */\n\tpublic static boolean existsSecurityCredentials(String userToken) {\n\t\tSFile securityPath = getSecurityPath();\n\t\tif (securityPath != null) {\n\t\t\t// SFile does not allow access to the security path (to hide the credentials in\n\t\t\t// DSL scripts)\n\t\t\tFile securityFilePath = securityPath.conv();\n\t\t\tFile userCredentials = new File(securityFilePath, userToken + \".credential\");\n\t\t\treturn userCredentials.exists() && userCredentials.canRead() && !userCredentials.isDirectory()\n\t\t\t\t\t&& userCredentials.length() > 2;\n\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Loads the user credentials from the file system.\n\t *\n\t * @param userToken name of the credential file\n\t * @return the credentials or NONE\n\t */\n\tpublic static SecurityCredentials loadSecurityCredentials(String userToken) {\n\t\tif (userToken != null && checkFileSystemSaveCharactersStrict(userToken) && !NO_CREDENTIALS.equals(userToken)) {\n\t\t\tfinal SFile securityPath = getSecurityPath();\n\t\t\tif (securityPath != null) {\n\t\t\t\t// SFile does not allow access to the security path (to hide the credentials in\n\t\t\t\t// DSL scripts)\n\t\t\t\tFile securityFilePath = securityPath.conv();\n\t\t\t\tFile userCredentials = new File(securityFilePath, userToken + \".credential\");\n\t\t\t\tJsonValue jsonValue = loadJson(userCredentials);\n\t\t\t\treturn SecurityCredentials.fromJson(jsonValue);\n\t\t\t}\n\t\t}\n\t\treturn SecurityCredentials.NONE;\n\t}\n\n\t/**\n\t * Checks, if the token of a pathname (filename, ext, directory-name) uses only\n\t * a very strict set of characters and not longer than 64 characters.\n\t * <p>\n\t * Only characters from a to Z, Numbers and - are allowed.\n\t *\n\t * @param pathNameToken filename, ext, directory-name\n\t * @return true, if the string fits to the strict allow-list of characters\n\t * @see #SECURE_CHARS\n\t */\n\tprivate static boolean checkFileSystemSaveCharactersStrict(String pathNameToken) {\n\t\treturn StringUtils.isNotEmpty(pathNameToken) && SECURE_CHARS.matcher(pathNameToken).matches()\n\t\t\t\t&& pathNameToken.length() <= 64;\n\t}\n\n\t/**\n\t * Loads the path to the configured security folder, if existing.\n\t * <p>\n\t * Please note: A SFile referenced to a security folder cannot access the files.\n\t * The content of the files in the security path should never have passed to DSL\n\t * scripts.\n\t *\n\t * @return SFile folder or null\n\t */\n\tpublic static SFile getSecurityPath() {\n\t\tList<SFile> paths = getPath(PATHS_SECURITY);\n\t\tif (!paths.isEmpty()) {\n\t\t\tSFile secureSFile = paths.get(0);\n\t\t\tFile securityFolder = secureSFile.conv();\n\t\t\tif (securityFolder.exists() && securityFolder.isDirectory()) {\n\t\t\t\treturn secureSFile;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Loads a file as JSON object. If no file exists or the file is not parsable,\n\t * the method returns an empty JSON.\n\t *\n\t * @param jsonFile file path to the JSON file\n\t * @return a Json vale (maybe empty)\n\t */\n\tprivate static JsonValue loadJson(File jsonFile) {\n\t\tif (jsonFile.exists() && jsonFile.canRead() && jsonFile.length() > 2) {\n\t\t\t// we have a file with at least two bytes and readable, hopefully it's a JSON\n\t\t\ttry (Reader r = new BufferedReader(new FileReader(jsonFile))) {\n\t\t\t\treturn Json.parse(r);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn Json.object();\n\t}\n\t// ::done\n\n}", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.tim.stdlib;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.tim.EaterException;\nimport net.sourceforge.plantuml.tim.EaterExceptionLocated;\nimport net.sourceforge.plantuml.tim.TContext;\nimport net.sourceforge.plantuml.tim.TFunctionSignature;\nimport net.sourceforge.plantuml.tim.TMemory;\nimport net.sourceforge.plantuml.tim.expression.TValue;\nimport net.sourceforge.plantuml.utils.LineLocation;\n\npublic class FileExists extends SimpleReturnFunction {\n\n\tpublic TFunctionSignature getSignature() {\n\t\treturn new TFunctionSignature(\"%file_exists\", 1);\n\t}\n\n\tpublic boolean canCover(int nbArg, Set<String> namedArgument) {\n\t\treturn nbArg == 1;\n\t}\n\n\tpublic TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\t// ::comment when __CORE__\n\t\tif (OptionFlags.ALLOW_INCLUDE == false)\n\t\t\t// ::done\n\t\t\treturn TValue.fromBoolean(false);\n\t\t// ::comment when __CORE__\n\n\t\tfinal String path = values.get(0).toString();\n\t\treturn TValue.fromBoolean(fileExists(path));\n\t\t// ::done\n\t}\n\n\tprivate boolean fileExists(String path) {\n\t\tfinal SFile f = new SFile(path);\n\t\treturn f.exists();\n\t}\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.tim.stdlib;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.tim.EaterException;\nimport net.sourceforge.plantuml.tim.EaterExceptionLocated;\nimport net.sourceforge.plantuml.tim.TContext;\nimport net.sourceforge.plantuml.tim.TFunctionSignature;\nimport net.sourceforge.plantuml.tim.TMemory;\nimport net.sourceforge.plantuml.tim.expression.TValue;\nimport net.sourceforge.plantuml.utils.LineLocation;\n\npublic class Getenv extends SimpleReturnFunction {\n\n\tpublic TFunctionSignature getSignature() {\n\t\treturn new TFunctionSignature(\"%getenv\", 1);\n\t}\n\n\tpublic boolean canCover(int nbArg, Set<String> namedArgument) {\n\t\treturn nbArg == 1;\n\t}\n\n\tpublic TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\t// ::comment when __CORE__\n\t\tif (OptionFlags.ALLOW_INCLUDE == false)\n\t\t\t// ::done\n\t\t\treturn TValue.fromString(\"\");\n\t\t// ::comment when __CORE__\n\n\t\tfinal String name = values.get(0).toString();\n\t\tfinal String value = getenv(name);\n\t\tif (value == null)\n\t\t\treturn TValue.fromString(\"\");\n\n\t\treturn TValue.fromString(value);\n\t\t// ::done\n\t}\n\n\t// ::comment when __CORE__\n\tprivate String getenv(String name) {\n\t\t// Check, if the script requests secret information.\n\t\t// A plantuml server should have an own SecurityManager to\n\t\t// avoid access to properties and environment variables, but we should\n\t\t// also stop here in other deployments.\n\t\tif (SecurityUtils.isSecurityEnv(name))\n\t\t\treturn null;\n\t\tfinal String env = System.getProperty(name);\n\t\tif (env != null)\n\t\t\treturn env;\n\n\t\treturn System.getenv(name);\n\t}\n\t// ::done\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2021, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.tim.stdlib;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.plantuml.FileSystem;\nimport net.sourceforge.plantuml.FileUtils;\nimport net.sourceforge.plantuml.json.Json;\nimport net.sourceforge.plantuml.json.JsonValue;\nimport net.sourceforge.plantuml.json.ParseException;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SURL;\nimport net.sourceforge.plantuml.tim.EaterException;\nimport net.sourceforge.plantuml.tim.EaterExceptionLocated;\nimport net.sourceforge.plantuml.tim.TContext;\nimport net.sourceforge.plantuml.tim.TFunctionSignature;\nimport net.sourceforge.plantuml.tim.TMemory;\nimport net.sourceforge.plantuml.tim.expression.TValue;\nimport net.sourceforge.plantuml.utils.LineLocation;\n\n/**\n * Loads JSON data from file or URL source.\n * <p>\n * Supports three parameters for datasource, default JSON value and charset. The\n * datasource will be checked against the security rules.\n * <p>\n * Examples:<br/>\n * \n * <pre>\n *     &#64; startuml\n *     ' loads a local file\n *     !$JSON_LOCAL_RELATIVE=%load_json(\"file.json\")\n *\n *     ' loads a local file from an absolute file path\n *     !$JSON_LOCAL_ABS=%load_json(\"c:/loaded/data/file.json\")\n *\n *     ' tries to load a local file and returns an empty JSON\n *     !$JSON_LOCAL_REL_EMPTY=%load_json(\"file-not-existing.json\")\n *\n *     ' tries to load a local file and returns an default JSON\n *     !$DEF_JSON={\"status\":\"No data found\"}\n *     !$JSON_LOCAL_REL_DEF=%load_json(\"file-not-existing.json\", $DEF_JSON)\n *\n *     ' loads a local file with a specific charset (default is UTF-8)\n *     !$JSON_LOCAL_RELATIVE_CHARSET=%load_json(\"file.json\", \"{}\", \"iso-8859-1\")\n *\n *     ' loads a remote JSON from an endpoint (and default, if not reachable)\n *     !$STATUS_NO_CONNECTION={\"status\": \"No connection\"}\n *     !$JSON_REMOTE_DEF=%load_json(\"https://localhost:7778/management/health\", $STATUS_NO_CONNECTION)\n *     status -&gt; $JSON_REMOTE_DEF.status\n *     &#64; enduml\n * </pre>\n * \n * @author Aljoscha Rittner\n */\npublic class LoadJson extends SimpleReturnFunction {\n\n\tprivate static final String VALUE_CHARSET_DEFAULT = \"UTF-8\";\n\n\tprivate static final String VALUE_DEFAULT_DEFAULT = \"{}\";\n\n\tpublic TFunctionSignature getSignature() {\n\t\treturn new TFunctionSignature(\"%load_json\", 3);\n\t}\n\n\tpublic boolean canCover(int nbArg, Set<String> namedArgument) {\n\t\treturn nbArg == 1 || nbArg == 2 || nbArg == 3;\n\t}\n\n\tpublic TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\tfinal String path = values.get(0).toString();\n\t\ttry {\n\t\t\tString data = loadStringData(path, getCharset(values));\n\t\t\tif (data == null)\n\t\t\t\tdata = getDefaultJson(values);\n\n\t\t\tJsonValue jsonValue = Json.parse(data);\n\t\t\treturn TValue.fromJson(jsonValue);\n\t\t} catch (ParseException pe) {\n\t\t\tLogme.error(pe);\n\t\t\tthrow EaterException.unlocated(\"JSON parse issue in source \" + path + \" on location \" + pe.getLocation());\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tLogme.error(e);\n\t\t\tthrow EaterException.unlocated(\"JSON encoding issue in source \" + path + \": \" + e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Returns the JSON default, if the data source contains no data.\n\t * \n\t * @param values value parameters\n\t * @return the defined default JSON or {@code \"{}\"}\n\t */\n\tprivate String getDefaultJson(List<TValue> values) {\n\t\tif (values.size() > 1)\n\t\t\treturn values.get(1).toString();\n\n\t\treturn VALUE_DEFAULT_DEFAULT;\n\t}\n\n\t/**\n\t * Returns the charset name (if set)\n\t * \n\t * @param values value parameters\n\t * @return defined charset or {@code \"UTF-8\"}\n\t */\n\tprivate String getCharset(List<TValue> values) {\n\t\tif (values.size() == 3)\n\t\t\treturn values.get(2).toString();\n\n\t\treturn VALUE_CHARSET_DEFAULT;\n\t}\n\n\t/**\n\t * Loads String data from a data source {@code path} (file or URL) and expects\n\t * the data encoded in {@code charset}.\n\t * \n\t * @param path    path to data source (http(s)-URL or file).\n\t * @param charset character set to encode the string data\n\t * @return the decoded String from the data source\n\t * @throws EaterException if something went wrong on reading data\n\t */\n\tprivate String loadStringData(String path, String charset) throws EaterException, UnsupportedEncodingException {\n\n\t\tbyte[] byteData = null;\n\t\tif (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n\t\t\tfinal SURL url = SURL.create(path);\n\t\t\tif (url == null)\n\t\t\t\tthrow EaterException.located(\"load JSON: Invalid URL \" + path);\n\t\t\tbyteData = url.getBytes();\n\t\t\t// ::comment when __CORE__\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tfinal SFile file = FileSystem.getInstance().getFile(path);\n\t\t\t\tif (file != null && file.exists() && file.canRead() && !file.isDirectory()) {\n\t\t\t\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream(1024 * 8);\n\t\t\t\t\tFileUtils.copyToStream(file, out);\n\t\t\t\t\tbyteData = out.toByteArray();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t\tthrow EaterException.located(\"load JSON: Cannot read file \" + path + \". \" + e.getMessage());\n\t\t\t}\n\t\t\t// ::done\n\t\t}\n\n\t\tif (byteData == null || byteData.length == 0)\n\t\t\treturn null; // no length, no data (we want the default)\n\n\t\treturn new String(byteData, charset);\n\n\t}\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.version;\n\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SImageIO;\nimport net.sourceforge.plantuml.utils.Log;\nimport net.sourceforge.plantuml.utils.SignatureUtils;\n\npublic class LicenseInfo {\n\n\tpublic static synchronized LicenseInfo retrieveQuick() {\n\t\t// ::revert when __CORE__\n\t\tif (cache == null)\n\t\t\tcache = retrieveDistributor();\n\n\t\tif (cache == null)\n\t\t\tcache = retrieveNamedSlow();\n\t\treturn cache;\n\t\t// return new LicenseInfo();\n\t\t// ::done\n\t}\n\n\tpublic boolean isValid() {\n\t\t// ::revert when __CORE__\n\t\treturn owner != null && System.currentTimeMillis() <= this.expirationDate;\n\t\t// return false;\n\t\t// ::done\n\t}\n\n\t// ::comment when __CORE__\n\tprivate static LicenseInfo cache;\n\n\tprivate final static Preferences prefs = Preferences.userNodeForPackage(LicenseInfo.class);\n\tpublic final static LicenseInfo NONE = new LicenseInfo(LicenseType.NONE, 0, 0, null, null, null);\n\n\tprivate final LicenseType type;\n\tprivate final long generationDate;\n\tprivate final long expirationDate;\n\tprivate final String owner;\n\tprivate final String context;\n\tprivate final byte[] sha;\n\n\tpublic LicenseInfo(LicenseType type, long generationDate, long expirationDate, String owner, String context,\n\t\t\tbyte[] sha) {\n\t\tthis.type = type;\n\t\tthis.generationDate = generationDate;\n\t\tthis.expirationDate = expirationDate;\n\t\tthis.owner = owner;\n\t\tthis.context = context;\n\t\tthis.sha = sha;\n\t}\n\n\tpublic static void persistMe(String key) throws BackingStoreException {\n\t\tprefs.sync();\n\t\tprefs.put(\"license\", key);\n\t}\n\n\tpublic static boolean retrieveNamedOrDistributorQuickIsValid() {\n\t\treturn retrieveQuick().isValid();\n\t}\n\n\tpublic static synchronized LicenseInfo retrieveNamedSlow() {\n\t\tcache = LicenseInfo.NONE;\n\t\tif (OptionFlags.ALLOW_INCLUDE == false)\n\t\t\treturn cache;\n\n\t\tfinal String key = prefs.get(\"license\", \"\");\n\t\tif (key.length() > 0) {\n\t\t\tcache = setIfValid(retrieveNamed(key), cache);\n\t\t\tif (cache.isValid())\n\t\t\t\treturn cache;\n\n\t\t}\n\t\tfor (SFile f : fileCandidates()) {\n\t\t\ttry {\n\t\t\t\tif (f.exists() && f.canRead()) {\n\t\t\t\t\tfinal LicenseInfo result = retrieve(f);\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\tcache = setIfValid(result, cache);\n\t\t\t\t\tif (cache.isValid())\n\t\t\t\t\t\treturn cache;\n\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.info(\"Error \" + e);\n\t\t\t\t// Logme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t}\n\n\tpublic static LicenseInfo retrieveNamed(final String key) {\n\t\tif (key.length() > 99 && key.matches(\"^[0-9a-z]+$\")) {\n\t\t\ttry {\n\t\t\t\tfinal String sig = SignatureUtils.toHexString(PLSSignature.signature());\n\t\t\t\treturn PLSSignature.retrieveNamed(sig, key, true);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// Logme.error(e);\n\t\t\t\tLog.info(\"Error retrieving license info\" + e);\n\t\t\t}\n\t\t}\n\t\treturn LicenseInfo.NONE;\n\t}\n\n\tpublic static BufferedImage retrieveDistributorImage(LicenseInfo licenseInfo) {\n\t\tif (licenseInfo.getLicenseType() != LicenseType.DISTRIBUTOR) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tfinal byte[] s1 = PLSSignature.retrieveDistributorImageSignature();\n\t\t\tif (SignatureUtils.toHexString(s1).equals(SignatureUtils.toHexString(licenseInfo.sha)) == false)\n\t\t\t\treturn null;\n\n\t\t\tfinal InputStream dis = PSystemVersion.class.getResourceAsStream(\"/distributor.png\");\n\t\t\tif (dis == null)\n\t\t\t\treturn null;\n\n\t\t\ttry {\n\t\t\t\tfinal BufferedImage result = SImageIO.read(dis);\n\t\t\t\treturn result;\n\t\t\t} finally {\n\t\t\t\tdis.close();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLogme.error(e);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static LicenseInfo retrieveDistributor() {\n\t\tfinal InputStream dis = PSystemVersion.class.getResourceAsStream(\"/distributor.txt\");\n\t\tif (dis == null)\n\t\t\treturn null;\n\n\t\ttry {\n\t\t\tfinal BufferedReader br = new BufferedReader(new InputStreamReader(dis));\n\t\t\tfinal String licenseString = br.readLine();\n\t\t\tbr.close();\n\t\t\tfinal LicenseInfo result = PLSSignature.retrieveDistributor(licenseString);\n\t\t\tfinal Throwable creationPoint = new Throwable();\n\t\t\tcreationPoint.fillInStackTrace();\n\t\t\tfor (StackTraceElement ste : creationPoint.getStackTrace())\n\t\t\t\tif (ste.toString().contains(result.context))\n\t\t\t\t\treturn result;\n\n\t\t\treturn null;\n\t\t} catch (Exception e) {\n\t\t\tLogme.error(e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static Collection<SFile> fileCandidates() {\n\t\tfinal Set<SFile> result = new TreeSet<>();\n\t\tfinal String classpath = System.getProperty(\"java.class.path\");\n\t\tString[] classpathEntries = classpath.split(SFile.pathSeparator);\n\t\tfor (String s : classpathEntries) {\n\t\t\tif (s == null)\n\t\t\t\tcontinue;\n\t\t\tSFile dir = new SFile(s);\n\t\t\tif (dir.isFile())\n\t\t\t\tdir = dir.getParentFile();\n\n\t\t\tif (dir != null && dir.isDirectory())\n\t\t\t\tresult.add(dir.file(\"license.txt\"));\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static LicenseInfo setIfValid(LicenseInfo value, LicenseInfo def) {\n\t\tif (value.isValid() || def.isNone())\n\t\t\treturn value;\n\n\t\treturn def;\n\t}\n\n\tprivate static LicenseInfo retrieve(SFile f) throws IOException {\n\t\tfinal BufferedReader br = f.openBufferedReader();\n\t\tif (br == null)\n\t\t\treturn null;\n\n\t\ttry {\n\t\t\tfinal String s = br.readLine();\n\t\t\tfinal LicenseInfo result = retrieveNamed(s);\n\t\t\tif (result != null)\n\t\t\t\tLog.info(\"Reading license from \" + f.getAbsolutePath());\n\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLicenseInfo info = retrieveNamedSlow();\n\t\tSystem.err.println(\"valid=\" + info.isValid());\n\t\tSystem.err.println(\"info=\" + info.owner);\n\n\t}\n\n\tpublic final Date getGenerationDate() {\n\t\treturn new Date(generationDate);\n\t}\n\n\tpublic final Date getExpirationDate() {\n\t\treturn new Date(expirationDate);\n\t}\n\n\tpublic final String getOwner() {\n\t\treturn owner;\n\t}\n\n\tpublic boolean isNone() {\n\t\treturn owner == null;\n\t}\n\n\tpublic boolean hasExpired() {\n\t\treturn owner != null && System.currentTimeMillis() > this.expirationDate;\n\t}\n\n\tpublic final LicenseType getLicenseType() {\n\t\treturn type;\n\t}\n\n\tpublic final String getContext() {\n\t\treturn context;\n\t}\n\t// ::done\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.version;\n\nimport static net.sourceforge.plantuml.klimt.geom.GraphicPosition.BACKGROUND_CORNER_BOTTOM_RIGHT;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.OptionPrint;\nimport net.sourceforge.plantuml.PlainStringsDiagram;\nimport net.sourceforge.plantuml.Run;\nimport net.sourceforge.plantuml.core.DiagramDescription;\nimport net.sourceforge.plantuml.core.UmlSource;\nimport net.sourceforge.plantuml.dot.GraphvizUtils;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.preproc.Stdlib;\nimport net.sourceforge.plantuml.preproc2.PreprocessorUtils;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SImageIO;\nimport net.sourceforge.plantuml.security.SecurityProfile;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.svek.GraphvizCrash;\n\npublic class PSystemVersion extends PlainStringsDiagram {\n\n\tPSystemVersion(UmlSource source, boolean withImage, List<String> args) {\n\t\tsuper(source);\n\t\tthis.strings.addAll(args);\n\t\ttry {\n\t\t\tif (withImage) {\n\t\t\t\tthis.image = getPlantumlImage();\n\t\t\t\tthis.imagePosition = BACKGROUND_CORNER_BOTTOM_RIGHT;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate PSystemVersion(UmlSource source, List<String> args, BufferedImage image) {\n\t\tsuper(source);\n\t\tthis.strings.addAll(args);\n\t\tthis.image = image;\n\t\tthis.imagePosition = BACKGROUND_CORNER_BOTTOM_RIGHT;\n\t}\n\n\tpublic static BufferedImage getPlantumlImage() {\n\t\treturn getImage(\"logo.png\");\n\t}\n\n\tpublic static BufferedImage getTime01() {\n\t\treturn getImage(\"time01.png\");\n\t}\n\n\tpublic static BufferedImage getTime15() {\n\t\treturn getImage(\"time15.png\");\n\t}\n\n\tpublic static BufferedImage getCharlieImage() {\n\t\treturn getImage(\"charlie.png\");\n\t}\n\n\tpublic static BufferedImage getPlantumlSmallIcon() {\n\t\treturn getImage(\"favicon.png\");\n\t}\n\n\t// ::comment when __CORE__\n\tpublic static BufferedImage getArecibo() {\n\t\treturn getImage(\"arecibo.png\");\n\t}\n\n\tpublic static BufferedImage getDotc() {\n\t\treturn getImage(\"dotc.png\");\n\t}\n\n\tpublic static BufferedImage getDotd() {\n\t\treturn getImage(\"dotd.png\");\n\t}\n\n\tpublic static BufferedImage getApple2Image() {\n\t\treturn getImageWebp(\"apple2.png\");\n\t}\n\t// ::done\n\n\tprivate static BufferedImage getImage(final String name) {\n\t\ttry {\n\t\t\tfinal InputStream is = PSystemVersion.class.getResourceAsStream(name);\n\t\t\tfinal BufferedImage image = SImageIO.read(is);\n\t\t\tis.close();\n\t\t\treturn image;\n\t\t} catch (IOException e) {\n\t\t\tLogme.error(e);\n\t\t}\n\t\treturn new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n\t}\n\n\t// ::comment when __CORE__\n\tprivate static BufferedImage getImageWebp(final String name) {\n\t\ttry (InputStream is = PSystemVersion.class.getResourceAsStream(name)) {\n\t\t\treturn SFile.getBufferedImageFromWebpButHeader(is);\n\t\t} catch (IOException e) {\n\t\t\tLogme.error(e);\n\t\t}\n\t\treturn new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n\t}\n\t// ::done\n\n\tprivate static BufferedImage transparentIcon;\n\n\tpublic static BufferedImage getPlantumlSmallIcon2() {\n\t\tif (transparentIcon != null) {\n\t\t\treturn transparentIcon;\n\t\t}\n\t\tfinal BufferedImage ico = getPlantumlSmallIcon();\n\t\tif (ico == null) {\n\t\t\treturn new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n\t\t}\n\t\ttransparentIcon = new BufferedImage(ico.getWidth(), ico.getHeight(), BufferedImage.TYPE_INT_ARGB_PRE);\n\t\tfor (int i = 0; i < ico.getWidth(); i++) {\n\t\t\tfor (int j = 0; j < ico.getHeight(); j++) {\n\t\t\t\tfinal int col = ico.getRGB(i, j);\n\t\t\t\tif (col != ico.getRGB(0, 0)) {\n\t\t\t\t\ttransparentIcon.setRGB(i, j, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn transparentIcon;\n\t}\n\n\tpublic static PSystemVersion createShowVersion2(UmlSource source) {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tstrings.add(\"<b>PlantUML version \" + Version.versionString() + \"</b> (\" + Version.compileTimeString() + \")\");\n\t\tstrings.add(\"(\" + License.getCurrent() + \" source distribution)\");\n\t\t// :: uncomment when __CORE__\n//\t\tstrings.add(\" \");\n//\t\tstrings.add(\"Compiled with CheerpJ 2.3\");\n//\t\tstrings.add(\"Powered by CheerpJ, a Leaning Technologies Java tool\");\n\t\t// :: done\n\t\t// :: comment when __CORE__\n\t\tGraphvizCrash.checkOldVersionWarning(strings);\n\t\tif (OptionFlags.ALLOW_INCLUDE) {\n\t\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE)\n\t\t\t\tstrings.add(\"Loaded from \" + Version.getJarPath());\n\n\t\t\tif (OptionFlags.getInstance().isWord()) {\n\t\t\t\tstrings.add(\"Word Mode\");\n\t\t\t\tstrings.add(\"Command Line: \" + Run.getCommandLine());\n\t\t\t\tstrings.add(\"Current Dir: \" + new SFile(\".\").getAbsolutePath());\n\t\t\t\tstrings.add(\"plantuml.include.path: \" + PreprocessorUtils.getenv(SecurityUtils.PATHS_INCLUDES));\n\t\t\t}\n\t\t}\n\t\tstrings.add(\" \");\n\n\t\tGraphvizUtils.addDotStatus(strings, true);\n\t\tstrings.add(\" \");\n\t\tfor (String name : OptionPrint.interestingProperties())\n\t\t\tstrings.add(name);\n\n\t\tfor (String v : OptionPrint.interestingValues())\n\t\t\tstrings.add(v);\n\n\t\t// ::done\n\n\t\treturn new PSystemVersion(source, true, strings);\n\t}\n\n\t// :: comment when __CORE__\n\tpublic static PSystemVersion createStdLib(UmlSource source) {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tStdlib.addInfoVersion(strings, true);\n\t\tstrings.add(\" \");\n\n\t\treturn new PSystemVersion(source, true, strings);\n\t}\n\t// ::done\n\n\tpublic static PSystemVersion createShowAuthors2(UmlSource source) {\n\t\t// Duplicate in OptionPrint\n\t\tfinal List<String> strings = getAuthorsStrings(true);\n\t\treturn new PSystemVersion(source, true, strings);\n\t}\n\n\tpublic static List<String> getAuthorsStrings(boolean withTag) {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tadd(strings, \"<b>PlantUML version \" + Version.versionString() + \"</b> (\" + Version.compileTimeString() + \")\",\n\t\t\t\twithTag);\n\t\tadd(strings, \"(\" + License.getCurrent() + \" source distribution)\", withTag);\n\t\tadd(strings, \" \", withTag);\n\t\tadd(strings, \"<u>Original idea</u>: Arnaud Roques\", withTag);\n\t\tadd(strings, \"<u>Word Macro</u>: Alain Bertucat & Matthieu Sabatier\", withTag);\n\t\tadd(strings, \"<u>Word Add-in</u>: Adriaan van den Brand\", withTag);\n\t\tadd(strings, \"<u>J2V8 & viz.js integration</u>: Andreas Studer\", withTag);\n\t\tadd(strings, \"<u>Official Eclipse Plugin</u>: Hallvard Tr\\u00E6tteberg\", withTag);\n\t\tadd(strings, \"<u>Original Eclipse Plugin</u>: Claude Durif & Anne Pecoil\", withTag);\n\t\tadd(strings, \"<u>Servlet & XWiki</u>: Maxime Sinclair\", withTag);\n\t\tadd(strings, \"<u>Docker</u>: David Ducatel\", withTag);\n\t\tadd(strings, \"<u>AWS lib</u>: Chris Passarello\", withTag);\n\t\tadd(strings, \"<u>Stdlib Icons</u>: tupadr3\", withTag);\n\t\tadd(strings, \"<u>Site design</u>: Raphael Cotisson\", withTag);\n\t\tadd(strings, \"<u>Logo</u>: Benjamin Croizet\", withTag);\n\t\tadd(strings, \"<u>Web Assembly</u>: Sakir Temel\", withTag);\n\n\t\tadd(strings, \" \", withTag);\n\t\tadd(strings, \"https://plantuml.com\", withTag);\n\t\tadd(strings, \" \", withTag);\n\t\treturn strings;\n\t}\n\n\tprivate static void add(List<String> result, String s, boolean withTag) {\n\t\tif (withTag == false)\n\t\t\ts = s.replaceAll(\"\\\\</?\\\\w+\\\\>\", \"\");\n\n\t\tresult.add(s);\n\n\t}\n\n\t// ::comment when __CORE__\n\tpublic static PSystemVersion createTestDot(UmlSource source) throws IOException {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tstrings.add(Version.fullDescription());\n\t\tGraphvizUtils.addDotStatus(strings, true);\n\t\treturn new PSystemVersion(source, false, strings);\n\t}\n\t// ::done\n\n//\tpublic static PSystemVersion createDumpStackTrace() throws IOException {\n//\t\tfinal List<String> strings = new ArrayList<>();\n//\t\tfinal Throwable creationPoint = new Throwable();\n//\t\tcreationPoint.fillInStackTrace();\n//\t\tfor (StackTraceElement ste : creationPoint.getStackTrace()) {\n//\t\t\tstrings.add(ste.toString());\n//\t\t}\n//\t\treturn new PSystemVersion(false, strings);\n//\t}\n\n\t// ::comment when __CORE__\n\tpublic static PSystemVersion createKeyDistributor(UmlSource source) throws IOException {\n\t\tfinal LicenseInfo license = LicenseInfo.retrieveDistributor();\n\t\tBufferedImage im = null;\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tif (license == null) {\n\t\t\tstrings.add(\"No license found\");\n\t\t} else {\n\t\t\tstrings.add(license.getOwner());\n\t\t\tstrings.add(license.getContext());\n\t\t\tstrings.add(license.getGenerationDate().toString());\n\t\t\tstrings.add(license.getExpirationDate().toString());\n\t\t\tim = LicenseInfo.retrieveDistributorImage(license);\n\t\t}\n\t\treturn new PSystemVersion(source, strings, im);\n\t}\n\t// ::done\n\n//\tpublic static PSystemVersion createPath(UmlSource source) throws IOException {\n//\t\tfinal List<String> strings = new ArrayList<>();\n//\t\tstrings.add(\"<u>Current Dir</u>: \" + new SFile(\".\").getPrintablePath());\n//\t\tstrings.add(\" \");\n//\t\tstrings.add(\"<u>Default path</u>:\");\n//\t\tfor (SFile f : ImportedFiles.createImportedFiles(null).getPath()) {\n//\t\t\tstrings.add(f.getPrintablePath());\n//\t\t}\n//\t\treturn new PSystemVersion(source, true, strings);\n//\t}\n\n\tpublic DiagramDescription getDescription() {\n\t\treturn new DiagramDescription(\"(Version)\");\n\t}\n\n\tpublic List<String> getLines() {\n\t\treturn Collections.unmodifiableList(strings);\n\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.version;\n\nimport java.util.Date;\n\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SURL;\nimport net.sourceforge.plantuml.utils.SignatureUtils;\n\npublic class Version {\n\t// ::remove folder when __HAXE__\n\n\t// Warning, \"version\" should be the same in gradle.properties and Version.java\n\t// Any idea anyone how to magically synchronize those :-) ?\n\tprivate static final String version = \"1.2023.9beta4\";\n\n\tpublic static String versionString() {\n\t\treturn version;\n\t}\n\n\tpublic static String fullDescription() {\n\t\treturn \"PlantUML version \" + Version.versionString() + \" (\" + Version.compileTimeString() + \")\";\n\t}\n\n\tpublic static String versionString(int size) {\n\t\tfinal StringBuilder sb = new StringBuilder(versionString());\n\t\twhile (sb.length() < size)\n\t\t\tsb.append(' ');\n\n\t\treturn sb.toString();\n\t}\n\n\tpublic static int beta() {\n\t\tfinal int x = version.indexOf(\"beta\");\n\t\tif (x == -1)\n\t\t\treturn 0;\n\t\treturn Integer.parseInt(version.substring(x + \"beta\".length()));\n\t}\n\n\tpublic static String etag() {\n\t\treturn SignatureUtils.getMD5Hex(version);\n\t}\n\n\tpublic static String turningId() {\n\t\treturn etag();\n\t}\n\n\tpublic static long compileTime() {\n\t\treturn 1684658280620L;\n\t}\n\n\tpublic static String compileTimeString() {\n\t\tif (version.contains(\"beta\"))\n\t\t\treturn \"Unknown compile time\";\n\n\t\treturn new Date(Version.compileTime()).toString();\n\t}\n\n\t// ::comment when __CORE__\n\tpublic static String getJarPath() {\n\t\ttry {\n\t\t\tfinal ClassLoader loader = Version.class.getClassLoader();\n\t\t\tif (loader == null) {\n\t\t\t\treturn \"No ClassLoader?\";\n\t\t\t}\n\t\t\tfinal SURL url = SURL.create(loader.getResource(\"net/sourceforge/plantuml/version/Version.class\"));\n\t\t\tif (url == null) {\n\t\t\t\treturn \"No URL?\";\n\t\t\t}\n\t\t\tString fullpath = url.toString();\n\t\t\tfullpath = fullpath.replaceAll(\"net/sourceforge/plantuml/version/Version\\\\.class\", \"\");\n\t\t\treturn fullpath;\n\t\t} catch (Throwable t) {\n\t\t\tLogme.error(t);\n\t\t\treturn t.toString();\n\t\t}\n\t}\n\t// ::done\n\n}\n"], "fixing_code": ["# Warning, \"version\" should be the same in gradle.properties and Version.java\n# Any idea anyone how to magically synchronize those :-) ?\nversion = 1.2023.9beta5\norg.gradle.workers.max = 3", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n *\n */\npackage net.sourceforge.plantuml;\n\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport net.sourceforge.plantuml.core.Diagram;\nimport net.sourceforge.plantuml.dot.GraphvizUtils;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.utils.Log;\n\npublic class OptionFlags {\n\t// ::remove file when __HAXE__\n\n\tprivate static final OptionFlags singleton = new OptionFlags();\n\tstatic public final boolean STRICT_SELFMESSAGE_POSITION = true;\n\tstatic public final boolean USE_INTERFACE_EYE1 = false;\n\tstatic public final boolean USE_INTERFACE_EYE2 = false;\n\tstatic public final boolean FORCE_TEOZ = false;\n\n\tprivate boolean replaceWhiteBackgroundByTransparent;\n\n\tpublic static OptionFlags getInstance() {\n\t\treturn singleton;\n\t}\n\n\tpublic final boolean isReplaceWhiteBackgroundByTransparent() {\n\t\treturn replaceWhiteBackgroundByTransparent;\n\t}\n\n\tpublic final void setReplaceWhiteBackgroundByTransparent(boolean replaceWhiteBackgroundByTransparent) {\n\t\tthis.replaceWhiteBackgroundByTransparent = replaceWhiteBackgroundByTransparent;\n\t}\n\n\t// ::comment when __CORE__\n\t// static public final boolean PBBACK = false;\n\t// static public boolean GRAPHVIZCACHE = false;\n\t// static public final boolean TRACE_DOT = false;\n\n//\tstatic public boolean ALLOW_INCLUDE = true;\n//\n//\tstatic public void setAllowIncludeFalse() {\n//\t\tALLOW_INCLUDE = false;\n//\t}\n\n\tstatic public void setMaxPixel(int max) {\n\t}\n\n\tstatic public final boolean USE_HECTOR = false;\n\tstatic public boolean ADD_NICE_FOR_DOT = false;\n\n\t// static public final boolean USE_IF_VERTICAL = true;\n\t// static public final boolean SWI2 = false;\n\t// static public final boolean USE_COMPOUND = false;\n\t// static public final boolean OMEGA_CROSSING = false;\n\n\t// static public final boolean LINK_BETWEEN_FIELDS = true;\n\n\tpublic void reset() {\n\t\treset(false);\n\t\tGraphvizUtils.setDotExecutable(null);\n\t}\n\n\tpublic final void setDotExecutable(String dotExecutable) {\n\t\tGraphvizUtils.setDotExecutable(dotExecutable);\n\t}\n\n\tprivate OptionFlags() {\n\t\treset(true);\n\t}\n\n\tprivate void reset(boolean exit) {\n\t\tverbose = false;\n\t\textractFromMetadata = false;\n\t\tword = false;\n\t\tsystemExit = exit;\n\t\tgui = false;\n\t\tquiet = false;\n\t\tcheckDotError = false;\n\t\tprintFonts = false;\n\t\t// failOnError = false;\n\t\tencodesprite = false;\n\t\t// PIC_LINE = false;\n\t}\n\n\tpublic boolean useJavaInsteadOfDot() {\n\t\treturn false;\n\t}\n\n\tprivate boolean verbose;\n\tprivate boolean extractFromMetadata;\n\tprivate boolean word;\n\tprivate boolean systemExit;\n\tprivate boolean gui;\n\tprivate boolean quiet;\n\tprivate boolean checkDotError;\n\tprivate boolean printFonts;\n\tprivate boolean encodesprite;\n\tprivate boolean dumpHtmlStats;\n\tprivate boolean dumpStats;\n\tprivate boolean loopStats;\n\tprivate boolean overwrite;\n\tprivate boolean enableStats = defaultForStats();\n\tprivate boolean stdLib;\n\tprivate boolean silentlyCompletelyIgnoreErrors;\n\tprivate boolean extractStdLib;\n\tprivate boolean clipboardLoop;\n\tprivate boolean clipboard;\n\tprivate String fileSeparator = \"_\";\n\tprivate long timeoutMs = 15 * 60 * 1000L; // 15 minutes\n\tprivate SFile logData;\n\n\tpublic final boolean isVerbose() {\n\t\treturn verbose;\n\t}\n\n\tpublic final void setVerbose(boolean verbose) {\n\t\tthis.verbose = verbose;\n\t}\n\n\tpublic final boolean isExtractFromMetadata() {\n\t\treturn extractFromMetadata;\n\t}\n\n\tpublic final void setExtractFromMetadata(boolean extractFromMetadata) {\n\t\tthis.extractFromMetadata = extractFromMetadata;\n\t}\n\n\tpublic final boolean isWord() {\n\t\treturn word;\n\t}\n\n\tpublic final void setWord(boolean word) {\n\t\tthis.word = word;\n\t}\n\n\tpublic final boolean isSystemExit() {\n\t\treturn systemExit;\n\t}\n\n\tpublic final void setSystemExit(boolean systemExit) {\n\t\tthis.systemExit = systemExit;\n\t}\n\n\tpublic final boolean isGui() {\n\t\treturn gui;\n\t}\n\n\tpublic final void setGui(boolean gui) {\n\t\tthis.gui = gui;\n\t}\n\n\tpublic final boolean isQuiet() {\n\t\treturn quiet;\n\t}\n\n\tpublic final void setQuiet(boolean quiet) {\n\t\tthis.quiet = quiet;\n\t}\n\n\tpublic final boolean isCheckDotError() {\n\t\treturn checkDotError;\n\t}\n\n\tpublic final void setCheckDotError(boolean checkDotError) {\n\t\tthis.checkDotError = checkDotError;\n\t}\n\n\tprivate final AtomicBoolean logDataInitized = new AtomicBoolean(false);\n\n\tpublic void logData(final SFile file, Diagram system) {\n\t\tfinal String warnOrError = system.getWarningOrError();\n\t\tif (warnOrError == null) {\n\t\t\treturn;\n\t\t}\n\t\tsynchronized (logDataInitized) {\n\t\t\tif (logData == null && logDataInitized.get() == false) {\n\t\t\t\tfinal String s = GraphvizUtils.getenvLogData();\n\t\t\t\tif (s != null) {\n\t\t\t\t\tsetLogData(new SFile(s));\n\t\t\t\t}\n\t\t\t\tlogDataInitized.set(true);\n\t\t\t}\n\n\t\t\tif (logData == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// final PSystemError systemError = (PSystemError) system;\n\t\t\ttry (PrintStream ps = SecurityUtils.createPrintStream(logData.createFileOutputStream(true))) {\n\t\t\t\tps.println(\"Start of \" + file.getName());\n\t\t\t\tps.println(warnOrError);\n\t\t\t\tps.println(\"End of \" + file.getName());\n\t\t\t\tps.println();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLog.error(\"Cannot open \" + logData);\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic final void setLogData(SFile logData) {\n\t\tthis.logData = logData;\n\t\tlogData.delete();\n\t\ttry (PrintStream ps = SecurityUtils.createPrintStream(logData.createFileOutputStream())) {\n\t\t\tps.println();\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLog.error(\"Cannot open \" + logData);\n\t\t\tLogme.error(e);\n\t\t}\n\t}\n\n\tpublic final boolean isPrintFonts() {\n\t\treturn printFonts;\n\t}\n\n\tpublic final void setPrintFonts(boolean printFonts) {\n\t\tthis.printFonts = printFonts;\n\t}\n\n\tpublic final boolean isUseSuggestEngine2() {\n\t\treturn false;\n\t}\n\n\tpublic final boolean isEncodesprite() {\n\t\treturn encodesprite;\n\t}\n\n\tpublic final void setEncodesprite(boolean encodesprite) {\n\t\tthis.encodesprite = encodesprite;\n\t}\n\n\tpublic final boolean isOverwrite() {\n\t\treturn overwrite;\n\t}\n\n\tpublic final void setOverwrite(boolean overwrite) {\n\t\tthis.overwrite = overwrite;\n\t}\n\n\tpublic final String getFileSeparator() {\n\t\treturn fileSeparator;\n\t}\n\n\tpublic final void setFileSeparator(String fileSeparator) {\n\t\tthis.fileSeparator = fileSeparator;\n\t}\n\n\tpublic final boolean isDumpHtmlStats() {\n\t\treturn dumpHtmlStats;\n\t}\n\n\tpublic final void setDumpHtmlStats(boolean value) {\n\t\tthis.dumpHtmlStats = value;\n\t}\n\n\tpublic final boolean isDumpStats() {\n\t\treturn dumpStats;\n\t}\n\n\tpublic final void setDumpStats(boolean dumpStats) {\n\t\tthis.dumpStats = dumpStats;\n\t}\n\n\tpublic final boolean isLoopStats() {\n\t\treturn loopStats;\n\t}\n\n\tpublic final void setLoopStats(boolean loopStats) {\n\t\tthis.loopStats = loopStats;\n\t}\n\n\tprivate static boolean defaultForStats() {\n\t\treturn isTrue(System.getProperty(\"PLANTUML_STATS\")) || isTrue(System.getenv(\"PLANTUML_STATS\"));\n\t}\n\n\tprivate static boolean isTrue(final String value) {\n\t\treturn \"on\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value);\n\t}\n\n\tpublic boolean isEnableStats() {\n\t\treturn enableStats;\n\t}\n\n\tpublic void setEnableStats(boolean enableStats) {\n\t\tthis.enableStats = enableStats;\n\t}\n\n\tpublic final long getTimeoutMs() {\n\t\treturn timeoutMs;\n\t}\n\n\tpublic final void setTimeoutMs(long timeoutMs) {\n\t\tthis.timeoutMs = timeoutMs;\n\t}\n\n\tpublic void setExtractStdLib(boolean extractStdLib) {\n\t\tthis.extractStdLib = extractStdLib;\n\t}\n\n\tpublic boolean isExtractStdLib() {\n\t\treturn extractStdLib;\n\t}\n\n\tpublic final boolean isClipboardLoop() {\n\t\treturn clipboardLoop;\n\t}\n\n\tpublic final void setClipboardLoop(boolean clipboardLoop) {\n\t\tthis.clipboardLoop = clipboardLoop;\n\t}\n\n\tpublic final boolean isClipboard() {\n\t\treturn clipboard;\n\t}\n\n\tpublic final void setClipboard(boolean clipboard) {\n\t\tthis.clipboard = clipboard;\n\t}\n\n\tpublic final boolean isStdLib() {\n\t\treturn stdLib;\n\t}\n\n\tpublic final void setStdLib(boolean stdLib) {\n\t\tthis.stdLib = stdLib;\n\t}\n\n\tpublic final boolean isSilentlyCompletelyIgnoreErrors() {\n\t\treturn silentlyCompletelyIgnoreErrors;\n\t}\n\n\tpublic final void setSilentlyCompletelyIgnoreErrors(boolean silentlyCompletelyIgnoreErrors) {\n\t\tthis.silentlyCompletelyIgnoreErrors = silentlyCompletelyIgnoreErrors;\n\t}\n\n\t// ::done\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * Modified by: Nicolas Jouanin\n * \n *\n */\npackage net.sourceforge.plantuml.preproc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.sourceforge.plantuml.file.AFile;\nimport net.sourceforge.plantuml.file.AFileRegular;\nimport net.sourceforge.plantuml.file.AFileZipEntry;\nimport net.sourceforge.plantuml.file.AParentFolder;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.utils.Log;\n// ::uncomment when __CORE__\n//import java.util.Collections;\n//  ::done\n\npublic class ImportedFiles {\n\n\tprivate final List<SFile> imported;\n\tprivate final AParentFolder currentDir;\n\n\tprivate ImportedFiles(List<SFile> imported, AParentFolder currentDir) {\n\t\tthis.imported = imported;\n\t\tthis.currentDir = currentDir;\n\t}\n\n\tpublic ImportedFiles withCurrentDir(AParentFolder newCurrentDir) {\n\t\tif (newCurrentDir == null) \n\t\t\treturn this;\n\t\t\n\t\treturn new ImportedFiles(imported, newCurrentDir);\n\t}\n\n\tpublic static ImportedFiles createImportedFiles(AParentFolder newCurrentDir) {\n\t\treturn new ImportedFiles(new ArrayList<SFile>(), newCurrentDir);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ImportedFiles=\" + imported + \" currentDir=\" + currentDir;\n\t}\n\n\tpublic AFile getAFile(String nameOrPath) throws IOException {\n\t\t// Log.info(\"ImportedFiles::getAFile nameOrPath = \" + nameOrPath);\n\t\t// Log.info(\"ImportedFiles::getAFile currentDir = \" + currentDir);\n\t\tfinal AParentFolder dir = currentDir;\n\t\tif (dir == null || isAbsolute(nameOrPath)) \n\t\t\treturn new AFileRegular(new SFile(nameOrPath).getCanonicalFile());\n\t\t\n\t\t// final File filecurrent = SecurityUtils.File(dir.getAbsoluteFile(),\n\t\t// nameOrPath);\n\t\tfinal AFile filecurrent = dir.getAFile(nameOrPath);\n\t\tLog.info(\"ImportedFiles::getAFile filecurrent = \" + filecurrent);\n\t\tif (filecurrent != null && filecurrent.isOk()) \n\t\t\treturn filecurrent;\n\t\t\n\t\tfor (SFile d : getPath()) {\n\t\t\tif (d.isDirectory()) {\n\t\t\t\tfinal SFile file = d.file(nameOrPath);\n\t\t\t\tif (file.exists()) \n\t\t\t\t\treturn new AFileRegular(file.getCanonicalFile());\n\t\t\t\t\n\t\t\t} else if (d.isFile()) {\n\t\t\t\tfinal AFileZipEntry zipEntry = new AFileZipEntry(d, nameOrPath);\n\t\t\t\tif (zipEntry.isOk()) \n\t\t\t\t\treturn zipEntry;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn filecurrent;\n\t}\n\n\tpublic List<SFile> getPath() {\n\t\tfinal List<SFile> result = new ArrayList<>(imported);\n\t\t// ::comment when __CORE__\n\t\tresult.addAll(includePath());\n\t\tresult.addAll(SecurityUtils.getPath(SecurityUtils.PATHS_CLASSES));\n\t\t// ::done\n\t\treturn result;\n\t}\n\n\tprivate List<SFile> includePath() {\n\t\t// ::comment when __CORE__\n\t\treturn SecurityUtils.getPath(SecurityUtils.PATHS_INCLUDES);\n\t\t// ::done\n\t\t// ::uncomment when __CORE__\n\t\t// return Collections.emptyList();\n\t\t// ::done\n\t}\n\n\tprivate boolean isAbsolute(String nameOrPath) {\n\t\tfinal SFile f = new SFile(nameOrPath);\n\t\treturn f.isAbsolute();\n\t}\n\n\tpublic void add(SFile file) {\n\t\tthis.imported.add(file);\n\t}\n\n\tpublic AParentFolder getCurrentDir() {\n\t\treturn currentDir;\n\t}\n\n\tpublic FileWithSuffix getFile(String filename, String suffix) throws IOException {\n\t\tfinal int idx = filename.indexOf('~');\n\t\tfinal AFile file;\n\t\tfinal String entry;\n\t\tif (idx == -1) {\n\t\t\tfile = getAFile(filename);\n\t\t\tentry = null;\n\t\t} else {\n\t\t\tfile = getAFile(filename.substring(0, idx));\n\t\t\tentry = filename.substring(idx + 1);\n\t\t}\n\t\t// if (isAllowed(file) == false)\n\t\tif (file == null || file.getUnderlyingFile().isFileOk() == false)\n\t\t\treturn FileWithSuffix.none();\n\n\t\treturn new FileWithSuffix(filename, suffix, file, entry);\n\t}\n\n//\tprivate boolean isAllowed(AFile file) throws IOException {\n//\t\t// ::comment when __CORE__\n//\t\tif (file != null) {\n//\t\t\tfinal SFile folder = file.getSystemFolder();\n//\t\t\t// System.err.println(\"canonicalPath=\" + path + \" \" + folder + \" \" +\n//\t\t\t// INCLUDE_PATH);\n//\t\t\tif (includePath().contains(folder) && folder.isFileOk())\n//\t\t\t\treturn true;\n//\n//\t\t}\n//\t\t// ::done\n//\t\treturn false;\n//\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.security;\n\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.imageio.stream.ImageInputStream;\nimport javax.swing.ImageIcon;\n\nimport net.sourceforge.plantuml.log.Logme;\n\n/**\n * Secure replacement for java.io.File.\n * <p>\n * This class should be used instead of java.io.File. There are few exceptions\n * (mainly in the Swing part and in the ANT task)\n * <p>\n * This class does some control access and in secure mode hide the real path of\n * file, so that it cannot be printed to end users.\n *\n */\npublic class SFile implements Comparable<SFile> {\n\n\tpublic static String separator = File.separator;\n\n\tpublic static String pathSeparator = File.pathSeparator;\n\n\tpublic static char separatorChar = File.separatorChar;\n\n\tprivate final File internal;\n\n\t@Override\n\tpublic String toString() {\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET\n\t\t\t\t|| SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)\n\t\t\treturn super.toString();\n\t\ttry {\n\t\t\treturn internal.getCanonicalPath();\n\t\t} catch (IOException e) {\n\t\t\treturn internal.getAbsolutePath();\n\t\t}\n\t}\n\n\tpublic SFile(String nameOrPath) {\n\t\tthis(new File(nameOrPath));\n\t}\n\n\tpublic SFile(String dirname, String name) {\n\t\tthis(new File(dirname, name));\n\t}\n\n\tpublic SFile(SFile basedir, String name) {\n\t\tthis(new File(basedir.internal, name));\n\t}\n\n\tpublic SFile(URI uri) {\n\t\tthis(new File(uri));\n\t}\n\n\tprivate SFile(File internal) {\n\t\tthis.internal = internal;\n\t}\n\n\tpublic static SFile fromFile(File internal) {\n\t\tif (internal == null)\n\t\t\treturn null;\n\n\t\treturn new SFile(internal);\n\t}\n\n\tpublic SFile file(String name) {\n\t\treturn new SFile(this, name);\n\t}\n\n\tpublic boolean exists() {\n\t\tif (internal != null && isFileOk())\n\t\t\treturn internal.exists();\n\t\treturn false;\n\t}\n\n\tpublic SFile getCanonicalFile() throws IOException {\n\t\treturn new SFile(internal.getCanonicalFile());\n\t}\n\n\tpublic boolean isAbsolute() {\n\t\treturn internal != null && internal.isAbsolute();\n\t}\n\n\tpublic boolean isDirectory() {\n\t\treturn internal != null && internal.exists() && internal.isDirectory();\n\t}\n\n\tpublic String getName() {\n\t\treturn internal.getName();\n\t}\n\n\tpublic boolean isFile() {\n\t\treturn internal != null && internal.isFile();\n\t}\n\n\tpublic long lastModified() {\n\t\treturn internal.lastModified();\n\t}\n\n\tpublic int compareTo(SFile other) {\n\t\treturn this.internal.compareTo(other.internal);\n\t}\n\n\tpublic String getPath() {\n\t\treturn internal.getPath();\n\t}\n\n\tpublic long length() {\n\t\treturn internal.length();\n\t}\n\n\tpublic boolean canWrite() {\n\t\treturn internal.canWrite();\n\t}\n\n\tpublic void setWritable(boolean b) {\n\t\tinternal.setWritable(b);\n\t}\n\n\tpublic void delete() {\n\t\tinternal.delete();\n\t}\n\n\tpublic Collection<SFile> listFiles() {\n\t\tfinal File[] tmp = internal.listFiles();\n\t\tif (tmp == null)\n\t\t\treturn Collections.emptyList();\n\n\t\tfinal List<SFile> result = new ArrayList<>(tmp.length);\n\t\tfor (File f : tmp)\n\t\t\tresult.add(new SFile(f));\n\n\t\treturn Collections.unmodifiableCollection(result);\n\t}\n\n\tpublic String[] list() {\n\t\treturn internal.list();\n\t}\n\n\tpublic SFile getAbsoluteFile() {\n\t\treturn new SFile(internal.getAbsoluteFile());\n\t}\n\n\tpublic SFile getParentFile() {\n\t\treturn new SFile(internal.getParentFile());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn internal.hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn internal.equals(((SFile) obj).internal);\n\t}\n\n\tpublic String getAbsolutePath() {\n\t\treturn internal.getAbsolutePath();\n\t}\n\n\tpublic String getPrintablePath() {\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE) {\n\t\t\ttry {\n\t\t\t\treturn internal.getCanonicalPath();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic boolean canRead() {\n\t\treturn internal.canRead();\n\t}\n\n\tpublic void deleteOnExit() {\n\t\tinternal.deleteOnExit();\n\t}\n\n\tpublic void mkdirs() {\n\t\tinternal.mkdirs();\n\t}\n\n\tpublic static SFile createTempFile(String prefix, String suffix) throws IOException {\n\t\treturn new SFile(File.createTempFile(prefix, suffix));\n\t}\n\n\tpublic URI toURI() {\n\t\treturn internal.toURI();\n\t}\n\n\tpublic boolean renameTo(SFile dest) {\n\t\treturn internal.renameTo(dest.internal);\n\t}\n\n\t/**\n\t * Check SecurityProfile to see if this file can be open.\n\t */\n\tpublic boolean isFileOk() {\n\t\t// ::comment when __CORE__\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)\n\t\t\t// In SANDBOX, we cannot read any files\n\t\t\treturn false;\n\n\t\t// In any case SFile should not access the security folders\n\t\t// (the files must be handled internally)\n\t\ttry {\n\t\t\tif (isDenied())\n\t\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\t// Files in \"plantuml.include.path\" and \"plantuml.allowlist.path\" are ok.\n\t\tif (isInAllowList(SecurityUtils.getPath(SecurityUtils.PATHS_INCLUDES)))\n\t\t\treturn true;\n\n\t\tif (isInAllowList(SecurityUtils.getPath(SecurityUtils.ALLOWLIST_LOCAL_PATHS)))\n\t\t\treturn true;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET)\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() != SecurityProfile.UNSECURE) {\n\t\t\t// For UNSECURE, we did not do those checks\n\t\t\tfinal String path = getCleanPathSecure();\n\t\t\tif (path.startsWith(\"/etc/\") || path.startsWith(\"/dev/\") || path.startsWith(\"/boot/\")\n\t\t\t\t\t|| path.startsWith(\"/proc/\") || path.startsWith(\"/sys/\"))\n\t\t\t\treturn false;\n\n\t\t\tif (path.startsWith(\"//\"))\n\t\t\t\treturn false;\n\n\t\t}\n\t\t// ::done\n\t\treturn true;\n\t}\n\n\tprivate boolean isInAllowList(List<SFile> allowlist) {\n\t\tfinal String path = getCleanPathSecure();\n\t\tfor (SFile allow : allowlist)\n\t\t\tif (path.startsWith(allow.getCleanPathSecure()))\n\t\t\t\t// File directory is in the allowlist\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks, if the SFile is inside the folder (-structure) of the security area.\n\t *\n\t * @return true, if the file is not allowed to read/write\n\t * @throws IOException If an I/O error occurs, which is possible because the\n\t *                     check the pathname may require filesystem queries\n\t */\n\t// ::comment when __CORE__\n\tprivate boolean isDenied() throws IOException {\n\t\tSFile securityPath = SecurityUtils.getSecurityPath();\n\t\tif (securityPath == null)\n\t\t\treturn false;\n\t\treturn getSanitizedPath().startsWith(securityPath.getSanitizedPath());\n\t}\n\t// ::done\n\n\t/**\n\t * Returns a sanitized, canonical and normalized Path to a file.\n\t *\n\t * @return the Path\n\t * @throws IOException If an I/O error occurs, which is possible because the\n\t *                     construction of the canonical pathname may require\n\t *                     filesystem queries\n\t * @see #getCleanPathSecure()\n\t * @see File#getCanonicalPath()\n\t * @see Path#normalize()\n\t */\n\tprivate Path getSanitizedPath() throws IOException {\n\t\treturn Paths.get(new File(getCleanPathSecure()).getCanonicalPath()).normalize();\n\t}\n\n\tprivate String getCleanPathSecure() {\n\t\tString result = internal.getAbsolutePath();\n\t\tresult = result.replace(\"\\0\", \"\");\n\t\tresult = result.replace(\"\\\\\\\\\", \"/\");\n\t\treturn result;\n\t}\n\n\t// Reading\n\t// http://forum.plantuml.net/9048/img-tag-for-sequence-diagram-participants-does-always-render\n\tpublic BufferedImage readRasterImageFromFile() {\n\t\t// https://www.experts-exchange.com/questions/26171948/Why-are-ImageIO-read-images-losing-their-transparency.html\n\t\t// https://stackoverflow.com/questions/18743790/can-java-load-images-with-transparency\n\t\tif (isFileOk())\n\t\t\ttry {\n\t\t\t\t// ::comment when __CORE__\n\t\t\t\tif (internal.getName().endsWith(\".webp\"))\n\t\t\t\t\treturn readWebp();\n\t\t\t\telse\n\t\t\t\t\t// ::done\n\t\t\t\t\treturn SecurityUtils.readRasterImage(new ImageIcon(this.getAbsolutePath()));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t// ::comment when __CORE__\n\tprivate BufferedImage readWebp() throws IOException {\n\t\ttry (InputStream is = openFile()) {\n\t\t\tfinal int riff = read32(is);\n\t\t\tif (riff != 0x46464952)\n\t\t\t\treturn null;\n\t\t\tfinal int len1 = read32(is);\n\t\t\tfinal int webp = read32(is);\n\t\t\tif (webp != 0x50424557)\n\t\t\t\treturn null;\n\t\t\tfinal int vp8_ = read32(is);\n\t\t\tif (vp8_ != 0x20385056)\n\t\t\t\treturn null;\n\t\t\tfinal int len2 = read32(is);\n\t\t\tif (len1 != len2 + 12)\n\t\t\t\treturn null;\n\n\t\t\treturn getBufferedImageFromWebpButHeader(is);\n\t\t}\n\t}\n\n\tprivate int read32(InputStream is) throws IOException {\n\t\treturn (is.read() << 0) + (is.read() << 8) + (is.read() << 16) + (is.read() << 24);\n\t}\n\n\tpublic static BufferedImage getBufferedImageFromWebpButHeader(InputStream is) {\n\t\tif (is == null)\n\t\t\treturn null;\n\t\ttry {\n\t\t\tfinal Class<?> clVP8Decoder = Class.forName(\"net.sourceforge.plantuml.webp.VP8Decoder\");\n\t\t\tfinal Object vp8Decoder = clVP8Decoder.getDeclaredConstructor().newInstance();\n\t\t\t// final VP8Decoder vp8Decoder = new VP8Decoder();\n\t\t\tfinal Method decodeFrame = clVP8Decoder.getMethod(\"decodeFrame\", ImageInputStream.class);\n\t\t\tfinal ImageInputStream iis = SImageIO.createImageInputStream(is);\n\t\t\tdecodeFrame.invoke(vp8Decoder, iis);\n\t\t\t// vp8Decoder.decodeFrame(iis);\n\t\t\tiis.close();\n\t\t\tfinal Object frame = clVP8Decoder.getMethod(\"getFrame\").invoke(vp8Decoder);\n\t\t\treturn (BufferedImage) frame.getClass().getMethod(\"getBufferedImage\").invoke(frame);\n\t\t\t// final VP8Frame frame = vp8Decoder.getFrame();\n\t\t\t// return frame.getBufferedImage();\n\t\t} catch (Exception e) {\n\t\t\tLogme.error(e);\n\t\t\treturn null;\n\t\t}\n\t}\n\t// ::done\n\n\tpublic BufferedReader openBufferedReader() {\n\t\tif (isFileOk()) {\n\t\t\ttry {\n\t\t\t\treturn new BufferedReader(new FileReader(internal));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic File conv() {\n\t\treturn internal;\n\t}\n\n\tpublic InputStream openFile() {\n\t\tif (isFileOk())\n\t\t\ttry {\n\t\t\t\treturn new BufferedInputStream(new FileInputStream(internal));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t// ::comment when __CORE__\n\t// Writing\n\tpublic BufferedOutputStream createBufferedOutputStream() throws FileNotFoundException {\n\t\treturn new BufferedOutputStream(new FileOutputStream(internal));\n\t}\n\n\tpublic PrintWriter createPrintWriter() throws FileNotFoundException {\n\t\treturn new PrintWriter(internal);\n\t}\n\n\tpublic PrintWriter createPrintWriter(String charset) throws FileNotFoundException, UnsupportedEncodingException {\n\t\treturn new PrintWriter(internal, charset);\n\t}\n\n\tpublic FileOutputStream createFileOutputStream() throws FileNotFoundException {\n\t\treturn new FileOutputStream(internal);\n\t}\n\n\tpublic FileOutputStream createFileOutputStream(boolean append) throws FileNotFoundException {\n\t\treturn new FileOutputStream(internal, append);\n\t}\n\n\tpublic PrintStream createPrintStream() throws FileNotFoundException {\n\t\treturn new PrintStream(internal);\n\t}\n\n\tpublic PrintStream createPrintStream(String charset) throws FileNotFoundException, UnsupportedEncodingException {\n\t\treturn new PrintStream(internal, charset);\n\t}\n\n\tpublic PrintStream createPrintStream(Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n\t\treturn new PrintStream(internal, charset.name());\n\t}\n\t// ::done\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.security;\n\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.swing.ImageIcon;\n\nimport net.sourceforge.plantuml.StringUtils;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.authentication.SecurityAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.SecurityAuthentication;\nimport net.sourceforge.plantuml.security.authentication.SecurityCredentials;\n//::uncomment when __CORE__\n//import net.sourceforge.plantuml.FileUtils;\n//::done\n\n/**\n * Secure replacement for java.net.URL.\n * <p>\n * This class should be used instead of java.net.URL.\n * <p>\n * This class does some control access and manages access-tokens via URL. If a\n * URL contains a access-token, similar to a user prefix, SURL loads the\n * authorization config for this user-token and passes the credentials to the\n * host.\n * <p>\n * Example:<br/>\n * \n * <pre>\n *     SURL url = SURL.create (\"https://jenkins-access@jenkins.mycompany.com/api/json\")\n * </pre>\n * \n * The {@code jenkins-access} will checked against the Security context access\n * token configuration. If a configuration exists for this token name, the token\n * will be removed from the URL and the credentials will be added to the\n * headers. If the token is not found, the URL remains as it is and no separate\n * authentication will be performed.\n * <p>\n * TODO: Some methods should be moved to a HttpClient implementation, because\n * SURL is not the valid class to manage it. <br/>\n * TODO: BAD_HOSTS implementation should be reviewed and moved to HttpClient\n * implementation with a circuit-breaker. <br/>\n * TODO: Token expiration with refresh should be implemented in future. <br/>\n */\npublic class SURL {\n\n\t/**\n\t * Indicates, that we have no authentication to access the URL.\n\t */\n\tpublic static final String WITHOUT_AUTHENTICATION = SecurityUtils.NO_CREDENTIALS;\n\n\t/**\n\t * Internal URL, maybe cleaned from user-token.\n\t */\n\tprivate final URL internal;\n\n\t/**\n\t * Assigned credentials to this URL.\n\t */\n\tprivate final String securityIdentifier;\n\n\tprivate SURL(URL url, String securityIdentifier) {\n\t\tthis.internal = Objects.requireNonNull(url);\n\t\tthis.securityIdentifier = Objects.requireNonNull(securityIdentifier);\n\t}\n\n\t/**\n\t * Create a secure URL from a String.\n\t * <p>\n\t * The url must be http or https. Return null in case of error or if\n\t * <code>url</code> is null\n\t * \n\t * @param url plain url starting by http:// or https//\n\t * @return the secure URL or null\n\t */\n\tpublic static SURL create(String url) {\n\t\tif (url == null)\n\t\t\treturn null;\n\n\t\tif (url.startsWith(\"http://\") || url.startsWith(\"https://\"))\n\t\t\ttry {\n\t\t\t\treturn create(new URL(url));\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create a secure URL from a <code>java.net.URL</code> object.\n\t * <p>\n\t * It takes into account credentials.\n\t * \n\t * @param url\n\t * @return the secure URL\n\t * @throws MalformedURLException if <code>url</code> is null\n\t */\n\tpublic static SURL create(URL url) throws MalformedURLException {\n\t\tif (url == null)\n\t\t\tthrow new MalformedURLException(\"URL cannot be null\");\n\n\t\t// ::comment when __CORE__\n\t\tfinal String credentialId = url.getUserInfo();\n\n\t\tif (credentialId == null || credentialId.indexOf(':') > 0)\n\t\t\t// No user info at all, or a user with password (This is a legacy BasicAuth\n\t\t\t// access, and we bypass it):\n\t\t\treturn new SURL(url, WITHOUT_AUTHENTICATION);\n\t\telse if (SecurityUtils.existsSecurityCredentials(credentialId))\n\t\t\t// Given userInfo, but without a password. We try to find SecurityCredentials\n\t\t\treturn new SURL(removeUserInfo(url), credentialId);\n\t\telse\n\t\t\t// ::done\n\t\t\treturn new SURL(url, WITHOUT_AUTHENTICATION);\n\t}\n\n\t// ::uncomment when __CORE__\n//\tpublic InputStream openStream() {\n//\ttry {\n//\t\treturn internal.openStream();\n//\t} catch (IOException e) {\n//\t\tSystem.err.println(\"SURL::openStream \" + e);\n//\t\treturn null;\n//\t}\n//}\n//public byte[] getBytes() {\n//\tfinal InputStream is = openStream();\n//\tif (is != null)\n//\t\ttry {\n//\t\t\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n//\t\t\tFileUtils.copyInternal(is, baos, true);\n//\t\t\treturn baos.toByteArray();\n//\t\t} catch (IOException e) {\n//\t\t\tSystem.err.println(\"SURL::getBytes \" + e);\n//\t\t}\n//\treturn null;\n//}\n\t// ::done\n\n\tpublic BufferedImage readRasterImageFromURL() {\n\t\tif (isUrlOk())\n\t\t\ttry {\n\t\t\t\tfinal byte[] bytes = getBytes();\n\t\t\t\tif (bytes == null || bytes.length == 0)\n\t\t\t\t\treturn null;\n\t\t\t\tfinal ImageIcon tmp = new ImageIcon(bytes);\n\t\t\t\treturn SecurityUtils.readRasterImage(tmp);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check SecurityProfile to see if this URL can be opened.\n\t */\n\tpublic boolean isUrlOk() {\n\t\t// ::comment when __CORE__\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)\n\t\t\t// In SANDBOX, we cannot read any URL\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.LEGACY)\n\t\t\treturn true;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE)\n\t\t\t// We are UNSECURE anyway\n\t\t\treturn true;\n\n\t\tif (isInUrlAllowList())\n\t\t\t// ::done\n\t\t\treturn true;\n\t\t// ::comment when __CORE__\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET) {\n\t\t\tif (forbiddenURL(cleanPath(internal.toString())))\n\t\t\t\treturn false;\n\n\t\t\tfinal int port = internal.getPort();\n\t\t\t// Using INTERNET profile, port 80 and 443 are ok\n\t\t\treturn port == 80 || port == 443 || port == -1;\n\t\t}\n\t\treturn false;\n\t\t// ::done\n\t}\n\n\t// ::comment when __CORE__\n\t/**\n\t * Regex to remove the UserInfo part from a URL.\n\t */\n\tprivate static final Pattern PATTERN_USERINFO = Pattern.compile(\"(^https?://)([-_0-9a-zA-Z]+@)([^@]*)$\");\n\n\tprivate static final ExecutorService EXE = Executors.newCachedThreadPool(new ThreadFactory() {\n\t\tpublic Thread newThread(Runnable r) {\n\t\t\tfinal Thread t = Executors.defaultThreadFactory().newThread(r);\n\t\t\tt.setDaemon(true);\n\t\t\treturn t;\n\t\t}\n\t});\n\n\tprivate static final Map<String, Long> BAD_HOSTS = new ConcurrentHashMap<String, Long>();\n\n\t/**\n\t * Creates a URL without UserInfo part and without SecurityCredentials.\n\t *\n\t * @param url plain URL\n\t * @return SURL without any user credential information.\n\t * @throws MalformedURLException\n\t */\n\tstatic SURL createWithoutUser(URL url) throws MalformedURLException {\n\t\treturn new SURL(removeUserInfo(url), WITHOUT_AUTHENTICATION);\n\t}\n\n\t/**\n\t * Clears the bad hosts cache.\n\t * <p>\n\t * In some test cases (and maybe also needed for other functionality) the bad\n\t * hosts cache must be cleared.<br/>\n\t * E.g., in a test we check the failure on missing credentials and then a test\n\t * with existing credentials. With a bad host cache the second test will fail,\n\t * or we have unpredicted results.\n\t */\n\tstatic void resetBadHosts() {\n\t\tBAD_HOSTS.clear();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn internal.toString();\n\t}\n\n\tprivate boolean forbiddenURL(String full) {\n\t\t// Thanks to Agasthya Kasturi\n\t\tif (full.contains(\"@\"))\n\t\t\treturn true;\n\t\tif (full.startsWith(\"https://\") == false && full.startsWith(\"http://\") == false)\n\t\t\treturn true;\n\t\tif (full.matches(\"^https?://[-#.0-9:\\\\[\\\\]+]+/.*\"))\n\t\t\treturn true;\n\t\tif (full.matches(\"^https?://[^.]+/.*\"))\n\t\t\treturn true;\n\t\tif (full.matches(\"^https?://[^.]+$\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate boolean isInUrlAllowList() {\n\t\tfinal String full = cleanPath(internal.toString());\n\t\t// Thanks to Agasthya Kasturi\n\t\tif (full.contains(\"@\"))\n\t\t\treturn false;\n\t\tfor (String allow : getUrlAllowList())\n\t\t\tif (full.startsWith(cleanPath(allow)))\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tprivate String cleanPath(String path) {\n\t\t// Remove user information, because we don't like to store user/password or\n\t\t// userTokens in allow-list\n\t\tpath = removeUserInfoFromUrlPath(path);\n\t\tpath = path.trim().toLowerCase(Locale.US);\n\t\t// We simplify/normalize the url, removing default ports\n\t\tpath = path.replace(\":80/\", \"\");\n\t\tpath = path.replace(\":443/\", \"\");\n\t\treturn path;\n\t}\n\n\tprivate List<String> getUrlAllowList() {\n\t\tfinal String env = SecurityUtils.getenv(SecurityUtils.ALLOWLIST_URL);\n\t\tif (env == null)\n\t\t\treturn Collections.emptyList();\n\n\t\treturn Arrays.asList(StringUtils.eventuallyRemoveStartingAndEndingDoubleQuote(env).split(\";\"));\n\t}\n\n\t/**\n\t * Reads from an endpoint (with configured credentials and proxy) the response\n\t * as blob.\n\t * <p>\n\t * This method allows access to an endpoint, with a configured\n\t * SecurityCredentials object. The credentials will load on the fly and\n\t * authentication fetched from an authentication-manager. Caching of tokens is\n\t * not supported.\n\t * <p>\n\t * authors: Alain Corbiere, Aljoscha Rittner\n\t *\n\t * @return data loaded data from endpoint\n\t */\n\tpublic byte[] getBytes() {\n\t\tif (isUrlOk() == false)\n\t\t\treturn null;\n\n\t\tfinal SecurityCredentials credentials = SecurityUtils.loadSecurityCredentials(securityIdentifier);\n\t\tfinal SecurityAuthentication authentication = SecurityUtils.getAuthenticationManager(credentials)\n\t\t\t\t.create(credentials);\n\t\ttry {\n\t\t\tfinal String host = internal.getHost();\n\t\t\tfinal Long bad = BAD_HOSTS.get(host);\n\t\t\tif (bad != null) {\n\t\t\t\tif ((System.currentTimeMillis() - bad) < 1000L * 60)\n\t\t\t\t\treturn null;\n\t\t\t\tBAD_HOSTS.remove(host);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfinal Future<byte[]> result = EXE\n\t\t\t\t\t\t.submit(requestWithGetAndResponse(internal, credentials.getProxy(), authentication, null));\n\t\t\t\tfinal byte[] data = result.get(SecurityUtils.getSecurityProfile().getTimeout(), TimeUnit.MILLISECONDS);\n\t\t\t\tif (data != null)\n\t\t\t\t\treturn data;\n\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(\"issue \" + host + \" \" + e);\n\t\t\t}\n\n\t\t\tBAD_HOSTS.put(host, System.currentTimeMillis());\n\t\t\treturn null;\n\t\t} finally {\n\t\t\t// clean up. We don't cache tokens, no expire handling. All time a re-request.\n\t\t\tcredentials.eraseCredentials();\n\t\t\tauthentication.eraseCredentials();\n\t\t}\n\t}\n\n\t/**\n\t * Reads from an endpoint with a given authentication and proxy the response as\n\t * blob.\n\t * <p>\n\t * This method allows a parametrized access to an endpoint, without a configured\n\t * SecurityCredentials object. This is useful to access internally identity\n\t * providers (IDP), or authorization servers (to request access tokens).\n\t * <p>\n\t * This method don't use the \"bad-host\" functionality, because the access to\n\t * infrastructure services should not be obfuscated by some internal management.\n\t * <p>\n\t * <strong>Please don't use this method directly from DSL scripts.</strong>\n\t *\n\t * @param authentication authentication object data. Caller is responsible to\n\t *                       erase credentials\n\t * @param proxy          proxy configuration\n\t * @param headers        additional headers, if needed\n\t * @return loaded data from endpoint\n\t */\n\tprivate byte[] getBytes(Proxy proxy, SecurityAuthentication authentication, Map<String, Object> headers) {\n\t\tif (isUrlOk() == false)\n\t\t\treturn null;\n\n\t\tfinal Future<byte[]> result = EXE.submit(requestWithGetAndResponse(internal, proxy, authentication, headers));\n\n\t\ttry {\n\t\t\treturn result.get(SecurityUtils.getSecurityProfile().getTimeout(), TimeUnit.MILLISECONDS);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"SURL response issue to \" + internal.getHost() + \" \" + e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Post to an endpoint with a given authentication and proxy the response as\n\t * blob.\n\t * <p>\n\t * This method allows a parametrized access to an endpoint, without a configured\n\t * SecurityCredentials object. This is useful to access internally identity\n\t * providers (IDP), or authorization servers (to request access tokens).\n\t * <p>\n\t * This method don't use the \"bad-host\" functionality, because the access to\n\t * infrastructure services should not be obfuscated by some internal management.\n\t * <p>\n\t * <strong>Please don't use this method directly from DSL scripts.</strong>\n\t *\n\t * @param authentication authentication object data. Caller is responsible to\n\t *                       erase credentials\n\t * @param proxy          proxy configuration\n\t * @param data           content to post\n\t * @param headers        headers, if needed\n\t * @return loaded data from endpoint\n\t */\n\tpublic byte[] getBytesOnPost(Proxy proxy, SecurityAuthentication authentication, String data,\n\t\t\tMap<String, Object> headers) {\n\t\tif (isUrlOk() == false)\n\t\t\treturn null;\n\n\t\tfinal Future<byte[]> result = EXE\n\t\t\t\t.submit(requestWithPostAndResponse(internal, proxy, authentication, data, headers));\n\n\t\ttry {\n\t\t\treturn result.get(SecurityUtils.getSecurityProfile().getTimeout(), TimeUnit.MILLISECONDS);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"SURL response issue to \" + internal.getHost() + \" \" + e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a GET request and response handler\n\t * \n\t * @param url            URL to request\n\t * @param proxy          proxy to apply\n\t * @param authentication the authentication to use\n\t * @param headers        additional headers, if needed\n\t * @return the callable handler.\n\t */\n\tprivate static Callable<byte[]> requestWithGetAndResponse(final URL url, final Proxy proxy,\n\t\t\tfinal SecurityAuthentication authentication, final Map<String, Object> headers) {\n\t\treturn new Callable<byte[]>() {\n\n\t\t\tprivate HttpURLConnection openConnection(final URL url) throws IOException {\n\t\t\t\t// Add proxy, if passed throw parameters\n\t\t\t\tfinal URLConnection connection = proxy == null ? url.openConnection() : url.openConnection(proxy);\n\t\t\t\tif (connection == null)\n\t\t\t\t\treturn null;\n\n\t\t\t\tfinal HttpURLConnection http = (HttpURLConnection) connection;\n\n\t\t\t\tapplyEndpointAccessAuthentication(http, authentication);\n\t\t\t\tapplyAdditionalHeaders(http, headers);\n\t\t\t\treturn http;\n\t\t\t}\n\n\t\t\tpublic byte[] call() throws IOException {\n\t\t\t\tHttpURLConnection http = openConnection(url);\n\t\t\t\tfinal int responseCode = http.getResponseCode();\n\n\t\t\t\tif (responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n\t\t\t\t\t\t|| responseCode == HttpURLConnection.HTTP_MOVED_PERM) {\n\t\t\t\t\tfinal String newUrl = http.getHeaderField(\"Location\");\n\t\t\t\t\thttp = openConnection(new URL(newUrl));\n\t\t\t\t}\n\n\t\t\t\treturn retrieveResponseAsBytes(http);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Creates a POST request and response handler with a simple String content. The\n\t * content will be identified as form or JSON data. The charset encoding can be\n\t * set by header parameters or will be set to UTF-8. The method to some fancy\n\t * logic to simplify it for the user.\n\t * \n\t * @param url            URL to request via POST method\n\t * @param proxy          proxy to apply\n\t * @param authentication the authentication to use\n\t * @param headers        additional headers, if needed\n\t * @return the callable handler.\n\t */\n\tprivate static Callable<byte[]> requestWithPostAndResponse(final URL url, final Proxy proxy,\n\t\t\tfinal SecurityAuthentication authentication, final String data, final Map<String, Object> headers) {\n\t\treturn new Callable<byte[]>() {\n\t\t\tpublic byte[] call() throws IOException {\n\t\t\t\t// Add proxy, if passed throw parameters\n\t\t\t\tfinal URLConnection connection = proxy == null ? url.openConnection() : url.openConnection(proxy);\n\t\t\t\tif (connection == null)\n\t\t\t\t\treturn null;\n\n\t\t\t\tfinal boolean withContent = StringUtils.isNotEmpty(data);\n\n\t\t\t\tfinal HttpURLConnection http = (HttpURLConnection) connection;\n\t\t\t\thttp.setRequestMethod(\"POST\");\n\t\t\t\tif (withContent)\n\t\t\t\t\thttp.setDoOutput(true);\n\n\t\t\t\tapplyEndpointAccessAuthentication(http, authentication);\n\t\t\t\tapplyAdditionalHeaders(http, headers);\n\n\t\t\t\tfinal Charset charSet = extractCharset(http.getRequestProperty(\"Content-Type\"));\n\n\t\t\t\tif (withContent)\n\t\t\t\t\tsendRequestAsBytes(http, data.getBytes(charSet != null ? charSet : StandardCharsets.UTF_8));\n\n\t\t\t\treturn retrieveResponseAsBytes(http);\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate static Charset extractCharset(String contentType) {\n\t\tif (StringUtils.isEmpty(contentType))\n\t\t\treturn null;\n\n\t\tfinal Matcher matcher = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\").matcher(contentType);\n\t\tif (matcher.find())\n\t\t\ttry {\n\t\t\t\treturn Charset.forName(matcher.group(1));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Loads a response from an endpoint as a byte[] array.\n\t *\n\t * @param connection the URL connection\n\t * @return the loaded byte arrays\n\t * @throws IOException an exception, if the connection cannot establish or the\n\t *                     download was broken\n\t */\n\tprivate static byte[] retrieveResponseAsBytes(HttpURLConnection connection) throws IOException {\n\t\tfinal int responseCode = connection.getResponseCode();\n\t\tif (responseCode < HttpURLConnection.HTTP_BAD_REQUEST) {\n\t\t\ttry (InputStream input = connection.getInputStream()) {\n\t\t\t\treturn retrieveData(input);\n\t\t\t}\n\t\t} else {\n\t\t\ttry (InputStream error = connection.getErrorStream()) {\n\t\t\t\tfinal byte[] bytes = retrieveData(error);\n\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\"HTTP error \" + responseCode + \" with \" + new String(bytes, StandardCharsets.UTF_8));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reads data in a byte[] array.\n\t * \n\t * @param input input stream\n\t * @return byte data\n\t * @throws IOException if something went wrong\n\t */\n\tprivate static byte[] retrieveData(InputStream input) throws IOException {\n\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tfinal byte[] buffer = new byte[1024];\n\t\tint read;\n\t\twhile ((read = input.read(buffer)) > 0) {\n\t\t\tout.write(buffer, 0, read);\n\t\t}\n\t\tout.close();\n\t\treturn out.toByteArray();\n\t}\n\n\t/**\n\t * Sends a request content payload to an endpoint.\n\t * \n\t * @param connection HTTP connection\n\t * @param data       data as byte array\n\t * @throws IOException if something went wrong\n\t */\n\tprivate static void sendRequestAsBytes(HttpURLConnection connection, byte[] data) throws IOException {\n\t\tconnection.setFixedLengthStreamingMode(data.length);\n\t\ttry (OutputStream os = connection.getOutputStream()) {\n\t\t\tos.write(data);\n\t\t}\n\t}\n\n\tpublic InputStream openStream() {\n\t\tif (isUrlOk()) {\n\t\t\tfinal byte[] data = getBytes();\n\t\t\tif (data != null)\n\t\t\t\treturn new ByteArrayInputStream(data);\n\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Informs, if SecurityCredentials are configured for this connection.\n\t *\n\t * @return true, if credentials will be used for a connection\n\t */\n\tpublic boolean isAuthorizationConfigured() {\n\t\treturn WITHOUT_AUTHENTICATION.equals(securityIdentifier) == false;\n\t}\n\n\t/**\n\t * Applies the given authentication data to the http connection.\n\t *\n\t * @param http           HTTP URL connection (must be an encrypted https-TLS/SSL\n\t *                       connection, or http must be activated with a property)\n\t * @param authentication the data to request the access\n\t * @see SecurityUtils#getAccessInterceptor(SecurityAuthentication)\n\t * @see SecurityUtils#isNonSSLAuthenticationAllowed()\n\t */\n\tprivate static void applyEndpointAccessAuthentication(URLConnection http, SecurityAuthentication authentication) {\n\t\tif (authentication.isPublic())\n\t\t\t// Shortcut: No need to apply authentication.\n\t\t\treturn;\n\n\t\tif (http instanceof HttpsURLConnection || SecurityUtils.isNonSSLAuthenticationAllowed()) {\n\t\t\tSecurityAccessInterceptor accessInterceptor = SecurityUtils.getAccessInterceptor(authentication);\n\t\t\taccessInterceptor.apply(authentication, http);\n\t\t} else {\n\t\t\t// We cannot allow applying secret tokens on plain connections. Everyone can\n\t\t\t// read the data.\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"The transport of authentication data over an unencrypted http connection is not allowed\");\n\t\t}\n\t}\n\n\t/**\n\t * Set the headers for a URL connection\n\t * \n\t * @param headers map Keys with values (can be String or list of String)\n\t */\n\tprivate static void applyAdditionalHeaders(URLConnection http, Map<String, Object> headers) {\n\t\tif (headers == null || headers.isEmpty())\n\t\t\treturn;\n\n\t\tfor (Map.Entry<String, Object> header : headers.entrySet()) {\n\t\t\tfinal Object value = header.getValue();\n\t\t\tif (value instanceof String)\n\t\t\t\thttp.setRequestProperty(header.getKey(), (String) value);\n\t\t\telse if (value instanceof List)\n\t\t\t\tfor (Object item : (List<?>) value)\n\t\t\t\t\tif (item != null)\n\t\t\t\t\t\thttp.addRequestProperty(header.getKey(), item.toString());\n\n\t\t}\n\t}\n\n\t/**\n\t * Removes the userInfo part from the URL, because we want to use the\n\t * SecurityCredentials instead.\n\t * \n\t * @param url URL with UserInfo part\n\t * @return url without UserInfo part\n\t * @throws MalformedURLException\n\t */\n\tprivate static URL removeUserInfo(URL url) throws MalformedURLException {\n\t\treturn new URL(removeUserInfoFromUrlPath(url.toExternalForm()));\n\t}\n\n\t/**\n\t * Removes the userInfo part from the URL, because we want to use the\n\t * SecurityCredentials instead.\n\t * \n\t * @param url URL with UserInfo part\n\t * @return url without UserInfo part\n\t */\n\tprivate static String removeUserInfoFromUrlPath(String url) {\n\t\t// Simple solution:\n\t\tfinal Matcher matcher = PATTERN_USERINFO.matcher(url);\n\t\tif (matcher.find())\n\t\t\treturn matcher.replaceFirst(\"$1$3\");\n\n\t\treturn url;\n\t}\n\t// ::done\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.security;\n\n/**\n * There are 4 different security profile defined.\n * <p>\n * The security profile to be used is set at the launch of PlantUML and cannot\n * be changed by users. The security profile defines what an instance of\n * PlantUML is allowed to do:<br>\n * - access some local file <br>\n * - connection to some remote URL <br>\n * - print some technical information to the users.\n * <p>\n * <p>\n * The security profile is defined: <br>\n * - either by an environment variable<br>\n * - or an option at command line\n * <p>\n * There is also a default value, which is LEGACY in this current\n * implementation.\n * \n */\npublic enum SecurityProfile {\n\t// ::remove folder when __HAXE__\n\n\t/**\n\t * Running in SANDBOX mode is completely secure. No local file can be read\n\t * (except dot executable) No remote URL access can be used No technical\n\t * information are print to users.\n\t * <p>\n\t * This mode is defined for test and debug, since it's not very useful for\n\t * users. However, you can use it if you need to.\n\t */\n\tSANDBOX,\n\n\t/**\n\t * \n\t */\n\tALLOWLIST,\n\n\t/**\n\t * This mode is designed for PlantUML running in a web server.\n\t * \n\t */\n\tINTERNET,\n\n\t/**\n\t * This mode reproduce old PlantUML version behaviour.\n\t * <p>\n\t * Right now, this is the default Security Profile but this will be removed from\n\t * future version because it is now full secure, especially on Internet server.\n\t */\n\tLEGACY,\n\n\t/**\n\t * Running in UNSECURE mode means that PlantUML can access to any local file and\n\t * can connect to any URL.\n\t * <p>\n\t * Some technical information (file path, Java version) are also printed in some\n\t * error messages. This is not an issue if you are running PlantUML locally. But\n\t * you should not use this mode if PlantUML is running on some server,\n\t * especially if the server is accessible from Internet.\n\t */\n\tUNSECURE;\n\n\t/**\n\t * Initialize the default value.\n\t * <p>\n\t * It search in some config variable if the user has defined a some default\n\t * value.\n\t * \n\t * @return the value\n\t */\n\tstatic SecurityProfile init() {\n\t\t// ::comment when __CORE__\n\t\tfinal String env = SecurityUtils.getenv(\"PLANTUML_SECURITY_PROFILE\");\n\t\tif (\"SANDBOX\".equalsIgnoreCase(env))\n\t\t\treturn SANDBOX;\n\t\telse if (\"ALLOWLIST\".equalsIgnoreCase(env))\n\t\t\treturn ALLOWLIST;\n\t\telse if (\"INTERNET\".equalsIgnoreCase(env))\n\t\t\treturn INTERNET;\n\t\telse if (\"UNSECURE\".equalsIgnoreCase(env))\n\t\t\t// ::done\n\t\t\treturn UNSECURE;\n\t\t// ::comment when __CORE__\n\n\t\treturn LEGACY;\n\t\t// ::done\n\t}\n\n\t/**\n\t * A Human understandable description.\n\t */\n\tpublic String longDescription() {\n\t\tswitch (this) {\n\t\tcase SANDBOX:\n\t\t\treturn \"This is completely safe: no access to local files or to distant URL.\";\n\t\tcase ALLOWLIST:\n\t\t\treturn \"Some local resource may be accessible.\";\n\t\tcase INTERNET:\n\t\t\treturn \"<i>Mode designed for server connected to Internet.\";\n\t\tcase LEGACY:\n\t\t\treturn \"<b>Warning: this mode will be removed in future version\";\n\t\tcase UNSECURE:\n\t\t\treturn \"<b>Make sure that this server is not accessible from Internet\";\n\t\t}\n\t\treturn \"<i>This is completely safe: no access on local files or on distant URL.\";\n\t}\n\n\t/**\n\t * Retrieve the timeout for URL.\n\t */\n\tpublic long getTimeout() {\n\t\tswitch (this) {\n\t\tcase SANDBOX:\n\t\t\treturn 1000L;\n\t\tcase ALLOWLIST:\n\t\t\treturn 1000L * 60 * 5;\n\t\tcase INTERNET:\n\t\t\treturn 1000L * 10;\n\t\tcase LEGACY:\n\t\t\treturn 1000L * 60;\n\t\tcase UNSECURE:\n\t\t\treturn 1000L * 60 * 5;\n\t\t}\n\t\tthrow new AssertionError();\n\t}\n\n\tpublic boolean canWeReadThisEnvironmentVariable(String name) {\n\t\tif (name == null)\n\t\t\treturn false;\n\n\t\tif (this == UNSECURE)\n\t\t\treturn true;\n\t\t\n\t\tif (name.toLowerCase().startsWith(\"plantuml\"))\n\t\t\treturn true;\n\t\t\n\t\treturn true;\n\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n *\n */\npackage net.sourceforge.plantuml.security;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\nimport javax.swing.ImageIcon;\n\nimport net.sourceforge.plantuml.StringUtils;\nimport net.sourceforge.plantuml.json.Json;\nimport net.sourceforge.plantuml.json.JsonValue;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.authentication.SecurityAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.SecurityAuthentication;\nimport net.sourceforge.plantuml.security.authentication.SecurityAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.SecurityCredentials;\nimport net.sourceforge.plantuml.security.authentication.SecurityDefaultNoopAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.SecurityDefaultNoopAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.basicauth.BasicAuthAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.basicauth.BasicAuthAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.oauth.OAuth2AccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.oauth.OAuth2ClientAccessAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.oauth.OAuth2ResourceOwnerAccessAuthorizeManager;\nimport net.sourceforge.plantuml.security.authentication.token.TokenAuthAccessInterceptor;\nimport net.sourceforge.plantuml.security.authentication.token.TokenAuthAuthorizeManager;\nimport net.sourceforge.plantuml.utils.Log;\n\npublic class SecurityUtils {\n\n\t// ::uncomment when __CORE__\n//\tpublic static SecurityProfile getSecurityProfile() {\n//\t\treturn SecurityProfile.UNSECURE;\n//\t}\n\t// ::done\n\n\tpublic static boolean ignoreThisLink(String url) {\n\t\t// ::comment when __CORE__\n\t\tif (allowJavascriptInLink() == false && isJavascriptLink(url))\n\t\t\treturn true;\n\t\t// ::done\n\t\treturn false;\n\t}\n\n\t/**\n\t * Indicates, that we have no authentication and credentials to access the URL.\n\t */\n\tpublic static final String NO_CREDENTIALS = \"<none>\";\n\n\tpublic synchronized static BufferedImage readRasterImage(final ImageIcon imageIcon) {\n\t\tfinal Image tmpImage = imageIcon.getImage();\n\t\tif (imageIcon.getIconWidth() == -1)\n\t\t\treturn null;\n\n\t\tfinal BufferedImage image = new BufferedImage(imageIcon.getIconWidth(), imageIcon.getIconHeight(),\n\t\t\t\tBufferedImage.TYPE_INT_ARGB);\n\t\timage.getGraphics().drawImage(tmpImage, 0, 0, null);\n\t\ttmpImage.flush();\n\t\treturn image;\n\t}\n\n\t// ::comment when __CORE__\n\t/**\n\t * Java class paths to import files from.\n\t */\n\tpublic static final String PATHS_CLASSES = \"java.class.path\";\n\n\t/**\n\t * Paths to include files.\n\t */\n\tpublic static final String PATHS_INCLUDES = \"plantuml.include.path\";\n\n\t/**\n\t * Whitelist of paths from where scripts can load data.\n\t */\n\tpublic static final String ALLOWLIST_LOCAL_PATHS = \"plantuml.allowlist.path\";\n\n\t/**\n\t * Whitelist of urls\n\t */\n\tpublic static final String ALLOWLIST_URL = \"plantuml.allowlist.url\";\n\n\t/**\n\t * Paths to folders with security specific content (not allowed to read via\n\t * SFile).\n\t */\n\tpublic static final String PATHS_SECURITY = \"plantuml.security.credentials.path\";\n\n\tpublic static final String SECURITY_ALLOW_NONSSL_AUTH = \"plantuml.security.allowNonSSLAuth\";\n\n\t/**\n\t * Standard BasicAuth authentication interceptor, to generate a\n\t * SecurityAuthentication from credentials.\n\t */\n\tprivate static final SecurityAuthorizeManager PUBLIC_AUTH_MANAGER = new SecurityDefaultNoopAuthorizeManager();\n\n\t/**\n\t * Standard interceptor for public endpoint access.\n\t */\n\tprivate static final SecurityAccessInterceptor PUBLIC_ACCESS_INTERCEPTOR = new SecurityDefaultNoopAccessInterceptor();\n\n\t/**\n\t * Standard TokenAuth authorize manager, to generate a SecurityAuthentication\n\t * from credentials.\n\t */\n\tprivate static final SecurityAuthorizeManager TOKEN_AUTH_MANAGER = new TokenAuthAuthorizeManager();\n\n\t/**\n\t * Standard token access interceptor.\n\t */\n\tprivate static final SecurityAccessInterceptor TOKEN_ACCESS_INTERCEPTOR = new TokenAuthAccessInterceptor();\n\n\t/**\n\t * Standard BasicAuth authorize manager, to generate a SecurityAuthentication\n\t * from credentials.\n\t */\n\tprivate static final SecurityAuthorizeManager BASICAUTH_AUTH_MANAGER = new BasicAuthAuthorizeManager();\n\n\t/**\n\t * Standard BasicAuth access interceptor.\n\t */\n\tprivate static final SecurityAccessInterceptor BASICAUTH_ACCESS_INTERCEPTOR = new BasicAuthAccessInterceptor();\n\n\t/**\n\t * OAuth2 client credentials authorization manager.\n\t */\n\tprivate static final SecurityAuthorizeManager OAUTH2_CLIENT_AUTH_MANAGER = new OAuth2ClientAccessAuthorizeManager();\n\n\t/**\n\t * OAuth2 resource owner authorization manager.\n\t */\n\tprivate static final SecurityAuthorizeManager OAUTH2_RESOURCEOWNER_AUTH_MANAGER = new OAuth2ResourceOwnerAccessAuthorizeManager();\n\n\t/**\n\t * Standard 'bearer' OAuth2 access interceptor.\n\t */\n\tprivate static final SecurityAccessInterceptor OAUTH2_ACCESS_INTERCEPTOR = new OAuth2AccessInterceptor();\n\n\t/**\n\t * Filesystem-save characters.\n\t */\n\tprivate static final Pattern SECURE_CHARS = Pattern.compile(\"^[a-zA-Z0-9\\\\-]+$\");\n\n\tstatic private SecurityProfile current = null;\n\n\tpublic static synchronized SecurityProfile getSecurityProfile() {\n\t\tif (current == null)\n\t\t\tcurrent = SecurityProfile.init();\n\n\t\treturn current;\n\t}\n\n\tprivate static boolean isJavascriptLink(String url) {\n\t\treturn url.toLowerCase().replaceAll(\"[^a-z]\", \"\").startsWith(\"javascript\");\n\t}\n\n\tprivate static boolean allowJavascriptInLink() {\n\t\tfinal String env = getenv(\"PLANTUML_ALLOW_JAVASCRIPT_IN_LINK\");\n\t\treturn \"true\".equalsIgnoreCase(env);\n\t}\n\n\tpublic static String getenv(String name) {\n\t\tString result = System.getProperty(name);\n\t\tif (StringUtils.isNotEmpty(result))\n\t\t\treturn result;\n\n\t\tresult = System.getenv(name);\n\t\tif (StringUtils.isNotEmpty(result))\n\t\t\treturn result;\n\n\t\tfinal String alternateName = name.replace(\".\", \"_\").toUpperCase();\n\t\treturn System.getenv(alternateName);\n\t}\n\n//\t/**\n//\t * Checks the environment variable and returns true if the variable is used in\n//\t * security context. In this case, the value should not be displayed in scripts.\n//\t *\n//\t * @param name Environment variable to check\n//\t * @return true, if this is a secret variable\n//\t */\n//\tpublic static boolean isSecurityEnv(String name) {\n//\t\treturn name != null && name.toLowerCase().startsWith(\"plantuml.security.\");\n//\t}\n\n\t/**\n\t * Configuration for Non-SSL authentication methods.\n\t *\n\t * @return true, if plantUML should allow authentication in plain connections\n\t *         (without encryption).\n\t * @see #SECURITY_ALLOW_NONSSL_AUTH\n\t */\n\tpublic static boolean isNonSSLAuthenticationAllowed() {\n\t\treturn Boolean.parseBoolean(getenv(SECURITY_ALLOW_NONSSL_AUTH));\n\t}\n\n\tpublic static List<SFile> getPath(String prop) {\n\t\tfinal List<SFile> result = new ArrayList<>();\n\t\tString paths = getenv(prop);\n\t\tif (paths == null) {\n\t\t\treturn Collections.unmodifiableList(result);\n\t\t}\n\t\tpaths = StringUtils.eventuallyRemoveStartingAndEndingDoubleQuote(paths);\n\t\tfinal StringTokenizer st = new StringTokenizer(paths, System.getProperty(\"path.separator\"));\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tfinal String tmp = st.nextToken();\n\t\t\ttry {\n\t\t\t\tfinal SFile f = new SFile(tmp).getCanonicalFile();\n\t\t\t\tif (f.isDirectory())\n\t\t\t\t\tresult.add(f);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.info(\"Cannot access to \" + tmp + \". \" + e);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(result);\n\t}\n\n\tpublic static boolean allowSvgText() {\n\t\treturn true;\n\t}\n\n\tpublic static java.io.PrintWriter createPrintWriter(OutputStream os) {\n\t\treturn new PrintWriter(os);\n\t}\n\n\tpublic static java.io.PrintWriter createPrintWriter(OutputStream os, boolean append) {\n\t\treturn new PrintWriter(os, append);\n\t}\n\n\tpublic static PrintStream createPrintStream(OutputStream os) {\n\t\treturn new PrintStream(os);\n\t}\n\n\tpublic static PrintStream createPrintStream(OutputStream os, boolean autoFlush, String charset)\n\t\t\tthrows UnsupportedEncodingException {\n\t\treturn new PrintStream(os, autoFlush, charset);\n\t}\n\n\tpublic static PrintStream createPrintStream(OutputStream os, boolean autoFlush, Charset charset)\n\t\t\tthrows UnsupportedEncodingException {\n\t\treturn new PrintStream(os, autoFlush, charset.name());\n\t}\n\n\t// ----\n\tpublic static FileReader createFileReader(String path) throws FileNotFoundException {\n\t\treturn new FileReader(path);\n\t}\n\n\tpublic static java.io.PrintWriter createPrintWriter(String path) throws FileNotFoundException {\n\t\treturn new PrintWriter(path);\n\t}\n\n\tpublic static FileOutputStream createFileOutputStream(String path) throws FileNotFoundException {\n\t\treturn new FileOutputStream(path);\n\t}\n\n\t/**\n\t * Returns the authorize-manager for a security credentials configuration.\n\t *\n\t * @param credentialConfiguration the credentials\n\t * @return the manager.\n\t */\n\tpublic static SecurityAuthorizeManager getAuthenticationManager(SecurityCredentials credentialConfiguration) {\n\t\tif (credentialConfiguration == SecurityCredentials.NONE) {\n\t\t\treturn PUBLIC_AUTH_MANAGER;\n\t\t} else if (\"tokenauth\".equalsIgnoreCase(credentialConfiguration.getType())) {\n\t\t\treturn TOKEN_AUTH_MANAGER;\n\t\t} else if (\"basicauth\".equalsIgnoreCase(credentialConfiguration.getType())) {\n\t\t\treturn BASICAUTH_AUTH_MANAGER;\n\t\t} else if (\"oauth2\".equalsIgnoreCase(credentialConfiguration.getType())) {\n\t\t\tString grantType = credentialConfiguration.getPropertyStr(\"grantType\");\n\t\t\tif (\"client_credentials\".equalsIgnoreCase(grantType)) {\n\t\t\t\treturn OAUTH2_CLIENT_AUTH_MANAGER;\n\t\t\t} else if (\"password\".equalsIgnoreCase(grantType)) {\n\t\t\t\treturn OAUTH2_RESOURCEOWNER_AUTH_MANAGER;\n\t\t\t}\n\t\t}\n\t\treturn PUBLIC_AUTH_MANAGER;\n\t}\n\n\t/**\n\t * Returns the authentication interceptor for a {@link SecurityAuthentication}.\n\t *\n\t * @param authentication the authentication data\n\t * @return the interceptor.\n\t */\n\tpublic static SecurityAccessInterceptor getAccessInterceptor(SecurityAuthentication authentication) {\n\t\tif (authentication != null) {\n\t\t\tString type = authentication.getType();\n\t\t\tif (\"public\".equals(type)) {\n\t\t\t\treturn PUBLIC_ACCESS_INTERCEPTOR;\n\t\t\t} else if (\"tokenauth\".equalsIgnoreCase(type)) {\n\t\t\t\treturn TOKEN_ACCESS_INTERCEPTOR;\n\t\t\t} else if (\"basicauth\".equalsIgnoreCase(type)) {\n\t\t\t\treturn BASICAUTH_ACCESS_INTERCEPTOR;\n\t\t\t} else if (\"oauth2\".equalsIgnoreCase(type)) {\n\t\t\t\treturn OAUTH2_ACCESS_INTERCEPTOR;\n\t\t\t}\n\t\t}\n\t\t// Unknown? Fall back to public:\n\t\treturn PUBLIC_ACCESS_INTERCEPTOR;\n\t}\n\n\t/**\n\t * Checks if user credentials existing.\n\t *\n\t * @param userToken name of the credential file\n\t * @return boolean, if exists\n\t */\n\tpublic static boolean existsSecurityCredentials(String userToken) {\n\t\tSFile securityPath = getSecurityPath();\n\t\tif (securityPath != null) {\n\t\t\t// SFile does not allow access to the security path (to hide the credentials in\n\t\t\t// DSL scripts)\n\t\t\tFile securityFilePath = securityPath.conv();\n\t\t\tFile userCredentials = new File(securityFilePath, userToken + \".credential\");\n\t\t\treturn userCredentials.exists() && userCredentials.canRead() && !userCredentials.isDirectory()\n\t\t\t\t\t&& userCredentials.length() > 2;\n\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Loads the user credentials from the file system.\n\t *\n\t * @param userToken name of the credential file\n\t * @return the credentials or NONE\n\t */\n\tpublic static SecurityCredentials loadSecurityCredentials(String userToken) {\n\t\tif (userToken != null && checkFileSystemSaveCharactersStrict(userToken) && !NO_CREDENTIALS.equals(userToken)) {\n\t\t\tfinal SFile securityPath = getSecurityPath();\n\t\t\tif (securityPath != null) {\n\t\t\t\t// SFile does not allow access to the security path (to hide the credentials in\n\t\t\t\t// DSL scripts)\n\t\t\t\tFile securityFilePath = securityPath.conv();\n\t\t\t\tFile userCredentials = new File(securityFilePath, userToken + \".credential\");\n\t\t\t\tJsonValue jsonValue = loadJson(userCredentials);\n\t\t\t\treturn SecurityCredentials.fromJson(jsonValue);\n\t\t\t}\n\t\t}\n\t\treturn SecurityCredentials.NONE;\n\t}\n\n\t/**\n\t * Checks, if the token of a pathname (filename, ext, directory-name) uses only\n\t * a very strict set of characters and not longer than 64 characters.\n\t * <p>\n\t * Only characters from a to Z, Numbers and - are allowed.\n\t *\n\t * @param pathNameToken filename, ext, directory-name\n\t * @return true, if the string fits to the strict allow-list of characters\n\t * @see #SECURE_CHARS\n\t */\n\tprivate static boolean checkFileSystemSaveCharactersStrict(String pathNameToken) {\n\t\treturn StringUtils.isNotEmpty(pathNameToken) && SECURE_CHARS.matcher(pathNameToken).matches()\n\t\t\t\t&& pathNameToken.length() <= 64;\n\t}\n\n\t/**\n\t * Loads the path to the configured security folder, if existing.\n\t * <p>\n\t * Please note: A SFile referenced to a security folder cannot access the files.\n\t * The content of the files in the security path should never have passed to DSL\n\t * scripts.\n\t *\n\t * @return SFile folder or null\n\t */\n\tpublic static SFile getSecurityPath() {\n\t\tList<SFile> paths = getPath(PATHS_SECURITY);\n\t\tif (!paths.isEmpty()) {\n\t\t\tSFile secureSFile = paths.get(0);\n\t\t\tFile securityFolder = secureSFile.conv();\n\t\t\tif (securityFolder.exists() && securityFolder.isDirectory()) {\n\t\t\t\treturn secureSFile;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Loads a file as JSON object. If no file exists or the file is not parsable,\n\t * the method returns an empty JSON.\n\t *\n\t * @param jsonFile file path to the JSON file\n\t * @return a Json vale (maybe empty)\n\t */\n\tprivate static JsonValue loadJson(File jsonFile) {\n\t\tif (jsonFile.exists() && jsonFile.canRead() && jsonFile.length() > 2) {\n\t\t\t// we have a file with at least two bytes and readable, hopefully it's a JSON\n\t\t\ttry (Reader r = new BufferedReader(new FileReader(jsonFile))) {\n\t\t\t\treturn Json.parse(r);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn Json.object();\n\t}\n\t// ::done\n\n}", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.tim.stdlib;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.tim.EaterException;\nimport net.sourceforge.plantuml.tim.EaterExceptionLocated;\nimport net.sourceforge.plantuml.tim.TContext;\nimport net.sourceforge.plantuml.tim.TFunctionSignature;\nimport net.sourceforge.plantuml.tim.TMemory;\nimport net.sourceforge.plantuml.tim.expression.TValue;\nimport net.sourceforge.plantuml.utils.LineLocation;\n\npublic class FileExists extends SimpleReturnFunction {\n\n\tpublic TFunctionSignature getSignature() {\n\t\treturn new TFunctionSignature(\"%file_exists\", 1);\n\t}\n\n\tpublic boolean canCover(int nbArg, Set<String> namedArgument) {\n\t\treturn nbArg == 1;\n\t}\n\n\tpublic TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\t// ::comment when __CORE__\n\t\tfinal String path = values.get(0).toString();\n\t\treturn TValue.fromBoolean(new SFile(path).exists());\n\t\t// ::done\n\n\t\t// ::uncomment when __CORE__\n\t\t// return TValue.fromBoolean(false);\n\t\t// ::done\n\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.tim.stdlib;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.tim.EaterException;\nimport net.sourceforge.plantuml.tim.EaterExceptionLocated;\nimport net.sourceforge.plantuml.tim.TContext;\nimport net.sourceforge.plantuml.tim.TFunctionSignature;\nimport net.sourceforge.plantuml.tim.TMemory;\nimport net.sourceforge.plantuml.tim.expression.TValue;\nimport net.sourceforge.plantuml.utils.LineLocation;\n\npublic class Getenv extends SimpleReturnFunction {\n\n\tpublic TFunctionSignature getSignature() {\n\t\treturn new TFunctionSignature(\"%getenv\", 1);\n\t}\n\n\tpublic boolean canCover(int nbArg, Set<String> namedArgument) {\n\t\treturn nbArg == 1;\n\t}\n\n\tpublic TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\t// ::comment when __CORE__\n\t\tfinal String value = getenv(values.get(0).toString());\n\t\tif (value == null)\n\t\t\treturn TValue.fromString(\"\");\n\n\t\treturn TValue.fromString(value);\n\t\t// ::done\n\n\t\t// ::uncomment when __CORE__\n\t\t// return TValue.fromString(\"\");\n\t\t// ::done\n\t}\n\n\t// ::comment when __CORE__\n\tprivate String getenv(String name) {\n\t\t// Check, if the script requests secret information.\n\t\t// A plantuml server should have an own SecurityManager to\n\t\t// avoid access to properties and environment variables, but we should\n\t\t// also stop here in other deployments.\n\t\tif (SecurityUtils.getSecurityProfile().canWeReadThisEnvironmentVariable(name) == false)\n\t\t\treturn null;\n\t\t\n\t\tfinal String env = System.getProperty(name);\n\t\tif (env != null)\n\t\t\treturn env;\n\n\t\treturn System.getenv(name);\n\t}\n\t// ::done\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2021, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n *\n * If you like this project or if you find it useful, you can support us at:\n *\n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n *\n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.tim.stdlib;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.plantuml.FileSystem;\nimport net.sourceforge.plantuml.FileUtils;\nimport net.sourceforge.plantuml.json.Json;\nimport net.sourceforge.plantuml.json.JsonValue;\nimport net.sourceforge.plantuml.json.ParseException;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SURL;\nimport net.sourceforge.plantuml.tim.EaterException;\nimport net.sourceforge.plantuml.tim.EaterExceptionLocated;\nimport net.sourceforge.plantuml.tim.TContext;\nimport net.sourceforge.plantuml.tim.TFunctionSignature;\nimport net.sourceforge.plantuml.tim.TMemory;\nimport net.sourceforge.plantuml.tim.expression.TValue;\nimport net.sourceforge.plantuml.utils.LineLocation;\n\n/**\n * Loads JSON data from file or URL source.\n * <p>\n * Supports three parameters for datasource, default JSON value and charset. The\n * datasource will be checked against the security rules.\n * <p>\n * Examples:<br/>\n * \n * <pre>\n *     &#64; startuml\n *     ' loads a local file\n *     !$JSON_LOCAL_RELATIVE=%load_json(\"file.json\")\n *\n *     ' loads a local file from an absolute file path\n *     !$JSON_LOCAL_ABS=%load_json(\"c:/loaded/data/file.json\")\n *\n *     ' tries to load a local file and returns an empty JSON\n *     !$JSON_LOCAL_REL_EMPTY=%load_json(\"file-not-existing.json\")\n *\n *     ' tries to load a local file and returns an default JSON\n *     !$DEF_JSON={\"status\":\"No data found\"}\n *     !$JSON_LOCAL_REL_DEF=%load_json(\"file-not-existing.json\", $DEF_JSON)\n *\n *     ' loads a local file with a specific charset (default is UTF-8)\n *     !$JSON_LOCAL_RELATIVE_CHARSET=%load_json(\"file.json\", \"{}\", \"iso-8859-1\")\n *\n *     ' loads a remote JSON from an endpoint (and default, if not reachable)\n *     !$STATUS_NO_CONNECTION={\"status\": \"No connection\"}\n *     !$JSON_REMOTE_DEF=%load_json(\"https://localhost:7778/management/health\", $STATUS_NO_CONNECTION)\n *     status -&gt; $JSON_REMOTE_DEF.status\n *     &#64; enduml\n * </pre>\n * \n * @author Aljoscha Rittner\n */\npublic class LoadJson extends SimpleReturnFunction {\n\n\tprivate static final String VALUE_CHARSET_DEFAULT = \"UTF-8\";\n\n\tprivate static final String VALUE_DEFAULT_DEFAULT = \"{}\";\n\n\tpublic TFunctionSignature getSignature() {\n\t\treturn new TFunctionSignature(\"%load_json\", 3);\n\t}\n\n\tpublic boolean canCover(int nbArg, Set<String> namedArgument) {\n\t\treturn nbArg == 1 || nbArg == 2 || nbArg == 3;\n\t}\n\n\tpublic TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\tfinal String path = values.get(0).toString();\n\t\ttry {\n\t\t\tString data = loadStringData(path, getCharset(values));\n\t\t\tif (data == null)\n\t\t\t\tdata = getDefaultJson(values);\n\n\t\t\tJsonValue jsonValue = Json.parse(data);\n\t\t\treturn TValue.fromJson(jsonValue);\n\t\t} catch (ParseException pe) {\n\t\t\tLogme.error(pe);\n\t\t\tthrow EaterException.unlocated(\"JSON parse issue in source \" + path + \" on location \" + pe.getLocation());\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tLogme.error(e);\n\t\t\tthrow EaterException.unlocated(\"JSON encoding issue in source \" + path + \": \" + e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Returns the JSON default, if the data source contains no data.\n\t * \n\t * @param values value parameters\n\t * @return the defined default JSON or {@code \"{}\"}\n\t */\n\tprivate String getDefaultJson(List<TValue> values) {\n\t\tif (values.size() > 1)\n\t\t\treturn values.get(1).toString();\n\n\t\treturn VALUE_DEFAULT_DEFAULT;\n\t}\n\n\t/**\n\t * Returns the charset name (if set)\n\t * \n\t * @param values value parameters\n\t * @return defined charset or {@code \"UTF-8\"}\n\t */\n\tprivate String getCharset(List<TValue> values) {\n\t\tif (values.size() == 3)\n\t\t\treturn values.get(2).toString();\n\n\t\treturn VALUE_CHARSET_DEFAULT;\n\t}\n\n\t/**\n\t * Loads String data from a data source {@code path} (file or URL) and expects\n\t * the data encoded in {@code charset}.\n\t * \n\t * @param path    path to data source (http(s)-URL or file).\n\t * @param charset character set to encode the string data\n\t * @return the decoded String from the data source\n\t * @throws EaterException if something went wrong on reading data\n\t */\n\tprivate String loadStringData(String path, String charset) throws EaterException, UnsupportedEncodingException {\n\n\t\tbyte[] byteData = null;\n\t\tif (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n\t\t\tfinal SURL url = SURL.create(path);\n\t\t\tif (url != null)\n\t\t\t\tbyteData = url.getBytes();\n\t\t\t// ::comment when __CORE__\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tfinal SFile file = FileSystem.getInstance().getFile(path);\n\t\t\t\tif (file != null && file.exists() && file.canRead() && !file.isDirectory()) {\n\t\t\t\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream(1024 * 8);\n\t\t\t\t\tFileUtils.copyToStream(file, out);\n\t\t\t\t\tbyteData = out.toByteArray();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogme.error(e);\n\t\t\t}\n\t\t\t// ::done\n\t\t}\n\n\t\tif (byteData == null || byteData.length == 0)\n\t\t\treturn null; // no length, no data (we want the default)\n\n\t\treturn new String(byteData, charset);\n\n\t}\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.version;\n\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SImageIO;\nimport net.sourceforge.plantuml.utils.Log;\nimport net.sourceforge.plantuml.utils.SignatureUtils;\n\npublic class LicenseInfo {\n\n\tpublic static synchronized LicenseInfo retrieveQuick() {\n\t\t// ::revert when __CORE__\n\t\tif (cache == null)\n\t\t\tcache = retrieveDistributor();\n\n\t\tif (cache == null)\n\t\t\tcache = retrieveNamedSlow();\n\t\treturn cache;\n\t\t// return new LicenseInfo();\n\t\t// ::done\n\t}\n\n\tpublic boolean isValid() {\n\t\t// ::revert when __CORE__\n\t\treturn owner != null && System.currentTimeMillis() <= this.expirationDate;\n\t\t// return false;\n\t\t// ::done\n\t}\n\n\t// ::comment when __CORE__\n\tprivate static LicenseInfo cache;\n\n\tprivate final static Preferences prefs = Preferences.userNodeForPackage(LicenseInfo.class);\n\tpublic final static LicenseInfo NONE = new LicenseInfo(LicenseType.NONE, 0, 0, null, null, null);\n\n\tprivate final LicenseType type;\n\tprivate final long generationDate;\n\tprivate final long expirationDate;\n\tprivate final String owner;\n\tprivate final String context;\n\tprivate final byte[] sha;\n\n\tpublic LicenseInfo(LicenseType type, long generationDate, long expirationDate, String owner, String context,\n\t\t\tbyte[] sha) {\n\t\tthis.type = type;\n\t\tthis.generationDate = generationDate;\n\t\tthis.expirationDate = expirationDate;\n\t\tthis.owner = owner;\n\t\tthis.context = context;\n\t\tthis.sha = sha;\n\t}\n\n\tpublic static void persistMe(String key) throws BackingStoreException {\n\t\tprefs.sync();\n\t\tprefs.put(\"license\", key);\n\t}\n\n\tpublic static boolean retrieveNamedOrDistributorQuickIsValid() {\n\t\treturn retrieveQuick().isValid();\n\t}\n\n\tpublic static synchronized LicenseInfo retrieveNamedSlow() {\n\t\tcache = LicenseInfo.NONE;\n//\t\tif (OptionFlags.ALLOW_INCLUDE == false)\n//\t\t\treturn cache;\n\n\t\tfinal String key = prefs.get(\"license\", \"\");\n\t\tif (key.length() > 0) {\n\t\t\tcache = setIfValid(retrieveNamed(key), cache);\n\t\t\tif (cache.isValid())\n\t\t\t\treturn cache;\n\n\t\t}\n\t\tfor (SFile f : fileCandidates()) {\n\t\t\ttry {\n\t\t\t\tif (f.exists() && f.canRead()) {\n\t\t\t\t\tfinal LicenseInfo result = retrieve(f);\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\tcache = setIfValid(result, cache);\n\t\t\t\t\tif (cache.isValid())\n\t\t\t\t\t\treturn cache;\n\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.info(\"Error \" + e);\n\t\t\t\t// Logme.error(e);\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t}\n\n\tpublic static LicenseInfo retrieveNamed(final String key) {\n\t\tif (key.length() > 99 && key.matches(\"^[0-9a-z]+$\")) {\n\t\t\ttry {\n\t\t\t\tfinal String sig = SignatureUtils.toHexString(PLSSignature.signature());\n\t\t\t\treturn PLSSignature.retrieveNamed(sig, key, true);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// Logme.error(e);\n\t\t\t\tLog.info(\"Error retrieving license info\" + e);\n\t\t\t}\n\t\t}\n\t\treturn LicenseInfo.NONE;\n\t}\n\n\tpublic static BufferedImage retrieveDistributorImage(LicenseInfo licenseInfo) {\n\t\tif (licenseInfo.getLicenseType() != LicenseType.DISTRIBUTOR) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tfinal byte[] s1 = PLSSignature.retrieveDistributorImageSignature();\n\t\t\tif (SignatureUtils.toHexString(s1).equals(SignatureUtils.toHexString(licenseInfo.sha)) == false)\n\t\t\t\treturn null;\n\n\t\t\tfinal InputStream dis = PSystemVersion.class.getResourceAsStream(\"/distributor.png\");\n\t\t\tif (dis == null)\n\t\t\t\treturn null;\n\n\t\t\ttry {\n\t\t\t\tfinal BufferedImage result = SImageIO.read(dis);\n\t\t\t\treturn result;\n\t\t\t} finally {\n\t\t\t\tdis.close();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLogme.error(e);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static LicenseInfo retrieveDistributor() {\n\t\tfinal InputStream dis = PSystemVersion.class.getResourceAsStream(\"/distributor.txt\");\n\t\tif (dis == null)\n\t\t\treturn null;\n\n\t\ttry {\n\t\t\tfinal BufferedReader br = new BufferedReader(new InputStreamReader(dis));\n\t\t\tfinal String licenseString = br.readLine();\n\t\t\tbr.close();\n\t\t\tfinal LicenseInfo result = PLSSignature.retrieveDistributor(licenseString);\n\t\t\tfinal Throwable creationPoint = new Throwable();\n\t\t\tcreationPoint.fillInStackTrace();\n\t\t\tfor (StackTraceElement ste : creationPoint.getStackTrace())\n\t\t\t\tif (ste.toString().contains(result.context))\n\t\t\t\t\treturn result;\n\n\t\t\treturn null;\n\t\t} catch (Exception e) {\n\t\t\tLogme.error(e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static Collection<SFile> fileCandidates() {\n\t\tfinal Set<SFile> result = new TreeSet<>();\n\t\tfinal String classpath = System.getProperty(\"java.class.path\");\n\t\tString[] classpathEntries = classpath.split(SFile.pathSeparator);\n\t\tfor (String s : classpathEntries) {\n\t\t\tif (s == null)\n\t\t\t\tcontinue;\n\t\t\tSFile dir = new SFile(s);\n\t\t\tif (dir.isFile())\n\t\t\t\tdir = dir.getParentFile();\n\n\t\t\tif (dir != null && dir.isDirectory())\n\t\t\t\tresult.add(dir.file(\"license.txt\"));\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static LicenseInfo setIfValid(LicenseInfo value, LicenseInfo def) {\n\t\tif (value.isValid() || def.isNone())\n\t\t\treturn value;\n\n\t\treturn def;\n\t}\n\n\tprivate static LicenseInfo retrieve(SFile f) throws IOException {\n\t\tfinal BufferedReader br = f.openBufferedReader();\n\t\tif (br == null)\n\t\t\treturn null;\n\n\t\ttry {\n\t\t\tfinal String s = br.readLine();\n\t\t\tfinal LicenseInfo result = retrieveNamed(s);\n\t\t\tif (result != null)\n\t\t\t\tLog.info(\"Reading license from \" + f.getAbsolutePath());\n\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLicenseInfo info = retrieveNamedSlow();\n\t\tSystem.err.println(\"valid=\" + info.isValid());\n\t\tSystem.err.println(\"info=\" + info.owner);\n\n\t}\n\n\tpublic final Date getGenerationDate() {\n\t\treturn new Date(generationDate);\n\t}\n\n\tpublic final Date getExpirationDate() {\n\t\treturn new Date(expirationDate);\n\t}\n\n\tpublic final String getOwner() {\n\t\treturn owner;\n\t}\n\n\tpublic boolean isNone() {\n\t\treturn owner == null;\n\t}\n\n\tpublic boolean hasExpired() {\n\t\treturn owner != null && System.currentTimeMillis() > this.expirationDate;\n\t}\n\n\tpublic final LicenseType getLicenseType() {\n\t\treturn type;\n\t}\n\n\tpublic final String getContext() {\n\t\treturn context;\n\t}\n\t// ::done\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n *\n */\npackage net.sourceforge.plantuml.version;\n\nimport static net.sourceforge.plantuml.klimt.geom.GraphicPosition.BACKGROUND_CORNER_BOTTOM_RIGHT;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport net.sourceforge.plantuml.OptionFlags;\nimport net.sourceforge.plantuml.OptionPrint;\nimport net.sourceforge.plantuml.PlainStringsDiagram;\nimport net.sourceforge.plantuml.Run;\nimport net.sourceforge.plantuml.core.DiagramDescription;\nimport net.sourceforge.plantuml.core.UmlSource;\nimport net.sourceforge.plantuml.dot.GraphvizUtils;\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.preproc.Stdlib;\nimport net.sourceforge.plantuml.preproc2.PreprocessorUtils;\nimport net.sourceforge.plantuml.security.SFile;\nimport net.sourceforge.plantuml.security.SImageIO;\nimport net.sourceforge.plantuml.security.SecurityProfile;\nimport net.sourceforge.plantuml.security.SecurityUtils;\nimport net.sourceforge.plantuml.svek.GraphvizCrash;\n\npublic class PSystemVersion extends PlainStringsDiagram {\n\n\tPSystemVersion(UmlSource source, boolean withImage, List<String> args) {\n\t\tsuper(source);\n\t\tthis.strings.addAll(args);\n\t\ttry {\n\t\t\tif (withImage) {\n\t\t\t\tthis.image = getPlantumlImage();\n\t\t\t\tthis.imagePosition = BACKGROUND_CORNER_BOTTOM_RIGHT;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate PSystemVersion(UmlSource source, List<String> args, BufferedImage image) {\n\t\tsuper(source);\n\t\tthis.strings.addAll(args);\n\t\tthis.image = image;\n\t\tthis.imagePosition = BACKGROUND_CORNER_BOTTOM_RIGHT;\n\t}\n\n\tpublic static BufferedImage getPlantumlImage() {\n\t\treturn getImage(\"logo.png\");\n\t}\n\n\tpublic static BufferedImage getTime01() {\n\t\treturn getImage(\"time01.png\");\n\t}\n\n\tpublic static BufferedImage getTime15() {\n\t\treturn getImage(\"time15.png\");\n\t}\n\n\tpublic static BufferedImage getCharlieImage() {\n\t\treturn getImage(\"charlie.png\");\n\t}\n\n\tpublic static BufferedImage getPlantumlSmallIcon() {\n\t\treturn getImage(\"favicon.png\");\n\t}\n\n\t// ::comment when __CORE__\n\tpublic static BufferedImage getArecibo() {\n\t\treturn getImage(\"arecibo.png\");\n\t}\n\n\tpublic static BufferedImage getDotc() {\n\t\treturn getImage(\"dotc.png\");\n\t}\n\n\tpublic static BufferedImage getDotd() {\n\t\treturn getImage(\"dotd.png\");\n\t}\n\n\tpublic static BufferedImage getApple2Image() {\n\t\treturn getImageWebp(\"apple2.png\");\n\t}\n\t// ::done\n\n\tprivate static BufferedImage getImage(final String name) {\n\t\ttry {\n\t\t\tfinal InputStream is = PSystemVersion.class.getResourceAsStream(name);\n\t\t\tfinal BufferedImage image = SImageIO.read(is);\n\t\t\tis.close();\n\t\t\treturn image;\n\t\t} catch (IOException e) {\n\t\t\tLogme.error(e);\n\t\t}\n\t\treturn new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n\t}\n\n\t// ::comment when __CORE__\n\tprivate static BufferedImage getImageWebp(final String name) {\n\t\ttry (InputStream is = PSystemVersion.class.getResourceAsStream(name)) {\n\t\t\treturn SFile.getBufferedImageFromWebpButHeader(is);\n\t\t} catch (IOException e) {\n\t\t\tLogme.error(e);\n\t\t}\n\t\treturn new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n\t}\n\t// ::done\n\n\tprivate static BufferedImage transparentIcon;\n\n\tpublic static BufferedImage getPlantumlSmallIcon2() {\n\t\tif (transparentIcon != null) {\n\t\t\treturn transparentIcon;\n\t\t}\n\t\tfinal BufferedImage ico = getPlantumlSmallIcon();\n\t\tif (ico == null) {\n\t\t\treturn new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n\t\t}\n\t\ttransparentIcon = new BufferedImage(ico.getWidth(), ico.getHeight(), BufferedImage.TYPE_INT_ARGB_PRE);\n\t\tfor (int i = 0; i < ico.getWidth(); i++) {\n\t\t\tfor (int j = 0; j < ico.getHeight(); j++) {\n\t\t\t\tfinal int col = ico.getRGB(i, j);\n\t\t\t\tif (col != ico.getRGB(0, 0)) {\n\t\t\t\t\ttransparentIcon.setRGB(i, j, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn transparentIcon;\n\t}\n\n\tpublic static PSystemVersion createShowVersion2(UmlSource source) {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tstrings.add(\"<b>PlantUML version \" + Version.versionString() + \"</b> (\" + Version.compileTimeString() + \")\");\n\t\tstrings.add(\"(\" + License.getCurrent() + \" source distribution)\");\n\t\t// :: uncomment when __CORE__\n//\t\tstrings.add(\" \");\n//\t\tstrings.add(\"Compiled with CheerpJ 2.3\");\n//\t\tstrings.add(\"Powered by CheerpJ, a Leaning Technologies Java tool\");\n\t\t// :: done\n\t\t// :: comment when __CORE__\n\t\tGraphvizCrash.checkOldVersionWarning(strings);\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE) {\n\t\t\tstrings.add(\"Loaded from \" + Version.getJarPath());\n\n\t\t\tif (OptionFlags.getInstance().isWord()) {\n\t\t\t\tstrings.add(\"Word Mode\");\n\t\t\t\tstrings.add(\"Command Line: \" + Run.getCommandLine());\n\t\t\t\tstrings.add(\"Current Dir: \" + new SFile(\".\").getAbsolutePath());\n\t\t\t\tstrings.add(\"plantuml.include.path: \" + PreprocessorUtils.getenv(SecurityUtils.PATHS_INCLUDES));\n\t\t\t}\n\t\t}\n\t\tstrings.add(\" \");\n\n\t\tGraphvizUtils.addDotStatus(strings, true);\n\t\tstrings.add(\" \");\n\t\tfor (String name : OptionPrint.interestingProperties())\n\t\t\tstrings.add(name);\n\n\t\tfor (String v : OptionPrint.interestingValues())\n\t\t\tstrings.add(v);\n\n\t\t// ::done\n\n\t\treturn new PSystemVersion(source, true, strings);\n\t}\n\n\t// :: comment when __CORE__\n\tpublic static PSystemVersion createStdLib(UmlSource source) {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tStdlib.addInfoVersion(strings, true);\n\t\tstrings.add(\" \");\n\n\t\treturn new PSystemVersion(source, true, strings);\n\t}\n\t// ::done\n\n\tpublic static PSystemVersion createShowAuthors2(UmlSource source) {\n\t\t// Duplicate in OptionPrint\n\t\tfinal List<String> strings = getAuthorsStrings(true);\n\t\treturn new PSystemVersion(source, true, strings);\n\t}\n\n\tpublic static List<String> getAuthorsStrings(boolean withTag) {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tadd(strings, \"<b>PlantUML version \" + Version.versionString() + \"</b> (\" + Version.compileTimeString() + \")\",\n\t\t\t\twithTag);\n\t\tadd(strings, \"(\" + License.getCurrent() + \" source distribution)\", withTag);\n\t\tadd(strings, \" \", withTag);\n\t\tadd(strings, \"<u>Original idea</u>: Arnaud Roques\", withTag);\n\t\tadd(strings, \"<u>Word Macro</u>: Alain Bertucat & Matthieu Sabatier\", withTag);\n\t\tadd(strings, \"<u>Word Add-in</u>: Adriaan van den Brand\", withTag);\n\t\tadd(strings, \"<u>J2V8 & viz.js integration</u>: Andreas Studer\", withTag);\n\t\tadd(strings, \"<u>Official Eclipse Plugin</u>: Hallvard Tr\\u00E6tteberg\", withTag);\n\t\tadd(strings, \"<u>Original Eclipse Plugin</u>: Claude Durif & Anne Pecoil\", withTag);\n\t\tadd(strings, \"<u>Servlet & XWiki</u>: Maxime Sinclair\", withTag);\n\t\tadd(strings, \"<u>Docker</u>: David Ducatel\", withTag);\n\t\tadd(strings, \"<u>AWS lib</u>: Chris Passarello\", withTag);\n\t\tadd(strings, \"<u>Stdlib Icons</u>: tupadr3\", withTag);\n\t\tadd(strings, \"<u>Site design</u>: Raphael Cotisson\", withTag);\n\t\tadd(strings, \"<u>Logo</u>: Benjamin Croizet\", withTag);\n\t\tadd(strings, \"<u>Web Assembly</u>: Sakir Temel\", withTag);\n\n\t\tadd(strings, \" \", withTag);\n\t\tadd(strings, \"https://plantuml.com\", withTag);\n\t\tadd(strings, \" \", withTag);\n\t\treturn strings;\n\t}\n\n\tprivate static void add(List<String> result, String s, boolean withTag) {\n\t\tif (withTag == false)\n\t\t\ts = s.replaceAll(\"\\\\</?\\\\w+\\\\>\", \"\");\n\n\t\tresult.add(s);\n\n\t}\n\n\t// ::comment when __CORE__\n\tpublic static PSystemVersion createTestDot(UmlSource source) throws IOException {\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tstrings.add(Version.fullDescription());\n\t\tGraphvizUtils.addDotStatus(strings, true);\n\t\treturn new PSystemVersion(source, false, strings);\n\t}\n\t// ::done\n\n//\tpublic static PSystemVersion createDumpStackTrace() throws IOException {\n//\t\tfinal List<String> strings = new ArrayList<>();\n//\t\tfinal Throwable creationPoint = new Throwable();\n//\t\tcreationPoint.fillInStackTrace();\n//\t\tfor (StackTraceElement ste : creationPoint.getStackTrace()) {\n//\t\t\tstrings.add(ste.toString());\n//\t\t}\n//\t\treturn new PSystemVersion(false, strings);\n//\t}\n\n\t// ::comment when __CORE__\n\tpublic static PSystemVersion createKeyDistributor(UmlSource source) throws IOException {\n\t\tfinal LicenseInfo license = LicenseInfo.retrieveDistributor();\n\t\tBufferedImage im = null;\n\t\tfinal List<String> strings = new ArrayList<>();\n\t\tif (license == null) {\n\t\t\tstrings.add(\"No license found\");\n\t\t} else {\n\t\t\tstrings.add(license.getOwner());\n\t\t\tstrings.add(license.getContext());\n\t\t\tstrings.add(license.getGenerationDate().toString());\n\t\t\tstrings.add(license.getExpirationDate().toString());\n\t\t\tim = LicenseInfo.retrieveDistributorImage(license);\n\t\t}\n\t\treturn new PSystemVersion(source, strings, im);\n\t}\n\t// ::done\n\n//\tpublic static PSystemVersion createPath(UmlSource source) throws IOException {\n//\t\tfinal List<String> strings = new ArrayList<>();\n//\t\tstrings.add(\"<u>Current Dir</u>: \" + new SFile(\".\").getPrintablePath());\n//\t\tstrings.add(\" \");\n//\t\tstrings.add(\"<u>Default path</u>:\");\n//\t\tfor (SFile f : ImportedFiles.createImportedFiles(null).getPath()) {\n//\t\t\tstrings.add(f.getPrintablePath());\n//\t\t}\n//\t\treturn new PSystemVersion(source, true, strings);\n//\t}\n\n\tpublic DiagramDescription getDescription() {\n\t\treturn new DiagramDescription(\"(Version)\");\n\t}\n\n\tpublic List<String> getLines() {\n\t\treturn Collections.unmodifiableList(strings);\n\t}\n\n}\n", "/* ========================================================================\n * PlantUML : a free UML diagram generator\n * ========================================================================\n *\n * (C) Copyright 2009-2024, Arnaud Roques\n *\n * Project Info:  https://plantuml.com\n * \n * If you like this project or if you find it useful, you can support us at:\n * \n * https://plantuml.com/patreon (only 1$ per month!)\n * https://plantuml.com/paypal\n * \n * This file is part of PlantUML.\n *\n * PlantUML is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * PlantUML distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n * License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n *\n * Original Author:  Arnaud Roques\n * \n *\n */\npackage net.sourceforge.plantuml.version;\n\nimport java.util.Date;\n\nimport net.sourceforge.plantuml.log.Logme;\nimport net.sourceforge.plantuml.security.SURL;\nimport net.sourceforge.plantuml.utils.SignatureUtils;\n\npublic class Version {\n\t// ::remove folder when __HAXE__\n\n\t// Warning, \"version\" should be the same in gradle.properties and Version.java\n\t// Any idea anyone how to magically synchronize those :-) ?\n\tprivate static final String version = \"1.2023.9beta5\";\n\n\tpublic static String versionString() {\n\t\treturn version;\n\t}\n\n\tpublic static String fullDescription() {\n\t\treturn \"PlantUML version \" + Version.versionString() + \" (\" + Version.compileTimeString() + \")\";\n\t}\n\n\tpublic static String versionString(int size) {\n\t\tfinal StringBuilder sb = new StringBuilder(versionString());\n\t\twhile (sb.length() < size)\n\t\t\tsb.append(' ');\n\n\t\treturn sb.toString();\n\t}\n\n\tpublic static int beta() {\n\t\tfinal int x = version.indexOf(\"beta\");\n\t\tif (x == -1)\n\t\t\treturn 0;\n\t\treturn Integer.parseInt(version.substring(x + \"beta\".length()));\n\t}\n\n\tpublic static String etag() {\n\t\treturn SignatureUtils.getMD5Hex(version);\n\t}\n\n\tpublic static String turningId() {\n\t\treturn etag();\n\t}\n\n\tpublic static long compileTime() {\n\t\treturn 1684658280620L;\n\t}\n\n\tpublic static String compileTimeString() {\n\t\tif (version.contains(\"beta\"))\n\t\t\treturn \"Unknown compile time\";\n\n\t\treturn new Date(Version.compileTime()).toString();\n\t}\n\n\t// ::comment when __CORE__\n\tpublic static String getJarPath() {\n\t\ttry {\n\t\t\tfinal ClassLoader loader = Version.class.getClassLoader();\n\t\t\tif (loader == null) {\n\t\t\t\treturn \"No ClassLoader?\";\n\t\t\t}\n\t\t\tfinal SURL url = SURL.create(loader.getResource(\"net/sourceforge/plantuml/version/Version.class\"));\n\t\t\tif (url == null) {\n\t\t\t\treturn \"No URL?\";\n\t\t\t}\n\t\t\tString fullpath = url.toString();\n\t\t\tfullpath = fullpath.replaceAll(\"net/sourceforge/plantuml/version/Version\\\\.class\", \"\");\n\t\t\treturn fullpath;\n\t\t} catch (Throwable t) {\n\t\t\tLogme.error(t);\n\t\t\treturn t.toString();\n\t\t}\n\t}\n\t// ::done\n\n}\n"], "filenames": ["gradle.properties", "src/net/sourceforge/plantuml/OptionFlags.java", "src/net/sourceforge/plantuml/preproc/ImportedFiles.java", "src/net/sourceforge/plantuml/security/SFile.java", "src/net/sourceforge/plantuml/security/SURL.java", "src/net/sourceforge/plantuml/security/SecurityProfile.java", "src/net/sourceforge/plantuml/security/SecurityUtils.java", "src/net/sourceforge/plantuml/tim/stdlib/FileExists.java", "src/net/sourceforge/plantuml/tim/stdlib/Getenv.java", "src/net/sourceforge/plantuml/tim/stdlib/LoadJson.java", "src/net/sourceforge/plantuml/version/LicenseInfo.java", "src/net/sourceforge/plantuml/version/PSystemVersion.java", "src/net/sourceforge/plantuml/version/Version.java"], "buggy_code_start_loc": [3, 77, 43, 120, 219, 58, 225, 41, 41, 168, 111, 178, 49], "buggy_code_end_loc": [4, 82, 175, 261, 220, 163, 235, 78, 85, 183, 113, 181, 50], "fixing_code_start_loc": [3, 77, 42, 120, 219, 58, 225, 40, 40, 168, 111, 178, 49], "fixing_code_end_loc": [4, 82, 172, 261, 220, 177, 235, 71, 84, 180, 113, 180, 50], "type": "CWE-284", "message": "Improper Access Control in GitHub repository plantuml/plantuml prior to 1.2023.9.", "other": {"cve": {"id": "CVE-2023-3431", "sourceIdentifier": "security@huntr.dev", "published": "2023-06-27T15:15:11.743", "lastModified": "2024-02-01T01:21:58.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository plantuml/plantuml prior to 1.2023.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plantuml:plantuml:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2023.9", "matchCriteriaId": "389D4A80-A72D-42CC-885E-818A52175C8A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://github.com/plantuml/plantuml/commit/fbe7fa3b25b4c887d83927cffb1009ec6cb8ab1e", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/fa741f95-b53c-4ed7-b157-e32c5145164c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FV7XL3CY3K3K5ER3ASMEQA546MIQQ7QM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/plantuml/plantuml/commit/fbe7fa3b25b4c887d83927cffb1009ec6cb8ab1e"}}