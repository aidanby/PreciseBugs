{"buggy_code": ["<?php\n/*\n @version   v5.20.20  01-Feb-2021\n @copyright (c) 2000-2013 John Lim (jlim#natsoft.com). All rights reserved.\n @copyright (c) 2014      Damien Regad, Mark Newnham and the ADOdb community\n  Released under both BSD license and Lesser GPL library license.\n  Whenever there is any discrepancy between the two licenses,\n  the BSD license will take precedence.\n  Set tabs to 8.\n\n  Original version derived from Alberto Cerezal (acerezalp@dbnet.es) - DBNet Informatica & Comunicaciones.\n  08 Nov 2000 jlim - Minor corrections, removing mysql stuff\n  09 Nov 2000 jlim - added insertid support suggested by \"Christopher Kings-Lynne\" <chriskl@familyhealth.com.au>\n\t\t\t  jlim - changed concat operator to || and data types to MetaType to match documented pgsql types\n\t\t\t\t\t see http://www.postgresql.org/devel-corner/docs/postgres/datatype.htm\n  22 Nov 2000 jlim - added changes to FetchField() and MetaTables() contributed by \"raser\" <raser@mail.zen.com.tw>\n  27 Nov 2000 jlim - added changes to _connect/_pconnect from ideas by \"Lennie\" <leen@wirehub.nl>\n  15 Dec 2000 jlim - added changes suggested by Additional code changes by \"Eric G. Werk\" egw@netguide.dk.\n  31 Jan 2002 jlim - finally installed postgresql. testing\n  01 Mar 2001 jlim - Freek Dijkstra changes, also support for text type\n\n  See http://www.varlena.com/varlena/GeneralBits/47.php\n\n\t-- What indexes are on my table?\n\tselect * from pg_indexes where tablename = 'tablename';\n\n\t-- What triggers are on my table?\n\tselect c.relname as \"Table\", t.tgname as \"Trigger Name\",\n\t   t.tgconstrname as \"Constraint Name\", t.tgenabled as \"Enabled\",\n\t   t.tgisconstraint as \"Is Constraint\", cc.relname as \"Referenced Table\",\n\t   p.proname as \"Function Name\"\n\tfrom pg_trigger t, pg_class c, pg_class cc, pg_proc p\n\twhere t.tgfoid = p.oid and t.tgrelid = c.oid\n\t   and t.tgconstrrelid = cc.oid\n\t   and c.relname = 'tablename';\n\n\t-- What constraints are on my table?\n\tselect r.relname as \"Table\", c.conname as \"Constraint Name\",\n\t   contype as \"Constraint Type\", conkey as \"Key Columns\",\n\t   confkey as \"Foreign Columns\", consrc as \"Source\"\n\tfrom pg_class r, pg_constraint c\n\twhere r.oid = c.conrelid\n\t   and relname = 'tablename';\n\n*/\n\n// security - hide paths\nif (!defined('ADODB_DIR')) die();\n\nfunction adodb_addslashes($s)\n{\n\t$len = strlen($s);\n\tif ($len == 0) return \"''\";\n\tif (strncmp($s,\"'\",1) === 0 && substr($s,$len-1) == \"'\") return $s; // already quoted\n\n\treturn \"'\".addslashes($s).\"'\";\n}\n\nclass ADODB_postgres64 extends ADOConnection{\n\tvar $databaseType = 'postgres64';\n\tvar $dataProvider = 'postgres';\n\tvar $hasInsertID = true;\n\tvar $_resultid = false;\n\tvar $concat_operator='||';\n\tvar $metaDatabasesSQL = \"select datname from pg_database where datname not in ('template0','template1') order by 1\";\n\tvar $metaTablesSQL = \"select tablename,'T' from pg_tables where tablename not like 'pg\\_%'\n\t\tand tablename not in ('sql_features', 'sql_implementation_info', 'sql_languages',\n\t\t\t'sql_packages', 'sql_sizing', 'sql_sizing_profiles')\n\tunion\n\t\tselect viewname,'V' from pg_views where viewname not like 'pg\\_%'\";\n\t//\"select tablename from pg_tables where tablename not like 'pg_%' order by 1\";\n\tvar $isoDates = true; // accepts dates in ISO format\n\tvar $sysDate = \"CURRENT_DATE\";\n\tvar $sysTimeStamp = \"CURRENT_TIMESTAMP\";\n\tvar $blobEncodeType = 'C';\n\tvar $metaColumnsSQL = \"SELECT a.attname,t.typname,a.attlen,a.atttypmod,a.attnotnull,a.atthasdef,a.attnum\n\t\tFROM pg_class c, pg_attribute a,pg_type t\n\t\tWHERE relkind in ('r','v') AND (c.relname='%s' or c.relname = lower('%s')) and a.attname not like '....%%'\n\t\tAND a.attnum > 0 AND a.atttypid = t.oid AND a.attrelid = c.oid ORDER BY a.attnum\";\n\n\t// used when schema defined\n\tvar $metaColumnsSQL1 = \"SELECT a.attname, t.typname, a.attlen, a.atttypmod, a.attnotnull, a.atthasdef, a.attnum\n\t\tFROM pg_class c, pg_attribute a, pg_type t, pg_namespace n\n\t\tWHERE relkind in ('r','v') AND (c.relname='%s' or c.relname = lower('%s'))\n\t\tand c.relnamespace=n.oid and n.nspname='%s'\n\t\tand a.attname not like '....%%' AND a.attnum > 0\n\t\tAND a.atttypid = t.oid AND a.attrelid = c.oid ORDER BY a.attnum\";\n\n\t// get primary key etc -- from Freek Dijkstra\n\tvar $metaKeySQL = \"SELECT ic.relname AS index_name, a.attname AS column_name,i.indisunique AS unique_key, i.indisprimary AS primary_key\n\t\tFROM pg_class bc, pg_class ic, pg_index i, pg_attribute a\n\t\tWHERE bc.oid = i.indrelid AND ic.oid = i.indexrelid\n\t\tAND (i.indkey[0] = a.attnum OR i.indkey[1] = a.attnum OR i.indkey[2] = a.attnum OR i.indkey[3] = a.attnum OR i.indkey[4] = a.attnum OR i.indkey[5] = a.attnum OR i.indkey[6] = a.attnum OR i.indkey[7] = a.attnum)\n\t\tAND a.attrelid = bc.oid AND bc.relname = '%s'\";\n\n\tvar $hasAffectedRows = true;\n\tvar $hasLimit = false;\t// set to true for pgsql 7 only. support pgsql/mysql SELECT * FROM TABLE LIMIT 10\n\t// below suggested by Freek Dijkstra\n\tvar $true = 'TRUE';\t\t// string that represents TRUE for a database\n\tvar $false = 'FALSE';\t\t// string that represents FALSE for a database\n\tvar $fmtDate = \"'Y-m-d'\";\t// used by DBDate() as the default date format used by the database\n\tvar $fmtTimeStamp = \"'Y-m-d H:i:s'\"; // used by DBTimeStamp as the default timestamp fmt.\n\tvar $hasMoveFirst = true;\n\tvar $hasGenID = true;\n\tvar $_genIDSQL = \"SELECT NEXTVAL('%s')\";\n\tvar $_genSeqSQL = \"CREATE SEQUENCE %s START %s\";\n\tvar $_dropSeqSQL = \"DROP SEQUENCE %s\";\n\tvar $metaDefaultsSQL = \"SELECT d.adnum as num, d.adsrc as def from pg_attrdef d, pg_class c where d.adrelid=c.oid and c.relname='%s' order by d.adnum\";\n\tvar $random = 'random()';\t\t/// random function\n\tvar $autoRollback = true; // apparently pgsql does not autorollback properly before php 4.3.4\n\t\t\t\t\t\t\t// http://bugs.php.net/bug.php?id=25404\n\n\tvar $uniqueIisR = true;\n\tvar $_bindInputArray = false; // requires postgresql 7.3+ and ability to modify database\n\tvar $disableBlobs = false; // set to true to disable blob checking, resulting in 2-5% improvement in performance.\n\n\tvar $_pnum = 0;\n\n\t// The last (fmtTimeStamp is not entirely correct:\n\t// PostgreSQL also has support for time zones,\n\t// and writes these time in this format: \"2001-03-01 18:59:26+02\".\n\t// There is no code for the \"+02\" time zone information, so I just left that out.\n\t// I'm not familiar enough with both ADODB as well as Postgres\n\t// to know what the concequences are. The other values are correct (wheren't in 0.94)\n\t// -- Freek Dijkstra\n\n\tfunction __construct()\n\t{\n\t\t// changes the metaColumnsSQL, adds columns: attnum[6]\n\t}\n\n\tfunction ServerInfo()\n\t{\n\t\tif (isset($this->version)) return $this->version;\n\n\t\t$arr['description'] = $this->GetOne(\"select version()\");\n\t\t$arr['version'] = ADOConnection::_findvers($arr['description']);\n\t\t$this->version = $arr;\n\t\treturn $arr;\n\t}\n\n\tfunction IfNull( $field, $ifNull )\n\t{\n\t\treturn \" coalesce($field, $ifNull) \";\n\t}\n\n\t// get the last id - never tested\n\tfunction pg_insert_id($tablename,$fieldname)\n\t{\n\t\t$result=pg_query($this->_connectionID, 'SELECT last_value FROM '. $tablename .'_'. $fieldname .'_seq');\n\t\tif ($result) {\n\t\t\t$arr = @pg_fetch_row($result,0);\n\t\t\tpg_free_result($result);\n\t\t\tif (isset($arr[0])) return $arr[0];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Warning from http://www.php.net/manual/function.pg-getlastoid.php:\n\t * Using a OID as a unique identifier is not generally wise.\n\t * Unless you are very careful, you might end up with a tuple having\n\t * a different OID if a database must be reloaded.\n\t */\n\tfunction _insertid($table,$column)\n\t{\n\t\tif (!is_resource($this->_resultid) || get_resource_type($this->_resultid) !== 'pgsql result') return false;\n\t\t$oid = pg_last_oid($this->_resultid);\n\t\t// to really return the id, we need the table and column-name, else we can only return the oid != id\n\t\treturn empty($table) || empty($column) ? $oid : $this->GetOne(\"SELECT $column FROM $table WHERE oid=\".(int)$oid);\n\t}\n\n\tfunction _affectedrows()\n\t{\n\t\tif (!is_resource($this->_resultid) || get_resource_type($this->_resultid) !== 'pgsql result') return false;\n\t\treturn pg_affected_rows($this->_resultid);\n\t}\n\n\n\t/**\n\t * @return true/false\n\t */\n\tfunction BeginTrans()\n\t{\n\t\tif ($this->transOff) return true;\n\t\t$this->transCnt += 1;\n\t\treturn pg_query($this->_connectionID, 'begin '.$this->_transmode);\n\t}\n\n\tfunction RowLock($tables,$where,$col='1 as adodbignore')\n\t{\n\t\tif (!$this->transCnt) $this->BeginTrans();\n\t\treturn $this->GetOne(\"select $col from $tables where $where for update\");\n\t}\n\n\t// returns true/false.\n\tfunction CommitTrans($ok=true)\n\t{\n\t\tif ($this->transOff) return true;\n\t\tif (!$ok) return $this->RollbackTrans();\n\n\t\t$this->transCnt -= 1;\n\t\treturn pg_query($this->_connectionID, 'commit');\n\t}\n\n\t// returns true/false\n\tfunction RollbackTrans()\n\t{\n\t\tif ($this->transOff) return true;\n\t\t$this->transCnt -= 1;\n\t\treturn pg_query($this->_connectionID, 'rollback');\n\t}\n\n\tfunction MetaTables($ttype=false,$showSchema=false,$mask=false)\n\t{\n\t\t$info = $this->ServerInfo();\n\t\tif ($info['version'] >= 7.3) {\n\t\t$this->metaTablesSQL = \"\n\t\t\tselect table_name,'T' from information_schema.tables where table_schema not in ( 'pg_catalog','information_schema')\n\t\t\tunion\n\t\t\tselect table_name,'V' from information_schema.views where table_schema not in ( 'pg_catalog','information_schema') \";\n\t\t}\n\t\tif ($mask) {\n\t\t\t$save = $this->metaTablesSQL;\n\t\t\t$mask = $this->qstr(strtolower($mask));\n\t\t\tif ($info['version']>=7.3)\n\t\t\t\t$this->metaTablesSQL = \"\n\t\t\t\t\tselect table_name,'T' from information_schema.tables where table_name like $mask and table_schema not in ( 'pg_catalog','information_schema')\n\t\t\t\t\tunion\n\t\t\t\t\tselect table_name,'V' from information_schema.views where table_name like $mask and table_schema not in ( 'pg_catalog','information_schema') \";\n\t\t\telse\n\t\t\t\t$this->metaTablesSQL = \"\n\t\t\t\t\tselect tablename,'T' from pg_tables where tablename like $mask\n\t\t\t\t\tunion\n\t\t\t\t\tselect viewname,'V' from pg_views where viewname like $mask\";\n\t\t}\n\t\t$ret = ADOConnection::MetaTables($ttype,$showSchema);\n\n\t\tif ($mask) {\n\t\t\t$this->metaTablesSQL = $save;\n\t\t}\n\t\treturn $ret;\n\t}\n\n\n\t// if magic quotes disabled, use pg_escape_string()\n\tfunction qstr($s,$magic_quotes=false)\n\t{\n\t\tif (is_bool($s)) return $s ? 'true' : 'false';\n\n\t\tif (!$magic_quotes) {\n\t\t\tif (ADODB_PHPVER >= 0x5200 && $this->_connectionID) {\n\t\t\t\treturn  \"'\".pg_escape_string($this->_connectionID,$s).\"'\";\n\t\t\t}\n\t\t\tif (ADODB_PHPVER >= 0x4200) {\n\t\t\t\treturn  \"'\".pg_escape_string($s).\"'\";\n\t\t\t}\n\t\t\tif ($this->replaceQuote[0] == '\\\\'){\n\t\t\t\t$s = adodb_str_replace(array('\\\\',\"\\0\"),array('\\\\\\\\',\"\\\\\\\\000\"),$s);\n\t\t\t}\n\t\t\treturn  \"'\".str_replace(\"'\",$this->replaceQuote,$s).\"'\";\n\t\t}\n\n\t\t// undo magic quotes for \"\n\t\t$s = str_replace('\\\\\"','\"',$s);\n\t\treturn \"'$s'\";\n\t}\n\n\n\n\t// Format date column in sql string given an input format that understands Y M D\n\tfunction SQLDate($fmt, $col=false)\n\t{\n\t\tif (!$col) $col = $this->sysTimeStamp;\n\t\t$s = 'TO_CHAR('.$col.\",'\";\n\n\t\t$len = strlen($fmt);\n\t\tfor ($i=0; $i < $len; $i++) {\n\t\t\t$ch = $fmt[$i];\n\t\t\tswitch($ch) {\n\t\t\tcase 'Y':\n\t\t\tcase 'y':\n\t\t\t\t$s .= 'YYYY';\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\tcase 'q':\n\t\t\t\t$s .= 'Q';\n\t\t\t\tbreak;\n\n\t\t\tcase 'M':\n\t\t\t\t$s .= 'Mon';\n\t\t\t\tbreak;\n\n\t\t\tcase 'm':\n\t\t\t\t$s .= 'MM';\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\t\t$s .= 'DD';\n\t\t\t\tbreak;\n\n\t\t\tcase 'H':\n\t\t\t\t$s.= 'HH24';\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\t\t$s .= 'HH';\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\t$s .= 'MI';\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\t$s .= 'SS';\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\t$s .= 'AM';\n\t\t\t\tbreak;\n\n\t\t\tcase 'w':\n\t\t\t\t$s .= 'D';\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\t$s .= 'DAY';\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\t$s .= 'WW';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t// handle escape characters...\n\t\t\t\tif ($ch == '\\\\') {\n\t\t\t\t\t$i++;\n\t\t\t\t\t$ch = substr($fmt,$i,1);\n\t\t\t\t}\n\t\t\t\tif (strpos('-/.:;, ',$ch) !== false) $s .= $ch;\n\t\t\t\telse $s .= '\"'.$ch.'\"';\n\n\t\t\t}\n\t\t}\n\t\treturn $s. \"')\";\n\t}\n\n\n\n\t/*\n\t* Load a Large Object from a file\n\t* - the procedure stores the object id in the table and imports the object using\n\t* postgres proprietary blob handling routines\n\t*\n\t* contributed by Mattia Rossi mattia@technologist.com\n\t* modified for safe mode by juraj chlebec\n\t*/\n\tfunction UpdateBlobFile($table,$column,$path,$where,$blobtype='BLOB')\n\t{\n\t\tpg_query($this->_connectionID, 'begin');\n\n\t\t$fd = fopen($path,'r');\n\t\t$contents = fread($fd,filesize($path));\n\t\tfclose($fd);\n\n\t\t$oid = pg_lo_create($this->_connectionID);\n\t\t$handle = pg_lo_open($this->_connectionID, $oid, 'w');\n\t\tpg_lo_write($handle, $contents);\n\t\tpg_lo_close($handle);\n\n\t\t// $oid = pg_lo_import ($path);\n\t\tpg_query($this->_connectionID, 'commit');\n\t\t$rs = ADOConnection::UpdateBlob($table,$column,$oid,$where,$blobtype);\n\t\t$rez = !empty($rs);\n\t\treturn $rez;\n\t}\n\n\t/*\n\t* Deletes/Unlinks a Blob from the database, otherwise it\n\t* will be left behind\n\t*\n\t* Returns TRUE on success or FALSE on failure.\n\t*\n\t* contributed by Todd Rogers todd#windfox.net\n\t*/\n\tfunction BlobDelete( $blob )\n\t{\n\t\tpg_query($this->_connectionID, 'begin');\n\t\t$result = @pg_lo_unlink($blob);\n\t\tpg_query($this->_connectionID, 'commit');\n\t\treturn( $result );\n\t}\n\n\t/*\n\t\tHueristic - not guaranteed to work.\n\t*/\n\tfunction GuessOID($oid)\n\t{\n\t\tif (strlen($oid)>16) return false;\n\t\treturn is_numeric($oid);\n\t}\n\n\t/*\n\t* If an OID is detected, then we use pg_lo_* to open the oid file and read the\n\t* real blob from the db using the oid supplied as a parameter. If you are storing\n\t* blobs using bytea, we autodetect and process it so this function is not needed.\n\t*\n\t* contributed by Mattia Rossi mattia@technologist.com\n\t*\n\t* see http://www.postgresql.org/idocs/index.php?largeobjects.html\n\t*\n\t* Since adodb 4.54, this returns the blob, instead of sending it to stdout. Also\n\t* added maxsize parameter, which defaults to $db->maxblobsize if not defined.\n\t*/\n\tfunction BlobDecode($blob,$maxsize=false,$hastrans=true)\n\t{\n\t\tif (!$this->GuessOID($blob)) return $blob;\n\n\t\tif ($hastrans) pg_query($this->_connectionID,'begin');\n\t\t$fd = @pg_lo_open($this->_connectionID,$blob,'r');\n\t\tif ($fd === false) {\n\t\t\tif ($hastrans) pg_query($this->_connectionID,'commit');\n\t\t\treturn $blob;\n\t\t}\n\t\tif (!$maxsize) $maxsize = $this->maxblobsize;\n\t\t$realblob = @pg_lo_read($fd,$maxsize);\n\t\t@pg_lo_close($fd);\n\t\tif ($hastrans) pg_query($this->_connectionID,'commit');\n\t\treturn $realblob;\n\t}\n\n\t/*\n\t\tSee http://www.postgresql.org/idocs/index.php?datatype-binary.html\n\n\t\tNOTE: SQL string literals (input strings) must be preceded with two backslashes\n\t\tdue to the fact that they must pass through two parsers in the PostgreSQL\n\t\tbackend.\n\t*/\n\tfunction BlobEncode($blob)\n\t{\n\t\tif (ADODB_PHPVER >= 0x5200) return pg_escape_bytea($this->_connectionID, $blob);\n\t\tif (ADODB_PHPVER >= 0x4200) return pg_escape_bytea($blob);\n\n\t\t/*92=backslash, 0=null, 39=single-quote*/\n\t\t$badch = array(chr(92),chr(0),chr(39)); # \\  null  '\n\t\t$fixch = array('\\\\\\\\134','\\\\\\\\000','\\\\\\\\047');\n\t\treturn adodb_str_replace($badch,$fixch,$blob);\n\n\t\t// note that there is a pg_escape_bytea function only for php 4.2.0 or later\n\t}\n\n\t// assumes bytea for blob, and varchar for clob\n\tfunction UpdateBlob($table,$column,$val,$where,$blobtype='BLOB')\n\t{\n\t\tif ($blobtype == 'CLOB') {\n\t\t\treturn $this->Execute(\"UPDATE $table SET $column=\" . $this->qstr($val) . \" WHERE $where\");\n\t\t}\n\t\t// do not use bind params which uses qstr(), as blobencode() already quotes data\n\t\treturn $this->Execute(\"UPDATE $table SET $column='\".$this->BlobEncode($val).\"'::bytea WHERE $where\");\n\t}\n\n\tfunction OffsetDate($dayFraction,$date=false)\n\t{\n\t\tif (!$date) $date = $this->sysDate;\n\t\telse if (strncmp($date,\"'\",1) == 0) {\n\t\t\t$len = strlen($date);\n\t\t\tif (10 <= $len && $len <= 12) $date = 'date '.$date;\n\t\t\telse $date = 'timestamp '.$date;\n\t\t}\n\n\n\t\treturn \"($date+interval'\".($dayFraction * 1440).\" minutes')\";\n\t\t#return \"($date+interval'$dayFraction days')\";\n\t}\n\n\t/**\n\t * Generate the SQL to retrieve MetaColumns data\n\t * @param string $table Table name\n\t * @param string $schema Schema name (can be blank)\n\t * @return string SQL statement to execute\n\t */\n\tprotected function _generateMetaColumnsSQL($table, $schema)\n\t{\n\t\tif ($schema) {\n\t\t\treturn sprintf($this->metaColumnsSQL1, $table, $table, $schema);\n\t\t}\n\t\telse {\n\t\t\treturn sprintf($this->metaColumnsSQL, $table, $table, $schema);\n\t\t}\n\t}\n\n\t// for schema support, pass in the $table param \"$schema.$tabname\".\n\t// converts field names to lowercase, $upper is ignored\n\t// see PHPLens Issue No: 14018 for more info\n\tfunction MetaColumns($table,$normalize=true)\n\t{\n\t\tglobal $ADODB_FETCH_MODE;\n\n\t\t$schema = false;\n\t\t$false = false;\n\t\t$this->_findschema($table,$schema);\n\n\t\tif ($normalize) $table = strtolower($table);\n\n\t\t$save = $ADODB_FETCH_MODE;\n\t\t$ADODB_FETCH_MODE = ADODB_FETCH_NUM;\n\t\tif ($this->fetchMode !== false) $savem = $this->SetFetchMode(false);\n\n\t\t$rs = $this->Execute($this->_generateMetaColumnsSQL($table, $schema));\n\t\tif (isset($savem)) $this->SetFetchMode($savem);\n\t\t$ADODB_FETCH_MODE = $save;\n\n\t\tif ($rs === false) {\n\t\t\treturn $false;\n\t\t}\n\t\tif (!empty($this->metaKeySQL)) {\n\t\t\t// If we want the primary keys, we have to issue a separate query\n\t\t\t// Of course, a modified version of the metaColumnsSQL query using a\n\t\t\t// LEFT JOIN would have been much more elegant, but postgres does\n\t\t\t// not support OUTER JOINS. So here is the clumsy way.\n\n\t\t\t$ADODB_FETCH_MODE = ADODB_FETCH_ASSOC;\n\n\t\t\t$rskey = $this->Execute(sprintf($this->metaKeySQL,($table)));\n\t\t\t// fetch all result in once for performance.\n\t\t\t$keys = $rskey->GetArray();\n\t\t\tif (isset($savem)) $this->SetFetchMode($savem);\n\t\t\t$ADODB_FETCH_MODE = $save;\n\n\t\t\t$rskey->Close();\n\t\t\tunset($rskey);\n\t\t}\n\n\t\t$rsdefa = array();\n\t\tif (!empty($this->metaDefaultsSQL)) {\n\t\t\t$ADODB_FETCH_MODE = ADODB_FETCH_ASSOC;\n\t\t\t$sql = sprintf($this->metaDefaultsSQL, ($table));\n\t\t\t$rsdef = $this->Execute($sql);\n\t\t\tif (isset($savem)) $this->SetFetchMode($savem);\n\t\t\t$ADODB_FETCH_MODE = $save;\n\n\t\t\tif ($rsdef) {\n\t\t\t\twhile (!$rsdef->EOF) {\n\t\t\t\t\t$num = $rsdef->fields['num'];\n\t\t\t\t\t$s = $rsdef->fields['def'];\n\t\t\t\t\tif (strpos($s,'::')===false && substr($s, 0, 1) == \"'\") { /* quoted strings hack... for now... fixme */\n\t\t\t\t\t\t$s = substr($s, 1);\n\t\t\t\t\t\t$s = substr($s, 0, strlen($s) - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\t$rsdefa[$num] = $s;\n\t\t\t\t\t$rsdef->MoveNext();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tADOConnection::outp( \"==> SQL => \" . $sql);\n\t\t\t}\n\t\t\tunset($rsdef);\n\t\t}\n\n\t\t$retarr = array();\n\t\twhile (!$rs->EOF) {\n\t\t\t$fld = new ADOFieldObject();\n\t\t\t$fld->name = $rs->fields[0];\n\t\t\t$fld->type = $rs->fields[1];\n\t\t\t$fld->max_length = $rs->fields[2];\n\t\t\t$fld->attnum = $rs->fields[6];\n\n\t\t\tif ($fld->max_length <= 0) $fld->max_length = $rs->fields[3]-4;\n\t\t\tif ($fld->max_length <= 0) $fld->max_length = -1;\n\t\t\tif ($fld->type == 'numeric') {\n\t\t\t\t$fld->scale = $fld->max_length & 0xFFFF;\n\t\t\t\t$fld->max_length >>= 16;\n\t\t\t}\n\t\t\t// dannym\n\t\t\t// 5 hasdefault; 6 num-of-column\n\t\t\t$fld->has_default = ($rs->fields[5] == 't');\n\t\t\tif ($fld->has_default) {\n\t\t\t\t$fld->default_value = $rsdefa[$rs->fields[6]];\n\t\t\t}\n\n\t\t\t//Freek\n\t\t\t$fld->not_null = $rs->fields[4] == 't';\n\n\n\t\t\t// Freek\n\t\t\tif (is_array($keys)) {\n\t\t\t\tforeach($keys as $key) {\n\t\t\t\t\tif ($fld->name == $key['column_name'] AND $key['primary_key'] == 't')\n\t\t\t\t\t\t$fld->primary_key = true;\n\t\t\t\t\tif ($fld->name == $key['column_name'] AND $key['unique_key'] == 't')\n\t\t\t\t\t\t$fld->unique = true; // What name is more compatible?\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($ADODB_FETCH_MODE == ADODB_FETCH_NUM) $retarr[] = $fld;\n\t\t\telse $retarr[($normalize) ? strtoupper($fld->name) : $fld->name] = $fld;\n\n\t\t\t$rs->MoveNext();\n\t\t}\n\t\t$rs->Close();\n\t\tif (empty($retarr))\n\t\t\treturn  $false;\n\t\telse\n\t\t\treturn $retarr;\n\n\t}\n\n\tfunction Param($name,$type='C')\n\t{\n\t\tif ($name) {\n\t\t\t$this->_pnum += 1;\n\t\t} else {\n\t\t\t// Reset param num if $name is false\n\t\t\t$this->_pnum = 1;\n\t\t}\n\t\treturn '$'.$this->_pnum;\n\t}\n\n\tfunction MetaIndexes ($table, $primary = FALSE, $owner = false)\n\t{\n\t\tglobal $ADODB_FETCH_MODE;\n\n\t\t$schema = false;\n\t\t$this->_findschema($table,$schema);\n\n\t\tif ($schema) { // requires pgsql 7.3+ - pg_namespace used.\n\t\t\t$sql = '\n\t\t\t\tSELECT c.relname as \"Name\", i.indisunique as \"Unique\", i.indkey as \"Columns\"\n\t\t\t\tFROM pg_catalog.pg_class c\n\t\t\t\tJOIN pg_catalog.pg_index i ON i.indexrelid=c.oid\n\t\t\t\tJOIN pg_catalog.pg_class c2 ON c2.oid=i.indrelid\n\t\t\t\t\t,pg_namespace n\n\t\t\t\tWHERE (c2.relname=\\'%s\\' or c2.relname=lower(\\'%s\\'))\n\t\t\t\tand c.relnamespace=c2.relnamespace\n\t\t\t\tand c.relnamespace=n.oid\n\t\t\t\tand n.nspname=\\'%s\\'';\n\t\t} else {\n\t\t\t$sql = '\n\t\t\t\tSELECT c.relname as \"Name\", i.indisunique as \"Unique\", i.indkey as \"Columns\"\n\t\t\t\tFROM pg_catalog.pg_class c\n\t\t\t\tJOIN pg_catalog.pg_index i ON i.indexrelid=c.oid\n\t\t\t\tJOIN pg_catalog.pg_class c2 ON c2.oid=i.indrelid\n\t\t\t\tWHERE (c2.relname=\\'%s\\' or c2.relname=lower(\\'%s\\'))';\n\t\t}\n\n\t\tif ($primary == FALSE) {\n\t\t\t$sql .= ' AND i.indisprimary=false;';\n\t\t}\n\n\t\t$save = $ADODB_FETCH_MODE;\n\t\t$ADODB_FETCH_MODE = ADODB_FETCH_NUM;\n\t\tif ($this->fetchMode !== FALSE) {\n\t\t\t$savem = $this->SetFetchMode(FALSE);\n\t\t}\n\n\t\t$rs = $this->Execute(sprintf($sql,$table,$table,$schema));\n\t\tif (isset($savem)) {\n\t\t\t$this->SetFetchMode($savem);\n\t\t}\n\t\t$ADODB_FETCH_MODE = $save;\n\n\t\tif (!is_object($rs)) {\n\t\t\t$false = false;\n\t\t\treturn $false;\n\t\t}\n\n\t\t$col_names = $this->MetaColumnNames($table,true,true);\n\t\t// 3rd param is use attnum,\n\t\t// see https://sourceforge.net/p/adodb/bugs/45/\n\t\t$indexes = array();\n\t\twhile ($row = $rs->FetchRow()) {\n\t\t\t$columns = array();\n\t\t\tforeach (explode(' ', $row[2]) as $col) {\n\t\t\t\t$columns[] = $col_names[$col];\n\t\t\t}\n\n\t\t\t$indexes[$row[0]] = array(\n\t\t\t\t'unique' => ($row[1] == 't'),\n\t\t\t\t'columns' => $columns\n\t\t\t);\n\t\t}\n\t\treturn $indexes;\n\t}\n\n\t// returns true or false\n\t//\n\t// examples:\n\t// \t$db->Connect(\"host=host1 user=user1 password=secret port=4341\");\n\t// \t$db->Connect('host1','user1','secret');\n\tfunction _connect($str,$user='',$pwd='',$db='',$ctype=0)\n\t{\n\t\tif (!function_exists('pg_connect')) return null;\n\n\t\t$this->_errorMsg = false;\n\n\t\tif ($user || $pwd || $db) {\n\t\t\t$user = adodb_addslashes($user);\n\t\t\t$pwd = adodb_addslashes($pwd);\n\t\t\tif (strlen($db) == 0) $db = 'template1';\n\t\t\t$db = adodb_addslashes($db);\n\t\t\tif ($str)  {\n\t\t\t\t$host = explode(\":\", $str);\n\t\t\t\tif ($host[0]) $str = \"host=\".adodb_addslashes($host[0]);\n\t\t\t\telse $str = '';\n\t\t\t\tif (isset($host[1])) $str .= \" port=$host[1]\";\n\t\t\t\telse if (!empty($this->port)) $str .= \" port=\".$this->port;\n\t\t\t}\n\t\t\tif ($user) $str .= \" user=\".$user;\n\t\t\tif ($pwd)  $str .= \" password=\".$pwd;\n\t\t\tif ($db)   $str .= \" dbname=\".$db;\n\t\t}\n\n\t\t//if ($user) $linea = \"user=$user host=$linea password=$pwd dbname=$db port=5432\";\n\n\t\tif ($ctype === 1) { // persistent\n\t\t\t$this->_connectionID = pg_pconnect($str);\n\t\t} else {\n\t\t\tif ($ctype === -1) { // nconnect, we trick pgsql ext by changing the connection str\n\t\t\t\tstatic $ncnt;\n\n\t\t\t\tif (empty($ncnt)) $ncnt = 1;\n\t\t\t\telse $ncnt += 1;\n\n\t\t\t\t$str .= str_repeat(' ',$ncnt);\n\t\t\t}\n\t\t\t$this->_connectionID = pg_connect($str);\n\t\t}\n\t\tif ($this->_connectionID === false) return false;\n\t\t$this->Execute(\"set datestyle='ISO'\");\n\n\t\t$info = $this->ServerInfo();\n\t\t$this->pgVersion = (float) substr($info['version'],0,3);\n\t\tif ($this->pgVersion >= 7.1) { // good till version 999\n\t\t\t$this->_nestedSQL = true;\n\t\t}\n\n\t\t# PostgreSQL 9.0 changed the default output for bytea from 'escape' to 'hex'\n\t\t# PHP does not handle 'hex' properly ('x74657374' is returned as 't657374')\n\t\t# https://bugs.php.net/bug.php?id=59831 states this is in fact not a bug,\n\t\t# so we manually set bytea_output\n\t\tif ( !empty($this->connection->noBlobs) && version_compare($info['version'], '9.0', '>=')) {\n\t\t\t$this->Execute('set bytea_output=escape');\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction _nconnect($argHostname, $argUsername, $argPassword, $argDatabaseName)\n\t{\n\t\treturn $this->_connect($argHostname, $argUsername, $argPassword, $argDatabaseName,-1);\n\t}\n\n\t// returns true or false\n\t//\n\t// examples:\n\t// \t$db->PConnect(\"host=host1 user=user1 password=secret port=4341\");\n\t// \t$db->PConnect('host1','user1','secret');\n\tfunction _pconnect($str,$user='',$pwd='',$db='')\n\t{\n\t\treturn $this->_connect($str,$user,$pwd,$db,1);\n\t}\n\n\n\t// returns queryID or false\n\tfunction _query($sql,$inputarr=false)\n\t{\n\t\t$this->_pnum = 0;\n\t\t$this->_errorMsg = false;\n\t\tif ($inputarr) {\n\t\t/*\n\t\t\tIt appears that PREPARE/EXECUTE is slower for many queries.\n\n\t\t\tFor query executed 1000 times:\n\t\t\t\"select id,firstname,lastname from adoxyz\n\t\t\t\twhere firstname not like ? and lastname not like ? and id = ?\"\n\n\t\t\twith plan = 1.51861286163 secs\n\t\t\tno plan =   1.26903700829 secs\n\t\t*/\n\t\t\t$plan = 'P'.md5($sql);\n\n\t\t\t$execp = '';\n\t\t\tforeach($inputarr as $v) {\n\t\t\t\tif ($execp) $execp .= ',';\n\t\t\t\tif (is_string($v)) {\n\t\t\t\t\tif (strncmp($v,\"'\",1) !== 0) $execp .= $this->qstr($v);\n\t\t\t\t} else {\n\t\t\t\t\t$execp .= $v;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($execp) $exsql = \"EXECUTE $plan ($execp)\";\n\t\t\telse $exsql = \"EXECUTE $plan\";\n\n\n\t\t\t$rez = @pg_execute($this->_connectionID,$exsql);\n\t\t\tif (!$rez) {\n\t\t\t# Perhaps plan does not exist? Prepare/compile plan.\n\t\t\t\t$params = '';\n\t\t\t\tforeach($inputarr as $v) {\n\t\t\t\t\tif ($params) $params .= ',';\n\t\t\t\t\tif (is_string($v)) {\n\t\t\t\t\t\t$params .= 'VARCHAR';\n\t\t\t\t\t} else if (is_integer($v)) {\n\t\t\t\t\t\t$params .= 'INTEGER';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$params .= \"REAL\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$sqlarr = explode('?',$sql);\n\t\t\t\t//print_r($sqlarr);\n\t\t\t\t$sql = '';\n\t\t\t\t$i = 1;\n\t\t\t\tforeach($sqlarr as $v) {\n\t\t\t\t\t$sql .= $v.' $'.$i;\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t\t$s = \"PREPARE $plan ($params) AS \".substr($sql,0,strlen($sql)-2);\n\t\t\t\t//adodb_pr($s);\n\t\t\t\t$rez = pg_execute($this->_connectionID,$s);\n\t\t\t\t//echo $this->ErrorMsg();\n\t\t\t}\n\t\t\tif ($rez)\n\t\t\t\t$rez = pg_execute($this->_connectionID,$exsql);\n\t\t} else {\n\t\t\t//adodb_backtrace();\n\t\t\t$rez = pg_query($this->_connectionID,$sql);\n\t\t}\n\t\t// check if no data returned, then no need to create real recordset\n\t\tif ($rez && pg_num_fields($rez) <= 0) {\n\t\t\tif (is_resource($this->_resultid) && get_resource_type($this->_resultid) === 'pgsql result') {\n\t\t\t\tpg_free_result($this->_resultid);\n\t\t\t}\n\t\t\t$this->_resultid = $rez;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn $rez;\n\t}\n\n\tfunction _errconnect()\n\t{\n\t\tif (defined('DB_ERROR_CONNECT_FAILED')) return DB_ERROR_CONNECT_FAILED;\n\t\telse return 'Database connection failed';\n\t}\n\n\t/*\tReturns: the last error message from previous database operation\t*/\n\tfunction ErrorMsg()\n\t{\n\t\tif ($this->_errorMsg !== false) return $this->_errorMsg;\n\t\tif (ADODB_PHPVER >= 0x4300) {\n\t\t\tif (!empty($this->_resultid)) {\n\t\t\t\t$this->_errorMsg = @pg_result_error($this->_resultid);\n\t\t\t\tif ($this->_errorMsg) return $this->_errorMsg;\n\t\t\t}\n\n\t\t\tif (!empty($this->_connectionID)) {\n\t\t\t\t$this->_errorMsg = @pg_last_error($this->_connectionID);\n\t\t\t} else $this->_errorMsg = $this->_errconnect();\n\t\t} else {\n\t\t\tif (empty($this->_connectionID)) $this->_errconnect();\n\t\t\telse $this->_errorMsg = @pg_last_error($this->_connectionID);\n\t\t}\n\t\treturn $this->_errorMsg;\n\t}\n\n\tfunction ErrorNo()\n\t{\n\t\t$e = $this->ErrorMsg();\n\t\tif (strlen($e)) {\n\t\t\treturn ADOConnection::MetaError($e);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// returns true or false\n\tfunction _close()\n\t{\n\t\tif ($this->transCnt) $this->RollbackTrans();\n\t\tif ($this->_resultid) {\n\t\t\t@pg_free_result($this->_resultid);\n\t\t\t$this->_resultid = false;\n\t\t}\n\t\t@pg_close($this->_connectionID);\n\t\t$this->_connectionID = false;\n\t\treturn true;\n\t}\n\n\n\t/*\n\t* Maximum size of C field\n\t*/\n\tfunction CharMax()\n\t{\n\t\treturn 1000000000;  // should be 1 Gb?\n\t}\n\n\t/*\n\t* Maximum size of X field\n\t*/\n\tfunction TextMax()\n\t{\n\t\treturn 1000000000; // should be 1 Gb?\n\t}\n\n\n}\n\n/*--------------------------------------------------------------------------------------\n\tClass Name: Recordset\n--------------------------------------------------------------------------------------*/\n\nclass ADORecordSet_postgres64 extends ADORecordSet{\n\tvar $_blobArr;\n\tvar $databaseType = \"postgres64\";\n\tvar $canSeek = true;\n\n\tfunction __construct($queryID, $mode=false)\n\t{\n\t\tif ($mode === false) {\n\t\t\tglobal $ADODB_FETCH_MODE;\n\t\t\t$mode = $ADODB_FETCH_MODE;\n\t\t}\n\t\tswitch ($mode)\n\t\t{\n\t\tcase ADODB_FETCH_NUM: $this->fetchMode = PGSQL_NUM; break;\n\t\tcase ADODB_FETCH_ASSOC:$this->fetchMode = PGSQL_ASSOC; break;\n\n\t\tcase ADODB_FETCH_DEFAULT:\n\t\tcase ADODB_FETCH_BOTH:\n\t\tdefault: $this->fetchMode = PGSQL_BOTH; break;\n\t\t}\n\t\t$this->adodbFetchMode = $mode;\n\n\t\t// Parent's constructor\n\t\tparent::__construct($queryID);\n\t}\n\n\tfunction GetRowAssoc($upper = ADODB_ASSOC_CASE)\n\t{\n\t\tif ($this->fetchMode == PGSQL_ASSOC && $upper == ADODB_ASSOC_CASE_LOWER) {\n\t\t\treturn $this->fields;\n\t\t}\n\t\t$row = ADORecordSet::GetRowAssoc($upper);\n\t\treturn $row;\n\t}\n\n\n\tfunction _initrs()\n\t{\n\tglobal $ADODB_COUNTRECS;\n\t\t$qid = $this->_queryID;\n\t\t$this->_numOfRows = ($ADODB_COUNTRECS)? @pg_num_rows($qid):-1;\n\t\t$this->_numOfFields = @pg_num_fields($qid);\n\n\t\t// cache types for blob decode check\n\t\t// apparently pg_field_type actually performs an sql query on the database to get the type.\n\t\tif (empty($this->connection->noBlobs))\n\t\tfor ($i=0, $max = $this->_numOfFields; $i < $max; $i++) {\n\t\t\tif (pg_field_type($qid,$i) == 'bytea') {\n\t\t\t\t$this->_blobArr[$i] = pg_field_name($qid,$i);\n\t\t\t}\n\t\t}\n\t}\n\n\t\t/* Use associative array to get fields array */\n\tfunction Fields($colname)\n\t{\n\t\tif ($this->fetchMode != PGSQL_NUM) return @$this->fields[$colname];\n\n\t\tif (!$this->bind) {\n\t\t\t$this->bind = array();\n\t\t\tfor ($i=0; $i < $this->_numOfFields; $i++) {\n\t\t\t\t$o = $this->FetchField($i);\n\t\t\t\t$this->bind[strtoupper($o->name)] = $i;\n\t\t\t}\n\t\t}\n\t\treturn $this->fields[$this->bind[strtoupper($colname)]];\n\t}\n\n\tfunction FetchField($off = 0)\n\t{\n\t\t// offsets begin at 0\n\n\t\t$o= new ADOFieldObject();\n\t\t$o->name = @pg_field_name($this->_queryID,$off);\n\t\t$o->type = @pg_field_type($this->_queryID,$off);\n\t\t$o->max_length = @pg_field_size($this->_queryID,$off);\n\t\treturn $o;\n\t}\n\n\tfunction _seek($row)\n\t{\n\t\treturn @pg_fetch_row($this->_queryID,$row);\n\t}\n\n\tfunction _decode($blob)\n\t{\n\t\tif ($blob === NULL) return NULL;\n//\t\teval('$realblob=\"'.adodb_str_replace(array('\"','$'),array('\\\"','\\$'),$blob).'\";');\n\t\treturn pg_unescape_bytea($blob);\n\t}\n\n\tfunction _fixblobs()\n\t{\n\t\tif ($this->fetchMode == PGSQL_NUM || $this->fetchMode == PGSQL_BOTH) {\n\t\t\tforeach($this->_blobArr as $k => $v) {\n\t\t\t\t$this->fields[$k] = ADORecordSet_postgres64::_decode($this->fields[$k]);\n\t\t\t}\n\t\t}\n\t\tif ($this->fetchMode == PGSQL_ASSOC || $this->fetchMode == PGSQL_BOTH) {\n\t\t\tforeach($this->_blobArr as $k => $v) {\n\t\t\t\t$this->fields[$v] = ADORecordSet_postgres64::_decode($this->fields[$v]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 10% speedup to move MoveNext to child class\n\tfunction MoveNext()\n\t{\n\t\tif (!$this->EOF) {\n\t\t\t$this->_currentRow++;\n\t\t\tif ($this->_numOfRows < 0 || $this->_numOfRows > $this->_currentRow) {\n\t\t\t\t$this->fields = @pg_fetch_array($this->_queryID,$this->_currentRow,$this->fetchMode);\n\t\t\t\tif (is_array($this->fields) && $this->fields) {\n\t\t\t\t\tif (isset($this->_blobArr)) $this->_fixblobs();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->fields = false;\n\t\t\t$this->EOF = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction _fetch()\n\t{\n\n\t\tif ($this->_currentRow >= $this->_numOfRows && $this->_numOfRows >= 0)\n\t\t\treturn false;\n\n\t\t$this->fields = @pg_fetch_array($this->_queryID,$this->_currentRow,$this->fetchMode);\n\n\t\tif ($this->fields && isset($this->_blobArr)) $this->_fixblobs();\n\n\t\treturn (is_array($this->fields));\n\t}\n\n\tfunction _close()\n\t{\n\t\tif (!is_resource($this->_queryID)\n\t\t\t|| get_resource_type($this->_queryID) != 'pgsql result'\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn pg_free_result($this->_queryID);\n\t}\n\n\tfunction MetaType($t,$len=-1,$fieldobj=false)\n\t{\n\t\tif (is_object($t)) {\n\t\t\t$fieldobj = $t;\n\t\t\t$t = $fieldobj->type;\n\t\t\t$len = $fieldobj->max_length;\n\t\t}\n\t\tswitch (strtoupper($t)) {\n\t\t\t\tcase 'MONEY': // stupid, postgres expects money to be a string\n\t\t\t\tcase 'INTERVAL':\n\t\t\t\tcase 'CHAR':\n\t\t\t\tcase 'CHARACTER':\n\t\t\t\tcase 'VARCHAR':\n\t\t\t\tcase 'NAME':\n\t\t\t\tcase 'BPCHAR':\n\t\t\t\tcase '_VARCHAR':\n\t\t\t\tcase 'INET':\n\t\t\t\tcase 'MACADDR':\n\t\t\t\t\tif ($len <= $this->blobSize) return 'C';\n\n\t\t\t\tcase 'TEXT':\n\t\t\t\t\treturn 'X';\n\n\t\t\t\tcase 'IMAGE': // user defined type\n\t\t\t\tcase 'BLOB': // user defined type\n\t\t\t\tcase 'BIT':\t// This is a bit string, not a single bit, so don't return 'L'\n\t\t\t\tcase 'VARBIT':\n\t\t\t\tcase 'BYTEA':\n\t\t\t\t\treturn 'B';\n\n\t\t\t\tcase 'BOOL':\n\t\t\t\tcase 'BOOLEAN':\n\t\t\t\t\treturn 'L';\n\n\t\t\t\tcase 'DATE':\n\t\t\t\t\treturn 'D';\n\n\n\t\t\t\tcase 'TIMESTAMP WITHOUT TIME ZONE':\n\t\t\t\tcase 'TIME':\n\t\t\t\tcase 'DATETIME':\n\t\t\t\tcase 'TIMESTAMP':\n\t\t\t\tcase 'TIMESTAMPTZ':\n\t\t\t\t\treturn 'T';\n\n\t\t\t\tcase 'SMALLINT':\n\t\t\t\tcase 'BIGINT':\n\t\t\t\tcase 'INTEGER':\n\t\t\t\tcase 'INT8':\n\t\t\t\tcase 'INT4':\n\t\t\t\tcase 'INT2':\n\t\t\t\t\tif (isset($fieldobj) &&\n\t\t\t\tempty($fieldobj->primary_key) && (!$this->connection->uniqueIisR || empty($fieldobj->unique))) return 'I';\n\n\t\t\t\tcase 'OID':\n\t\t\t\tcase 'SERIAL':\n\t\t\t\t\treturn 'R';\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn 'N';\n\t\t\t}\n\t}\n\n}\n"], "fixing_code": ["<?php\n/*\n @version   v5.20.20  01-Feb-2021\n @copyright (c) 2000-2013 John Lim (jlim#natsoft.com). All rights reserved.\n @copyright (c) 2014      Damien Regad, Mark Newnham and the ADOdb community\n  Released under both BSD license and Lesser GPL library license.\n  Whenever there is any discrepancy between the two licenses,\n  the BSD license will take precedence.\n  Set tabs to 8.\n\n  Original version derived from Alberto Cerezal (acerezalp@dbnet.es) - DBNet Informatica & Comunicaciones.\n  08 Nov 2000 jlim - Minor corrections, removing mysql stuff\n  09 Nov 2000 jlim - added insertid support suggested by \"Christopher Kings-Lynne\" <chriskl@familyhealth.com.au>\n\t\t\t  jlim - changed concat operator to || and data types to MetaType to match documented pgsql types\n\t\t\t\t\t see http://www.postgresql.org/devel-corner/docs/postgres/datatype.htm\n  22 Nov 2000 jlim - added changes to FetchField() and MetaTables() contributed by \"raser\" <raser@mail.zen.com.tw>\n  27 Nov 2000 jlim - added changes to _connect/_pconnect from ideas by \"Lennie\" <leen@wirehub.nl>\n  15 Dec 2000 jlim - added changes suggested by Additional code changes by \"Eric G. Werk\" egw@netguide.dk.\n  31 Jan 2002 jlim - finally installed postgresql. testing\n  01 Mar 2001 jlim - Freek Dijkstra changes, also support for text type\n\n  See http://www.varlena.com/varlena/GeneralBits/47.php\n\n\t-- What indexes are on my table?\n\tselect * from pg_indexes where tablename = 'tablename';\n\n\t-- What triggers are on my table?\n\tselect c.relname as \"Table\", t.tgname as \"Trigger Name\",\n\t   t.tgconstrname as \"Constraint Name\", t.tgenabled as \"Enabled\",\n\t   t.tgisconstraint as \"Is Constraint\", cc.relname as \"Referenced Table\",\n\t   p.proname as \"Function Name\"\n\tfrom pg_trigger t, pg_class c, pg_class cc, pg_proc p\n\twhere t.tgfoid = p.oid and t.tgrelid = c.oid\n\t   and t.tgconstrrelid = cc.oid\n\t   and c.relname = 'tablename';\n\n\t-- What constraints are on my table?\n\tselect r.relname as \"Table\", c.conname as \"Constraint Name\",\n\t   contype as \"Constraint Type\", conkey as \"Key Columns\",\n\t   confkey as \"Foreign Columns\", consrc as \"Source\"\n\tfrom pg_class r, pg_constraint c\n\twhere r.oid = c.conrelid\n\t   and relname = 'tablename';\n\n*/\n\n// security - hide paths\nif (!defined('ADODB_DIR')) die();\n\nfunction adodb_addslashes($s)\n{\n\t$len = strlen($s);\n\tif ($len == 0) return \"''\";\n\n\treturn \"'\".addslashes($s).\"'\";\n}\n\nclass ADODB_postgres64 extends ADOConnection{\n\tvar $databaseType = 'postgres64';\n\tvar $dataProvider = 'postgres';\n\tvar $hasInsertID = true;\n\tvar $_resultid = false;\n\tvar $concat_operator='||';\n\tvar $metaDatabasesSQL = \"select datname from pg_database where datname not in ('template0','template1') order by 1\";\n\tvar $metaTablesSQL = \"select tablename,'T' from pg_tables where tablename not like 'pg\\_%'\n\t\tand tablename not in ('sql_features', 'sql_implementation_info', 'sql_languages',\n\t\t\t'sql_packages', 'sql_sizing', 'sql_sizing_profiles')\n\tunion\n\t\tselect viewname,'V' from pg_views where viewname not like 'pg\\_%'\";\n\t//\"select tablename from pg_tables where tablename not like 'pg_%' order by 1\";\n\tvar $isoDates = true; // accepts dates in ISO format\n\tvar $sysDate = \"CURRENT_DATE\";\n\tvar $sysTimeStamp = \"CURRENT_TIMESTAMP\";\n\tvar $blobEncodeType = 'C';\n\tvar $metaColumnsSQL = \"SELECT a.attname,t.typname,a.attlen,a.atttypmod,a.attnotnull,a.atthasdef,a.attnum\n\t\tFROM pg_class c, pg_attribute a,pg_type t\n\t\tWHERE relkind in ('r','v') AND (c.relname='%s' or c.relname = lower('%s')) and a.attname not like '....%%'\n\t\tAND a.attnum > 0 AND a.atttypid = t.oid AND a.attrelid = c.oid ORDER BY a.attnum\";\n\n\t// used when schema defined\n\tvar $metaColumnsSQL1 = \"SELECT a.attname, t.typname, a.attlen, a.atttypmod, a.attnotnull, a.atthasdef, a.attnum\n\t\tFROM pg_class c, pg_attribute a, pg_type t, pg_namespace n\n\t\tWHERE relkind in ('r','v') AND (c.relname='%s' or c.relname = lower('%s'))\n\t\tand c.relnamespace=n.oid and n.nspname='%s'\n\t\tand a.attname not like '....%%' AND a.attnum > 0\n\t\tAND a.atttypid = t.oid AND a.attrelid = c.oid ORDER BY a.attnum\";\n\n\t// get primary key etc -- from Freek Dijkstra\n\tvar $metaKeySQL = \"SELECT ic.relname AS index_name, a.attname AS column_name,i.indisunique AS unique_key, i.indisprimary AS primary_key\n\t\tFROM pg_class bc, pg_class ic, pg_index i, pg_attribute a\n\t\tWHERE bc.oid = i.indrelid AND ic.oid = i.indexrelid\n\t\tAND (i.indkey[0] = a.attnum OR i.indkey[1] = a.attnum OR i.indkey[2] = a.attnum OR i.indkey[3] = a.attnum OR i.indkey[4] = a.attnum OR i.indkey[5] = a.attnum OR i.indkey[6] = a.attnum OR i.indkey[7] = a.attnum)\n\t\tAND a.attrelid = bc.oid AND bc.relname = '%s'\";\n\n\tvar $hasAffectedRows = true;\n\tvar $hasLimit = false;\t// set to true for pgsql 7 only. support pgsql/mysql SELECT * FROM TABLE LIMIT 10\n\t// below suggested by Freek Dijkstra\n\tvar $true = 'TRUE';\t\t// string that represents TRUE for a database\n\tvar $false = 'FALSE';\t\t// string that represents FALSE for a database\n\tvar $fmtDate = \"'Y-m-d'\";\t// used by DBDate() as the default date format used by the database\n\tvar $fmtTimeStamp = \"'Y-m-d H:i:s'\"; // used by DBTimeStamp as the default timestamp fmt.\n\tvar $hasMoveFirst = true;\n\tvar $hasGenID = true;\n\tvar $_genIDSQL = \"SELECT NEXTVAL('%s')\";\n\tvar $_genSeqSQL = \"CREATE SEQUENCE %s START %s\";\n\tvar $_dropSeqSQL = \"DROP SEQUENCE %s\";\n\tvar $metaDefaultsSQL = \"SELECT d.adnum as num, d.adsrc as def from pg_attrdef d, pg_class c where d.adrelid=c.oid and c.relname='%s' order by d.adnum\";\n\tvar $random = 'random()';\t\t/// random function\n\tvar $autoRollback = true; // apparently pgsql does not autorollback properly before php 4.3.4\n\t\t\t\t\t\t\t// http://bugs.php.net/bug.php?id=25404\n\n\tvar $uniqueIisR = true;\n\tvar $_bindInputArray = false; // requires postgresql 7.3+ and ability to modify database\n\tvar $disableBlobs = false; // set to true to disable blob checking, resulting in 2-5% improvement in performance.\n\n\tvar $_pnum = 0;\n\n\t// The last (fmtTimeStamp is not entirely correct:\n\t// PostgreSQL also has support for time zones,\n\t// and writes these time in this format: \"2001-03-01 18:59:26+02\".\n\t// There is no code for the \"+02\" time zone information, so I just left that out.\n\t// I'm not familiar enough with both ADODB as well as Postgres\n\t// to know what the concequences are. The other values are correct (wheren't in 0.94)\n\t// -- Freek Dijkstra\n\n\tfunction __construct()\n\t{\n\t\t// changes the metaColumnsSQL, adds columns: attnum[6]\n\t}\n\n\tfunction ServerInfo()\n\t{\n\t\tif (isset($this->version)) return $this->version;\n\n\t\t$arr['description'] = $this->GetOne(\"select version()\");\n\t\t$arr['version'] = ADOConnection::_findvers($arr['description']);\n\t\t$this->version = $arr;\n\t\treturn $arr;\n\t}\n\n\tfunction IfNull( $field, $ifNull )\n\t{\n\t\treturn \" coalesce($field, $ifNull) \";\n\t}\n\n\t// get the last id - never tested\n\tfunction pg_insert_id($tablename,$fieldname)\n\t{\n\t\t$result=pg_query($this->_connectionID, 'SELECT last_value FROM '. $tablename .'_'. $fieldname .'_seq');\n\t\tif ($result) {\n\t\t\t$arr = @pg_fetch_row($result,0);\n\t\t\tpg_free_result($result);\n\t\t\tif (isset($arr[0])) return $arr[0];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Warning from http://www.php.net/manual/function.pg-getlastoid.php:\n\t * Using a OID as a unique identifier is not generally wise.\n\t * Unless you are very careful, you might end up with a tuple having\n\t * a different OID if a database must be reloaded.\n\t */\n\tfunction _insertid($table,$column)\n\t{\n\t\tif (!is_resource($this->_resultid) || get_resource_type($this->_resultid) !== 'pgsql result') return false;\n\t\t$oid = pg_last_oid($this->_resultid);\n\t\t// to really return the id, we need the table and column-name, else we can only return the oid != id\n\t\treturn empty($table) || empty($column) ? $oid : $this->GetOne(\"SELECT $column FROM $table WHERE oid=\".(int)$oid);\n\t}\n\n\tfunction _affectedrows()\n\t{\n\t\tif (!is_resource($this->_resultid) || get_resource_type($this->_resultid) !== 'pgsql result') return false;\n\t\treturn pg_affected_rows($this->_resultid);\n\t}\n\n\n\t/**\n\t * @return true/false\n\t */\n\tfunction BeginTrans()\n\t{\n\t\tif ($this->transOff) return true;\n\t\t$this->transCnt += 1;\n\t\treturn pg_query($this->_connectionID, 'begin '.$this->_transmode);\n\t}\n\n\tfunction RowLock($tables,$where,$col='1 as adodbignore')\n\t{\n\t\tif (!$this->transCnt) $this->BeginTrans();\n\t\treturn $this->GetOne(\"select $col from $tables where $where for update\");\n\t}\n\n\t// returns true/false.\n\tfunction CommitTrans($ok=true)\n\t{\n\t\tif ($this->transOff) return true;\n\t\tif (!$ok) return $this->RollbackTrans();\n\n\t\t$this->transCnt -= 1;\n\t\treturn pg_query($this->_connectionID, 'commit');\n\t}\n\n\t// returns true/false\n\tfunction RollbackTrans()\n\t{\n\t\tif ($this->transOff) return true;\n\t\t$this->transCnt -= 1;\n\t\treturn pg_query($this->_connectionID, 'rollback');\n\t}\n\n\tfunction MetaTables($ttype=false,$showSchema=false,$mask=false)\n\t{\n\t\t$info = $this->ServerInfo();\n\t\tif ($info['version'] >= 7.3) {\n\t\t$this->metaTablesSQL = \"\n\t\t\tselect table_name,'T' from information_schema.tables where table_schema not in ( 'pg_catalog','information_schema')\n\t\t\tunion\n\t\t\tselect table_name,'V' from information_schema.views where table_schema not in ( 'pg_catalog','information_schema') \";\n\t\t}\n\t\tif ($mask) {\n\t\t\t$save = $this->metaTablesSQL;\n\t\t\t$mask = $this->qstr(strtolower($mask));\n\t\t\tif ($info['version']>=7.3)\n\t\t\t\t$this->metaTablesSQL = \"\n\t\t\t\t\tselect table_name,'T' from information_schema.tables where table_name like $mask and table_schema not in ( 'pg_catalog','information_schema')\n\t\t\t\t\tunion\n\t\t\t\t\tselect table_name,'V' from information_schema.views where table_name like $mask and table_schema not in ( 'pg_catalog','information_schema') \";\n\t\t\telse\n\t\t\t\t$this->metaTablesSQL = \"\n\t\t\t\t\tselect tablename,'T' from pg_tables where tablename like $mask\n\t\t\t\t\tunion\n\t\t\t\t\tselect viewname,'V' from pg_views where viewname like $mask\";\n\t\t}\n\t\t$ret = ADOConnection::MetaTables($ttype,$showSchema);\n\n\t\tif ($mask) {\n\t\t\t$this->metaTablesSQL = $save;\n\t\t}\n\t\treturn $ret;\n\t}\n\n\n\t// if magic quotes disabled, use pg_escape_string()\n\tfunction qstr($s,$magic_quotes=false)\n\t{\n\t\tif (is_bool($s)) return $s ? 'true' : 'false';\n\n\t\tif (!$magic_quotes) {\n\t\t\tif (ADODB_PHPVER >= 0x5200 && $this->_connectionID) {\n\t\t\t\treturn  \"'\".pg_escape_string($this->_connectionID,$s).\"'\";\n\t\t\t}\n\t\t\tif (ADODB_PHPVER >= 0x4200) {\n\t\t\t\treturn  \"'\".pg_escape_string($s).\"'\";\n\t\t\t}\n\t\t\tif ($this->replaceQuote[0] == '\\\\'){\n\t\t\t\t$s = adodb_str_replace(array('\\\\',\"\\0\"),array('\\\\\\\\',\"\\\\\\\\000\"),$s);\n\t\t\t}\n\t\t\treturn  \"'\".str_replace(\"'\",$this->replaceQuote,$s).\"'\";\n\t\t}\n\n\t\t// undo magic quotes for \"\n\t\t$s = str_replace('\\\\\"','\"',$s);\n\t\treturn \"'$s'\";\n\t}\n\n\n\n\t// Format date column in sql string given an input format that understands Y M D\n\tfunction SQLDate($fmt, $col=false)\n\t{\n\t\tif (!$col) $col = $this->sysTimeStamp;\n\t\t$s = 'TO_CHAR('.$col.\",'\";\n\n\t\t$len = strlen($fmt);\n\t\tfor ($i=0; $i < $len; $i++) {\n\t\t\t$ch = $fmt[$i];\n\t\t\tswitch($ch) {\n\t\t\tcase 'Y':\n\t\t\tcase 'y':\n\t\t\t\t$s .= 'YYYY';\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\tcase 'q':\n\t\t\t\t$s .= 'Q';\n\t\t\t\tbreak;\n\n\t\t\tcase 'M':\n\t\t\t\t$s .= 'Mon';\n\t\t\t\tbreak;\n\n\t\t\tcase 'm':\n\t\t\t\t$s .= 'MM';\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\t\t$s .= 'DD';\n\t\t\t\tbreak;\n\n\t\t\tcase 'H':\n\t\t\t\t$s.= 'HH24';\n\t\t\t\tbreak;\n\n\t\t\tcase 'h':\n\t\t\t\t$s .= 'HH';\n\t\t\t\tbreak;\n\n\t\t\tcase 'i':\n\t\t\t\t$s .= 'MI';\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\t$s .= 'SS';\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\t$s .= 'AM';\n\t\t\t\tbreak;\n\n\t\t\tcase 'w':\n\t\t\t\t$s .= 'D';\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\t\t$s .= 'DAY';\n\t\t\t\tbreak;\n\n\t\t\tcase 'W':\n\t\t\t\t$s .= 'WW';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t// handle escape characters...\n\t\t\t\tif ($ch == '\\\\') {\n\t\t\t\t\t$i++;\n\t\t\t\t\t$ch = substr($fmt,$i,1);\n\t\t\t\t}\n\t\t\t\tif (strpos('-/.:;, ',$ch) !== false) $s .= $ch;\n\t\t\t\telse $s .= '\"'.$ch.'\"';\n\n\t\t\t}\n\t\t}\n\t\treturn $s. \"')\";\n\t}\n\n\n\n\t/*\n\t* Load a Large Object from a file\n\t* - the procedure stores the object id in the table and imports the object using\n\t* postgres proprietary blob handling routines\n\t*\n\t* contributed by Mattia Rossi mattia@technologist.com\n\t* modified for safe mode by juraj chlebec\n\t*/\n\tfunction UpdateBlobFile($table,$column,$path,$where,$blobtype='BLOB')\n\t{\n\t\tpg_query($this->_connectionID, 'begin');\n\n\t\t$fd = fopen($path,'r');\n\t\t$contents = fread($fd,filesize($path));\n\t\tfclose($fd);\n\n\t\t$oid = pg_lo_create($this->_connectionID);\n\t\t$handle = pg_lo_open($this->_connectionID, $oid, 'w');\n\t\tpg_lo_write($handle, $contents);\n\t\tpg_lo_close($handle);\n\n\t\t// $oid = pg_lo_import ($path);\n\t\tpg_query($this->_connectionID, 'commit');\n\t\t$rs = ADOConnection::UpdateBlob($table,$column,$oid,$where,$blobtype);\n\t\t$rez = !empty($rs);\n\t\treturn $rez;\n\t}\n\n\t/*\n\t* Deletes/Unlinks a Blob from the database, otherwise it\n\t* will be left behind\n\t*\n\t* Returns TRUE on success or FALSE on failure.\n\t*\n\t* contributed by Todd Rogers todd#windfox.net\n\t*/\n\tfunction BlobDelete( $blob )\n\t{\n\t\tpg_query($this->_connectionID, 'begin');\n\t\t$result = @pg_lo_unlink($blob);\n\t\tpg_query($this->_connectionID, 'commit');\n\t\treturn( $result );\n\t}\n\n\t/*\n\t\tHueristic - not guaranteed to work.\n\t*/\n\tfunction GuessOID($oid)\n\t{\n\t\tif (strlen($oid)>16) return false;\n\t\treturn is_numeric($oid);\n\t}\n\n\t/*\n\t* If an OID is detected, then we use pg_lo_* to open the oid file and read the\n\t* real blob from the db using the oid supplied as a parameter. If you are storing\n\t* blobs using bytea, we autodetect and process it so this function is not needed.\n\t*\n\t* contributed by Mattia Rossi mattia@technologist.com\n\t*\n\t* see http://www.postgresql.org/idocs/index.php?largeobjects.html\n\t*\n\t* Since adodb 4.54, this returns the blob, instead of sending it to stdout. Also\n\t* added maxsize parameter, which defaults to $db->maxblobsize if not defined.\n\t*/\n\tfunction BlobDecode($blob,$maxsize=false,$hastrans=true)\n\t{\n\t\tif (!$this->GuessOID($blob)) return $blob;\n\n\t\tif ($hastrans) pg_query($this->_connectionID,'begin');\n\t\t$fd = @pg_lo_open($this->_connectionID,$blob,'r');\n\t\tif ($fd === false) {\n\t\t\tif ($hastrans) pg_query($this->_connectionID,'commit');\n\t\t\treturn $blob;\n\t\t}\n\t\tif (!$maxsize) $maxsize = $this->maxblobsize;\n\t\t$realblob = @pg_lo_read($fd,$maxsize);\n\t\t@pg_lo_close($fd);\n\t\tif ($hastrans) pg_query($this->_connectionID,'commit');\n\t\treturn $realblob;\n\t}\n\n\t/*\n\t\tSee http://www.postgresql.org/idocs/index.php?datatype-binary.html\n\n\t\tNOTE: SQL string literals (input strings) must be preceded with two backslashes\n\t\tdue to the fact that they must pass through two parsers in the PostgreSQL\n\t\tbackend.\n\t*/\n\tfunction BlobEncode($blob)\n\t{\n\t\tif (ADODB_PHPVER >= 0x5200) return pg_escape_bytea($this->_connectionID, $blob);\n\t\tif (ADODB_PHPVER >= 0x4200) return pg_escape_bytea($blob);\n\n\t\t/*92=backslash, 0=null, 39=single-quote*/\n\t\t$badch = array(chr(92),chr(0),chr(39)); # \\  null  '\n\t\t$fixch = array('\\\\\\\\134','\\\\\\\\000','\\\\\\\\047');\n\t\treturn adodb_str_replace($badch,$fixch,$blob);\n\n\t\t// note that there is a pg_escape_bytea function only for php 4.2.0 or later\n\t}\n\n\t// assumes bytea for blob, and varchar for clob\n\tfunction UpdateBlob($table,$column,$val,$where,$blobtype='BLOB')\n\t{\n\t\tif ($blobtype == 'CLOB') {\n\t\t\treturn $this->Execute(\"UPDATE $table SET $column=\" . $this->qstr($val) . \" WHERE $where\");\n\t\t}\n\t\t// do not use bind params which uses qstr(), as blobencode() already quotes data\n\t\treturn $this->Execute(\"UPDATE $table SET $column='\".$this->BlobEncode($val).\"'::bytea WHERE $where\");\n\t}\n\n\tfunction OffsetDate($dayFraction,$date=false)\n\t{\n\t\tif (!$date) $date = $this->sysDate;\n\t\telse if (strncmp($date,\"'\",1) == 0) {\n\t\t\t$len = strlen($date);\n\t\t\tif (10 <= $len && $len <= 12) $date = 'date '.$date;\n\t\t\telse $date = 'timestamp '.$date;\n\t\t}\n\n\n\t\treturn \"($date+interval'\".($dayFraction * 1440).\" minutes')\";\n\t\t#return \"($date+interval'$dayFraction days')\";\n\t}\n\n\t/**\n\t * Generate the SQL to retrieve MetaColumns data\n\t * @param string $table Table name\n\t * @param string $schema Schema name (can be blank)\n\t * @return string SQL statement to execute\n\t */\n\tprotected function _generateMetaColumnsSQL($table, $schema)\n\t{\n\t\tif ($schema) {\n\t\t\treturn sprintf($this->metaColumnsSQL1, $table, $table, $schema);\n\t\t}\n\t\telse {\n\t\t\treturn sprintf($this->metaColumnsSQL, $table, $table, $schema);\n\t\t}\n\t}\n\n\t// for schema support, pass in the $table param \"$schema.$tabname\".\n\t// converts field names to lowercase, $upper is ignored\n\t// see PHPLens Issue No: 14018 for more info\n\tfunction MetaColumns($table,$normalize=true)\n\t{\n\t\tglobal $ADODB_FETCH_MODE;\n\n\t\t$schema = false;\n\t\t$false = false;\n\t\t$this->_findschema($table,$schema);\n\n\t\tif ($normalize) $table = strtolower($table);\n\n\t\t$save = $ADODB_FETCH_MODE;\n\t\t$ADODB_FETCH_MODE = ADODB_FETCH_NUM;\n\t\tif ($this->fetchMode !== false) $savem = $this->SetFetchMode(false);\n\n\t\t$rs = $this->Execute($this->_generateMetaColumnsSQL($table, $schema));\n\t\tif (isset($savem)) $this->SetFetchMode($savem);\n\t\t$ADODB_FETCH_MODE = $save;\n\n\t\tif ($rs === false) {\n\t\t\treturn $false;\n\t\t}\n\t\tif (!empty($this->metaKeySQL)) {\n\t\t\t// If we want the primary keys, we have to issue a separate query\n\t\t\t// Of course, a modified version of the metaColumnsSQL query using a\n\t\t\t// LEFT JOIN would have been much more elegant, but postgres does\n\t\t\t// not support OUTER JOINS. So here is the clumsy way.\n\n\t\t\t$ADODB_FETCH_MODE = ADODB_FETCH_ASSOC;\n\n\t\t\t$rskey = $this->Execute(sprintf($this->metaKeySQL,($table)));\n\t\t\t// fetch all result in once for performance.\n\t\t\t$keys = $rskey->GetArray();\n\t\t\tif (isset($savem)) $this->SetFetchMode($savem);\n\t\t\t$ADODB_FETCH_MODE = $save;\n\n\t\t\t$rskey->Close();\n\t\t\tunset($rskey);\n\t\t}\n\n\t\t$rsdefa = array();\n\t\tif (!empty($this->metaDefaultsSQL)) {\n\t\t\t$ADODB_FETCH_MODE = ADODB_FETCH_ASSOC;\n\t\t\t$sql = sprintf($this->metaDefaultsSQL, ($table));\n\t\t\t$rsdef = $this->Execute($sql);\n\t\t\tif (isset($savem)) $this->SetFetchMode($savem);\n\t\t\t$ADODB_FETCH_MODE = $save;\n\n\t\t\tif ($rsdef) {\n\t\t\t\twhile (!$rsdef->EOF) {\n\t\t\t\t\t$num = $rsdef->fields['num'];\n\t\t\t\t\t$s = $rsdef->fields['def'];\n\t\t\t\t\tif (strpos($s,'::')===false && substr($s, 0, 1) == \"'\") { /* quoted strings hack... for now... fixme */\n\t\t\t\t\t\t$s = substr($s, 1);\n\t\t\t\t\t\t$s = substr($s, 0, strlen($s) - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\t$rsdefa[$num] = $s;\n\t\t\t\t\t$rsdef->MoveNext();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tADOConnection::outp( \"==> SQL => \" . $sql);\n\t\t\t}\n\t\t\tunset($rsdef);\n\t\t}\n\n\t\t$retarr = array();\n\t\twhile (!$rs->EOF) {\n\t\t\t$fld = new ADOFieldObject();\n\t\t\t$fld->name = $rs->fields[0];\n\t\t\t$fld->type = $rs->fields[1];\n\t\t\t$fld->max_length = $rs->fields[2];\n\t\t\t$fld->attnum = $rs->fields[6];\n\n\t\t\tif ($fld->max_length <= 0) $fld->max_length = $rs->fields[3]-4;\n\t\t\tif ($fld->max_length <= 0) $fld->max_length = -1;\n\t\t\tif ($fld->type == 'numeric') {\n\t\t\t\t$fld->scale = $fld->max_length & 0xFFFF;\n\t\t\t\t$fld->max_length >>= 16;\n\t\t\t}\n\t\t\t// dannym\n\t\t\t// 5 hasdefault; 6 num-of-column\n\t\t\t$fld->has_default = ($rs->fields[5] == 't');\n\t\t\tif ($fld->has_default) {\n\t\t\t\t$fld->default_value = $rsdefa[$rs->fields[6]];\n\t\t\t}\n\n\t\t\t//Freek\n\t\t\t$fld->not_null = $rs->fields[4] == 't';\n\n\n\t\t\t// Freek\n\t\t\tif (is_array($keys)) {\n\t\t\t\tforeach($keys as $key) {\n\t\t\t\t\tif ($fld->name == $key['column_name'] AND $key['primary_key'] == 't')\n\t\t\t\t\t\t$fld->primary_key = true;\n\t\t\t\t\tif ($fld->name == $key['column_name'] AND $key['unique_key'] == 't')\n\t\t\t\t\t\t$fld->unique = true; // What name is more compatible?\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($ADODB_FETCH_MODE == ADODB_FETCH_NUM) $retarr[] = $fld;\n\t\t\telse $retarr[($normalize) ? strtoupper($fld->name) : $fld->name] = $fld;\n\n\t\t\t$rs->MoveNext();\n\t\t}\n\t\t$rs->Close();\n\t\tif (empty($retarr))\n\t\t\treturn  $false;\n\t\telse\n\t\t\treturn $retarr;\n\n\t}\n\n\tfunction Param($name,$type='C')\n\t{\n\t\tif ($name) {\n\t\t\t$this->_pnum += 1;\n\t\t} else {\n\t\t\t// Reset param num if $name is false\n\t\t\t$this->_pnum = 1;\n\t\t}\n\t\treturn '$'.$this->_pnum;\n\t}\n\n\tfunction MetaIndexes ($table, $primary = FALSE, $owner = false)\n\t{\n\t\tglobal $ADODB_FETCH_MODE;\n\n\t\t$schema = false;\n\t\t$this->_findschema($table,$schema);\n\n\t\tif ($schema) { // requires pgsql 7.3+ - pg_namespace used.\n\t\t\t$sql = '\n\t\t\t\tSELECT c.relname as \"Name\", i.indisunique as \"Unique\", i.indkey as \"Columns\"\n\t\t\t\tFROM pg_catalog.pg_class c\n\t\t\t\tJOIN pg_catalog.pg_index i ON i.indexrelid=c.oid\n\t\t\t\tJOIN pg_catalog.pg_class c2 ON c2.oid=i.indrelid\n\t\t\t\t\t,pg_namespace n\n\t\t\t\tWHERE (c2.relname=\\'%s\\' or c2.relname=lower(\\'%s\\'))\n\t\t\t\tand c.relnamespace=c2.relnamespace\n\t\t\t\tand c.relnamespace=n.oid\n\t\t\t\tand n.nspname=\\'%s\\'';\n\t\t} else {\n\t\t\t$sql = '\n\t\t\t\tSELECT c.relname as \"Name\", i.indisunique as \"Unique\", i.indkey as \"Columns\"\n\t\t\t\tFROM pg_catalog.pg_class c\n\t\t\t\tJOIN pg_catalog.pg_index i ON i.indexrelid=c.oid\n\t\t\t\tJOIN pg_catalog.pg_class c2 ON c2.oid=i.indrelid\n\t\t\t\tWHERE (c2.relname=\\'%s\\' or c2.relname=lower(\\'%s\\'))';\n\t\t}\n\n\t\tif ($primary == FALSE) {\n\t\t\t$sql .= ' AND i.indisprimary=false;';\n\t\t}\n\n\t\t$save = $ADODB_FETCH_MODE;\n\t\t$ADODB_FETCH_MODE = ADODB_FETCH_NUM;\n\t\tif ($this->fetchMode !== FALSE) {\n\t\t\t$savem = $this->SetFetchMode(FALSE);\n\t\t}\n\n\t\t$rs = $this->Execute(sprintf($sql,$table,$table,$schema));\n\t\tif (isset($savem)) {\n\t\t\t$this->SetFetchMode($savem);\n\t\t}\n\t\t$ADODB_FETCH_MODE = $save;\n\n\t\tif (!is_object($rs)) {\n\t\t\t$false = false;\n\t\t\treturn $false;\n\t\t}\n\n\t\t$col_names = $this->MetaColumnNames($table,true,true);\n\t\t// 3rd param is use attnum,\n\t\t// see https://sourceforge.net/p/adodb/bugs/45/\n\t\t$indexes = array();\n\t\twhile ($row = $rs->FetchRow()) {\n\t\t\t$columns = array();\n\t\t\tforeach (explode(' ', $row[2]) as $col) {\n\t\t\t\t$columns[] = $col_names[$col];\n\t\t\t}\n\n\t\t\t$indexes[$row[0]] = array(\n\t\t\t\t'unique' => ($row[1] == 't'),\n\t\t\t\t'columns' => $columns\n\t\t\t);\n\t\t}\n\t\treturn $indexes;\n\t}\n\n\t// returns true or false\n\t//\n\t// examples:\n\t// \t$db->Connect(\"host=host1 user=user1 password=secret port=4341\");\n\t// \t$db->Connect('host1','user1','secret');\n\tfunction _connect($str,$user='',$pwd='',$db='',$ctype=0)\n\t{\n\t\tif (!function_exists('pg_connect')) return null;\n\n\t\t$this->_errorMsg = false;\n\n\t\tif ($user || $pwd || $db) {\n\t\t\t$user = adodb_addslashes($user);\n\t\t\t$pwd = adodb_addslashes($pwd);\n\t\t\tif (strlen($db) == 0) $db = 'template1';\n\t\t\t$db = adodb_addslashes($db);\n\t\t\tif ($str)  {\n\t\t\t\t$host = explode(\":\", $str);\n\t\t\t\tif ($host[0]) $str = \"host=\".adodb_addslashes($host[0]);\n\t\t\t\telse $str = '';\n\t\t\t\tif (isset($host[1])) $str .= \" port=$host[1]\";\n\t\t\t\telse if (!empty($this->port)) $str .= \" port=\".$this->port;\n\t\t\t}\n\t\t\tif ($user) $str .= \" user=\".$user;\n\t\t\tif ($pwd)  $str .= \" password=\".$pwd;\n\t\t\tif ($db)   $str .= \" dbname=\".$db;\n\t\t}\n\n\t\t//if ($user) $linea = \"user=$user host=$linea password=$pwd dbname=$db port=5432\";\n\n\t\tif ($ctype === 1) { // persistent\n\t\t\t$this->_connectionID = pg_pconnect($str);\n\t\t} else {\n\t\t\tif ($ctype === -1) { // nconnect, we trick pgsql ext by changing the connection str\n\t\t\t\tstatic $ncnt;\n\n\t\t\t\tif (empty($ncnt)) $ncnt = 1;\n\t\t\t\telse $ncnt += 1;\n\n\t\t\t\t$str .= str_repeat(' ',$ncnt);\n\t\t\t}\n\t\t\t$this->_connectionID = pg_connect($str);\n\t\t}\n\t\tif ($this->_connectionID === false) return false;\n\t\t$this->Execute(\"set datestyle='ISO'\");\n\n\t\t$info = $this->ServerInfo();\n\t\t$this->pgVersion = (float) substr($info['version'],0,3);\n\t\tif ($this->pgVersion >= 7.1) { // good till version 999\n\t\t\t$this->_nestedSQL = true;\n\t\t}\n\n\t\t# PostgreSQL 9.0 changed the default output for bytea from 'escape' to 'hex'\n\t\t# PHP does not handle 'hex' properly ('x74657374' is returned as 't657374')\n\t\t# https://bugs.php.net/bug.php?id=59831 states this is in fact not a bug,\n\t\t# so we manually set bytea_output\n\t\tif ( !empty($this->connection->noBlobs) && version_compare($info['version'], '9.0', '>=')) {\n\t\t\t$this->Execute('set bytea_output=escape');\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction _nconnect($argHostname, $argUsername, $argPassword, $argDatabaseName)\n\t{\n\t\treturn $this->_connect($argHostname, $argUsername, $argPassword, $argDatabaseName,-1);\n\t}\n\n\t// returns true or false\n\t//\n\t// examples:\n\t// \t$db->PConnect(\"host=host1 user=user1 password=secret port=4341\");\n\t// \t$db->PConnect('host1','user1','secret');\n\tfunction _pconnect($str,$user='',$pwd='',$db='')\n\t{\n\t\treturn $this->_connect($str,$user,$pwd,$db,1);\n\t}\n\n\n\t// returns queryID or false\n\tfunction _query($sql,$inputarr=false)\n\t{\n\t\t$this->_pnum = 0;\n\t\t$this->_errorMsg = false;\n\t\tif ($inputarr) {\n\t\t/*\n\t\t\tIt appears that PREPARE/EXECUTE is slower for many queries.\n\n\t\t\tFor query executed 1000 times:\n\t\t\t\"select id,firstname,lastname from adoxyz\n\t\t\t\twhere firstname not like ? and lastname not like ? and id = ?\"\n\n\t\t\twith plan = 1.51861286163 secs\n\t\t\tno plan =   1.26903700829 secs\n\t\t*/\n\t\t\t$plan = 'P'.md5($sql);\n\n\t\t\t$execp = '';\n\t\t\tforeach($inputarr as $v) {\n\t\t\t\tif ($execp) $execp .= ',';\n\t\t\t\tif (is_string($v)) {\n\t\t\t\t\tif (strncmp($v,\"'\",1) !== 0) $execp .= $this->qstr($v);\n\t\t\t\t} else {\n\t\t\t\t\t$execp .= $v;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($execp) $exsql = \"EXECUTE $plan ($execp)\";\n\t\t\telse $exsql = \"EXECUTE $plan\";\n\n\n\t\t\t$rez = @pg_execute($this->_connectionID,$exsql);\n\t\t\tif (!$rez) {\n\t\t\t# Perhaps plan does not exist? Prepare/compile plan.\n\t\t\t\t$params = '';\n\t\t\t\tforeach($inputarr as $v) {\n\t\t\t\t\tif ($params) $params .= ',';\n\t\t\t\t\tif (is_string($v)) {\n\t\t\t\t\t\t$params .= 'VARCHAR';\n\t\t\t\t\t} else if (is_integer($v)) {\n\t\t\t\t\t\t$params .= 'INTEGER';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$params .= \"REAL\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$sqlarr = explode('?',$sql);\n\t\t\t\t//print_r($sqlarr);\n\t\t\t\t$sql = '';\n\t\t\t\t$i = 1;\n\t\t\t\tforeach($sqlarr as $v) {\n\t\t\t\t\t$sql .= $v.' $'.$i;\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t\t$s = \"PREPARE $plan ($params) AS \".substr($sql,0,strlen($sql)-2);\n\t\t\t\t//adodb_pr($s);\n\t\t\t\t$rez = pg_execute($this->_connectionID,$s);\n\t\t\t\t//echo $this->ErrorMsg();\n\t\t\t}\n\t\t\tif ($rez)\n\t\t\t\t$rez = pg_execute($this->_connectionID,$exsql);\n\t\t} else {\n\t\t\t//adodb_backtrace();\n\t\t\t$rez = pg_query($this->_connectionID,$sql);\n\t\t}\n\t\t// check if no data returned, then no need to create real recordset\n\t\tif ($rez && pg_num_fields($rez) <= 0) {\n\t\t\tif (is_resource($this->_resultid) && get_resource_type($this->_resultid) === 'pgsql result') {\n\t\t\t\tpg_free_result($this->_resultid);\n\t\t\t}\n\t\t\t$this->_resultid = $rez;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn $rez;\n\t}\n\n\tfunction _errconnect()\n\t{\n\t\tif (defined('DB_ERROR_CONNECT_FAILED')) return DB_ERROR_CONNECT_FAILED;\n\t\telse return 'Database connection failed';\n\t}\n\n\t/*\tReturns: the last error message from previous database operation\t*/\n\tfunction ErrorMsg()\n\t{\n\t\tif ($this->_errorMsg !== false) return $this->_errorMsg;\n\t\tif (ADODB_PHPVER >= 0x4300) {\n\t\t\tif (!empty($this->_resultid)) {\n\t\t\t\t$this->_errorMsg = @pg_result_error($this->_resultid);\n\t\t\t\tif ($this->_errorMsg) return $this->_errorMsg;\n\t\t\t}\n\n\t\t\tif (!empty($this->_connectionID)) {\n\t\t\t\t$this->_errorMsg = @pg_last_error($this->_connectionID);\n\t\t\t} else $this->_errorMsg = $this->_errconnect();\n\t\t} else {\n\t\t\tif (empty($this->_connectionID)) $this->_errconnect();\n\t\t\telse $this->_errorMsg = @pg_last_error($this->_connectionID);\n\t\t}\n\t\treturn $this->_errorMsg;\n\t}\n\n\tfunction ErrorNo()\n\t{\n\t\t$e = $this->ErrorMsg();\n\t\tif (strlen($e)) {\n\t\t\treturn ADOConnection::MetaError($e);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// returns true or false\n\tfunction _close()\n\t{\n\t\tif ($this->transCnt) $this->RollbackTrans();\n\t\tif ($this->_resultid) {\n\t\t\t@pg_free_result($this->_resultid);\n\t\t\t$this->_resultid = false;\n\t\t}\n\t\t@pg_close($this->_connectionID);\n\t\t$this->_connectionID = false;\n\t\treturn true;\n\t}\n\n\n\t/*\n\t* Maximum size of C field\n\t*/\n\tfunction CharMax()\n\t{\n\t\treturn 1000000000;  // should be 1 Gb?\n\t}\n\n\t/*\n\t* Maximum size of X field\n\t*/\n\tfunction TextMax()\n\t{\n\t\treturn 1000000000; // should be 1 Gb?\n\t}\n\n\n}\n\n/*--------------------------------------------------------------------------------------\n\tClass Name: Recordset\n--------------------------------------------------------------------------------------*/\n\nclass ADORecordSet_postgres64 extends ADORecordSet{\n\tvar $_blobArr;\n\tvar $databaseType = \"postgres64\";\n\tvar $canSeek = true;\n\n\tfunction __construct($queryID, $mode=false)\n\t{\n\t\tif ($mode === false) {\n\t\t\tglobal $ADODB_FETCH_MODE;\n\t\t\t$mode = $ADODB_FETCH_MODE;\n\t\t}\n\t\tswitch ($mode)\n\t\t{\n\t\tcase ADODB_FETCH_NUM: $this->fetchMode = PGSQL_NUM; break;\n\t\tcase ADODB_FETCH_ASSOC:$this->fetchMode = PGSQL_ASSOC; break;\n\n\t\tcase ADODB_FETCH_DEFAULT:\n\t\tcase ADODB_FETCH_BOTH:\n\t\tdefault: $this->fetchMode = PGSQL_BOTH; break;\n\t\t}\n\t\t$this->adodbFetchMode = $mode;\n\n\t\t// Parent's constructor\n\t\tparent::__construct($queryID);\n\t}\n\n\tfunction GetRowAssoc($upper = ADODB_ASSOC_CASE)\n\t{\n\t\tif ($this->fetchMode == PGSQL_ASSOC && $upper == ADODB_ASSOC_CASE_LOWER) {\n\t\t\treturn $this->fields;\n\t\t}\n\t\t$row = ADORecordSet::GetRowAssoc($upper);\n\t\treturn $row;\n\t}\n\n\n\tfunction _initrs()\n\t{\n\tglobal $ADODB_COUNTRECS;\n\t\t$qid = $this->_queryID;\n\t\t$this->_numOfRows = ($ADODB_COUNTRECS)? @pg_num_rows($qid):-1;\n\t\t$this->_numOfFields = @pg_num_fields($qid);\n\n\t\t// cache types for blob decode check\n\t\t// apparently pg_field_type actually performs an sql query on the database to get the type.\n\t\tif (empty($this->connection->noBlobs))\n\t\tfor ($i=0, $max = $this->_numOfFields; $i < $max; $i++) {\n\t\t\tif (pg_field_type($qid,$i) == 'bytea') {\n\t\t\t\t$this->_blobArr[$i] = pg_field_name($qid,$i);\n\t\t\t}\n\t\t}\n\t}\n\n\t\t/* Use associative array to get fields array */\n\tfunction Fields($colname)\n\t{\n\t\tif ($this->fetchMode != PGSQL_NUM) return @$this->fields[$colname];\n\n\t\tif (!$this->bind) {\n\t\t\t$this->bind = array();\n\t\t\tfor ($i=0; $i < $this->_numOfFields; $i++) {\n\t\t\t\t$o = $this->FetchField($i);\n\t\t\t\t$this->bind[strtoupper($o->name)] = $i;\n\t\t\t}\n\t\t}\n\t\treturn $this->fields[$this->bind[strtoupper($colname)]];\n\t}\n\n\tfunction FetchField($off = 0)\n\t{\n\t\t// offsets begin at 0\n\n\t\t$o= new ADOFieldObject();\n\t\t$o->name = @pg_field_name($this->_queryID,$off);\n\t\t$o->type = @pg_field_type($this->_queryID,$off);\n\t\t$o->max_length = @pg_field_size($this->_queryID,$off);\n\t\treturn $o;\n\t}\n\n\tfunction _seek($row)\n\t{\n\t\treturn @pg_fetch_row($this->_queryID,$row);\n\t}\n\n\tfunction _decode($blob)\n\t{\n\t\tif ($blob === NULL) return NULL;\n//\t\teval('$realblob=\"'.adodb_str_replace(array('\"','$'),array('\\\"','\\$'),$blob).'\";');\n\t\treturn pg_unescape_bytea($blob);\n\t}\n\n\tfunction _fixblobs()\n\t{\n\t\tif ($this->fetchMode == PGSQL_NUM || $this->fetchMode == PGSQL_BOTH) {\n\t\t\tforeach($this->_blobArr as $k => $v) {\n\t\t\t\t$this->fields[$k] = ADORecordSet_postgres64::_decode($this->fields[$k]);\n\t\t\t}\n\t\t}\n\t\tif ($this->fetchMode == PGSQL_ASSOC || $this->fetchMode == PGSQL_BOTH) {\n\t\t\tforeach($this->_blobArr as $k => $v) {\n\t\t\t\t$this->fields[$v] = ADORecordSet_postgres64::_decode($this->fields[$v]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 10% speedup to move MoveNext to child class\n\tfunction MoveNext()\n\t{\n\t\tif (!$this->EOF) {\n\t\t\t$this->_currentRow++;\n\t\t\tif ($this->_numOfRows < 0 || $this->_numOfRows > $this->_currentRow) {\n\t\t\t\t$this->fields = @pg_fetch_array($this->_queryID,$this->_currentRow,$this->fetchMode);\n\t\t\t\tif (is_array($this->fields) && $this->fields) {\n\t\t\t\t\tif (isset($this->_blobArr)) $this->_fixblobs();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->fields = false;\n\t\t\t$this->EOF = true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction _fetch()\n\t{\n\n\t\tif ($this->_currentRow >= $this->_numOfRows && $this->_numOfRows >= 0)\n\t\t\treturn false;\n\n\t\t$this->fields = @pg_fetch_array($this->_queryID,$this->_currentRow,$this->fetchMode);\n\n\t\tif ($this->fields && isset($this->_blobArr)) $this->_fixblobs();\n\n\t\treturn (is_array($this->fields));\n\t}\n\n\tfunction _close()\n\t{\n\t\tif (!is_resource($this->_queryID)\n\t\t\t|| get_resource_type($this->_queryID) != 'pgsql result'\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn pg_free_result($this->_queryID);\n\t}\n\n\tfunction MetaType($t,$len=-1,$fieldobj=false)\n\t{\n\t\tif (is_object($t)) {\n\t\t\t$fieldobj = $t;\n\t\t\t$t = $fieldobj->type;\n\t\t\t$len = $fieldobj->max_length;\n\t\t}\n\t\tswitch (strtoupper($t)) {\n\t\t\t\tcase 'MONEY': // stupid, postgres expects money to be a string\n\t\t\t\tcase 'INTERVAL':\n\t\t\t\tcase 'CHAR':\n\t\t\t\tcase 'CHARACTER':\n\t\t\t\tcase 'VARCHAR':\n\t\t\t\tcase 'NAME':\n\t\t\t\tcase 'BPCHAR':\n\t\t\t\tcase '_VARCHAR':\n\t\t\t\tcase 'INET':\n\t\t\t\tcase 'MACADDR':\n\t\t\t\t\tif ($len <= $this->blobSize) return 'C';\n\n\t\t\t\tcase 'TEXT':\n\t\t\t\t\treturn 'X';\n\n\t\t\t\tcase 'IMAGE': // user defined type\n\t\t\t\tcase 'BLOB': // user defined type\n\t\t\t\tcase 'BIT':\t// This is a bit string, not a single bit, so don't return 'L'\n\t\t\t\tcase 'VARBIT':\n\t\t\t\tcase 'BYTEA':\n\t\t\t\t\treturn 'B';\n\n\t\t\t\tcase 'BOOL':\n\t\t\t\tcase 'BOOLEAN':\n\t\t\t\t\treturn 'L';\n\n\t\t\t\tcase 'DATE':\n\t\t\t\t\treturn 'D';\n\n\n\t\t\t\tcase 'TIMESTAMP WITHOUT TIME ZONE':\n\t\t\t\tcase 'TIME':\n\t\t\t\tcase 'DATETIME':\n\t\t\t\tcase 'TIMESTAMP':\n\t\t\t\tcase 'TIMESTAMPTZ':\n\t\t\t\t\treturn 'T';\n\n\t\t\t\tcase 'SMALLINT':\n\t\t\t\tcase 'BIGINT':\n\t\t\t\tcase 'INTEGER':\n\t\t\t\tcase 'INT8':\n\t\t\t\tcase 'INT4':\n\t\t\t\tcase 'INT2':\n\t\t\t\t\tif (isset($fieldobj) &&\n\t\t\t\tempty($fieldobj->primary_key) && (!$this->connection->uniqueIisR || empty($fieldobj->unique))) return 'I';\n\n\t\t\t\tcase 'OID':\n\t\t\t\tcase 'SERIAL':\n\t\t\t\t\treturn 'R';\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn 'N';\n\t\t\t}\n\t}\n\n}\n"], "filenames": ["drivers/adodb-postgres64.inc.php"], "buggy_code_start_loc": [54], "buggy_code_end_loc": [55], "fixing_code_start_loc": [53], "fixing_code_end_loc": [53], "type": "CWE-287", "message": "Authentication Bypass by Primary Weakness in GitHub repository adodb/adodb prior to 5.20.21.", "other": {"cve": {"id": "CVE-2021-3850", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-25T15:15:08.013", "lastModified": "2022-10-27T11:45:56.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Authentication Bypass by Primary Weakness in GitHub repository adodb/adodb prior to 5.20.21."}, {"lang": "es", "value": "Una Omisi\u00f3n de Autenticaci\u00f3n por Debilidad Primaria en el repositorio de GitHub adodb/adodb versiones anteriores a 5.20.21"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-305"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.20.21", "matchCriteriaId": "DD9D707E-EF89-4981-86D5-B714E8743B3B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/adodb/adodb/commit/952de6c4273d9b1e91c2b838044f8c2111150c29", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/bdf5f216-4499-4225-a737-b28bc6f5801c", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/02/msg00006.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5101", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/adodb/adodb/commit/952de6c4273d9b1e91c2b838044f8c2111150c29"}}