{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR\n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n#include \"opj_common.h\"\n\n/* ----------------------------------------------------------------------- */\n\n/* TODO MSD: */\n#ifdef TODO_MSD\nvoid tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img)\n{\n    int tileno, compno, resno, bandno, precno;/*, cblkno;*/\n\n    fprintf(fd, \"image {\\n\");\n    fprintf(fd, \"  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\\n\",\n            img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0,\n            tcd->image->y1);\n\n    for (tileno = 0; tileno < img->th * img->tw; tileno++) {\n        opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];\n        fprintf(fd, \"  tile {\\n\");\n        fprintf(fd, \"    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\\n\",\n                tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);\n        for (compno = 0; compno < tile->numcomps; compno++) {\n            opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n            fprintf(fd, \"    tilec {\\n\");\n            fprintf(fd,\n                    \"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\\n\",\n                    tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);\n            for (resno = 0; resno < tilec->numresolutions; resno++) {\n                opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n                fprintf(fd, \"\\n   res {\\n\");\n                fprintf(fd,\n                        \"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\\n\",\n                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);\n                for (bandno = 0; bandno < res->numbands; bandno++) {\n                    opj_tcd_band_t *band = &res->bands[bandno];\n                    fprintf(fd, \"        band {\\n\");\n                    fprintf(fd,\n                            \"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\\n\",\n                            band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);\n                    for (precno = 0; precno < res->pw * res->ph; precno++) {\n                        opj_tcd_precinct_t *prec = &band->precincts[precno];\n                        fprintf(fd, \"          prec {\\n\");\n                        fprintf(fd,\n                                \"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\\n\",\n                                prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);\n                        /*\n                        for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {\n                                opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];\n                                fprintf(fd, \"            cblk {\\n\");\n                                fprintf(fd,\n                                        \"              x0=%d, y0=%d, x1=%d, y1=%d\\n\",\n                                        cblk->x0, cblk->y0, cblk->x1, cblk->y1);\n                                fprintf(fd, \"            }\\n\");\n                        }\n                        */\n                        fprintf(fd, \"          }\\n\");\n                    }\n                    fprintf(fd, \"        }\\n\");\n                }\n                fprintf(fd, \"      }\\n\");\n            }\n            fprintf(fd, \"    }\\n\");\n        }\n        fprintf(fd, \"  }\\n\");\n    }\n    fprintf(fd, \"}\\n\");\n}\n#endif\n\n/**\n * Initializes tile coding/decoding\n */\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,\n        opj_event_mgr_t* manager);\n\n/**\n* Allocates memory for a decoding code block.\n*/\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block);\n\n/**\n * Deallocates the decoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t * p_precinct);\n\n/**\n * Allocates memory for an encoding code block (but not data).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *\n        p_code_block);\n\n/**\n * Allocates data for an encoding code block\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block);\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t * p_precinct);\n\n\n/**\nFree the memory allocated for encoding\n@param tcd TCD handle\n*/\nstatic void opj_tcd_free_tile(opj_tcd_t *tcd);\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_src_data,\n                                  OPJ_UINT32 * p_data_read,\n                                  OPJ_UINT32 p_max_src_size,\n                                  opj_codestream_index_t *p_cstr_index,\n                                  opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd,\n                                  opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd,\n                                   opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd);\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_dest_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_max_dest_size,\n                                  opj_codestream_info_t *p_cstr_info);\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd,\n        OPJ_BYTE * p_dest_data,\n        OPJ_UINT32 p_max_dest_size,\n        opj_codestream_info_t *p_cstr_info);\n\n/* ----------------------------------------------------------------------- */\n\n/**\nCreate a new TCD handle\n*/\nopj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)\n{\n    opj_tcd_t *l_tcd = 00;\n\n    /* create the tcd structure */\n    l_tcd = (opj_tcd_t*) opj_calloc(1, sizeof(opj_tcd_t));\n    if (!l_tcd) {\n        return 00;\n    }\n\n    l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;\n\n    l_tcd->tcd_image = (opj_tcd_image_t*)opj_calloc(1, sizeof(opj_tcd_image_t));\n    if (!l_tcd->tcd_image) {\n        opj_free(l_tcd);\n        return 00;\n    }\n\n    return l_tcd;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\nvoid opj_tcd_rateallocate_fixed(opj_tcd_t *tcd)\n{\n    OPJ_UINT32 layno;\n\n    for (layno = 0; layno < tcd->tcp->numlayers; layno++) {\n        opj_tcd_makelayer_fixed(tcd, layno, 1);\n    }\n}\n\n\nvoid opj_tcd_makelayer(opj_tcd_t *tcd,\n                       OPJ_UINT32 layno,\n                       OPJ_FLOAT64 thresh,\n                       OPJ_UINT32 final)\n{\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    OPJ_UINT32 passno;\n\n    opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n\n    tcd_tile->distolayer[layno] = 0;        /* fixed_quality */\n\n    for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n        opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n        for (resno = 0; resno < tilec->numresolutions; resno++) {\n            opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n            for (bandno = 0; bandno < res->numbands; bandno++) {\n                opj_tcd_band_t *band = &res->bands[bandno];\n\n                /* Skip empty bands */\n                if (opj_tcd_is_band_empty(band)) {\n                    continue;\n                }\n\n                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                    opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                    for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                        opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                        opj_tcd_layer_t *layer = &cblk->layers[layno];\n                        OPJ_UINT32 n;\n\n                        if (layno == 0) {\n                            cblk->numpassesinlayers = 0;\n                        }\n\n                        n = cblk->numpassesinlayers;\n\n                        for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {\n                            OPJ_UINT32 dr;\n                            OPJ_FLOAT64 dd;\n                            opj_tcd_pass_t *pass = &cblk->passes[passno];\n\n                            if (n == 0) {\n                                dr = pass->rate;\n                                dd = pass->distortiondec;\n                            } else {\n                                dr = pass->rate - cblk->passes[n - 1].rate;\n                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;\n                            }\n\n                            if (!dr) {\n                                if (dd != 0) {\n                                    n = passno + 1;\n                                }\n                                continue;\n                            }\n                            if (thresh - (dd / dr) <\n                                    DBL_EPSILON) { /* do not rely on float equality, check with DBL_EPSILON margin */\n                                n = passno + 1;\n                            }\n                        }\n\n                        layer->numpasses = n - cblk->numpassesinlayers;\n\n                        if (!layer->numpasses) {\n                            layer->disto = 0;\n                            continue;\n                        }\n\n                        if (cblk->numpassesinlayers == 0) {\n                            layer->len = cblk->passes[n - 1].rate;\n                            layer->data = cblk->data;\n                            layer->disto = cblk->passes[n - 1].distortiondec;\n                        } else {\n                            layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers -\n                                         1].rate;\n                            layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                            layer->disto = cblk->passes[n - 1].distortiondec -\n                                           cblk->passes[cblk->numpassesinlayers - 1].distortiondec;\n                        }\n\n                        tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */\n\n                        if (final) {\n                            cblk->numpassesinlayers = n;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno,\n                             OPJ_UINT32 final)\n{\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */\n    OPJ_INT32 matrice[10][10][3];\n    OPJ_UINT32 i, j, k;\n\n    opj_cp_t *cp = tcd->cp;\n    opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n    opj_tcp_t *tcd_tcp = tcd->tcp;\n\n    for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n        opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n        for (i = 0; i < tcd_tcp->numlayers; i++) {\n            for (j = 0; j < tilec->numresolutions; j++) {\n                for (k = 0; k < 3; k++) {\n                    matrice[i][j][k] =\n                        (OPJ_INT32)((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i *\n                                      tilec->numresolutions * 3 + j * 3 + k]\n                                    * (OPJ_FLOAT32)(tcd->image->comps[compno].prec / 16.0));\n                }\n            }\n        }\n\n        for (resno = 0; resno < tilec->numresolutions; resno++) {\n            opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n            for (bandno = 0; bandno < res->numbands; bandno++) {\n                opj_tcd_band_t *band = &res->bands[bandno];\n\n                /* Skip empty bands */\n                if (opj_tcd_is_band_empty(band)) {\n                    continue;\n                }\n\n                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                    opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                    for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                        opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                        opj_tcd_layer_t *layer = &cblk->layers[layno];\n                        OPJ_UINT32 n;\n                        OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec -\n                                                     cblk->numbps); /* number of bit-plan equal to zero */\n\n                        /* Correction of the matrix of coefficient to include the IMSB information */\n                        if (layno == 0) {\n                            value = matrice[layno][resno][bandno];\n                            if (imsb >= value) {\n                                value = 0;\n                            } else {\n                                value -= imsb;\n                            }\n                        } else {\n                            value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];\n                            if (imsb >= matrice[layno - 1][resno][bandno]) {\n                                value -= (imsb - matrice[layno - 1][resno][bandno]);\n                                if (value < 0) {\n                                    value = 0;\n                                }\n                            }\n                        }\n\n                        if (layno == 0) {\n                            cblk->numpassesinlayers = 0;\n                        }\n\n                        n = cblk->numpassesinlayers;\n                        if (cblk->numpassesinlayers == 0) {\n                            if (value != 0) {\n                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;\n                            } else {\n                                n = cblk->numpassesinlayers;\n                            }\n                        } else {\n                            n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;\n                        }\n\n                        layer->numpasses = n - cblk->numpassesinlayers;\n\n                        if (!layer->numpasses) {\n                            continue;\n                        }\n\n                        if (cblk->numpassesinlayers == 0) {\n                            layer->len = cblk->passes[n - 1].rate;\n                            layer->data = cblk->data;\n                        } else {\n                            layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers -\n                                         1].rate;\n                            layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                        }\n\n                        if (final) {\n                            cblk->numpassesinlayers = n;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nOPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd,\n                              OPJ_BYTE *dest,\n                              OPJ_UINT32 * p_data_written,\n                              OPJ_UINT32 len,\n                              opj_codestream_info_t *cstr_info)\n{\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;\n    OPJ_UINT32 passno;\n    OPJ_FLOAT64 min, max;\n    OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */\n    const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */\n    OPJ_FLOAT64 maxSE = 0;\n\n    opj_cp_t *cp = tcd->cp;\n    opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n    opj_tcp_t *tcd_tcp = tcd->tcp;\n\n    min = DBL_MAX;\n    max = 0;\n\n    tcd_tile->numpix = 0;           /* fixed_quality */\n\n    for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n        opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n        tilec->numpix = 0;\n\n        for (resno = 0; resno < tilec->numresolutions; resno++) {\n            opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n            for (bandno = 0; bandno < res->numbands; bandno++) {\n                opj_tcd_band_t *band = &res->bands[bandno];\n\n                /* Skip empty bands */\n                if (opj_tcd_is_band_empty(band)) {\n                    continue;\n                }\n\n                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                    opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                    for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                        opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n\n                        for (passno = 0; passno < cblk->totalpasses; passno++) {\n                            opj_tcd_pass_t *pass = &cblk->passes[passno];\n                            OPJ_INT32 dr;\n                            OPJ_FLOAT64 dd, rdslope;\n\n                            if (passno == 0) {\n                                dr = (OPJ_INT32)pass->rate;\n                                dd = pass->distortiondec;\n                            } else {\n                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);\n                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;\n                            }\n\n                            if (dr == 0) {\n                                continue;\n                            }\n\n                            rdslope = dd / dr;\n                            if (rdslope < min) {\n                                min = rdslope;\n                            }\n\n                            if (rdslope > max) {\n                                max = rdslope;\n                            }\n                        } /* passno */\n\n                        /* fixed_quality */\n                        tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                        tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                    } /* cbklno */\n                } /* precno */\n            } /* bandno */\n        } /* resno */\n\n        maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)\n                  * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0))\n                 * ((OPJ_FLOAT64)(tilec->numpix));\n    } /* compno */\n\n    /* index file */\n    if (cstr_info) {\n        opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];\n        tile_info->numpix = tcd_tile->numpix;\n        tile_info->distotile = tcd_tile->distotile;\n        tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(\n                                OPJ_FLOAT64));\n        if (!tile_info->thresh) {\n            /* FIXME event manager error callback */\n            return OPJ_FALSE;\n        }\n    }\n\n    for (layno = 0; layno < tcd_tcp->numlayers; layno++) {\n        OPJ_FLOAT64 lo = min;\n        OPJ_FLOAT64 hi = max;\n        OPJ_UINT32 maxlen = tcd_tcp->rates[layno] > 0.0f ? opj_uint_min(((\n                                OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;\n        OPJ_FLOAT64 goodthresh = 0;\n        OPJ_FLOAT64 stable_thresh = 0;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 distotarget;                /* fixed_quality */\n\n        /* fixed_quality */\n        distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10,\n                                             tcd_tcp->distoratio[layno] / 10));\n\n        /* Don't try to find an optimal threshold but rather take everything not included yet, if\n          -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)\n          -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)\n          ==> possible to have some lossy layers and the last layer for sure lossless */\n        if (((cp->m_specific_param.m_enc.m_disto_alloc == 1) &&\n                (tcd_tcp->rates[layno] > 0.0f)) ||\n                ((cp->m_specific_param.m_enc.m_fixed_quality == 1) &&\n                 (tcd_tcp->distoratio[layno] > 0.0))) {\n            opj_t2_t*t2 = opj_t2_create(tcd->image, cp);\n            OPJ_FLOAT64 thresh = 0;\n\n            if (t2 == 00) {\n                return OPJ_FALSE;\n            }\n\n            for (i = 0; i < 128; ++i) {\n                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */\n\n                thresh = (lo + hi) / 2;\n\n                opj_tcd_makelayer(tcd, layno, thresh, 0);\n\n                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */\n                    if (OPJ_IS_CINEMA(cp->rsiz)) {\n                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,\n                                                    p_data_written, maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,\n                                                    THRESH_CALC)) {\n\n                            lo = thresh;\n                            continue;\n                        } else {\n                            distoachieved = layno == 0 ?\n                                            tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];\n\n                            if (distoachieved < distotarget) {\n                                hi = thresh;\n                                stable_thresh = thresh;\n                                continue;\n                            } else {\n                                lo = thresh;\n                            }\n                        }\n                    } else {\n                        distoachieved = (layno == 0) ?\n                                        tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n\n                        if (distoachieved < distotarget) {\n                            hi = thresh;\n                            stable_thresh = thresh;\n                            continue;\n                        }\n                        lo = thresh;\n                    }\n                } else {\n                    if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,\n                                                p_data_written, maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,\n                                                THRESH_CALC)) {\n                        /* TODO: what to do with l ??? seek / tell ??? */\n                        /* opj_event_msg(tcd->cinfo, EVT_INFO, \"rate alloc: len=%d, max=%d\\n\", l, maxlen); */\n                        lo = thresh;\n                        continue;\n                    }\n\n                    hi = thresh;\n                    stable_thresh = thresh;\n                }\n            }\n\n            goodthresh = stable_thresh == 0 ? thresh : stable_thresh;\n\n            opj_t2_destroy(t2);\n        } else {\n            goodthresh = min;\n        }\n\n        if (cstr_info) { /* Threshold for Marcela Index */\n            cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;\n        }\n\n        opj_tcd_makelayer(tcd, layno, goodthresh, 1);\n\n        /* fixed_quality */\n        cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] :\n                          (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd,\n                      opj_image_t * p_image,\n                      opj_cp_t * p_cp,\n                      opj_thread_pool_t* p_tp)\n{\n    p_tcd->image = p_image;\n    p_tcd->cp = p_cp;\n\n    p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,\n                              sizeof(opj_tcd_tile_t));\n    if (! p_tcd->tcd_image->tiles) {\n        return OPJ_FALSE;\n    }\n\n    p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(\n                                         p_image->numcomps, sizeof(opj_tcd_tilecomp_t));\n    if (! p_tcd->tcd_image->tiles->comps) {\n        return OPJ_FALSE;\n    }\n\n    p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n    p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n    p_tcd->thread_pool = p_tp;\n\n    return OPJ_TRUE;\n}\n\n/**\nDestroy a previously created TCD handle\n*/\nvoid opj_tcd_destroy(opj_tcd_t *tcd)\n{\n    if (tcd) {\n        opj_tcd_free_tile(tcd);\n\n        if (tcd->tcd_image) {\n            opj_free(tcd->tcd_image);\n            tcd->tcd_image = 00;\n        }\n        opj_free(tcd);\n    }\n}\n\nOPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)\n{\n    if ((l_tilec->data == 00) ||\n            ((l_tilec->data_size_needed > l_tilec->data_size) &&\n             (l_tilec->ownsData == OPJ_FALSE))) {\n        l_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n        if (! l_tilec->data) {\n            return OPJ_FALSE;\n        }\n        /*fprintf(stderr, \"tAllocate data of tilec (int): %d x OPJ_UINT32n\",l_data_size);*/\n        l_tilec->data_size = l_tilec->data_size_needed;\n        l_tilec->ownsData = OPJ_TRUE;\n    } else if (l_tilec->data_size_needed > l_tilec->data_size) {\n        /* We don't need to keep old data */\n        opj_aligned_free(l_tilec->data);\n        l_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n        if (! l_tilec->data) {\n            l_tilec->data_size = 0;\n            l_tilec->data_size_needed = 0;\n            l_tilec->ownsData = OPJ_FALSE;\n            return OPJ_FALSE;\n        }\n        /*fprintf(stderr, \"tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n\", l_tilec->data_size, l_data_size);*/\n        l_tilec->data_size = l_tilec->data_size_needed;\n        l_tilec->ownsData = OPJ_TRUE;\n    }\n    return OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,\n        opj_event_mgr_t* manager)\n{\n    OPJ_UINT32(*l_gain_ptr)(OPJ_UINT32) = 00;\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    opj_tcp_t * l_tcp = 00;\n    opj_cp_t * l_cp = 00;\n    opj_tcd_tile_t * l_tile = 00;\n    opj_tccp_t *l_tccp = 00;\n    opj_tcd_tilecomp_t *l_tilec = 00;\n    opj_image_comp_t * l_image_comp = 00;\n    opj_tcd_resolution_t *l_res = 00;\n    opj_tcd_band_t *l_band = 00;\n    opj_stepsize_t * l_step_size = 00;\n    opj_tcd_precinct_t *l_current_precinct = 00;\n    opj_image_t *l_image = 00;\n    OPJ_UINT32 p, q;\n    OPJ_UINT32 l_level_no;\n    OPJ_UINT32 l_pdx, l_pdy;\n    OPJ_UINT32 l_gain;\n    OPJ_INT32 l_x0b, l_y0b;\n    OPJ_UINT32 l_tx0, l_ty0;\n    /* extent of precincts , top left, bottom right**/\n    OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n    /* number of precinct for a resolution */\n    OPJ_UINT32 l_nb_precincts;\n    /* room needed to store l_nb_precinct precinct for a resolution */\n    OPJ_UINT32 l_nb_precinct_size;\n    /* number of code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks;\n    /* room needed to store l_nb_code_blocks code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks_size;\n    /* size of data for a tile */\n    OPJ_UINT32 l_data_size;\n\n    l_cp = p_tcd->cp;\n    l_tcp = &(l_cp->tcps[p_tile_no]);\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tccp = l_tcp->tccps;\n    l_tilec = l_tile->comps;\n    l_image = p_tcd->image;\n    l_image_comp = p_tcd->image->comps;\n\n    p = p_tile_no % l_cp->tw;       /* tile coordinates */\n    q = p_tile_no / l_cp->tw;\n    /*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\n    /* 4 borders of the tile rescale on the image if necessary */\n    l_tx0 = l_cp->tx0 + p *\n            l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n    l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n    l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx),\n                                         l_image->x1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile X coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n    l_ty0 = l_cp->ty0 + q *\n            l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n    l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n    l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy),\n                                         l_image->y1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile Y coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n\n\n    /* testcase 1888.pdf.asan.35.988 */\n    if (l_tccp->numresolutions == 0) {\n        opj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n        return OPJ_FALSE;\n    }\n    /*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\n    /*tile->numcomps = image->numcomps; */\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        /*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n        l_image_comp->resno_decoded = 0;\n        /* border of each l_tile component (global) */\n        l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n        l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n        /*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\n        /* compute l_data_size with overflow check */\n        l_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n        /* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */\n        if ((l_data_size > 0U) &&\n                ((((OPJ_UINT32) - 1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 -\n                        l_tilec->y0))) {\n            opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n            return OPJ_FALSE;\n        }\n        l_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\n        if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n            opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n            return OPJ_FALSE;\n        }\n        l_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n        l_tilec->numresolutions = l_tccp->numresolutions;\n        if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n            l_tilec->minimum_num_resolutions = 1;\n        } else {\n            l_tilec->minimum_num_resolutions = l_tccp->numresolutions -\n                                               l_cp->m_specific_param.m_dec.m_reduce;\n        }\n\n        l_tilec->data_size_needed = l_data_size;\n        if (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n            opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n            return OPJ_FALSE;\n        }\n\n        l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(\n                          opj_tcd_resolution_t);\n\n        if (l_tilec->resolutions == 00) {\n            l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n            if (! l_tilec->resolutions) {\n                return OPJ_FALSE;\n            }\n            /*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n            l_tilec->resolutions_size = l_data_size;\n            memset(l_tilec->resolutions, 0, l_data_size);\n        } else if (l_data_size > l_tilec->resolutions_size) {\n            opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(\n                    l_tilec->resolutions, l_data_size);\n            if (! new_resolutions) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n                opj_free(l_tilec->resolutions);\n                l_tilec->resolutions = NULL;\n                l_tilec->resolutions_size = 0;\n                return OPJ_FALSE;\n            }\n            l_tilec->resolutions = new_resolutions;\n            /*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n            memset(((OPJ_BYTE*) l_tilec->resolutions) + l_tilec->resolutions_size, 0,\n                   l_data_size - l_tilec->resolutions_size);\n            l_tilec->resolutions_size = l_data_size;\n        }\n\n        l_level_no = l_tilec->numresolutions;\n        l_res = l_tilec->resolutions;\n        l_step_size = l_tccp->stepsizes;\n        if (l_tccp->qmfbid == 0) {\n            l_gain_ptr = &opj_dwt_getgain_real;\n        } else {\n            l_gain_ptr  = &opj_dwt_getgain;\n        }\n        /*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\n        for (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n            /*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n            OPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n            OPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n            OPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\n            --l_level_no;\n\n            /* border for each resolution level (global) */\n            l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n            l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n            l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n            l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n            /*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n            /* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n            /*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n            /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n            l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n            /*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\n            l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n            l_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n            /*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\n            if ((l_res->pw != 0U) && ((((OPJ_UINT32) - 1) / l_res->pw) < l_res->ph)) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precincts = l_res->pw * l_res->ph;\n\n            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <\n                    l_nb_precincts) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n            if (resno == 0) {\n                tlcbgxstart = l_tl_prc_x_start;\n                tlcbgystart = l_tl_prc_y_start;\n                /*brcbgxend = l_br_prc_x_end;*/\n                /* brcbgyend = l_br_prc_y_end;*/\n                cbgwidthexpn = l_pdx;\n                cbgheightexpn = l_pdy;\n                l_res->numbands = 1;\n            } else {\n                tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n                tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n                /*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n                /*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n                cbgwidthexpn = l_pdx - 1;\n                cbgheightexpn = l_pdy - 1;\n                l_res->numbands = 3;\n            }\n\n            cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n            cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n            l_band = l_res->bands;\n\n            for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band, ++l_step_size) {\n                OPJ_INT32 numbps;\n                /*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\n                if (resno == 0) {\n                    l_band->bandno = 0 ;\n                    l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n                    l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n                    l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n                    l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n                } else {\n                    l_band->bandno = bandno + 1;\n                    /* x0b = 1 if bandno = 1 or 3 */\n                    l_x0b = l_band->bandno & 1;\n                    /* y0b = 1 if bandno = 2 or 3 */\n                    l_y0b = (OPJ_INT32)((l_band->bandno) >> 1);\n                    /* l_band border (global) */\n                    l_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                }\n\n                if (isEncoder) {\n                    /* Skip empty bands */\n                    if (opj_tcd_is_band_empty(l_band)) {\n                        /* Do not zero l_band->precints to avoid leaks */\n                        /* but make sure we don't use it later, since */\n                        /* it will point to precincts of previous bands... */\n                        continue;\n                    }\n                }\n\n                /** avoid an if with storing function pointer */\n                l_gain = (*l_gain_ptr)(l_band->bandno);\n                numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n                l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0,\n                                                  (OPJ_INT32)(numbps - l_step_size->expn)))) * fraction;\n                l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits -\n                                 1;      /* WHY -1 ? */\n\n                if (!l_band->precincts && (l_nb_precincts > 0U)) {\n                    l_band->precincts = (opj_tcd_precinct_t *) opj_malloc(/*3 * */\n                                            l_nb_precinct_size);\n                    if (! l_band->precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        return OPJ_FALSE;\n                    }\n                    /*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n                    memset(l_band->precincts, 0, l_nb_precinct_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                } else if (l_band->precincts_data_size < l_nb_precinct_size) {\n\n                    opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(\n                            l_band->precincts,/*3 * */ l_nb_precinct_size);\n                    if (! new_precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        opj_free(l_band->precincts);\n                        l_band->precincts = NULL;\n                        l_band->precincts_data_size = 0;\n                        return OPJ_FALSE;\n                    }\n                    l_band->precincts = new_precincts;\n                    /*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n                    memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size, 0,\n                           l_nb_precinct_size - l_band->precincts_data_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                }\n\n                l_current_precinct = l_band->precincts;\n                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                    OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n                    OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) *\n                                          (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) *\n                                          (1 << cbgheightexpn);\n                    OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n                    /*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n                    /*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\n                    /* precinct size (global) */\n                    /*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\n                    l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n                    l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n                    l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n                    l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n                    /*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\n                    tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0,\n                                                        (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n                    tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0,\n                                                        (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n                    brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1,\n                                                     (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n                    brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1,\n                                                     (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n                    l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >>\n                                                          cblkwidthexpn);\n                    l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >>\n                                                          cblkheightexpn);\n\n                    l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n                    /*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n                    l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\n                    if (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n                        l_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n                        if (! l_current_precinct->cblks.blocks) {\n                            return OPJ_FALSE;\n                        }\n                        /*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\n                        memset(l_current_precinct->cblks.blocks, 0, l_nb_code_blocks_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    } else if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n                        void *new_blocks = opj_realloc(l_current_precinct->cblks.blocks,\n                                                       l_nb_code_blocks_size);\n                        if (! new_blocks) {\n                            opj_free(l_current_precinct->cblks.blocks);\n                            l_current_precinct->cblks.blocks = NULL;\n                            l_current_precinct->block_size = 0;\n                            opj_event_msg(manager, EVT_ERROR,\n                                          \"Not enough memory for current precinct codeblock element\\n\");\n                            return OPJ_FALSE;\n                        }\n                        l_current_precinct->cblks.blocks = new_blocks;\n                        /*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\n                        memset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) +\n                               l_current_precinct->block_size\n                               , 0\n                               , l_nb_code_blocks_size - l_current_precinct->block_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    }\n\n                    if (! l_current_precinct->incltree) {\n                        l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    if (! l_current_precinct->imsbtree) {\n                        l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n                        OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno %\n                                               l_current_precinct->cw) * (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno /\n                                               l_current_precinct->cw) * (1 << cblkheightexpn);\n                        OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\n                        if (isEncoder) {\n                            opj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\n                            if (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\n                            if (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                        } else {\n                            opj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\n                            if (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n                        }\n                    }\n                    ++l_current_precinct;\n                } /* precno */\n            } /* bandno */\n            ++l_res;\n        } /* resno */\n        ++l_tccp;\n        ++l_tilec;\n        ++l_image_comp;\n    } /* compno */\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n                                  opj_event_mgr_t* p_manager)\n{\n    return opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_TRUE, 1.0F,\n                             sizeof(opj_tcd_cblk_enc_t), p_manager);\n}\n\nOPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n                                  opj_event_mgr_t* p_manager)\n{\n    return opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_FALSE, 0.5F,\n                             sizeof(opj_tcd_cblk_dec_t), p_manager);\n}\n\n/**\n * Allocates memory for an encoding code block (but not data memory).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    if (! p_code_block->layers) {\n        /* no memset since data */\n        p_code_block->layers = (opj_tcd_layer_t*) opj_calloc(100,\n                               sizeof(opj_tcd_layer_t));\n        if (! p_code_block->layers) {\n            return OPJ_FALSE;\n        }\n    }\n    if (! p_code_block->passes) {\n        p_code_block->passes = (opj_tcd_pass_t*) opj_calloc(100,\n                               sizeof(opj_tcd_pass_t));\n        if (! p_code_block->passes) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\n/**\n * Allocates data memory for an encoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                               (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}\n\n/**\n * Allocates memory for a decoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block)\n{\n    if (! p_code_block->data) {\n\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE);\n        if (! p_code_block->data) {\n            return OPJ_FALSE;\n        }\n        p_code_block->data_max_size = OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE;\n        /*fprintf(stderr, \"Allocate 8192 elements of code_block->data\\n\");*/\n\n        p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,\n                             sizeof(opj_tcd_seg_t));\n        if (! p_code_block->segs) {\n            return OPJ_FALSE;\n        }\n        /*fprintf(stderr, \"Allocate %d elements of code_block->data\\n\", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/\n\n        p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n        /*fprintf(stderr, \"m_current_max_segs of code_block->data = %d\\n\", p_code_block->m_current_max_segs);*/\n    } else {\n        /* sanitize */\n        OPJ_BYTE* l_data = p_code_block->data;\n        OPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n        opj_tcd_seg_t * l_segs = p_code_block->segs;\n        OPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n\n        memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n        p_code_block->data = l_data;\n        p_code_block->data_max_size = l_data_max_size;\n        p_code_block->segs = l_segs;\n        p_code_block->m_current_max_segs = l_current_max_segs;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tile_comp = 00;\n    opj_tcd_resolution_t * l_res = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_UINT32 l_temp;\n\n    l_tile_comp = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n        l_temp = (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 -\n                              l_res->y0)); /* x1*y1 can't overflow */\n        if (l_size_comp && UINT_MAX / l_size_comp < l_temp) {\n            return UINT_MAX;\n        }\n        l_temp *= l_size_comp;\n\n        if (l_temp > UINT_MAX - l_data_size) {\n            return UINT_MAX;\n        }\n        l_data_size += l_temp;\n        ++l_img_comp;\n        ++l_tile_comp;\n    }\n\n    return l_data_size;\n}\n\nOPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd,\n                             OPJ_UINT32 p_tile_no,\n                             OPJ_BYTE *p_dest,\n                             OPJ_UINT32 * p_data_written,\n                             OPJ_UINT32 p_max_length,\n                             opj_codestream_info_t *p_cstr_info)\n{\n\n    if (p_tcd->cur_tp_num == 0) {\n\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n        /* INDEX >> \"Precinct_nb_X et Precinct_nb_Y\" */\n        if (p_cstr_info)  {\n            OPJ_UINT32 l_num_packs = 0;\n            OPJ_UINT32 i;\n            opj_tcd_tilecomp_t *l_tilec_idx =\n                &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */\n            opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */\n\n            for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n            }\n            p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((\n                    size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs,\n                                                  sizeof(opj_packet_info_t));\n            if (!p_cstr_info->tile[p_tile_no].packet) {\n                /* FIXME event manager error callback */\n                return OPJ_FALSE;\n            }\n        }\n        /* << INDEX */\n\n        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n        /*---------------TILE-------------------*/\n        if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n        /* FIXME _ProfStart(PGROUP_MCT); */\n        if (! opj_tcd_mct_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_MCT); */\n\n        /* FIXME _ProfStart(PGROUP_DWT); */\n        if (! opj_tcd_dwt_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME  _ProfStop(PGROUP_DWT); */\n\n        /* FIXME  _ProfStart(PGROUP_T1); */\n        if (! opj_tcd_t1_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T1); */\n\n        /* FIXME _ProfStart(PGROUP_RATE); */\n        if (! opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_RATE); */\n\n    }\n    /*--------------TIER2------------------*/\n\n    /* INDEX */\n    if (p_cstr_info) {\n        p_cstr_info->index_write = 1;\n    }\n    /* FIXME _ProfStart(PGROUP_T2); */\n\n    if (! opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length,\n                            p_cstr_info)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_T2); */\n\n    /*---------------CLEAN-------------------*/\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd,\n                             OPJ_BYTE *p_src,\n                             OPJ_UINT32 p_max_length,\n                             OPJ_UINT32 p_tile_no,\n                             opj_codestream_index_t *p_cstr_index,\n                             opj_event_mgr_t *p_manager\n                            )\n{\n    OPJ_UINT32 l_data_read;\n    p_tcd->tcd_tileno = p_tile_no;\n    p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);\n\n#ifdef TODO_MSD /* FIXME */\n    /* INDEX >>  */\n    if (p_cstr_info) {\n        OPJ_UINT32 resno, compno, numprec = 0;\n        for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {\n            opj_tcp_t *tcp = &p_tcd->cp->tcps[0];\n            opj_tccp_t *tccp = &tcp->tccps[compno];\n            opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];\n            for (resno = 0; resno < tilec_idx->numresolutions; resno++) {\n                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];\n                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;\n                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;\n                numprec += res_idx->pw * res_idx->ph;\n                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];\n                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];\n            }\n        }\n        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(\n                p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));\n        p_cstr_info->packno = 0;\n    }\n    /* << INDEX */\n#endif\n\n    /*--------------TIER2------------------*/\n    /* FIXME _ProfStart(PGROUP_T2); */\n    l_data_read = 0;\n    if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index,\n                            p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_T2); */\n\n    /*------------------TIER1-----------------*/\n\n    /* FIXME _ProfStart(PGROUP_T1); */\n    if (! opj_tcd_t1_decode(p_tcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_T1); */\n\n    /*----------------DWT---------------------*/\n\n    /* FIXME _ProfStart(PGROUP_DWT); */\n    if\n    (! opj_tcd_dwt_decode(p_tcd)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_DWT); */\n\n    /*----------------MCT-------------------*/\n    /* FIXME _ProfStart(PGROUP_MCT); */\n    if\n    (! opj_tcd_mct_decode(p_tcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_MCT); */\n\n    /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n    if\n    (! opj_tcd_dc_level_shift_decode(p_tcd)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n\n    /*---------------TILE-------------------*/\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_dest,\n                                  OPJ_UINT32 p_dest_length\n                                 )\n{\n    OPJ_UINT32 i, j, k, l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    opj_tcd_resolution_t * l_res;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_UINT32 l_stride, l_width, l_height;\n\n    l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n    if (l_data_size == UINT_MAX || l_data_size > p_dest_length) {\n        return OPJ_FALSE;\n    }\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n        l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n        l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n        l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n        l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n            const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_CHAR)(*(l_src_ptr++));\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_CHAR)((*(l_src_ptr++)) & 0xff);\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_dest = (OPJ_BYTE *)l_dest_ptr;\n        }\n        break;\n        case 2: {\n            const OPJ_INT32 * l_src_ptr = l_tilec->data;\n            OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        OPJ_INT16 val = (OPJ_INT16)(*(l_src_ptr++));\n                        memcpy(l_dest_ptr, &val, sizeof(val));\n                        l_dest_ptr ++;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        OPJ_INT16 val = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);\n                        memcpy(l_dest_ptr, &val, sizeof(val));\n                        l_dest_ptr ++;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_dest = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n            OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n            for (j = 0; j < l_height; ++j) {\n                memcpy(l_dest_ptr, l_src_ptr, l_width * sizeof(OPJ_INT32));\n                l_dest_ptr += l_width;\n                l_src_ptr += l_width + l_stride;\n            }\n\n            p_dest = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        }\n\n        ++l_img_comp;\n        ++l_tilec;\n    }\n\n    return OPJ_TRUE;\n}\n\n\n\n\nstatic void opj_tcd_free_tile(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno, resno, bandno, precno;\n    opj_tcd_tile_t *l_tile = 00;\n    opj_tcd_tilecomp_t *l_tile_comp = 00;\n    opj_tcd_resolution_t *l_res = 00;\n    opj_tcd_band_t *l_band = 00;\n    opj_tcd_precinct_t *l_precinct = 00;\n    OPJ_UINT32 l_nb_resolutions, l_nb_precincts;\n    void (* l_tcd_code_block_deallocate)(opj_tcd_precinct_t *) = 00;\n\n    if (! p_tcd) {\n        return;\n    }\n\n    if (! p_tcd->tcd_image) {\n        return;\n    }\n\n    if (p_tcd->m_is_decoder) {\n        l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;\n    } else {\n        l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;\n    }\n\n    l_tile = p_tcd->tcd_image->tiles;\n    if (! l_tile) {\n        return;\n    }\n\n    l_tile_comp = l_tile->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        l_res = l_tile_comp->resolutions;\n        if (l_res) {\n\n            l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);\n            for (resno = 0; resno < l_nb_resolutions; ++resno) {\n                l_band = l_res->bands;\n                for (bandno = 0; bandno < 3; ++bandno) {\n                    l_precinct = l_band->precincts;\n                    if (l_precinct) {\n\n                        l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);\n                        for (precno = 0; precno < l_nb_precincts; ++precno) {\n                            opj_tgt_destroy(l_precinct->incltree);\n                            l_precinct->incltree = 00;\n                            opj_tgt_destroy(l_precinct->imsbtree);\n                            l_precinct->imsbtree = 00;\n                            (*l_tcd_code_block_deallocate)(l_precinct);\n                            ++l_precinct;\n                        }\n\n                        opj_free(l_band->precincts);\n                        l_band->precincts = 00;\n                    }\n                    ++l_band;\n                } /* for (resno */\n                ++l_res;\n            }\n\n            opj_free(l_tile_comp->resolutions);\n            l_tile_comp->resolutions = 00;\n        }\n\n        if (l_tile_comp->ownsData && l_tile_comp->data) {\n            opj_aligned_free(l_tile_comp->data);\n            l_tile_comp->data = 00;\n            l_tile_comp->ownsData = 0;\n            l_tile_comp->data_size = 0;\n            l_tile_comp->data_size_needed = 0;\n        }\n        ++l_tile_comp;\n    }\n\n    opj_free(l_tile->comps);\n    l_tile->comps = 00;\n    opj_free(p_tcd->tcd_image->tiles);\n    p_tcd->tcd_image->tiles = 00;\n}\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_src_data,\n                                  OPJ_UINT32 * p_data_read,\n                                  OPJ_UINT32 p_max_src_size,\n                                  opj_codestream_index_t *p_cstr_index,\n                                  opj_event_mgr_t *p_manager\n                                 )\n{\n    opj_t2_t * l_t2;\n\n    l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n    if (l_t2 == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_t2_decode_packets(\n                l_t2,\n                p_tcd->tcd_tileno,\n                p_tcd->tcd_image->tiles,\n                p_src_data,\n                p_data_read,\n                p_max_src_size,\n                p_cstr_index,\n                p_manager)) {\n        opj_t2_destroy(l_t2);\n        return OPJ_FALSE;\n    }\n\n    opj_t2_destroy(l_t2);\n\n    /*---------------CLEAN-------------------*/\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;\n    opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n    volatile OPJ_BOOL ret = OPJ_TRUE;\n    OPJ_BOOL check_pterm = OPJ_FALSE;\n    opj_mutex_t* p_manager_mutex = NULL;\n\n    p_manager_mutex = opj_mutex_create();\n\n    /* Only enable PTERM check if we decode all layers */\n    if (p_tcd->tcp->num_layers_to_decode == p_tcd->tcp->numlayers &&\n            (l_tccp->cblksty & J2K_CCP_CBLKSTY_PTERM) != 0) {\n        check_pterm = OPJ_TRUE;\n    }\n\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        opj_t1_decode_cblks(p_tcd->thread_pool, &ret, l_tile_comp, l_tccp,\n                            p_manager, p_manager_mutex, check_pterm);\n        if (!ret) {\n            break;\n        }\n        ++l_tile_comp;\n        ++l_tccp;\n    }\n\n    opj_thread_pool_wait_completion(p_tcd->thread_pool, 0);\n    if (p_manager_mutex) {\n        opj_mutex_destroy(p_manager_mutex);\n    }\n    return ret;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n    opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n    opj_image_comp_t * l_img_comp = p_tcd->image->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; compno++) {\n        /*\n        if (tcd->cp->reduce != 0) {\n                tcd->image->comps[compno].resno_decoded =\n                        tile->comps[compno].numresolutions - tcd->cp->reduce - 1;\n                if (tcd->image->comps[compno].resno_decoded < 0)\n                {\n                        return false;\n                }\n        }\n        numres2decode = tcd->image->comps[compno].resno_decoded + 1;\n        if(numres2decode > 0){\n        */\n\n        if (l_tccp->qmfbid == 1) {\n            if (! opj_dwt_decode(p_tcd->thread_pool, l_tile_comp,\n                                 l_img_comp->resno_decoded + 1)) {\n                return OPJ_FALSE;\n            }\n        } else {\n            if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded + 1)) {\n                return OPJ_FALSE;\n            }\n        }\n\n        ++l_tile_comp;\n        ++l_img_comp;\n        ++l_tccp;\n    }\n\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager)\n{\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcp_t * l_tcp = p_tcd->tcp;\n    opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n    OPJ_UINT32 l_samples, i;\n\n    if (! l_tcp->mct) {\n        return OPJ_TRUE;\n    }\n\n    l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) *\n                             (l_tile_comp->y1 - l_tile_comp->y0));\n\n    if (l_tile->numcomps >= 3) {\n        /* testcase 1336.pdf.asan.47.376 */\n        if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 -\n                l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||\n                (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 -\n                        l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||\n                (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 -\n                        l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Tiles don't all have the same dimension. Skip the MCT step.\\n\");\n            return OPJ_FALSE;\n        } else if (l_tcp->mct == 2) {\n            OPJ_BYTE ** l_data;\n\n            if (! l_tcp->m_mct_decoding_matrix) {\n                return OPJ_TRUE;\n            }\n\n            l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps * sizeof(OPJ_BYTE*));\n            if (! l_data) {\n                return OPJ_FALSE;\n            }\n\n            for (i = 0; i < l_tile->numcomps; ++i) {\n                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                ++l_tile_comp;\n            }\n\n            if (! opj_mct_decode_custom(/* MCT data */\n                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,\n                        /* size of components */\n                        l_samples,\n                        /* components */\n                        l_data,\n                        /* nb of components (i.e. size of pData) */\n                        l_tile->numcomps,\n                        /* tells if the data is signed */\n                        p_tcd->image->comps->sgnd)) {\n                opj_free(l_data);\n                return OPJ_FALSE;\n            }\n\n            opj_free(l_data);\n        } else {\n            if (l_tcp->tccps->qmfbid == 1) {\n                opj_mct_decode(l_tile->comps[0].data,\n                               l_tile->comps[1].data,\n                               l_tile->comps[2].data,\n                               l_samples);\n            } else {\n                opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,\n                                    (OPJ_FLOAT32*)l_tile->comps[1].data,\n                                    (OPJ_FLOAT32*)l_tile->comps[2].data,\n                                    l_samples);\n            }\n        }\n    } else {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\\n\",\n                      l_tile->numcomps);\n    }\n\n    return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tilecomp_t * l_tile_comp = 00;\n    opj_tccp_t * l_tccp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_resolution_t* l_res = 00;\n    opj_tcd_tile_t * l_tile;\n    OPJ_UINT32 l_width, l_height, i, j;\n    OPJ_INT32 * l_current_ptr;\n    OPJ_INT32 l_min, l_max;\n    OPJ_UINT32 l_stride;\n\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tile_comp = l_tile->comps;\n    l_tccp = p_tcd->tcp->tccps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; compno++) {\n        l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;\n        l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n        l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n        l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;\n\n        assert(l_height == 0 ||\n               l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/\n\n        if (l_img_comp->sgnd) {\n            l_min = -(1 << (l_img_comp->prec - 1));\n            l_max = (1 << (l_img_comp->prec - 1)) - 1;\n        } else {\n            l_min = 0;\n            l_max = (1 << l_img_comp->prec) - 1;\n        }\n\n        l_current_ptr = l_tile_comp->data;\n\n        if (l_tccp->qmfbid == 1) {\n            for (j = 0; j < l_height; ++j) {\n                for (i = 0; i < l_width; ++i) {\n                    *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min,\n                                                   l_max);\n                    ++l_current_ptr;\n                }\n                l_current_ptr += l_stride;\n            }\n        } else {\n            for (j = 0; j < l_height; ++j) {\n                for (i = 0; i < l_width; ++i) {\n                    OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);\n                    OPJ_INT32 l_value_int = (OPJ_INT32)opj_lrintf(l_value);\n                    if (l_value > INT_MAX ||\n                            (l_value_int > 0 && l_tccp->m_dc_level_shift > 0 &&\n                             l_value_int > INT_MAX - l_tccp->m_dc_level_shift)) {\n                        *l_current_ptr = l_max;\n                    } else {\n                        *l_current_ptr = opj_int_clamp(\n                                             l_value_int + l_tccp->m_dc_level_shift, l_min, l_max);\n                    }\n                    ++l_current_ptr;\n                }\n                l_current_ptr += l_stride;\n            }\n        }\n\n        ++l_img_comp;\n        ++l_tccp;\n        ++l_tile_comp;\n    }\n\n    return OPJ_TRUE;\n}\n\n\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t * p_precinct)\n{\n    OPJ_UINT32 cblkno, l_nb_code_blocks;\n\n    opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n    if (l_code_block) {\n        /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n        /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n        /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                        l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n        l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n        /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n            if (l_code_block->data) {\n                opj_free(l_code_block->data);\n                l_code_block->data = 00;\n            }\n\n            if (l_code_block->segs) {\n                opj_free(l_code_block->segs);\n                l_code_block->segs = 00;\n            }\n\n            ++l_code_block;\n        }\n\n        opj_free(p_precinct->cblks.dec);\n        p_precinct->cblks.dec = 00;\n    }\n}\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t * p_precinct)\n{\n    OPJ_UINT32 cblkno, l_nb_code_blocks;\n\n    opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;\n    if (l_code_block) {\n        l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);\n\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {\n            if (l_code_block->data) {\n                /* We refer to data - 1 since below we incremented it */\n                /* in opj_tcd_code_block_enc_allocate_data() */\n                opj_free(l_code_block->data - 1);\n                l_code_block->data = 00;\n            }\n\n            if (l_code_block->layers) {\n                opj_free(l_code_block->layers);\n                l_code_block->layers = 00;\n            }\n\n            if (l_code_block->passes) {\n                opj_free(l_code_block->passes);\n                l_code_block->passes = 00;\n            }\n            ++l_code_block;\n        }\n\n        opj_free(p_precinct->cblks.enc);\n\n        p_precinct->cblks.enc = 00;\n    }\n}\n\nOPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 i, l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) *\n                       (l_tilec->y1 - l_tilec->y0));\n        ++l_img_comp;\n        ++l_tilec;\n    }\n\n    return l_data_size;\n}\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tilecomp_t * l_tile_comp = 00;\n    opj_tccp_t * l_tccp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tile_t * l_tile;\n    OPJ_UINT32 l_nb_elem, i;\n    OPJ_INT32 * l_current_ptr;\n\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tile_comp = l_tile->comps;\n    l_tccp = p_tcd->tcp->tccps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; compno++) {\n        l_current_ptr = l_tile_comp->data;\n        l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) *\n                                 (l_tile_comp->y1 - l_tile_comp->y0));\n\n        if (l_tccp->qmfbid == 1) {\n            for (i = 0; i < l_nb_elem; ++i) {\n                *l_current_ptr -= l_tccp->m_dc_level_shift ;\n                ++l_current_ptr;\n            }\n        } else {\n            for (i = 0; i < l_nb_elem; ++i) {\n                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) * (1 << 11);\n                ++l_current_ptr;\n            }\n        }\n\n        ++l_img_comp;\n        ++l_tccp;\n        ++l_tile_comp;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd)\n{\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n    OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) *\n                                      (l_tile_comp->y1 - l_tile_comp->y0));\n    OPJ_UINT32 i;\n    OPJ_BYTE ** l_data = 00;\n    opj_tcp_t * l_tcp = p_tcd->tcp;\n\n    if (!p_tcd->tcp->mct) {\n        return OPJ_TRUE;\n    }\n\n    if (p_tcd->tcp->mct == 2) {\n        if (! p_tcd->tcp->m_mct_coding_matrix) {\n            return OPJ_TRUE;\n        }\n\n        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps * sizeof(OPJ_BYTE*));\n        if (! l_data) {\n            return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_tile->numcomps; ++i) {\n            l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n            ++l_tile_comp;\n        }\n\n        if (! opj_mct_encode_custom(/* MCT data */\n                    (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,\n                    /* size of components */\n                    samples,\n                    /* components */\n                    l_data,\n                    /* nb of components (i.e. size of pData) */\n                    l_tile->numcomps,\n                    /* tells if the data is signed */\n                    p_tcd->image->comps->sgnd)) {\n            opj_free(l_data);\n            return OPJ_FALSE;\n        }\n\n        opj_free(l_data);\n    } else if (l_tcp->tccps->qmfbid == 0) {\n        opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data,\n                            l_tile->comps[2].data, samples);\n    } else {\n        opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data,\n                       l_tile->comps[2].data, samples);\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd)\n{\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n    opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n    OPJ_UINT32 compno;\n\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        if (l_tccp->qmfbid == 1) {\n            if (! opj_dwt_encode(l_tile_comp)) {\n                return OPJ_FALSE;\n            }\n        } else if (l_tccp->qmfbid == 0) {\n            if (! opj_dwt_encode_real(l_tile_comp)) {\n                return OPJ_FALSE;\n            }\n        }\n\n        ++l_tile_comp;\n        ++l_tccp;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd)\n{\n    opj_t1_t * l_t1;\n    const OPJ_FLOAT64 * l_mct_norms;\n    OPJ_UINT32 l_mct_numcomps = 0U;\n    opj_tcp_t * l_tcp = p_tcd->tcp;\n\n    l_t1 = opj_t1_create(OPJ_TRUE);\n    if (l_t1 == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (l_tcp->mct == 1) {\n        l_mct_numcomps = 3U;\n        /* irreversible encoding */\n        if (l_tcp->tccps->qmfbid == 0) {\n            l_mct_norms = opj_mct_get_mct_norms_real();\n        } else {\n            l_mct_norms = opj_mct_get_mct_norms();\n        }\n    } else {\n        l_mct_numcomps = p_tcd->image->numcomps;\n        l_mct_norms = (const OPJ_FLOAT64 *)(l_tcp->mct_norms);\n    }\n\n    if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles, l_tcp, l_mct_norms,\n                              l_mct_numcomps)) {\n        opj_t1_destroy(l_t1);\n        return OPJ_FALSE;\n    }\n\n    opj_t1_destroy(l_t1);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_dest_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_max_dest_size,\n                                  opj_codestream_info_t *p_cstr_info)\n{\n    opj_t2_t * l_t2;\n\n    l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n    if (l_t2 == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_t2_encode_packets(\n                l_t2,\n                p_tcd->tcd_tileno,\n                p_tcd->tcd_image->tiles,\n                p_tcd->tcp->numlayers,\n                p_dest_data,\n                p_data_written,\n                p_max_dest_size,\n                p_cstr_info,\n                p_tcd->tp_num,\n                p_tcd->tp_pos,\n                p_tcd->cur_pino,\n                FINAL_PASS)) {\n        opj_t2_destroy(l_t2);\n        return OPJ_FALSE;\n    }\n\n    opj_t2_destroy(l_t2);\n\n    /*---------------CLEAN-------------------*/\n    return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd,\n        OPJ_BYTE * p_dest_data,\n        OPJ_UINT32 p_max_dest_size,\n        opj_codestream_info_t *p_cstr_info)\n{\n    opj_cp_t * l_cp = p_tcd->cp;\n    OPJ_UINT32 l_nb_written = 0;\n\n    if (p_cstr_info)  {\n        p_cstr_info->index_write = 0;\n    }\n\n    if (l_cp->m_specific_param.m_enc.m_disto_alloc ||\n            l_cp->m_specific_param.m_enc.m_fixed_quality)  {\n        /* fixed_quality */\n        /* Normal Rate/distortion allocation */\n        if (! opj_tcd_rateallocate(p_tcd, p_dest_data, &l_nb_written, p_max_dest_size,\n                                   p_cstr_info)) {\n            return OPJ_FALSE;\n        }\n    } else {\n        /* Fixed layer allocation */\n        opj_tcd_rateallocate_fixed(p_tcd);\n    }\n\n    return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd,\n                                OPJ_BYTE * p_src,\n                                OPJ_UINT32 p_src_length)\n{\n    OPJ_UINT32 i, j, l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_UINT32 l_nb_elem;\n\n    l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);\n    if (l_data_size != p_src_length) {\n        return OPJ_FALSE;\n    }\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n        l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 -\n                                 l_tilec->y0));\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;\n            OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (OPJ_INT32)(*(l_src_ptr++));\n                }\n            } else {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (*(l_src_ptr++)) & 0xff;\n                }\n            }\n\n            p_src = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        case 2: {\n            OPJ_INT32 * l_dest_ptr = l_tilec->data;\n            OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (OPJ_INT32)(*(l_src_ptr++));\n                }\n            } else {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (*(l_src_ptr++)) & 0xffff;\n                }\n            }\n\n            p_src = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;\n            OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n            for (j = 0; j < l_nb_elem; ++j) {\n                *(l_dest_ptr++) = (OPJ_INT32)(*(l_src_ptr++));\n            }\n\n            p_src = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        }\n\n        ++l_img_comp;\n        ++l_tilec;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t* band)\n{\n    return (band->x1 - band->x0 == 0) || (band->y1 - band->y0 == 0);\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR\n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n#include \"opj_common.h\"\n\n/* ----------------------------------------------------------------------- */\n\n/* TODO MSD: */\n#ifdef TODO_MSD\nvoid tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img)\n{\n    int tileno, compno, resno, bandno, precno;/*, cblkno;*/\n\n    fprintf(fd, \"image {\\n\");\n    fprintf(fd, \"  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\\n\",\n            img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0,\n            tcd->image->y1);\n\n    for (tileno = 0; tileno < img->th * img->tw; tileno++) {\n        opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];\n        fprintf(fd, \"  tile {\\n\");\n        fprintf(fd, \"    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\\n\",\n                tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);\n        for (compno = 0; compno < tile->numcomps; compno++) {\n            opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n            fprintf(fd, \"    tilec {\\n\");\n            fprintf(fd,\n                    \"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\\n\",\n                    tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);\n            for (resno = 0; resno < tilec->numresolutions; resno++) {\n                opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n                fprintf(fd, \"\\n   res {\\n\");\n                fprintf(fd,\n                        \"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\\n\",\n                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);\n                for (bandno = 0; bandno < res->numbands; bandno++) {\n                    opj_tcd_band_t *band = &res->bands[bandno];\n                    fprintf(fd, \"        band {\\n\");\n                    fprintf(fd,\n                            \"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\\n\",\n                            band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);\n                    for (precno = 0; precno < res->pw * res->ph; precno++) {\n                        opj_tcd_precinct_t *prec = &band->precincts[precno];\n                        fprintf(fd, \"          prec {\\n\");\n                        fprintf(fd,\n                                \"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\\n\",\n                                prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);\n                        /*\n                        for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {\n                                opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];\n                                fprintf(fd, \"            cblk {\\n\");\n                                fprintf(fd,\n                                        \"              x0=%d, y0=%d, x1=%d, y1=%d\\n\",\n                                        cblk->x0, cblk->y0, cblk->x1, cblk->y1);\n                                fprintf(fd, \"            }\\n\");\n                        }\n                        */\n                        fprintf(fd, \"          }\\n\");\n                    }\n                    fprintf(fd, \"        }\\n\");\n                }\n                fprintf(fd, \"      }\\n\");\n            }\n            fprintf(fd, \"    }\\n\");\n        }\n        fprintf(fd, \"  }\\n\");\n    }\n    fprintf(fd, \"}\\n\");\n}\n#endif\n\n/**\n * Initializes tile coding/decoding\n */\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,\n        opj_event_mgr_t* manager);\n\n/**\n* Allocates memory for a decoding code block.\n*/\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block);\n\n/**\n * Deallocates the decoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t * p_precinct);\n\n/**\n * Allocates memory for an encoding code block (but not data).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *\n        p_code_block);\n\n/**\n * Allocates data for an encoding code block\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block);\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t * p_precinct);\n\n\n/**\nFree the memory allocated for encoding\n@param tcd TCD handle\n*/\nstatic void opj_tcd_free_tile(opj_tcd_t *tcd);\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_src_data,\n                                  OPJ_UINT32 * p_data_read,\n                                  OPJ_UINT32 p_max_src_size,\n                                  opj_codestream_index_t *p_cstr_index,\n                                  opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd,\n                                  opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd,\n                                   opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd);\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_dest_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_max_dest_size,\n                                  opj_codestream_info_t *p_cstr_info);\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd,\n        OPJ_BYTE * p_dest_data,\n        OPJ_UINT32 p_max_dest_size,\n        opj_codestream_info_t *p_cstr_info);\n\n/* ----------------------------------------------------------------------- */\n\n/**\nCreate a new TCD handle\n*/\nopj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)\n{\n    opj_tcd_t *l_tcd = 00;\n\n    /* create the tcd structure */\n    l_tcd = (opj_tcd_t*) opj_calloc(1, sizeof(opj_tcd_t));\n    if (!l_tcd) {\n        return 00;\n    }\n\n    l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;\n\n    l_tcd->tcd_image = (opj_tcd_image_t*)opj_calloc(1, sizeof(opj_tcd_image_t));\n    if (!l_tcd->tcd_image) {\n        opj_free(l_tcd);\n        return 00;\n    }\n\n    return l_tcd;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\nvoid opj_tcd_rateallocate_fixed(opj_tcd_t *tcd)\n{\n    OPJ_UINT32 layno;\n\n    for (layno = 0; layno < tcd->tcp->numlayers; layno++) {\n        opj_tcd_makelayer_fixed(tcd, layno, 1);\n    }\n}\n\n\nvoid opj_tcd_makelayer(opj_tcd_t *tcd,\n                       OPJ_UINT32 layno,\n                       OPJ_FLOAT64 thresh,\n                       OPJ_UINT32 final)\n{\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    OPJ_UINT32 passno;\n\n    opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n\n    tcd_tile->distolayer[layno] = 0;        /* fixed_quality */\n\n    for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n        opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n        for (resno = 0; resno < tilec->numresolutions; resno++) {\n            opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n            for (bandno = 0; bandno < res->numbands; bandno++) {\n                opj_tcd_band_t *band = &res->bands[bandno];\n\n                /* Skip empty bands */\n                if (opj_tcd_is_band_empty(band)) {\n                    continue;\n                }\n\n                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                    opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                    for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                        opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                        opj_tcd_layer_t *layer = &cblk->layers[layno];\n                        OPJ_UINT32 n;\n\n                        if (layno == 0) {\n                            cblk->numpassesinlayers = 0;\n                        }\n\n                        n = cblk->numpassesinlayers;\n\n                        for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {\n                            OPJ_UINT32 dr;\n                            OPJ_FLOAT64 dd;\n                            opj_tcd_pass_t *pass = &cblk->passes[passno];\n\n                            if (n == 0) {\n                                dr = pass->rate;\n                                dd = pass->distortiondec;\n                            } else {\n                                dr = pass->rate - cblk->passes[n - 1].rate;\n                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;\n                            }\n\n                            if (!dr) {\n                                if (dd != 0) {\n                                    n = passno + 1;\n                                }\n                                continue;\n                            }\n                            if (thresh - (dd / dr) <\n                                    DBL_EPSILON) { /* do not rely on float equality, check with DBL_EPSILON margin */\n                                n = passno + 1;\n                            }\n                        }\n\n                        layer->numpasses = n - cblk->numpassesinlayers;\n\n                        if (!layer->numpasses) {\n                            layer->disto = 0;\n                            continue;\n                        }\n\n                        if (cblk->numpassesinlayers == 0) {\n                            layer->len = cblk->passes[n - 1].rate;\n                            layer->data = cblk->data;\n                            layer->disto = cblk->passes[n - 1].distortiondec;\n                        } else {\n                            layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers -\n                                         1].rate;\n                            layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                            layer->disto = cblk->passes[n - 1].distortiondec -\n                                           cblk->passes[cblk->numpassesinlayers - 1].distortiondec;\n                        }\n\n                        tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */\n\n                        if (final) {\n                            cblk->numpassesinlayers = n;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno,\n                             OPJ_UINT32 final)\n{\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */\n    OPJ_INT32 matrice[10][10][3];\n    OPJ_UINT32 i, j, k;\n\n    opj_cp_t *cp = tcd->cp;\n    opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n    opj_tcp_t *tcd_tcp = tcd->tcp;\n\n    for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n        opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n        for (i = 0; i < tcd_tcp->numlayers; i++) {\n            for (j = 0; j < tilec->numresolutions; j++) {\n                for (k = 0; k < 3; k++) {\n                    matrice[i][j][k] =\n                        (OPJ_INT32)((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i *\n                                      tilec->numresolutions * 3 + j * 3 + k]\n                                    * (OPJ_FLOAT32)(tcd->image->comps[compno].prec / 16.0));\n                }\n            }\n        }\n\n        for (resno = 0; resno < tilec->numresolutions; resno++) {\n            opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n            for (bandno = 0; bandno < res->numbands; bandno++) {\n                opj_tcd_band_t *band = &res->bands[bandno];\n\n                /* Skip empty bands */\n                if (opj_tcd_is_band_empty(band)) {\n                    continue;\n                }\n\n                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                    opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                    for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                        opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                        opj_tcd_layer_t *layer = &cblk->layers[layno];\n                        OPJ_UINT32 n;\n                        OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec -\n                                                     cblk->numbps); /* number of bit-plan equal to zero */\n\n                        /* Correction of the matrix of coefficient to include the IMSB information */\n                        if (layno == 0) {\n                            value = matrice[layno][resno][bandno];\n                            if (imsb >= value) {\n                                value = 0;\n                            } else {\n                                value -= imsb;\n                            }\n                        } else {\n                            value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];\n                            if (imsb >= matrice[layno - 1][resno][bandno]) {\n                                value -= (imsb - matrice[layno - 1][resno][bandno]);\n                                if (value < 0) {\n                                    value = 0;\n                                }\n                            }\n                        }\n\n                        if (layno == 0) {\n                            cblk->numpassesinlayers = 0;\n                        }\n\n                        n = cblk->numpassesinlayers;\n                        if (cblk->numpassesinlayers == 0) {\n                            if (value != 0) {\n                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;\n                            } else {\n                                n = cblk->numpassesinlayers;\n                            }\n                        } else {\n                            n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;\n                        }\n\n                        layer->numpasses = n - cblk->numpassesinlayers;\n\n                        if (!layer->numpasses) {\n                            continue;\n                        }\n\n                        if (cblk->numpassesinlayers == 0) {\n                            layer->len = cblk->passes[n - 1].rate;\n                            layer->data = cblk->data;\n                        } else {\n                            layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers -\n                                         1].rate;\n                            layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                        }\n\n                        if (final) {\n                            cblk->numpassesinlayers = n;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nOPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd,\n                              OPJ_BYTE *dest,\n                              OPJ_UINT32 * p_data_written,\n                              OPJ_UINT32 len,\n                              opj_codestream_info_t *cstr_info)\n{\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;\n    OPJ_UINT32 passno;\n    OPJ_FLOAT64 min, max;\n    OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */\n    const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */\n    OPJ_FLOAT64 maxSE = 0;\n\n    opj_cp_t *cp = tcd->cp;\n    opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n    opj_tcp_t *tcd_tcp = tcd->tcp;\n\n    min = DBL_MAX;\n    max = 0;\n\n    tcd_tile->numpix = 0;           /* fixed_quality */\n\n    for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n        opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n        tilec->numpix = 0;\n\n        for (resno = 0; resno < tilec->numresolutions; resno++) {\n            opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n            for (bandno = 0; bandno < res->numbands; bandno++) {\n                opj_tcd_band_t *band = &res->bands[bandno];\n\n                /* Skip empty bands */\n                if (opj_tcd_is_band_empty(band)) {\n                    continue;\n                }\n\n                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                    opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                    for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                        opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n\n                        for (passno = 0; passno < cblk->totalpasses; passno++) {\n                            opj_tcd_pass_t *pass = &cblk->passes[passno];\n                            OPJ_INT32 dr;\n                            OPJ_FLOAT64 dd, rdslope;\n\n                            if (passno == 0) {\n                                dr = (OPJ_INT32)pass->rate;\n                                dd = pass->distortiondec;\n                            } else {\n                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);\n                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;\n                            }\n\n                            if (dr == 0) {\n                                continue;\n                            }\n\n                            rdslope = dd / dr;\n                            if (rdslope < min) {\n                                min = rdslope;\n                            }\n\n                            if (rdslope > max) {\n                                max = rdslope;\n                            }\n                        } /* passno */\n\n                        /* fixed_quality */\n                        tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                        tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                    } /* cbklno */\n                } /* precno */\n            } /* bandno */\n        } /* resno */\n\n        maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)\n                  * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0))\n                 * ((OPJ_FLOAT64)(tilec->numpix));\n    } /* compno */\n\n    /* index file */\n    if (cstr_info) {\n        opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];\n        tile_info->numpix = tcd_tile->numpix;\n        tile_info->distotile = tcd_tile->distotile;\n        tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(\n                                OPJ_FLOAT64));\n        if (!tile_info->thresh) {\n            /* FIXME event manager error callback */\n            return OPJ_FALSE;\n        }\n    }\n\n    for (layno = 0; layno < tcd_tcp->numlayers; layno++) {\n        OPJ_FLOAT64 lo = min;\n        OPJ_FLOAT64 hi = max;\n        OPJ_UINT32 maxlen = tcd_tcp->rates[layno] > 0.0f ? opj_uint_min(((\n                                OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;\n        OPJ_FLOAT64 goodthresh = 0;\n        OPJ_FLOAT64 stable_thresh = 0;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 distotarget;                /* fixed_quality */\n\n        /* fixed_quality */\n        distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10,\n                                             tcd_tcp->distoratio[layno] / 10));\n\n        /* Don't try to find an optimal threshold but rather take everything not included yet, if\n          -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)\n          -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)\n          ==> possible to have some lossy layers and the last layer for sure lossless */\n        if (((cp->m_specific_param.m_enc.m_disto_alloc == 1) &&\n                (tcd_tcp->rates[layno] > 0.0f)) ||\n                ((cp->m_specific_param.m_enc.m_fixed_quality == 1) &&\n                 (tcd_tcp->distoratio[layno] > 0.0))) {\n            opj_t2_t*t2 = opj_t2_create(tcd->image, cp);\n            OPJ_FLOAT64 thresh = 0;\n\n            if (t2 == 00) {\n                return OPJ_FALSE;\n            }\n\n            for (i = 0; i < 128; ++i) {\n                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */\n\n                thresh = (lo + hi) / 2;\n\n                opj_tcd_makelayer(tcd, layno, thresh, 0);\n\n                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */\n                    if (OPJ_IS_CINEMA(cp->rsiz)) {\n                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,\n                                                    p_data_written, maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,\n                                                    THRESH_CALC)) {\n\n                            lo = thresh;\n                            continue;\n                        } else {\n                            distoachieved = layno == 0 ?\n                                            tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];\n\n                            if (distoachieved < distotarget) {\n                                hi = thresh;\n                                stable_thresh = thresh;\n                                continue;\n                            } else {\n                                lo = thresh;\n                            }\n                        }\n                    } else {\n                        distoachieved = (layno == 0) ?\n                                        tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n\n                        if (distoachieved < distotarget) {\n                            hi = thresh;\n                            stable_thresh = thresh;\n                            continue;\n                        }\n                        lo = thresh;\n                    }\n                } else {\n                    if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,\n                                                p_data_written, maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,\n                                                THRESH_CALC)) {\n                        /* TODO: what to do with l ??? seek / tell ??? */\n                        /* opj_event_msg(tcd->cinfo, EVT_INFO, \"rate alloc: len=%d, max=%d\\n\", l, maxlen); */\n                        lo = thresh;\n                        continue;\n                    }\n\n                    hi = thresh;\n                    stable_thresh = thresh;\n                }\n            }\n\n            goodthresh = stable_thresh == 0 ? thresh : stable_thresh;\n\n            opj_t2_destroy(t2);\n        } else {\n            goodthresh = min;\n        }\n\n        if (cstr_info) { /* Threshold for Marcela Index */\n            cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;\n        }\n\n        opj_tcd_makelayer(tcd, layno, goodthresh, 1);\n\n        /* fixed_quality */\n        cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] :\n                          (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd,\n                      opj_image_t * p_image,\n                      opj_cp_t * p_cp,\n                      opj_thread_pool_t* p_tp)\n{\n    p_tcd->image = p_image;\n    p_tcd->cp = p_cp;\n\n    p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,\n                              sizeof(opj_tcd_tile_t));\n    if (! p_tcd->tcd_image->tiles) {\n        return OPJ_FALSE;\n    }\n\n    p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(\n                                         p_image->numcomps, sizeof(opj_tcd_tilecomp_t));\n    if (! p_tcd->tcd_image->tiles->comps) {\n        return OPJ_FALSE;\n    }\n\n    p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n    p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n    p_tcd->thread_pool = p_tp;\n\n    return OPJ_TRUE;\n}\n\n/**\nDestroy a previously created TCD handle\n*/\nvoid opj_tcd_destroy(opj_tcd_t *tcd)\n{\n    if (tcd) {\n        opj_tcd_free_tile(tcd);\n\n        if (tcd->tcd_image) {\n            opj_free(tcd->tcd_image);\n            tcd->tcd_image = 00;\n        }\n        opj_free(tcd);\n    }\n}\n\nOPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)\n{\n    if ((l_tilec->data == 00) ||\n            ((l_tilec->data_size_needed > l_tilec->data_size) &&\n             (l_tilec->ownsData == OPJ_FALSE))) {\n        l_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n        if (! l_tilec->data) {\n            return OPJ_FALSE;\n        }\n        /*fprintf(stderr, \"tAllocate data of tilec (int): %d x OPJ_UINT32n\",l_data_size);*/\n        l_tilec->data_size = l_tilec->data_size_needed;\n        l_tilec->ownsData = OPJ_TRUE;\n    } else if (l_tilec->data_size_needed > l_tilec->data_size) {\n        /* We don't need to keep old data */\n        opj_aligned_free(l_tilec->data);\n        l_tilec->data = (OPJ_INT32 *) opj_aligned_malloc(l_tilec->data_size_needed);\n        if (! l_tilec->data) {\n            l_tilec->data_size = 0;\n            l_tilec->data_size_needed = 0;\n            l_tilec->ownsData = OPJ_FALSE;\n            return OPJ_FALSE;\n        }\n        /*fprintf(stderr, \"tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n\", l_tilec->data_size, l_data_size);*/\n        l_tilec->data_size = l_tilec->data_size_needed;\n        l_tilec->ownsData = OPJ_TRUE;\n    }\n    return OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,\n        opj_event_mgr_t* manager)\n{\n    OPJ_UINT32(*l_gain_ptr)(OPJ_UINT32) = 00;\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    opj_tcp_t * l_tcp = 00;\n    opj_cp_t * l_cp = 00;\n    opj_tcd_tile_t * l_tile = 00;\n    opj_tccp_t *l_tccp = 00;\n    opj_tcd_tilecomp_t *l_tilec = 00;\n    opj_image_comp_t * l_image_comp = 00;\n    opj_tcd_resolution_t *l_res = 00;\n    opj_tcd_band_t *l_band = 00;\n    opj_stepsize_t * l_step_size = 00;\n    opj_tcd_precinct_t *l_current_precinct = 00;\n    opj_image_t *l_image = 00;\n    OPJ_UINT32 p, q;\n    OPJ_UINT32 l_level_no;\n    OPJ_UINT32 l_pdx, l_pdy;\n    OPJ_UINT32 l_gain;\n    OPJ_INT32 l_x0b, l_y0b;\n    OPJ_UINT32 l_tx0, l_ty0;\n    /* extent of precincts , top left, bottom right**/\n    OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n    /* number of precinct for a resolution */\n    OPJ_UINT32 l_nb_precincts;\n    /* room needed to store l_nb_precinct precinct for a resolution */\n    OPJ_UINT32 l_nb_precinct_size;\n    /* number of code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks;\n    /* room needed to store l_nb_code_blocks code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks_size;\n    /* size of data for a tile */\n    OPJ_UINT32 l_data_size;\n\n    l_cp = p_tcd->cp;\n    l_tcp = &(l_cp->tcps[p_tile_no]);\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tccp = l_tcp->tccps;\n    l_tilec = l_tile->comps;\n    l_image = p_tcd->image;\n    l_image_comp = p_tcd->image->comps;\n\n    p = p_tile_no % l_cp->tw;       /* tile coordinates */\n    q = p_tile_no / l_cp->tw;\n    /*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\n    /* 4 borders of the tile rescale on the image if necessary */\n    l_tx0 = l_cp->tx0 + p *\n            l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n    l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n    l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx),\n                                         l_image->x1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile X coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n    l_ty0 = l_cp->ty0 + q *\n            l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n    l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n    l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy),\n                                         l_image->y1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile Y coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n\n\n    /* testcase 1888.pdf.asan.35.988 */\n    if (l_tccp->numresolutions == 0) {\n        opj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n        return OPJ_FALSE;\n    }\n    /*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\n    /*tile->numcomps = image->numcomps; */\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        /*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n        l_image_comp->resno_decoded = 0;\n        /* border of each l_tile component (global) */\n        l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n        l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n        /*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\n        /* compute l_data_size with overflow check */\n        l_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n        /* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */\n        if ((l_data_size > 0U) &&\n                ((((OPJ_UINT32) - 1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 -\n                        l_tilec->y0))) {\n            opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n            return OPJ_FALSE;\n        }\n        l_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\n        if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n            opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n            return OPJ_FALSE;\n        }\n        l_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n        l_tilec->numresolutions = l_tccp->numresolutions;\n        if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n            l_tilec->minimum_num_resolutions = 1;\n        } else {\n            l_tilec->minimum_num_resolutions = l_tccp->numresolutions -\n                                               l_cp->m_specific_param.m_dec.m_reduce;\n        }\n\n        l_tilec->data_size_needed = l_data_size;\n        if (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n            opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n            return OPJ_FALSE;\n        }\n\n        l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(\n                          opj_tcd_resolution_t);\n\n        if (l_tilec->resolutions == 00) {\n            l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n            if (! l_tilec->resolutions) {\n                return OPJ_FALSE;\n            }\n            /*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n            l_tilec->resolutions_size = l_data_size;\n            memset(l_tilec->resolutions, 0, l_data_size);\n        } else if (l_data_size > l_tilec->resolutions_size) {\n            opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(\n                    l_tilec->resolutions, l_data_size);\n            if (! new_resolutions) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n                opj_free(l_tilec->resolutions);\n                l_tilec->resolutions = NULL;\n                l_tilec->resolutions_size = 0;\n                return OPJ_FALSE;\n            }\n            l_tilec->resolutions = new_resolutions;\n            /*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n            memset(((OPJ_BYTE*) l_tilec->resolutions) + l_tilec->resolutions_size, 0,\n                   l_data_size - l_tilec->resolutions_size);\n            l_tilec->resolutions_size = l_data_size;\n        }\n\n        l_level_no = l_tilec->numresolutions;\n        l_res = l_tilec->resolutions;\n        l_step_size = l_tccp->stepsizes;\n        if (l_tccp->qmfbid == 0) {\n            l_gain_ptr = &opj_dwt_getgain_real;\n        } else {\n            l_gain_ptr  = &opj_dwt_getgain;\n        }\n        /*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\n        for (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n            /*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n            OPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n            OPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n            OPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\n            --l_level_no;\n\n            /* border for each resolution level (global) */\n            l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n            l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n            l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n            l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n            /*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n            /* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n            /*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n            /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n            l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n            /*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\n            l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n            l_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n            /*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\n            if ((l_res->pw != 0U) && ((((OPJ_UINT32) - 1) / l_res->pw) < l_res->ph)) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precincts = l_res->pw * l_res->ph;\n\n            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <\n                    l_nb_precincts) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile data\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n            if (resno == 0) {\n                tlcbgxstart = l_tl_prc_x_start;\n                tlcbgystart = l_tl_prc_y_start;\n                /*brcbgxend = l_br_prc_x_end;*/\n                /* brcbgyend = l_br_prc_y_end;*/\n                cbgwidthexpn = l_pdx;\n                cbgheightexpn = l_pdy;\n                l_res->numbands = 1;\n            } else {\n                tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n                tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n                /*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n                /*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n                cbgwidthexpn = l_pdx - 1;\n                cbgheightexpn = l_pdy - 1;\n                l_res->numbands = 3;\n            }\n\n            cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n            cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n            l_band = l_res->bands;\n\n            for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band, ++l_step_size) {\n                OPJ_INT32 numbps;\n                /*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\n                if (resno == 0) {\n                    l_band->bandno = 0 ;\n                    l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n                    l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n                    l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n                    l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n                } else {\n                    l_band->bandno = bandno + 1;\n                    /* x0b = 1 if bandno = 1 or 3 */\n                    l_x0b = l_band->bandno & 1;\n                    /* y0b = 1 if bandno = 2 or 3 */\n                    l_y0b = (OPJ_INT32)((l_band->bandno) >> 1);\n                    /* l_band border (global) */\n                    l_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                }\n\n                if (isEncoder) {\n                    /* Skip empty bands */\n                    if (opj_tcd_is_band_empty(l_band)) {\n                        /* Do not zero l_band->precints to avoid leaks */\n                        /* but make sure we don't use it later, since */\n                        /* it will point to precincts of previous bands... */\n                        continue;\n                    }\n                }\n\n                /** avoid an if with storing function pointer */\n                l_gain = (*l_gain_ptr)(l_band->bandno);\n                numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n                l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0,\n                                                  (OPJ_INT32)(numbps - l_step_size->expn)))) * fraction;\n                l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits -\n                                 1;      /* WHY -1 ? */\n\n                if (!l_band->precincts && (l_nb_precincts > 0U)) {\n                    l_band->precincts = (opj_tcd_precinct_t *) opj_malloc(/*3 * */\n                                            l_nb_precinct_size);\n                    if (! l_band->precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        return OPJ_FALSE;\n                    }\n                    /*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n                    memset(l_band->precincts, 0, l_nb_precinct_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                } else if (l_band->precincts_data_size < l_nb_precinct_size) {\n\n                    opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(\n                            l_band->precincts,/*3 * */ l_nb_precinct_size);\n                    if (! new_precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        opj_free(l_band->precincts);\n                        l_band->precincts = NULL;\n                        l_band->precincts_data_size = 0;\n                        return OPJ_FALSE;\n                    }\n                    l_band->precincts = new_precincts;\n                    /*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n                    memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size, 0,\n                           l_nb_precinct_size - l_band->precincts_data_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                }\n\n                l_current_precinct = l_band->precincts;\n                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                    OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n                    OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) *\n                                          (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) *\n                                          (1 << cbgheightexpn);\n                    OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n                    /*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n                    /*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\n                    /* precinct size (global) */\n                    /*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\n                    l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n                    l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n                    l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n                    l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n                    /*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\n                    tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0,\n                                                        (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n                    tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0,\n                                                        (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n                    brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1,\n                                                     (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n                    brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1,\n                                                     (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n                    l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >>\n                                                          cblkwidthexpn);\n                    l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >>\n                                                          cblkheightexpn);\n\n                    l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n                    /*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n                    l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\n                    if (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n                        l_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n                        if (! l_current_precinct->cblks.blocks) {\n                            return OPJ_FALSE;\n                        }\n                        /*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\n                        memset(l_current_precinct->cblks.blocks, 0, l_nb_code_blocks_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    } else if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n                        void *new_blocks = opj_realloc(l_current_precinct->cblks.blocks,\n                                                       l_nb_code_blocks_size);\n                        if (! new_blocks) {\n                            opj_free(l_current_precinct->cblks.blocks);\n                            l_current_precinct->cblks.blocks = NULL;\n                            l_current_precinct->block_size = 0;\n                            opj_event_msg(manager, EVT_ERROR,\n                                          \"Not enough memory for current precinct codeblock element\\n\");\n                            return OPJ_FALSE;\n                        }\n                        l_current_precinct->cblks.blocks = new_blocks;\n                        /*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\n                        memset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) +\n                               l_current_precinct->block_size\n                               , 0\n                               , l_nb_code_blocks_size - l_current_precinct->block_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    }\n\n                    if (! l_current_precinct->incltree) {\n                        l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    if (! l_current_precinct->imsbtree) {\n                        l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n                        OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno %\n                                               l_current_precinct->cw) * (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno /\n                                               l_current_precinct->cw) * (1 << cblkheightexpn);\n                        OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\n                        if (isEncoder) {\n                            opj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\n                            if (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\n                            if (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                        } else {\n                            opj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\n                            if (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n                        }\n                    }\n                    ++l_current_precinct;\n                } /* precno */\n            } /* bandno */\n            ++l_res;\n        } /* resno */\n        ++l_tccp;\n        ++l_tilec;\n        ++l_image_comp;\n    } /* compno */\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n                                  opj_event_mgr_t* p_manager)\n{\n    return opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_TRUE, 1.0F,\n                             sizeof(opj_tcd_cblk_enc_t), p_manager);\n}\n\nOPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n                                  opj_event_mgr_t* p_manager)\n{\n    return opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_FALSE, 0.5F,\n                             sizeof(opj_tcd_cblk_dec_t), p_manager);\n}\n\n/**\n * Allocates memory for an encoding code block (but not data memory).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    if (! p_code_block->layers) {\n        /* no memset since data */\n        p_code_block->layers = (opj_tcd_layer_t*) opj_calloc(100,\n                               sizeof(opj_tcd_layer_t));\n        if (! p_code_block->layers) {\n            return OPJ_FALSE;\n        }\n    }\n    if (! p_code_block->passes) {\n        p_code_block->passes = (opj_tcd_pass_t*) opj_calloc(100,\n                               sizeof(opj_tcd_pass_t));\n        if (! p_code_block->passes) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\n/**\n * Allocates data memory for an encoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    /* The +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}\n\n/**\n * Allocates memory for a decoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block)\n{\n    if (! p_code_block->data) {\n\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE);\n        if (! p_code_block->data) {\n            return OPJ_FALSE;\n        }\n        p_code_block->data_max_size = OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE;\n        /*fprintf(stderr, \"Allocate 8192 elements of code_block->data\\n\");*/\n\n        p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,\n                             sizeof(opj_tcd_seg_t));\n        if (! p_code_block->segs) {\n            return OPJ_FALSE;\n        }\n        /*fprintf(stderr, \"Allocate %d elements of code_block->data\\n\", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/\n\n        p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n        /*fprintf(stderr, \"m_current_max_segs of code_block->data = %d\\n\", p_code_block->m_current_max_segs);*/\n    } else {\n        /* sanitize */\n        OPJ_BYTE* l_data = p_code_block->data;\n        OPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n        opj_tcd_seg_t * l_segs = p_code_block->segs;\n        OPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n\n        memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n        p_code_block->data = l_data;\n        p_code_block->data_max_size = l_data_max_size;\n        p_code_block->segs = l_segs;\n        p_code_block->m_current_max_segs = l_current_max_segs;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 i;\n    OPJ_UINT32 l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tile_comp = 00;\n    opj_tcd_resolution_t * l_res = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_UINT32 l_temp;\n\n    l_tile_comp = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n        l_temp = (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 -\n                              l_res->y0)); /* x1*y1 can't overflow */\n        if (l_size_comp && UINT_MAX / l_size_comp < l_temp) {\n            return UINT_MAX;\n        }\n        l_temp *= l_size_comp;\n\n        if (l_temp > UINT_MAX - l_data_size) {\n            return UINT_MAX;\n        }\n        l_data_size += l_temp;\n        ++l_img_comp;\n        ++l_tile_comp;\n    }\n\n    return l_data_size;\n}\n\nOPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd,\n                             OPJ_UINT32 p_tile_no,\n                             OPJ_BYTE *p_dest,\n                             OPJ_UINT32 * p_data_written,\n                             OPJ_UINT32 p_max_length,\n                             opj_codestream_info_t *p_cstr_info)\n{\n\n    if (p_tcd->cur_tp_num == 0) {\n\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n        /* INDEX >> \"Precinct_nb_X et Precinct_nb_Y\" */\n        if (p_cstr_info)  {\n            OPJ_UINT32 l_num_packs = 0;\n            OPJ_UINT32 i;\n            opj_tcd_tilecomp_t *l_tilec_idx =\n                &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */\n            opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */\n\n            for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n            }\n            p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((\n                    size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs,\n                                                  sizeof(opj_packet_info_t));\n            if (!p_cstr_info->tile[p_tile_no].packet) {\n                /* FIXME event manager error callback */\n                return OPJ_FALSE;\n            }\n        }\n        /* << INDEX */\n\n        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n        /*---------------TILE-------------------*/\n        if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n        /* FIXME _ProfStart(PGROUP_MCT); */\n        if (! opj_tcd_mct_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_MCT); */\n\n        /* FIXME _ProfStart(PGROUP_DWT); */\n        if (! opj_tcd_dwt_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME  _ProfStop(PGROUP_DWT); */\n\n        /* FIXME  _ProfStart(PGROUP_T1); */\n        if (! opj_tcd_t1_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T1); */\n\n        /* FIXME _ProfStart(PGROUP_RATE); */\n        if (! opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info)) {\n            return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_RATE); */\n\n    }\n    /*--------------TIER2------------------*/\n\n    /* INDEX */\n    if (p_cstr_info) {\n        p_cstr_info->index_write = 1;\n    }\n    /* FIXME _ProfStart(PGROUP_T2); */\n\n    if (! opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length,\n                            p_cstr_info)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_T2); */\n\n    /*---------------CLEAN-------------------*/\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd,\n                             OPJ_BYTE *p_src,\n                             OPJ_UINT32 p_max_length,\n                             OPJ_UINT32 p_tile_no,\n                             opj_codestream_index_t *p_cstr_index,\n                             opj_event_mgr_t *p_manager\n                            )\n{\n    OPJ_UINT32 l_data_read;\n    p_tcd->tcd_tileno = p_tile_no;\n    p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);\n\n#ifdef TODO_MSD /* FIXME */\n    /* INDEX >>  */\n    if (p_cstr_info) {\n        OPJ_UINT32 resno, compno, numprec = 0;\n        for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {\n            opj_tcp_t *tcp = &p_tcd->cp->tcps[0];\n            opj_tccp_t *tccp = &tcp->tccps[compno];\n            opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];\n            for (resno = 0; resno < tilec_idx->numresolutions; resno++) {\n                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];\n                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;\n                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;\n                numprec += res_idx->pw * res_idx->ph;\n                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];\n                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];\n            }\n        }\n        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(\n                p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));\n        p_cstr_info->packno = 0;\n    }\n    /* << INDEX */\n#endif\n\n    /*--------------TIER2------------------*/\n    /* FIXME _ProfStart(PGROUP_T2); */\n    l_data_read = 0;\n    if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index,\n                            p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_T2); */\n\n    /*------------------TIER1-----------------*/\n\n    /* FIXME _ProfStart(PGROUP_T1); */\n    if (! opj_tcd_t1_decode(p_tcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_T1); */\n\n    /*----------------DWT---------------------*/\n\n    /* FIXME _ProfStart(PGROUP_DWT); */\n    if\n    (! opj_tcd_dwt_decode(p_tcd)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_DWT); */\n\n    /*----------------MCT-------------------*/\n    /* FIXME _ProfStart(PGROUP_MCT); */\n    if\n    (! opj_tcd_mct_decode(p_tcd, p_manager)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_MCT); */\n\n    /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n    if\n    (! opj_tcd_dc_level_shift_decode(p_tcd)) {\n        return OPJ_FALSE;\n    }\n    /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n\n    /*---------------TILE-------------------*/\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_dest,\n                                  OPJ_UINT32 p_dest_length\n                                 )\n{\n    OPJ_UINT32 i, j, k, l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    opj_tcd_resolution_t * l_res;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_UINT32 l_stride, l_width, l_height;\n\n    l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n    if (l_data_size == UINT_MAX || l_data_size > p_dest_length) {\n        return OPJ_FALSE;\n    }\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n        l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n        l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n        l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n        l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n            const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_CHAR)(*(l_src_ptr++));\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        *(l_dest_ptr++) = (OPJ_CHAR)((*(l_src_ptr++)) & 0xff);\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_dest = (OPJ_BYTE *)l_dest_ptr;\n        }\n        break;\n        case 2: {\n            const OPJ_INT32 * l_src_ptr = l_tilec->data;\n            OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        OPJ_INT16 val = (OPJ_INT16)(*(l_src_ptr++));\n                        memcpy(l_dest_ptr, &val, sizeof(val));\n                        l_dest_ptr ++;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            } else {\n                for (j = 0; j < l_height; ++j) {\n                    for (k = 0; k < l_width; ++k) {\n                        OPJ_INT16 val = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);\n                        memcpy(l_dest_ptr, &val, sizeof(val));\n                        l_dest_ptr ++;\n                    }\n                    l_src_ptr += l_stride;\n                }\n            }\n\n            p_dest = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n            OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n            for (j = 0; j < l_height; ++j) {\n                memcpy(l_dest_ptr, l_src_ptr, l_width * sizeof(OPJ_INT32));\n                l_dest_ptr += l_width;\n                l_src_ptr += l_width + l_stride;\n            }\n\n            p_dest = (OPJ_BYTE*) l_dest_ptr;\n        }\n        break;\n        }\n\n        ++l_img_comp;\n        ++l_tilec;\n    }\n\n    return OPJ_TRUE;\n}\n\n\n\n\nstatic void opj_tcd_free_tile(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno, resno, bandno, precno;\n    opj_tcd_tile_t *l_tile = 00;\n    opj_tcd_tilecomp_t *l_tile_comp = 00;\n    opj_tcd_resolution_t *l_res = 00;\n    opj_tcd_band_t *l_band = 00;\n    opj_tcd_precinct_t *l_precinct = 00;\n    OPJ_UINT32 l_nb_resolutions, l_nb_precincts;\n    void (* l_tcd_code_block_deallocate)(opj_tcd_precinct_t *) = 00;\n\n    if (! p_tcd) {\n        return;\n    }\n\n    if (! p_tcd->tcd_image) {\n        return;\n    }\n\n    if (p_tcd->m_is_decoder) {\n        l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;\n    } else {\n        l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;\n    }\n\n    l_tile = p_tcd->tcd_image->tiles;\n    if (! l_tile) {\n        return;\n    }\n\n    l_tile_comp = l_tile->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        l_res = l_tile_comp->resolutions;\n        if (l_res) {\n\n            l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);\n            for (resno = 0; resno < l_nb_resolutions; ++resno) {\n                l_band = l_res->bands;\n                for (bandno = 0; bandno < 3; ++bandno) {\n                    l_precinct = l_band->precincts;\n                    if (l_precinct) {\n\n                        l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);\n                        for (precno = 0; precno < l_nb_precincts; ++precno) {\n                            opj_tgt_destroy(l_precinct->incltree);\n                            l_precinct->incltree = 00;\n                            opj_tgt_destroy(l_precinct->imsbtree);\n                            l_precinct->imsbtree = 00;\n                            (*l_tcd_code_block_deallocate)(l_precinct);\n                            ++l_precinct;\n                        }\n\n                        opj_free(l_band->precincts);\n                        l_band->precincts = 00;\n                    }\n                    ++l_band;\n                } /* for (resno */\n                ++l_res;\n            }\n\n            opj_free(l_tile_comp->resolutions);\n            l_tile_comp->resolutions = 00;\n        }\n\n        if (l_tile_comp->ownsData && l_tile_comp->data) {\n            opj_aligned_free(l_tile_comp->data);\n            l_tile_comp->data = 00;\n            l_tile_comp->ownsData = 0;\n            l_tile_comp->data_size = 0;\n            l_tile_comp->data_size_needed = 0;\n        }\n        ++l_tile_comp;\n    }\n\n    opj_free(l_tile->comps);\n    l_tile->comps = 00;\n    opj_free(p_tcd->tcd_image->tiles);\n    p_tcd->tcd_image->tiles = 00;\n}\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_src_data,\n                                  OPJ_UINT32 * p_data_read,\n                                  OPJ_UINT32 p_max_src_size,\n                                  opj_codestream_index_t *p_cstr_index,\n                                  opj_event_mgr_t *p_manager\n                                 )\n{\n    opj_t2_t * l_t2;\n\n    l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n    if (l_t2 == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_t2_decode_packets(\n                l_t2,\n                p_tcd->tcd_tileno,\n                p_tcd->tcd_image->tiles,\n                p_src_data,\n                p_data_read,\n                p_max_src_size,\n                p_cstr_index,\n                p_manager)) {\n        opj_t2_destroy(l_t2);\n        return OPJ_FALSE;\n    }\n\n    opj_t2_destroy(l_t2);\n\n    /*---------------CLEAN-------------------*/\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;\n    opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n    volatile OPJ_BOOL ret = OPJ_TRUE;\n    OPJ_BOOL check_pterm = OPJ_FALSE;\n    opj_mutex_t* p_manager_mutex = NULL;\n\n    p_manager_mutex = opj_mutex_create();\n\n    /* Only enable PTERM check if we decode all layers */\n    if (p_tcd->tcp->num_layers_to_decode == p_tcd->tcp->numlayers &&\n            (l_tccp->cblksty & J2K_CCP_CBLKSTY_PTERM) != 0) {\n        check_pterm = OPJ_TRUE;\n    }\n\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        opj_t1_decode_cblks(p_tcd->thread_pool, &ret, l_tile_comp, l_tccp,\n                            p_manager, p_manager_mutex, check_pterm);\n        if (!ret) {\n            break;\n        }\n        ++l_tile_comp;\n        ++l_tccp;\n    }\n\n    opj_thread_pool_wait_completion(p_tcd->thread_pool, 0);\n    if (p_manager_mutex) {\n        opj_mutex_destroy(p_manager_mutex);\n    }\n    return ret;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n    opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n    opj_image_comp_t * l_img_comp = p_tcd->image->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; compno++) {\n        /*\n        if (tcd->cp->reduce != 0) {\n                tcd->image->comps[compno].resno_decoded =\n                        tile->comps[compno].numresolutions - tcd->cp->reduce - 1;\n                if (tcd->image->comps[compno].resno_decoded < 0)\n                {\n                        return false;\n                }\n        }\n        numres2decode = tcd->image->comps[compno].resno_decoded + 1;\n        if(numres2decode > 0){\n        */\n\n        if (l_tccp->qmfbid == 1) {\n            if (! opj_dwt_decode(p_tcd->thread_pool, l_tile_comp,\n                                 l_img_comp->resno_decoded + 1)) {\n                return OPJ_FALSE;\n            }\n        } else {\n            if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded + 1)) {\n                return OPJ_FALSE;\n            }\n        }\n\n        ++l_tile_comp;\n        ++l_img_comp;\n        ++l_tccp;\n    }\n\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd, opj_event_mgr_t *p_manager)\n{\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcp_t * l_tcp = p_tcd->tcp;\n    opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n    OPJ_UINT32 l_samples, i;\n\n    if (! l_tcp->mct) {\n        return OPJ_TRUE;\n    }\n\n    l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) *\n                             (l_tile_comp->y1 - l_tile_comp->y0));\n\n    if (l_tile->numcomps >= 3) {\n        /* testcase 1336.pdf.asan.47.376 */\n        if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 -\n                l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||\n                (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 -\n                        l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||\n                (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 -\n                        l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Tiles don't all have the same dimension. Skip the MCT step.\\n\");\n            return OPJ_FALSE;\n        } else if (l_tcp->mct == 2) {\n            OPJ_BYTE ** l_data;\n\n            if (! l_tcp->m_mct_decoding_matrix) {\n                return OPJ_TRUE;\n            }\n\n            l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps * sizeof(OPJ_BYTE*));\n            if (! l_data) {\n                return OPJ_FALSE;\n            }\n\n            for (i = 0; i < l_tile->numcomps; ++i) {\n                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                ++l_tile_comp;\n            }\n\n            if (! opj_mct_decode_custom(/* MCT data */\n                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,\n                        /* size of components */\n                        l_samples,\n                        /* components */\n                        l_data,\n                        /* nb of components (i.e. size of pData) */\n                        l_tile->numcomps,\n                        /* tells if the data is signed */\n                        p_tcd->image->comps->sgnd)) {\n                opj_free(l_data);\n                return OPJ_FALSE;\n            }\n\n            opj_free(l_data);\n        } else {\n            if (l_tcp->tccps->qmfbid == 1) {\n                opj_mct_decode(l_tile->comps[0].data,\n                               l_tile->comps[1].data,\n                               l_tile->comps[2].data,\n                               l_samples);\n            } else {\n                opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,\n                                    (OPJ_FLOAT32*)l_tile->comps[1].data,\n                                    (OPJ_FLOAT32*)l_tile->comps[2].data,\n                                    l_samples);\n            }\n        }\n    } else {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\\n\",\n                      l_tile->numcomps);\n    }\n\n    return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tilecomp_t * l_tile_comp = 00;\n    opj_tccp_t * l_tccp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_resolution_t* l_res = 00;\n    opj_tcd_tile_t * l_tile;\n    OPJ_UINT32 l_width, l_height, i, j;\n    OPJ_INT32 * l_current_ptr;\n    OPJ_INT32 l_min, l_max;\n    OPJ_UINT32 l_stride;\n\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tile_comp = l_tile->comps;\n    l_tccp = p_tcd->tcp->tccps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; compno++) {\n        l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;\n        l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n        l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n        l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;\n\n        assert(l_height == 0 ||\n               l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/\n\n        if (l_img_comp->sgnd) {\n            l_min = -(1 << (l_img_comp->prec - 1));\n            l_max = (1 << (l_img_comp->prec - 1)) - 1;\n        } else {\n            l_min = 0;\n            l_max = (1 << l_img_comp->prec) - 1;\n        }\n\n        l_current_ptr = l_tile_comp->data;\n\n        if (l_tccp->qmfbid == 1) {\n            for (j = 0; j < l_height; ++j) {\n                for (i = 0; i < l_width; ++i) {\n                    *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min,\n                                                   l_max);\n                    ++l_current_ptr;\n                }\n                l_current_ptr += l_stride;\n            }\n        } else {\n            for (j = 0; j < l_height; ++j) {\n                for (i = 0; i < l_width; ++i) {\n                    OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);\n                    OPJ_INT32 l_value_int = (OPJ_INT32)opj_lrintf(l_value);\n                    if (l_value > INT_MAX ||\n                            (l_value_int > 0 && l_tccp->m_dc_level_shift > 0 &&\n                             l_value_int > INT_MAX - l_tccp->m_dc_level_shift)) {\n                        *l_current_ptr = l_max;\n                    } else {\n                        *l_current_ptr = opj_int_clamp(\n                                             l_value_int + l_tccp->m_dc_level_shift, l_min, l_max);\n                    }\n                    ++l_current_ptr;\n                }\n                l_current_ptr += l_stride;\n            }\n        }\n\n        ++l_img_comp;\n        ++l_tccp;\n        ++l_tile_comp;\n    }\n\n    return OPJ_TRUE;\n}\n\n\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t * p_precinct)\n{\n    OPJ_UINT32 cblkno, l_nb_code_blocks;\n\n    opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n    if (l_code_block) {\n        /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n        /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n        /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                        l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n        l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n        /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n            if (l_code_block->data) {\n                opj_free(l_code_block->data);\n                l_code_block->data = 00;\n            }\n\n            if (l_code_block->segs) {\n                opj_free(l_code_block->segs);\n                l_code_block->segs = 00;\n            }\n\n            ++l_code_block;\n        }\n\n        opj_free(p_precinct->cblks.dec);\n        p_precinct->cblks.dec = 00;\n    }\n}\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t * p_precinct)\n{\n    OPJ_UINT32 cblkno, l_nb_code_blocks;\n\n    opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;\n    if (l_code_block) {\n        l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);\n\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {\n            if (l_code_block->data) {\n                /* We refer to data - 1 since below we incremented it */\n                /* in opj_tcd_code_block_enc_allocate_data() */\n                opj_free(l_code_block->data - 1);\n                l_code_block->data = 00;\n            }\n\n            if (l_code_block->layers) {\n                opj_free(l_code_block->layers);\n                l_code_block->layers = 00;\n            }\n\n            if (l_code_block->passes) {\n                opj_free(l_code_block->passes);\n                l_code_block->passes = 00;\n            }\n            ++l_code_block;\n        }\n\n        opj_free(p_precinct->cblks.enc);\n\n        p_precinct->cblks.enc = 00;\n    }\n}\n\nOPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 i, l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) *\n                       (l_tilec->y1 - l_tilec->y0));\n        ++l_img_comp;\n        ++l_tilec;\n    }\n\n    return l_data_size;\n}\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd)\n{\n    OPJ_UINT32 compno;\n    opj_tcd_tilecomp_t * l_tile_comp = 00;\n    opj_tccp_t * l_tccp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tile_t * l_tile;\n    OPJ_UINT32 l_nb_elem, i;\n    OPJ_INT32 * l_current_ptr;\n\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tile_comp = l_tile->comps;\n    l_tccp = p_tcd->tcp->tccps;\n    l_img_comp = p_tcd->image->comps;\n\n    for (compno = 0; compno < l_tile->numcomps; compno++) {\n        l_current_ptr = l_tile_comp->data;\n        l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) *\n                                 (l_tile_comp->y1 - l_tile_comp->y0));\n\n        if (l_tccp->qmfbid == 1) {\n            for (i = 0; i < l_nb_elem; ++i) {\n                *l_current_ptr -= l_tccp->m_dc_level_shift ;\n                ++l_current_ptr;\n            }\n        } else {\n            for (i = 0; i < l_nb_elem; ++i) {\n                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) * (1 << 11);\n                ++l_current_ptr;\n            }\n        }\n\n        ++l_img_comp;\n        ++l_tccp;\n        ++l_tile_comp;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd)\n{\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n    OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) *\n                                      (l_tile_comp->y1 - l_tile_comp->y0));\n    OPJ_UINT32 i;\n    OPJ_BYTE ** l_data = 00;\n    opj_tcp_t * l_tcp = p_tcd->tcp;\n\n    if (!p_tcd->tcp->mct) {\n        return OPJ_TRUE;\n    }\n\n    if (p_tcd->tcp->mct == 2) {\n        if (! p_tcd->tcp->m_mct_coding_matrix) {\n            return OPJ_TRUE;\n        }\n\n        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps * sizeof(OPJ_BYTE*));\n        if (! l_data) {\n            return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_tile->numcomps; ++i) {\n            l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n            ++l_tile_comp;\n        }\n\n        if (! opj_mct_encode_custom(/* MCT data */\n                    (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,\n                    /* size of components */\n                    samples,\n                    /* components */\n                    l_data,\n                    /* nb of components (i.e. size of pData) */\n                    l_tile->numcomps,\n                    /* tells if the data is signed */\n                    p_tcd->image->comps->sgnd)) {\n            opj_free(l_data);\n            return OPJ_FALSE;\n        }\n\n        opj_free(l_data);\n    } else if (l_tcp->tccps->qmfbid == 0) {\n        opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data,\n                            l_tile->comps[2].data, samples);\n    } else {\n        opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data,\n                       l_tile->comps[2].data, samples);\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd)\n{\n    opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n    opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n    opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n    OPJ_UINT32 compno;\n\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        if (l_tccp->qmfbid == 1) {\n            if (! opj_dwt_encode(l_tile_comp)) {\n                return OPJ_FALSE;\n            }\n        } else if (l_tccp->qmfbid == 0) {\n            if (! opj_dwt_encode_real(l_tile_comp)) {\n                return OPJ_FALSE;\n            }\n        }\n\n        ++l_tile_comp;\n        ++l_tccp;\n    }\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd)\n{\n    opj_t1_t * l_t1;\n    const OPJ_FLOAT64 * l_mct_norms;\n    OPJ_UINT32 l_mct_numcomps = 0U;\n    opj_tcp_t * l_tcp = p_tcd->tcp;\n\n    l_t1 = opj_t1_create(OPJ_TRUE);\n    if (l_t1 == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (l_tcp->mct == 1) {\n        l_mct_numcomps = 3U;\n        /* irreversible encoding */\n        if (l_tcp->tccps->qmfbid == 0) {\n            l_mct_norms = opj_mct_get_mct_norms_real();\n        } else {\n            l_mct_norms = opj_mct_get_mct_norms();\n        }\n    } else {\n        l_mct_numcomps = p_tcd->image->numcomps;\n        l_mct_norms = (const OPJ_FLOAT64 *)(l_tcp->mct_norms);\n    }\n\n    if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles, l_tcp, l_mct_norms,\n                              l_mct_numcomps)) {\n        opj_t1_destroy(l_t1);\n        return OPJ_FALSE;\n    }\n\n    opj_t1_destroy(l_t1);\n\n    return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd,\n                                  OPJ_BYTE * p_dest_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_max_dest_size,\n                                  opj_codestream_info_t *p_cstr_info)\n{\n    opj_t2_t * l_t2;\n\n    l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n    if (l_t2 == 00) {\n        return OPJ_FALSE;\n    }\n\n    if (! opj_t2_encode_packets(\n                l_t2,\n                p_tcd->tcd_tileno,\n                p_tcd->tcd_image->tiles,\n                p_tcd->tcp->numlayers,\n                p_dest_data,\n                p_data_written,\n                p_max_dest_size,\n                p_cstr_info,\n                p_tcd->tp_num,\n                p_tcd->tp_pos,\n                p_tcd->cur_pino,\n                FINAL_PASS)) {\n        opj_t2_destroy(l_t2);\n        return OPJ_FALSE;\n    }\n\n    opj_t2_destroy(l_t2);\n\n    /*---------------CLEAN-------------------*/\n    return OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd,\n        OPJ_BYTE * p_dest_data,\n        OPJ_UINT32 p_max_dest_size,\n        opj_codestream_info_t *p_cstr_info)\n{\n    opj_cp_t * l_cp = p_tcd->cp;\n    OPJ_UINT32 l_nb_written = 0;\n\n    if (p_cstr_info)  {\n        p_cstr_info->index_write = 0;\n    }\n\n    if (l_cp->m_specific_param.m_enc.m_disto_alloc ||\n            l_cp->m_specific_param.m_enc.m_fixed_quality)  {\n        /* fixed_quality */\n        /* Normal Rate/distortion allocation */\n        if (! opj_tcd_rateallocate(p_tcd, p_dest_data, &l_nb_written, p_max_dest_size,\n                                   p_cstr_info)) {\n            return OPJ_FALSE;\n        }\n    } else {\n        /* Fixed layer allocation */\n        opj_tcd_rateallocate_fixed(p_tcd);\n    }\n\n    return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd,\n                                OPJ_BYTE * p_src,\n                                OPJ_UINT32 p_src_length)\n{\n    OPJ_UINT32 i, j, l_data_size = 0;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_tcd_tilecomp_t * l_tilec = 00;\n    OPJ_UINT32 l_size_comp, l_remaining;\n    OPJ_UINT32 l_nb_elem;\n\n    l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);\n    if (l_data_size != p_src_length) {\n        return OPJ_FALSE;\n    }\n\n    l_tilec = p_tcd->tcd_image->tiles->comps;\n    l_img_comp = p_tcd->image->comps;\n    for (i = 0; i < p_tcd->image->numcomps; ++i) {\n        l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n        l_remaining = l_img_comp->prec & 7;  /* (%8) */\n        l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 -\n                                 l_tilec->y0));\n\n        if (l_remaining) {\n            ++l_size_comp;\n        }\n\n        if (l_size_comp == 3) {\n            l_size_comp = 4;\n        }\n\n        switch (l_size_comp) {\n        case 1: {\n            OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;\n            OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (OPJ_INT32)(*(l_src_ptr++));\n                }\n            } else {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (*(l_src_ptr++)) & 0xff;\n                }\n            }\n\n            p_src = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        case 2: {\n            OPJ_INT32 * l_dest_ptr = l_tilec->data;\n            OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;\n\n            if (l_img_comp->sgnd) {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (OPJ_INT32)(*(l_src_ptr++));\n                }\n            } else {\n                for (j = 0; j < l_nb_elem; ++j) {\n                    *(l_dest_ptr++) = (*(l_src_ptr++)) & 0xffff;\n                }\n            }\n\n            p_src = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        case 4: {\n            OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;\n            OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n            for (j = 0; j < l_nb_elem; ++j) {\n                *(l_dest_ptr++) = (OPJ_INT32)(*(l_src_ptr++));\n            }\n\n            p_src = (OPJ_BYTE*) l_src_ptr;\n        }\n        break;\n        }\n\n        ++l_img_comp;\n        ++l_tilec;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t* band)\n{\n    return (band->x1 - band->x0 == 0) || (band->y1 - band->y0 == 0);\n}\n"], "filenames": ["src/lib/openjp2/tcd.c"], "buggy_code_start_loc": [1185], "buggy_code_end_loc": [1187], "fixing_code_start_loc": [1185], "fixing_code_end_loc": [1188], "type": "CWE-119", "message": "Heap-based buffer overflow vulnerability in the opj_mqc_byteout function in mqc.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (application crash) via a crafted bmp file.", "other": {"cve": {"id": "CVE-2016-10504", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-30T09:29:00.247", "lastModified": "2020-09-09T19:57:18.373", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow vulnerability in the opj_mqc_byteout function in mqc.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (application crash) via a crafted bmp file."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer basado en mont\u00edculos en la funci\u00f3n opj_mqc_byteout en mqc.c en OpenJPEG en versiones anteriores a la 2.2.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (fallo de servicio) mediante un archivo bmp manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.2", "matchCriteriaId": "2A0A42B9-5905-4F51-8513-59CDC67CF06E"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-4013", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100564", "source": "cve@mitre.org"}, {"url": "https://github.com/uclouvain/openjpeg/commit/397f62c0a838e15d667ef50e27d5d011d2c79c04", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/835", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-26", "source": "cve@mitre.org"}, {"url": "https://www.exploit-db.com/exploits/42600/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/397f62c0a838e15d667ef50e27d5d011d2c79c04"}}