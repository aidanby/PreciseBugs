{"buggy_code": ["/***************************************************************************\n          ofx_preproc.cpp\n                             -------------------\n    copyright            : (C) 2002 by Benoit Gr\ufffdoir\n    email                : benoitg@coeus.ca\n***************************************************************************/\n/**@file\n * \\brief Preprocessing of the OFX files before parsing\n *\n Implements the pre-treatement of the OFX file prior to parsing:  OFX header striping, OFX proprietary tags and SGML comment striping, locating the appropriate DTD.\n*/\n/***************************************************************************\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n ***************************************************************************/\n#include \"../config.h\"\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <stdio.h>\n#include <string>\n#include \"ParserEventGeneratorKit.h\"\n#include \"libofx.h\"\n#include \"messages.hh\"\n#include \"ofx_sgml.hh\"\n#include \"ofc_sgml.hh\"\n#include \"ofx_preproc.hh\"\n#include \"ofx_utilities.hh\"\n#ifdef HAVE_ICONV\n#include <iconv.h>\n#endif\n\n#ifdef OS_WIN32\n# define DIRSEP \"\\\\\"\n#else\n# define DIRSEP \"/\"\n#endif\n\n#ifdef OS_WIN32\n# include \"win32.hh\"\n# include <windows.h> // for GetModuleFileName()\n# undef ERROR\n# undef DELETE\n#endif\n\n#define LIBOFX_DEFAULT_INPUT_ENCODING \"CP1252\"\n#define LIBOFX_DEFAULT_OUTPUT_ENCODING \"UTF-8\"\n\nusing namespace std;\n/**\n   \\brief The number of different paths to search for DTDs.\n*/\n#ifdef MAKEFILE_DTD_PATH\nconst int DTD_SEARCH_PATH_NUM = 4;\n#else\nconst int DTD_SEARCH_PATH_NUM = 3;\n#endif\n\n/**\n   \\brief The list of paths to search for the DTDs.\n*/\nconst char *DTD_SEARCH_PATH[DTD_SEARCH_PATH_NUM] =\n{\n#ifdef MAKEFILE_DTD_PATH\n  MAKEFILE_DTD_PATH ,\n#endif\n  \"/usr/local/share/libofx/dtd\",\n  \"/usr/share/libofx/dtd\",\n  \"~\"\n};\nconst unsigned int READ_BUFFER_SIZE = 1024;\n\n/** @brief File pre-processing of OFX AND for OFC files\n*\n* Takes care of comment striping, dtd locating, etc.\n*/\nint ofx_proc_file(LibofxContextPtr ctx, const char * p_filename)\n{\n  LibofxContext *libofx_context;\n  bool ofx_start = false;\n  bool ofx_end = false;\n  bool file_is_xml = false;\n\n  ifstream input_file;\n  ofstream tmp_file;\n  char buffer[READ_BUFFER_SIZE];\n  char *iconv_buffer;\n  string s_buffer;\n  char *filenames[3];\n  char tmp_filename[256];\n  int tmp_file_fd;\n#ifdef HAVE_ICONV\n  iconv_t conversion_descriptor;\n#endif\n  libofx_context = (LibofxContext*)ctx;\n\n  if (p_filename != NULL && strcmp(p_filename, \"\") != 0)\n  {\n    message_out(DEBUG, string(\"ofx_proc_file():Opening file: \") + p_filename);\n\n    input_file.open(p_filename);\n    if (!input_file)\n    {\n      message_out(ERROR, \"ofx_proc_file():Unable to open the input file \" + string(p_filename));\n    }\n\n    mkTempFileName(\"libofxtmpXXXXXX\", tmp_filename, sizeof(tmp_filename));\n\n    message_out(DEBUG, \"ofx_proc_file(): Creating temp file: \" + string(tmp_filename));\n    tmp_file_fd = mkstemp(tmp_filename);\n    if (tmp_file_fd)\n    {\n      tmp_file.open(tmp_filename);\n      if (!tmp_file)\n      {\n        message_out(ERROR, \"ofx_proc_file():Unable to open the created temp file \" + string(tmp_filename));\n        return -1;\n      }\n    }\n    else\n    {\n      message_out(ERROR, \"ofx_proc_file():Unable to create a temp file at \" + string(tmp_filename));\n      return -1;\n    }\n\n    if (input_file && tmp_file)\n    {\n      int header_separator_idx;\n      string header_name;\n      string header_value;\n      string ofx_encoding;\n      string ofx_charset;\n      do\n      {\n        s_buffer.clear();\n        bool end_of_line = false;\n        do\n        {\n          input_file.get(buffer, sizeof(buffer), '\\n');\n          //cout<< \"got: \\\"\" << buffer<<\"\\\"\\n\";\n          s_buffer.append(buffer);\n\n          // Watch out: If input_file is in eof(), any subsequent read or\n          // peek() will fail and we must exit this loop.\n          if (input_file.eof())\n            break;\n\n          //cout<<\"input_file.gcount(): \"<<input_file.gcount()<< \" s_buffer.size=\" << s_buffer.size()<<\" sizeof(buffer): \"<<sizeof(buffer) << \" peek=\\\"\" << int(input_file.peek()) << \"\\\"\" <<endl;\n          if (input_file.fail()) // If no characters were extracted above, the failbit is set.\n          {\n            // No characters extracted means that we've reached the newline\n            // delimiter (because we already checked for EOF). We will check\n            // for and remove that newline in the next if-clause, but must\n            // remove the failbit so that peek() will work again.\n            input_file.clear();\n          }\n\n          // Is the next character really the newline?\n          if (input_file.peek() == '\\n')\n          {\n            // Yes. Then discard that newline character from the stream and\n            // append it manually to the output string.\n            input_file.get();\n            s_buffer.append(\"\\n\");\n            end_of_line = true; // We found the end-of-line.\n          }\n        }\n        // Continue reading as long as we're not at EOF *and* we've not yet\n        // reached an end-of-line.\n        while (!input_file.eof() && !end_of_line);\n\n        if (ofx_start == false && (s_buffer.find(\"<?xml\") != string::npos))\n        {\n          message_out(DEBUG, \"ofx_proc_file(): File is an actual XML file, iconv conversion will be skipped.\");\n          file_is_xml = true;\n        }\n\n        int ofx_start_idx;\n        if (ofx_start == false &&\n            (\n              (libofx_context->currentFileType() == OFX &&\n               ((ofx_start_idx = s_buffer.find(\"<OFX>\")) !=\n                string::npos || (ofx_start_idx = s_buffer.find(\"<ofx>\")) != string::npos))\n              || (libofx_context->currentFileType() == OFC &&\n                  ((ofx_start_idx = s_buffer.find(\"<OFC>\")) != string::npos ||\n                   (ofx_start_idx = s_buffer.find(\"<ofc>\")) != string::npos))\n            )\n           )\n        {\n          ofx_start = true;\n          if (file_is_xml == false)\n          {\n            s_buffer.erase(0, ofx_start_idx); //Fix for really broken files that don't have a newline after the header.\n          }\n          message_out(DEBUG, \"ofx_proc_file():<OFX> or <OFC> has been found\");\n\n          if (file_is_xml == true)\n          {\n            static char sp_charset_fixed[] = \"SP_CHARSET_FIXED=1\";\n            if (putenv(sp_charset_fixed) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n            /* Normally the following would be \"xml\".\n             * Unfortunately, opensp's generic api will garble UTF-8 if this is\n             * set to xml.  So we set any single byte encoding to avoid messing\n             * up UTF-8.  Unfortunately this means that non-UTF-8 files will not\n             * get properly translated.  We'd need to manually detect the\n             * encoding in the XML header and convert the xml with iconv like we\n             * do for SGML to work around the problem.  Most unfortunate. */\n            static char sp_encoding[] = \"SP_ENCODING=ms-dos\";\n            if (putenv(sp_encoding) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n          }\n          else\n          {\n            static char sp_charset_fixed[] = \"SP_CHARSET_FIXED=1\";\n            if (putenv(sp_charset_fixed) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n            static char sp_encoding[] = \"SP_ENCODING=ms-dos\"; //Any single byte encoding will do, we don't want opensp messing up UTF-8;\n            if (putenv(sp_encoding) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n#ifdef HAVE_ICONV\n            string fromcode;\n            string tocode;\n            if (ofx_encoding.compare(\"USASCII\") == 0)\n            {\n              if (ofx_charset.compare(\"ISO-8859-1\") == 0 || ofx_charset.compare(\"8859-1\") == 0)\n              {\n                //Only \"ISO-8859-1\" is actually a legal value, but since the banks follows the spec SO well...\n                fromcode = \"ISO-8859-1\";\n              }\n              else if (ofx_charset.compare(\"1252\") == 0 || ofx_charset.compare(\"CP1252\") == 0)\n              {\n                //Only \"1252\" is actually a legal value, but since the banks follows the spec SO well...\n                fromcode = \"CP1252\";\n              }\n              else if (ofx_charset.compare(\"NONE\") == 0)\n              {\n                fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;\n              }\n              else\n              {\n                fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;\n              }\n            }\n            else if (ofx_encoding.compare(\"UTF-8\") == 0 || ofx_encoding.compare(\"UNICODE\") == 0)\n            {\n              //While \"UNICODE\" isn't a legal value, some cyrilic files do specify it as such...\n              fromcode = \"UTF-8\";\n            }\n            else\n            {\n              fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;\n            }\n            tocode = LIBOFX_DEFAULT_OUTPUT_ENCODING;\n            message_out(DEBUG, \"ofx_proc_file(): Setting up iconv for fromcode: \" + fromcode + \", tocode: \" + tocode);\n            conversion_descriptor = iconv_open (tocode.c_str(), fromcode.c_str());\n#endif\n          }\n        }\n        else\n        {\n          //We are still in the headers\n          if ((header_separator_idx = s_buffer.find(':')) != string::npos)\n          {\n            //Header processing\n            header_name.assign(s_buffer.substr(0, header_separator_idx));\n            header_value.assign(s_buffer.substr(header_separator_idx + 1));\n            while ( header_value[header_value.length() -1 ] == '\\n' ||\n                    header_value[header_value.length() -1 ] == '\\r' )\n              header_value.erase(header_value.length() - 1);\n            message_out(DEBUG, \"ofx_proc_file():Header: \" + header_name + \" with value: \" + header_value + \" has been found\");\n            if (header_name.compare(\"ENCODING\") == 0)\n            {\n              ofx_encoding.assign(header_value);\n            }\n            if (header_name.compare(\"CHARSET\") == 0)\n            {\n              ofx_charset.assign(header_value);\n            }\n          }\n        }\n\n        if (file_is_xml == true || (ofx_start == true && ofx_end == false))\n        {\n          if (ofx_start == true)\n          {\n            /* The above test won't help us if the <OFX> tag is on the same line\n             * as the xml header, but as opensp can't be used to parse it anyway\n             * this isn't a great loss for now.\n             */\n            s_buffer = sanitize_proprietary_tags(s_buffer);\n          }\n          //cout<< s_buffer<<\"\\n\";\n          if (file_is_xml == false)\n          {\n#ifdef HAVE_ICONV\n            size_t inbytesleft = strlen(s_buffer.c_str());\n            size_t outbytesleft = inbytesleft * 2 - 1;\n            iconv_buffer = (char*) malloc (inbytesleft * 2);\n            memset(iconv_buffer, 0, inbytesleft * 2);\n#if defined(OS_WIN32) || defined(__sun) || defined(__NetBSD__)\n            const char * inchar = (const char *)s_buffer.c_str();\n#else\n            char * inchar = (char *)s_buffer.c_str();\n#endif\n            char * outchar = iconv_buffer;\n            int iconv_retval = iconv (conversion_descriptor,\n                                      &inchar, &inbytesleft,\n                                      &outchar, &outbytesleft);\n            if (iconv_retval == -1)\n            {\n              message_out(ERROR, \"ofx_proc_file(): Conversion error\");\n            }\n            s_buffer = iconv_buffer;\n            free (iconv_buffer);\n#endif\n          }\n          //cout << s_buffer << \"\\n\";\n          tmp_file.write(s_buffer.c_str(), s_buffer.length());\n        }\n\n        if (ofx_start == true &&\n            (\n              (libofx_context->currentFileType() == OFX &&\n               ((ofx_start_idx = s_buffer.find(\"</OFX>\")) != string::npos ||\n                (ofx_start_idx = s_buffer.find(\"</ofx>\")) != string::npos))\n              || (libofx_context->currentFileType() == OFC &&\n                  ((ofx_start_idx = s_buffer.find(\"</OFC>\")) != string::npos ||\n                   (ofx_start_idx = s_buffer.find(\"</ofc>\")) != string::npos))\n            )\n           )\n        {\n          ofx_end = true;\n          message_out(DEBUG, \"ofx_proc_file():</OFX> or </OFC>  has been found\");\n        }\n\n      }\n      while (!input_file.eof() && !input_file.bad());\n    }\n    input_file.close();\n    tmp_file.close();\n#ifdef HAVE_ICONV\n    if (file_is_xml == false)\n    {\n      iconv_close(conversion_descriptor);\n    }\n#endif\n    char filename_openspdtd[255];\n    char filename_dtd[255];\n    char filename_ofx[255];\n    strncpy(filename_openspdtd, find_dtd(ctx, OPENSPDCL_FILENAME).c_str(), 255); //The opensp sgml dtd file\n    if (libofx_context->currentFileType() == OFX)\n    {\n      strncpy(filename_dtd, find_dtd(ctx, OFX160DTD_FILENAME).c_str(), 255); //The ofx dtd file\n    }\n    else if (libofx_context->currentFileType() == OFC)\n    {\n      strncpy(filename_dtd, find_dtd(ctx, OFCDTD_FILENAME).c_str(), 255); //The ofc dtd file\n    }\n    else\n    {\n      message_out(ERROR, string(\"ofx_proc_file(): Error unknown file format for the OFX parser\"));\n    }\n\n    if ((string)filename_dtd != \"\" && (string)filename_openspdtd != \"\")\n    {\n      strncpy(filename_ofx, tmp_filename, 255); //The processed ofx file\n      filenames[0] = filename_openspdtd;\n      filenames[1] = filename_dtd;\n      filenames[2] = filename_ofx;\n      if (libofx_context->currentFileType() == OFX)\n      {\n        ofx_proc_sgml(libofx_context, 3, filenames);\n      }\n      else if (libofx_context->currentFileType() == OFC)\n      {\n        ofc_proc_sgml(libofx_context, 3, filenames);\n      }\n      else\n      {\n        message_out(ERROR, string(\"ofx_proc_file(): Error unknown file format for the OFX parser\"));\n      }\n      if (remove(tmp_filename) != 0)\n      {\n        message_out(ERROR, \"ofx_proc_file(): Error deleting temporary file \" + string(tmp_filename));\n      }\n    }\n    else\n    {\n      message_out(ERROR, \"ofx_proc_file(): FATAL: Missing DTD, aborting\");\n    }\n  }\n  else\n  {\n    message_out(ERROR, \"ofx_proc_file():No input file specified\");\n  }\n  return 0;\n}\n\n\n/**\n   This function will strip all the OFX proprietary tags and SGML comments from the SGML string passed to it\n*/\n\nstring sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  size_t input_string_size;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; //Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  input_string_size = input_string.size();\n\n  for (i = 0; i < input_string_size; i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '/')\n      {\n        //We are now in a closing tag\n        closing_tag_open = true;\n        //cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;\n        if (strncmp(tagname, &(input_string.c_str()[i+2]), strlen(tagname)) != 0)\n        {\n          //If it is the begining of an other tag\n          //cout<<\"DIFFERENT!\"<<endl;\n          crop_end_idx = i - 1;\n          strip = true;\n        }\n        else\n        {\n          //Otherwise, it is the start of the closing tag of the proprietary tag\n          proprietary_closing_tag = true;\n        }\n      }\n      else if (proprietary_tag == true)\n      {\n        //It is the start of a new tag, following a proprietary tag\n        crop_end_idx = i - 1;\n        strip = true;\n      }\n    }\n    else if (input_string.c_str()[i] == '>')\n    {\n      tag_open = false;\n      closing_tag_open = false;\n      tagname[tagname_idx] = 0;\n      tagname_idx = 0;\n      if (proprietary_closing_tag == true)\n      {\n        crop_end_idx = i;\n        strip = true;\n      }\n    }\n    else if (tag_open == true && closing_tag_open == false)\n    {\n      if (input_string.c_str()[i] == '.')\n      {\n        if (proprietary_tag != true)\n        {\n          orig_tag_open_idx = tag_open_idx;\n          proprietary_tag = true;\n        }\n      }\n      tagname[tagname_idx] = input_string.c_str()[i];\n      tagname_idx++;\n    }\n    //cerr <<i<<endl;\n    if (strip == true && orig_tag_open_idx < input_string.size())\n    {\n      input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);\n      message_out(INFO, \"sanitize_proprietary_tags() (end tag or new tag) removed: \" + string(buffer));\n      input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);\n      i = orig_tag_open_idx - 1;\n      proprietary_tag = false;\n      proprietary_closing_tag = false;\n      closing_tag_open = false;\n      tag_open = false;\n      strip = false;\n\n      input_string_size = input_string.size();\n    }\n\n  }//end for\n  if (proprietary_tag == true && orig_tag_open_idx < input_string.size())\n  {\n    if (crop_end_idx == 0)   //no closing tag\n    {\n      crop_end_idx = input_string.size() - 1;\n    }\n    input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);\n    message_out(INFO, \"sanitize_proprietary_tags() (end of line) removed: \" + string(buffer));\n    input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);\n    input_string_size = input_string.size();\n  }\n  return input_string;\n}\n\n\n#ifdef OS_WIN32\nstatic std::string get_dtd_installation_directory()\n{\n  // Partial implementation of\n  // http://developer.gnome.org/doc/API/2.0/glib/glib-Windows-Compatibility-Functions.html#g-win32-get-package-installation-directory\n  char ch_fn[MAX_PATH], *p;\n  std::string str_fn;\n\n  if (!GetModuleFileName(NULL, ch_fn, MAX_PATH)) return \"\";\n\n  if ((p = strrchr(ch_fn, '\\\\')) != NULL)\n    * p = '\\0';\n\n  p = strrchr(ch_fn, '\\\\');\n  if (p && (_stricmp(p + 1, \"bin\") == 0 ||\n            _stricmp(p + 1, \"lib\") == 0))\n    *p = '\\0';\n\n  str_fn = ch_fn;\n  str_fn += \"\\\\share\\\\libofx\\\\dtd\";\n\n  return str_fn;\n}\n#endif\n\n\n/**\n   This function will try to find a DTD matching the requested_version and return the full path of the DTD found (or an empty string if unsuccessful)\n   *\n   Please note that currently the function will ALWAYS look for version 160, since OpenSP can't parse the 201 DTD correctly\n\n   It will look, in (order)\n\n   1- The environment variable OFX_DTD_PATH (if present)\n   2- On windows only, a relative path specified by get_dtd_installation_directory()\n   3- The path specified by the makefile in MAKEFILE_DTD_PATH, thru LIBOFX_DTD_DIR in configure (if present)\n   4- Any hardcoded paths in DTD_SEARCH_PATH\n*/\nstd::string find_dtd(LibofxContextPtr ctx, const std::string& dtd_filename)\n{\n  string dtd_path_filename;\n  char *env_dtd_path;\n\n  dtd_path_filename = reinterpret_cast<const LibofxContext*>(ctx)->dtdDir();\n  if (!dtd_path_filename.empty())\n  {\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (dtd_file)\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n\n#ifdef OS_WIN32\n  dtd_path_filename = get_dtd_installation_directory();\n  if (!dtd_path_filename.empty())\n  {\n    dtd_path_filename.append(DIRSEP);\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (dtd_file)\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n#endif\n  /* Search in environement variable OFX_DTD_PATH */\n  env_dtd_path = getenv(\"OFX_DTD_PATH\");\n  if (env_dtd_path)\n  {\n    dtd_path_filename.append(env_dtd_path);\n    dtd_path_filename.append(DIRSEP);\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (!dtd_file)\n    {\n      message_out(STATUS, \"find_dtd():OFX_DTD_PATH env variable was was present, but unable to open the file \" + dtd_path_filename);\n    }\n    else\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n\n  for (int i = 0; i < DTD_SEARCH_PATH_NUM; i++)\n  {\n    dtd_path_filename = DTD_SEARCH_PATH[i];\n    dtd_path_filename.append(DIRSEP);\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (!dtd_file)\n    {\n      message_out(DEBUG, \"find_dtd():Unable to open the file \" + dtd_path_filename);\n    }\n    else\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n\n  /* Last resort, look in source tree relative path (useful for development) */\n  dtd_path_filename = \"\";\n  dtd_path_filename.append(\"..\");\n  dtd_path_filename.append(DIRSEP);\n  dtd_path_filename.append(\"dtd\");\n  dtd_path_filename.append(DIRSEP);\n  dtd_path_filename.append(dtd_filename);\n  ifstream dtd_file(dtd_path_filename.c_str());\n  if (!dtd_file)\n  {\n    message_out(DEBUG, \"find_dtd(): Unable to open the file \" + dtd_path_filename + \", most likely we are not in the source tree.\");\n  }\n  else\n  {\n    message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n    return dtd_path_filename;\n  }\n\n\n  message_out(ERROR, \"find_dtd():Unable to find the DTD named \" + dtd_filename);\n  return \"\";\n}\n\n\n"], "fixing_code": ["/***************************************************************************\n          ofx_preproc.cpp\n                             -------------------\n    copyright            : (C) 2002 by Benoit Gr\ufffdoir\n    email                : benoitg@coeus.ca\n***************************************************************************/\n/**@file\n * \\brief Preprocessing of the OFX files before parsing\n *\n Implements the pre-treatement of the OFX file prior to parsing:  OFX header striping, OFX proprietary tags and SGML comment striping, locating the appropriate DTD.\n*/\n/***************************************************************************\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n ***************************************************************************/\n#include \"../config.h\"\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <stdio.h>\n#include <string>\n#include \"ParserEventGeneratorKit.h\"\n#include \"libofx.h\"\n#include \"messages.hh\"\n#include \"ofx_sgml.hh\"\n#include \"ofc_sgml.hh\"\n#include \"ofx_preproc.hh\"\n#include \"ofx_utilities.hh\"\n#ifdef HAVE_ICONV\n#include <iconv.h>\n#endif\n\n#ifdef OS_WIN32\n# define DIRSEP \"\\\\\"\n#else\n# define DIRSEP \"/\"\n#endif\n\n#ifdef OS_WIN32\n# include \"win32.hh\"\n# include <windows.h> // for GetModuleFileName()\n# undef ERROR\n# undef DELETE\n#endif\n\n#define LIBOFX_DEFAULT_INPUT_ENCODING \"CP1252\"\n#define LIBOFX_DEFAULT_OUTPUT_ENCODING \"UTF-8\"\n\nusing namespace std;\n/**\n   \\brief The number of different paths to search for DTDs.\n*/\n#ifdef MAKEFILE_DTD_PATH\nconst int DTD_SEARCH_PATH_NUM = 4;\n#else\nconst int DTD_SEARCH_PATH_NUM = 3;\n#endif\n\n/**\n   \\brief The list of paths to search for the DTDs.\n*/\nconst char *DTD_SEARCH_PATH[DTD_SEARCH_PATH_NUM] =\n{\n#ifdef MAKEFILE_DTD_PATH\n  MAKEFILE_DTD_PATH ,\n#endif\n  \"/usr/local/share/libofx/dtd\",\n  \"/usr/share/libofx/dtd\",\n  \"~\"\n};\nconst unsigned int READ_BUFFER_SIZE = 1024;\n\n/** @brief File pre-processing of OFX AND for OFC files\n*\n* Takes care of comment striping, dtd locating, etc.\n*/\nint ofx_proc_file(LibofxContextPtr ctx, const char * p_filename)\n{\n  LibofxContext *libofx_context;\n  bool ofx_start = false;\n  bool ofx_end = false;\n  bool file_is_xml = false;\n\n  ifstream input_file;\n  ofstream tmp_file;\n  char buffer[READ_BUFFER_SIZE];\n  char *iconv_buffer;\n  string s_buffer;\n  char *filenames[3];\n  char tmp_filename[256];\n  int tmp_file_fd;\n#ifdef HAVE_ICONV\n  iconv_t conversion_descriptor;\n#endif\n  libofx_context = (LibofxContext*)ctx;\n\n  if (p_filename != NULL && strcmp(p_filename, \"\") != 0)\n  {\n    message_out(DEBUG, string(\"ofx_proc_file():Opening file: \") + p_filename);\n\n    input_file.open(p_filename);\n    if (!input_file)\n    {\n      message_out(ERROR, \"ofx_proc_file():Unable to open the input file \" + string(p_filename));\n    }\n\n    mkTempFileName(\"libofxtmpXXXXXX\", tmp_filename, sizeof(tmp_filename));\n\n    message_out(DEBUG, \"ofx_proc_file(): Creating temp file: \" + string(tmp_filename));\n    tmp_file_fd = mkstemp(tmp_filename);\n    if (tmp_file_fd)\n    {\n      tmp_file.open(tmp_filename);\n      if (!tmp_file)\n      {\n        message_out(ERROR, \"ofx_proc_file():Unable to open the created temp file \" + string(tmp_filename));\n        return -1;\n      }\n    }\n    else\n    {\n      message_out(ERROR, \"ofx_proc_file():Unable to create a temp file at \" + string(tmp_filename));\n      return -1;\n    }\n\n    if (input_file && tmp_file)\n    {\n      int header_separator_idx;\n      string header_name;\n      string header_value;\n      string ofx_encoding;\n      string ofx_charset;\n      do\n      {\n        s_buffer.clear();\n        bool end_of_line = false;\n        do\n        {\n          input_file.get(buffer, sizeof(buffer), '\\n');\n          //cout<< \"got: \\\"\" << buffer<<\"\\\"\\n\";\n          s_buffer.append(buffer);\n\n          // Watch out: If input_file is in eof(), any subsequent read or\n          // peek() will fail and we must exit this loop.\n          if (input_file.eof())\n            break;\n\n          //cout<<\"input_file.gcount(): \"<<input_file.gcount()<< \" s_buffer.size=\" << s_buffer.size()<<\" sizeof(buffer): \"<<sizeof(buffer) << \" peek=\\\"\" << int(input_file.peek()) << \"\\\"\" <<endl;\n          if (input_file.fail()) // If no characters were extracted above, the failbit is set.\n          {\n            // No characters extracted means that we've reached the newline\n            // delimiter (because we already checked for EOF). We will check\n            // for and remove that newline in the next if-clause, but must\n            // remove the failbit so that peek() will work again.\n            input_file.clear();\n          }\n\n          // Is the next character really the newline?\n          if (input_file.peek() == '\\n')\n          {\n            // Yes. Then discard that newline character from the stream and\n            // append it manually to the output string.\n            input_file.get();\n            s_buffer.append(\"\\n\");\n            end_of_line = true; // We found the end-of-line.\n          }\n        }\n        // Continue reading as long as we're not at EOF *and* we've not yet\n        // reached an end-of-line.\n        while (!input_file.eof() && !end_of_line);\n\n        if (ofx_start == false && (s_buffer.find(\"<?xml\") != string::npos))\n        {\n          message_out(DEBUG, \"ofx_proc_file(): File is an actual XML file, iconv conversion will be skipped.\");\n          file_is_xml = true;\n        }\n\n        int ofx_start_idx;\n        if (ofx_start == false &&\n            (\n              (libofx_context->currentFileType() == OFX &&\n               ((ofx_start_idx = s_buffer.find(\"<OFX>\")) !=\n                string::npos || (ofx_start_idx = s_buffer.find(\"<ofx>\")) != string::npos))\n              || (libofx_context->currentFileType() == OFC &&\n                  ((ofx_start_idx = s_buffer.find(\"<OFC>\")) != string::npos ||\n                   (ofx_start_idx = s_buffer.find(\"<ofc>\")) != string::npos))\n            )\n           )\n        {\n          ofx_start = true;\n          if (file_is_xml == false)\n          {\n            s_buffer.erase(0, ofx_start_idx); //Fix for really broken files that don't have a newline after the header.\n          }\n          message_out(DEBUG, \"ofx_proc_file():<OFX> or <OFC> has been found\");\n\n          if (file_is_xml == true)\n          {\n            static char sp_charset_fixed[] = \"SP_CHARSET_FIXED=1\";\n            if (putenv(sp_charset_fixed) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n            /* Normally the following would be \"xml\".\n             * Unfortunately, opensp's generic api will garble UTF-8 if this is\n             * set to xml.  So we set any single byte encoding to avoid messing\n             * up UTF-8.  Unfortunately this means that non-UTF-8 files will not\n             * get properly translated.  We'd need to manually detect the\n             * encoding in the XML header and convert the xml with iconv like we\n             * do for SGML to work around the problem.  Most unfortunate. */\n            static char sp_encoding[] = \"SP_ENCODING=ms-dos\";\n            if (putenv(sp_encoding) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n          }\n          else\n          {\n            static char sp_charset_fixed[] = \"SP_CHARSET_FIXED=1\";\n            if (putenv(sp_charset_fixed) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n            static char sp_encoding[] = \"SP_ENCODING=ms-dos\"; //Any single byte encoding will do, we don't want opensp messing up UTF-8;\n            if (putenv(sp_encoding) != 0)\n            {\n              message_out(ERROR, \"ofx_proc_file(): putenv failed\");\n            }\n#ifdef HAVE_ICONV\n            string fromcode;\n            string tocode;\n            if (ofx_encoding.compare(\"USASCII\") == 0)\n            {\n              if (ofx_charset.compare(\"ISO-8859-1\") == 0 || ofx_charset.compare(\"8859-1\") == 0)\n              {\n                //Only \"ISO-8859-1\" is actually a legal value, but since the banks follows the spec SO well...\n                fromcode = \"ISO-8859-1\";\n              }\n              else if (ofx_charset.compare(\"1252\") == 0 || ofx_charset.compare(\"CP1252\") == 0)\n              {\n                //Only \"1252\" is actually a legal value, but since the banks follows the spec SO well...\n                fromcode = \"CP1252\";\n              }\n              else if (ofx_charset.compare(\"NONE\") == 0)\n              {\n                fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;\n              }\n              else\n              {\n                fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;\n              }\n            }\n            else if (ofx_encoding.compare(\"UTF-8\") == 0 || ofx_encoding.compare(\"UNICODE\") == 0)\n            {\n              //While \"UNICODE\" isn't a legal value, some cyrilic files do specify it as such...\n              fromcode = \"UTF-8\";\n            }\n            else\n            {\n              fromcode = LIBOFX_DEFAULT_INPUT_ENCODING;\n            }\n            tocode = LIBOFX_DEFAULT_OUTPUT_ENCODING;\n            message_out(DEBUG, \"ofx_proc_file(): Setting up iconv for fromcode: \" + fromcode + \", tocode: \" + tocode);\n            conversion_descriptor = iconv_open (tocode.c_str(), fromcode.c_str());\n#endif\n          }\n        }\n        else\n        {\n          //We are still in the headers\n          if ((header_separator_idx = s_buffer.find(':')) != string::npos)\n          {\n            //Header processing\n            header_name.assign(s_buffer.substr(0, header_separator_idx));\n            header_value.assign(s_buffer.substr(header_separator_idx + 1));\n            while ( header_value[header_value.length() -1 ] == '\\n' ||\n                    header_value[header_value.length() -1 ] == '\\r' )\n              header_value.erase(header_value.length() - 1);\n            message_out(DEBUG, \"ofx_proc_file():Header: \" + header_name + \" with value: \" + header_value + \" has been found\");\n            if (header_name.compare(\"ENCODING\") == 0)\n            {\n              ofx_encoding.assign(header_value);\n            }\n            if (header_name.compare(\"CHARSET\") == 0)\n            {\n              ofx_charset.assign(header_value);\n            }\n          }\n        }\n\n        if (file_is_xml == true || (ofx_start == true && ofx_end == false))\n        {\n          if (ofx_start == true)\n          {\n            /* The above test won't help us if the <OFX> tag is on the same line\n             * as the xml header, but as opensp can't be used to parse it anyway\n             * this isn't a great loss for now.\n             */\n            s_buffer = sanitize_proprietary_tags(s_buffer);\n          }\n          //cout<< s_buffer<<\"\\n\";\n          if (file_is_xml == false)\n          {\n#ifdef HAVE_ICONV\n            size_t inbytesleft = strlen(s_buffer.c_str());\n            size_t outbytesleft = inbytesleft * 2 - 1;\n            iconv_buffer = (char*) malloc (inbytesleft * 2);\n            memset(iconv_buffer, 0, inbytesleft * 2);\n#if defined(OS_WIN32) || defined(__sun) || defined(__NetBSD__)\n            const char * inchar = (const char *)s_buffer.c_str();\n#else\n            char * inchar = (char *)s_buffer.c_str();\n#endif\n            char * outchar = iconv_buffer;\n            int iconv_retval = iconv (conversion_descriptor,\n                                      &inchar, &inbytesleft,\n                                      &outchar, &outbytesleft);\n            if (iconv_retval == -1)\n            {\n              message_out(ERROR, \"ofx_proc_file(): Conversion error\");\n            }\n            s_buffer = iconv_buffer;\n            free (iconv_buffer);\n#endif\n          }\n          //cout << s_buffer << \"\\n\";\n          tmp_file.write(s_buffer.c_str(), s_buffer.length());\n        }\n\n        if (ofx_start == true &&\n            (\n              (libofx_context->currentFileType() == OFX &&\n               ((ofx_start_idx = s_buffer.find(\"</OFX>\")) != string::npos ||\n                (ofx_start_idx = s_buffer.find(\"</ofx>\")) != string::npos))\n              || (libofx_context->currentFileType() == OFC &&\n                  ((ofx_start_idx = s_buffer.find(\"</OFC>\")) != string::npos ||\n                   (ofx_start_idx = s_buffer.find(\"</ofc>\")) != string::npos))\n            )\n           )\n        {\n          ofx_end = true;\n          message_out(DEBUG, \"ofx_proc_file():</OFX> or </OFC>  has been found\");\n        }\n\n      }\n      while (!input_file.eof() && !input_file.bad());\n    }\n    input_file.close();\n    tmp_file.close();\n#ifdef HAVE_ICONV\n    if (file_is_xml == false)\n    {\n      iconv_close(conversion_descriptor);\n    }\n#endif\n    char filename_openspdtd[255];\n    char filename_dtd[255];\n    char filename_ofx[255];\n    strncpy(filename_openspdtd, find_dtd(ctx, OPENSPDCL_FILENAME).c_str(), 255); //The opensp sgml dtd file\n    if (libofx_context->currentFileType() == OFX)\n    {\n      strncpy(filename_dtd, find_dtd(ctx, OFX160DTD_FILENAME).c_str(), 255); //The ofx dtd file\n    }\n    else if (libofx_context->currentFileType() == OFC)\n    {\n      strncpy(filename_dtd, find_dtd(ctx, OFCDTD_FILENAME).c_str(), 255); //The ofc dtd file\n    }\n    else\n    {\n      message_out(ERROR, string(\"ofx_proc_file(): Error unknown file format for the OFX parser\"));\n    }\n\n    if ((string)filename_dtd != \"\" && (string)filename_openspdtd != \"\")\n    {\n      strncpy(filename_ofx, tmp_filename, 255); //The processed ofx file\n      filenames[0] = filename_openspdtd;\n      filenames[1] = filename_dtd;\n      filenames[2] = filename_ofx;\n      if (libofx_context->currentFileType() == OFX)\n      {\n        ofx_proc_sgml(libofx_context, 3, filenames);\n      }\n      else if (libofx_context->currentFileType() == OFC)\n      {\n        ofc_proc_sgml(libofx_context, 3, filenames);\n      }\n      else\n      {\n        message_out(ERROR, string(\"ofx_proc_file(): Error unknown file format for the OFX parser\"));\n      }\n      if (remove(tmp_filename) != 0)\n      {\n        message_out(ERROR, \"ofx_proc_file(): Error deleting temporary file \" + string(tmp_filename));\n      }\n    }\n    else\n    {\n      message_out(ERROR, \"ofx_proc_file(): FATAL: Missing DTD, aborting\");\n    }\n  }\n  else\n  {\n    message_out(ERROR, \"ofx_proc_file():No input file specified\");\n  }\n  return 0;\n}\n\n\n/**\n   This function will strip all the OFX proprietary tags and SGML comments from the SGML string passed to it\n*/\n\nstring sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; //Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  size_t input_string_size = input_string.size();\n\n  // Minimum workaround to prevent buffer overflow: Stop iterating\n  // once the (fixed!) size of the output buffers is reached. In\n  // response to\n  // https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0317\n  //\n  // However, this code is a huge mess anyway and is in no way\n  // anything like up-to-date C++ code. Please, anyone, replace it\n  // with something more modern. Thanks. - cstim, 2017-09-17.\n  for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '/')\n      {\n        //We are now in a closing tag\n        closing_tag_open = true;\n        //cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;\n        if (strncmp(tagname, &(input_string.c_str()[i+2]), strlen(tagname)) != 0)\n        {\n          //If it is the begining of an other tag\n          //cout<<\"DIFFERENT!\"<<endl;\n          crop_end_idx = i - 1;\n          strip = true;\n        }\n        else\n        {\n          //Otherwise, it is the start of the closing tag of the proprietary tag\n          proprietary_closing_tag = true;\n        }\n      }\n      else if (proprietary_tag == true)\n      {\n        //It is the start of a new tag, following a proprietary tag\n        crop_end_idx = i - 1;\n        strip = true;\n      }\n    }\n    else if (input_string.c_str()[i] == '>')\n    {\n      tag_open = false;\n      closing_tag_open = false;\n      tagname[tagname_idx] = 0;\n      tagname_idx = 0;\n      if (proprietary_closing_tag == true)\n      {\n        crop_end_idx = i;\n        strip = true;\n      }\n    }\n    else if (tag_open == true && closing_tag_open == false)\n    {\n      if (input_string.c_str()[i] == '.')\n      {\n        if (proprietary_tag != true)\n        {\n          orig_tag_open_idx = tag_open_idx;\n          proprietary_tag = true;\n        }\n      }\n      tagname[tagname_idx] = input_string.c_str()[i];\n      tagname_idx++;\n    }\n    //cerr <<i<<endl;\n    if (strip == true && orig_tag_open_idx < input_string.size())\n    {\n      input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);\n      message_out(INFO, \"sanitize_proprietary_tags() (end tag or new tag) removed: \" + string(buffer));\n      input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);\n      i = orig_tag_open_idx - 1;\n      proprietary_tag = false;\n      proprietary_closing_tag = false;\n      closing_tag_open = false;\n      tag_open = false;\n      strip = false;\n\n      input_string_size = input_string.size();\n    }\n\n  }//end for\n  if (proprietary_tag == true && orig_tag_open_idx < input_string.size())\n  {\n    if (crop_end_idx == 0)   //no closing tag\n    {\n      crop_end_idx = input_string.size() - 1;\n    }\n    input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx);\n    message_out(INFO, \"sanitize_proprietary_tags() (end of line) removed: \" + string(buffer));\n    input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1);\n    input_string_size = input_string.size();\n  }\n  return input_string;\n}\n\n\n#ifdef OS_WIN32\nstatic std::string get_dtd_installation_directory()\n{\n  // Partial implementation of\n  // http://developer.gnome.org/doc/API/2.0/glib/glib-Windows-Compatibility-Functions.html#g-win32-get-package-installation-directory\n  char ch_fn[MAX_PATH], *p;\n  std::string str_fn;\n\n  if (!GetModuleFileName(NULL, ch_fn, MAX_PATH)) return \"\";\n\n  if ((p = strrchr(ch_fn, '\\\\')) != NULL)\n    * p = '\\0';\n\n  p = strrchr(ch_fn, '\\\\');\n  if (p && (_stricmp(p + 1, \"bin\") == 0 ||\n            _stricmp(p + 1, \"lib\") == 0))\n    *p = '\\0';\n\n  str_fn = ch_fn;\n  str_fn += \"\\\\share\\\\libofx\\\\dtd\";\n\n  return str_fn;\n}\n#endif\n\n\n/**\n   This function will try to find a DTD matching the requested_version and return the full path of the DTD found (or an empty string if unsuccessful)\n   *\n   Please note that currently the function will ALWAYS look for version 160, since OpenSP can't parse the 201 DTD correctly\n\n   It will look, in (order)\n\n   1- The environment variable OFX_DTD_PATH (if present)\n   2- On windows only, a relative path specified by get_dtd_installation_directory()\n   3- The path specified by the makefile in MAKEFILE_DTD_PATH, thru LIBOFX_DTD_DIR in configure (if present)\n   4- Any hardcoded paths in DTD_SEARCH_PATH\n*/\nstd::string find_dtd(LibofxContextPtr ctx, const std::string& dtd_filename)\n{\n  string dtd_path_filename;\n  char *env_dtd_path;\n\n  dtd_path_filename = reinterpret_cast<const LibofxContext*>(ctx)->dtdDir();\n  if (!dtd_path_filename.empty())\n  {\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (dtd_file)\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n\n#ifdef OS_WIN32\n  dtd_path_filename = get_dtd_installation_directory();\n  if (!dtd_path_filename.empty())\n  {\n    dtd_path_filename.append(DIRSEP);\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (dtd_file)\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n#endif\n  /* Search in environement variable OFX_DTD_PATH */\n  env_dtd_path = getenv(\"OFX_DTD_PATH\");\n  if (env_dtd_path)\n  {\n    dtd_path_filename.append(env_dtd_path);\n    dtd_path_filename.append(DIRSEP);\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (!dtd_file)\n    {\n      message_out(STATUS, \"find_dtd():OFX_DTD_PATH env variable was was present, but unable to open the file \" + dtd_path_filename);\n    }\n    else\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n\n  for (int i = 0; i < DTD_SEARCH_PATH_NUM; i++)\n  {\n    dtd_path_filename = DTD_SEARCH_PATH[i];\n    dtd_path_filename.append(DIRSEP);\n    dtd_path_filename.append(dtd_filename);\n    ifstream dtd_file(dtd_path_filename.c_str());\n    if (!dtd_file)\n    {\n      message_out(DEBUG, \"find_dtd():Unable to open the file \" + dtd_path_filename);\n    }\n    else\n    {\n      message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n      return dtd_path_filename;\n    }\n  }\n\n  /* Last resort, look in source tree relative path (useful for development) */\n  dtd_path_filename = \"\";\n  dtd_path_filename.append(\"..\");\n  dtd_path_filename.append(DIRSEP);\n  dtd_path_filename.append(\"dtd\");\n  dtd_path_filename.append(DIRSEP);\n  dtd_path_filename.append(dtd_filename);\n  ifstream dtd_file(dtd_path_filename.c_str());\n  if (!dtd_file)\n  {\n    message_out(DEBUG, \"find_dtd(): Unable to open the file \" + dtd_path_filename + \", most likely we are not in the source tree.\");\n  }\n  else\n  {\n    message_out(STATUS, \"find_dtd():DTD found: \" + dtd_path_filename);\n    return dtd_path_filename;\n  }\n\n\n  message_out(ERROR, \"find_dtd():Unable to find the DTD named \" + dtd_filename);\n  return \"\";\n}\n\n\n"], "filenames": ["lib/ofx_preproc.cpp"], "buggy_code_start_loc": [420], "buggy_code_end_loc": [444], "fixing_code_start_loc": [419], "fixing_code_end_loc": [451], "type": "CWE-119", "message": "An memory corruption vulnerability exists in the .SVG parsing functionality of Computerinsel Photoline 20.02. A specially crafted .SVG file can cause a vulnerability resulting in memory corruption, which can potentially lead to arbitrary code execution. An attacker can send a specific .SVG file to trigger this vulnerability.", "other": {"cve": {"id": "CVE-2017-2920", "sourceIdentifier": "talos-cna@cisco.com", "published": "2017-10-05T19:29:00.260", "lastModified": "2022-06-13T19:18:01.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An memory corruption vulnerability exists in the .SVG parsing functionality of Computerinsel Photoline 20.02. A specially crafted .SVG file can cause a vulnerability resulting in memory corruption, which can potentially lead to arbitrary code execution. An attacker can send a specific .SVG file to trigger this vulnerability."}, {"lang": "es", "value": "Existe una vulnerabilidad explotable de desbordamiento de b\u00fafer en la funcionalidad de an\u00e1lisis sint\u00e1ctico de etiquetas de LibOFX 0.9.11. Un archivo OFX especialmente manipulado puede provocar una escritura fuera de l\u00edmites que d\u00e9 lugar a un desbordamiento de b\u00fafer en la pila. Un atacante puede crear un archivo OFX malicioso para provocar esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "talos-cna@cisco.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pl32:photoline:20.02:*:*:*:*:*:*:*", "matchCriteriaId": "F60D6566-A566-4FC8-BEA9-7EFC7E8721A6"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/101186", "source": "talos-cna@cisco.com", "tags": ["Broken Link"]}, {"url": "https://github.com/libofx/libofx/commit/a70934eea95c76a7737b83773bffe8738935082d", "source": "talos-cna@cisco.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201908-26", "source": "talos-cna@cisco.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0427", "source": "talos-cna@cisco.com", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libofx/libofx/commit/a70934eea95c76a7737b83773bffe8738935082d"}}