{"buggy_code": ["/**\n * @file\n * IMAP helper functions\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012-2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_util IMAP helper functions\n *\n * IMAP helper functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"lib.h\"\n#include \"bcache/lib.h\"\n#include \"adata.h\"\n#include \"edata.h\"\n#include \"mdata.h\"\n#include \"msn.h\"\n#include \"mutt_account.h\"\n#include \"mutt_globals.h\"\n#include \"options.h\"\n#ifdef USE_HCACHE\n#include \"hcache/lib.h\"\n#endif\n\n/**\n * imap_adata_find - Find the Account data for this path\n * @param path  Path to search for\n * @param adata Imap Account data\n * @param mdata Imap Mailbox data\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_adata_find(const char *path, struct ImapAccountData **adata,\n                    struct ImapMboxData **mdata)\n{\n  struct ConnAccount cac = { { 0 } };\n  struct ImapAccountData *tmp_adata = NULL;\n  char tmp[1024];\n\n  if (imap_parse_path(path, &cac, tmp, sizeof(tmp)) < 0)\n    return -1;\n\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != MUTT_IMAP)\n      continue;\n\n    tmp_adata = np->adata;\n    if (!tmp_adata)\n      continue;\n    if (imap_account_match(&tmp_adata->conn->account, &cac))\n    {\n      *mdata = imap_mdata_new(tmp_adata, tmp);\n      *adata = tmp_adata;\n      return 0;\n    }\n  }\n  mutt_debug(LL_DEBUG3, \"no ImapAccountData found\\n\");\n  return -1;\n}\n\n/**\n * imap_mdata_cache_reset - Release and clear cache data of ImapMboxData structure\n * @param mdata Imap Mailbox data\n */\nvoid imap_mdata_cache_reset(struct ImapMboxData *mdata)\n{\n  mutt_hash_free(&mdata->uid_hash);\n  imap_msn_free(&mdata->msn);\n  mutt_bcache_close(&mdata->bcache);\n}\n\n/**\n * imap_get_parent - Get an IMAP folder's parent\n * @param mbox   Mailbox whose parent is to be determined\n * @param delim  Path delimiter\n * @param buf    Buffer for the result\n * @param buflen Length of the buffer\n */\nvoid imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)\n{\n  /* Make a copy of the mailbox name, but only if the pointers are different */\n  if (mbox != buf)\n    mutt_str_copy(buf, mbox, buflen);\n\n  int n = mutt_str_len(buf);\n\n  /* Let's go backwards until the next delimiter\n   *\n   * If buf[n] is a '/', the first n-- will allow us\n   * to ignore it. If it isn't, then buf looks like\n   * \"/aaaaa/bbbb\". There is at least one \"b\", so we can't skip\n   * the \"/\" after the 'a's.\n   *\n   * If buf == '/', then n-- => n == 0, so the loop ends\n   * immediately */\n  for (n--; (n >= 0) && (buf[n] != delim); n--)\n    ; // do nothing\n\n  /* We stopped before the beginning. There is a trailing slash.  */\n  if (n > 0)\n  {\n    /* Strip the trailing delimiter.  */\n    buf[n] = '\\0';\n  }\n  else\n  {\n    buf[0] = (n == 0) ? delim : '\\0';\n  }\n}\n\n/**\n * imap_get_parent_path - Get the path of the parent folder\n * @param path   Mailbox whose parent is to be determined\n * @param buf    Buffer for the result\n * @param buflen Length of the buffer\n *\n * Provided an imap path, returns in buf the parent directory if\n * existent. Else returns the same path.\n */\nvoid imap_get_parent_path(const char *path, char *buf, size_t buflen)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n  char mbox[1024];\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n  {\n    mutt_str_copy(buf, path, buflen);\n    return;\n  }\n\n  /* Gets the parent mbox in mbox */\n  imap_get_parent(mdata->name, adata->delim, mbox, sizeof(mbox));\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(buf, buflen, &adata->conn->account, mbox);\n  imap_mdata_free((void *) &mdata);\n}\n\n/**\n * imap_clean_path - Cleans an IMAP path using imap_fix_path\n * @param path Path to be cleaned\n * @param plen Length of the buffer\n *\n * Does it in place.\n */\nvoid imap_clean_path(char *path, size_t plen)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n    return;\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(path, plen, &adata->conn->account, mdata->name);\n  imap_mdata_free((void *) &mdata);\n}\n\n/**\n * imap_get_field - Get connection login credentials - Implements ConnAccount::get_field()\n */\nstatic const char *imap_get_field(enum ConnAccountField field, void *gf_data)\n{\n  switch (field)\n  {\n    case MUTT_CA_LOGIN:\n      return cs_subset_string(NeoMutt->sub, \"imap_login\");\n    case MUTT_CA_USER:\n      return cs_subset_string(NeoMutt->sub, \"imap_user\");\n    case MUTT_CA_PASS:\n      return cs_subset_string(NeoMutt->sub, \"imap_pass\");\n    case MUTT_CA_OAUTH_CMD:\n      return cs_subset_string(NeoMutt->sub, \"imap_oauth_refresh_command\");\n    case MUTT_CA_HOST:\n    default:\n      return NULL;\n  }\n}\n\n#ifdef USE_HCACHE\n/**\n * imap_msn_index_to_uid_seqset - Convert MSN index of UIDs to Seqset\n * @param buf   Buffer for the result\n * @param mdata Imap Mailbox data\n *\n * Generates a seqseq of the UIDs in msn_index to persist in the header cache.\n * Empty spots are stored as 0.\n */\nstatic void imap_msn_index_to_uid_seqset(struct Buffer *buf, struct ImapMboxData *mdata)\n{\n  int first = 1, state = 0;\n  unsigned int cur_uid = 0, last_uid = 0;\n  unsigned int range_begin = 0, range_end = 0;\n  const size_t max_msn = imap_msn_highest(&mdata->msn);\n\n  for (unsigned int msn = 1; msn <= max_msn + 1; msn++)\n  {\n    bool match = false;\n    if (msn <= max_msn)\n    {\n      struct Email *e_cur = imap_msn_get(&mdata->msn, msn - 1);\n      cur_uid = e_cur ? imap_edata_get(e_cur)->uid : 0;\n      if (!state || (cur_uid && ((cur_uid - 1) == last_uid)))\n        match = true;\n      last_uid = cur_uid;\n    }\n\n    if (match)\n    {\n      switch (state)\n      {\n        case 1: /* single: convert to a range */\n          state = 2;\n          /* fall through */\n        case 2: /* extend range ending */\n          range_end = cur_uid;\n          break;\n        default:\n          state = 1;\n          range_begin = cur_uid;\n          break;\n      }\n    }\n    else if (state)\n    {\n      if (first)\n        first = 0;\n      else\n        mutt_buffer_addch(buf, ',');\n\n      if (state == 1)\n        mutt_buffer_add_printf(buf, \"%u\", range_begin);\n      else if (state == 2)\n        mutt_buffer_add_printf(buf, \"%u:%u\", range_begin, range_end);\n\n      state = 1;\n      range_begin = cur_uid;\n    }\n  }\n}\n\n/**\n * imap_hcache_namer - Generate a filename for the header cache - Implements ::hcache_namer_t\n */\nstatic void imap_hcache_namer(const char *path, struct Buffer *dest)\n{\n  mutt_buffer_printf(dest, \"%s.hcache\", path);\n}\n\n/**\n * imap_hcache_open - Open a header cache\n * @param adata Imap Account data\n * @param mdata Imap Mailbox data\n */\nvoid imap_hcache_open(struct ImapAccountData *adata, struct ImapMboxData *mdata)\n{\n  if (!adata || !mdata)\n    return;\n\n  if (mdata->hcache)\n    return;\n\n  struct HeaderCache *hc = NULL;\n  struct Buffer *mbox = mutt_buffer_pool_get();\n  struct Buffer *cachepath = mutt_buffer_pool_get();\n\n  imap_cachepath(adata->delim, mdata->name, mbox);\n\n  if (strstr(mutt_buffer_string(mbox), \"/../\") ||\n      mutt_str_equal(mutt_buffer_string(mbox), \"..\") ||\n      mutt_strn_equal(mutt_buffer_string(mbox), \"../\", 3))\n  {\n    goto cleanup;\n  }\n  size_t len = mutt_buffer_len(mbox);\n  if ((len > 3) && (strcmp(mutt_buffer_string(mbox) + len - 3, \"/..\") == 0))\n    goto cleanup;\n\n  struct Url url = { 0 };\n  mutt_account_tourl(&adata->conn->account, &url);\n  url.path = mbox->data;\n  url_tobuffer(&url, cachepath, U_PATH);\n\n  const char *const c_header_cache =\n      cs_subset_path(NeoMutt->sub, \"header_cache\");\n  hc = mutt_hcache_open(c_header_cache, mutt_buffer_string(cachepath), imap_hcache_namer);\n\ncleanup:\n  mutt_buffer_pool_release(&mbox);\n  mutt_buffer_pool_release(&cachepath);\n  mdata->hcache = hc;\n}\n\n/**\n * imap_hcache_close - Close the header cache\n * @param mdata Imap Mailbox data\n */\nvoid imap_hcache_close(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return;\n\n  mutt_hcache_close(mdata->hcache);\n  mdata->hcache = NULL;\n}\n\n/**\n * imap_hcache_get - Get a header cache entry by its UID\n * @param mdata Imap Mailbox data\n * @param uid   UID to find\n * @retval ptr Email\n * @retval NULL Failure\n */\nstruct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid)\n{\n  if (!mdata->hcache)\n    return NULL;\n\n  char key[16];\n\n  sprintf(key, \"/%u\", uid);\n  struct HCacheEntry hce =\n      mutt_hcache_fetch(mdata->hcache, key, mutt_str_len(key), mdata->uidvalidity);\n  if (!hce.email && hce.uidvalidity)\n  {\n    mutt_debug(LL_DEBUG3, \"hcache uidvalidity mismatch: %u\\n\", hce.uidvalidity);\n  }\n\n  return hce.email;\n}\n\n/**\n * imap_hcache_put - Add an entry to the header cache\n * @param mdata Imap Mailbox data\n * @param e     Email\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_put(struct ImapMboxData *mdata, struct Email *e)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  char key[16];\n\n  sprintf(key, \"/%u\", imap_edata_get(e)->uid);\n  return mutt_hcache_store(mdata->hcache, key, mutt_str_len(key), e, mdata->uidvalidity);\n}\n\n/**\n * imap_hcache_del - Delete an item from the header cache\n * @param mdata Imap Mailbox data\n * @param uid   UID of entry to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  char key[16];\n\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete_record(mdata->hcache, key, mutt_str_len(key));\n}\n\n/**\n * imap_hcache_store_uid_seqset - Store a UID Sequence Set in the header cache\n * @param mdata Imap Mailbox data\n * @retval  0 Success\n * @retval -1 Error\n */\nint imap_hcache_store_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  /* The seqset is likely large.  Preallocate to reduce reallocs */\n  struct Buffer buf = mutt_buffer_make(8192);\n  imap_msn_index_to_uid_seqset(&buf, mdata);\n\n  int rc = mutt_hcache_store_raw(mdata->hcache, \"/UIDSEQSET\", 10, buf.data,\n                                 mutt_buffer_len(&buf) + 1);\n  mutt_debug(LL_DEBUG3, \"Stored /UIDSEQSET %s\\n\", buf.data);\n  mutt_buffer_dealloc(&buf);\n  return rc;\n}\n\n/**\n * imap_hcache_clear_uid_seqset - Delete a UID Sequence Set from the header cache\n * @param mdata Imap Mailbox data\n * @retval  0 Success\n * @retval -1 Error\n */\nint imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  return mutt_hcache_delete_record(mdata->hcache, \"/UIDSEQSET\", 10);\n}\n\n/**\n * imap_hcache_get_uid_seqset - Get a UID Sequence Set from the header cache\n * @param mdata Imap Mailbox data\n * @retval ptr  UID Sequence Set\n * @retval NULL Error\n */\nchar *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return NULL;\n\n  char *seqset = NULL;\n  size_t dlen = 0;\n  char *hc_seqset = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDSEQSET\", 10, &dlen);\n  if (hc_seqset)\n  {\n    seqset = mutt_strn_dup(hc_seqset, dlen);\n    mutt_hcache_free_raw(mdata->hcache, (void **) &hc_seqset);\n  }\n  mutt_debug(LL_DEBUG3, \"Retrieved /UIDSEQSET %s\\n\", NONULL(seqset));\n\n  return seqset;\n}\n#endif\n\n/**\n * imap_parse_path - Parse an IMAP mailbox name into ConnAccount, name\n * @param path       Mailbox path to parse\n * @param cac        Account credentials\n * @param mailbox    Buffer for mailbox name\n * @param mailboxlen Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given an IMAP mailbox name, return host, port and a path IMAP servers will\n * recognize.\n */\nint imap_parse_path(const char *path, struct ConnAccount *cac, char *mailbox, size_t mailboxlen)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n\n  if (ImapPort == 0)\n  {\n    struct servent *service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(LL_DEBUG3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n\n  if (ImapsPort == 0)\n  {\n    struct servent *service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(LL_DEBUG3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n\n  /* Defaults */\n  cac->port = ImapPort;\n  cac->type = MUTT_ACCT_TYPE_IMAP;\n  cac->service = \"imap\";\n  cac->get_field = imap_get_field;\n\n  struct Url *url = url_parse(path);\n  if (!url)\n    return -1;\n\n  if ((url->scheme != U_IMAP) && (url->scheme != U_IMAPS))\n  {\n    url_free(&url);\n    return -1;\n  }\n\n  if ((mutt_account_fromurl(cac, url) < 0) || (cac->host[0] == '\\0'))\n  {\n    url_free(&url);\n    return -1;\n  }\n\n  if (url->scheme == U_IMAPS)\n    cac->flags |= MUTT_ACCT_SSL;\n\n  mutt_str_copy(mailbox, url->path, mailboxlen);\n\n  url_free(&url);\n\n  if ((cac->flags & MUTT_ACCT_SSL) && !(cac->flags & MUTT_ACCT_PORT))\n    cac->port = ImapsPort;\n\n  return 0;\n}\n\n/**\n * imap_mxcmp - Compare mailbox names, giving priority to INBOX\n * @param mx1 First mailbox name\n * @param mx2 Second mailbox name\n * @retval <0 First mailbox precedes Second mailbox\n * @retval  0 Mailboxes are the same\n * @retval >0 Second mailbox precedes First mailbox\n *\n * Like a normal sort function except that \"INBOX\" will be sorted to the\n * beginning of the list.\n */\nint imap_mxcmp(const char *mx1, const char *mx2)\n{\n  char *b1 = NULL;\n  char *b2 = NULL;\n  int rc;\n\n  if (!mx1 || (*mx1 == '\\0'))\n    mx1 = \"INBOX\";\n  if (!mx2 || (*mx2 == '\\0'))\n    mx2 = \"INBOX\";\n  if (mutt_istr_equal(mx1, \"INBOX\") && mutt_istr_equal(mx2, \"INBOX\"))\n  {\n    return 0;\n  }\n\n  b1 = mutt_mem_malloc(strlen(mx1) + 1);\n  b2 = mutt_mem_malloc(strlen(mx2) + 1);\n\n  imap_fix_path('\\0', mx1, b1, strlen(mx1) + 1);\n  imap_fix_path('\\0', mx2, b2, strlen(mx2) + 1);\n\n  rc = mutt_str_cmp(b1, b2);\n  FREE(&b1);\n  FREE(&b2);\n\n  return rc;\n}\n\n/**\n * imap_pretty_mailbox - Prettify an IMAP mailbox name\n * @param path    Mailbox name to be tidied\n * @param pathlen Length of path\n * @param folder  Path to use for '+' abbreviations\n *\n * Called by mutt_pretty_mailbox() to make IMAP paths look nice.\n */\nvoid imap_pretty_mailbox(char *path, size_t pathlen, const char *folder)\n{\n  struct ConnAccount cac_target = { { 0 } };\n  struct ConnAccount cac_home = { { 0 } };\n  struct Url url = { 0 };\n  const char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n  char target_mailbox[1024];\n  char home_mailbox[1024];\n\n  if (imap_parse_path(path, &cac_target, target_mailbox, sizeof(target_mailbox)) < 0)\n    return;\n\n  if (imap_path_probe(folder, NULL) != MUTT_IMAP)\n    goto fallback;\n\n  if (imap_parse_path(folder, &cac_home, home_mailbox, sizeof(home_mailbox)) < 0)\n    goto fallback;\n\n  tlen = mutt_str_len(target_mailbox);\n  hlen = mutt_str_len(home_mailbox);\n\n  /* check whether we can do '+' substitution */\n  if (tlen && imap_account_match(&cac_home, &cac_target) &&\n      mutt_strn_equal(home_mailbox, target_mailbox, hlen))\n  {\n    const char *const c_imap_delim_chars =\n        cs_subset_string(NeoMutt->sub, \"imap_delim_chars\");\n    if (hlen == 0)\n      home_match = true;\n    else if (c_imap_delim_chars)\n    {\n      for (delim = c_imap_delim_chars; *delim != '\\0'; delim++)\n        if (target_mailbox[hlen] == *delim)\n          home_match = true;\n    }\n  }\n\n  /* do the '+' substitution */\n  if (home_match)\n  {\n    *path++ = '+';\n    /* copy remaining path, skipping delimiter */\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target_mailbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n    return;\n  }\n\nfallback:\n  mutt_account_tourl(&cac_target, &url);\n  url.path = target_mailbox;\n  url_tostring(&url, path, pathlen, U_NO_FLAGS);\n}\n\n/**\n * imap_continue - display a message and ask the user if they want to go on\n * @param msg  Location of the error\n * @param resp Message for user\n * @retval #QuadOption Result, e.g. #MUTT_NO\n */\nenum QuadOption imap_continue(const char *msg, const char *resp)\n{\n  imap_error(msg, resp);\n  return mutt_yesorno(_(\"Continue?\"), MUTT_NO);\n}\n\n/**\n * imap_error - show an error and abort\n * @param where Location of the error\n * @param msg   Message for user\n */\nvoid imap_error(const char *where, const char *msg)\n{\n  mutt_error(\"%s [%s]\", where, msg);\n}\n\n/**\n * imap_fix_path - Fix up the imap path\n * @param delim     Delimiter specified by the server, '\\0' for `$imap_delim_chars`\n * @param mailbox   Mailbox path\n * @param path      Buffer for the result\n * @param plen      Length of buffer\n * @retval ptr      Fixed-up path\n *\n * @note if delim is '\\0', the first character in mailbox matching any of the\n * characters in `$imap_delim_chars` is used as a delimiter.\n *\n * This is necessary because the rest of neomutt assumes a hierarchy delimiter of\n * '/', which is not necessarily true in IMAP.  Additionally, the filesystem\n * converts multiple hierarchy delimiters into a single one, ie \"///\" is equal\n * to \"/\".  IMAP servers are not required to do this.\n * Moreover, IMAP servers may dislike the path ending with the delimiter.\n */\nchar *imap_fix_path(char delim, const char *mailbox, char *path, size_t plen)\n{\n  int i = 0;\n  for (; mailbox && *mailbox && (i < plen - 1); i++)\n  {\n    const char *const c_imap_delim_chars =\n        cs_subset_string(NeoMutt->sub, \"imap_delim_chars\");\n    if (*mailbox == delim || (!delim && strchr(NONULL(c_imap_delim_chars), *mailbox)))\n    {\n      delim = *mailbox;\n      /* Skip multiple occurrences of delim */\n      while (*mailbox && *(mailbox + 1) == delim)\n        mailbox++;\n    }\n    path[i] = *mailbox++;\n  }\n\n  /* Do not terminate with a delimiter */\n  if (i && path[i - 1] == delim)\n    i--;\n\n  /* Ensure null termination */\n  path[i] = '\\0';\n  return path;\n}\n\n/**\n * imap_cachepath - Generate a cache path for a mailbox\n * @param delim   Imap server delimiter\n * @param mailbox Mailbox name\n * @param dest    Buffer to store cache path\n */\nvoid imap_cachepath(char delim, const char *mailbox, struct Buffer *dest)\n{\n  const char *p = mailbox;\n  mutt_buffer_reset(dest);\n  if (!p)\n    return;\n\n  while (*p)\n  {\n    if (p[0] == delim)\n    {\n      mutt_buffer_addch(dest, '/');\n      /* simple way to avoid collisions with UIDs */\n      if ((p[1] >= '0') && (p[1] <= '9'))\n        mutt_buffer_addch(dest, '_');\n    }\n    else\n      mutt_buffer_addch(dest, *p);\n    p++;\n  }\n}\n\n/**\n * imap_get_literal_count - write number of bytes in an IMAP literal into bytes\n * @param[in]  buf   Number as a string\n * @param[out] bytes Resulting number\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_get_literal_count(const char *buf, unsigned int *bytes)\n{\n  char *pc = NULL;\n  char *pn = NULL;\n\n  if (!buf || !(pc = strchr(buf, '{')))\n    return -1;\n\n  pc++;\n  pn = pc;\n  while (isdigit((unsigned char) *pc))\n    pc++;\n  *pc = '\\0';\n  if (mutt_str_atoui(pn, bytes) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_get_qualifier - Get the qualifier from a tagged response\n * @param buf Command string to process\n * @retval ptr Start of the qualifier\n *\n * In a tagged response, skip tag and status for the qualifier message.\n * Used by imap_copy_message for TRYCREATE\n */\nchar *imap_get_qualifier(char *buf)\n{\n  char *s = buf;\n\n  /* skip tag */\n  s = imap_next_word(s);\n  /* skip OK/NO/BAD response */\n  s = imap_next_word(s);\n\n  return s;\n}\n\n/**\n * imap_next_word - Find where the next IMAP word begins\n * @param s Command string to process\n * @retval ptr Next IMAP word\n */\nchar *imap_next_word(char *s)\n{\n  bool quoted = false;\n\n  while (*s)\n  {\n    if (*s == '\\\\')\n    {\n      s++;\n      if (*s)\n        s++;\n      continue;\n    }\n    if (*s == '\\\"')\n      quoted = !quoted;\n    if (!quoted && IS_SPACE(*s))\n      break;\n    s++;\n  }\n\n  SKIPWS(s);\n  return s;\n}\n\n/**\n * imap_qualify_path - Make an absolute IMAP folder target\n * @param buf    Buffer for the result\n * @param buflen Length of buffer\n * @param cac    ConnAccount of the account\n * @param path   Path relative to the mailbox\n */\nvoid imap_qualify_path(char *buf, size_t buflen, struct ConnAccount *cac, char *path)\n{\n  struct Url url = { 0 };\n  mutt_account_tourl(cac, &url);\n  url.path = path;\n  url_tostring(&url, buf, buflen, U_NO_FLAGS);\n}\n\n/**\n * imap_quote_string - quote string according to IMAP rules\n * @param dest           Buffer for the result\n * @param dlen           Length of the buffer\n * @param src            String to be quoted\n * @param quote_backtick If true, quote backticks too\n *\n * Surround string with quotes, escape \" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for quote-chars */\n  dlen -= 3;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\"')\n    s++;\n  else\n    return;\n\n  while (*s)\n  {\n    if (*s == '\\\"')\n    {\n      *d = '\\0';\n      return;\n    }\n    if (*s == '\\\\')\n    {\n      s++;\n    }\n    if (*s)\n    {\n      *d = *s;\n      d++;\n      s++;\n    }\n  }\n  *d = '\\0';\n}\n\n/**\n * imap_munge_mbox_name - Quote awkward characters in a mailbox name\n * @param unicode true if Unicode is allowed\n * @param dest    Buffer to store safe mailbox name\n * @param dlen    Length of buffer\n * @param src     Mailbox name\n */\nvoid imap_munge_mbox_name(bool unicode, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_dup(src);\n  imap_utf_encode(unicode, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}\n\n/**\n * imap_unmunge_mbox_name - Remove quoting from a mailbox name\n * @param unicode true if Unicode is allowed\n * @param s       Mailbox name\n *\n * The string will be altered in-place.\n */\nvoid imap_unmunge_mbox_name(bool unicode, char *s)\n{\n  imap_unquote_string(s);\n\n  char *buf = mutt_str_dup(s);\n  if (buf)\n  {\n    imap_utf_decode(unicode, &buf);\n    strncpy(s, buf, strlen(s));\n  }\n\n  FREE(&buf);\n}\n\n/**\n * imap_keepalive - poll the current folder to keep the connection alive\n */\nvoid imap_keepalive(void)\n{\n  time_t now = mutt_date_epoch();\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != MUTT_IMAP)\n      continue;\n\n    struct ImapAccountData *adata = np->adata;\n    if (!adata || !adata->mailbox)\n      continue;\n\n    const short c_imap_keepalive =\n        cs_subset_number(NeoMutt->sub, \"imap_keepalive\");\n    if ((adata->state >= IMAP_AUTHENTICATED) && (now >= (adata->lastread + c_imap_keepalive)))\n      imap_check_mailbox(adata->mailbox, true);\n  }\n}\n\n/**\n * imap_wait_keepalive - Wait for a process to change state\n * @param pid Process ID to listen to\n * @retval num 'wstatus' from waitpid()\n */\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n\n  const bool c_imap_passive = cs_subset_bool(NeoMutt->sub, \"imap_passive\");\n  cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", true, NULL);\n  OptKeepQuiet = true;\n\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n\n  sigaction(SIGALRM, &act, &oldalrm);\n\n  const short c_imap_keepalive =\n      cs_subset_number(NeoMutt->sub, \"imap_keepalive\");\n  alarm(c_imap_keepalive);\n  while ((waitpid(pid, &rc, 0) < 0) && (errno == EINTR))\n  {\n    alarm(0); /* cancel a possibly pending alarm */\n    imap_keepalive();\n    alarm(c_imap_keepalive);\n  }\n\n  alarm(0); /* cancel a possibly pending alarm */\n\n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n  OptKeepQuiet = false;\n  cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", c_imap_passive, NULL);\n\n  return rc;\n}\n\n/**\n * imap_allow_reopen - Allow re-opening a folder upon expunge\n * @param m Mailbox\n */\nvoid imap_allow_reopen(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !adata->mailbox || (adata->mailbox != m) || !mdata)\n    return;\n  mdata->reopen |= IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_disallow_reopen - Disallow re-opening a folder upon expunge\n * @param m Mailbox\n */\nvoid imap_disallow_reopen(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !adata->mailbox || (adata->mailbox != m) || !mdata)\n    return;\n  mdata->reopen &= ~IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_account_match - Compare two Accounts\n * @param a1 First ConnAccount\n * @param a2 Second ConnAccount\n * @retval true Accounts match\n */\nbool imap_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2)\n{\n  if (!a1 || !a2)\n    return false;\n  if (a1->type != a2->type)\n    return false;\n  if (!mutt_istr_equal(a1->host, a2->host))\n    return false;\n  if ((a1->port != 0) && (a2->port != 0) && (a1->port != a2->port))\n    return false;\n  if (a1->flags & a2->flags & MUTT_ACCT_USER)\n    return strcmp(a1->user, a2->user) == 0;\n\n  const char *user = NONULL(Username);\n\n  const char *const c_imap_user = cs_subset_string(NeoMutt->sub, \"imap_user\");\n  if ((a1->type == MUTT_ACCT_TYPE_IMAP) && c_imap_user)\n    user = c_imap_user;\n\n  if (a1->flags & MUTT_ACCT_USER)\n    return strcmp(a1->user, user) == 0;\n  if (a2->flags & MUTT_ACCT_USER)\n    return strcmp(a2->user, user) == 0;\n\n  return true;\n}\n\n/**\n * mutt_seqset_iterator_new - Create a new Sequence Set Iterator\n * @param seqset Source Sequence Set\n * @retval ptr Newly allocated Sequence Set Iterator\n */\nstruct SeqsetIterator *mutt_seqset_iterator_new(const char *seqset)\n{\n  if (!seqset || (*seqset == '\\0'))\n    return NULL;\n\n  struct SeqsetIterator *iter = mutt_mem_calloc(1, sizeof(struct SeqsetIterator));\n  iter->full_seqset = mutt_str_dup(seqset);\n  iter->eostr = strchr(iter->full_seqset, '\\0');\n  iter->substr_cur = iter->substr_end = iter->full_seqset;\n\n  return iter;\n}\n\n/**\n * mutt_seqset_iterator_next - Get the next UID from a Sequence Set\n * @param[in]  iter Sequence Set Iterator\n * @param[out] next Next UID in set\n * @retval  0 Next sequence is generated\n * @retval  1 Iterator is finished\n * @retval -1 error\n */\nint mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n\n  return 0;\n}\n\n/**\n * mutt_seqset_iterator_free - Free a Sequence Set Iterator\n * @param[out] ptr Iterator to free\n */\nvoid mutt_seqset_iterator_free(struct SeqsetIterator **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct SeqsetIterator *iter = *ptr;\n  FREE(&iter->full_seqset);\n  FREE(ptr);\n}\n"], "fixing_code": ["/**\n * @file\n * IMAP helper functions\n *\n * @authors\n * Copyright (C) 1996-1998,2010,2012-2013 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009,2012 Brendan Cully <brendan@kublai.com>\n * Copyright (C) 2018 Richard Russon <rich@flatcap.org>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_util IMAP helper functions\n *\n * IMAP helper functions\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"lib.h\"\n#include \"bcache/lib.h\"\n#include \"adata.h\"\n#include \"edata.h\"\n#include \"mdata.h\"\n#include \"msn.h\"\n#include \"mutt_account.h\"\n#include \"mutt_globals.h\"\n#include \"options.h\"\n#ifdef USE_HCACHE\n#include \"hcache/lib.h\"\n#endif\n\n/**\n * imap_adata_find - Find the Account data for this path\n * @param path  Path to search for\n * @param adata Imap Account data\n * @param mdata Imap Mailbox data\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_adata_find(const char *path, struct ImapAccountData **adata,\n                    struct ImapMboxData **mdata)\n{\n  struct ConnAccount cac = { { 0 } };\n  struct ImapAccountData *tmp_adata = NULL;\n  char tmp[1024];\n\n  if (imap_parse_path(path, &cac, tmp, sizeof(tmp)) < 0)\n    return -1;\n\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != MUTT_IMAP)\n      continue;\n\n    tmp_adata = np->adata;\n    if (!tmp_adata)\n      continue;\n    if (imap_account_match(&tmp_adata->conn->account, &cac))\n    {\n      *mdata = imap_mdata_new(tmp_adata, tmp);\n      *adata = tmp_adata;\n      return 0;\n    }\n  }\n  mutt_debug(LL_DEBUG3, \"no ImapAccountData found\\n\");\n  return -1;\n}\n\n/**\n * imap_mdata_cache_reset - Release and clear cache data of ImapMboxData structure\n * @param mdata Imap Mailbox data\n */\nvoid imap_mdata_cache_reset(struct ImapMboxData *mdata)\n{\n  mutt_hash_free(&mdata->uid_hash);\n  imap_msn_free(&mdata->msn);\n  mutt_bcache_close(&mdata->bcache);\n}\n\n/**\n * imap_get_parent - Get an IMAP folder's parent\n * @param mbox   Mailbox whose parent is to be determined\n * @param delim  Path delimiter\n * @param buf    Buffer for the result\n * @param buflen Length of the buffer\n */\nvoid imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)\n{\n  /* Make a copy of the mailbox name, but only if the pointers are different */\n  if (mbox != buf)\n    mutt_str_copy(buf, mbox, buflen);\n\n  int n = mutt_str_len(buf);\n\n  /* Let's go backwards until the next delimiter\n   *\n   * If buf[n] is a '/', the first n-- will allow us\n   * to ignore it. If it isn't, then buf looks like\n   * \"/aaaaa/bbbb\". There is at least one \"b\", so we can't skip\n   * the \"/\" after the 'a's.\n   *\n   * If buf == '/', then n-- => n == 0, so the loop ends\n   * immediately */\n  for (n--; (n >= 0) && (buf[n] != delim); n--)\n    ; // do nothing\n\n  /* We stopped before the beginning. There is a trailing slash.  */\n  if (n > 0)\n  {\n    /* Strip the trailing delimiter.  */\n    buf[n] = '\\0';\n  }\n  else\n  {\n    buf[0] = (n == 0) ? delim : '\\0';\n  }\n}\n\n/**\n * imap_get_parent_path - Get the path of the parent folder\n * @param path   Mailbox whose parent is to be determined\n * @param buf    Buffer for the result\n * @param buflen Length of the buffer\n *\n * Provided an imap path, returns in buf the parent directory if\n * existent. Else returns the same path.\n */\nvoid imap_get_parent_path(const char *path, char *buf, size_t buflen)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n  char mbox[1024];\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n  {\n    mutt_str_copy(buf, path, buflen);\n    return;\n  }\n\n  /* Gets the parent mbox in mbox */\n  imap_get_parent(mdata->name, adata->delim, mbox, sizeof(mbox));\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(buf, buflen, &adata->conn->account, mbox);\n  imap_mdata_free((void *) &mdata);\n}\n\n/**\n * imap_clean_path - Cleans an IMAP path using imap_fix_path\n * @param path Path to be cleaned\n * @param plen Length of the buffer\n *\n * Does it in place.\n */\nvoid imap_clean_path(char *path, size_t plen)\n{\n  struct ImapAccountData *adata = NULL;\n  struct ImapMboxData *mdata = NULL;\n\n  if (imap_adata_find(path, &adata, &mdata) < 0)\n    return;\n\n  /* Returns a fully qualified IMAP url */\n  imap_qualify_path(path, plen, &adata->conn->account, mdata->name);\n  imap_mdata_free((void *) &mdata);\n}\n\n/**\n * imap_get_field - Get connection login credentials - Implements ConnAccount::get_field()\n */\nstatic const char *imap_get_field(enum ConnAccountField field, void *gf_data)\n{\n  switch (field)\n  {\n    case MUTT_CA_LOGIN:\n      return cs_subset_string(NeoMutt->sub, \"imap_login\");\n    case MUTT_CA_USER:\n      return cs_subset_string(NeoMutt->sub, \"imap_user\");\n    case MUTT_CA_PASS:\n      return cs_subset_string(NeoMutt->sub, \"imap_pass\");\n    case MUTT_CA_OAUTH_CMD:\n      return cs_subset_string(NeoMutt->sub, \"imap_oauth_refresh_command\");\n    case MUTT_CA_HOST:\n    default:\n      return NULL;\n  }\n}\n\n#ifdef USE_HCACHE\n/**\n * imap_msn_index_to_uid_seqset - Convert MSN index of UIDs to Seqset\n * @param buf   Buffer for the result\n * @param mdata Imap Mailbox data\n *\n * Generates a seqseq of the UIDs in msn_index to persist in the header cache.\n * Empty spots are stored as 0.\n */\nstatic void imap_msn_index_to_uid_seqset(struct Buffer *buf, struct ImapMboxData *mdata)\n{\n  int first = 1, state = 0;\n  unsigned int cur_uid = 0, last_uid = 0;\n  unsigned int range_begin = 0, range_end = 0;\n  const size_t max_msn = imap_msn_highest(&mdata->msn);\n\n  for (unsigned int msn = 1; msn <= max_msn + 1; msn++)\n  {\n    bool match = false;\n    if (msn <= max_msn)\n    {\n      struct Email *e_cur = imap_msn_get(&mdata->msn, msn - 1);\n      cur_uid = e_cur ? imap_edata_get(e_cur)->uid : 0;\n      if (!state || (cur_uid && ((cur_uid - 1) == last_uid)))\n        match = true;\n      last_uid = cur_uid;\n    }\n\n    if (match)\n    {\n      switch (state)\n      {\n        case 1: /* single: convert to a range */\n          state = 2;\n          /* fall through */\n        case 2: /* extend range ending */\n          range_end = cur_uid;\n          break;\n        default:\n          state = 1;\n          range_begin = cur_uid;\n          break;\n      }\n    }\n    else if (state)\n    {\n      if (first)\n        first = 0;\n      else\n        mutt_buffer_addch(buf, ',');\n\n      if (state == 1)\n        mutt_buffer_add_printf(buf, \"%u\", range_begin);\n      else if (state == 2)\n        mutt_buffer_add_printf(buf, \"%u:%u\", range_begin, range_end);\n\n      state = 1;\n      range_begin = cur_uid;\n    }\n  }\n}\n\n/**\n * imap_hcache_namer - Generate a filename for the header cache - Implements ::hcache_namer_t\n */\nstatic void imap_hcache_namer(const char *path, struct Buffer *dest)\n{\n  mutt_buffer_printf(dest, \"%s.hcache\", path);\n}\n\n/**\n * imap_hcache_open - Open a header cache\n * @param adata Imap Account data\n * @param mdata Imap Mailbox data\n */\nvoid imap_hcache_open(struct ImapAccountData *adata, struct ImapMboxData *mdata)\n{\n  if (!adata || !mdata)\n    return;\n\n  if (mdata->hcache)\n    return;\n\n  struct HeaderCache *hc = NULL;\n  struct Buffer *mbox = mutt_buffer_pool_get();\n  struct Buffer *cachepath = mutt_buffer_pool_get();\n\n  imap_cachepath(adata->delim, mdata->name, mbox);\n\n  if (strstr(mutt_buffer_string(mbox), \"/../\") ||\n      mutt_str_equal(mutt_buffer_string(mbox), \"..\") ||\n      mutt_strn_equal(mutt_buffer_string(mbox), \"../\", 3))\n  {\n    goto cleanup;\n  }\n  size_t len = mutt_buffer_len(mbox);\n  if ((len > 3) && (strcmp(mutt_buffer_string(mbox) + len - 3, \"/..\") == 0))\n    goto cleanup;\n\n  struct Url url = { 0 };\n  mutt_account_tourl(&adata->conn->account, &url);\n  url.path = mbox->data;\n  url_tobuffer(&url, cachepath, U_PATH);\n\n  const char *const c_header_cache =\n      cs_subset_path(NeoMutt->sub, \"header_cache\");\n  hc = mutt_hcache_open(c_header_cache, mutt_buffer_string(cachepath), imap_hcache_namer);\n\ncleanup:\n  mutt_buffer_pool_release(&mbox);\n  mutt_buffer_pool_release(&cachepath);\n  mdata->hcache = hc;\n}\n\n/**\n * imap_hcache_close - Close the header cache\n * @param mdata Imap Mailbox data\n */\nvoid imap_hcache_close(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return;\n\n  mutt_hcache_close(mdata->hcache);\n  mdata->hcache = NULL;\n}\n\n/**\n * imap_hcache_get - Get a header cache entry by its UID\n * @param mdata Imap Mailbox data\n * @param uid   UID to find\n * @retval ptr Email\n * @retval NULL Failure\n */\nstruct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid)\n{\n  if (!mdata->hcache)\n    return NULL;\n\n  char key[16];\n\n  sprintf(key, \"/%u\", uid);\n  struct HCacheEntry hce =\n      mutt_hcache_fetch(mdata->hcache, key, mutt_str_len(key), mdata->uidvalidity);\n  if (!hce.email && hce.uidvalidity)\n  {\n    mutt_debug(LL_DEBUG3, \"hcache uidvalidity mismatch: %u\\n\", hce.uidvalidity);\n  }\n\n  return hce.email;\n}\n\n/**\n * imap_hcache_put - Add an entry to the header cache\n * @param mdata Imap Mailbox data\n * @param e     Email\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_put(struct ImapMboxData *mdata, struct Email *e)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  char key[16];\n\n  sprintf(key, \"/%u\", imap_edata_get(e)->uid);\n  return mutt_hcache_store(mdata->hcache, key, mutt_str_len(key), e, mdata->uidvalidity);\n}\n\n/**\n * imap_hcache_del - Delete an item from the header cache\n * @param mdata Imap Mailbox data\n * @param uid   UID of entry to delete\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  char key[16];\n\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete_record(mdata->hcache, key, mutt_str_len(key));\n}\n\n/**\n * imap_hcache_store_uid_seqset - Store a UID Sequence Set in the header cache\n * @param mdata Imap Mailbox data\n * @retval  0 Success\n * @retval -1 Error\n */\nint imap_hcache_store_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  /* The seqset is likely large.  Preallocate to reduce reallocs */\n  struct Buffer buf = mutt_buffer_make(8192);\n  imap_msn_index_to_uid_seqset(&buf, mdata);\n\n  int rc = mutt_hcache_store_raw(mdata->hcache, \"/UIDSEQSET\", 10, buf.data,\n                                 mutt_buffer_len(&buf) + 1);\n  mutt_debug(LL_DEBUG3, \"Stored /UIDSEQSET %s\\n\", buf.data);\n  mutt_buffer_dealloc(&buf);\n  return rc;\n}\n\n/**\n * imap_hcache_clear_uid_seqset - Delete a UID Sequence Set from the header cache\n * @param mdata Imap Mailbox data\n * @retval  0 Success\n * @retval -1 Error\n */\nint imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return -1;\n\n  return mutt_hcache_delete_record(mdata->hcache, \"/UIDSEQSET\", 10);\n}\n\n/**\n * imap_hcache_get_uid_seqset - Get a UID Sequence Set from the header cache\n * @param mdata Imap Mailbox data\n * @retval ptr  UID Sequence Set\n * @retval NULL Error\n */\nchar *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return NULL;\n\n  char *seqset = NULL;\n  size_t dlen = 0;\n  char *hc_seqset = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDSEQSET\", 10, &dlen);\n  if (hc_seqset)\n  {\n    seqset = mutt_strn_dup(hc_seqset, dlen);\n    mutt_hcache_free_raw(mdata->hcache, (void **) &hc_seqset);\n  }\n  mutt_debug(LL_DEBUG3, \"Retrieved /UIDSEQSET %s\\n\", NONULL(seqset));\n\n  return seqset;\n}\n#endif\n\n/**\n * imap_parse_path - Parse an IMAP mailbox name into ConnAccount, name\n * @param path       Mailbox path to parse\n * @param cac        Account credentials\n * @param mailbox    Buffer for mailbox name\n * @param mailboxlen Length of buffer\n * @retval  0 Success\n * @retval -1 Failure\n *\n * Given an IMAP mailbox name, return host, port and a path IMAP servers will\n * recognize.\n */\nint imap_parse_path(const char *path, struct ConnAccount *cac, char *mailbox, size_t mailboxlen)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n\n  if (ImapPort == 0)\n  {\n    struct servent *service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(LL_DEBUG3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n\n  if (ImapsPort == 0)\n  {\n    struct servent *service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(LL_DEBUG3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n\n  /* Defaults */\n  cac->port = ImapPort;\n  cac->type = MUTT_ACCT_TYPE_IMAP;\n  cac->service = \"imap\";\n  cac->get_field = imap_get_field;\n\n  struct Url *url = url_parse(path);\n  if (!url)\n    return -1;\n\n  if ((url->scheme != U_IMAP) && (url->scheme != U_IMAPS))\n  {\n    url_free(&url);\n    return -1;\n  }\n\n  if ((mutt_account_fromurl(cac, url) < 0) || (cac->host[0] == '\\0'))\n  {\n    url_free(&url);\n    return -1;\n  }\n\n  if (url->scheme == U_IMAPS)\n    cac->flags |= MUTT_ACCT_SSL;\n\n  mutt_str_copy(mailbox, url->path, mailboxlen);\n\n  url_free(&url);\n\n  if ((cac->flags & MUTT_ACCT_SSL) && !(cac->flags & MUTT_ACCT_PORT))\n    cac->port = ImapsPort;\n\n  return 0;\n}\n\n/**\n * imap_mxcmp - Compare mailbox names, giving priority to INBOX\n * @param mx1 First mailbox name\n * @param mx2 Second mailbox name\n * @retval <0 First mailbox precedes Second mailbox\n * @retval  0 Mailboxes are the same\n * @retval >0 Second mailbox precedes First mailbox\n *\n * Like a normal sort function except that \"INBOX\" will be sorted to the\n * beginning of the list.\n */\nint imap_mxcmp(const char *mx1, const char *mx2)\n{\n  char *b1 = NULL;\n  char *b2 = NULL;\n  int rc;\n\n  if (!mx1 || (*mx1 == '\\0'))\n    mx1 = \"INBOX\";\n  if (!mx2 || (*mx2 == '\\0'))\n    mx2 = \"INBOX\";\n  if (mutt_istr_equal(mx1, \"INBOX\") && mutt_istr_equal(mx2, \"INBOX\"))\n  {\n    return 0;\n  }\n\n  b1 = mutt_mem_malloc(strlen(mx1) + 1);\n  b2 = mutt_mem_malloc(strlen(mx2) + 1);\n\n  imap_fix_path('\\0', mx1, b1, strlen(mx1) + 1);\n  imap_fix_path('\\0', mx2, b2, strlen(mx2) + 1);\n\n  rc = mutt_str_cmp(b1, b2);\n  FREE(&b1);\n  FREE(&b2);\n\n  return rc;\n}\n\n/**\n * imap_pretty_mailbox - Prettify an IMAP mailbox name\n * @param path    Mailbox name to be tidied\n * @param pathlen Length of path\n * @param folder  Path to use for '+' abbreviations\n *\n * Called by mutt_pretty_mailbox() to make IMAP paths look nice.\n */\nvoid imap_pretty_mailbox(char *path, size_t pathlen, const char *folder)\n{\n  struct ConnAccount cac_target = { { 0 } };\n  struct ConnAccount cac_home = { { 0 } };\n  struct Url url = { 0 };\n  const char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n  char target_mailbox[1024];\n  char home_mailbox[1024];\n\n  if (imap_parse_path(path, &cac_target, target_mailbox, sizeof(target_mailbox)) < 0)\n    return;\n\n  if (imap_path_probe(folder, NULL) != MUTT_IMAP)\n    goto fallback;\n\n  if (imap_parse_path(folder, &cac_home, home_mailbox, sizeof(home_mailbox)) < 0)\n    goto fallback;\n\n  tlen = mutt_str_len(target_mailbox);\n  hlen = mutt_str_len(home_mailbox);\n\n  /* check whether we can do '+' substitution */\n  if (tlen && imap_account_match(&cac_home, &cac_target) &&\n      mutt_strn_equal(home_mailbox, target_mailbox, hlen))\n  {\n    const char *const c_imap_delim_chars =\n        cs_subset_string(NeoMutt->sub, \"imap_delim_chars\");\n    if (hlen == 0)\n      home_match = true;\n    else if (c_imap_delim_chars)\n    {\n      for (delim = c_imap_delim_chars; *delim != '\\0'; delim++)\n        if (target_mailbox[hlen] == *delim)\n          home_match = true;\n    }\n  }\n\n  /* do the '+' substitution */\n  if (home_match)\n  {\n    *path++ = '+';\n    /* copy remaining path, skipping delimiter */\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target_mailbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n    return;\n  }\n\nfallback:\n  mutt_account_tourl(&cac_target, &url);\n  url.path = target_mailbox;\n  url_tostring(&url, path, pathlen, U_NO_FLAGS);\n}\n\n/**\n * imap_continue - display a message and ask the user if they want to go on\n * @param msg  Location of the error\n * @param resp Message for user\n * @retval #QuadOption Result, e.g. #MUTT_NO\n */\nenum QuadOption imap_continue(const char *msg, const char *resp)\n{\n  imap_error(msg, resp);\n  return mutt_yesorno(_(\"Continue?\"), MUTT_NO);\n}\n\n/**\n * imap_error - show an error and abort\n * @param where Location of the error\n * @param msg   Message for user\n */\nvoid imap_error(const char *where, const char *msg)\n{\n  mutt_error(\"%s [%s]\", where, msg);\n}\n\n/**\n * imap_fix_path - Fix up the imap path\n * @param delim     Delimiter specified by the server, '\\0' for `$imap_delim_chars`\n * @param mailbox   Mailbox path\n * @param path      Buffer for the result\n * @param plen      Length of buffer\n * @retval ptr      Fixed-up path\n *\n * @note if delim is '\\0', the first character in mailbox matching any of the\n * characters in `$imap_delim_chars` is used as a delimiter.\n *\n * This is necessary because the rest of neomutt assumes a hierarchy delimiter of\n * '/', which is not necessarily true in IMAP.  Additionally, the filesystem\n * converts multiple hierarchy delimiters into a single one, ie \"///\" is equal\n * to \"/\".  IMAP servers are not required to do this.\n * Moreover, IMAP servers may dislike the path ending with the delimiter.\n */\nchar *imap_fix_path(char delim, const char *mailbox, char *path, size_t plen)\n{\n  int i = 0;\n  for (; mailbox && *mailbox && (i < plen - 1); i++)\n  {\n    const char *const c_imap_delim_chars =\n        cs_subset_string(NeoMutt->sub, \"imap_delim_chars\");\n    if (*mailbox == delim || (!delim && strchr(NONULL(c_imap_delim_chars), *mailbox)))\n    {\n      delim = *mailbox;\n      /* Skip multiple occurrences of delim */\n      while (*mailbox && *(mailbox + 1) == delim)\n        mailbox++;\n    }\n    path[i] = *mailbox++;\n  }\n\n  /* Do not terminate with a delimiter */\n  if (i && path[i - 1] == delim)\n    i--;\n\n  /* Ensure null termination */\n  path[i] = '\\0';\n  return path;\n}\n\n/**\n * imap_cachepath - Generate a cache path for a mailbox\n * @param delim   Imap server delimiter\n * @param mailbox Mailbox name\n * @param dest    Buffer to store cache path\n */\nvoid imap_cachepath(char delim, const char *mailbox, struct Buffer *dest)\n{\n  const char *p = mailbox;\n  mutt_buffer_reset(dest);\n  if (!p)\n    return;\n\n  while (*p)\n  {\n    if (p[0] == delim)\n    {\n      mutt_buffer_addch(dest, '/');\n      /* simple way to avoid collisions with UIDs */\n      if ((p[1] >= '0') && (p[1] <= '9'))\n        mutt_buffer_addch(dest, '_');\n    }\n    else\n      mutt_buffer_addch(dest, *p);\n    p++;\n  }\n}\n\n/**\n * imap_get_literal_count - write number of bytes in an IMAP literal into bytes\n * @param[in]  buf   Number as a string\n * @param[out] bytes Resulting number\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_get_literal_count(const char *buf, unsigned int *bytes)\n{\n  char *pc = NULL;\n  char *pn = NULL;\n\n  if (!buf || !(pc = strchr(buf, '{')))\n    return -1;\n\n  pc++;\n  pn = pc;\n  while (isdigit((unsigned char) *pc))\n    pc++;\n  *pc = '\\0';\n  if (mutt_str_atoui(pn, bytes) < 0)\n    return -1;\n\n  return 0;\n}\n\n/**\n * imap_get_qualifier - Get the qualifier from a tagged response\n * @param buf Command string to process\n * @retval ptr Start of the qualifier\n *\n * In a tagged response, skip tag and status for the qualifier message.\n * Used by imap_copy_message for TRYCREATE\n */\nchar *imap_get_qualifier(char *buf)\n{\n  char *s = buf;\n\n  /* skip tag */\n  s = imap_next_word(s);\n  /* skip OK/NO/BAD response */\n  s = imap_next_word(s);\n\n  return s;\n}\n\n/**\n * imap_next_word - Find where the next IMAP word begins\n * @param s Command string to process\n * @retval ptr Next IMAP word\n */\nchar *imap_next_word(char *s)\n{\n  bool quoted = false;\n\n  while (*s)\n  {\n    if (*s == '\\\\')\n    {\n      s++;\n      if (*s)\n        s++;\n      continue;\n    }\n    if (*s == '\\\"')\n      quoted = !quoted;\n    if (!quoted && IS_SPACE(*s))\n      break;\n    s++;\n  }\n\n  SKIPWS(s);\n  return s;\n}\n\n/**\n * imap_qualify_path - Make an absolute IMAP folder target\n * @param buf    Buffer for the result\n * @param buflen Length of buffer\n * @param cac    ConnAccount of the account\n * @param path   Path relative to the mailbox\n */\nvoid imap_qualify_path(char *buf, size_t buflen, struct ConnAccount *cac, char *path)\n{\n  struct Url url = { 0 };\n  mutt_account_tourl(cac, &url);\n  url.path = path;\n  url_tostring(&url, buf, buflen, U_NO_FLAGS);\n}\n\n/**\n * imap_quote_string - quote string according to IMAP rules\n * @param dest           Buffer for the result\n * @param dlen           Length of the buffer\n * @param src            String to be quoted\n * @param quote_backtick If true, quote backticks too\n *\n * Surround string with quotes, escape \" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for quote-chars */\n  dlen -= 3;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\"')\n    s++;\n  else\n    return;\n\n  while (*s)\n  {\n    if (*s == '\\\"')\n    {\n      *d = '\\0';\n      return;\n    }\n    if (*s == '\\\\')\n    {\n      s++;\n    }\n    if (*s)\n    {\n      *d = *s;\n      d++;\n      s++;\n    }\n  }\n  *d = '\\0';\n}\n\n/**\n * imap_munge_mbox_name - Quote awkward characters in a mailbox name\n * @param unicode true if Unicode is allowed\n * @param dest    Buffer to store safe mailbox name\n * @param dlen    Length of buffer\n * @param src     Mailbox name\n */\nvoid imap_munge_mbox_name(bool unicode, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_dup(src);\n  imap_utf_encode(unicode, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}\n\n/**\n * imap_unmunge_mbox_name - Remove quoting from a mailbox name\n * @param unicode true if Unicode is allowed\n * @param s       Mailbox name\n *\n * The string will be altered in-place.\n */\nvoid imap_unmunge_mbox_name(bool unicode, char *s)\n{\n  imap_unquote_string(s);\n\n  char *buf = mutt_str_dup(s);\n  if (buf)\n  {\n    imap_utf_decode(unicode, &buf);\n    strncpy(s, buf, strlen(s));\n  }\n\n  FREE(&buf);\n}\n\n/**\n * imap_keepalive - poll the current folder to keep the connection alive\n */\nvoid imap_keepalive(void)\n{\n  time_t now = mutt_date_epoch();\n  struct Account *np = NULL;\n  TAILQ_FOREACH(np, &NeoMutt->accounts, entries)\n  {\n    if (np->type != MUTT_IMAP)\n      continue;\n\n    struct ImapAccountData *adata = np->adata;\n    if (!adata || !adata->mailbox)\n      continue;\n\n    const short c_imap_keepalive =\n        cs_subset_number(NeoMutt->sub, \"imap_keepalive\");\n    if ((adata->state >= IMAP_AUTHENTICATED) && (now >= (adata->lastread + c_imap_keepalive)))\n      imap_check_mailbox(adata->mailbox, true);\n  }\n}\n\n/**\n * imap_wait_keepalive - Wait for a process to change state\n * @param pid Process ID to listen to\n * @retval num 'wstatus' from waitpid()\n */\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n\n  const bool c_imap_passive = cs_subset_bool(NeoMutt->sub, \"imap_passive\");\n  cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", true, NULL);\n  OptKeepQuiet = true;\n\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n\n  sigaction(SIGALRM, &act, &oldalrm);\n\n  const short c_imap_keepalive =\n      cs_subset_number(NeoMutt->sub, \"imap_keepalive\");\n  alarm(c_imap_keepalive);\n  while ((waitpid(pid, &rc, 0) < 0) && (errno == EINTR))\n  {\n    alarm(0); /* cancel a possibly pending alarm */\n    imap_keepalive();\n    alarm(c_imap_keepalive);\n  }\n\n  alarm(0); /* cancel a possibly pending alarm */\n\n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n  OptKeepQuiet = false;\n  cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", c_imap_passive, NULL);\n\n  return rc;\n}\n\n/**\n * imap_allow_reopen - Allow re-opening a folder upon expunge\n * @param m Mailbox\n */\nvoid imap_allow_reopen(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !adata->mailbox || (adata->mailbox != m) || !mdata)\n    return;\n  mdata->reopen |= IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_disallow_reopen - Disallow re-opening a folder upon expunge\n * @param m Mailbox\n */\nvoid imap_disallow_reopen(struct Mailbox *m)\n{\n  struct ImapAccountData *adata = imap_adata_get(m);\n  struct ImapMboxData *mdata = imap_mdata_get(m);\n  if (!adata || !adata->mailbox || (adata->mailbox != m) || !mdata)\n    return;\n  mdata->reopen &= ~IMAP_REOPEN_ALLOW;\n}\n\n/**\n * imap_account_match - Compare two Accounts\n * @param a1 First ConnAccount\n * @param a2 Second ConnAccount\n * @retval true Accounts match\n */\nbool imap_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2)\n{\n  if (!a1 || !a2)\n    return false;\n  if (a1->type != a2->type)\n    return false;\n  if (!mutt_istr_equal(a1->host, a2->host))\n    return false;\n  if ((a1->port != 0) && (a2->port != 0) && (a1->port != a2->port))\n    return false;\n  if (a1->flags & a2->flags & MUTT_ACCT_USER)\n    return strcmp(a1->user, a2->user) == 0;\n\n  const char *user = NONULL(Username);\n\n  const char *const c_imap_user = cs_subset_string(NeoMutt->sub, \"imap_user\");\n  if ((a1->type == MUTT_ACCT_TYPE_IMAP) && c_imap_user)\n    user = c_imap_user;\n\n  if (a1->flags & MUTT_ACCT_USER)\n    return strcmp(a1->user, user) == 0;\n  if (a2->flags & MUTT_ACCT_USER)\n    return strcmp(a2->user, user) == 0;\n\n  return true;\n}\n\n/**\n * mutt_seqset_iterator_new - Create a new Sequence Set Iterator\n * @param seqset Source Sequence Set\n * @retval ptr Newly allocated Sequence Set Iterator\n */\nstruct SeqsetIterator *mutt_seqset_iterator_new(const char *seqset)\n{\n  if (!seqset || (*seqset == '\\0'))\n    return NULL;\n\n  struct SeqsetIterator *iter = mutt_mem_calloc(1, sizeof(struct SeqsetIterator));\n  iter->full_seqset = mutt_str_dup(seqset);\n  iter->eostr = strchr(iter->full_seqset, '\\0');\n  iter->substr_cur = iter->substr_end = iter->full_seqset;\n\n  return iter;\n}\n\n/**\n * mutt_seqset_iterator_next - Get the next UID from a Sequence Set\n * @param[in]  iter Sequence Set Iterator\n * @param[out] next Next UID in set\n * @retval  0 Next sequence is generated\n * @retval  1 Iterator is finished\n * @retval -1 error\n */\nint mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end++) = '\\0';\n\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n\n  return 0;\n}\n\n/**\n * mutt_seqset_iterator_free - Free a Sequence Set Iterator\n * @param[out] ptr Iterator to free\n */\nvoid mutt_seqset_iterator_free(struct SeqsetIterator **ptr)\n{\n  if (!ptr || !*ptr)\n    return;\n\n  struct SeqsetIterator *iter = *ptr;\n  FREE(&iter->full_seqset);\n  FREE(ptr);\n}\n"], "filenames": ["imap/util.c"], "buggy_code_start_loc": [1122], "buggy_code_end_loc": [1129], "fixing_code_start_loc": [1121], "fixing_code_end_loc": [1127], "type": "CWE-125", "message": "Mutt 1.11.0 through 2.0.x before 2.0.7 (and NeoMutt 2019-10-25 through 2021-05-04) has a $imap_qresync issue in which imap/util.c has an out-of-bounds read in situations where an IMAP sequence set ends with a comma. NOTE: the $imap_qresync setting for QRESYNC is not enabled by default.", "other": {"cve": {"id": "CVE-2021-32055", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-05T16:15:08.117", "lastModified": "2021-06-01T14:52:16.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mutt 1.11.0 through 2.0.x before 2.0.7 (and NeoMutt 2019-10-25 through 2021-05-04) has a $imap_qresync issue in which imap/util.c has an out-of-bounds read in situations where an IMAP sequence set ends with a comma. NOTE: the $imap_qresync setting for QRESYNC is not enabled by default."}, {"lang": "es", "value": "Mutt versiones 1.11.0 hasta 2.0.x versiones anteriores a 2.0.7 (y NeoMutt versiones del 25-10-2019 hasta 04-05-2021) presenta un problema de $imap_qresync en donde el archivo imap/util.c presenta una lectura fuera de l\u00edmites en situaciones en las que un ajuste de secuencias IMAP termina con una coma.&#xa0;NOTA: la configuraci\u00f3n $ imap_qresync para QRESYNC no est\u00e1 habilitada por defecto"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.0", "versionEndExcluding": "2.0.7", "matchCriteriaId": "A023CC31-DEB4-452F-9EF7-7A7DC0083991"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionStartIncluding": "20191025", "versionEndIncluding": "20210504", "matchCriteriaId": "1168F82B-A165-425B-A417-57F8225F7C21"}]}]}], "references": [{"url": "http://lists.mutt.org/pipermail/mutt-announce/Week-of-Mon-20210503/000036.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/-/commit/7c4779ac24d2fb68a2a47b58c7904118f40965d5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc"}}