{"buggy_code": ["module github.com/clastix/capsule-proxy\n\ngo 1.16\n\nrequire (\n\tgithub.com/clastix/capsule v0.1.0\n\tgithub.com/go-logr/logr v0.4.0\n\tgithub.com/golang-jwt/jwt v3.2.2+incompatible\n\tgithub.com/gorilla/handlers v1.5.1\n\tgithub.com/gorilla/mux v1.8.0\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgo.uber.org/zap v1.18.1\n\tk8s.io/api v0.22.0\n\tk8s.io/apimachinery v0.22.1\n\tk8s.io/apiserver v0.22.0\n\tk8s.io/client-go v0.22.0\n\tsigs.k8s.io/controller-runtime v0.9.5\n)\n", "// Copyright 2020-2021 Clastix Labs\n// SPDX-License-Identifier: Apache-2.0\n\npackage webserver\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"strings\"\n\t\"time\"\n\n\tcapsulev1beta1 \"github.com/clastix/capsule/api/v1beta1\"\n\t\"github.com/go-logr/logr\"\n\t\"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/pkg/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/apiserver/pkg/authentication/serviceaccount\"\n\tctrl \"sigs.k8s.io/controller-runtime\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n\n\t\"github.com/clastix/capsule-proxy/internal/controllers\"\n\t\"github.com/clastix/capsule-proxy/internal/modules\"\n\tmoderrors \"github.com/clastix/capsule-proxy/internal/modules/errors\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/ingressclass\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/lease\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/metric\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/namespace\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/node\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/pod\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/priorityclass\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/storageclass\"\n\t\"github.com/clastix/capsule-proxy/internal/options\"\n\treq \"github.com/clastix/capsule-proxy/internal/request\"\n\t\"github.com/clastix/capsule-proxy/internal/tenant\"\n\tserverr \"github.com/clastix/capsule-proxy/internal/webserver/errors\"\n\t\"github.com/clastix/capsule-proxy/internal/webserver/middleware\"\n)\n\nfunc NewKubeFilter(opts options.ListenerOpts, srv options.ServerOptions, rbReflector *controllers.RoleBindingReflector) (Filter, error) {\n\treverseProxy := httputil.NewSingleHostReverseProxy(opts.KubernetesControlPlaneURL())\n\treverseProxy.FlushInterval = time.Millisecond * 100\n\n\treverseProxyTransport, err := opts.ReverseProxyTransport()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot create transport for reverse proxy\")\n\t}\n\n\treverseProxy.Transport = reverseProxyTransport\n\n\treturn &kubeFilter{\n\t\tallowedPaths:          sets.NewString(\"/api\", \"/apis\", \"/version\"),\n\t\tignoredUserGroups:     sets.NewString(opts.IgnoredGroupNames()...),\n\t\treverseProxy:          reverseProxy,\n\t\tbearerToken:           opts.BearerToken(),\n\t\tusernameClaimField:    opts.PreferredUsernameClaim(),\n\t\tserverOptions:         srv,\n\t\tlog:                   ctrl.Log.WithName(\"proxy\"),\n\t\troleBindingsReflector: rbReflector,\n\t}, nil\n}\n\ntype kubeFilter struct {\n\tallowedPaths          sets.String\n\tignoredUserGroups     sets.String\n\treverseProxy          *httputil.ReverseProxy\n\tclient                client.Client\n\tbearerToken           string\n\tusernameClaimField    string\n\tserverOptions         options.ServerOptions\n\tlog                   logr.Logger\n\troleBindingsReflector *controllers.RoleBindingReflector\n}\n\nfunc (n *kubeFilter) LivenessProbe(req *http.Request) error {\n\treturn nil\n}\n\nfunc (n *kubeFilter) ReadinessProbe(req *http.Request) (err error) {\n\tscheme := \"http\"\n\tclt := &http.Client{}\n\n\tif n.serverOptions.IsListeningTLS() {\n\t\tscheme = \"https\"\n\t\tclt = &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\t//nolint:gosec\n\t\t\t\t\tInsecureSkipVerify: true,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\turl := fmt.Sprintf(\"%s://localhost:%d/_healthz\", scheme, n.serverOptions.ListeningPort())\n\n\tvar r *http.Request\n\n\tif r, err = http.NewRequestWithContext(context.Background(), \"GET\", url, nil); err != nil {\n\t\treturn errors.Wrap(err, \"cannot create request\")\n\t}\n\n\tvar resp *http.Response\n\n\tif resp, err = clt.Do(r); err != nil {\n\t\treturn errors.Wrap(err, \"cannot make local _healthz request\")\n\t}\n\n\tdefer func() {\n\t\t_ = resp.Body.Close()\n\t}()\n\n\tif sc := resp.StatusCode; sc != 200 {\n\t\treturn fmt.Errorf(\"returned status code from _healthz is %d, expected 200\", sc)\n\t}\n\n\treturn nil\n}\n\nfunc (n *kubeFilter) InjectClient(client client.Client) error {\n\tn.client = client\n\n\treturn nil\n}\n\nfunc (n kubeFilter) reverseProxyMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {\n\t\tnext.ServeHTTP(writer, request)\n\n\t\tn.log.V(5).Info(\"debugging request\", \"uri\", request.RequestURI, \"method\", request.Method)\n\t\tn.reverseProxy.ServeHTTP(writer, request)\n\t})\n}\n\n// nolint:interfacer\nfunc (n kubeFilter) handleRequest(request *http.Request, selector labels.Selector) {\n\tq := request.URL.Query()\n\tif e := q.Get(\"labelSelector\"); len(e) > 0 {\n\t\tn.log.V(4).Info(\"handling current labelSelector\", \"selector\", e)\n\n\t\tv := strings.Join([]string{e, selector.String()}, \",\")\n\t\tq.Set(\"labelSelector\", v)\n\t\tn.log.V(4).Info(\"labelSelector updated\", \"selector\", v)\n\t} else {\n\t\tq.Set(\"labelSelector\", selector.String())\n\t\tn.log.V(4).Info(\"labelSelector added\", \"selector\", selector.String())\n\t}\n\n\tn.log.V(4).Info(\"updating RawQuery\", \"query\", q.Encode())\n\trequest.URL.RawQuery = q.Encode()\n\n\tif len(n.bearerToken) > 0 {\n\t\tn.log.V(4).Info(\"Updating the token\", \"token\", n.bearerToken)\n\t\trequest.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", n.bearerToken))\n\t}\n}\n\nfunc (n kubeFilter) impersonateHandler(writer http.ResponseWriter, request *http.Request) {\n\thr := req.NewHTTP(request, n.usernameClaimField, n.client)\n\n\tvar username string\n\n\tvar groups []string\n\n\tvar err error\n\n\tif username, groups, err = hr.GetUserAndGroups(); err != nil {\n\t\tserverr.HandleError(writer, err, \"cannot retrieve user and group\")\n\t}\n\n\tn.log.V(4).Info(\"impersonating for the current request\", \"username\", username, \"groups\", groups)\n\n\tif len(n.bearerToken) > 0 {\n\t\trequest.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", n.bearerToken))\n\t}\n\n\trequest.Header.Add(\"Impersonate-User\", username)\n\n\tfor _, group := range groups {\n\t\trequest.Header.Add(\"Impersonate-Group\", group)\n\t}\n}\n\nfunc (n kubeFilter) registerModules(root *mux.Router) {\n\tmodList := []modules.Module{\n\t\tnamespace.List(n.roleBindingsReflector),\n\t\tnode.List(n.client),\n\t\tnode.Get(n.client),\n\t\tingressclass.List(n.client),\n\t\tingressclass.Get(n.client),\n\t\tstorageclass.Get(n.client),\n\t\tstorageclass.List(n.client),\n\t\tpriorityclass.List(n.client),\n\t\tpriorityclass.Get(n.client),\n\t\tlease.Get(n.client),\n\t\tmetric.Get(n.client),\n\t\tmetric.List(n.client),\n\t\tpod.Get(n.client),\n\t}\n\tfor _, i := range modList {\n\t\tmod := i\n\t\trp := root.Path(mod.Path())\n\n\t\tif m := mod.Methods(); len(m) > 0 {\n\t\t\trp = rp.Methods(m...)\n\t\t}\n\n\t\tsr := rp.Subrouter()\n\t\tsr.Use(\n\t\t\tmiddleware.CheckPaths(n.client, n.log, n.allowedPaths, n.impersonateHandler),\n\t\t\tmiddleware.CheckAuthorization(n.client, n.log, n.serverOptions.IsListeningTLS()),\n\t\t\tmiddleware.CheckJWTMiddleware(n.client, n.log),\n\t\t\tmiddleware.CheckUserInIgnoredGroupMiddleware(n.client, n.log, n.usernameClaimField, n.ignoredUserGroups, n.impersonateHandler),\n\t\t\tmiddleware.CheckUserInCapsuleGroupMiddleware(n.client, n.log, n.usernameClaimField, n.impersonateHandler),\n\t\t)\n\t\tsr.HandleFunc(\"\", func(writer http.ResponseWriter, request *http.Request) {\n\t\t\tproxyRequest := req.NewHTTP(request, n.usernameClaimField, n.client)\n\t\t\tusername, groups, _ := proxyRequest.GetUserAndGroups()\n\t\t\tproxyTenants, err := n.getTenantsForOwner(username, groups)\n\t\t\tif err != nil {\n\t\t\t\tserverr.HandleError(writer, err, \"cannot list Tenant resources\")\n\t\t\t}\n\n\t\t\tvar selector labels.Selector\n\t\t\tselector, err = mod.Handle(proxyTenants, proxyRequest)\n\t\t\tswitch {\n\t\t\tcase err != nil:\n\t\t\t\tvar t moderrors.Error\n\t\t\t\tif errors.As(err, &t) {\n\t\t\t\t\twriter.Header().Set(\"content-type\", \"application/json\")\n\t\t\t\t\tb, _ := json.Marshal(t.Status())\n\t\t\t\t\t_, _ = writer.Write(b)\n\t\t\t\t\tpanic(err.Error())\n\t\t\t\t}\n\t\t\t\tserverr.HandleError(writer, err, err.Error())\n\t\t\tcase selector == nil:\n\t\t\t\t// if there's no selector, let it pass to the\n\t\t\t\tn.impersonateHandler(writer, request)\n\t\t\tdefault:\n\t\t\t\tn.handleRequest(request, selector)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (n kubeFilter) Start(ctx context.Context) error {\n\tr := mux.NewRouter().StrictSlash(true)\n\tr.Use(handlers.RecoveryHandler())\n\tr.Path(\"/_healthz\").Subrouter().HandleFunc(\"\", func(writer http.ResponseWriter, request *http.Request) {\n\t\twriter.WriteHeader(200)\n\t\t_, _ = writer.Write([]byte(\"ok\"))\n\t})\n\n\troot := r.PathPrefix(\"\").Subrouter()\n\tn.registerModules(root)\n\troot.Use(\n\t\tn.reverseProxyMiddleware,\n\t\tmiddleware.CheckPaths(n.client, n.log, n.allowedPaths, n.impersonateHandler),\n\t\tmiddleware.CheckAuthorization(n.client, n.log, n.serverOptions.IsListeningTLS()),\n\t\tmiddleware.CheckJWTMiddleware(n.client, n.log),\n\t)\n\troot.PathPrefix(\"/\").HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {\n\t\tn.impersonateHandler(writer, request)\n\t})\n\n\tvar srv *http.Server\n\n\tgo func() {\n\t\tvar err error\n\n\t\taddr := fmt.Sprintf(\"0.0.0.0:%d\", n.serverOptions.ListeningPort())\n\n\t\tif n.serverOptions.IsListeningTLS() {\n\t\t\ttlsConfig := &tls.Config{\n\t\t\t\tMinVersion: tls.VersionTLS12,\n\t\t\t\tClientCAs:  n.serverOptions.GetCertificateAuthorityPool(),\n\t\t\t\tClientAuth: tls.VerifyClientCertIfGiven,\n\t\t\t}\n\t\t\tsrv = &http.Server{\n\t\t\t\tHandler:   r,\n\t\t\t\tAddr:      addr,\n\t\t\t\tTLSConfig: tlsConfig,\n\t\t\t}\n\t\t\terr = srv.ListenAndServeTLS(n.serverOptions.TLSCertificatePath(), n.serverOptions.TLSCertificateKeyPath())\n\t\t} else {\n\t\t\tsrv = &http.Server{\n\t\t\t\tHandler: r,\n\t\t\t\tAddr:    addr,\n\t\t\t}\n\t\t\terr = srv.ListenAndServe()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\n\treturn srv.Shutdown(ctx)\n}\n\nfunc (n *kubeFilter) getTenantsForOwner(username string, groups []string) (proxyTenants []*tenant.ProxyTenant, err error) {\n\tif strings.HasPrefix(username, serviceaccount.ServiceAccountUsernamePrefix) {\n\t\tproxyTenants, err = n.getProxyTenantsForOwnerKind(capsulev1beta1.ServiceAccountOwner, username)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot get Tenants slice owned by Tenant Owner: %w\", err)\n\t\t}\n\t} else {\n\t\tproxyTenants, err = n.getProxyTenantsForOwnerKind(capsulev1beta1.UserOwner, username)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot get Tenants slice owned by Tenant Owner: %w\", err)\n\t\t}\n\t}\n\n\t// Find tenants belonging to a group\n\tfor _, group := range groups {\n\t\tpt, err := n.getProxyTenantsForOwnerKind(capsulev1beta1.GroupOwner, group)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot get Tenants slice owned by Tenant Owner: %w\", err)\n\t\t}\n\n\t\tproxyTenants = append(proxyTenants, pt...)\n\t}\n\n\treturn\n}\n\nfunc (n kubeFilter) getProxyTenantsForOwnerKind(ownerKind capsulev1beta1.OwnerKind, ownerName string) (proxyTenants []*tenant.ProxyTenant, err error) {\n\t// nolint:prealloc\n\tvar tenants []string\n\n\ttl := &capsulev1beta1.TenantList{}\n\n\tf := client.MatchingFields{\n\t\t\".spec.owner.ownerkind\": fmt.Sprintf(\"%s:%s\", ownerKind.String(), ownerName),\n\t}\n\tif err := n.client.List(context.Background(), tl, f); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot retrieve Tenants list: %w\", err)\n\t}\n\n\tn.log.V(8).Info(\"Tenant\", \"owner\", ownerKind, \"name\", ownerName, \"tenantList items\", tl.Items, \"number of tenants\", len(tl.Items))\n\n\tfor _, t := range tl.Items {\n\t\tproxyTenants = append(proxyTenants, tenant.NewProxyTenant(ownerName, ownerKind, t))\n\t\ttenants = append(tenants, t.GetName())\n\t}\n\n\tn.log.V(4).Info(\"Proxy tenant list\", \"owner\", ownerKind, \"name\", ownerName, \"tenants\", tenants)\n\n\treturn\n}\n"], "fixing_code": ["module github.com/clastix/capsule-proxy\n\ngo 1.16\n\nrequire (\n\tgithub.com/clastix/capsule v0.1.0\n\tgithub.com/go-logr/logr v0.4.0\n\tgithub.com/golang-jwt/jwt v3.2.2+incompatible\n\tgithub.com/gorilla/handlers v1.5.1\n\tgithub.com/gorilla/mux v1.8.0\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgo.uber.org/zap v1.18.1\n\tgolang.org/x/net v0.0.0-20210520170846-37e1c6afe023\n\tk8s.io/api v0.22.0\n\tk8s.io/apimachinery v0.22.1\n\tk8s.io/apiserver v0.22.0\n\tk8s.io/client-go v0.22.0\n\tsigs.k8s.io/controller-runtime v0.9.5\n)\n", "// Copyright 2020-2021 Clastix Labs\n// SPDX-License-Identifier: Apache-2.0\n\npackage webserver\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/textproto\"\n\t\"strings\"\n\t\"time\"\n\n\tcapsulev1beta1 \"github.com/clastix/capsule/api/v1beta1\"\n\t\"github.com/go-logr/logr\"\n\t\"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/http/httpguts\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/apiserver/pkg/authentication/serviceaccount\"\n\tctrl \"sigs.k8s.io/controller-runtime\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n\n\t\"github.com/clastix/capsule-proxy/internal/controllers\"\n\t\"github.com/clastix/capsule-proxy/internal/modules\"\n\tmoderrors \"github.com/clastix/capsule-proxy/internal/modules/errors\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/ingressclass\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/lease\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/metric\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/namespace\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/node\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/pod\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/priorityclass\"\n\t\"github.com/clastix/capsule-proxy/internal/modules/storageclass\"\n\t\"github.com/clastix/capsule-proxy/internal/options\"\n\treq \"github.com/clastix/capsule-proxy/internal/request\"\n\t\"github.com/clastix/capsule-proxy/internal/tenant\"\n\tserverr \"github.com/clastix/capsule-proxy/internal/webserver/errors\"\n\t\"github.com/clastix/capsule-proxy/internal/webserver/middleware\"\n)\n\nfunc NewKubeFilter(opts options.ListenerOpts, srv options.ServerOptions, rbReflector *controllers.RoleBindingReflector) (Filter, error) {\n\treverseProxy := httputil.NewSingleHostReverseProxy(opts.KubernetesControlPlaneURL())\n\treverseProxy.FlushInterval = time.Millisecond * 100\n\n\treverseProxyTransport, err := opts.ReverseProxyTransport()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot create transport for reverse proxy\")\n\t}\n\n\treverseProxy.Transport = reverseProxyTransport\n\n\treturn &kubeFilter{\n\t\tallowedPaths:          sets.NewString(\"/api\", \"/apis\", \"/version\"),\n\t\tignoredUserGroups:     sets.NewString(opts.IgnoredGroupNames()...),\n\t\treverseProxy:          reverseProxy,\n\t\tbearerToken:           opts.BearerToken(),\n\t\tusernameClaimField:    opts.PreferredUsernameClaim(),\n\t\tserverOptions:         srv,\n\t\tlog:                   ctrl.Log.WithName(\"proxy\"),\n\t\troleBindingsReflector: rbReflector,\n\t}, nil\n}\n\ntype kubeFilter struct {\n\tallowedPaths          sets.String\n\tignoredUserGroups     sets.String\n\treverseProxy          *httputil.ReverseProxy\n\tclient                client.Client\n\tbearerToken           string\n\tusernameClaimField    string\n\tserverOptions         options.ServerOptions\n\tlog                   logr.Logger\n\troleBindingsReflector *controllers.RoleBindingReflector\n}\n\nfunc (n *kubeFilter) LivenessProbe(req *http.Request) error {\n\treturn nil\n}\n\nfunc (n *kubeFilter) ReadinessProbe(req *http.Request) (err error) {\n\tscheme := \"http\"\n\tclt := &http.Client{}\n\n\tif n.serverOptions.IsListeningTLS() {\n\t\tscheme = \"https\"\n\t\tclt = &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\t//nolint:gosec\n\t\t\t\t\tInsecureSkipVerify: true,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\turl := fmt.Sprintf(\"%s://localhost:%d/_healthz\", scheme, n.serverOptions.ListeningPort())\n\n\tvar r *http.Request\n\n\tif r, err = http.NewRequestWithContext(context.Background(), \"GET\", url, nil); err != nil {\n\t\treturn errors.Wrap(err, \"cannot create request\")\n\t}\n\n\tvar resp *http.Response\n\n\tif resp, err = clt.Do(r); err != nil {\n\t\treturn errors.Wrap(err, \"cannot make local _healthz request\")\n\t}\n\n\tdefer func() {\n\t\t_ = resp.Body.Close()\n\t}()\n\n\tif sc := resp.StatusCode; sc != 200 {\n\t\treturn fmt.Errorf(\"returned status code from _healthz is %d, expected 200\", sc)\n\t}\n\n\treturn nil\n}\n\nfunc (n *kubeFilter) InjectClient(client client.Client) error {\n\tn.client = client\n\n\treturn nil\n}\n\nfunc (n kubeFilter) reverseProxyMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {\n\t\tnext.ServeHTTP(writer, request)\n\n\t\tn.log.V(5).Info(\"debugging request\", \"uri\", request.RequestURI, \"method\", request.Method)\n\t\tn.reverseProxy.ServeHTTP(writer, request)\n\t})\n}\n\n// nolint:interfacer\nfunc (n kubeFilter) handleRequest(request *http.Request, selector labels.Selector) {\n\tq := request.URL.Query()\n\tif e := q.Get(\"labelSelector\"); len(e) > 0 {\n\t\tn.log.V(4).Info(\"handling current labelSelector\", \"selector\", e)\n\n\t\tv := strings.Join([]string{e, selector.String()}, \",\")\n\t\tq.Set(\"labelSelector\", v)\n\t\tn.log.V(4).Info(\"labelSelector updated\", \"selector\", v)\n\t} else {\n\t\tq.Set(\"labelSelector\", selector.String())\n\t\tn.log.V(4).Info(\"labelSelector added\", \"selector\", selector.String())\n\t}\n\n\tn.log.V(4).Info(\"updating RawQuery\", \"query\", q.Encode())\n\trequest.URL.RawQuery = q.Encode()\n\n\tif len(n.bearerToken) > 0 {\n\t\tn.log.V(4).Info(\"Updating the token\", \"token\", n.bearerToken)\n\t\trequest.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", n.bearerToken))\n\t}\n}\n\nfunc (n kubeFilter) impersonateHandler(writer http.ResponseWriter, request *http.Request) {\n\thr := req.NewHTTP(request, n.usernameClaimField, n.client)\n\n\tvar username string\n\n\tvar groups []string\n\n\tvar err error\n\n\tif username, groups, err = hr.GetUserAndGroups(); err != nil {\n\t\tserverr.HandleError(writer, err, \"cannot retrieve user and group\")\n\t}\n\n\tn.log.V(4).Info(\"impersonating for the current request\", \"username\", username, \"groups\", groups)\n\n\tif len(n.bearerToken) > 0 {\n\t\trequest.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", n.bearerToken))\n\t}\n\t// Dropping malicious header connection\n\t// https://github.com/clastix/capsule-proxy/issues/188\n\tn.removingHopByHopHeaders(request)\n\n\trequest.Header.Add(\"Impersonate-User\", username)\n\n\tfor _, group := range groups {\n\t\trequest.Header.Add(\"Impersonate-Group\", group)\n\t}\n}\n\nfunc (n kubeFilter) registerModules(root *mux.Router) {\n\tmodList := []modules.Module{\n\t\tnamespace.List(n.roleBindingsReflector),\n\t\tnode.List(n.client),\n\t\tnode.Get(n.client),\n\t\tingressclass.List(n.client),\n\t\tingressclass.Get(n.client),\n\t\tstorageclass.Get(n.client),\n\t\tstorageclass.List(n.client),\n\t\tpriorityclass.List(n.client),\n\t\tpriorityclass.Get(n.client),\n\t\tlease.Get(n.client),\n\t\tmetric.Get(n.client),\n\t\tmetric.List(n.client),\n\t\tpod.Get(n.client),\n\t}\n\tfor _, i := range modList {\n\t\tmod := i\n\t\trp := root.Path(mod.Path())\n\n\t\tif m := mod.Methods(); len(m) > 0 {\n\t\t\trp = rp.Methods(m...)\n\t\t}\n\n\t\tsr := rp.Subrouter()\n\t\tsr.Use(\n\t\t\tmiddleware.CheckPaths(n.client, n.log, n.allowedPaths, n.impersonateHandler),\n\t\t\tmiddleware.CheckAuthorization(n.client, n.log, n.serverOptions.IsListeningTLS()),\n\t\t\tmiddleware.CheckJWTMiddleware(n.client, n.log),\n\t\t\tmiddleware.CheckUserInIgnoredGroupMiddleware(n.client, n.log, n.usernameClaimField, n.ignoredUserGroups, n.impersonateHandler),\n\t\t\tmiddleware.CheckUserInCapsuleGroupMiddleware(n.client, n.log, n.usernameClaimField, n.impersonateHandler),\n\t\t)\n\t\tsr.HandleFunc(\"\", func(writer http.ResponseWriter, request *http.Request) {\n\t\t\tproxyRequest := req.NewHTTP(request, n.usernameClaimField, n.client)\n\t\t\tusername, groups, _ := proxyRequest.GetUserAndGroups()\n\t\t\tproxyTenants, err := n.getTenantsForOwner(username, groups)\n\t\t\tif err != nil {\n\t\t\t\tserverr.HandleError(writer, err, \"cannot list Tenant resources\")\n\t\t\t}\n\n\t\t\tvar selector labels.Selector\n\t\t\tselector, err = mod.Handle(proxyTenants, proxyRequest)\n\t\t\tswitch {\n\t\t\tcase err != nil:\n\t\t\t\tvar t moderrors.Error\n\t\t\t\tif errors.As(err, &t) {\n\t\t\t\t\twriter.Header().Set(\"content-type\", \"application/json\")\n\t\t\t\t\tb, _ := json.Marshal(t.Status())\n\t\t\t\t\t_, _ = writer.Write(b)\n\t\t\t\t\tpanic(err.Error())\n\t\t\t\t}\n\t\t\t\tserverr.HandleError(writer, err, err.Error())\n\t\t\tcase selector == nil:\n\t\t\t\t// if there's no selector, let it pass to the\n\t\t\t\tn.impersonateHandler(writer, request)\n\t\t\tdefault:\n\t\t\t\tn.handleRequest(request, selector)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (n kubeFilter) Start(ctx context.Context) error {\n\tr := mux.NewRouter().StrictSlash(true)\n\tr.Use(handlers.RecoveryHandler())\n\tr.Path(\"/_healthz\").Subrouter().HandleFunc(\"\", func(writer http.ResponseWriter, request *http.Request) {\n\t\twriter.WriteHeader(200)\n\t\t_, _ = writer.Write([]byte(\"ok\"))\n\t})\n\n\troot := r.PathPrefix(\"\").Subrouter()\n\tn.registerModules(root)\n\troot.Use(\n\t\tn.reverseProxyMiddleware,\n\t\tmiddleware.CheckPaths(n.client, n.log, n.allowedPaths, n.impersonateHandler),\n\t\tmiddleware.CheckAuthorization(n.client, n.log, n.serverOptions.IsListeningTLS()),\n\t\tmiddleware.CheckJWTMiddleware(n.client, n.log),\n\t)\n\troot.PathPrefix(\"/\").HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {\n\t\tn.impersonateHandler(writer, request)\n\t})\n\n\tvar srv *http.Server\n\n\tgo func() {\n\t\tvar err error\n\n\t\taddr := fmt.Sprintf(\"0.0.0.0:%d\", n.serverOptions.ListeningPort())\n\n\t\tif n.serverOptions.IsListeningTLS() {\n\t\t\ttlsConfig := &tls.Config{\n\t\t\t\tMinVersion: tls.VersionTLS12,\n\t\t\t\tClientCAs:  n.serverOptions.GetCertificateAuthorityPool(),\n\t\t\t\tClientAuth: tls.VerifyClientCertIfGiven,\n\t\t\t}\n\t\t\tsrv = &http.Server{\n\t\t\t\tHandler:   r,\n\t\t\t\tAddr:      addr,\n\t\t\t\tTLSConfig: tlsConfig,\n\t\t\t}\n\t\t\terr = srv.ListenAndServeTLS(n.serverOptions.TLSCertificatePath(), n.serverOptions.TLSCertificateKeyPath())\n\t\t} else {\n\t\t\tsrv = &http.Server{\n\t\t\t\tHandler: r,\n\t\t\t\tAddr:    addr,\n\t\t\t}\n\t\t\terr = srv.ListenAndServe()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t<-ctx.Done()\n\n\treturn srv.Shutdown(ctx)\n}\n\nfunc (n *kubeFilter) getTenantsForOwner(username string, groups []string) (proxyTenants []*tenant.ProxyTenant, err error) {\n\tif strings.HasPrefix(username, serviceaccount.ServiceAccountUsernamePrefix) {\n\t\tproxyTenants, err = n.getProxyTenantsForOwnerKind(capsulev1beta1.ServiceAccountOwner, username)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot get Tenants slice owned by Tenant Owner: %w\", err)\n\t\t}\n\t} else {\n\t\tproxyTenants, err = n.getProxyTenantsForOwnerKind(capsulev1beta1.UserOwner, username)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot get Tenants slice owned by Tenant Owner: %w\", err)\n\t\t}\n\t}\n\n\t// Find tenants belonging to a group\n\tfor _, group := range groups {\n\t\tpt, err := n.getProxyTenantsForOwnerKind(capsulev1beta1.GroupOwner, group)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"cannot get Tenants slice owned by Tenant Owner: %w\", err)\n\t\t}\n\n\t\tproxyTenants = append(proxyTenants, pt...)\n\t}\n\n\treturn\n}\n\nfunc (n kubeFilter) getProxyTenantsForOwnerKind(ownerKind capsulev1beta1.OwnerKind, ownerName string) (proxyTenants []*tenant.ProxyTenant, err error) {\n\t// nolint:prealloc\n\tvar tenants []string\n\n\ttl := &capsulev1beta1.TenantList{}\n\n\tf := client.MatchingFields{\n\t\t\".spec.owner.ownerkind\": fmt.Sprintf(\"%s:%s\", ownerKind.String(), ownerName),\n\t}\n\tif err := n.client.List(context.Background(), tl, f); err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot retrieve Tenants list: %w\", err)\n\t}\n\n\tn.log.V(8).Info(\"Tenant\", \"owner\", ownerKind, \"name\", ownerName, \"tenantList items\", tl.Items, \"number of tenants\", len(tl.Items))\n\n\tfor _, t := range tl.Items {\n\t\tproxyTenants = append(proxyTenants, tenant.NewProxyTenant(ownerName, ownerKind, t))\n\t\ttenants = append(tenants, t.GetName())\n\t}\n\n\tn.log.V(4).Info(\"Proxy tenant list\", \"owner\", ownerKind, \"name\", ownerName, \"tenants\", tenants)\n\n\treturn\n}\n\nfunc (n *kubeFilter) removingHopByHopHeaders(request *http.Request) {\n\tconnectionHeaderName, upgradeHeaderName, requestUpgradeType := \"connection\", \"upgrade\", \"\"\n\n\tif httpguts.HeaderValuesContainsToken(request.Header[connectionHeaderName], upgradeHeaderName) {\n\t\trequestUpgradeType = request.Header.Get(upgradeHeaderName)\n\t}\n\t// Removing connection headers\n\tfor _, f := range request.Header.Values(connectionHeaderName) {\n\t\tfor _, sf := range strings.Split(f, \",\") {\n\t\t\tif sf = textproto.TrimString(sf); sf != \"\" {\n\t\t\t\trequest.Header.Del(sf)\n\t\t\t}\n\t\t}\n\t}\n\n\tif requestUpgradeType != \"\" {\n\t\trequest.Header.Set(connectionHeaderName, upgradeHeaderName)\n\t\trequest.Header.Set(upgradeHeaderName, requestUpgradeType)\n\n\t\treturn\n\t}\n\n\trequest.Header.Del(connectionHeaderName)\n}\n"], "filenames": ["go.mod", "internal/webserver/webserver.go"], "buggy_code_start_loc": [13, 12], "buggy_code_end_loc": [13, 357], "fixing_code_start_loc": [14, 13], "fixing_code_end_loc": [15, 388], "type": "CWE-287", "message": "capsule-proxy is a reverse proxy for Capsule Operator which provides multi-tenancy in Kubernetes. In versions prior to 0.2.1 an attacker with a proper authentication mechanism may use a malicious `Connection` header to start a privilege escalation attack towards the Kubernetes API Server. This vulnerability allows for an exploit of the `cluster-admin` Role bound to `capsule-proxy`. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23652", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T20:15:07.763", "lastModified": "2022-03-01T20:08:43.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "capsule-proxy is a reverse proxy for Capsule Operator which provides multi-tenancy in Kubernetes. In versions prior to 0.2.1 an attacker with a proper authentication mechanism may use a malicious `Connection` header to start a privilege escalation attack towards the Kubernetes API Server. This vulnerability allows for an exploit of the `cluster-admin` Role bound to `capsule-proxy`. There are no known workarounds for this issue."}, {"lang": "es", "value": "capsule-proxy es un proxy inverso para Capsule Operator que proporciona multi-tenancy en Kubernetes. En versiones anteriores a la 0.2.1 un atacante con un mecanismo de autenticaci\u00f3n adecuado puede utilizar una cabecera `Connection` maliciosa para iniciar un ataque de escalada de privilegios hacia el servidor de la API de Kubernetes. Esta vulnerabilidad permite explotar el rol `cluster-admin` vinculado a `capsule-proxy`. No hay soluciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clastix:capsule-proxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.1", "matchCriteriaId": "67F30FEB-4C18-4522-9B33-D66E83DB8F13"}]}]}], "references": [{"url": "https://github.com/clastix/capsule-proxy/commit/efe91f68ebf8a9e3d21491dc57da7b8a746415d8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/clastix/capsule-proxy/issues/188", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/clastix/capsule-proxy/security/advisories/GHSA-9cwv-cppx-mqjm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/clastix/capsule-proxy/commit/efe91f68ebf8a9e3d21491dc57da7b8a746415d8"}}