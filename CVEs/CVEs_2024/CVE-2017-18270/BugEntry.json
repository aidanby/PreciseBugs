{"buggy_code": ["/* Authentication token and access key management\n *\n * Copyright (C) 2004, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n *\n * See Documentation/security/keys/core.rst for information on keys/keyrings.\n */\n\n#ifndef _LINUX_KEY_H\n#define _LINUX_KEY_H\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/rcupdate.h>\n#include <linux/sysctl.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n#include <linux/assoc_array.h>\n#include <linux/refcount.h>\n\n#ifdef __KERNEL__\n#include <linux/uidgid.h>\n\n/* key handle serial number */\ntypedef int32_t key_serial_t;\n\n/* key handle permissions mask */\ntypedef uint32_t key_perm_t;\n\nstruct key;\n\n#ifdef CONFIG_KEYS\n\n#undef KEY_DEBUGGING\n\n#define KEY_POS_VIEW\t0x01000000\t/* possessor can view a key's attributes */\n#define KEY_POS_READ\t0x02000000\t/* possessor can read key payload / view keyring */\n#define KEY_POS_WRITE\t0x04000000\t/* possessor can update key payload / add link to keyring */\n#define KEY_POS_SEARCH\t0x08000000\t/* possessor can find a key in search / search a keyring */\n#define KEY_POS_LINK\t0x10000000\t/* possessor can create a link to a key/keyring */\n#define KEY_POS_SETATTR\t0x20000000\t/* possessor can set key attributes */\n#define KEY_POS_ALL\t0x3f000000\n\n#define KEY_USR_VIEW\t0x00010000\t/* user permissions... */\n#define KEY_USR_READ\t0x00020000\n#define KEY_USR_WRITE\t0x00040000\n#define KEY_USR_SEARCH\t0x00080000\n#define KEY_USR_LINK\t0x00100000\n#define KEY_USR_SETATTR\t0x00200000\n#define KEY_USR_ALL\t0x003f0000\n\n#define KEY_GRP_VIEW\t0x00000100\t/* group permissions... */\n#define KEY_GRP_READ\t0x00000200\n#define KEY_GRP_WRITE\t0x00000400\n#define KEY_GRP_SEARCH\t0x00000800\n#define KEY_GRP_LINK\t0x00001000\n#define KEY_GRP_SETATTR\t0x00002000\n#define KEY_GRP_ALL\t0x00003f00\n\n#define KEY_OTH_VIEW\t0x00000001\t/* third party permissions... */\n#define KEY_OTH_READ\t0x00000002\n#define KEY_OTH_WRITE\t0x00000004\n#define KEY_OTH_SEARCH\t0x00000008\n#define KEY_OTH_LINK\t0x00000010\n#define KEY_OTH_SETATTR\t0x00000020\n#define KEY_OTH_ALL\t0x0000003f\n\n#define KEY_PERM_UNDEF\t0xffffffff\n\nstruct seq_file;\nstruct user_struct;\nstruct signal_struct;\nstruct cred;\n\nstruct key_type;\nstruct key_owner;\nstruct keyring_list;\nstruct keyring_name;\n\nstruct keyring_index_key {\n\tstruct key_type\t\t*type;\n\tconst char\t\t*description;\n\tsize_t\t\t\tdesc_len;\n};\n\nunion key_payload {\n\tvoid __rcu\t\t*rcu_data0;\n\tvoid\t\t\t*data[4];\n};\n\n/*****************************************************************************/\n/*\n * key reference with possession attribute handling\n *\n * NOTE! key_ref_t is a typedef'd pointer to a type that is not actually\n * defined. This is because we abuse the bottom bit of the reference to carry a\n * flag to indicate whether the calling process possesses that key in one of\n * its keyrings.\n *\n * the key_ref_t has been made a separate type so that the compiler can reject\n * attempts to dereference it without proper conversion.\n *\n * the three functions are used to assemble and disassemble references\n */\ntypedef struct __key_reference_with_attributes *key_ref_t;\n\nstatic inline key_ref_t make_key_ref(const struct key *key,\n\t\t\t\t     bool possession)\n{\n\treturn (key_ref_t) ((unsigned long) key | possession);\n}\n\nstatic inline struct key *key_ref_to_ptr(const key_ref_t key_ref)\n{\n\treturn (struct key *) ((unsigned long) key_ref & ~1UL);\n}\n\nstatic inline bool is_key_possessed(const key_ref_t key_ref)\n{\n\treturn (unsigned long) key_ref & 1UL;\n}\n\ntypedef int (*key_restrict_link_func_t)(struct key *dest_keyring,\n\t\t\t\t\tconst struct key_type *type,\n\t\t\t\t\tconst union key_payload *payload,\n\t\t\t\t\tstruct key *restriction_key);\n\nstruct key_restriction {\n\tkey_restrict_link_func_t check;\n\tstruct key *key;\n\tstruct key_type *keytype;\n};\n\n/*****************************************************************************/\n/*\n * authentication token / access credential / keyring\n * - types of key include:\n *   - keyrings\n *   - disk encryption IDs\n *   - Kerberos TGTs and tickets\n */\nstruct key {\n\trefcount_t\t\tusage;\t\t/* number of references */\n\tkey_serial_t\t\tserial;\t\t/* key serial number */\n\tunion {\n\t\tstruct list_head graveyard_link;\n\t\tstruct rb_node\tserial_node;\n\t};\n\tstruct rw_semaphore\tsem;\t\t/* change vs change sem */\n\tstruct key_user\t\t*user;\t\t/* owner of this key */\n\tvoid\t\t\t*security;\t/* security data for this key */\n\tunion {\n\t\ttime_t\t\texpiry;\t\t/* time at which key expires (or 0) */\n\t\ttime_t\t\trevoked_at;\t/* time at which key was revoked */\n\t};\n\ttime_t\t\t\tlast_used_at;\t/* last time used for LRU keyring discard */\n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tkey_perm_t\t\tperm;\t\t/* access permissions */\n\tunsigned short\t\tquotalen;\t/* length added to quota */\n\tunsigned short\t\tdatalen;\t/* payload data length\n\t\t\t\t\t\t * - may not match RCU dereferenced payload\n\t\t\t\t\t\t * - payload should contain own length\n\t\t\t\t\t\t */\n\n#ifdef KEY_DEBUGGING\n\tunsigned\t\tmagic;\n#define KEY_DEBUG_MAGIC\t\t0x18273645u\n#endif\n\n\tunsigned long\t\tflags;\t\t/* status flags (change with bitops) */\n#define KEY_FLAG_INSTANTIATED\t0\t/* set if key has been instantiated */\n#define KEY_FLAG_DEAD\t\t1\t/* set if key type has been deleted */\n#define KEY_FLAG_REVOKED\t2\t/* set if key had been revoked */\n#define KEY_FLAG_IN_QUOTA\t3\t/* set if key consumes quota */\n#define KEY_FLAG_USER_CONSTRUCT\t4\t/* set if key is being constructed in userspace */\n#define KEY_FLAG_NEGATIVE\t5\t/* set if key is negative */\n#define KEY_FLAG_ROOT_CAN_CLEAR\t6\t/* set if key can be cleared by root without permission */\n#define KEY_FLAG_INVALIDATED\t7\t/* set if key has been invalidated */\n#define KEY_FLAG_BUILTIN\t8\t/* set if key is built in to the kernel */\n#define KEY_FLAG_ROOT_CAN_INVAL\t9\t/* set if key can be invalidated by root without permission */\n#define KEY_FLAG_KEEP\t\t10\t/* set if key should not be removed */\n\n\t/* the key type and key description string\n\t * - the desc is used to match a key against search criteria\n\t * - it should be a printable string\n\t * - eg: for krb5 AFS, this might be \"afs@REDHAT.COM\"\n\t */\n\tunion {\n\t\tstruct keyring_index_key index_key;\n\t\tstruct {\n\t\t\tstruct key_type\t*type;\t\t/* type of key */\n\t\t\tchar\t\t*description;\n\t\t};\n\t};\n\n\t/* key data\n\t * - this is used to hold the data actually used in cryptography or\n\t *   whatever\n\t */\n\tunion {\n\t\tunion key_payload payload;\n\t\tstruct {\n\t\t\t/* Keyring bits */\n\t\t\tstruct list_head name_link;\n\t\t\tstruct assoc_array keys;\n\t\t};\n\t\tint reject_error;\n\t};\n\n\t/* This is set on a keyring to restrict the addition of a link to a key\n\t * to it.  If this structure isn't provided then it is assumed that the\n\t * keyring is open to any addition.  It is ignored for non-keyring\n\t * keys. Only set this value using keyring_restrict(), keyring_alloc(),\n\t * or key_alloc().\n\t *\n\t * This is intended for use with rings of trusted keys whereby addition\n\t * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION\n\t * overrides this, allowing the kernel to add extra keys without\n\t * restriction.\n\t */\n\tstruct key_restriction *restrict_link;\n};\n\nextern struct key *key_alloc(struct key_type *type,\n\t\t\t     const char *desc,\n\t\t\t     kuid_t uid, kgid_t gid,\n\t\t\t     const struct cred *cred,\n\t\t\t     key_perm_t perm,\n\t\t\t     unsigned long flags,\n\t\t\t     struct key_restriction *restrict_link);\n\n\n#define KEY_ALLOC_IN_QUOTA\t\t0x0000\t/* add to quota, reject if would overrun */\n#define KEY_ALLOC_QUOTA_OVERRUN\t\t0x0001\t/* add to quota, permit even if overrun */\n#define KEY_ALLOC_NOT_IN_QUOTA\t\t0x0002\t/* not in quota */\n#define KEY_ALLOC_BUILT_IN\t\t0x0004\t/* Key is built into kernel */\n#define KEY_ALLOC_BYPASS_RESTRICTION\t0x0008\t/* Override the check on restricted keyrings */\n\nextern void key_revoke(struct key *key);\nextern void key_invalidate(struct key *key);\nextern void key_put(struct key *key);\n\nstatic inline struct key *__key_get(struct key *key)\n{\n\trefcount_inc(&key->usage);\n\treturn key;\n}\n\nstatic inline struct key *key_get(struct key *key)\n{\n\treturn key ? __key_get(key) : key;\n}\n\nstatic inline void key_ref_put(key_ref_t key_ref)\n{\n\tkey_put(key_ref_to_ptr(key_ref));\n}\n\nextern struct key *request_key(struct key_type *type,\n\t\t\t       const char *description,\n\t\t\t       const char *callout_info);\n\nextern struct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t\t    const char *description,\n\t\t\t\t\t    const void *callout_info,\n\t\t\t\t\t    size_t callout_len,\n\t\t\t\t\t    void *aux);\n\nextern struct key *request_key_async(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len);\n\nextern struct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t\t  const char *description,\n\t\t\t\t\t\t  const void *callout_info,\n\t\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t\t  void *aux);\n\nextern int wait_for_key_construction(struct key *key, bool intr);\n\nextern int key_validate(const struct key *key);\n\nextern key_ref_t key_create_or_update(key_ref_t keyring,\n\t\t\t\t      const char *type,\n\t\t\t\t      const char *description,\n\t\t\t\t      const void *payload,\n\t\t\t\t      size_t plen,\n\t\t\t\t      key_perm_t perm,\n\t\t\t\t      unsigned long flags);\n\nextern int key_update(key_ref_t key,\n\t\t      const void *payload,\n\t\t      size_t plen);\n\nextern int key_link(struct key *keyring,\n\t\t    struct key *key);\n\nextern int key_unlink(struct key *keyring,\n\t\t      struct key *key);\n\nextern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t\t const struct cred *cred,\n\t\t\t\t key_perm_t perm,\n\t\t\t\t unsigned long flags,\n\t\t\t\t struct key_restriction *restrict_link,\n\t\t\t\t struct key *dest);\n\nextern int restrict_link_reject(struct key *keyring,\n\t\t\t\tconst struct key_type *type,\n\t\t\t\tconst union key_payload *payload,\n\t\t\t\tstruct key *restriction_key);\n\nextern int keyring_clear(struct key *keyring);\n\nextern key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t\tstruct key_type *type,\n\t\t\t\tconst char *description);\n\nextern int keyring_add_key(struct key *keyring,\n\t\t\t   struct key *key);\n\nextern int keyring_restrict(key_ref_t keyring, const char *type,\n\t\t\t    const char *restriction);\n\nextern struct key *key_lookup(key_serial_t id);\n\nstatic inline key_serial_t key_serial(const struct key *key)\n{\n\treturn key ? key->serial : 0;\n}\n\nextern void key_set_timeout(struct key *, unsigned);\n\n/*\n * The permissions required on a key that we're looking up.\n */\n#define\tKEY_NEED_VIEW\t0x01\t/* Require permission to view attributes */\n#define\tKEY_NEED_READ\t0x02\t/* Require permission to read content */\n#define\tKEY_NEED_WRITE\t0x04\t/* Require permission to update / modify */\n#define\tKEY_NEED_SEARCH\t0x08\t/* Require permission to search (keyring) or find (key) */\n#define\tKEY_NEED_LINK\t0x10\t/* Require permission to link */\n#define\tKEY_NEED_SETATTR 0x20\t/* Require permission to change attributes */\n#define\tKEY_NEED_ALL\t0x3f\t/* All the above permissions */\n\n/**\n * key_is_instantiated - Determine if a key has been positively instantiated\n * @key: The key to check.\n *\n * Return true if the specified key has been positively instantiated, false\n * otherwise.\n */\nstatic inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}\n\n#define dereference_key_rcu(KEY)\t\t\t\t\t\\\n\t(rcu_dereference((KEY)->payload.rcu_data0))\n\n#define dereference_key_locked(KEY)\t\t\t\t\t\\\n\t(rcu_dereference_protected((KEY)->payload.rcu_data0,\t\t\\\n\t\t\t\t   rwsem_is_locked(&((struct key *)(KEY))->sem)))\n\n#define rcu_assign_keypointer(KEY, PAYLOAD)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_assign_pointer((KEY)->payload.rcu_data0, (PAYLOAD));\t\\\n} while (0)\n\n#ifdef CONFIG_SYSCTL\nextern struct ctl_table key_sysctls[];\n#endif\n/*\n * the userspace interface\n */\nextern int install_thread_keyring_to_cred(struct cred *cred);\nextern void key_fsuid_changed(struct task_struct *tsk);\nextern void key_fsgid_changed(struct task_struct *tsk);\nextern void key_init(void);\n\n#else /* CONFIG_KEYS */\n\n#define key_validate(k)\t\t\t0\n#define key_serial(k)\t\t\t0\n#define key_get(k) \t\t\t({ NULL; })\n#define key_revoke(k)\t\t\tdo { } while(0)\n#define key_invalidate(k)\t\tdo { } while(0)\n#define key_put(k)\t\t\tdo { } while(0)\n#define key_ref_put(k)\t\t\tdo { } while(0)\n#define make_key_ref(k, p)\t\tNULL\n#define key_ref_to_ptr(k)\t\tNULL\n#define is_key_possessed(k)\t\t0\n#define key_fsuid_changed(t)\t\tdo { } while(0)\n#define key_fsgid_changed(t)\t\tdo { } while(0)\n#define key_init()\t\t\tdo { } while(0)\n\n#endif /* CONFIG_KEYS */\n#endif /* __KERNEL__ */\n#endif /* _LINUX_KEY_H */\n", "/* Authentication token and access key management internal defs\n *\n * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#ifndef _INTERNAL_H\n#define _INTERNAL_H\n\n#include <linux/sched.h>\n#include <linux/wait_bit.h>\n#include <linux/cred.h>\n#include <linux/key-type.h>\n#include <linux/task_work.h>\n#include <linux/keyctl.h>\n#include <linux/refcount.h>\n#include <linux/compat.h>\n\nstruct iovec;\n\n#ifdef __KDEBUG\n#define kenter(FMT, ...) \\\n\tprintk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tprintk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tprintk(KERN_DEBUG \"   \"FMT\"\\n\", ##__VA_ARGS__)\n#else\n#define kenter(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tno_printk(KERN_DEBUG FMT\"\\n\", ##__VA_ARGS__)\n#endif\n\nextern struct key_type key_type_dead;\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\n/*****************************************************************************/\n/*\n * Keep track of keys for a user.\n *\n * This needs to be separate to user_struct to avoid a refcount-loop\n * (user_struct pins some keyrings which pin this struct).\n *\n * We also keep track of keys under request from userspace for this UID here.\n */\nstruct key_user {\n\tstruct rb_node\t\tnode;\n\tstruct mutex\t\tcons_lock;\t/* construction initiation lock */\n\tspinlock_t\t\tlock;\n\trefcount_t\t\tusage;\t\t/* for accessing qnkeys & qnbytes */\n\tatomic_t\t\tnkeys;\t\t/* number of keys */\n\tatomic_t\t\tnikeys;\t\t/* number of instantiated keys */\n\tkuid_t\t\t\tuid;\n\tint\t\t\tqnkeys;\t\t/* number of keys allocated to this user */\n\tint\t\t\tqnbytes;\t/* number of bytes allocated to this user */\n};\n\nextern struct rb_root\tkey_user_tree;\nextern spinlock_t\tkey_user_lock;\nextern struct key_user\troot_key_user;\n\nextern struct key_user *key_user_lookup(kuid_t uid);\nextern void key_user_put(struct key_user *user);\n\n/*\n * Key quota limits.\n * - root has its own separate limits to everyone else\n */\nextern unsigned key_quota_root_maxkeys;\nextern unsigned key_quota_root_maxbytes;\nextern unsigned key_quota_maxkeys;\nextern unsigned key_quota_maxbytes;\n\n#define KEYQUOTA_LINK_BYTES\t4\t\t/* a link in a keyring is worth 4 bytes */\n\n\nextern struct kmem_cache *key_jar;\nextern struct rb_root key_serial_tree;\nextern spinlock_t key_serial_lock;\nextern struct mutex key_construction_mutex;\nextern wait_queue_head_t request_key_conswq;\n\n\nextern struct key_type *key_type_lookup(const char *type);\nextern void key_type_put(struct key_type *ktype);\n\nextern int __key_link_begin(struct key *keyring,\n\t\t\t    const struct keyring_index_key *index_key,\n\t\t\t    struct assoc_array_edit **_edit);\nextern int __key_link_check_live_key(struct key *keyring, struct key *key);\nextern void __key_link(struct key *key, struct assoc_array_edit **_edit);\nextern void __key_link_end(struct key *keyring,\n\t\t\t   const struct keyring_index_key *index_key,\n\t\t\t   struct assoc_array_edit *edit);\n\nextern key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t\t    const struct keyring_index_key *index_key);\n\nextern struct key *keyring_search_instkey(struct key *keyring,\n\t\t\t\t\t  key_serial_t target_id);\n\nextern int iterate_over_keyring(const struct key *keyring,\n\t\t\t\tint (*func)(const struct key *key, void *data),\n\t\t\t\tvoid *data);\n\nstruct keyring_search_context {\n\tstruct keyring_index_key index_key;\n\tconst struct cred\t*cred;\n\tstruct key_match_data\tmatch_data;\n\tunsigned\t\tflags;\n#define KEYRING_SEARCH_NO_STATE_CHECK\t0x0001\t/* Skip state checks */\n#define KEYRING_SEARCH_DO_STATE_CHECK\t0x0002\t/* Override NO_STATE_CHECK */\n#define KEYRING_SEARCH_NO_UPDATE_TIME\t0x0004\t/* Don't update times */\n#define KEYRING_SEARCH_NO_CHECK_PERM\t0x0008\t/* Don't check permissions */\n#define KEYRING_SEARCH_DETECT_TOO_DEEP\t0x0010\t/* Give an error on excessive depth */\n#define KEYRING_SEARCH_SKIP_EXPIRED\t0x0020\t/* Ignore expired keys (intention to replace) */\n\n\tint (*iterator)(const void *object, void *iterator_data);\n\n\t/* Internal stuff */\n\tint\t\t\tskipped_ret;\n\tbool\t\t\tpossessed;\n\tkey_ref_t\t\tresult;\n\tstruct timespec\t\tnow;\n};\n\nextern bool key_default_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data);\nextern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t\t    struct keyring_search_context *ctx);\n\nextern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);\nextern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);\n\nextern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);\n\nextern int install_user_keyrings(void);\nextern int install_thread_keyring_to_cred(struct cred *);\nextern int install_process_keyring_to_cred(struct cred *);\nextern int install_session_keyring_to_cred(struct cred *, struct key *);\n\nextern struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t\tconst char *description,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tvoid *aux,\n\t\t\t\t\tstruct key *dest_keyring,\n\t\t\t\t\tunsigned long flags);\n\nextern bool lookup_user_key_possessed(const struct key *key,\n\t\t\t\t      const struct key_match_data *match_data);\nextern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,\n\t\t\t\t key_perm_t perm);\n#define KEY_LOOKUP_CREATE\t0x01\n#define KEY_LOOKUP_PARTIAL\t0x02\n#define KEY_LOOKUP_FOR_UNLINK\t0x04\n\nextern long join_session_keyring(const char *name);\nextern void key_change_session_keyring(struct callback_head *twork);\n\nextern struct work_struct key_gc_work;\nextern unsigned key_gc_delay;\nextern void keyring_gc(struct key *keyring, time_t limit);\nextern void keyring_restriction_gc(struct key *keyring,\n\t\t\t\t   struct key_type *dead_type);\nextern void key_schedule_gc(time_t gc_at);\nextern void key_schedule_gc_links(void);\nextern void key_gc_keytype(struct key_type *ktype);\n\nextern int key_task_permission(const key_ref_t key_ref,\n\t\t\t       const struct cred *cred,\n\t\t\t       key_perm_t perm);\n\n/*\n * Check to see whether permission is granted to use a key in the desired way.\n */\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}\n\n/*\n * Authorisation record for request_key().\n */\nstruct request_key_auth {\n\tstruct key\t\t*target_key;\n\tstruct key\t\t*dest_keyring;\n\tconst struct cred\t*cred;\n\tvoid\t\t\t*callout_info;\n\tsize_t\t\t\tcallout_len;\n\tpid_t\t\t\tpid;\n} __randomize_layout;\n\nextern struct key_type key_type_request_key_auth;\nextern struct key *request_key_auth_new(struct key *target,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tstruct key *dest_keyring);\n\nextern struct key *key_get_instantiation_authkey(key_serial_t target_id);\n\n/*\n * Determine whether a key is dead.\n */\nstatic inline bool key_is_dead(const struct key *key, time_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}\n\n/*\n * keyctl() functions\n */\nextern long keyctl_get_keyring_ID(key_serial_t, int);\nextern long keyctl_join_session_keyring(const char __user *);\nextern long keyctl_update_key(key_serial_t, const void __user *, size_t);\nextern long keyctl_revoke_key(key_serial_t);\nextern long keyctl_keyring_clear(key_serial_t);\nextern long keyctl_keyring_link(key_serial_t, key_serial_t);\nextern long keyctl_keyring_unlink(key_serial_t, key_serial_t);\nextern long keyctl_describe_key(key_serial_t, char __user *, size_t);\nextern long keyctl_keyring_search(key_serial_t, const char __user *,\n\t\t\t\t  const char __user *, key_serial_t);\nextern long keyctl_read_key(key_serial_t, char __user *, size_t);\nextern long keyctl_chown_key(key_serial_t, uid_t, gid_t);\nextern long keyctl_setperm_key(key_serial_t, key_perm_t);\nextern long keyctl_instantiate_key(key_serial_t, const void __user *,\n\t\t\t\t   size_t, key_serial_t);\nextern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);\nextern long keyctl_set_reqkey_keyring(int);\nextern long keyctl_set_timeout(key_serial_t, unsigned);\nextern long keyctl_assume_authority(key_serial_t);\nextern long keyctl_get_security(key_serial_t keyid, char __user *buffer,\n\t\t\t\tsize_t buflen);\nextern long keyctl_session_to_parent(void);\nextern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);\nextern long keyctl_instantiate_key_iov(key_serial_t,\n\t\t\t\t       const struct iovec __user *,\n\t\t\t\t       unsigned, key_serial_t);\nextern long keyctl_invalidate_key(key_serial_t);\n\nstruct iov_iter;\nextern long keyctl_instantiate_key_common(key_serial_t,\n\t\t\t\t\t  struct iov_iter *,\n\t\t\t\t\t  key_serial_t);\nextern long keyctl_restrict_keyring(key_serial_t id,\n\t\t\t\t    const char __user *_type,\n\t\t\t\t    const char __user *_restriction);\n#ifdef CONFIG_PERSISTENT_KEYRINGS\nextern long keyctl_get_persistent(uid_t, key_serial_t);\nextern unsigned persistent_keyring_expiry;\n#else\nstatic inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n#ifdef CONFIG_KEY_DH_OPERATIONS\nextern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,\n\t\t\t      size_t, struct keyctl_kdf_params __user *);\nextern long __keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,\n\t\t\t\tsize_t, struct keyctl_kdf_params *);\n#ifdef CONFIG_KEYS_COMPAT\nextern long compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t\tchar __user *buffer, size_t buflen,\n\t\t\t\tstruct compat_keyctl_kdf_params __user *kdf);\n#endif\n#define KEYCTL_KDF_MAX_OUTPUT_LEN\t1024\t/* max length of KDF output */\n#define KEYCTL_KDF_MAX_OI_LEN\t\t64\t/* max length of otherinfo */\n#else\nstatic inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t\t     char __user *buffer, size_t buflen,\n\t\t\t\t     struct keyctl_kdf_params __user *kdf)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#ifdef CONFIG_KEYS_COMPAT\nstatic inline long compat_keyctl_dh_compute(\n\t\t\t\tstruct keyctl_dh_params __user *params,\n\t\t\t\tchar __user *buffer, size_t buflen,\n\t\t\t\tstruct keyctl_kdf_params __user *kdf)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n#endif\n\n/*\n * Debugging key validation\n */\n#ifdef KEY_DEBUGGING\nextern void __key_check(const struct key *);\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}\n\n#else\n\n#define key_check(key) do {} while(0)\n\n#endif\n\n#endif /* _INTERNAL_H */\n", "/* Basic authentication token and access key management\n *\n * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree; /* tree of keys indexed by serial */\nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree; /* tree of quota records indexed by UID */\nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 1000000;\t/* root's key count quota */\nunsigned int key_quota_root_maxbytes = 25000000; /* root's key space quota */\nunsigned int key_quota_maxkeys = 200;\t\t/* general key count quota */\nunsigned int key_quota_maxbytes = 20000;\t/* general key space quota */\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n/* We serialise key instantiation and link */\nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n/*\n * Get the key quota record for a user, allocating a new record if one doesn't\n * already exist.\n */\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p;\n\ntry_again:\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n/*\n * Dispose of a user structure\n */\nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n/*\n * Allocate a serial number for a key.  These are assigned randomly to avoid\n * security issues through covert channel problems.\n */\nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t/* propose a random serial number and look for a hole for it in the\n\t * serial number tree */\n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1; /* negative numbers are not permitted */\n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t/* we've found a suitable hole - arrange for this key to occupy it */\n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t/* we found a key with the proposed serial number - walk the tree from\n\t * that point looking for the next unused serial number */\nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n/**\n * key_alloc - Allocate a key of the specified type.\n * @type: The type of key to allocate.\n * @desc: The key description to allow the key to be searched out.\n * @uid: The owner of the new key.\n * @gid: The group ID for the new key's group permissions.\n * @cred: The credentials specifying UID namespace.\n * @perm: The permissions mask of the new key.\n * @flags: Flags specifying quota properties.\n * @restrict_link: Optional link restriction for new keyrings.\n *\n * Allocate a key of the specified type with the attributes given.  The key is\n * returned in an uninstantiated state and the caller needs to instantiate the\n * key before returning.\n *\n * The restrict_link structure (if not NULL) will be freed when the\n * keyring is destroyed, so it must be dynamically allocated.\n *\n * The user's key count quota is updated to reflect the creation of the key and\n * the user's key data quota has the default for the key type reserved.  The\n * instantiation function should amend this as necessary.  If insufficient\n * quota is available, -EDQUOT will be returned.\n *\n * The LSM security modules can prevent a key being created, in which case\n * -EACCES will be returned.\n *\n * Returns a pointer to the new key if successful and an error code otherwise.\n *\n * Note that the caller needs to ensure the key type isn't uninstantiated.\n * Internally this can be done by locking key_types_sem.  Externally, this can\n * be done by either never unregistering the key type, or making sure\n * key_alloc() calls don't race with module unloading.\n */\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n/**\n * key_payload_reserve - Adjust data quota reservation for the key's payload\n * @key: The key to make the reservation for.\n * @datalen: The amount of data payload the caller now wants.\n *\n * Adjust the amount of the owning user's key data quota that a key reserves.\n * If the amount is increased, then -EDQUOT may be returned if there isn't\n * enough free quota available.\n *\n * If successful, 0 is returned.\n */\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n/*\n * Instantiate a key and link it into the target keyring atomically.  Must be\n * called with the target keyring's semaphore writelocked.  The target key's\n * semaphore need not be locked as instantiation is serialised by\n * key_construction_mutex.\n */\nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\n\t\t\t/* disable the authorisation key */\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n/**\n * key_instantiate_and_link - Instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @data: The data to use to instantiate the keyring.\n * @datalen: The length of @data.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Instantiate a key that's in the uninstantiated state using the provided data\n * and, if successful, link it in to the destination keyring if one is\n * supplied.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n/**\n * key_reject_and_link - Negatively instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @timeout: The timeout on the negative key.\n * @error: The error to return when the key is hit.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Negatively instantiate a key that's in the uninstantiated state and, if\n * successful, set its timeout and stored error and link it in to the\n * destination keyring if one is supplied.  The key and any links to the key\n * will be automatically garbage collected after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the stored error code (typically ENOKEY) until the negative\n * key expires.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n/**\n * key_put - Discard a reference to a key.\n * @key: The key to discard a reference from.\n *\n * Discard a reference to a key, and when all the references are gone, we\n * schedule the cleanup task to come and pull it out of the tree in process\n * context at some later time.\n */\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n/*\n * Find a key by its serial number.\n */\nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t/* search the tree for the specified key */\n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t/* A key is allowed to be looked up only if someone still owns a\n\t * reference to it - otherwise it's awaiting the gc.\n\t */\n\tif (!refcount_inc_not_zero(&key->usage))\n\t\tgoto not_found;\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n/*\n * Find and lock the specified key type against removal.\n *\n * We return with the sem read-locked if successful.  If the type wasn't\n * available -ENOKEY is returned instead.\n */\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n/*\n * Unlock a key type locked by key_type_lookup().\n */\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n/*\n * Attempt to update an existing key.\n *\n * The key is given to us with an incremented refcount that we need to discard\n * if we get an error.\n */\nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n/**\n * key_create_or_update - Update or create and instantiate a key.\n * @keyring_ref: A pointer to the destination keyring with possession flag.\n * @type: The type of key.\n * @description: The searchable description for the key.\n * @payload: The data to use to instantiate or update the key.\n * @plen: The length of @payload.\n * @perm: The permissions mask for a new key.\n * @flags: The quota flags for a new key.\n *\n * Search the destination keyring for a key of the same description and if one\n * is found, update it, otherwise create and instantiate a new one and create a\n * link to it from that keyring.\n *\n * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be\n * concocted.\n *\n * Returns a pointer to the new key if successful, -ENODEV if the key type\n * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the\n * caller isn't permitted to modify the keyring or the LSM did not permit\n * creation of the key.\n *\n * On success, the possession flag from the keyring ref will be tacked on to\n * the key ref before it is returned.\n */\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n/**\n * key_update - Update a key's contents.\n * @key_ref: The pointer (plus possession flag) to the key.\n * @payload: The data to be used to update the key.\n * @plen: The length of @payload.\n *\n * Attempt to update the contents of a key with the given payload data.  The\n * caller must be granted Write permission on the key.  Negative keys can be\n * instantiated by this method.\n *\n * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key\n * type does not support updating.  The key type may return other errors.\n */\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attempt to update it if supported */\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n/**\n * key_revoke - Revoke a key.\n * @key: The key to be revoked.\n *\n * Mark a key as being revoked and ask the type to free up its resources.  The\n * revocation timeout is set and the key and all its links will be\n * automatically garbage collected after key_gc_delay amount of time if they\n * are not manually dealt with first.\n */\nvoid key_revoke(struct key *key)\n{\n\tstruct timespec now;\n\ttime_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\tnow = current_kernel_time();\n\ttime = now.tv_sec;\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n/**\n * key_invalidate - Invalidate a key.\n * @key: The key to be invalidated.\n *\n * Mark a key as being invalidated and have it cleaned up immediately.  The key\n * is ignored by all searches and other operations from this point.\n */\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n/**\n * generic_key_instantiate - Simple instantiation of a key from preparsed data\n * @key: The key to be instantiated\n * @prep: The preparsed data to load.\n *\n * Instantiate a key from preparsed data.  We assume we can just copy the data\n * in directly and clear the old pointers.\n *\n * This can be pointed to directly by the key type instantiate op pointer.\n */\nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\trcu_assign_keypointer(key, prep->payload.data[0]);\n\t\tkey->payload.data[1] = prep->payload.data[1];\n\t\tkey->payload.data[2] = prep->payload.data[2];\n\t\tkey->payload.data[3] = prep->payload.data[3];\n\t\tprep->payload.data[0] = NULL;\n\t\tprep->payload.data[1] = NULL;\n\t\tprep->payload.data[2] = NULL;\n\t\tprep->payload.data[3] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n/**\n * register_key_type - Register a type of key.\n * @ktype: The new key type.\n *\n * Register a new key type.\n *\n * Returns 0 on success or -EEXIST if a type of this name already exists.\n */\nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n/**\n * unregister_key_type - Unregister a type of key.\n * @ktype: The key type.\n *\n * Unregister a key type and mark all the extant keys of this type as dead.\n * Those keys of this type are then destroyed to get rid of their payloads and\n * they and their links will be garbage collected as soon as possible.\n */\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n/*\n * Initialise the key management state.\n */\nvoid __init key_init(void)\n{\n\t/* allocate a slab in which we can store keys */\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* add the special key types */\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t/* record the root user tracking */\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n", "/* Keyring handling\n *\n * Copyright (C) 2004-2005, 2008, 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/*\n * When plumbing the depths of the key tree, this sets a hard limit\n * set on how deep we're willing to go.\n */\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n/*\n * We keep all named keyrings in a hash to speed looking them up.\n */\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\n/*\n * We mark pointers we pass to the associative array with bit 1 set if\n * they're keyrings and clear otherwise.\n */\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}\n\n/*\n * The keyring key type definition.  Keyrings are simply keys of this type and\n * can be treated as ordinary keys in addition to having their own special\n * operations.\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n/*\n * Semaphore to serialise link/link calls to prevent two link calls in parallel\n * introducing a cycle.\n */\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\n/*\n * Publish the name of a keyring so that it can be found by name (if it has\n * one).\n */\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n/*\n * Preparse a keyring payload\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n/*\n * Free a preparse of a user defined key payload\n */\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Initialise a keyring.\n *\n * Returns 0 on success, -EINVAL if given any data.\n */\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n/*\n * Multiply 64-bits by 32-bits to 96-bits and fold back to 64-bit.  Ideally we'd\n * fold the carry back too, but that requires inline asm.\n */\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n/*\n * Hash a key type and description.\n */\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\n\n/*\n * Build the next index key chunk.\n *\n * On 32-bit systems the index key is laid out as:\n *\n *\t0\t4\t5\t9...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * On 64-bit systems:\n *\n *\t0\t8\t9\t17...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * We return it one word-sized chunk at a time.\n */\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n/*\n * Compare the index keys of a pair of objects and determine the bit position\n * at which they differ - if they differ.\n */\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n/*\n * Free an object after stripping the keyring flag off of the pointer.\n */\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n/*\n * Operations for keyring management by the index-tree routines.\n */\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n/*\n * Clean up a keyring when it is destroyed.  Unpublish its name if it had one\n * and dispose of its data.\n *\n * The garbage collector detects the final key_put(), removes the keyring from\n * the serial number tree and then does RCU synchronisation before coming here,\n * so we shouldn't need to worry about code poking around here with the RCU\n * readlock held by this time.\n */\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n/*\n * Describe a keyring for /proc.\n */\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tbuflen;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n/*\n * Read a list of key IDs from the keyring's contents in binary form\n *\n * The keyring's semaphore is read-locked by the caller.  This prevents someone\n * from modifying it under us - which could cause us to read key IDs multiple\n * times.\n */\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\n\t/* Calculate how much data we could return */\n\tif (!buffer || !buflen)\n\t\treturn nr_keys * sizeof(key_serial_t);\n\n\t/* Copy the IDs of the subscribed keys into the buffer */\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.buflen = buflen;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\n\n/*\n * Allocate a keyring and link into the destination keyring.\n */\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n/**\n * restrict_link_reject - Give -EPERM to restrict link\n * @keyring: The keyring being added to.\n * @type: The type of key being added.\n * @payload: The payload of the key intended to be added.\n * @data: Additional data for evaluating restriction.\n *\n * Reject the addition of any links to a keyring.  It can be overridden by\n * passing KEY_ALLOC_BYPASS_RESTRICTION to key_instantiate_and_link() when\n * adding a key to a keyring.\n *\n * This is meant to be stored in a key_restriction structure which is passed\n * in the restrict_link parameter to keyring_alloc().\n */\nint restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}\n\n/*\n * By default, we keys found by getting an exact match on their descriptions.\n */\nbool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\n/*\n * Iteration function to consider each key found.\n */\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n/*\n * Search inside a keyring for a key.  We can search by walking to it\n * directly based on its index-key or we can iterate over the entire\n * tree looking for it, based on the match function.\n */\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n/*\n * Search a tree of keyrings that point to other keyrings up to the maximum\n * depth.\n */\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n/**\n * keyring_search_aux - Search a keyring tree for a key matching some criteria\n * @keyring_ref: A pointer to the keyring with possession indicator.\n * @ctx: The keyring search context.\n *\n * Search the supplied keyring tree for a key that matches the criteria given.\n * The root keyring and any linked keyrings must grant Search permission to the\n * caller to be searchable and keys can only be found if they too grant Search\n * to the caller. The possession flag on the root keyring pointer controls use\n * of the possessor bits in permissions checking of the entire tree.  In\n * addition, the LSM gets to forbid keyring searches and key matches.\n *\n * The search is performed as a breadth-then-depth search up to the prescribed\n * limit (KEYRING_SEARCH_MAX_DEPTH).\n *\n * Keys are matched to the type provided and are then filtered by the match\n * function, which is given the description to use in any way it sees fit.  The\n * match function may use any attributes of a key that it wishes to to\n * determine the match.  Normally the match function from the key type would be\n * used.\n *\n * RCU can be used to prevent the keyring key lists from disappearing without\n * the need to take lots of locks.\n *\n * Returns a pointer to the found key and increments the key usage count if\n * successful; -EAGAIN if no matching keys were found, or if expired or revoked\n * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the\n * specified keyring wasn't a keyring.\n *\n * In the case of a successful return, the possession attribute from\n * @keyring_ref is propagated to the returned key reference.\n */\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}\n\n/**\n * keyring_search - Search the supplied keyring tree for a matching key\n * @keyring: The root of the keyring tree to be searched.\n * @type: The type of keyring we want to find.\n * @description: The name of the keyring we want to find.\n *\n * As keyring_search_aux() above, but using the current task's credentials and\n * type's default matching function and preferred search method.\n */\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}\n\n/*\n * Semaphore to serialise restriction setup to prevent reference count\n * cycles through restriction key pointers.\n */\nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\n/*\n * Check for restriction cycles that would prevent keyring garbage collection.\n * keyring_serialise_restrict_sem must be held.\n */\nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}\n\n/**\n * keyring_restrict - Look up and apply a restriction to a keyring\n *\n * @keyring: The keyring to be restricted\n * @restriction: The restriction options to apply to the keyring\n */\nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_restrict);\n\n/*\n * Search the given keyring for a key that might be updated.\n *\n * The caller must guarantee that the keyring is a keyring and that the\n * permission is granted to modify the keyring as no check is made here.  The\n * caller must also hold a lock on the keyring semaphore.\n *\n * Returns a pointer to the found key with usage count incremented if\n * successful and returns NULL if not found.  Revoked and invalidated keys are\n * skipped over.\n *\n * If successful, the possession indicator is propagated from the keyring ref\n * to the returned key reference.\n */\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n/*\n * Find a keyring with the specified name.\n *\n * All named keyrings in the current user namespace are searched, provided they\n * grant Search permission directly to the caller (unless this check is\n * skipped).  Keyrings whose usage points have reached zero or who have been\n * revoked are skipped.\n *\n * Returns a pointer to the keyring with the keyring's refcount having being\n * incremented on success.  -ENOKEY is returned if a key could not be found.\n */\nstruct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n/*\n * See if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A).\n *\n * Since we are adding B to A at the top level, checking for cycles should just\n * be a matter of seeing if node A is somewhere in tree B.\n */\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n/*\n * Preallocate memory so that a key can be linked into to a keyring.\n */\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Check already instantiated keys aren't going to be a problem.\n *\n * The caller must have called __key_link_begin(). Don't need to call this for\n * keys that were created since __key_link_begin() was called.\n */\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n/*\n * Link a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.  Discards any\n * already extant link to matching key if there is one, so that each keyring\n * holds at most one link to any given key of a particular type+description\n * combination.\n */\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}\n\n/*\n * Finish linking a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.\n */\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\n\n/*\n * Check addition of keys to restricted keyrings.\n */\nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}\n\n/**\n * key_link - Link a key to a keyring\n * @keyring: The keyring to make the link in.\n * @key: The key to link to.\n *\n * Make a link in a keyring to a key, such that the keyring holds a reference\n * on that key and the key can potentially be found by searching that keyring.\n *\n * This function will write-lock the keyring's semaphore and will consume some\n * of the user's key data quota to hold the link.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,\n * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is\n * full, -EDQUOT if there is insufficient key data quota remaining to add\n * another link or -ENOMEM if there's insufficient memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be made (the keyring should have Write permission and the key Link\n * permission).\n */\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n/**\n * key_unlink - Unlink the first link to a key from a keyring.\n * @keyring: The keyring to remove the link from.\n * @key: The key the link is to.\n *\n * Remove a link from a keyring to a key.\n *\n * This function will write-lock the keyring's semaphore.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if\n * the key isn't linked to by the keyring or -ENOMEM if there's insufficient\n * memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be removed (the keyring should have Write permission; no permissions are\n * required on the key).\n */\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n/**\n * keyring_clear - Clear a keyring\n * @keyring: The keyring to clear.\n *\n * Clear the contents of the specified keyring.\n *\n * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.\n */\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n/*\n * Dispose of the links from a revoked keyring.\n *\n * This is called with the key sem write-locked.\n */\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n/*\n * Garbage collect pointers from a keyring.\n *\n * Not called with any locks held.  The keyring's key struct will not be\n * deallocated under us as only our caller may deallocate it.\n */\nvoid keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n\n/*\n * Garbage collect restriction pointers from a keyring.\n *\n * Keyring restrictions are associated with a key type, and must be cleaned\n * up if the key type is unregistered. The restriction is altered to always\n * reject additional keys so a keyring cannot be opened up by unregistering\n * a key type.\n *\n * Not called with any keyring locks held. The keyring's key struct will not\n * be deallocated under us as only our caller may deallocate it.\n *\n * The caller is required to hold key_types_sem and dead_type->sem. This is\n * fulfilled by key_gc_keytype() holding the locks on behalf of\n * key_garbage_collector(), which it invokes on a workqueue.\n */\nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}\n", "/* Manage a process's keyrings\n *\n * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/* Session keyring create vs join semaphore */\nstatic DEFINE_MUTEX(key_session_mutex);\n\n/* User keyring creation semaphore */\nstatic DEFINE_MUTEX(key_user_keyring_mutex);\n\n/* The root user's tracking struct */\nstruct key_user root_key_user = {\n\t.usage\t\t= REFCOUNT_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n/*\n * Install the user and user session keyrings for the current process's UID.\n */\nint install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Install a thread keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a thread keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a process keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a process keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install the given keyring as the session keyring of the given credentials\n * struct, replacing the existing one if any.  If the given keyring is NULL,\n * then install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n/*\n * Install the given keyring as the session keyring of the current task,\n * replacing the existing one if any.  If the given keyring is NULL, then\n * install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Handle the fsuid changing.\n */\nvoid key_fsuid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->uid = tsk->cred->fsuid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Handle the fsgid changing.\n */\nvoid key_fsgid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->gid = tsk->cred->fsgid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key.\n *\n * The search criteria are the type and the match function.  The description is\n * given to the match function as a parameter, but doesn't otherwise influence\n * the search.  Typically the match function will compare the description\n * parameter to the key's description.\n *\n * This can only search keyrings that grant Search permission to the supplied\n * credentials.  Keyrings linked to searched keyrings will also be searched if\n * they grant Search permission too.  Keys can only be found if they grant\n * Search permission to the credentials.\n *\n * Returns a pointer to the key with the key usage count incremented if\n * successful, -EAGAIN if we didn't find any matching key or -ENOKEY if we only\n * matched negative keys.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key in the manner of search_my_process_keyrings(), but also search\n * the keys attached to the assumed authorisation key using its credentials if\n * one is available.\n *\n * Return same as search_my_process_keyrings().\n */\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * See if the key we're looking at is the target key.\n */\nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n/*\n * Look up a key ID given us by userspace with a given permissions mask to get\n * the key it refers to.\n *\n * Flags can be passed to request that special keyrings be created if referred\n * to directly, to permit partially constructed keys to be found and to skip\n * validity and permission checks on the found key.\n *\n * Returns a pointer to the key with an incremented usage count if successful;\n * -EINVAL if the key ID is invalid; -ENOKEY if the key ID does not correspond\n * to a key or the best found key was a negative key; -EKEYREVOKED or\n * -EKEYEXPIRED if the best found key was revoked or expired; -EACCES if the\n * found key doesn't grant the requested permit or the LSM denied access to it;\n * or -ENOMEM if a special keyring couldn't be created.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\n\n/*\n * Join the named keyring as the session keyring if possible else attempt to\n * create a new one of that name and join that.\n *\n * If the name is NULL, an empty anonymous keyring will be installed as the\n * session keyring.\n *\n * Named session keyrings are joined with a semaphore held to prevent the\n * keyrings from going away whilst the attempt is made to going them and also\n * to prevent a race in creating compatible session keyrings.\n */\nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tret = 0;\n\t\tgoto error3;\n\t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error3;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror3:\n\tkey_put(keyring);\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Replace a process's session keyring on behalf of one of its children when\n * the target  process is about to resume userspace execution.\n */\nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n/*\n * Make sure that root's user and user-session keyrings exist.\n */\nstatic int __init init_root_keyring(void)\n{\n\treturn install_user_keyrings();\n}\n\nlate_initcall(init_root_keyring);\n"], "fixing_code": ["/* Authentication token and access key management\n *\n * Copyright (C) 2004, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n *\n * See Documentation/security/keys/core.rst for information on keys/keyrings.\n */\n\n#ifndef _LINUX_KEY_H\n#define _LINUX_KEY_H\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/rcupdate.h>\n#include <linux/sysctl.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n#include <linux/assoc_array.h>\n#include <linux/refcount.h>\n\n#ifdef __KERNEL__\n#include <linux/uidgid.h>\n\n/* key handle serial number */\ntypedef int32_t key_serial_t;\n\n/* key handle permissions mask */\ntypedef uint32_t key_perm_t;\n\nstruct key;\n\n#ifdef CONFIG_KEYS\n\n#undef KEY_DEBUGGING\n\n#define KEY_POS_VIEW\t0x01000000\t/* possessor can view a key's attributes */\n#define KEY_POS_READ\t0x02000000\t/* possessor can read key payload / view keyring */\n#define KEY_POS_WRITE\t0x04000000\t/* possessor can update key payload / add link to keyring */\n#define KEY_POS_SEARCH\t0x08000000\t/* possessor can find a key in search / search a keyring */\n#define KEY_POS_LINK\t0x10000000\t/* possessor can create a link to a key/keyring */\n#define KEY_POS_SETATTR\t0x20000000\t/* possessor can set key attributes */\n#define KEY_POS_ALL\t0x3f000000\n\n#define KEY_USR_VIEW\t0x00010000\t/* user permissions... */\n#define KEY_USR_READ\t0x00020000\n#define KEY_USR_WRITE\t0x00040000\n#define KEY_USR_SEARCH\t0x00080000\n#define KEY_USR_LINK\t0x00100000\n#define KEY_USR_SETATTR\t0x00200000\n#define KEY_USR_ALL\t0x003f0000\n\n#define KEY_GRP_VIEW\t0x00000100\t/* group permissions... */\n#define KEY_GRP_READ\t0x00000200\n#define KEY_GRP_WRITE\t0x00000400\n#define KEY_GRP_SEARCH\t0x00000800\n#define KEY_GRP_LINK\t0x00001000\n#define KEY_GRP_SETATTR\t0x00002000\n#define KEY_GRP_ALL\t0x00003f00\n\n#define KEY_OTH_VIEW\t0x00000001\t/* third party permissions... */\n#define KEY_OTH_READ\t0x00000002\n#define KEY_OTH_WRITE\t0x00000004\n#define KEY_OTH_SEARCH\t0x00000008\n#define KEY_OTH_LINK\t0x00000010\n#define KEY_OTH_SETATTR\t0x00000020\n#define KEY_OTH_ALL\t0x0000003f\n\n#define KEY_PERM_UNDEF\t0xffffffff\n\nstruct seq_file;\nstruct user_struct;\nstruct signal_struct;\nstruct cred;\n\nstruct key_type;\nstruct key_owner;\nstruct keyring_list;\nstruct keyring_name;\n\nstruct keyring_index_key {\n\tstruct key_type\t\t*type;\n\tconst char\t\t*description;\n\tsize_t\t\t\tdesc_len;\n};\n\nunion key_payload {\n\tvoid __rcu\t\t*rcu_data0;\n\tvoid\t\t\t*data[4];\n};\n\n/*****************************************************************************/\n/*\n * key reference with possession attribute handling\n *\n * NOTE! key_ref_t is a typedef'd pointer to a type that is not actually\n * defined. This is because we abuse the bottom bit of the reference to carry a\n * flag to indicate whether the calling process possesses that key in one of\n * its keyrings.\n *\n * the key_ref_t has been made a separate type so that the compiler can reject\n * attempts to dereference it without proper conversion.\n *\n * the three functions are used to assemble and disassemble references\n */\ntypedef struct __key_reference_with_attributes *key_ref_t;\n\nstatic inline key_ref_t make_key_ref(const struct key *key,\n\t\t\t\t     bool possession)\n{\n\treturn (key_ref_t) ((unsigned long) key | possession);\n}\n\nstatic inline struct key *key_ref_to_ptr(const key_ref_t key_ref)\n{\n\treturn (struct key *) ((unsigned long) key_ref & ~1UL);\n}\n\nstatic inline bool is_key_possessed(const key_ref_t key_ref)\n{\n\treturn (unsigned long) key_ref & 1UL;\n}\n\ntypedef int (*key_restrict_link_func_t)(struct key *dest_keyring,\n\t\t\t\t\tconst struct key_type *type,\n\t\t\t\t\tconst union key_payload *payload,\n\t\t\t\t\tstruct key *restriction_key);\n\nstruct key_restriction {\n\tkey_restrict_link_func_t check;\n\tstruct key *key;\n\tstruct key_type *keytype;\n};\n\n/*****************************************************************************/\n/*\n * authentication token / access credential / keyring\n * - types of key include:\n *   - keyrings\n *   - disk encryption IDs\n *   - Kerberos TGTs and tickets\n */\nstruct key {\n\trefcount_t\t\tusage;\t\t/* number of references */\n\tkey_serial_t\t\tserial;\t\t/* key serial number */\n\tunion {\n\t\tstruct list_head graveyard_link;\n\t\tstruct rb_node\tserial_node;\n\t};\n\tstruct rw_semaphore\tsem;\t\t/* change vs change sem */\n\tstruct key_user\t\t*user;\t\t/* owner of this key */\n\tvoid\t\t\t*security;\t/* security data for this key */\n\tunion {\n\t\ttime_t\t\texpiry;\t\t/* time at which key expires (or 0) */\n\t\ttime_t\t\trevoked_at;\t/* time at which key was revoked */\n\t};\n\ttime_t\t\t\tlast_used_at;\t/* last time used for LRU keyring discard */\n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tkey_perm_t\t\tperm;\t\t/* access permissions */\n\tunsigned short\t\tquotalen;\t/* length added to quota */\n\tunsigned short\t\tdatalen;\t/* payload data length\n\t\t\t\t\t\t * - may not match RCU dereferenced payload\n\t\t\t\t\t\t * - payload should contain own length\n\t\t\t\t\t\t */\n\n#ifdef KEY_DEBUGGING\n\tunsigned\t\tmagic;\n#define KEY_DEBUG_MAGIC\t\t0x18273645u\n#endif\n\n\tunsigned long\t\tflags;\t\t/* status flags (change with bitops) */\n#define KEY_FLAG_INSTANTIATED\t0\t/* set if key has been instantiated */\n#define KEY_FLAG_DEAD\t\t1\t/* set if key type has been deleted */\n#define KEY_FLAG_REVOKED\t2\t/* set if key had been revoked */\n#define KEY_FLAG_IN_QUOTA\t3\t/* set if key consumes quota */\n#define KEY_FLAG_USER_CONSTRUCT\t4\t/* set if key is being constructed in userspace */\n#define KEY_FLAG_NEGATIVE\t5\t/* set if key is negative */\n#define KEY_FLAG_ROOT_CAN_CLEAR\t6\t/* set if key can be cleared by root without permission */\n#define KEY_FLAG_INVALIDATED\t7\t/* set if key has been invalidated */\n#define KEY_FLAG_BUILTIN\t8\t/* set if key is built in to the kernel */\n#define KEY_FLAG_ROOT_CAN_INVAL\t9\t/* set if key can be invalidated by root without permission */\n#define KEY_FLAG_KEEP\t\t10\t/* set if key should not be removed */\n#define KEY_FLAG_UID_KEYRING\t11\t/* set if key is a user or user session keyring */\n\n\t/* the key type and key description string\n\t * - the desc is used to match a key against search criteria\n\t * - it should be a printable string\n\t * - eg: for krb5 AFS, this might be \"afs@REDHAT.COM\"\n\t */\n\tunion {\n\t\tstruct keyring_index_key index_key;\n\t\tstruct {\n\t\t\tstruct key_type\t*type;\t\t/* type of key */\n\t\t\tchar\t\t*description;\n\t\t};\n\t};\n\n\t/* key data\n\t * - this is used to hold the data actually used in cryptography or\n\t *   whatever\n\t */\n\tunion {\n\t\tunion key_payload payload;\n\t\tstruct {\n\t\t\t/* Keyring bits */\n\t\t\tstruct list_head name_link;\n\t\t\tstruct assoc_array keys;\n\t\t};\n\t\tint reject_error;\n\t};\n\n\t/* This is set on a keyring to restrict the addition of a link to a key\n\t * to it.  If this structure isn't provided then it is assumed that the\n\t * keyring is open to any addition.  It is ignored for non-keyring\n\t * keys. Only set this value using keyring_restrict(), keyring_alloc(),\n\t * or key_alloc().\n\t *\n\t * This is intended for use with rings of trusted keys whereby addition\n\t * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION\n\t * overrides this, allowing the kernel to add extra keys without\n\t * restriction.\n\t */\n\tstruct key_restriction *restrict_link;\n};\n\nextern struct key *key_alloc(struct key_type *type,\n\t\t\t     const char *desc,\n\t\t\t     kuid_t uid, kgid_t gid,\n\t\t\t     const struct cred *cred,\n\t\t\t     key_perm_t perm,\n\t\t\t     unsigned long flags,\n\t\t\t     struct key_restriction *restrict_link);\n\n\n#define KEY_ALLOC_IN_QUOTA\t\t0x0000\t/* add to quota, reject if would overrun */\n#define KEY_ALLOC_QUOTA_OVERRUN\t\t0x0001\t/* add to quota, permit even if overrun */\n#define KEY_ALLOC_NOT_IN_QUOTA\t\t0x0002\t/* not in quota */\n#define KEY_ALLOC_BUILT_IN\t\t0x0004\t/* Key is built into kernel */\n#define KEY_ALLOC_BYPASS_RESTRICTION\t0x0008\t/* Override the check on restricted keyrings */\n#define KEY_ALLOC_UID_KEYRING\t\t0x0010\t/* allocating a user or user session keyring */\n\nextern void key_revoke(struct key *key);\nextern void key_invalidate(struct key *key);\nextern void key_put(struct key *key);\n\nstatic inline struct key *__key_get(struct key *key)\n{\n\trefcount_inc(&key->usage);\n\treturn key;\n}\n\nstatic inline struct key *key_get(struct key *key)\n{\n\treturn key ? __key_get(key) : key;\n}\n\nstatic inline void key_ref_put(key_ref_t key_ref)\n{\n\tkey_put(key_ref_to_ptr(key_ref));\n}\n\nextern struct key *request_key(struct key_type *type,\n\t\t\t       const char *description,\n\t\t\t       const char *callout_info);\n\nextern struct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t\t    const char *description,\n\t\t\t\t\t    const void *callout_info,\n\t\t\t\t\t    size_t callout_len,\n\t\t\t\t\t    void *aux);\n\nextern struct key *request_key_async(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len);\n\nextern struct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t\t  const char *description,\n\t\t\t\t\t\t  const void *callout_info,\n\t\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t\t  void *aux);\n\nextern int wait_for_key_construction(struct key *key, bool intr);\n\nextern int key_validate(const struct key *key);\n\nextern key_ref_t key_create_or_update(key_ref_t keyring,\n\t\t\t\t      const char *type,\n\t\t\t\t      const char *description,\n\t\t\t\t      const void *payload,\n\t\t\t\t      size_t plen,\n\t\t\t\t      key_perm_t perm,\n\t\t\t\t      unsigned long flags);\n\nextern int key_update(key_ref_t key,\n\t\t      const void *payload,\n\t\t      size_t plen);\n\nextern int key_link(struct key *keyring,\n\t\t    struct key *key);\n\nextern int key_unlink(struct key *keyring,\n\t\t      struct key *key);\n\nextern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t\t const struct cred *cred,\n\t\t\t\t key_perm_t perm,\n\t\t\t\t unsigned long flags,\n\t\t\t\t struct key_restriction *restrict_link,\n\t\t\t\t struct key *dest);\n\nextern int restrict_link_reject(struct key *keyring,\n\t\t\t\tconst struct key_type *type,\n\t\t\t\tconst union key_payload *payload,\n\t\t\t\tstruct key *restriction_key);\n\nextern int keyring_clear(struct key *keyring);\n\nextern key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t\tstruct key_type *type,\n\t\t\t\tconst char *description);\n\nextern int keyring_add_key(struct key *keyring,\n\t\t\t   struct key *key);\n\nextern int keyring_restrict(key_ref_t keyring, const char *type,\n\t\t\t    const char *restriction);\n\nextern struct key *key_lookup(key_serial_t id);\n\nstatic inline key_serial_t key_serial(const struct key *key)\n{\n\treturn key ? key->serial : 0;\n}\n\nextern void key_set_timeout(struct key *, unsigned);\n\n/*\n * The permissions required on a key that we're looking up.\n */\n#define\tKEY_NEED_VIEW\t0x01\t/* Require permission to view attributes */\n#define\tKEY_NEED_READ\t0x02\t/* Require permission to read content */\n#define\tKEY_NEED_WRITE\t0x04\t/* Require permission to update / modify */\n#define\tKEY_NEED_SEARCH\t0x08\t/* Require permission to search (keyring) or find (key) */\n#define\tKEY_NEED_LINK\t0x10\t/* Require permission to link */\n#define\tKEY_NEED_SETATTR 0x20\t/* Require permission to change attributes */\n#define\tKEY_NEED_ALL\t0x3f\t/* All the above permissions */\n\n/**\n * key_is_instantiated - Determine if a key has been positively instantiated\n * @key: The key to check.\n *\n * Return true if the specified key has been positively instantiated, false\n * otherwise.\n */\nstatic inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}\n\n#define dereference_key_rcu(KEY)\t\t\t\t\t\\\n\t(rcu_dereference((KEY)->payload.rcu_data0))\n\n#define dereference_key_locked(KEY)\t\t\t\t\t\\\n\t(rcu_dereference_protected((KEY)->payload.rcu_data0,\t\t\\\n\t\t\t\t   rwsem_is_locked(&((struct key *)(KEY))->sem)))\n\n#define rcu_assign_keypointer(KEY, PAYLOAD)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_assign_pointer((KEY)->payload.rcu_data0, (PAYLOAD));\t\\\n} while (0)\n\n#ifdef CONFIG_SYSCTL\nextern struct ctl_table key_sysctls[];\n#endif\n/*\n * the userspace interface\n */\nextern int install_thread_keyring_to_cred(struct cred *cred);\nextern void key_fsuid_changed(struct task_struct *tsk);\nextern void key_fsgid_changed(struct task_struct *tsk);\nextern void key_init(void);\n\n#else /* CONFIG_KEYS */\n\n#define key_validate(k)\t\t\t0\n#define key_serial(k)\t\t\t0\n#define key_get(k) \t\t\t({ NULL; })\n#define key_revoke(k)\t\t\tdo { } while(0)\n#define key_invalidate(k)\t\tdo { } while(0)\n#define key_put(k)\t\t\tdo { } while(0)\n#define key_ref_put(k)\t\t\tdo { } while(0)\n#define make_key_ref(k, p)\t\tNULL\n#define key_ref_to_ptr(k)\t\tNULL\n#define is_key_possessed(k)\t\t0\n#define key_fsuid_changed(t)\t\tdo { } while(0)\n#define key_fsgid_changed(t)\t\tdo { } while(0)\n#define key_init()\t\t\tdo { } while(0)\n\n#endif /* CONFIG_KEYS */\n#endif /* __KERNEL__ */\n#endif /* _LINUX_KEY_H */\n", "/* Authentication token and access key management internal defs\n *\n * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#ifndef _INTERNAL_H\n#define _INTERNAL_H\n\n#include <linux/sched.h>\n#include <linux/wait_bit.h>\n#include <linux/cred.h>\n#include <linux/key-type.h>\n#include <linux/task_work.h>\n#include <linux/keyctl.h>\n#include <linux/refcount.h>\n#include <linux/compat.h>\n\nstruct iovec;\n\n#ifdef __KDEBUG\n#define kenter(FMT, ...) \\\n\tprintk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tprintk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tprintk(KERN_DEBUG \"   \"FMT\"\\n\", ##__VA_ARGS__)\n#else\n#define kenter(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tno_printk(KERN_DEBUG FMT\"\\n\", ##__VA_ARGS__)\n#endif\n\nextern struct key_type key_type_dead;\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\n/*****************************************************************************/\n/*\n * Keep track of keys for a user.\n *\n * This needs to be separate to user_struct to avoid a refcount-loop\n * (user_struct pins some keyrings which pin this struct).\n *\n * We also keep track of keys under request from userspace for this UID here.\n */\nstruct key_user {\n\tstruct rb_node\t\tnode;\n\tstruct mutex\t\tcons_lock;\t/* construction initiation lock */\n\tspinlock_t\t\tlock;\n\trefcount_t\t\tusage;\t\t/* for accessing qnkeys & qnbytes */\n\tatomic_t\t\tnkeys;\t\t/* number of keys */\n\tatomic_t\t\tnikeys;\t\t/* number of instantiated keys */\n\tkuid_t\t\t\tuid;\n\tint\t\t\tqnkeys;\t\t/* number of keys allocated to this user */\n\tint\t\t\tqnbytes;\t/* number of bytes allocated to this user */\n};\n\nextern struct rb_root\tkey_user_tree;\nextern spinlock_t\tkey_user_lock;\nextern struct key_user\troot_key_user;\n\nextern struct key_user *key_user_lookup(kuid_t uid);\nextern void key_user_put(struct key_user *user);\n\n/*\n * Key quota limits.\n * - root has its own separate limits to everyone else\n */\nextern unsigned key_quota_root_maxkeys;\nextern unsigned key_quota_root_maxbytes;\nextern unsigned key_quota_maxkeys;\nextern unsigned key_quota_maxbytes;\n\n#define KEYQUOTA_LINK_BYTES\t4\t\t/* a link in a keyring is worth 4 bytes */\n\n\nextern struct kmem_cache *key_jar;\nextern struct rb_root key_serial_tree;\nextern spinlock_t key_serial_lock;\nextern struct mutex key_construction_mutex;\nextern wait_queue_head_t request_key_conswq;\n\n\nextern struct key_type *key_type_lookup(const char *type);\nextern void key_type_put(struct key_type *ktype);\n\nextern int __key_link_begin(struct key *keyring,\n\t\t\t    const struct keyring_index_key *index_key,\n\t\t\t    struct assoc_array_edit **_edit);\nextern int __key_link_check_live_key(struct key *keyring, struct key *key);\nextern void __key_link(struct key *key, struct assoc_array_edit **_edit);\nextern void __key_link_end(struct key *keyring,\n\t\t\t   const struct keyring_index_key *index_key,\n\t\t\t   struct assoc_array_edit *edit);\n\nextern key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t\t    const struct keyring_index_key *index_key);\n\nextern struct key *keyring_search_instkey(struct key *keyring,\n\t\t\t\t\t  key_serial_t target_id);\n\nextern int iterate_over_keyring(const struct key *keyring,\n\t\t\t\tint (*func)(const struct key *key, void *data),\n\t\t\t\tvoid *data);\n\nstruct keyring_search_context {\n\tstruct keyring_index_key index_key;\n\tconst struct cred\t*cred;\n\tstruct key_match_data\tmatch_data;\n\tunsigned\t\tflags;\n#define KEYRING_SEARCH_NO_STATE_CHECK\t0x0001\t/* Skip state checks */\n#define KEYRING_SEARCH_DO_STATE_CHECK\t0x0002\t/* Override NO_STATE_CHECK */\n#define KEYRING_SEARCH_NO_UPDATE_TIME\t0x0004\t/* Don't update times */\n#define KEYRING_SEARCH_NO_CHECK_PERM\t0x0008\t/* Don't check permissions */\n#define KEYRING_SEARCH_DETECT_TOO_DEEP\t0x0010\t/* Give an error on excessive depth */\n#define KEYRING_SEARCH_SKIP_EXPIRED\t0x0020\t/* Ignore expired keys (intention to replace) */\n\n\tint (*iterator)(const void *object, void *iterator_data);\n\n\t/* Internal stuff */\n\tint\t\t\tskipped_ret;\n\tbool\t\t\tpossessed;\n\tkey_ref_t\t\tresult;\n\tstruct timespec\t\tnow;\n};\n\nextern bool key_default_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data);\nextern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t\t    struct keyring_search_context *ctx);\n\nextern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);\nextern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);\n\nextern struct key *find_keyring_by_name(const char *name, bool uid_keyring);\n\nextern int install_user_keyrings(void);\nextern int install_thread_keyring_to_cred(struct cred *);\nextern int install_process_keyring_to_cred(struct cred *);\nextern int install_session_keyring_to_cred(struct cred *, struct key *);\n\nextern struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t\tconst char *description,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tvoid *aux,\n\t\t\t\t\tstruct key *dest_keyring,\n\t\t\t\t\tunsigned long flags);\n\nextern bool lookup_user_key_possessed(const struct key *key,\n\t\t\t\t      const struct key_match_data *match_data);\nextern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,\n\t\t\t\t key_perm_t perm);\n#define KEY_LOOKUP_CREATE\t0x01\n#define KEY_LOOKUP_PARTIAL\t0x02\n#define KEY_LOOKUP_FOR_UNLINK\t0x04\n\nextern long join_session_keyring(const char *name);\nextern void key_change_session_keyring(struct callback_head *twork);\n\nextern struct work_struct key_gc_work;\nextern unsigned key_gc_delay;\nextern void keyring_gc(struct key *keyring, time_t limit);\nextern void keyring_restriction_gc(struct key *keyring,\n\t\t\t\t   struct key_type *dead_type);\nextern void key_schedule_gc(time_t gc_at);\nextern void key_schedule_gc_links(void);\nextern void key_gc_keytype(struct key_type *ktype);\n\nextern int key_task_permission(const key_ref_t key_ref,\n\t\t\t       const struct cred *cred,\n\t\t\t       key_perm_t perm);\n\n/*\n * Check to see whether permission is granted to use a key in the desired way.\n */\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}\n\n/*\n * Authorisation record for request_key().\n */\nstruct request_key_auth {\n\tstruct key\t\t*target_key;\n\tstruct key\t\t*dest_keyring;\n\tconst struct cred\t*cred;\n\tvoid\t\t\t*callout_info;\n\tsize_t\t\t\tcallout_len;\n\tpid_t\t\t\tpid;\n} __randomize_layout;\n\nextern struct key_type key_type_request_key_auth;\nextern struct key *request_key_auth_new(struct key *target,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tstruct key *dest_keyring);\n\nextern struct key *key_get_instantiation_authkey(key_serial_t target_id);\n\n/*\n * Determine whether a key is dead.\n */\nstatic inline bool key_is_dead(const struct key *key, time_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}\n\n/*\n * keyctl() functions\n */\nextern long keyctl_get_keyring_ID(key_serial_t, int);\nextern long keyctl_join_session_keyring(const char __user *);\nextern long keyctl_update_key(key_serial_t, const void __user *, size_t);\nextern long keyctl_revoke_key(key_serial_t);\nextern long keyctl_keyring_clear(key_serial_t);\nextern long keyctl_keyring_link(key_serial_t, key_serial_t);\nextern long keyctl_keyring_unlink(key_serial_t, key_serial_t);\nextern long keyctl_describe_key(key_serial_t, char __user *, size_t);\nextern long keyctl_keyring_search(key_serial_t, const char __user *,\n\t\t\t\t  const char __user *, key_serial_t);\nextern long keyctl_read_key(key_serial_t, char __user *, size_t);\nextern long keyctl_chown_key(key_serial_t, uid_t, gid_t);\nextern long keyctl_setperm_key(key_serial_t, key_perm_t);\nextern long keyctl_instantiate_key(key_serial_t, const void __user *,\n\t\t\t\t   size_t, key_serial_t);\nextern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);\nextern long keyctl_set_reqkey_keyring(int);\nextern long keyctl_set_timeout(key_serial_t, unsigned);\nextern long keyctl_assume_authority(key_serial_t);\nextern long keyctl_get_security(key_serial_t keyid, char __user *buffer,\n\t\t\t\tsize_t buflen);\nextern long keyctl_session_to_parent(void);\nextern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);\nextern long keyctl_instantiate_key_iov(key_serial_t,\n\t\t\t\t       const struct iovec __user *,\n\t\t\t\t       unsigned, key_serial_t);\nextern long keyctl_invalidate_key(key_serial_t);\n\nstruct iov_iter;\nextern long keyctl_instantiate_key_common(key_serial_t,\n\t\t\t\t\t  struct iov_iter *,\n\t\t\t\t\t  key_serial_t);\nextern long keyctl_restrict_keyring(key_serial_t id,\n\t\t\t\t    const char __user *_type,\n\t\t\t\t    const char __user *_restriction);\n#ifdef CONFIG_PERSISTENT_KEYRINGS\nextern long keyctl_get_persistent(uid_t, key_serial_t);\nextern unsigned persistent_keyring_expiry;\n#else\nstatic inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n#ifdef CONFIG_KEY_DH_OPERATIONS\nextern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,\n\t\t\t      size_t, struct keyctl_kdf_params __user *);\nextern long __keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,\n\t\t\t\tsize_t, struct keyctl_kdf_params *);\n#ifdef CONFIG_KEYS_COMPAT\nextern long compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t\tchar __user *buffer, size_t buflen,\n\t\t\t\tstruct compat_keyctl_kdf_params __user *kdf);\n#endif\n#define KEYCTL_KDF_MAX_OUTPUT_LEN\t1024\t/* max length of KDF output */\n#define KEYCTL_KDF_MAX_OI_LEN\t\t64\t/* max length of otherinfo */\n#else\nstatic inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t\t     char __user *buffer, size_t buflen,\n\t\t\t\t     struct keyctl_kdf_params __user *kdf)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#ifdef CONFIG_KEYS_COMPAT\nstatic inline long compat_keyctl_dh_compute(\n\t\t\t\tstruct keyctl_dh_params __user *params,\n\t\t\t\tchar __user *buffer, size_t buflen,\n\t\t\t\tstruct keyctl_kdf_params __user *kdf)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n#endif\n\n/*\n * Debugging key validation\n */\n#ifdef KEY_DEBUGGING\nextern void __key_check(const struct key *);\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}\n\n#else\n\n#define key_check(key) do {} while(0)\n\n#endif\n\n#endif /* _INTERNAL_H */\n", "/* Basic authentication token and access key management\n *\n * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree; /* tree of keys indexed by serial */\nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree; /* tree of quota records indexed by UID */\nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 1000000;\t/* root's key count quota */\nunsigned int key_quota_root_maxbytes = 25000000; /* root's key space quota */\nunsigned int key_quota_maxkeys = 200;\t\t/* general key count quota */\nunsigned int key_quota_maxbytes = 20000;\t/* general key space quota */\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n/* We serialise key instantiation and link */\nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n/*\n * Get the key quota record for a user, allocating a new record if one doesn't\n * already exist.\n */\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p;\n\ntry_again:\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n/*\n * Dispose of a user structure\n */\nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n/*\n * Allocate a serial number for a key.  These are assigned randomly to avoid\n * security issues through covert channel problems.\n */\nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t/* propose a random serial number and look for a hole for it in the\n\t * serial number tree */\n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1; /* negative numbers are not permitted */\n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t/* we've found a suitable hole - arrange for this key to occupy it */\n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t/* we found a key with the proposed serial number - walk the tree from\n\t * that point looking for the next unused serial number */\nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n/**\n * key_alloc - Allocate a key of the specified type.\n * @type: The type of key to allocate.\n * @desc: The key description to allow the key to be searched out.\n * @uid: The owner of the new key.\n * @gid: The group ID for the new key's group permissions.\n * @cred: The credentials specifying UID namespace.\n * @perm: The permissions mask of the new key.\n * @flags: Flags specifying quota properties.\n * @restrict_link: Optional link restriction for new keyrings.\n *\n * Allocate a key of the specified type with the attributes given.  The key is\n * returned in an uninstantiated state and the caller needs to instantiate the\n * key before returning.\n *\n * The restrict_link structure (if not NULL) will be freed when the\n * keyring is destroyed, so it must be dynamically allocated.\n *\n * The user's key count quota is updated to reflect the creation of the key and\n * the user's key data quota has the default for the key type reserved.  The\n * instantiation function should amend this as necessary.  If insufficient\n * quota is available, -EDQUOT will be returned.\n *\n * The LSM security modules can prevent a key being created, in which case\n * -EACCES will be returned.\n *\n * Returns a pointer to the new key if successful and an error code otherwise.\n *\n * Note that the caller needs to ensure the key type isn't uninstantiated.\n * Internally this can be done by locking key_types_sem.  Externally, this can\n * be done by either never unregistering the key type, or making sure\n * key_alloc() calls don't race with module unloading.\n */\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n/**\n * key_payload_reserve - Adjust data quota reservation for the key's payload\n * @key: The key to make the reservation for.\n * @datalen: The amount of data payload the caller now wants.\n *\n * Adjust the amount of the owning user's key data quota that a key reserves.\n * If the amount is increased, then -EDQUOT may be returned if there isn't\n * enough free quota available.\n *\n * If successful, 0 is returned.\n */\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n/*\n * Instantiate a key and link it into the target keyring atomically.  Must be\n * called with the target keyring's semaphore writelocked.  The target key's\n * semaphore need not be locked as instantiation is serialised by\n * key_construction_mutex.\n */\nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\n\t\t\t/* disable the authorisation key */\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n/**\n * key_instantiate_and_link - Instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @data: The data to use to instantiate the keyring.\n * @datalen: The length of @data.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Instantiate a key that's in the uninstantiated state using the provided data\n * and, if successful, link it in to the destination keyring if one is\n * supplied.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n/**\n * key_reject_and_link - Negatively instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @timeout: The timeout on the negative key.\n * @error: The error to return when the key is hit.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Negatively instantiate a key that's in the uninstantiated state and, if\n * successful, set its timeout and stored error and link it in to the\n * destination keyring if one is supplied.  The key and any links to the key\n * will be automatically garbage collected after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the stored error code (typically ENOKEY) until the negative\n * key expires.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n/**\n * key_put - Discard a reference to a key.\n * @key: The key to discard a reference from.\n *\n * Discard a reference to a key, and when all the references are gone, we\n * schedule the cleanup task to come and pull it out of the tree in process\n * context at some later time.\n */\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n/*\n * Find a key by its serial number.\n */\nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t/* search the tree for the specified key */\n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t/* A key is allowed to be looked up only if someone still owns a\n\t * reference to it - otherwise it's awaiting the gc.\n\t */\n\tif (!refcount_inc_not_zero(&key->usage))\n\t\tgoto not_found;\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n/*\n * Find and lock the specified key type against removal.\n *\n * We return with the sem read-locked if successful.  If the type wasn't\n * available -ENOKEY is returned instead.\n */\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n/*\n * Unlock a key type locked by key_type_lookup().\n */\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n/*\n * Attempt to update an existing key.\n *\n * The key is given to us with an incremented refcount that we need to discard\n * if we get an error.\n */\nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n/**\n * key_create_or_update - Update or create and instantiate a key.\n * @keyring_ref: A pointer to the destination keyring with possession flag.\n * @type: The type of key.\n * @description: The searchable description for the key.\n * @payload: The data to use to instantiate or update the key.\n * @plen: The length of @payload.\n * @perm: The permissions mask for a new key.\n * @flags: The quota flags for a new key.\n *\n * Search the destination keyring for a key of the same description and if one\n * is found, update it, otherwise create and instantiate a new one and create a\n * link to it from that keyring.\n *\n * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be\n * concocted.\n *\n * Returns a pointer to the new key if successful, -ENODEV if the key type\n * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the\n * caller isn't permitted to modify the keyring or the LSM did not permit\n * creation of the key.\n *\n * On success, the possession flag from the keyring ref will be tacked on to\n * the key ref before it is returned.\n */\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n/**\n * key_update - Update a key's contents.\n * @key_ref: The pointer (plus possession flag) to the key.\n * @payload: The data to be used to update the key.\n * @plen: The length of @payload.\n *\n * Attempt to update the contents of a key with the given payload data.  The\n * caller must be granted Write permission on the key.  Negative keys can be\n * instantiated by this method.\n *\n * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key\n * type does not support updating.  The key type may return other errors.\n */\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attempt to update it if supported */\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n/**\n * key_revoke - Revoke a key.\n * @key: The key to be revoked.\n *\n * Mark a key as being revoked and ask the type to free up its resources.  The\n * revocation timeout is set and the key and all its links will be\n * automatically garbage collected after key_gc_delay amount of time if they\n * are not manually dealt with first.\n */\nvoid key_revoke(struct key *key)\n{\n\tstruct timespec now;\n\ttime_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\tnow = current_kernel_time();\n\ttime = now.tv_sec;\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n/**\n * key_invalidate - Invalidate a key.\n * @key: The key to be invalidated.\n *\n * Mark a key as being invalidated and have it cleaned up immediately.  The key\n * is ignored by all searches and other operations from this point.\n */\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n/**\n * generic_key_instantiate - Simple instantiation of a key from preparsed data\n * @key: The key to be instantiated\n * @prep: The preparsed data to load.\n *\n * Instantiate a key from preparsed data.  We assume we can just copy the data\n * in directly and clear the old pointers.\n *\n * This can be pointed to directly by the key type instantiate op pointer.\n */\nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\trcu_assign_keypointer(key, prep->payload.data[0]);\n\t\tkey->payload.data[1] = prep->payload.data[1];\n\t\tkey->payload.data[2] = prep->payload.data[2];\n\t\tkey->payload.data[3] = prep->payload.data[3];\n\t\tprep->payload.data[0] = NULL;\n\t\tprep->payload.data[1] = NULL;\n\t\tprep->payload.data[2] = NULL;\n\t\tprep->payload.data[3] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n/**\n * register_key_type - Register a type of key.\n * @ktype: The new key type.\n *\n * Register a new key type.\n *\n * Returns 0 on success or -EEXIST if a type of this name already exists.\n */\nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n/**\n * unregister_key_type - Unregister a type of key.\n * @ktype: The key type.\n *\n * Unregister a key type and mark all the extant keys of this type as dead.\n * Those keys of this type are then destroyed to get rid of their payloads and\n * they and their links will be garbage collected as soon as possible.\n */\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n/*\n * Initialise the key management state.\n */\nvoid __init key_init(void)\n{\n\t/* allocate a slab in which we can store keys */\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* add the special key types */\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t/* record the root user tracking */\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n", "/* Keyring handling\n *\n * Copyright (C) 2004-2005, 2008, 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/*\n * When plumbing the depths of the key tree, this sets a hard limit\n * set on how deep we're willing to go.\n */\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n/*\n * We keep all named keyrings in a hash to speed looking them up.\n */\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\n/*\n * We mark pointers we pass to the associative array with bit 1 set if\n * they're keyrings and clear otherwise.\n */\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}\n\n/*\n * The keyring key type definition.  Keyrings are simply keys of this type and\n * can be treated as ordinary keys in addition to having their own special\n * operations.\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n/*\n * Semaphore to serialise link/link calls to prevent two link calls in parallel\n * introducing a cycle.\n */\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\n/*\n * Publish the name of a keyring so that it can be found by name (if it has\n * one).\n */\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n/*\n * Preparse a keyring payload\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n/*\n * Free a preparse of a user defined key payload\n */\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Initialise a keyring.\n *\n * Returns 0 on success, -EINVAL if given any data.\n */\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n/*\n * Multiply 64-bits by 32-bits to 96-bits and fold back to 64-bit.  Ideally we'd\n * fold the carry back too, but that requires inline asm.\n */\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n/*\n * Hash a key type and description.\n */\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\n\n/*\n * Build the next index key chunk.\n *\n * On 32-bit systems the index key is laid out as:\n *\n *\t0\t4\t5\t9...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * On 64-bit systems:\n *\n *\t0\t8\t9\t17...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * We return it one word-sized chunk at a time.\n */\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n/*\n * Compare the index keys of a pair of objects and determine the bit position\n * at which they differ - if they differ.\n */\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n/*\n * Free an object after stripping the keyring flag off of the pointer.\n */\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n/*\n * Operations for keyring management by the index-tree routines.\n */\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n/*\n * Clean up a keyring when it is destroyed.  Unpublish its name if it had one\n * and dispose of its data.\n *\n * The garbage collector detects the final key_put(), removes the keyring from\n * the serial number tree and then does RCU synchronisation before coming here,\n * so we shouldn't need to worry about code poking around here with the RCU\n * readlock held by this time.\n */\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n/*\n * Describe a keyring for /proc.\n */\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tbuflen;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n/*\n * Read a list of key IDs from the keyring's contents in binary form\n *\n * The keyring's semaphore is read-locked by the caller.  This prevents someone\n * from modifying it under us - which could cause us to read key IDs multiple\n * times.\n */\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\n\t/* Calculate how much data we could return */\n\tif (!buffer || !buflen)\n\t\treturn nr_keys * sizeof(key_serial_t);\n\n\t/* Copy the IDs of the subscribed keys into the buffer */\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.buflen = buflen;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\n\n/*\n * Allocate a keyring and link into the destination keyring.\n */\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n/**\n * restrict_link_reject - Give -EPERM to restrict link\n * @keyring: The keyring being added to.\n * @type: The type of key being added.\n * @payload: The payload of the key intended to be added.\n * @data: Additional data for evaluating restriction.\n *\n * Reject the addition of any links to a keyring.  It can be overridden by\n * passing KEY_ALLOC_BYPASS_RESTRICTION to key_instantiate_and_link() when\n * adding a key to a keyring.\n *\n * This is meant to be stored in a key_restriction structure which is passed\n * in the restrict_link parameter to keyring_alloc().\n */\nint restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}\n\n/*\n * By default, we keys found by getting an exact match on their descriptions.\n */\nbool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\n/*\n * Iteration function to consider each key found.\n */\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n/*\n * Search inside a keyring for a key.  We can search by walking to it\n * directly based on its index-key or we can iterate over the entire\n * tree looking for it, based on the match function.\n */\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n/*\n * Search a tree of keyrings that point to other keyrings up to the maximum\n * depth.\n */\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n/**\n * keyring_search_aux - Search a keyring tree for a key matching some criteria\n * @keyring_ref: A pointer to the keyring with possession indicator.\n * @ctx: The keyring search context.\n *\n * Search the supplied keyring tree for a key that matches the criteria given.\n * The root keyring and any linked keyrings must grant Search permission to the\n * caller to be searchable and keys can only be found if they too grant Search\n * to the caller. The possession flag on the root keyring pointer controls use\n * of the possessor bits in permissions checking of the entire tree.  In\n * addition, the LSM gets to forbid keyring searches and key matches.\n *\n * The search is performed as a breadth-then-depth search up to the prescribed\n * limit (KEYRING_SEARCH_MAX_DEPTH).\n *\n * Keys are matched to the type provided and are then filtered by the match\n * function, which is given the description to use in any way it sees fit.  The\n * match function may use any attributes of a key that it wishes to to\n * determine the match.  Normally the match function from the key type would be\n * used.\n *\n * RCU can be used to prevent the keyring key lists from disappearing without\n * the need to take lots of locks.\n *\n * Returns a pointer to the found key and increments the key usage count if\n * successful; -EAGAIN if no matching keys were found, or if expired or revoked\n * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the\n * specified keyring wasn't a keyring.\n *\n * In the case of a successful return, the possession attribute from\n * @keyring_ref is propagated to the returned key reference.\n */\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}\n\n/**\n * keyring_search - Search the supplied keyring tree for a matching key\n * @keyring: The root of the keyring tree to be searched.\n * @type: The type of keyring we want to find.\n * @description: The name of the keyring we want to find.\n *\n * As keyring_search_aux() above, but using the current task's credentials and\n * type's default matching function and preferred search method.\n */\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}\n\n/*\n * Semaphore to serialise restriction setup to prevent reference count\n * cycles through restriction key pointers.\n */\nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\n/*\n * Check for restriction cycles that would prevent keyring garbage collection.\n * keyring_serialise_restrict_sem must be held.\n */\nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}\n\n/**\n * keyring_restrict - Look up and apply a restriction to a keyring\n *\n * @keyring: The keyring to be restricted\n * @restriction: The restriction options to apply to the keyring\n */\nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_restrict);\n\n/*\n * Search the given keyring for a key that might be updated.\n *\n * The caller must guarantee that the keyring is a keyring and that the\n * permission is granted to modify the keyring as no check is made here.  The\n * caller must also hold a lock on the keyring semaphore.\n *\n * Returns a pointer to the found key with usage count incremented if\n * successful and returns NULL if not found.  Revoked and invalidated keys are\n * skipped over.\n *\n * If successful, the possession indicator is propagated from the keyring ref\n * to the returned key reference.\n */\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n/*\n * Find a keyring with the specified name.\n *\n * Only keyrings that have nonzero refcount, are not revoked, and are owned by a\n * user in the current user namespace are considered.  If @uid_keyring is %true,\n * the keyring additionally must have been allocated as a user or user session\n * keyring; otherwise, it must grant Search permission directly to the caller.\n *\n * Returns a pointer to the keyring with the keyring's refcount having being\n * incremented on success.  -ENOKEY is returned if a key could not be found.\n */\nstruct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n/*\n * See if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A).\n *\n * Since we are adding B to A at the top level, checking for cycles should just\n * be a matter of seeing if node A is somewhere in tree B.\n */\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n/*\n * Preallocate memory so that a key can be linked into to a keyring.\n */\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Check already instantiated keys aren't going to be a problem.\n *\n * The caller must have called __key_link_begin(). Don't need to call this for\n * keys that were created since __key_link_begin() was called.\n */\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n/*\n * Link a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.  Discards any\n * already extant link to matching key if there is one, so that each keyring\n * holds at most one link to any given key of a particular type+description\n * combination.\n */\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}\n\n/*\n * Finish linking a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.\n */\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\n\n/*\n * Check addition of keys to restricted keyrings.\n */\nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}\n\n/**\n * key_link - Link a key to a keyring\n * @keyring: The keyring to make the link in.\n * @key: The key to link to.\n *\n * Make a link in a keyring to a key, such that the keyring holds a reference\n * on that key and the key can potentially be found by searching that keyring.\n *\n * This function will write-lock the keyring's semaphore and will consume some\n * of the user's key data quota to hold the link.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,\n * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is\n * full, -EDQUOT if there is insufficient key data quota remaining to add\n * another link or -ENOMEM if there's insufficient memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be made (the keyring should have Write permission and the key Link\n * permission).\n */\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n/**\n * key_unlink - Unlink the first link to a key from a keyring.\n * @keyring: The keyring to remove the link from.\n * @key: The key the link is to.\n *\n * Remove a link from a keyring to a key.\n *\n * This function will write-lock the keyring's semaphore.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if\n * the key isn't linked to by the keyring or -ENOMEM if there's insufficient\n * memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be removed (the keyring should have Write permission; no permissions are\n * required on the key).\n */\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n/**\n * keyring_clear - Clear a keyring\n * @keyring: The keyring to clear.\n *\n * Clear the contents of the specified keyring.\n *\n * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.\n */\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n/*\n * Dispose of the links from a revoked keyring.\n *\n * This is called with the key sem write-locked.\n */\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n/*\n * Garbage collect pointers from a keyring.\n *\n * Not called with any locks held.  The keyring's key struct will not be\n * deallocated under us as only our caller may deallocate it.\n */\nvoid keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n\n/*\n * Garbage collect restriction pointers from a keyring.\n *\n * Keyring restrictions are associated with a key type, and must be cleaned\n * up if the key type is unregistered. The restriction is altered to always\n * reject additional keys so a keyring cannot be opened up by unregistering\n * a key type.\n *\n * Not called with any keyring locks held. The keyring's key struct will not\n * be deallocated under us as only our caller may deallocate it.\n *\n * The caller is required to hold key_types_sem and dead_type->sem. This is\n * fulfilled by key_gc_keytype() holding the locks on behalf of\n * key_garbage_collector(), which it invokes on a workqueue.\n */\nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}\n", "/* Manage a process's keyrings\n *\n * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/* Session keyring create vs join semaphore */\nstatic DEFINE_MUTEX(key_session_mutex);\n\n/* User keyring creation semaphore */\nstatic DEFINE_MUTEX(key_user_keyring_mutex);\n\n/* The root user's tracking struct */\nstruct key_user root_key_user = {\n\t.usage\t\t= REFCOUNT_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n/*\n * Install the user and user session keyrings for the current process's UID.\n */\nint install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t\tKEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t  KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Install a thread keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a thread keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a process keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a process keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install the given keyring as the session keyring of the given credentials\n * struct, replacing the existing one if any.  If the given keyring is NULL,\n * then install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n/*\n * Install the given keyring as the session keyring of the current task,\n * replacing the existing one if any.  If the given keyring is NULL, then\n * install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Handle the fsuid changing.\n */\nvoid key_fsuid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->uid = tsk->cred->fsuid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Handle the fsgid changing.\n */\nvoid key_fsgid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->gid = tsk->cred->fsgid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key.\n *\n * The search criteria are the type and the match function.  The description is\n * given to the match function as a parameter, but doesn't otherwise influence\n * the search.  Typically the match function will compare the description\n * parameter to the key's description.\n *\n * This can only search keyrings that grant Search permission to the supplied\n * credentials.  Keyrings linked to searched keyrings will also be searched if\n * they grant Search permission too.  Keys can only be found if they grant\n * Search permission to the credentials.\n *\n * Returns a pointer to the key with the key usage count incremented if\n * successful, -EAGAIN if we didn't find any matching key or -ENOKEY if we only\n * matched negative keys.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key in the manner of search_my_process_keyrings(), but also search\n * the keys attached to the assumed authorisation key using its credentials if\n * one is available.\n *\n * Return same as search_my_process_keyrings().\n */\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * See if the key we're looking at is the target key.\n */\nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n/*\n * Look up a key ID given us by userspace with a given permissions mask to get\n * the key it refers to.\n *\n * Flags can be passed to request that special keyrings be created if referred\n * to directly, to permit partially constructed keys to be found and to skip\n * validity and permission checks on the found key.\n *\n * Returns a pointer to the key with an incremented usage count if successful;\n * -EINVAL if the key ID is invalid; -ENOKEY if the key ID does not correspond\n * to a key or the best found key was a negative key; -EKEYREVOKED or\n * -EKEYEXPIRED if the best found key was revoked or expired; -EACCES if the\n * found key doesn't grant the requested permit or the LSM denied access to it;\n * or -ENOMEM if a special keyring couldn't be created.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\n\n/*\n * Join the named keyring as the session keyring if possible else attempt to\n * create a new one of that name and join that.\n *\n * If the name is NULL, an empty anonymous keyring will be installed as the\n * session keyring.\n *\n * Named session keyrings are joined with a semaphore held to prevent the\n * keyrings from going away whilst the attempt is made to going them and also\n * to prevent a race in creating compatible session keyrings.\n */\nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tret = 0;\n\t\tgoto error3;\n\t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error3;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror3:\n\tkey_put(keyring);\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Replace a process's session keyring on behalf of one of its children when\n * the target  process is about to resume userspace execution.\n */\nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n/*\n * Make sure that root's user and user-session keyrings exist.\n */\nstatic int __init init_root_keyring(void)\n{\n\treturn install_user_keyrings();\n}\n\nlate_initcall(init_root_keyring);\n"], "filenames": ["include/linux/key.h", "security/keys/internal.h", "security/keys/key.c", "security/keys/keyring.c", "security/keys/process_keys.c"], "buggy_code_start_loc": [189, 144, 304, 1100, 80], "buggy_code_end_loc": [245, 145, 304, 1140, 98], "fixing_code_start_loc": [190, 144, 305, 1100, 80], "fixing_code_end_loc": [248, 145, 307, 1145, 100], "type": "NVD-CWE-noinfo", "message": "In the Linux kernel before 4.13.5, a local user could create keyrings for other users via keyctl commands, setting unwanted defaults or causing a denial of service.", "other": {"cve": {"id": "CVE-2017-18270", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-18T16:29:00.307", "lastModified": "2020-08-14T20:15:12.513", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.13.5, a local user could create keyrings for other users via keyctl commands, setting unwanted defaults or causing a denial of service."}, {"lang": "es", "value": "En el kernel de Linux, en versiones anteriores a la 4.13.5, un usuario local podr\u00eda crear keyrings para otros usuarios mediante comandos keyctl, estableciendo configuraciones por defecto no deseadas o provocando una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.13.5", "matchCriteriaId": "72E6ACD1-0BF7-4E96-9C91-280176AA3A4E"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=237bbd29f7a049d310d907f4b2716a7feef9abf3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/104254", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1580979", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1856774#c11", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1856774#c9", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://support.f5.com/csp/article/K37301725", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.5", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3"}}