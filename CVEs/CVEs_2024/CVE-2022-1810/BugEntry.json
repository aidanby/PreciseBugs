{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"base64\"\n\nmodule Admin; end\n\nclass Admin::ContentController < Admin::BaseController\n  def index\n    @search = params[:search] || {}\n    @articles = this_blog.articles.search_with(@search).page(params[:page]).\n      per(this_blog.admin_display_elements)\n\n    if request.xhr?\n      respond_to do |format|\n        format.js {}\n      end\n    else\n      @article = Article.new(params[:article])\n    end\n  end\n\n  def new\n    @article = Article::Factory.new(this_blog, current_user).default\n    load_resources\n    render layout: \"editor\"\n  end\n\n  def edit\n    return unless access_granted?(params[:id])\n\n    @article = Article.find(params[:id])\n    @article.text_filter ||= default_text_filter\n    @article.keywords = Tag.collection_to_string @article.tags\n    load_resources\n    render layout: \"editor\"\n  end\n\n  def create\n    article_factory = Article::Factory.new(this_blog, current_user)\n    @article = article_factory.get_or_build_from(params[:article][:id])\n\n    update_article_attributes\n\n    if @article.draft\n      @article.state = \"draft\"\n    elsif @article.draft?\n      @article.publish!\n    end\n\n    if @article.save\n      flash[:success] = I18n.t(\"admin.content.create.success\")\n      redirect_to action: \"index\"\n    else\n      @article.keywords = Tag.collection_to_string @article.tags\n      load_resources\n      render \"new\", layout: \"editor\"\n    end\n  end\n\n  def update\n    return unless access_granted?(params[:id])\n\n    id = params[:article][:id] || params[:id]\n    @article = Article.find(id)\n\n    if params[:article][:draft]\n      fetch_fresh_or_existing_draft_for_article\n    else\n      @article = Article.find(@article.parent_id) unless @article.parent_id.nil?\n    end\n\n    update_article_attributes\n\n    if @article.draft\n      @article.state = \"draft\"\n    elsif @article.draft?\n      @article.publish!\n    end\n\n    if @article.save\n      Article.where(parent_id: @article.id).map(&:destroy) unless @article.draft\n      flash[:success] = I18n.t(\"admin.content.update.success\")\n      redirect_to action: \"index\"\n    else\n      @article.keywords = Tag.collection_to_string @article.tags\n      load_resources\n      render \"edit\"\n    end\n  end\n\n  def destroy\n    destroy_a(Article)\n  end\n\n  def auto_complete_for_article_keywords\n    @items = Tag.select(:display_name).order(:display_name).map(&:display_name)\n    render json: @items\n  end\n\n  def autosave\n    return false unless request.xhr?\n\n    id = params[:article][:id] || params[:id]\n\n    article_factory = Article::Factory.new(this_blog, current_user)\n    @article = article_factory.get_or_build_from(id)\n\n    fetch_fresh_or_existing_draft_for_article\n\n    @article.attributes = params[:article].permit!\n\n    @article.author = current_user\n    @article.save_attachments!(params[:attachments])\n    @article.state = \"draft\" unless @article.withdrawn?\n    @article.text_filter ||= current_user.default_text_filter\n\n    if @article.title.blank?\n      lastid = Article.order(\"id desc\").first.id\n      @article.title = \"Draft article #{lastid}\"\n    end\n\n    if @article.save\n      flash[:success] = I18n.t(\"admin.content.autosave.success\")\n      @must_update_calendar =\n        (params[:article][:published_at] and\n         params[:article][:published_at].to_time.to_i < Time.zone.now.to_time.to_i and\n         @article.parent_id.nil?)\n      respond_to do |format|\n        format.js\n      end\n    end\n  end\n\n  private\n\n  def fetch_fresh_or_existing_draft_for_article\n    return unless @article.published? && @article.id\n\n    parent_id = @article.id\n    @article =\n      this_blog.articles.drafts.child_of(parent_id).first || this_blog.articles.build\n    @article.allow_comments = this_blog.default_allow_comments\n    @article.allow_pings = this_blog.default_allow_pings\n    @article.parent_id = parent_id\n  end\n\n  attr_accessor :resources, :resource\n\n  def load_resources\n    @post_types = PostType.all\n    @macros = TextFilterPlugin.macro_filters\n  end\n\n  def access_granted?(article_id)\n    article = Article.find(article_id)\n    if article.access_by? current_user\n      true\n    else\n      flash[:error] = I18n.t(\"admin.content.access_granted.error\")\n      redirect_to action: \"index\"\n      false\n    end\n  end\n\n  def update_article_attributes\n    @article.assign_attributes(update_params)\n    @article.author = current_user\n    @article.save_attachments!(params[:attachments])\n    @article.text_filter_name ||= default_text_filter\n  end\n\n  def update_params\n    params.\n      require(:article).\n      permit(:allow_comments,\n             :allow_pings,\n             :body,\n             :body_and_extended,\n             :draft,\n             :extended,\n             :password,\n             :permalink,\n             :published_at,\n             :text_filter_name,\n             :title,\n             :keywords)\n  end\n\n  def default_text_filter\n    current_user.text_filter || this_blog.text_filter\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Admin::ContentController, type: :controller do\n  render_views\n\n  before do\n    create :blog\n  end\n\n  describe \"index\" do\n    let(:publisher) { create(:user, :as_publisher) }\n    let!(:article) { create(:article) }\n\n    before do\n      sign_in publisher\n    end\n\n    context \"simple query\" do\n      before { get :index }\n\n      it { expect(response).to be_successful }\n      it { expect(response).to render_template(\"index\", layout: \"administration\") }\n    end\n\n    it \"return article that match with search query\" do\n      get :index, params: { search: { searchstring: article.body[0..4] } }\n      expect(assigns(:articles)).to eq([article])\n    end\n\n    it \"search query and limit on published_at\" do\n      get :index, params: { search: {\n        searchstring: article.body[0..4],\n        published_at: article.published_at + 2.days,\n      } }\n      expect(assigns(:articles)).to be_empty\n    end\n\n    context \"search for state\" do\n      let!(:draft_article) { create(:article, state: \"draft\") }\n      let!(:pending_article) do\n        create(:article, state: \"publication_pending\", published_at: \"2020-01-01\")\n      end\n\n      it \"returns draft articles when drafts is specified\" do\n        get :index, params: { search: { state: \"drafts\" } }\n\n        expect(assigns(:articles)).to eq([draft_article])\n      end\n\n      it \"returns pending articles when pending is specified\" do\n        get :index, params: { search: { state: \"pending\" } }\n\n        expect(assigns(:articles)).to eq([pending_article])\n      end\n\n      it \"returns all states when called with a bad state\" do\n        get :index, params: { search: { state: \"3vI1 1337 h4x0r\" } }\n\n        expect(assigns(:articles).sort).\n          to eq([article, pending_article, draft_article].sort)\n      end\n    end\n  end\n\n  describe \"#autosave\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n    end\n\n    context \"first time save\" do\n      it \"creates a new draft Article\" do\n        expect do\n          post :autosave, xhr: true, params: { article: attributes_for(:article) }\n        end.to change(Article, :count).by(1)\n      end\n\n      it \"creates tags for the draft article if relevant\" do\n        expect do\n          post :autosave,\n               xhr: true, params: { article: attributes_for(:article, :with_tags) }\n        end.to change(Tag, :count).by(2)\n      end\n    end\n\n    context \"second call to save\" do\n      let!(:draft) { create(:article, state: \"draft\") }\n\n      it \"does not create an extra draft\" do\n        expect do\n          post :autosave,\n               xhr: true, params: { article: { id: draft.id,\n                                               body_and_extended: \"new body\" } }\n        end.not_to change(Article, :count)\n      end\n    end\n\n    context \"with an other existing draft\" do\n      let!(:draft) { create(:article, state: \"draft\", body: \"existing body\") }\n\n      it \"creates a new draft Article\" do\n        expect do\n          post :autosave, xhr: true, params: { article: attributes_for(:article) }\n        end.to change(Article, :count).by(1)\n      end\n\n      it \"does not replace existing draft\" do\n        post :autosave, xhr: true, params: { article: attributes_for(:article) }\n        expect(assigns(:article).id).not_to eq(draft.id)\n        expect(assigns(:article).body).not_to eq(draft.body)\n      end\n    end\n  end\n\n  describe \"#new\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n      get :new\n    end\n\n    it { expect(response).to be_successful }\n    it { expect(response).to render_template(\"new\") }\n    it { expect(assigns(:article)).not_to be_nil }\n    it { expect(assigns(:article).redirect).to be_nil }\n  end\n\n  describe \"#create\" do\n    shared_examples_for \"create action\" do\n      def base_article(options = {})\n        { title: \"posted via tests!\",\n          body: \"A good body\",\n          allow_comments: \"1\",\n          allow_pings: \"1\" }.merge(options)\n      end\n\n      it \"sends notifications on create\" do\n        u = create(:user, notify_via_email: true, notify_on_new_articles: true)\n        u.save!\n        ActionMailer::Base.deliveries.clear\n        emails = ActionMailer::Base.deliveries\n\n        post :create, params: { \"article\" => base_article }\n\n        assert_equal(1, emails.size)\n        assert_equal(u.email, emails.first.to[0])\n      end\n\n      it \"creates an article with tags\" do\n        post :create, params: { \"article\" => base_article(keywords: \"foo bar\") }\n        new_article = Article.last\n        assert_equal 2, new_article.tags.size\n      end\n\n      it \"creates an article with a password\" do\n        post :create, params: { \"article\" => base_article(password: \"foobar\") }\n        new_article = Article.last\n        expect(new_article.password).to eq(\"foobar\")\n      end\n\n      it \"creates an article with a unique Tag instance named lang:FR\" do\n        post :create, params: { \"article\" => base_article(keywords: \"lang:FR\") }\n        new_article = Article.last\n        expect(new_article.tags.map(&:name)).to include(\"lang-fr\")\n      end\n\n      it \"interprets time zone in :published_at correctly\" do\n        article = base_article(published_at: \"February 17, 2011 08:47 PM GMT+0100 (CET)\")\n        post :create, params: { article: article }\n        new_article = Article.last\n        assert_equal Time.utc(2011, 2, 17, 19, 47), new_article.published_at\n      end\n\n      it 'respects \"GMT+0000 (UTC)\" in :published_at' do\n        article = base_article(published_at: \"August 23, 2011 08:40 PM GMT+0000 (UTC)\")\n        post :create, params: { article: article }\n        new_article = Article.last\n        assert_equal Time.utc(2011, 8, 23, 20, 40), new_article.published_at\n      end\n\n      it \"creates a filtered article\" do\n        Article.delete_all\n        body = \"body via *markdown*\"\n        extended = \"*foo*\"\n        post :create,\n             params: { article: { title: \"another test\", body: body, extended: extended } }\n\n        assert_response :redirect, action: \"index\"\n\n        new_article = Article.order(created_at: :desc).first\n\n        expect(new_article.body).to eq body\n        expect(new_article.extended).to eq extended\n        expect(new_article.text_filter.name).to eq \"markdown smartypants\"\n        expect(new_article.html(:body)).to eq \"<p>body via <em>markdown</em></p>\"\n        expect(new_article.html(:extended)).to eq \"<p><em>foo</em></p>\"\n      end\n\n      context \"with a previously autosaved draft\" do\n        before do\n          @draft = create(:article, body: \"draft\", state: \"draft\")\n          post :create,\n               params: { article: { id: @draft.id, body: \"update\", published: true } }\n        end\n\n        it \"updates the draft\" do\n          expect(Article.find(@draft.id).body).to eq \"update\"\n        end\n\n        it \"makes the draft published\" do\n          expect(Article.find(@draft.id)).to be_published\n        end\n      end\n\n      describe \"with an unrelated draft in the database\" do\n        before do\n          @draft = create(:article, state: \"draft\")\n        end\n\n        describe \"saving new article as draft\" do\n          it \"leaves the original draft in existence\" do\n            post :create, params: { article: base_article(draft: \"save as draft\") }\n            expect(assigns(:article).id).not_to eq(@draft.id)\n            expect(Article.find(@draft.id)).not_to be_nil\n          end\n        end\n      end\n    end\n\n    context \"as a publisher\" do\n      let(:publisher) { create(:user, :as_publisher) }\n      let(:article_params) { { title: \"posted via tests!\", body: \"a good boy\" } }\n\n      before do\n        sign_in publisher\n        @user = publisher\n      end\n\n      it \"creates an article\" do\n        expect do\n          post :create, params: { article: article_params }\n        end.to change(Article, :count).by(1)\n      end\n\n      context \"classic\" do\n        before { post :create, params: { article: article_params } }\n\n        it { expect(response).to redirect_to(action: :index) }\n        it { expect(flash[:success]).to eq(I18n.t(\"admin.content.create.success\")) }\n\n        it { expect(assigns(:article)).to be_published }\n        it { expect(assigns(:article).user).to eq(publisher) }\n\n        context \"when doing a draft\" do\n          let(:article_params) do\n            { title: \"posted via tests!\", body: \"a good boy\", draft: \"true\" }\n          end\n\n          it { expect(assigns(:article)).not_to be_published }\n        end\n      end\n\n      context \"writing for the future\" do\n        let(:article_params) do\n          { title: \"posted via tests!\", body: \"a good boy\",\n            published_at: 1.hour.from_now.to_s }\n        end\n\n        before do\n          post :create, params: { article: article_params }\n        end\n\n        it \"does not create a short url\" do\n          expect(Redirect.count).to eq 0\n        end\n\n        it \"creates a trigger to publish the article\" do\n          expect(Trigger.count).to eq 1\n        end\n\n        it \"does not publish the article\" do\n          expect(assigns(:article)).to be_publication_pending\n        end\n\n        it \"sets the publication time in the future\" do\n          expect(assigns(:article).published_at).to be > 10.minutes.from_now\n        end\n      end\n    end\n\n    context \"as an admin\" do\n      let(:admin) { create(:user, :as_admin) }\n\n      before do\n        sign_in admin\n        @user = admin\n      end\n\n      it_behaves_like \"create action\"\n    end\n  end\n\n  describe \"#edit\" do\n    context \"as an admin\" do\n      let(:admin) { create(:user, :as_admin) }\n      let(:article) { create(:article) }\n\n      before do\n        sign_in admin\n      end\n\n      it \"edits article\" do\n        get :edit, params: { \"id\" => article.id }\n        expect(response).to render_template \"edit\"\n        expect(assigns(:article)).not_to be_nil\n        expect(assigns(:article)).to be_valid\n        expect(response.body).to match(/body/)\n        expect(response.body).to match(/extended content/)\n      end\n\n      it \"correctly converts multi-word tags\" do\n        a = create(:article, keywords: '\"foo bar\", baz')\n        get :edit, params: { id: a.id }\n        expect(response.body).\n          to have_selector(\"input[id=article_keywords][value='baz, \\\"foo bar\\\"']\")\n      end\n    end\n\n    context \"as a publisher\" do\n      let(:publisher) { create(:user, :as_publisher) }\n\n      before do\n        sign_in publisher\n      end\n\n      context \"with an article from an other user\" do\n        let(:article) { create(:article, user: create(:user, login: \"another_user\")) }\n\n        before { get :edit, params: { id: article.id } }\n\n        it { expect(response).to redirect_to(action: \"index\") }\n      end\n\n      context \"with an article from current user\" do\n        let(:article) { create(:article, user: publisher) }\n\n        before { get :edit, params: { id: article.id } }\n\n        it { expect(response).to render_template(\"edit\") }\n        it { expect(assigns(:article)).not_to be_nil }\n        it { expect(assigns(:article)).to be_valid }\n      end\n    end\n  end\n\n  describe \"#update\" do\n    context \"as an admin\" do\n      let(:admin) { create(:user, :as_admin) }\n      let(:article) { create(:article) }\n\n      before do\n        sign_in admin\n      end\n\n      it \"updates article\" do\n        emails = ActionMailer::Base.deliveries\n        emails.clear\n\n        art_id = article.id\n\n        body = \"another *textile* test\"\n        put :update, params: { id: art_id,\n                               article: { body: body, text_filter_name: \"textile\" } }\n        assert_response :redirect, action: \"show\", id: art_id\n\n        article.reload\n        expect(article.text_filter.name).to eq(\"textile\")\n        expect(body).to eq(article.body)\n\n        expect(emails.size).to eq(0)\n      end\n\n      it \"allows updating body_and_extended\" do\n        put :update, params: { \"id\" => article.id, \"article\" => {\n          \"body_and_extended\" => \"foo<!--more-->bar<!--more-->baz\",\n        } }\n        assert_response :redirect\n        article.reload\n        expect(article.body).to eq(\"foo\")\n        expect(article.extended).to eq(\"bar<!--more-->baz\")\n      end\n\n      it \"allows updating password\" do\n        put :update, params: { \"id\" => article.id, \"article\" => {\n          \"password\" => \"foobar\",\n        } }\n        assert_response :redirect\n        article.reload\n        expect(article.password).to eq(\"foobar\")\n      end\n\n      context \"when a published article has drafts\" do\n        let(:original_published_at) { 2.days.ago.to_date }\n        let!(:original) { create(:article, published_at: original_published_at) }\n        let!(:draft) { create(:article, parent_id: original.id, state: \"draft\") }\n        let!(:second_draft) { create(:article, parent_id: original.id, state: \"draft\") }\n\n        describe \"publishing the published article\" do\n          before do\n            put(:update, params: {\n                  id: original.id,\n                  article: { id: draft.id, body: \"update\" },\n                })\n          end\n\n          it \"updates the article\" do\n            expect(original.reload.body).to eq \"update\"\n          end\n\n          it \"deletes all drafts\" do\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(draft.id)\n            end\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(second_draft.id)\n            end\n          end\n\n          it \"keeps the original publication date\" do\n            expect(original.reload.published_at).to eq original_published_at\n          end\n        end\n\n        describe \"publishing a draft copy of the published article\" do\n          before do\n            put(:update, params: {\n                  id: draft.id,\n                  article: { id: draft.id, body: \"update\" },\n                })\n          end\n\n          it \"updates the original\" do\n            expect(original.reload.body).to eq(\"update\")\n          end\n\n          it \"deletes all drafts\" do\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(draft.id)\n            end\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(second_draft.id)\n            end\n          end\n\n          it \"keeps the original publication date\" do\n            expect(original.reload.published_at).to eq original_published_at\n          end\n        end\n\n        describe \"publishing a draft copy with a new publication date\" do\n          before do\n            put(:update, params: {\n                  id: draft.id,\n                  article: { id: draft.id, body: \"update\", published_at: \"2016-07-07\" },\n                })\n          end\n\n          it \"updates the original publication date\" do\n            expect(original.reload.published_at).to eq Date.new(2016, 7, 7)\n          end\n        end\n      end\n\n      describe \"saving a published article as draft\" do\n        before do\n          @orig = create(:article)\n          put(:update, params: {\n                id: @orig.id,\n                article: { title: @orig.title, draft: \"draft\", body: \"update\" },\n              })\n        end\n\n        it \"leaves the original published\" do\n          @orig.reload\n          expect(@orig).to be_published\n        end\n\n        it \"leaves the original as is\" do\n          @orig.reload\n          expect(@orig.body).not_to eq(\"update\")\n        end\n\n        it \"redirects to the index\" do\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"creates a draft\" do\n          draft = Article.child_of(@orig.id).first\n          expect(draft.parent_id).to eq(@orig.id)\n          expect(draft).not_to be_published\n        end\n      end\n    end\n\n    context \"as a publisher\" do\n      let(:publisher) { create(:user, :as_publisher) }\n\n      before do\n        sign_in publisher\n      end\n\n      context \"with an article\" do\n        let(:article) { create(:article, body: \"another *textile* test\", user: publisher) }\n        let(:body) { \"not the *same* text\" }\n\n        before do\n          put :update,\n              params: { id: article.id,\n                        article: { body: body, text_filter_name: \"textile\" } }\n        end\n\n        it { expect(response).to redirect_to(action: \"index\") }\n        it { expect(article.reload.text_filter.name).to eq(\"textile\") }\n        it { expect(article.reload.body).to eq(body) }\n      end\n    end\n  end\n\n  describe \"#auto_complete_for_article_keywords\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n    end\n\n    before do\n      create(:tag, name: \"foo\", contents: [create(:article)])\n      create(:tag, name: \"bazz\", contents: [create(:article)])\n      create(:tag, name: \"bar\", contents: [create(:article)])\n    end\n\n    it \"returns foo for keywords fo\" do\n      get :auto_complete_for_article_keywords, params: { article: { keywords: \"fo\" } }\n      expect(response).to be_successful\n      expect(response.body).to eq('[\"bar\",\"bazz\",\"foo\"]')\n    end\n  end\n\n  describe \"#destroy\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n    end\n\n    context \"with an article from other user\" do\n      let(:article) { create(:article, user: create(:user, login: \"other_user\")) }\n\n      before { delete :destroy, params: { id: article.id } }\n\n      it { expect(response).to redirect_to(action: \"index\") }\n      it { expect(Article.count).to eq(1) }\n    end\n\n    context \"with an article from user\" do\n      let(:article) { create(:article, user: publisher) }\n\n      before { delete :destroy, params: { id: article.id } }\n\n      it { expect(response).to redirect_to(action: \"index\") }\n      it { expect(Article.count).to eq(0) }\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"base64\"\n\nmodule Admin; end\n\nclass Admin::ContentController < Admin::BaseController\n  def index\n    @search = params[:search] || {}\n    @articles = this_blog.articles.search_with(@search).page(params[:page]).\n      per(this_blog.admin_display_elements)\n\n    if request.xhr?\n      respond_to do |format|\n        format.js {}\n      end\n    else\n      @article = Article.new(params[:article])\n    end\n  end\n\n  def new\n    @article = Article::Factory.new(this_blog, current_user).default\n    load_resources\n    render layout: \"editor\"\n  end\n\n  def edit\n    return unless access_granted?(params[:id])\n\n    @article = Article.find(params[:id])\n    @article.text_filter ||= default_text_filter\n    @article.keywords = Tag.collection_to_string @article.tags\n    load_resources\n    render layout: \"editor\"\n  end\n\n  def create\n    article_factory = Article::Factory.new(this_blog, current_user)\n    @article = article_factory.get_or_build_from(params[:article][:id])\n\n    update_article_attributes\n\n    if @article.draft\n      @article.state = \"draft\"\n    elsif @article.draft?\n      @article.publish!\n    end\n\n    if @article.save\n      flash[:success] = I18n.t(\"admin.content.create.success\")\n      redirect_to action: \"index\"\n    else\n      @article.keywords = Tag.collection_to_string @article.tags\n      load_resources\n      render \"new\", layout: \"editor\"\n    end\n  end\n\n  def update\n    id = params[:id]\n    return unless access_granted?(id)\n\n    @article = Article.find(id)\n\n    if params[:article][:draft]\n      fetch_fresh_or_existing_draft_for_article\n    else\n      @article = Article.find(@article.parent_id) unless @article.parent_id.nil?\n    end\n\n    update_article_attributes\n\n    if @article.draft\n      @article.state = \"draft\"\n    elsif @article.draft?\n      @article.publish!\n    end\n\n    if @article.save\n      Article.where(parent_id: @article.id).map(&:destroy) unless @article.draft\n      flash[:success] = I18n.t(\"admin.content.update.success\")\n      redirect_to action: \"index\"\n    else\n      @article.keywords = Tag.collection_to_string @article.tags\n      load_resources\n      render \"edit\"\n    end\n  end\n\n  def destroy\n    destroy_a(Article)\n  end\n\n  def auto_complete_for_article_keywords\n    @items = Tag.select(:display_name).order(:display_name).map(&:display_name)\n    render json: @items\n  end\n\n  def autosave\n    return false unless request.xhr?\n\n    id = params[:article][:id] || params[:id]\n\n    article_factory = Article::Factory.new(this_blog, current_user)\n    @article = article_factory.get_or_build_from(id)\n\n    fetch_fresh_or_existing_draft_for_article\n\n    @article.attributes = params[:article].permit!\n\n    @article.author = current_user\n    @article.save_attachments!(params[:attachments])\n    @article.state = \"draft\" unless @article.withdrawn?\n    @article.text_filter ||= current_user.default_text_filter\n\n    if @article.title.blank?\n      lastid = Article.order(\"id desc\").first.id\n      @article.title = \"Draft article #{lastid}\"\n    end\n\n    if @article.save\n      flash[:success] = I18n.t(\"admin.content.autosave.success\")\n      @must_update_calendar =\n        (params[:article][:published_at] and\n         params[:article][:published_at].to_time.to_i < Time.zone.now.to_time.to_i and\n         @article.parent_id.nil?)\n      respond_to do |format|\n        format.js\n      end\n    end\n  end\n\n  private\n\n  def fetch_fresh_or_existing_draft_for_article\n    return unless @article.published? && @article.id\n\n    parent_id = @article.id\n    @article =\n      this_blog.articles.drafts.child_of(parent_id).first || this_blog.articles.build\n    @article.allow_comments = this_blog.default_allow_comments\n    @article.allow_pings = this_blog.default_allow_pings\n    @article.parent_id = parent_id\n  end\n\n  attr_accessor :resources, :resource\n\n  def load_resources\n    @post_types = PostType.all\n    @macros = TextFilterPlugin.macro_filters\n  end\n\n  def access_granted?(article_id)\n    article = Article.find(article_id)\n    if article.access_by? current_user\n      true\n    else\n      flash[:error] = I18n.t(\"admin.content.access_granted.error\")\n      redirect_to action: \"index\"\n      false\n    end\n  end\n\n  def update_article_attributes\n    @article.assign_attributes(update_params)\n    @article.author = current_user\n    @article.save_attachments!(params[:attachments])\n    @article.text_filter_name ||= default_text_filter\n  end\n\n  def update_params\n    params.\n      require(:article).\n      permit(:allow_comments,\n             :allow_pings,\n             :body,\n             :body_and_extended,\n             :draft,\n             :extended,\n             :password,\n             :permalink,\n             :published_at,\n             :text_filter_name,\n             :title,\n             :keywords)\n  end\n\n  def default_text_filter\n    current_user.text_filter || this_blog.text_filter\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Admin::ContentController, type: :controller do\n  render_views\n\n  before do\n    create :blog\n  end\n\n  describe \"index\" do\n    let(:publisher) { create(:user, :as_publisher) }\n    let!(:article) { create(:article) }\n\n    before do\n      sign_in publisher\n    end\n\n    context \"simple query\" do\n      before { get :index }\n\n      it { expect(response).to be_successful }\n      it { expect(response).to render_template(\"index\", layout: \"administration\") }\n    end\n\n    it \"return article that match with search query\" do\n      get :index, params: { search: { searchstring: article.body[0..4] } }\n      expect(assigns(:articles)).to eq([article])\n    end\n\n    it \"search query and limit on published_at\" do\n      get :index, params: { search: {\n        searchstring: article.body[0..4],\n        published_at: article.published_at + 2.days,\n      } }\n      expect(assigns(:articles)).to be_empty\n    end\n\n    context \"search for state\" do\n      let!(:draft_article) { create(:article, state: \"draft\") }\n      let!(:pending_article) do\n        create(:article, state: \"publication_pending\", published_at: \"2020-01-01\")\n      end\n\n      it \"returns draft articles when drafts is specified\" do\n        get :index, params: { search: { state: \"drafts\" } }\n\n        expect(assigns(:articles)).to eq([draft_article])\n      end\n\n      it \"returns pending articles when pending is specified\" do\n        get :index, params: { search: { state: \"pending\" } }\n\n        expect(assigns(:articles)).to eq([pending_article])\n      end\n\n      it \"returns all states when called with a bad state\" do\n        get :index, params: { search: { state: \"3vI1 1337 h4x0r\" } }\n\n        expect(assigns(:articles).sort).\n          to eq([article, pending_article, draft_article].sort)\n      end\n    end\n  end\n\n  describe \"#autosave\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n    end\n\n    context \"first time save\" do\n      it \"creates a new draft Article\" do\n        expect do\n          post :autosave, xhr: true, params: { article: attributes_for(:article) }\n        end.to change(Article, :count).by(1)\n      end\n\n      it \"creates tags for the draft article if relevant\" do\n        expect do\n          post :autosave,\n               xhr: true, params: { article: attributes_for(:article, :with_tags) }\n        end.to change(Tag, :count).by(2)\n      end\n    end\n\n    context \"second call to save\" do\n      let!(:draft) { create(:article, state: \"draft\") }\n\n      it \"does not create an extra draft\" do\n        expect do\n          post :autosave,\n               xhr: true, params: { article: { id: draft.id,\n                                               body_and_extended: \"new body\" } }\n        end.not_to change(Article, :count)\n      end\n    end\n\n    context \"with an other existing draft\" do\n      let!(:draft) { create(:article, state: \"draft\", body: \"existing body\") }\n\n      it \"creates a new draft Article\" do\n        expect do\n          post :autosave, xhr: true, params: { article: attributes_for(:article) }\n        end.to change(Article, :count).by(1)\n      end\n\n      it \"does not replace existing draft\" do\n        post :autosave, xhr: true, params: { article: attributes_for(:article) }\n        expect(assigns(:article).id).not_to eq(draft.id)\n        expect(assigns(:article).body).not_to eq(draft.body)\n      end\n    end\n  end\n\n  describe \"#new\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n      get :new\n    end\n\n    it { expect(response).to be_successful }\n    it { expect(response).to render_template(\"new\") }\n    it { expect(assigns(:article)).not_to be_nil }\n    it { expect(assigns(:article).redirect).to be_nil }\n  end\n\n  describe \"#create\" do\n    shared_examples_for \"create action\" do\n      def base_article(options = {})\n        { title: \"posted via tests!\",\n          body: \"A good body\",\n          allow_comments: \"1\",\n          allow_pings: \"1\" }.merge(options)\n      end\n\n      it \"sends notifications on create\" do\n        u = create(:user, notify_via_email: true, notify_on_new_articles: true)\n        u.save!\n        ActionMailer::Base.deliveries.clear\n        emails = ActionMailer::Base.deliveries\n\n        post :create, params: { \"article\" => base_article }\n\n        assert_equal(1, emails.size)\n        assert_equal(u.email, emails.first.to[0])\n      end\n\n      it \"creates an article with tags\" do\n        post :create, params: { \"article\" => base_article(keywords: \"foo bar\") }\n        new_article = Article.last\n        assert_equal 2, new_article.tags.size\n      end\n\n      it \"creates an article with a password\" do\n        post :create, params: { \"article\" => base_article(password: \"foobar\") }\n        new_article = Article.last\n        expect(new_article.password).to eq(\"foobar\")\n      end\n\n      it \"creates an article with a unique Tag instance named lang:FR\" do\n        post :create, params: { \"article\" => base_article(keywords: \"lang:FR\") }\n        new_article = Article.last\n        expect(new_article.tags.map(&:name)).to include(\"lang-fr\")\n      end\n\n      it \"interprets time zone in :published_at correctly\" do\n        article = base_article(published_at: \"February 17, 2011 08:47 PM GMT+0100 (CET)\")\n        post :create, params: { article: article }\n        new_article = Article.last\n        assert_equal Time.utc(2011, 2, 17, 19, 47), new_article.published_at\n      end\n\n      it 'respects \"GMT+0000 (UTC)\" in :published_at' do\n        article = base_article(published_at: \"August 23, 2011 08:40 PM GMT+0000 (UTC)\")\n        post :create, params: { article: article }\n        new_article = Article.last\n        assert_equal Time.utc(2011, 8, 23, 20, 40), new_article.published_at\n      end\n\n      it \"creates a filtered article\" do\n        Article.delete_all\n        body = \"body via *markdown*\"\n        extended = \"*foo*\"\n        post :create,\n             params: { article: { title: \"another test\", body: body, extended: extended } }\n\n        assert_response :redirect, action: \"index\"\n\n        new_article = Article.order(created_at: :desc).first\n\n        expect(new_article.body).to eq body\n        expect(new_article.extended).to eq extended\n        expect(new_article.text_filter.name).to eq \"markdown smartypants\"\n        expect(new_article.html(:body)).to eq \"<p>body via <em>markdown</em></p>\"\n        expect(new_article.html(:extended)).to eq \"<p><em>foo</em></p>\"\n      end\n\n      context \"with a previously autosaved draft\" do\n        before do\n          @draft = create(:article, body: \"draft\", state: \"draft\")\n          post :create,\n               params: { article: { id: @draft.id, body: \"update\", published: true } }\n        end\n\n        it \"updates the draft\" do\n          expect(Article.find(@draft.id).body).to eq \"update\"\n        end\n\n        it \"makes the draft published\" do\n          expect(Article.find(@draft.id)).to be_published\n        end\n      end\n\n      describe \"with an unrelated draft in the database\" do\n        before do\n          @draft = create(:article, state: \"draft\")\n        end\n\n        describe \"saving new article as draft\" do\n          it \"leaves the original draft in existence\" do\n            post :create, params: { article: base_article(draft: \"save as draft\") }\n            expect(assigns(:article).id).not_to eq(@draft.id)\n            expect(Article.find(@draft.id)).not_to be_nil\n          end\n        end\n      end\n    end\n\n    context \"as a publisher\" do\n      let(:publisher) { create(:user, :as_publisher) }\n      let(:article_params) { { title: \"posted via tests!\", body: \"a good boy\" } }\n\n      before do\n        sign_in publisher\n        @user = publisher\n      end\n\n      it \"creates an article\" do\n        expect do\n          post :create, params: { article: article_params }\n        end.to change(Article, :count).by(1)\n      end\n\n      context \"classic\" do\n        before { post :create, params: { article: article_params } }\n\n        it { expect(response).to redirect_to(action: :index) }\n        it { expect(flash[:success]).to eq(I18n.t(\"admin.content.create.success\")) }\n\n        it { expect(assigns(:article)).to be_published }\n        it { expect(assigns(:article).user).to eq(publisher) }\n\n        context \"when doing a draft\" do\n          let(:article_params) do\n            { title: \"posted via tests!\", body: \"a good boy\", draft: \"true\" }\n          end\n\n          it { expect(assigns(:article)).not_to be_published }\n        end\n      end\n\n      context \"writing for the future\" do\n        let(:article_params) do\n          { title: \"posted via tests!\", body: \"a good boy\",\n            published_at: 1.hour.from_now.to_s }\n        end\n\n        before do\n          post :create, params: { article: article_params }\n        end\n\n        it \"does not create a short url\" do\n          expect(Redirect.count).to eq 0\n        end\n\n        it \"creates a trigger to publish the article\" do\n          expect(Trigger.count).to eq 1\n        end\n\n        it \"does not publish the article\" do\n          expect(assigns(:article)).to be_publication_pending\n        end\n\n        it \"sets the publication time in the future\" do\n          expect(assigns(:article).published_at).to be > 10.minutes.from_now\n        end\n      end\n    end\n\n    context \"as an admin\" do\n      let(:admin) { create(:user, :as_admin) }\n\n      before do\n        sign_in admin\n        @user = admin\n      end\n\n      it_behaves_like \"create action\"\n    end\n  end\n\n  describe \"#edit\" do\n    context \"as an admin\" do\n      let(:admin) { create(:user, :as_admin) }\n      let(:article) { create(:article) }\n\n      before do\n        sign_in admin\n      end\n\n      it \"edits article\" do\n        get :edit, params: { \"id\" => article.id }\n        expect(response).to render_template \"edit\"\n        expect(assigns(:article)).not_to be_nil\n        expect(assigns(:article)).to be_valid\n        expect(response.body).to match(/body/)\n        expect(response.body).to match(/extended content/)\n      end\n\n      it \"correctly converts multi-word tags\" do\n        a = create(:article, keywords: '\"foo bar\", baz')\n        get :edit, params: { id: a.id }\n        expect(response.body).\n          to have_selector(\"input[id=article_keywords][value='baz, \\\"foo bar\\\"']\")\n      end\n    end\n\n    context \"as a publisher\" do\n      let(:publisher) { create(:user, :as_publisher) }\n\n      before do\n        sign_in publisher\n      end\n\n      context \"with an article from an other user\" do\n        let(:article) { create(:article, user: create(:user, login: \"another_user\")) }\n\n        before { get :edit, params: { id: article.id } }\n\n        it { expect(response).to redirect_to(action: \"index\") }\n      end\n\n      context \"with an article from current user\" do\n        let(:article) { create(:article, user: publisher) }\n\n        before { get :edit, params: { id: article.id } }\n\n        it { expect(response).to render_template(\"edit\") }\n        it { expect(assigns(:article)).not_to be_nil }\n        it { expect(assigns(:article)).to be_valid }\n      end\n    end\n  end\n\n  describe \"#update\" do\n    context \"as an admin\" do\n      let(:admin) { create(:user, :as_admin) }\n      let(:article) { create(:article) }\n\n      before do\n        sign_in admin\n      end\n\n      it \"updates article\" do\n        emails = ActionMailer::Base.deliveries\n        emails.clear\n\n        art_id = article.id\n\n        body = \"another *textile* test\"\n        put :update, params: { id: art_id,\n                               article: { body: body, text_filter_name: \"textile\" } }\n        assert_response :redirect, action: \"show\", id: art_id\n\n        article.reload\n        expect(article.text_filter.name).to eq(\"textile\")\n        expect(body).to eq(article.body)\n\n        expect(emails.size).to eq(0)\n      end\n\n      it \"allows updating body_and_extended\" do\n        put :update, params: { \"id\" => article.id, \"article\" => {\n          \"body_and_extended\" => \"foo<!--more-->bar<!--more-->baz\",\n        } }\n        assert_response :redirect\n        article.reload\n        expect(article.body).to eq(\"foo\")\n        expect(article.extended).to eq(\"bar<!--more-->baz\")\n      end\n\n      it \"allows updating password\" do\n        put :update, params: { \"id\" => article.id, \"article\" => {\n          \"password\" => \"foobar\",\n        } }\n        assert_response :redirect\n        article.reload\n        expect(article.password).to eq(\"foobar\")\n      end\n\n      context \"when a published article has drafts\" do\n        let(:original_published_at) { 2.days.ago.to_date }\n        let!(:original) { create(:article, published_at: original_published_at) }\n        let!(:draft) { create(:article, parent_id: original.id, state: \"draft\") }\n        let!(:second_draft) { create(:article, parent_id: original.id, state: \"draft\") }\n\n        describe \"publishing the published article\" do\n          before do\n            put(:update, params: {\n                  id: original.id,\n                  article: { id: draft.id, body: \"update\" },\n                })\n          end\n\n          it \"updates the article\" do\n            expect(original.reload.body).to eq \"update\"\n          end\n\n          it \"deletes all drafts\" do\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(draft.id)\n            end\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(second_draft.id)\n            end\n          end\n\n          it \"keeps the original publication date\" do\n            expect(original.reload.published_at).to eq original_published_at\n          end\n        end\n\n        describe \"publishing a draft copy of the published article\" do\n          before do\n            put(:update, params: {\n                  id: draft.id,\n                  article: { id: draft.id, body: \"update\" },\n                })\n          end\n\n          it \"updates the original\" do\n            expect(original.reload.body).to eq(\"update\")\n          end\n\n          it \"deletes all drafts\" do\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(draft.id)\n            end\n            assert_raises ActiveRecord::RecordNotFound do\n              Article.find(second_draft.id)\n            end\n          end\n\n          it \"keeps the original publication date\" do\n            expect(original.reload.published_at).to eq original_published_at\n          end\n        end\n\n        describe \"publishing a draft copy with a new publication date\" do\n          before do\n            put(:update, params: {\n                  id: draft.id,\n                  article: { id: draft.id, body: \"update\", published_at: \"2016-07-07\" },\n                })\n          end\n\n          it \"updates the original publication date\" do\n            expect(original.reload.published_at).to eq Date.new(2016, 7, 7)\n          end\n        end\n      end\n\n      describe \"saving a published article as draft\" do\n        before do\n          @orig = create(:article)\n          put(:update, params: {\n                id: @orig.id,\n                article: { title: @orig.title, draft: \"draft\", body: \"update\" },\n              })\n        end\n\n        it \"leaves the original published\" do\n          @orig.reload\n          expect(@orig).to be_published\n        end\n\n        it \"leaves the original as is\" do\n          @orig.reload\n          expect(@orig.body).not_to eq(\"update\")\n        end\n\n        it \"redirects to the index\" do\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"creates a draft\" do\n          draft = Article.child_of(@orig.id).first\n          expect(draft.parent_id).to eq(@orig.id)\n          expect(draft).not_to be_published\n        end\n      end\n    end\n\n    context \"as a publisher\" do\n      let(:publisher) { create(:user, :as_publisher) }\n\n      before do\n        sign_in publisher\n      end\n\n      context \"with an article\" do\n        let(:article) { create(:article, body: \"another *textile* test\", user: publisher) }\n        let(:body) { \"not the *same* text\" }\n\n        before do\n          put :update,\n              params: { id: article.id,\n                        article: { body: body, text_filter_name: \"textile\" } }\n        end\n\n        it { expect(response).to redirect_to(action: \"index\") }\n        it { expect(article.reload.text_filter.name).to eq(\"textile\") }\n        it { expect(article.reload.body).to eq(body) }\n      end\n\n      context \"with an owned article and another user's article\" do\n        let(:article) { create(:article, body: \"another *textile* test\", user: publisher) }\n        let(:other_article) { create(:article, body: \"other article\") }\n        let(:body) { \"not the *same* text\" }\n\n        before do\n          put :update,\n              params: { id: article.id,\n                        article: { id: other_article.id, body: body } }\n        end\n\n        it \"ignores the extra id passed in the article parameters\" do\n          aggregate_failures do\n            expect(response).to redirect_to(action: \"index\")\n            expect(article.reload.body).to eq(body)\n            expect(other_article.reload.body).not_to eq(body)\n          end\n        end\n      end\n    end\n  end\n\n  describe \"#auto_complete_for_article_keywords\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n    end\n\n    before do\n      create(:tag, name: \"foo\", contents: [create(:article)])\n      create(:tag, name: \"bazz\", contents: [create(:article)])\n      create(:tag, name: \"bar\", contents: [create(:article)])\n    end\n\n    it \"returns foo for keywords fo\" do\n      get :auto_complete_for_article_keywords, params: { article: { keywords: \"fo\" } }\n      expect(response).to be_successful\n      expect(response.body).to eq('[\"bar\",\"bazz\",\"foo\"]')\n    end\n  end\n\n  describe \"#destroy\" do\n    let(:publisher) { create(:user, :as_publisher) }\n\n    before do\n      sign_in publisher\n    end\n\n    context \"with an article from other user\" do\n      let(:article) { create(:article, user: create(:user, login: \"other_user\")) }\n\n      before { delete :destroy, params: { id: article.id } }\n\n      it { expect(response).to redirect_to(action: \"index\") }\n      it { expect(Article.count).to eq(1) }\n    end\n\n    context \"with an article from user\" do\n      let(:article) { create(:article, user: publisher) }\n\n      before { delete :destroy, params: { id: article.id } }\n\n      it { expect(response).to redirect_to(action: \"index\") }\n      it { expect(Article.count).to eq(0) }\n    end\n  end\nend\n"], "filenames": ["publify_core/app/controllers/admin/content_controller.rb", "publify_core/spec/controllers/admin/content_controller_spec.rb"], "buggy_code_start_loc": [61, 529], "buggy_code_end_loc": [64, 529], "fixing_code_start_loc": [61, 530], "fixing_code_end_loc": [63, 550], "type": "CWE-732", "message": "Improper Access Control in GitHub repository publify/publify prior to 9.2.9.", "other": {"cve": {"id": "CVE-2022-1810", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-23T12:16:16.490", "lastModified": "2022-05-30T00:33:26.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository publify/publify prior to 9.2.9."}, {"lang": "es", "value": "Un Control de Acceso Inapropiado en el repositorio de GitHub publify/publify versiones anteriores a 9.2.9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.9", "matchCriteriaId": "FF11F0A5-4738-433F-9CBE-0312BE9B3DB2"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/c0aba87844d1e47da50c0d99a3465164a4d244ce", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/9b2d7579-032e-42da-b736-4b10a868eacb", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/c0aba87844d1e47da50c0d99a3465164a4d244ce"}}