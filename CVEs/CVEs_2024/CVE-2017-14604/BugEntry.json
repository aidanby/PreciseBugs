{"buggy_code": ["/*\n *  nautilus-directory-async.c: Nautilus directory model state machine.\n *\n *  Copyright (C) 1999, 2000, 2001 Eazel, Inc.\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public\n *  License along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n *  Author: Darin Adler <darin@bentspoon.com>\n */\n\n#include <config.h>\n\n#include \"nautilus-directory-notify.h\"\n#include \"nautilus-directory-private.h\"\n#include \"nautilus-file-attributes.h\"\n#include \"nautilus-file-private.h\"\n#include \"nautilus-file-utilities.h\"\n#include \"nautilus-signaller.h\"\n#include \"nautilus-global-preferences.h\"\n#include \"nautilus-link.h\"\n#include \"nautilus-profile.h\"\n#include <eel/eel-glib-extensions.h>\n#include <gtk/gtk.h>\n#include <libxml/parser.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/* turn this on to see messages about each load_directory call: */\n#if 0\n#define DEBUG_LOAD_DIRECTORY\n#endif\n\n/* turn this on to check if async. job calls are balanced */\n#if 0\n#define DEBUG_ASYNC_JOBS\n#endif\n\n/* turn this on to log things starting and stopping */\n#if 0\n#define DEBUG_START_STOP\n#endif\n\n#define DIRECTORY_LOAD_ITEMS_PER_CALLBACK 100\n\n/* Keep async. jobs down to this number for all directories. */\n#define MAX_ASYNC_JOBS 10\n\nstruct TopLeftTextReadState\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n    gboolean large;\n    GCancellable *cancellable;\n};\n\nstruct LinkInfoReadState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n};\n\nstruct ThumbnailState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n    gboolean trying_original;\n    gboolean tried_original;\n};\n\nstruct MountState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n};\n\nstruct FilesystemInfoState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n};\n\nstruct DirectoryLoadState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    GHashTable *load_mime_list_hash;\n    NautilusFile *load_directory_file;\n    int load_file_count;\n};\n\nstruct MimeListState\n{\n    NautilusDirectory *directory;\n    NautilusFile *mime_list_file;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    GHashTable *mime_list_hash;\n};\n\nstruct GetInfoState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n};\n\nstruct NewFilesState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    int count;\n};\n\nstruct DirectoryCountState\n{\n    NautilusDirectory *directory;\n    NautilusFile *count_file;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    int file_count;\n};\n\nstruct DeepCountState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    GFile *deep_count_location;\n    GList *deep_count_subdirectories;\n    GArray *seen_deep_count_inodes;\n    char *fs_id;\n};\n\n\n\ntypedef struct\n{\n    NautilusFile *file;     /* Which file, NULL means all. */\n    union\n    {\n        NautilusDirectoryCallback directory;\n        NautilusFileCallback file;\n    } callback;\n    gpointer callback_data;\n    Request request;\n    gboolean active;     /* Set to FALSE when the callback is triggered and\n                          * scheduled to be called at idle, its still kept\n                          * in the list so we can kill it when the file\n                          * goes away.\n                          */\n} ReadyCallback;\n\ntypedef struct\n{\n    NautilusFile *file;     /* Which file, NULL means all. */\n    gboolean monitor_hidden_files;     /* defines whether \"all\" includes hidden files */\n    gconstpointer client;\n    Request request;\n} Monitor;\n\ntypedef struct\n{\n    NautilusDirectory *directory;\n    NautilusInfoProvider *provider;\n    NautilusOperationHandle *handle;\n    NautilusOperationResult result;\n} InfoProviderResponse;\n\ntypedef gboolean (*RequestCheck) (Request);\ntypedef gboolean (*FileCheck) (NautilusFile *);\n\n/* Current number of async. jobs. */\nstatic int async_job_count;\nstatic GHashTable *waiting_directories;\n#ifdef DEBUG_ASYNC_JOBS\nstatic GHashTable *async_jobs;\n#endif\n\n/* Forward declarations for functions that need them. */\nstatic void     deep_count_load (DeepCountState *state,\n                                 GFile          *location);\nstatic gboolean request_is_satisfied (NautilusDirectory *directory,\n                                      NautilusFile      *file,\n                                      Request            request);\nstatic void     cancel_loading_attributes (NautilusDirectory     *directory,\n                                           NautilusFileAttributes file_attributes);\nstatic void     add_all_files_to_work_queue (NautilusDirectory *directory);\nstatic void     link_info_done (NautilusDirectory *directory,\n                                NautilusFile      *file,\n                                const char        *uri,\n                                const char        *name,\n                                GIcon             *icon,\n                                gboolean           is_launcher,\n                                gboolean           is_foreign);\nstatic void     move_file_to_low_priority_queue (NautilusDirectory *directory,\n                                                 NautilusFile      *file);\nstatic void     move_file_to_extension_queue (NautilusDirectory *directory,\n                                              NautilusFile      *file);\nstatic void     nautilus_directory_invalidate_file_attributes (NautilusDirectory     *directory,\n                                                               NautilusFileAttributes file_attributes);\n\n/* Some helpers for case-insensitive strings.\n * Move to nautilus-glib-extensions?\n */\n\nstatic gboolean\nistr_equal (gconstpointer v,\n            gconstpointer v2)\n{\n    return g_ascii_strcasecmp (v, v2) == 0;\n}\n\nstatic guint\nistr_hash (gconstpointer key)\n{\n    const char *p;\n    guint h;\n\n    h = 0;\n    for (p = key; *p != '\\0'; p++)\n    {\n        h = (h << 5) - h + g_ascii_tolower (*p);\n    }\n\n    return h;\n}\n\nstatic GHashTable *\nistr_set_new (void)\n{\n    return g_hash_table_new_full (istr_hash, istr_equal, g_free, NULL);\n}\n\nstatic void\nistr_set_insert (GHashTable *table,\n                 const char *istr)\n{\n    char *key;\n\n    key = g_strdup (istr);\n    g_hash_table_replace (table, key, key);\n}\n\nstatic void\nadd_istr_to_list (gpointer key,\n                  gpointer value,\n                  gpointer callback_data)\n{\n    GList **list;\n\n    list = callback_data;\n    *list = g_list_prepend (*list, g_strdup (key));\n}\n\nstatic GList *\nistr_set_get_as_list (GHashTable *table)\n{\n    GList *list;\n\n    list = NULL;\n    g_hash_table_foreach (table, add_istr_to_list, &list);\n    return list;\n}\n\nstatic void\nistr_set_destroy (GHashTable *table)\n{\n    g_hash_table_destroy (table);\n}\n\nstatic void\nrequest_counter_add_request (RequestCounter counter,\n                             Request        request)\n{\n    guint i;\n\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (REQUEST_WANTS_TYPE (request, i))\n        {\n            counter[i]++;\n        }\n    }\n}\n\nstatic void\nrequest_counter_remove_request (RequestCounter counter,\n                                Request        request)\n{\n    guint i;\n\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (REQUEST_WANTS_TYPE (request, i))\n        {\n            counter[i]--;\n        }\n    }\n}\n\n#if 0\nstatic void\nnautilus_directory_verify_request_counts (NautilusDirectory *directory)\n{\n    GList *l;\n    RequestCounter counters;\n    int i;\n    gboolean fail;\n\n    fail = FALSE;\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        counters[i] = 0;\n    }\n    for (l = directory->details->monitor_list; l != NULL; l = l->next)\n    {\n        Monitor *monitor = l->data;\n        request_counter_add_request (counters, monitor->request);\n    }\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (counters[i] != directory->details->monitor_counters[i])\n        {\n            g_warning (\"monitor counter for %i is wrong, expecting %d but found %d\",\n                       i, counters[i], directory->details->monitor_counters[i]);\n            fail = TRUE;\n        }\n    }\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        counters[i] = 0;\n    }\n    for (l = directory->details->call_when_ready_list; l != NULL; l = l->next)\n    {\n        ReadyCallback *callback = l->data;\n        request_counter_add_request (counters, callback->request);\n    }\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (counters[i] != directory->details->call_when_ready_counters[i])\n        {\n            g_warning (\"call when ready counter for %i is wrong, expecting %d but found %d\",\n                       i, counters[i], directory->details->call_when_ready_counters[i]);\n            fail = TRUE;\n        }\n    }\n    g_assert (!fail);\n}\n#endif\n\n/* Start a job. This is really just a way of limiting the number of\n * async. requests that we issue at any given time. Without this, the\n * number of requests is unbounded.\n */\nstatic gboolean\nasync_job_start (NautilusDirectory *directory,\n                 const char        *job)\n{\n#ifdef DEBUG_ASYNC_JOBS\n    char *key;\n#endif\n\n#ifdef DEBUG_START_STOP\n    g_message (\"starting %s in %p\", job, directory->details->location);\n#endif\n\n    g_assert (async_job_count >= 0);\n    g_assert (async_job_count <= MAX_ASYNC_JOBS);\n\n    if (async_job_count >= MAX_ASYNC_JOBS)\n    {\n        if (waiting_directories == NULL)\n        {\n            waiting_directories = g_hash_table_new (NULL, NULL);\n        }\n\n        g_hash_table_insert (waiting_directories,\n                             directory,\n                             directory);\n\n        return FALSE;\n    }\n\n#ifdef DEBUG_ASYNC_JOBS\n    {\n        char *uri;\n        if (async_jobs == NULL)\n        {\n            async_jobs = g_hash_table_new (g_str_hash, g_str_equal);\n        }\n        uri = nautilus_directory_get_uri (directory);\n        key = g_strconcat (uri, \": \", job, NULL);\n        if (g_hash_table_lookup (async_jobs, key) != NULL)\n        {\n            g_warning (\"same job twice: %s in %s\",\n                       job, uri);\n        }\n        g_free (uri);\n        g_hash_table_insert (async_jobs, key, directory);\n    }\n#endif\n\n    async_job_count += 1;\n    return TRUE;\n}\n\n/* End a job. */\nstatic void\nasync_job_end (NautilusDirectory *directory,\n               const char        *job)\n{\n#ifdef DEBUG_ASYNC_JOBS\n    char *key;\n    gpointer table_key, value;\n#endif\n\n#ifdef DEBUG_START_STOP\n    g_message (\"stopping %s in %p\", job, directory->details->location);\n#endif\n\n    g_assert (async_job_count > 0);\n\n#ifdef DEBUG_ASYNC_JOBS\n    {\n        char *uri;\n        uri = nautilus_directory_get_uri (directory);\n        g_assert (async_jobs != NULL);\n        key = g_strconcat (uri, \": \", job, NULL);\n        if (!g_hash_table_lookup_extended (async_jobs, key, &table_key, &value))\n        {\n            g_warning (\"ending job we didn't start: %s in %s\",\n                       job, uri);\n        }\n        else\n        {\n            g_hash_table_remove (async_jobs, key);\n            g_free (table_key);\n        }\n        g_free (uri);\n        g_free (key);\n    }\n#endif\n\n    async_job_count -= 1;\n}\n\n/* Helper to get one value from a hash table. */\nstatic void\nget_one_value_callback (gpointer key,\n                        gpointer value,\n                        gpointer callback_data)\n{\n    gpointer *returned_value;\n\n    returned_value = callback_data;\n    *returned_value = value;\n}\n\n/* return a single value from a hash table. */\nstatic gpointer\nget_one_value (GHashTable *table)\n{\n    gpointer value;\n\n    value = NULL;\n    if (table != NULL)\n    {\n        g_hash_table_foreach (table, get_one_value_callback, &value);\n    }\n    return value;\n}\n\n/* Wake up directories that are \"blocked\" as long as there are job\n * slots available.\n */\nstatic void\nasync_job_wake_up (void)\n{\n    static gboolean already_waking_up = FALSE;\n    gpointer value;\n\n    g_assert (async_job_count >= 0);\n    g_assert (async_job_count <= MAX_ASYNC_JOBS);\n\n    if (already_waking_up)\n    {\n        return;\n    }\n\n    already_waking_up = TRUE;\n    while (async_job_count < MAX_ASYNC_JOBS)\n    {\n        value = get_one_value (waiting_directories);\n        if (value == NULL)\n        {\n            break;\n        }\n        g_hash_table_remove (waiting_directories, value);\n        nautilus_directory_async_state_changed\n            (NAUTILUS_DIRECTORY (value));\n    }\n    already_waking_up = FALSE;\n}\n\nstatic void\ndirectory_count_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->count_in_progress != NULL)\n    {\n        g_cancellable_cancel (directory->details->count_in_progress->cancellable);\n        directory->details->count_in_progress = NULL;\n    }\n}\n\nstatic void\ndeep_count_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        g_assert (NAUTILUS_IS_FILE (directory->details->deep_count_file));\n\n        g_cancellable_cancel (directory->details->deep_count_in_progress->cancellable);\n\n        directory->details->deep_count_file->details->deep_counts_status = NAUTILUS_REQUEST_NOT_STARTED;\n\n        directory->details->deep_count_in_progress->directory = NULL;\n        directory->details->deep_count_in_progress = NULL;\n        directory->details->deep_count_file = NULL;\n\n        async_job_end (directory, \"deep count\");\n    }\n}\n\nstatic void\nmime_list_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->mime_list_in_progress != NULL)\n    {\n        g_cancellable_cancel (directory->details->mime_list_in_progress->cancellable);\n    }\n}\n\nstatic void\nlink_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->link_info_read_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->link_info_read_state->cancellable);\n        directory->details->link_info_read_state->directory = NULL;\n        directory->details->link_info_read_state = NULL;\n        async_job_end (directory, \"link info\");\n    }\n}\n\nstatic void\nthumbnail_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->thumbnail_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->thumbnail_state->cancellable);\n        directory->details->thumbnail_state->directory = NULL;\n        directory->details->thumbnail_state = NULL;\n        async_job_end (directory, \"thumbnail\");\n    }\n}\n\nstatic void\nmount_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->mount_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->mount_state->cancellable);\n        directory->details->mount_state->directory = NULL;\n        directory->details->mount_state = NULL;\n        async_job_end (directory, \"mount\");\n    }\n}\n\nstatic void\nfile_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->get_info_in_progress != NULL)\n    {\n        g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);\n        directory->details->get_info_in_progress->directory = NULL;\n        directory->details->get_info_in_progress = NULL;\n        directory->details->get_info_file = NULL;\n\n        async_job_end (directory, \"file info\");\n    }\n}\n\nstatic void\nnew_files_cancel (NautilusDirectory *directory)\n{\n    GList *l;\n    NewFilesState *state;\n\n    if (directory->details->new_files_in_progress != NULL)\n    {\n        for (l = directory->details->new_files_in_progress; l != NULL; l = l->next)\n        {\n            state = l->data;\n            g_cancellable_cancel (state->cancellable);\n            state->directory = NULL;\n        }\n        g_list_free (directory->details->new_files_in_progress);\n        directory->details->new_files_in_progress = NULL;\n    }\n}\n\nstatic int\nmonitor_key_compare (gconstpointer a,\n                     gconstpointer data)\n{\n    const Monitor *monitor;\n    const Monitor *compare_monitor;\n\n    monitor = a;\n    compare_monitor = data;\n\n    if (monitor->client < compare_monitor->client)\n    {\n        return -1;\n    }\n    if (monitor->client > compare_monitor->client)\n    {\n        return +1;\n    }\n\n    if (monitor->file < compare_monitor->file)\n    {\n        return -1;\n    }\n    if (monitor->file > compare_monitor->file)\n    {\n        return +1;\n    }\n\n    return 0;\n}\n\nstatic GList *\nfind_monitor (NautilusDirectory *directory,\n              NautilusFile      *file,\n              gconstpointer      client)\n{\n    Monitor monitor;\n\n    monitor.client = client;\n    monitor.file = file;\n\n    return g_list_find_custom (directory->details->monitor_list,\n                               &monitor,\n                               monitor_key_compare);\n}\n\nstatic void\nremove_monitor_link (NautilusDirectory *directory,\n                     GList             *link)\n{\n    Monitor *monitor;\n\n    if (link != NULL)\n    {\n        monitor = link->data;\n        request_counter_remove_request (directory->details->monitor_counters,\n                                        monitor->request);\n        directory->details->monitor_list =\n            g_list_remove_link (directory->details->monitor_list, link);\n        g_free (monitor);\n        g_list_free_1 (link);\n    }\n}\n\nstatic void\nremove_monitor (NautilusDirectory *directory,\n                NautilusFile      *file,\n                gconstpointer      client)\n{\n    remove_monitor_link (directory, find_monitor (directory, file, client));\n}\n\nRequest\nnautilus_directory_set_up_request (NautilusFileAttributes file_attributes)\n{\n    Request request;\n\n    request = 0;\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_DIRECTORY_COUNT);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DEEP_COUNTS) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_DEEP_COUNT);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_MIME_LIST);\n    }\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_INFO) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_LINK_INFO)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n        REQUEST_SET_TYPE (request, REQUEST_LINK_INFO);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_EXTENSION_INFO) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_EXTENSION_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_THUMBNAIL)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_THUMBNAIL);\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_MOUNT)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_MOUNT);\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_FILESYSTEM_INFO)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILESYSTEM_INFO);\n    }\n\n    return request;\n}\n\nstatic void\nmime_db_changed_callback (GObject           *ignore,\n                          NautilusDirectory *dir)\n{\n    NautilusFileAttributes attrs;\n\n    g_assert (dir != NULL);\n    g_assert (dir->details != NULL);\n\n    attrs = NAUTILUS_FILE_ATTRIBUTE_INFO |\n            NAUTILUS_FILE_ATTRIBUTE_LINK_INFO |\n            NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;\n\n    nautilus_directory_force_reload_internal (dir, attrs);\n}\n\nvoid\nnautilus_directory_monitor_add_internal (NautilusDirectory         *directory,\n                                         NautilusFile              *file,\n                                         gconstpointer              client,\n                                         gboolean                   monitor_hidden_files,\n                                         NautilusFileAttributes     file_attributes,\n                                         NautilusDirectoryCallback  callback,\n                                         gpointer                   callback_data)\n{\n    Monitor *monitor;\n    GList *file_list;\n    char *file_uri = NULL;\n    char *dir_uri = NULL;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n\n    if (file != NULL)\n    {\n        file_uri = nautilus_file_get_uri (file);\n    }\n    if (directory != NULL)\n    {\n        dir_uri = nautilus_directory_get_uri (directory);\n    }\n    nautilus_profile_start (\"uri %s file-uri %s client %p\", dir_uri, file_uri, client);\n    g_free (dir_uri);\n    g_free (file_uri);\n\n    /* Replace any current monitor for this client/file pair. */\n    remove_monitor (directory, file, client);\n\n    /* Add the new monitor. */\n    monitor = g_new (Monitor, 1);\n    monitor->file = file;\n    monitor->monitor_hidden_files = monitor_hidden_files;\n    monitor->client = client;\n    monitor->request = nautilus_directory_set_up_request (file_attributes);\n\n    if (file == NULL)\n    {\n        REQUEST_SET_TYPE (monitor->request, REQUEST_FILE_LIST);\n    }\n    directory->details->monitor_list =\n        g_list_prepend (directory->details->monitor_list, monitor);\n    request_counter_add_request (directory->details->monitor_counters,\n                                 monitor->request);\n\n    if (callback != NULL)\n    {\n        file_list = nautilus_directory_get_file_list (directory);\n        (*callback)(directory, file_list, callback_data);\n        nautilus_file_list_free (file_list);\n    }\n\n    /* Start the \"real\" monitoring (FAM or whatever). */\n    /* We always monitor the whole directory since in practice\n     * nautilus almost always shows the whole directory anyway, and\n     * it allows us to avoid one file monitor per file in a directory.\n     */\n    if (directory->details->monitor == NULL)\n    {\n        directory->details->monitor = nautilus_monitor_directory (directory->details->location);\n    }\n\n\n    if (REQUEST_WANTS_TYPE (monitor->request, REQUEST_FILE_INFO) &&\n        directory->details->mime_db_monitor == 0)\n    {\n        directory->details->mime_db_monitor =\n            g_signal_connect_object (nautilus_signaller_get_current (),\n                                     \"mime-data-changed\",\n                                     G_CALLBACK (mime_db_changed_callback), directory, 0);\n    }\n\n    /* Put the monitor file or all the files on the work queue. */\n    if (file != NULL)\n    {\n        nautilus_directory_add_file_to_work_queue (directory, file);\n    }\n    else\n    {\n        add_all_files_to_work_queue (directory);\n    }\n\n    /* Kick off I/O. */\n    nautilus_directory_async_state_changed (directory);\n    nautilus_profile_end (NULL);\n}\n\nstatic void\nset_file_unconfirmed (NautilusFile *file,\n                      gboolean      unconfirmed)\n{\n    NautilusDirectory *directory;\n\n    g_assert (NAUTILUS_IS_FILE (file));\n    g_assert (unconfirmed == FALSE || unconfirmed == TRUE);\n\n    if (file->details->unconfirmed == unconfirmed)\n    {\n        return;\n    }\n    file->details->unconfirmed = unconfirmed;\n\n    directory = file->details->directory;\n    if (unconfirmed)\n    {\n        directory->details->confirmed_file_count--;\n    }\n    else\n    {\n        directory->details->confirmed_file_count++;\n    }\n}\n\nstatic gboolean show_hidden_files = TRUE;\n\nstatic void\nshow_hidden_files_changed_callback (gpointer callback_data)\n{\n    show_hidden_files = g_settings_get_boolean (gtk_filechooser_preferences, NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES);\n}\n\nstatic gboolean\nshould_skip_file (NautilusDirectory *directory,\n                  GFileInfo         *info)\n{\n    static gboolean show_hidden_files_changed_callback_installed = FALSE;\n\n    /* Add the callback once for the life of our process */\n    if (!show_hidden_files_changed_callback_installed)\n    {\n        g_signal_connect_swapped (gtk_filechooser_preferences,\n                                  \"changed::\" NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES,\n                                  G_CALLBACK (show_hidden_files_changed_callback),\n                                  NULL);\n\n        show_hidden_files_changed_callback_installed = TRUE;\n\n        /* Peek for the first time */\n        show_hidden_files_changed_callback (NULL);\n    }\n\n    if (!show_hidden_files &&\n        (g_file_info_get_is_hidden (info) ||\n         g_file_info_get_is_backup (info)))\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic gboolean\ndequeue_pending_idle_callback (gpointer callback_data)\n{\n    NautilusDirectory *directory;\n    GList *pending_file_info;\n    GList *node, *next;\n    NautilusFile *file;\n    GList *changed_files, *added_files;\n    GFileInfo *file_info;\n    const char *mimetype, *name;\n    DirectoryLoadState *dir_load_state;\n\n    directory = NAUTILUS_DIRECTORY (callback_data);\n\n    nautilus_directory_ref (directory);\n\n    nautilus_profile_start (\"nitems %d\", g_list_length (directory->details->pending_file_info));\n\n    directory->details->dequeue_pending_idle_id = 0;\n\n    /* Handle the files in the order we saw them. */\n    pending_file_info = g_list_reverse (directory->details->pending_file_info);\n    directory->details->pending_file_info = NULL;\n\n    /* If we are no longer monitoring, then throw away these. */\n    if (!nautilus_directory_is_file_list_monitored (directory))\n    {\n        nautilus_directory_async_state_changed (directory);\n        goto drain;\n    }\n\n    added_files = NULL;\n    changed_files = NULL;\n\n    dir_load_state = directory->details->directory_load_in_progress;\n\n    /* Build a list of NautilusFile objects. */\n    for (node = pending_file_info; node != NULL; node = node->next)\n    {\n        file_info = node->data;\n\n        name = g_file_info_get_name (file_info);\n\n        /* Update the file count. */\n        /* FIXME bugzilla.gnome.org 45063: This could count a\n         * file twice if we get it from both load_directory\n         * and from new_files_callback. Not too hard to fix by\n         * moving this into the actual callback instead of\n         * waiting for the idle function.\n         */\n        if (dir_load_state &&\n            !should_skip_file (directory, file_info))\n        {\n            dir_load_state->load_file_count += 1;\n\n            /* Add the MIME type to the set. */\n            mimetype = g_file_info_get_content_type (file_info);\n            if (mimetype != NULL)\n            {\n                istr_set_insert (dir_load_state->load_mime_list_hash,\n                                 mimetype);\n            }\n        }\n\n        /* check if the file already exists */\n        file = nautilus_directory_find_file_by_name (directory, name);\n        if (file != NULL)\n        {\n            /* file already exists in dir, check if we still need to\n             *  emit file_added or if it changed */\n            set_file_unconfirmed (file, FALSE);\n            if (!file->details->is_added)\n            {\n                /* We consider this newly added even if its in the list.\n                 * This can happen if someone called nautilus_file_get_by_uri()\n                 * on a file in the folder before the add signal was\n                 * emitted */\n                nautilus_file_ref (file);\n                file->details->is_added = TRUE;\n                added_files = g_list_prepend (added_files, file);\n            }\n            else if (nautilus_file_update_info (file, file_info))\n            {\n                /* File changed, notify about the change. */\n                nautilus_file_ref (file);\n                changed_files = g_list_prepend (changed_files, file);\n            }\n        }\n        else\n        {\n            /* new file, create a nautilus file object and add it to the list */\n            file = nautilus_file_new_from_info (directory, file_info);\n            nautilus_directory_add_file (directory, file);\n            file->details->is_added = TRUE;\n            added_files = g_list_prepend (added_files, file);\n        }\n    }\n\n    /* If we are done loading, then we assume that any unconfirmed\n     * files are gone.\n     */\n    if (directory->details->directory_loaded)\n    {\n        for (node = directory->details->file_list;\n             node != NULL; node = next)\n        {\n            file = NAUTILUS_FILE (node->data);\n            next = node->next;\n\n            if (file->details->unconfirmed)\n            {\n                nautilus_file_ref (file);\n                changed_files = g_list_prepend (changed_files, file);\n\n                nautilus_file_mark_gone (file);\n            }\n        }\n    }\n\n    /* Send the changed and added signals. */\n    nautilus_directory_emit_change_signals (directory, changed_files);\n    nautilus_file_list_free (changed_files);\n    nautilus_directory_emit_files_added (directory, added_files);\n    nautilus_file_list_free (added_files);\n\n    if (directory->details->directory_loaded &&\n        !directory->details->directory_loaded_sent_notification)\n    {\n        /* Send the done_loading signal. */\n        nautilus_directory_emit_done_loading (directory);\n\n        if (dir_load_state)\n        {\n            file = dir_load_state->load_directory_file;\n\n            file->details->directory_count = dir_load_state->load_file_count;\n            file->details->directory_count_is_up_to_date = TRUE;\n            file->details->got_directory_count = TRUE;\n\n            file->details->got_mime_list = TRUE;\n            file->details->mime_list_is_up_to_date = TRUE;\n            g_list_free_full (file->details->mime_list, g_free);\n            file->details->mime_list = istr_set_get_as_list\n                                           (dir_load_state->load_mime_list_hash);\n\n            nautilus_file_changed (file);\n        }\n\n        nautilus_directory_async_state_changed (directory);\n\n        directory->details->directory_loaded_sent_notification = TRUE;\n    }\n\ndrain:\n    g_list_free_full (pending_file_info, g_object_unref);\n\n    /* Get the state machine running again. */\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_profile_end (NULL);\n\n    nautilus_directory_unref (directory);\n    return FALSE;\n}\n\nvoid\nnautilus_directory_schedule_dequeue_pending (NautilusDirectory *directory)\n{\n    if (directory->details->dequeue_pending_idle_id == 0)\n    {\n        directory->details->dequeue_pending_idle_id\n            = g_idle_add (dequeue_pending_idle_callback, directory);\n    }\n}\n\nstatic void\ndirectory_load_one (NautilusDirectory *directory,\n                    GFileInfo         *info)\n{\n    if (info == NULL)\n    {\n        return;\n    }\n\n    if (g_file_info_get_name (info) == NULL)\n    {\n        char *uri;\n\n        uri = nautilus_directory_get_uri (directory);\n        g_warning (\"Got GFileInfo with NULL name in %s, ignoring. This shouldn't happen unless the gvfs backend is broken.\\n\", uri);\n        g_free (uri);\n\n        return;\n    }\n\n    /* Arrange for the \"loading\" part of the work. */\n    g_object_ref (info);\n    directory->details->pending_file_info\n        = g_list_prepend (directory->details->pending_file_info, info);\n    nautilus_directory_schedule_dequeue_pending (directory);\n}\n\nstatic void\ndirectory_load_cancel (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n    DirectoryLoadState *state;\n\n    state = directory->details->directory_load_in_progress;\n    if (state != NULL)\n    {\n        file = state->load_directory_file;\n        file->details->loading_directory = FALSE;\n        if (file->details->directory != directory)\n        {\n            nautilus_directory_async_state_changed (file->details->directory);\n        }\n\n        g_cancellable_cancel (state->cancellable);\n        state->directory = NULL;\n        directory->details->directory_load_in_progress = NULL;\n        async_job_end (directory, \"file list\");\n    }\n}\n\nstatic void\nfile_list_cancel (NautilusDirectory *directory)\n{\n    directory_load_cancel (directory);\n\n    if (directory->details->dequeue_pending_idle_id != 0)\n    {\n        g_source_remove (directory->details->dequeue_pending_idle_id);\n        directory->details->dequeue_pending_idle_id = 0;\n    }\n\n    if (directory->details->pending_file_info != NULL)\n    {\n        g_list_free_full (directory->details->pending_file_info, g_object_unref);\n        directory->details->pending_file_info = NULL;\n    }\n}\n\nstatic void\ndirectory_load_done (NautilusDirectory *directory,\n                     GError            *error)\n{\n    GList *node;\n\n    nautilus_profile_start (NULL);\n    g_object_ref (directory);\n\n    directory->details->directory_loaded = TRUE;\n    directory->details->directory_loaded_sent_notification = FALSE;\n\n    if (error != NULL)\n    {\n        /* The load did not complete successfully. This means\n         * we don't know the status of the files in this directory.\n         * We clear the unconfirmed bit on each file here so that\n         * they won't be marked \"gone\" later -- we don't know enough\n         * about them to know whether they are really gone.\n         */\n        for (node = directory->details->file_list;\n             node != NULL; node = node->next)\n        {\n            set_file_unconfirmed (NAUTILUS_FILE (node->data), FALSE);\n        }\n\n        nautilus_directory_emit_load_error (directory, error);\n    }\n\n    /* Call the idle function right away. */\n    if (directory->details->dequeue_pending_idle_id != 0)\n    {\n        g_source_remove (directory->details->dequeue_pending_idle_id);\n    }\n    dequeue_pending_idle_callback (directory);\n\n    directory_load_cancel (directory);\n\n    g_object_unref (directory);\n    nautilus_profile_end (NULL);\n}\n\nvoid\nnautilus_directory_monitor_remove_internal (NautilusDirectory *directory,\n                                            NautilusFile      *file,\n                                            gconstpointer      client)\n{\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (client != NULL);\n\n    remove_monitor (directory, file, client);\n\n    if (directory->details->monitor != NULL\n        && directory->details->monitor_list == NULL)\n    {\n        nautilus_monitor_cancel (directory->details->monitor);\n        directory->details->monitor = NULL;\n    }\n\n    /* XXX - do we need to remove anything from the work queue? */\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nFileMonitors *\nnautilus_directory_remove_file_monitors (NautilusDirectory *directory,\n                                         NautilusFile      *file)\n{\n    GList *result, **list, *node, *next;\n    Monitor *monitor;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (NAUTILUS_IS_FILE (file));\n    g_assert (file->details->directory == directory);\n\n    result = NULL;\n\n    list = &directory->details->monitor_list;\n    for (node = directory->details->monitor_list; node != NULL; node = next)\n    {\n        next = node->next;\n        monitor = node->data;\n\n        if (monitor->file == file)\n        {\n            *list = g_list_remove_link (*list, node);\n            result = g_list_concat (node, result);\n            request_counter_remove_request (directory->details->monitor_counters,\n                                            monitor->request);\n        }\n    }\n\n    /* XXX - do we need to remove anything from the work queue? */\n\n    nautilus_directory_async_state_changed (directory);\n\n    return (FileMonitors *) result;\n}\n\nvoid\nnautilus_directory_add_file_monitors (NautilusDirectory *directory,\n                                      NautilusFile      *file,\n                                      FileMonitors      *monitors)\n{\n    GList **list;\n    GList *l;\n    Monitor *monitor;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (NAUTILUS_IS_FILE (file));\n    g_assert (file->details->directory == directory);\n\n    if (monitors == NULL)\n    {\n        return;\n    }\n\n    for (l = (GList *) monitors; l != NULL; l = l->next)\n    {\n        monitor = l->data;\n        request_counter_add_request (directory->details->monitor_counters,\n                                     monitor->request);\n    }\n\n    list = &directory->details->monitor_list;\n    *list = g_list_concat (*list, (GList *) monitors);\n\n    nautilus_directory_add_file_to_work_queue (directory, file);\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic int\nready_callback_key_compare (gconstpointer a,\n                            gconstpointer b)\n{\n    const ReadyCallback *callback_a, *callback_b;\n\n    callback_a = a;\n    callback_b = b;\n\n    if (callback_a->file < callback_b->file)\n    {\n        return -1;\n    }\n    if (callback_a->file > callback_b->file)\n    {\n        return 1;\n    }\n    if (callback_a->file == NULL)\n    {\n        /* ANSI C doesn't allow ordered compares of function pointers, so we cast them to\n         * normal pointers to make some overly pedantic compilers (*cough* HP-UX *cough*)\n         * compile this. Of course, on any compiler where ordered function pointers actually\n         * break this probably won't work, but at least it will compile on platforms where it\n         * works, but stupid compilers won't let you use it.\n         */\n        if ((void *) callback_a->callback.directory < (void *) callback_b->callback.directory)\n        {\n            return -1;\n        }\n        if ((void *) callback_a->callback.directory > (void *) callback_b->callback.directory)\n        {\n            return 1;\n        }\n    }\n    else\n    {\n        if ((void *) callback_a->callback.file < (void *) callback_b->callback.file)\n        {\n            return -1;\n        }\n        if ((void *) callback_a->callback.file > (void *) callback_b->callback.file)\n        {\n            return 1;\n        }\n    }\n    if (callback_a->callback_data < callback_b->callback_data)\n    {\n        return -1;\n    }\n    if (callback_a->callback_data > callback_b->callback_data)\n    {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\nready_callback_key_compare_only_active (gconstpointer a,\n                                        gconstpointer b)\n{\n    const ReadyCallback *callback_a;\n\n    callback_a = a;\n\n    /* Non active callbacks never match */\n    if (!callback_a->active)\n    {\n        return -1;\n    }\n\n    return ready_callback_key_compare (a, b);\n}\n\nstatic void\nready_callback_call (NautilusDirectory   *directory,\n                     const ReadyCallback *callback)\n{\n    GList *file_list;\n\n    /* Call the callback. */\n    if (callback->file != NULL)\n    {\n        if (callback->callback.file)\n        {\n            (*callback->callback.file)(callback->file,\n                                       callback->callback_data);\n        }\n    }\n    else if (callback->callback.directory != NULL)\n    {\n        if (directory == NULL ||\n            !REQUEST_WANTS_TYPE (callback->request, REQUEST_FILE_LIST))\n        {\n            file_list = NULL;\n        }\n        else\n        {\n            file_list = nautilus_directory_get_file_list (directory);\n        }\n\n        /* Pass back the file list if the user was waiting for it. */\n        (*callback->callback.directory)(directory,\n                                        file_list,\n                                        callback->callback_data);\n\n        nautilus_file_list_free (file_list);\n    }\n}\n\nvoid\nnautilus_directory_call_when_ready_internal (NautilusDirectory         *directory,\n                                             NautilusFile              *file,\n                                             NautilusFileAttributes     file_attributes,\n                                             gboolean                   wait_for_file_list,\n                                             NautilusDirectoryCallback  directory_callback,\n                                             NautilusFileCallback       file_callback,\n                                             gpointer                   callback_data)\n{\n    ReadyCallback callback;\n\n    g_assert (directory == NULL || NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (file != NULL || directory_callback != NULL);\n\n    /* Construct a callback object. */\n    callback.active = TRUE;\n    callback.file = file;\n    if (file == NULL)\n    {\n        callback.callback.directory = directory_callback;\n    }\n    else\n    {\n        callback.callback.file = file_callback;\n    }\n    callback.callback_data = callback_data;\n    callback.request = nautilus_directory_set_up_request (file_attributes);\n    if (wait_for_file_list)\n    {\n        REQUEST_SET_TYPE (callback.request, REQUEST_FILE_LIST);\n    }\n\n    /* Handle the NULL case. */\n    if (directory == NULL)\n    {\n        ready_callback_call (NULL, &callback);\n        return;\n    }\n\n    /* Check if the callback is already there. */\n    if (g_list_find_custom (directory->details->call_when_ready_list,\n                            &callback,\n                            ready_callback_key_compare_only_active) != NULL)\n    {\n        if (file_callback != NULL && directory_callback != NULL)\n        {\n            g_warning (\"tried to add a new callback while an old one was pending\");\n        }\n        /* NULL callback means, just read it. Conflicts are ok. */\n        return;\n    }\n\n    /* Add the new callback to the list. */\n    directory->details->call_when_ready_list = g_list_prepend\n                                                   (directory->details->call_when_ready_list,\n                                                   g_memdup (&callback, sizeof (callback)));\n    request_counter_add_request (directory->details->call_when_ready_counters,\n                                 callback.request);\n\n    /* Put the callback file or all the files on the work queue. */\n    if (file != NULL)\n    {\n        nautilus_directory_add_file_to_work_queue (directory, file);\n    }\n    else\n    {\n        add_all_files_to_work_queue (directory);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\ngboolean\nnautilus_directory_check_if_ready_internal (NautilusDirectory      *directory,\n                                            NautilusFile           *file,\n                                            NautilusFileAttributes  file_attributes)\n{\n    Request request;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n\n    request = nautilus_directory_set_up_request (file_attributes);\n    return request_is_satisfied (directory, file, request);\n}\n\nstatic void\nremove_callback_link_keep_data (NautilusDirectory *directory,\n                                GList             *link)\n{\n    ReadyCallback *callback;\n\n    callback = link->data;\n\n    directory->details->call_when_ready_list = g_list_remove_link\n                                                   (directory->details->call_when_ready_list, link);\n\n    request_counter_remove_request (directory->details->call_when_ready_counters,\n                                    callback->request);\n    g_list_free_1 (link);\n}\n\nstatic void\nremove_callback_link (NautilusDirectory *directory,\n                      GList             *link)\n{\n    ReadyCallback *callback;\n\n    callback = link->data;\n    remove_callback_link_keep_data (directory, link);\n    g_free (callback);\n}\n\nvoid\nnautilus_directory_cancel_callback_internal (NautilusDirectory         *directory,\n                                             NautilusFile              *file,\n                                             NautilusDirectoryCallback  directory_callback,\n                                             NautilusFileCallback       file_callback,\n                                             gpointer                   callback_data)\n{\n    ReadyCallback callback;\n    GList *node;\n\n    if (directory == NULL)\n    {\n        return;\n    }\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (file != NULL || directory_callback != NULL);\n    g_assert (file == NULL || file_callback != NULL);\n\n    /* Construct a callback object. */\n    callback.file = file;\n    if (file == NULL)\n    {\n        callback.callback.directory = directory_callback;\n    }\n    else\n    {\n        callback.callback.file = file_callback;\n    }\n    callback.callback_data = callback_data;\n\n    /* Remove all queued callback from the list (including non-active). */\n    do\n    {\n        node = g_list_find_custom (directory->details->call_when_ready_list,\n                                   &callback,\n                                   ready_callback_key_compare);\n        if (node != NULL)\n        {\n            remove_callback_link (directory, node);\n\n            nautilus_directory_async_state_changed (directory);\n        }\n    }\n    while (node != NULL);\n}\n\nstatic void\nnew_files_state_unref (NewFilesState *state)\n{\n    state->count--;\n\n    if (state->count == 0)\n    {\n        if (state->directory)\n        {\n            state->directory->details->new_files_in_progress =\n                g_list_remove (state->directory->details->new_files_in_progress,\n                               state);\n        }\n\n        g_object_unref (state->cancellable);\n        g_free (state);\n    }\n}\n\nstatic void\nnew_files_callback (GObject      *source_object,\n                    GAsyncResult *res,\n                    gpointer      user_data)\n{\n    NautilusDirectory *directory;\n    GFileInfo *info;\n    NewFilesState *state;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        new_files_state_unref (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    /* Queue up the new file. */\n    info = g_file_query_info_finish (G_FILE (source_object), res, NULL);\n    if (info != NULL)\n    {\n        directory_load_one (directory, info);\n        g_object_unref (info);\n    }\n\n    new_files_state_unref (state);\n\n    nautilus_directory_unref (directory);\n}\n\nvoid\nnautilus_directory_get_info_for_new_files (NautilusDirectory *directory,\n                                           GList             *location_list)\n{\n    NewFilesState *state;\n    GFile *location;\n    GList *l;\n\n    if (location_list == NULL)\n    {\n        return;\n    }\n\n    state = g_new (NewFilesState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->count = 0;\n\n    for (l = location_list; l != NULL; l = l->next)\n    {\n        location = l->data;\n\n        state->count++;\n\n        g_file_query_info_async (location,\n                                 NAUTILUS_FILE_DEFAULT_ATTRIBUTES,\n                                 0,\n                                 G_PRIORITY_DEFAULT,\n                                 state->cancellable,\n                                 new_files_callback, state);\n    }\n\n    directory->details->new_files_in_progress\n        = g_list_prepend (directory->details->new_files_in_progress,\n                          state);\n}\n\nvoid\nnautilus_async_destroying_file (NautilusFile *file)\n{\n    NautilusDirectory *directory;\n    gboolean changed;\n    GList *node, *next;\n    ReadyCallback *callback;\n    Monitor *monitor;\n\n    directory = file->details->directory;\n    changed = FALSE;\n\n    /* Check for callbacks. */\n    for (node = directory->details->call_when_ready_list; node != NULL; node = next)\n    {\n        next = node->next;\n        callback = node->data;\n\n        if (callback->file == file)\n        {\n            /* Client should have cancelled callback. */\n            if (callback->active)\n            {\n                g_warning (\"destroyed file has call_when_ready pending\");\n            }\n            remove_callback_link (directory, node);\n            changed = TRUE;\n        }\n    }\n\n    /* Check for monitors. */\n    for (node = directory->details->monitor_list; node != NULL; node = next)\n    {\n        next = node->next;\n        monitor = node->data;\n\n        if (monitor->file == file)\n        {\n            /* Client should have removed monitor earlier. */\n            g_warning (\"destroyed file still being monitored\");\n            remove_monitor_link (directory, node);\n            changed = TRUE;\n        }\n    }\n\n    /* Check if it's a file that's currently being worked on.\n     * If so, make that NULL so it gets canceled right away.\n     */\n    if (directory->details->count_in_progress != NULL &&\n        directory->details->count_in_progress->count_file == file)\n    {\n        directory->details->count_in_progress->count_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->deep_count_file == file)\n    {\n        directory->details->deep_count_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->mime_list_in_progress != NULL &&\n        directory->details->mime_list_in_progress->mime_list_file == file)\n    {\n        directory->details->mime_list_in_progress->mime_list_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->get_info_file == file)\n    {\n        directory->details->get_info_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->link_info_read_state != NULL &&\n        directory->details->link_info_read_state->file == file)\n    {\n        directory->details->link_info_read_state->file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->extension_info_file == file)\n    {\n        directory->details->extension_info_file = NULL;\n        changed = TRUE;\n    }\n\n    if (directory->details->thumbnail_state != NULL &&\n        directory->details->thumbnail_state->file == file)\n    {\n        directory->details->thumbnail_state->file = NULL;\n        changed = TRUE;\n    }\n\n    if (directory->details->mount_state != NULL &&\n        directory->details->mount_state->file == file)\n    {\n        directory->details->mount_state->file = NULL;\n        changed = TRUE;\n    }\n\n    if (directory->details->filesystem_info_state != NULL &&\n        directory->details->filesystem_info_state->file == file)\n    {\n        directory->details->filesystem_info_state->file = NULL;\n        changed = TRUE;\n    }\n\n    /* Let the directory take care of the rest. */\n    if (changed)\n    {\n        nautilus_directory_async_state_changed (directory);\n    }\n}\n\nstatic gboolean\nlacks_directory_count (NautilusFile *file)\n{\n    return !file->details->directory_count_is_up_to_date\n           && nautilus_file_should_show_directory_item_count (file);\n}\n\nstatic gboolean\nshould_get_directory_count_now (NautilusFile *file)\n{\n    return lacks_directory_count (file)\n           && !file->details->loading_directory;\n}\n\nstatic gboolean\nlacks_info (NautilusFile *file)\n{\n    return !file->details->file_info_is_up_to_date\n           && !file->details->is_gone;\n}\n\nstatic gboolean\nlacks_filesystem_info (NautilusFile *file)\n{\n    return !file->details->filesystem_info_is_up_to_date;\n}\n\nstatic gboolean\nlacks_deep_count (NautilusFile *file)\n{\n    return file->details->deep_counts_status != NAUTILUS_REQUEST_DONE;\n}\n\nstatic gboolean\nlacks_mime_list (NautilusFile *file)\n{\n    return !file->details->mime_list_is_up_to_date;\n}\n\nstatic gboolean\nshould_get_mime_list (NautilusFile *file)\n{\n    return lacks_mime_list (file)\n           && !file->details->loading_directory;\n}\n\nstatic gboolean\nlacks_link_info (NautilusFile *file)\n{\n    if (file->details->file_info_is_up_to_date &&\n        !file->details->link_info_is_up_to_date)\n    {\n        if (nautilus_file_is_nautilus_link (file))\n        {\n            return TRUE;\n        }\n        else\n        {\n            link_info_done (file->details->directory, file, NULL, NULL, NULL, FALSE, FALSE);\n            return FALSE;\n        }\n    }\n    else\n    {\n        return FALSE;\n    }\n}\n\nstatic gboolean\nlacks_extension_info (NautilusFile *file)\n{\n    return file->details->pending_info_providers != NULL;\n}\n\nstatic gboolean\nlacks_thumbnail (NautilusFile *file)\n{\n    return nautilus_file_should_show_thumbnail (file) &&\n           file->details->thumbnail_path != NULL &&\n           !file->details->thumbnail_is_up_to_date;\n}\n\nstatic gboolean\nlacks_mount (NautilusFile *file)\n{\n    return (!file->details->mount_is_up_to_date &&\n            (\n                /* Unix mountpoint, could be a GMount */\n                file->details->is_mountpoint ||\n\n                /* The toplevel directory of something */\n                (file->details->type == G_FILE_TYPE_DIRECTORY &&\n                 nautilus_file_is_self_owned (file)) ||\n\n                /* Mountable, could be a mountpoint */\n                (file->details->type == G_FILE_TYPE_MOUNTABLE)\n\n            )\n            );\n}\n\nstatic gboolean\nhas_problem (NautilusDirectory *directory,\n             NautilusFile      *file,\n             FileCheck          problem)\n{\n    GList *node;\n\n    if (file != NULL)\n    {\n        return (*problem)(file);\n    }\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        if ((*problem)(node->data))\n        {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\nstatic gboolean\nrequest_is_satisfied (NautilusDirectory *directory,\n                      NautilusFile      *file,\n                      Request            request)\n{\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_LIST) &&\n        !(directory->details->directory_loaded &&\n          directory->details->directory_loaded_sent_notification))\n    {\n        return FALSE;\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))\n    {\n        if (has_problem (directory, file, lacks_directory_count))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))\n    {\n        if (has_problem (directory, file, lacks_info))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))\n    {\n        if (has_problem (directory, file, lacks_filesystem_info))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))\n    {\n        if (has_problem (directory, file, lacks_deep_count))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))\n    {\n        if (has_problem (directory, file, lacks_thumbnail))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))\n    {\n        if (has_problem (directory, file, lacks_mount))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))\n    {\n        if (has_problem (directory, file, lacks_mime_list))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))\n    {\n        if (has_problem (directory, file, lacks_link_info))\n        {\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic gboolean\ncall_ready_callbacks_at_idle (gpointer callback_data)\n{\n    NautilusDirectory *directory;\n    GList *node, *next;\n    ReadyCallback *callback;\n\n    directory = NAUTILUS_DIRECTORY (callback_data);\n    directory->details->call_ready_idle_id = 0;\n\n    nautilus_directory_ref (directory);\n\n    callback = NULL;\n    while (1)\n    {\n        /* Check if any callbacks are non-active and call them if they are. */\n        for (node = directory->details->call_when_ready_list;\n             node != NULL; node = next)\n        {\n            next = node->next;\n            callback = node->data;\n            if (!callback->active)\n            {\n                /* Non-active, remove and call */\n                break;\n            }\n        }\n        if (node == NULL)\n        {\n            break;\n        }\n\n        /* Callbacks are one-shots, so remove it now. */\n        remove_callback_link_keep_data (directory, node);\n\n        /* Call the callback. */\n        ready_callback_call (directory, callback);\n        g_free (callback);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_directory_unref (directory);\n\n    return FALSE;\n}\n\nstatic void\nschedule_call_ready_callbacks (NautilusDirectory *directory)\n{\n    if (directory->details->call_ready_idle_id == 0)\n    {\n        directory->details->call_ready_idle_id\n            = g_idle_add (call_ready_callbacks_at_idle, directory);\n    }\n}\n\n/* Marks all callbacks that are ready as non-active and\n * calls them at idle time, unless they are removed\n * before then */\nstatic gboolean\ncall_ready_callbacks (NautilusDirectory *directory)\n{\n    gboolean found_any;\n    GList *node, *next;\n    ReadyCallback *callback;\n\n    found_any = FALSE;\n\n    /* Check if any callbacks are satisifed and mark them for call them if they are. */\n    for (node = directory->details->call_when_ready_list;\n         node != NULL; node = next)\n    {\n        next = node->next;\n        callback = node->data;\n        if (callback->active &&\n            request_is_satisfied (directory, callback->file, callback->request))\n        {\n            callback->active = FALSE;\n            found_any = TRUE;\n        }\n    }\n\n    if (found_any)\n    {\n        schedule_call_ready_callbacks (directory);\n    }\n\n    return found_any;\n}\n\ngboolean\nnautilus_directory_has_active_request_for_file (NautilusDirectory *directory,\n                                                NautilusFile      *file)\n{\n    GList *node;\n    ReadyCallback *callback;\n    Monitor *monitor;\n\n    for (node = directory->details->call_when_ready_list;\n         node != NULL; node = node->next)\n    {\n        callback = node->data;\n        if (callback->file == file ||\n            callback->file == NULL)\n        {\n            return TRUE;\n        }\n    }\n\n    for (node = directory->details->monitor_list;\n         node != NULL; node = node->next)\n    {\n        monitor = node->data;\n        if (monitor->file == file ||\n            monitor->file == NULL)\n        {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n\n/* This checks if there's a request for monitoring the file list. */\ngboolean\nnautilus_directory_is_anyone_monitoring_file_list (NautilusDirectory *directory)\n{\n    if (directory->details->call_when_ready_counters[REQUEST_FILE_LIST] > 0)\n    {\n        return TRUE;\n    }\n\n    if (directory->details->monitor_counters[REQUEST_FILE_LIST] > 0)\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\n/* This checks if the file list being monitored. */\ngboolean\nnautilus_directory_is_file_list_monitored (NautilusDirectory *directory)\n{\n    return directory->details->file_list_monitored;\n}\n\nstatic void\nmark_all_files_unconfirmed (NautilusDirectory *directory)\n{\n    GList *node;\n    NautilusFile *file;\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        file = node->data;\n        set_file_unconfirmed (file, TRUE);\n    }\n}\n\nstatic void\ndirectory_load_state_free (DirectoryLoadState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n\n    if (state->load_mime_list_hash != NULL)\n    {\n        istr_set_destroy (state->load_mime_list_hash);\n    }\n    nautilus_file_unref (state->load_directory_file);\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\nmore_files_callback (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    DirectoryLoadState *state;\n    NautilusDirectory *directory;\n    GError *error;\n    GList *files, *l;\n    GFileInfo *info;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        directory_load_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    g_assert (directory->details->directory_load_in_progress != NULL);\n    g_assert (directory->details->directory_load_in_progress == state);\n\n    error = NULL;\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, &error);\n\n    for (l = files; l != NULL; l = l->next)\n    {\n        info = l->data;\n        directory_load_one (directory, info);\n        g_object_unref (info);\n    }\n\n    if (files == NULL)\n    {\n        directory_load_done (directory, error);\n        directory_load_state_free (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            more_files_callback,\n                                            state);\n    }\n\n    nautilus_directory_unref (directory);\n\n    if (error)\n    {\n        g_error_free (error);\n    }\n\n    g_list_free (files);\n}\n\nstatic void\nenumerate_children_callback (GObject      *source_object,\n                             GAsyncResult *res,\n                             gpointer      user_data)\n{\n    DirectoryLoadState *state;\n    GFileEnumerator *enumerator;\n    GError *error;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        directory_load_state_free (state);\n        return;\n    }\n\n    error = NULL;\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),\n                                                   res, &error);\n\n    if (enumerator == NULL)\n    {\n        directory_load_done (state->directory, error);\n        g_error_free (error);\n        directory_load_state_free (state);\n        return;\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            more_files_callback,\n                                            state);\n    }\n}\n\n\n/* Start monitoring the file list if it isn't already. */\nstatic void\nstart_monitoring_file_list (NautilusDirectory *directory)\n{\n    DirectoryLoadState *state;\n\n    if (!directory->details->file_list_monitored)\n    {\n        g_assert (!directory->details->directory_load_in_progress);\n        directory->details->file_list_monitored = TRUE;\n        nautilus_file_list_ref (directory->details->file_list);\n    }\n\n    if (directory->details->directory_loaded ||\n        directory->details->directory_load_in_progress != NULL)\n    {\n        return;\n    }\n\n    if (!async_job_start (directory, \"file list\"))\n    {\n        return;\n    }\n\n    mark_all_files_unconfirmed (directory);\n\n    state = g_new0 (DirectoryLoadState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->load_mime_list_hash = istr_set_new ();\n    state->load_file_count = 0;\n\n    g_assert (directory->details->location != NULL);\n    state->load_directory_file =\n        nautilus_directory_get_corresponding_file (directory);\n    state->load_directory_file->details->loading_directory = TRUE;\n\n\n#ifdef DEBUG_LOAD_DIRECTORY\n    g_message (\"load_directory called to monitor file list of %p\", directory->details->location);\n#endif\n\n    directory->details->directory_load_in_progress = state;\n\n    g_file_enumerate_children_async (directory->details->location,\n                                     NAUTILUS_FILE_DEFAULT_ATTRIBUTES,\n                                     0,     /* flags */\n                                     G_PRIORITY_DEFAULT,     /* prio */\n                                     state->cancellable,\n                                     enumerate_children_callback,\n                                     state);\n}\n\n/* Stop monitoring the file list if it is being monitored. */\nvoid\nnautilus_directory_stop_monitoring_file_list (NautilusDirectory *directory)\n{\n    if (!directory->details->file_list_monitored)\n    {\n        g_assert (directory->details->directory_load_in_progress == NULL);\n        return;\n    }\n\n    directory->details->file_list_monitored = FALSE;\n    file_list_cancel (directory);\n    nautilus_file_list_unref (directory->details->file_list);\n    directory->details->directory_loaded = FALSE;\n}\n\nstatic void\nfile_list_start_or_stop (NautilusDirectory *directory)\n{\n    if (nautilus_directory_is_anyone_monitoring_file_list (directory))\n    {\n        start_monitoring_file_list (directory);\n    }\n    else\n    {\n        nautilus_directory_stop_monitoring_file_list (directory);\n    }\n}\n\nvoid\nnautilus_file_invalidate_count_and_mime_list (NautilusFile *file)\n{\n    NautilusFileAttributes attributes;\n\n    attributes = NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT |\n                 NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;\n\n    nautilus_file_invalidate_attributes (file, attributes);\n}\n\n\n/* Reset count and mime list. Invalidating deep counts is handled by\n * itself elsewhere because it's a relatively heavyweight and\n * special-purpose operation (see bug 5863). Also, the shallow count\n * needs to be refreshed when filtering changes, but the deep count\n * deliberately does not take filtering into account.\n */\nvoid\nnautilus_directory_invalidate_count_and_mime_list (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    file = nautilus_directory_get_existing_corresponding_file (directory);\n    if (file != NULL)\n    {\n        nautilus_file_invalidate_count_and_mime_list (file);\n    }\n\n    nautilus_file_unref (file);\n}\n\nstatic void\nnautilus_directory_invalidate_file_attributes (NautilusDirectory      *directory,\n                                               NautilusFileAttributes  file_attributes)\n{\n    GList *node;\n\n    cancel_loading_attributes (directory, file_attributes);\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        nautilus_file_invalidate_attributes_internal (NAUTILUS_FILE (node->data),\n                                                      file_attributes);\n    }\n\n    if (directory->details->as_file != NULL)\n    {\n        nautilus_file_invalidate_attributes_internal (directory->details->as_file,\n                                                      file_attributes);\n    }\n}\n\nvoid\nnautilus_directory_force_reload_internal (NautilusDirectory      *directory,\n                                          NautilusFileAttributes  file_attributes)\n{\n    nautilus_profile_start (NULL);\n\n    /* invalidate attributes that are getting reloaded for all files */\n    nautilus_directory_invalidate_file_attributes (directory, file_attributes);\n\n    /* Start a new directory load. */\n    file_list_cancel (directory);\n    directory->details->directory_loaded = FALSE;\n\n    /* Start a new directory count. */\n    nautilus_directory_invalidate_count_and_mime_list (directory);\n\n    add_all_files_to_work_queue (directory);\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_profile_end (NULL);\n}\n\nstatic gboolean\nmonitor_includes_file (const Monitor *monitor,\n                       NautilusFile  *file)\n{\n    if (monitor->file == file)\n    {\n        return TRUE;\n    }\n    if (monitor->file != NULL)\n    {\n        return FALSE;\n    }\n    if (file == file->details->directory->details->as_file)\n    {\n        return FALSE;\n    }\n    return nautilus_file_should_show (file,\n                                      monitor->monitor_hidden_files,\n                                      TRUE);\n}\n\nstatic gboolean\nis_needy (NautilusFile *file,\n          FileCheck     check_missing,\n          RequestType   request_type_wanted)\n{\n    NautilusDirectory *directory;\n    GList *node;\n    ReadyCallback *callback;\n    Monitor *monitor;\n\n    if (!(*check_missing)(file))\n    {\n        return FALSE;\n    }\n\n    directory = file->details->directory;\n    if (directory->details->call_when_ready_counters[request_type_wanted] > 0)\n    {\n        for (node = directory->details->call_when_ready_list;\n             node != NULL; node = node->next)\n        {\n            callback = node->data;\n            if (callback->active &&\n                REQUEST_WANTS_TYPE (callback->request, request_type_wanted))\n            {\n                if (callback->file == file)\n                {\n                    return TRUE;\n                }\n                if (callback->file == NULL\n                    && file != directory->details->as_file)\n                {\n                    return TRUE;\n                }\n            }\n        }\n    }\n\n    if (directory->details->monitor_counters[request_type_wanted] > 0)\n    {\n        for (node = directory->details->monitor_list;\n             node != NULL; node = node->next)\n        {\n            monitor = node->data;\n            if (REQUEST_WANTS_TYPE (monitor->request, request_type_wanted))\n            {\n                if (monitor_includes_file (monitor, file))\n                {\n                    return TRUE;\n                }\n            }\n        }\n    }\n    return FALSE;\n}\n\nstatic void\ndirectory_count_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->count_in_progress != NULL)\n    {\n        file = directory->details->count_in_progress->count_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          should_get_directory_count_now,\n                          REQUEST_DIRECTORY_COUNT))\n            {\n                return;\n            }\n        }\n\n        /* The count is not wanted, so stop it. */\n        directory_count_cancel (directory);\n    }\n}\n\nstatic guint\ncount_non_skipped_files (GList *list)\n{\n    guint count;\n    GList *node;\n    GFileInfo *info;\n\n    count = 0;\n    for (node = list; node != NULL; node = node->next)\n    {\n        info = node->data;\n        if (!should_skip_file (NULL, info))\n        {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nstatic void\ncount_children_done (NautilusDirectory *directory,\n                     NautilusFile      *count_file,\n                     gboolean           succeeded,\n                     int                count)\n{\n    g_assert (NAUTILUS_IS_FILE (count_file));\n\n    count_file->details->directory_count_is_up_to_date = TRUE;\n\n    /* Record either a failure or success. */\n    if (!succeeded)\n    {\n        count_file->details->directory_count_failed = TRUE;\n        count_file->details->got_directory_count = FALSE;\n        count_file->details->directory_count = 0;\n    }\n    else\n    {\n        count_file->details->directory_count_failed = FALSE;\n        count_file->details->got_directory_count = TRUE;\n        count_file->details->directory_count = count;\n    }\n    directory->details->count_in_progress = NULL;\n\n    /* Send file-changed even if count failed, so interested parties can\n     * distinguish between unknowable and not-yet-known cases.\n     */\n    nautilus_file_changed (count_file);\n\n    /* Start up the next one. */\n    async_job_end (directory, \"directory count\");\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\ndirectory_count_state_free (DirectoryCountState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n    g_object_unref (state->cancellable);\n    nautilus_directory_unref (state->directory);\n    g_free (state);\n}\n\nstatic void\ncount_more_files_callback (GObject      *source_object,\n                           GAsyncResult *res,\n                           gpointer      user_data)\n{\n    DirectoryCountState *state;\n    NautilusDirectory *directory;\n    GError *error;\n    GList *files;\n\n    state = user_data;\n    directory = state->directory;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n\n        async_job_end (directory, \"directory count\");\n        nautilus_directory_async_state_changed (directory);\n\n        directory_count_state_free (state);\n\n        return;\n    }\n\n    g_assert (directory->details->count_in_progress != NULL);\n    g_assert (directory->details->count_in_progress == state);\n\n    error = NULL;\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, &error);\n\n    state->file_count += count_non_skipped_files (files);\n\n    if (files == NULL)\n    {\n        count_children_done (directory, state->count_file,\n                             TRUE, state->file_count);\n        directory_count_state_free (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            count_more_files_callback,\n                                            state);\n    }\n\n    g_list_free_full (files, g_object_unref);\n\n    if (error)\n    {\n        g_error_free (error);\n    }\n}\n\nstatic void\ncount_children_callback (GObject      *source_object,\n                         GAsyncResult *res,\n                         gpointer      user_data)\n{\n    DirectoryCountState *state;\n    GFileEnumerator *enumerator;\n    NautilusDirectory *directory;\n    GError *error;\n\n    state = user_data;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n        directory = state->directory;\n\n        async_job_end (directory, \"directory count\");\n        nautilus_directory_async_state_changed (directory);\n\n        directory_count_state_free (state);\n\n        return;\n    }\n\n    error = NULL;\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),\n                                                   res, &error);\n\n    if (enumerator == NULL)\n    {\n        count_children_done (state->directory,\n                             state->count_file,\n                             FALSE, 0);\n        g_error_free (error);\n        directory_count_state_free (state);\n        return;\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            count_more_files_callback,\n                                            state);\n    }\n}\n\nstatic void\ndirectory_count_start (NautilusDirectory *directory,\n                       NautilusFile      *file,\n                       gboolean          *doing_io)\n{\n    DirectoryCountState *state;\n    GFile *location;\n\n    if (directory->details->count_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   should_get_directory_count_now,\n                   REQUEST_DIRECTORY_COUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        file->details->directory_count_is_up_to_date = TRUE;\n        file->details->directory_count_failed = FALSE;\n        file->details->got_directory_count = FALSE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"directory count\"))\n    {\n        return;\n    }\n\n    /* Start counting. */\n    state = g_new0 (DirectoryCountState, 1);\n    state->count_file = file;\n    state->directory = nautilus_directory_ref (directory);\n    state->cancellable = g_cancellable_new ();\n\n    directory->details->count_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n#ifdef DEBUG_LOAD_DIRECTORY\n    {\n        char *uri;\n        uri = g_file_get_uri (location);\n        g_message (\"load_directory called to get shallow file count for %s\", uri);\n        g_free (uri);\n    }\n#endif\n\n    g_file_enumerate_children_async (location,\n                                     G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP,\n                                     G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,     /* flags */\n                                     G_PRIORITY_DEFAULT,     /* prio */\n                                     state->cancellable,\n                                     count_children_callback,\n                                     state);\n    g_object_unref (location);\n}\n\nstatic inline gboolean\nseen_inode (DeepCountState *state,\n            GFileInfo      *info)\n{\n    guint64 inode, inode2;\n    guint i;\n\n    inode = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_UNIX_INODE);\n\n    if (inode != 0)\n    {\n        for (i = 0; i < state->seen_deep_count_inodes->len; i++)\n        {\n            inode2 = g_array_index (state->seen_deep_count_inodes, guint64, i);\n            if (inode == inode2)\n            {\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n\nstatic inline void\nmark_inode_as_seen (DeepCountState *state,\n                    GFileInfo      *info)\n{\n    guint64 inode;\n\n    inode = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_UNIX_INODE);\n    if (inode != 0)\n    {\n        g_array_append_val (state->seen_deep_count_inodes, inode);\n    }\n}\n\nstatic void\ndeep_count_one (DeepCountState *state,\n                GFileInfo      *info)\n{\n    NautilusFile *file;\n    GFile *subdir;\n    gboolean is_seen_inode;\n    const char *fs_id;\n\n    if (should_skip_file (NULL, info))\n    {\n        return;\n    }\n\n    is_seen_inode = seen_inode (state, info);\n    if (!is_seen_inode)\n    {\n        mark_inode_as_seen (state, info);\n    }\n\n    file = state->directory->details->deep_count_file;\n\n    if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n    {\n        /* Count the directory. */\n        file->details->deep_directory_count += 1;\n\n        /* Record the fact that we have to descend into this directory. */\n        fs_id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);\n        if (g_strcmp0 (fs_id, state->fs_id) == 0)\n        {\n            /* only if it is on the same filesystem */\n            subdir = g_file_get_child (state->deep_count_location, g_file_info_get_name (info));\n            state->deep_count_subdirectories = g_list_prepend\n                                                   (state->deep_count_subdirectories, subdir);\n        }\n    }\n    else\n    {\n        /* Even non-regular files count as files. */\n        file->details->deep_file_count += 1;\n    }\n\n    /* Count the size. */\n    if (!is_seen_inode && g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_STANDARD_SIZE))\n    {\n        file->details->deep_size += g_file_info_get_size (info);\n    }\n}\n\nstatic void\ndeep_count_state_free (DeepCountState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n    g_object_unref (state->cancellable);\n    if (state->deep_count_location)\n    {\n        g_object_unref (state->deep_count_location);\n    }\n    g_list_free_full (state->deep_count_subdirectories, g_object_unref);\n    g_array_free (state->seen_deep_count_inodes, TRUE);\n    g_free (state->fs_id);\n    g_free (state);\n}\n\nstatic void\ndeep_count_next_dir (DeepCountState *state)\n{\n    GFile *location;\n    NautilusFile *file;\n    NautilusDirectory *directory;\n    gboolean done;\n\n    directory = state->directory;\n\n    g_object_unref (state->deep_count_location);\n    state->deep_count_location = NULL;\n\n    done = FALSE;\n    file = directory->details->deep_count_file;\n\n    if (state->deep_count_subdirectories != NULL)\n    {\n        /* Work on a new directory. */\n        location = state->deep_count_subdirectories->data;\n        state->deep_count_subdirectories = g_list_remove\n                                               (state->deep_count_subdirectories, location);\n        deep_count_load (state, location);\n        g_object_unref (location);\n    }\n    else\n    {\n        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;\n        directory->details->deep_count_file = NULL;\n        directory->details->deep_count_in_progress = NULL;\n        deep_count_state_free (state);\n        done = TRUE;\n    }\n\n    nautilus_file_updated_deep_count_in_progress (file);\n\n    if (done)\n    {\n        nautilus_file_changed (file);\n        async_job_end (directory, \"deep count\");\n        nautilus_directory_async_state_changed (directory);\n    }\n}\n\nstatic void\ndeep_count_more_files_callback (GObject      *source_object,\n                                GAsyncResult *res,\n                                gpointer      user_data)\n{\n    DeepCountState *state;\n    NautilusDirectory *directory;\n    GList *files, *l;\n    GFileInfo *info;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        deep_count_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    g_assert (directory->details->deep_count_in_progress != NULL);\n    g_assert (directory->details->deep_count_in_progress == state);\n\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, NULL);\n\n    for (l = files; l != NULL; l = l->next)\n    {\n        info = l->data;\n        deep_count_one (state, info);\n        g_object_unref (info);\n    }\n\n    if (files == NULL)\n    {\n        g_file_enumerator_close_async (state->enumerator, 0, NULL, NULL, NULL);\n        g_object_unref (state->enumerator);\n        state->enumerator = NULL;\n\n        deep_count_next_dir (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_LOW,\n                                            state->cancellable,\n                                            deep_count_more_files_callback,\n                                            state);\n    }\n\n    g_list_free (files);\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\ndeep_count_callback (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    DeepCountState *state;\n    GFileEnumerator *enumerator;\n    NautilusFile *file;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        deep_count_state_free (state);\n        return;\n    }\n\n    file = state->directory->details->deep_count_file;\n\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object), res, NULL);\n\n    if (enumerator == NULL)\n    {\n        file->details->deep_unreadable_count += 1;\n\n        deep_count_next_dir (state);\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_LOW,\n                                            state->cancellable,\n                                            deep_count_more_files_callback,\n                                            state);\n    }\n}\n\n\nstatic void\ndeep_count_load (DeepCountState *state,\n                 GFile          *location)\n{\n    state->deep_count_location = g_object_ref (location);\n\n#ifdef DEBUG_LOAD_DIRECTORY\n    g_message (\"load_directory called to get deep file count for %p\", location);\n#endif\n    g_file_enumerate_children_async (state->deep_count_location,\n                                     G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_SIZE \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP \",\"\n                                     G_FILE_ATTRIBUTE_ID_FILESYSTEM \",\"\n                                     G_FILE_ATTRIBUTE_UNIX_INODE,\n                                     G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,     /* flags */\n                                     G_PRIORITY_LOW,     /* prio */\n                                     state->cancellable,\n                                     deep_count_callback,\n                                     state);\n}\n\nstatic void\ndeep_count_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        file = directory->details->deep_count_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_deep_count,\n                          REQUEST_DEEP_COUNT))\n            {\n                return;\n            }\n        }\n\n        /* The count is not wanted, so stop it. */\n        deep_count_cancel (directory);\n    }\n}\n\nstatic void\ndeep_count_got_info (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    GFileInfo *info;\n    const char *id;\n    GFile *file = (GFile *) source_object;\n    DeepCountState *state = (DeepCountState *) user_data;\n\n    info = g_file_query_info_finish (file, res, NULL);\n    if (info != NULL)\n    {\n        id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);\n        state->fs_id = g_strdup (id);\n        g_object_unref (info);\n    }\n    deep_count_load (state, file);\n}\n\nstatic void\ndeep_count_start (NautilusDirectory *directory,\n                  NautilusFile      *file,\n                  gboolean          *doing_io)\n{\n    GFile *location;\n    DeepCountState *state;\n\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_deep_count,\n                   REQUEST_DEEP_COUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"deep count\"))\n    {\n        return;\n    }\n\n    /* Start counting. */\n    file->details->deep_counts_status = NAUTILUS_REQUEST_IN_PROGRESS;\n    file->details->deep_directory_count = 0;\n    file->details->deep_file_count = 0;\n    file->details->deep_unreadable_count = 0;\n    file->details->deep_size = 0;\n    directory->details->deep_count_file = file;\n\n    state = g_new0 (DeepCountState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->seen_deep_count_inodes = g_array_new (FALSE, TRUE, sizeof (guint64));\n    state->fs_id = NULL;\n\n    directory->details->deep_count_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n    g_file_query_info_async (location,\n                             G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                             G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                             G_PRIORITY_DEFAULT,\n                             NULL,\n                             deep_count_got_info,\n                             state);\n    g_object_unref (location);\n}\n\nstatic void\nmime_list_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->mime_list_in_progress != NULL)\n    {\n        file = directory->details->mime_list_in_progress->mime_list_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          should_get_mime_list,\n                          REQUEST_MIME_LIST))\n            {\n                return;\n            }\n        }\n\n        /* The count is not wanted, so stop it. */\n        mime_list_cancel (directory);\n    }\n}\n\nstatic void\nmime_list_state_free (MimeListState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n    g_object_unref (state->cancellable);\n    istr_set_destroy (state->mime_list_hash);\n    nautilus_directory_unref (state->directory);\n    g_free (state);\n}\n\n\nstatic void\nmime_list_done (MimeListState *state,\n                gboolean       success)\n{\n    NautilusFile *file;\n    NautilusDirectory *directory;\n\n    directory = state->directory;\n    g_assert (directory != NULL);\n\n    file = state->mime_list_file;\n\n    file->details->mime_list_is_up_to_date = TRUE;\n    g_list_free_full (file->details->mime_list, g_free);\n    if (success)\n    {\n        file->details->mime_list_failed = TRUE;\n        file->details->mime_list = NULL;\n    }\n    else\n    {\n        file->details->got_mime_list = TRUE;\n        file->details->mime_list = istr_set_get_as_list (state->mime_list_hash);\n    }\n    directory->details->mime_list_in_progress = NULL;\n\n    /* Send file-changed even if getting the item type list\n     * failed, so interested parties can distinguish between\n     * unknowable and not-yet-known cases.\n     */\n    nautilus_file_changed (file);\n\n    /* Start up the next one. */\n    async_job_end (directory, \"MIME list\");\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\nmime_list_one (MimeListState *state,\n               GFileInfo     *info)\n{\n    const char *mime_type;\n\n    if (should_skip_file (NULL, info))\n    {\n        g_object_unref (info);\n        return;\n    }\n\n    mime_type = g_file_info_get_content_type (info);\n    if (mime_type != NULL)\n    {\n        istr_set_insert (state->mime_list_hash, mime_type);\n    }\n}\n\nstatic void\nmime_list_callback (GObject      *source_object,\n                    GAsyncResult *res,\n                    gpointer      user_data)\n{\n    MimeListState *state;\n    NautilusDirectory *directory;\n    GError *error;\n    GList *files, *l;\n    GFileInfo *info;\n\n    state = user_data;\n    directory = state->directory;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n        directory->details->mime_list_in_progress = NULL;\n\n        async_job_end (directory, \"MIME list\");\n        nautilus_directory_async_state_changed (directory);\n\n        mime_list_state_free (state);\n\n        return;\n    }\n\n    g_assert (directory->details->mime_list_in_progress != NULL);\n    g_assert (directory->details->mime_list_in_progress == state);\n\n    error = NULL;\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, &error);\n\n    for (l = files; l != NULL; l = l->next)\n    {\n        info = l->data;\n        mime_list_one (state, info);\n        g_object_unref (info);\n    }\n\n    if (files == NULL)\n    {\n        mime_list_done (state, error != NULL);\n        mime_list_state_free (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            mime_list_callback,\n                                            state);\n    }\n\n    g_list_free (files);\n\n    if (error)\n    {\n        g_error_free (error);\n    }\n}\n\nstatic void\nlist_mime_enum_callback (GObject      *source_object,\n                         GAsyncResult *res,\n                         gpointer      user_data)\n{\n    MimeListState *state;\n    GFileEnumerator *enumerator;\n    NautilusDirectory *directory;\n    GError *error;\n\n    state = user_data;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n        directory = state->directory;\n        directory->details->mime_list_in_progress = NULL;\n\n        async_job_end (directory, \"MIME list\");\n        nautilus_directory_async_state_changed (directory);\n\n        mime_list_state_free (state);\n\n        return;\n    }\n\n    error = NULL;\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),\n                                                   res, &error);\n\n    if (enumerator == NULL)\n    {\n        mime_list_done (state, FALSE);\n        g_error_free (error);\n        mime_list_state_free (state);\n        return;\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            mime_list_callback,\n                                            state);\n    }\n}\n\nstatic void\nmime_list_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    MimeListState *state;\n    GFile *location;\n\n    mime_list_stop (directory);\n\n    if (directory->details->mime_list_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    /* Figure out which file to get a mime list for. */\n    if (!is_needy (file,\n                   should_get_mime_list,\n                   REQUEST_MIME_LIST))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        g_list_free (file->details->mime_list);\n        file->details->mime_list_failed = FALSE;\n        file->details->got_mime_list = FALSE;\n        file->details->mime_list_is_up_to_date = TRUE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"MIME list\"))\n    {\n        return;\n    }\n\n\n    state = g_new0 (MimeListState, 1);\n    state->mime_list_file = file;\n    state->directory = nautilus_directory_ref (directory);\n    state->cancellable = g_cancellable_new ();\n    state->mime_list_hash = istr_set_new ();\n\n    directory->details->mime_list_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n#ifdef DEBUG_LOAD_DIRECTORY\n    {\n        char *uri;\n        uri = g_file_get_uri (location);\n        g_message (\"load_directory called to get MIME list of %s\", uri);\n        g_free (uri);\n    }\n#endif\n\n    g_file_enumerate_children_async (location,\n                                     G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,\n                                     0,     /* flags */\n                                     G_PRIORITY_LOW,     /* prio */\n                                     state->cancellable,\n                                     list_mime_enum_callback,\n                                     state);\n    g_object_unref (location);\n}\n\nstatic void\nget_info_state_free (GetInfoState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\nquery_info_callback (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    NautilusDirectory *directory;\n    NautilusFile *get_info_file;\n    GFileInfo *info;\n    GetInfoState *state;\n    GError *error;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        get_info_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    get_info_file = directory->details->get_info_file;\n    g_assert (NAUTILUS_IS_FILE (get_info_file));\n\n    directory->details->get_info_file = NULL;\n    directory->details->get_info_in_progress = NULL;\n\n    /* ref here because we might be removing the last ref when we\n     * mark the file gone below, but we need to keep a ref at\n     * least long enough to send the change notification.\n     */\n    nautilus_file_ref (get_info_file);\n\n    error = NULL;\n    info = g_file_query_info_finish (G_FILE (source_object), res, &error);\n\n    if (info == NULL)\n    {\n        if (error->domain == G_IO_ERROR && error->code == G_IO_ERROR_NOT_FOUND)\n        {\n            /* mark file as gone */\n            nautilus_file_mark_gone (get_info_file);\n        }\n        get_info_file->details->file_info_is_up_to_date = TRUE;\n        nautilus_file_clear_info (get_info_file);\n        get_info_file->details->get_info_failed = TRUE;\n        get_info_file->details->get_info_error = error;\n    }\n    else\n    {\n        nautilus_file_update_info (get_info_file, info);\n        g_object_unref (info);\n    }\n\n    nautilus_file_changed (get_info_file);\n    nautilus_file_unref (get_info_file);\n\n    async_job_end (directory, \"file info\");\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_directory_unref (directory);\n\n    get_info_state_free (state);\n}\n\nstatic void\nfile_info_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->get_info_in_progress != NULL)\n    {\n        file = directory->details->get_info_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file, lacks_info, REQUEST_FILE_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The info is not wanted, so stop it. */\n        file_info_cancel (directory);\n    }\n}\n\nstatic void\nfile_info_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    GetInfoState *state;\n\n    file_info_stop (directory);\n\n    if (directory->details->get_info_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file, lacks_info, REQUEST_FILE_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"file info\"))\n    {\n        return;\n    }\n\n    directory->details->get_info_file = file;\n    file->details->get_info_failed = FALSE;\n    if (file->details->get_info_error)\n    {\n        g_error_free (file->details->get_info_error);\n        file->details->get_info_error = NULL;\n    }\n\n    state = g_new (GetInfoState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n\n    directory->details->get_info_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n    g_file_query_info_async (location,\n                             NAUTILUS_FILE_DEFAULT_ATTRIBUTES,\n                             0,\n                             G_PRIORITY_DEFAULT,\n                             state->cancellable, query_info_callback, state);\n    g_object_unref (location);\n}\n\nstatic gboolean\nis_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}\n\nstatic void\nlink_info_done (NautilusDirectory *directory,\n                NautilusFile      *file,\n                const char        *uri,\n                const char        *name,\n                GIcon             *icon,\n                gboolean           is_launcher,\n                gboolean           is_foreign)\n{\n    gboolean is_trusted;\n\n    file->details->link_info_is_up_to_date = TRUE;\n\n    is_trusted = is_link_trusted (file, is_launcher);\n\n    if (is_trusted)\n    {\n        nautilus_file_set_display_name (file, name, name, TRUE);\n    }\n    else\n    {\n        nautilus_file_set_display_name (file, NULL, NULL, TRUE);\n    }\n\n    file->details->got_link_info = TRUE;\n    g_clear_object (&file->details->custom_icon);\n\n    if (uri)\n    {\n        g_free (file->details->activation_uri);\n        file->details->activation_uri = NULL;\n        file->details->got_custom_activation_uri = TRUE;\n        file->details->activation_uri = g_strdup (uri);\n    }\n    if (is_trusted && (icon != NULL))\n    {\n        file->details->custom_icon = g_object_ref (icon);\n    }\n    file->details->is_launcher = is_launcher;\n    file->details->is_foreign_link = is_foreign;\n    file->details->is_trusted_link = is_trusted;\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\nlink_info_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->link_info_read_state != NULL)\n    {\n        file = directory->details->link_info_read_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_link_info,\n                          REQUEST_LINK_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The link info is not wanted, so stop it. */\n        link_info_cancel (directory);\n    }\n}\n\nstatic void\nlink_info_got_data (NautilusDirectory *directory,\n                    NautilusFile      *file,\n                    gboolean           result,\n                    goffset            bytes_read,\n                    char              *file_contents)\n{\n    char *link_uri, *uri, *name;\n    GIcon *icon;\n    gboolean is_launcher;\n    gboolean is_foreign;\n\n    nautilus_directory_ref (directory);\n\n    uri = NULL;\n    name = NULL;\n    icon = NULL;\n    is_launcher = FALSE;\n    is_foreign = FALSE;\n\n    /* Handle the case where we read the Nautilus link. */\n    if (result)\n    {\n        link_uri = nautilus_file_get_uri (file);\n        nautilus_link_get_link_info_given_file_contents (file_contents, bytes_read, link_uri,\n                                                         &uri, &name, &icon, &is_launcher, &is_foreign);\n        g_free (link_uri);\n    }\n    else\n    {\n        /* FIXME bugzilla.gnome.org 42433: We should report this error to the user. */\n    }\n\n    nautilus_file_ref (file);\n    link_info_done (directory, file, uri, name, icon, is_launcher, is_foreign);\n    nautilus_file_changed (file);\n    nautilus_file_unref (file);\n\n    g_free (uri);\n    g_free (name);\n\n    if (icon != NULL)\n    {\n        g_object_unref (icon);\n    }\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nlink_info_read_state_free (LinkInfoReadState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\nlink_info_nautilus_link_read_callback (GObject      *source_object,\n                                       GAsyncResult *res,\n                                       gpointer      user_data)\n{\n    LinkInfoReadState *state;\n    gsize file_size;\n    char *file_contents;\n    gboolean result;\n    NautilusDirectory *directory;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        link_info_read_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    result = g_file_load_contents_finish (G_FILE (source_object),\n                                          res,\n                                          &file_contents, &file_size,\n                                          NULL, NULL);\n\n    state->directory->details->link_info_read_state = NULL;\n    async_job_end (state->directory, \"link info\");\n\n    link_info_got_data (state->directory, state->file, result, file_size, file_contents);\n\n    if (result)\n    {\n        g_free (file_contents);\n    }\n\n    link_info_read_state_free (state);\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nlink_info_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    gboolean nautilus_style_link;\n    LinkInfoReadState *state;\n\n    if (directory->details->link_info_read_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_link_info,\n                   REQUEST_LINK_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    /* Figure out if it is a link. */\n    nautilus_style_link = nautilus_file_is_nautilus_link (file);\n    location = nautilus_file_get_location (file);\n\n    /* If it's not a link we are done. If it is, we need to read it. */\n    if (!nautilus_style_link)\n    {\n        link_info_done (directory, file, NULL, NULL, NULL, FALSE, FALSE);\n    }\n    else\n    {\n        if (!async_job_start (directory, \"link info\"))\n        {\n            g_object_unref (location);\n            return;\n        }\n\n        state = g_new0 (LinkInfoReadState, 1);\n        state->directory = directory;\n        state->file = file;\n        state->cancellable = g_cancellable_new ();\n\n        directory->details->link_info_read_state = state;\n\n        g_file_load_contents_async (location,\n                                    state->cancellable,\n                                    link_info_nautilus_link_read_callback,\n                                    state);\n    }\n    g_object_unref (location);\n}\n\nstatic void\nthumbnail_done (NautilusDirectory *directory,\n                NautilusFile      *file,\n                GdkPixbuf         *pixbuf,\n                gboolean           tried_original)\n{\n    const char *thumb_mtime_str;\n    time_t thumb_mtime = 0;\n\n    file->details->thumbnail_is_up_to_date = TRUE;\n    file->details->thumbnail_tried_original = tried_original;\n    if (file->details->thumbnail)\n    {\n        g_object_unref (file->details->thumbnail);\n        file->details->thumbnail = NULL;\n    }\n    if (file->details->scaled_thumbnail)\n    {\n        g_object_unref (file->details->scaled_thumbnail);\n        file->details->scaled_thumbnail = NULL;\n    }\n\n    if (pixbuf)\n    {\n        if (tried_original)\n        {\n            thumb_mtime = file->details->mtime;\n        }\n        else\n        {\n            thumb_mtime_str = gdk_pixbuf_get_option (pixbuf, \"tEXt::Thumb::MTime\");\n            if (thumb_mtime_str)\n            {\n                thumb_mtime = atol (thumb_mtime_str);\n            }\n        }\n\n        if (thumb_mtime == 0 ||\n            thumb_mtime == file->details->mtime)\n        {\n            file->details->thumbnail = g_object_ref (pixbuf);\n            file->details->thumbnail_mtime = thumb_mtime;\n        }\n        else\n        {\n            g_free (file->details->thumbnail_path);\n            file->details->thumbnail_path = NULL;\n        }\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\nthumbnail_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->thumbnail_state != NULL)\n    {\n        file = directory->details->thumbnail_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_thumbnail,\n                          REQUEST_THUMBNAIL))\n            {\n                return;\n            }\n        }\n\n        /* The link info is not wanted, so stop it. */\n        thumbnail_cancel (directory);\n    }\n}\n\nstatic void\nthumbnail_got_pixbuf (NautilusDirectory *directory,\n                      NautilusFile      *file,\n                      GdkPixbuf         *pixbuf,\n                      gboolean           tried_original)\n{\n    nautilus_directory_ref (directory);\n\n    nautilus_file_ref (file);\n    thumbnail_done (directory, file, pixbuf, tried_original);\n    nautilus_file_changed (file);\n    nautilus_file_unref (file);\n\n    if (pixbuf)\n    {\n        g_object_unref (pixbuf);\n    }\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nthumbnail_state_free (ThumbnailState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nextern int cached_thumbnail_size;\n\n/* scale very large images down to the max. size we need */\nstatic void\nthumbnail_loader_size_prepared (GdkPixbufLoader *loader,\n                                int              width,\n                                int              height,\n                                gpointer         user_data)\n{\n    int max_thumbnail_size;\n    double aspect_ratio;\n\n    aspect_ratio = ((double) width) / height;\n\n    /* cf. nautilus_file_get_icon() */\n    max_thumbnail_size = NAUTILUS_CANVAS_ICON_SIZE_LARGER * cached_thumbnail_size / NAUTILUS_CANVAS_ICON_SIZE_SMALL;\n    if (MAX (width, height) > max_thumbnail_size)\n    {\n        if (width > height)\n        {\n            width = max_thumbnail_size;\n            height = width / aspect_ratio;\n        }\n        else\n        {\n            height = max_thumbnail_size;\n            width = height * aspect_ratio;\n        }\n\n        gdk_pixbuf_loader_set_size (loader, width, height);\n    }\n}\n\nstatic GdkPixbuf *\nget_pixbuf_for_content (goffset  file_len,\n                        char    *file_contents)\n{\n    gboolean res;\n    GdkPixbuf *pixbuf, *pixbuf2;\n    GdkPixbufLoader *loader;\n    gsize chunk_len;\n    pixbuf = NULL;\n\n    loader = gdk_pixbuf_loader_new ();\n    g_signal_connect (loader, \"size-prepared\",\n                      G_CALLBACK (thumbnail_loader_size_prepared),\n                      NULL);\n\n    /* For some reason we have to write in chunks, or gdk-pixbuf fails */\n    res = TRUE;\n    while (res && file_len > 0)\n    {\n        chunk_len = file_len;\n        res = gdk_pixbuf_loader_write (loader, (guchar *) file_contents, chunk_len, NULL);\n        file_contents += chunk_len;\n        file_len -= chunk_len;\n    }\n    if (res)\n    {\n        res = gdk_pixbuf_loader_close (loader, NULL);\n    }\n    if (res)\n    {\n        pixbuf = g_object_ref (gdk_pixbuf_loader_get_pixbuf (loader));\n    }\n    g_object_unref (G_OBJECT (loader));\n\n    if (pixbuf)\n    {\n        pixbuf2 = gdk_pixbuf_apply_embedded_orientation (pixbuf);\n        g_object_unref (pixbuf);\n        pixbuf = pixbuf2;\n    }\n    return pixbuf;\n}\n\n\nstatic void\nthumbnail_read_callback (GObject      *source_object,\n                         GAsyncResult *res,\n                         gpointer      user_data)\n{\n    ThumbnailState *state;\n    gsize file_size;\n    char *file_contents;\n    gboolean result;\n    NautilusDirectory *directory;\n    GdkPixbuf *pixbuf;\n    GFile *location;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        thumbnail_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    result = g_file_load_contents_finish (G_FILE (source_object),\n                                          res,\n                                          &file_contents, &file_size,\n                                          NULL, NULL);\n\n    pixbuf = NULL;\n    if (result)\n    {\n        pixbuf = get_pixbuf_for_content (file_size, file_contents);\n        g_free (file_contents);\n    }\n\n    if (pixbuf == NULL && state->trying_original)\n    {\n        state->trying_original = FALSE;\n\n        location = g_file_new_for_path (state->file->details->thumbnail_path);\n        g_file_load_contents_async (location,\n                                    state->cancellable,\n                                    thumbnail_read_callback,\n                                    state);\n        g_object_unref (location);\n    }\n    else\n    {\n        state->directory->details->thumbnail_state = NULL;\n        async_job_end (state->directory, \"thumbnail\");\n\n        thumbnail_got_pixbuf (state->directory, state->file, pixbuf, state->tried_original);\n\n        thumbnail_state_free (state);\n    }\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nthumbnail_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    ThumbnailState *state;\n\n    if (directory->details->thumbnail_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_thumbnail,\n                   REQUEST_THUMBNAIL))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"thumbnail\"))\n    {\n        return;\n    }\n\n    state = g_new0 (ThumbnailState, 1);\n    state->directory = directory;\n    state->file = file;\n    state->cancellable = g_cancellable_new ();\n\n    if (file->details->thumbnail_wants_original)\n    {\n        state->tried_original = TRUE;\n        state->trying_original = TRUE;\n        location = nautilus_file_get_location (file);\n    }\n    else\n    {\n        location = g_file_new_for_path (file->details->thumbnail_path);\n    }\n\n    directory->details->thumbnail_state = state;\n\n    g_file_load_contents_async (location,\n                                state->cancellable,\n                                thumbnail_read_callback,\n                                state);\n    g_object_unref (location);\n}\n\nstatic void\nmount_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->mount_state != NULL)\n    {\n        file = directory->details->mount_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_mount,\n                          REQUEST_MOUNT))\n            {\n                return;\n            }\n        }\n\n        /* The link info is not wanted, so stop it. */\n        mount_cancel (directory);\n    }\n}\n\nstatic void\nmount_state_free (MountState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\ngot_mount (MountState *state,\n           GMount     *mount)\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n\n    directory = nautilus_directory_ref (state->directory);\n\n    state->directory->details->mount_state = NULL;\n    async_job_end (state->directory, \"mount\");\n\n    file = nautilus_file_ref (state->file);\n\n    file->details->mount_is_up_to_date = TRUE;\n    nautilus_file_set_mount (file, mount);\n\n    nautilus_directory_async_state_changed (directory);\n    nautilus_file_changed (file);\n\n    nautilus_file_unref (file);\n\n    nautilus_directory_unref (directory);\n\n    mount_state_free (state);\n}\n\nstatic void\nfind_enclosing_mount_callback (GObject      *source_object,\n                               GAsyncResult *res,\n                               gpointer      user_data)\n{\n    GMount *mount;\n    MountState *state;\n    GFile *location, *root;\n\n    state = user_data;\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        mount_state_free (state);\n        return;\n    }\n\n    mount = g_file_find_enclosing_mount_finish (G_FILE (source_object),\n                                                res, NULL);\n\n    if (mount)\n    {\n        root = g_mount_get_root (mount);\n        location = nautilus_file_get_location (state->file);\n        if (!g_file_equal (location, root))\n        {\n            g_object_unref (mount);\n            mount = NULL;\n        }\n        g_object_unref (root);\n        g_object_unref (location);\n    }\n\n    got_mount (state, mount);\n\n    if (mount)\n    {\n        g_object_unref (mount);\n    }\n}\n\nstatic GMount *\nget_mount_at (GFile *target)\n{\n    GVolumeMonitor *monitor;\n    GFile *root;\n    GList *mounts, *l;\n    GMount *found;\n\n    monitor = g_volume_monitor_get ();\n    mounts = g_volume_monitor_get_mounts (monitor);\n\n    found = NULL;\n    for (l = mounts; l != NULL; l = l->next)\n    {\n        GMount *mount = G_MOUNT (l->data);\n\n        if (g_mount_is_shadowed (mount))\n        {\n            continue;\n        }\n\n        root = g_mount_get_root (mount);\n\n        if (g_file_equal (target, root))\n        {\n            found = g_object_ref (mount);\n            break;\n        }\n\n        g_object_unref (root);\n    }\n\n    g_list_free_full (mounts, g_object_unref);\n\n    g_object_unref (monitor);\n\n    return found;\n}\n\nstatic void\nmount_start (NautilusDirectory *directory,\n             NautilusFile      *file,\n             gboolean          *doing_io)\n{\n    GFile *location;\n    MountState *state;\n\n    if (directory->details->mount_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_mount,\n                   REQUEST_MOUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"mount\"))\n    {\n        return;\n    }\n\n    state = g_new0 (MountState, 1);\n    state->directory = directory;\n    state->file = file;\n    state->cancellable = g_cancellable_new ();\n\n    location = nautilus_file_get_location (file);\n\n    directory->details->mount_state = state;\n\n    if (file->details->type == G_FILE_TYPE_MOUNTABLE)\n    {\n        GFile *target;\n        GMount *mount;\n\n        mount = NULL;\n        target = nautilus_file_get_activation_location (file);\n        if (target != NULL)\n        {\n            mount = get_mount_at (target);\n            g_object_unref (target);\n        }\n\n        got_mount (state, mount);\n\n        if (mount)\n        {\n            g_object_unref (mount);\n        }\n    }\n    else\n    {\n        g_file_find_enclosing_mount_async (location,\n                                           G_PRIORITY_DEFAULT,\n                                           state->cancellable,\n                                           find_enclosing_mount_callback,\n                                           state);\n    }\n    g_object_unref (location);\n}\n\nstatic void\nfilesystem_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->filesystem_info_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->filesystem_info_state->cancellable);\n        directory->details->filesystem_info_state->directory = NULL;\n        directory->details->filesystem_info_state = NULL;\n        async_job_end (directory, \"filesystem info\");\n    }\n}\n\nstatic void\nfilesystem_info_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->filesystem_info_state != NULL)\n    {\n        file = directory->details->filesystem_info_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_filesystem_info,\n                          REQUEST_FILESYSTEM_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The filesystem info is not wanted, so stop it. */\n        filesystem_info_cancel (directory);\n    }\n}\n\nstatic void\nfilesystem_info_state_free (FilesystemInfoState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\ngot_filesystem_info (FilesystemInfoState *state,\n                     GFileInfo           *info)\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n    const char *filesystem_type;\n\n    /* careful here, info may be NULL */\n\n    directory = nautilus_directory_ref (state->directory);\n\n    state->directory->details->filesystem_info_state = NULL;\n    async_job_end (state->directory, \"filesystem info\");\n\n    file = nautilus_file_ref (state->file);\n\n    file->details->filesystem_info_is_up_to_date = TRUE;\n    if (info != NULL)\n    {\n        file->details->filesystem_use_preview =\n            g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW);\n        file->details->filesystem_readonly =\n            g_file_info_get_attribute_boolean (info, G_FILE_ATTRIBUTE_FILESYSTEM_READONLY);\n        filesystem_type = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE);\n        if (g_strcmp0 (eel_ref_str_peek (file->details->filesystem_type), filesystem_type) != 0)\n        {\n            eel_ref_str_unref (file->details->filesystem_type);\n            file->details->filesystem_type = eel_ref_str_get_unique (filesystem_type);\n        }\n    }\n\n    nautilus_directory_async_state_changed (directory);\n    nautilus_file_changed (file);\n\n    nautilus_file_unref (file);\n\n    nautilus_directory_unref (directory);\n\n    filesystem_info_state_free (state);\n}\n\nstatic void\nquery_filesystem_info_callback (GObject      *source_object,\n                                GAsyncResult *res,\n                                gpointer      user_data)\n{\n    GFileInfo *info;\n    FilesystemInfoState *state;\n\n    state = user_data;\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        filesystem_info_state_free (state);\n        return;\n    }\n\n    info = g_file_query_filesystem_info_finish (G_FILE (source_object), res, NULL);\n\n    got_filesystem_info (state, info);\n\n    if (info != NULL)\n    {\n        g_object_unref (info);\n    }\n}\n\nstatic void\nfilesystem_info_start (NautilusDirectory *directory,\n                       NautilusFile      *file,\n                       gboolean          *doing_io)\n{\n    GFile *location;\n    FilesystemInfoState *state;\n\n    if (directory->details->filesystem_info_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_filesystem_info,\n                   REQUEST_FILESYSTEM_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"filesystem info\"))\n    {\n        return;\n    }\n\n    state = g_new0 (FilesystemInfoState, 1);\n    state->directory = directory;\n    state->file = file;\n    state->cancellable = g_cancellable_new ();\n\n    location = nautilus_file_get_location (file);\n\n    directory->details->filesystem_info_state = state;\n\n    g_file_query_filesystem_info_async (location,\n                                        G_FILE_ATTRIBUTE_FILESYSTEM_READONLY \",\"\n                                        G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW \",\"\n                                        G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,\n                                        G_PRIORITY_DEFAULT,\n                                        state->cancellable,\n                                        query_filesystem_info_callback,\n                                        state);\n    g_object_unref (location);\n}\n\nstatic void\nextension_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->extension_info_in_progress != NULL)\n    {\n        if (directory->details->extension_info_idle)\n        {\n            g_source_remove (directory->details->extension_info_idle);\n        }\n        else\n        {\n            nautilus_info_provider_cancel_update\n                (directory->details->extension_info_provider,\n                directory->details->extension_info_in_progress);\n        }\n\n        directory->details->extension_info_in_progress = NULL;\n        directory->details->extension_info_file = NULL;\n        directory->details->extension_info_provider = NULL;\n        directory->details->extension_info_idle = 0;\n\n        async_job_end (directory, \"extension info\");\n    }\n}\n\nstatic void\nextension_info_stop (NautilusDirectory *directory)\n{\n    if (directory->details->extension_info_in_progress != NULL)\n    {\n        NautilusFile *file;\n\n        file = directory->details->extension_info_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file, lacks_extension_info, REQUEST_EXTENSION_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The info is not wanted, so stop it. */\n        extension_info_cancel (directory);\n    }\n}\n\nstatic void\nfinish_info_provider (NautilusDirectory    *directory,\n                      NautilusFile         *file,\n                      NautilusInfoProvider *provider)\n{\n    file->details->pending_info_providers =\n        g_list_remove (file->details->pending_info_providers,\n                       provider);\n    g_object_unref (provider);\n\n    nautilus_directory_async_state_changed (directory);\n\n    if (file->details->pending_info_providers == NULL)\n    {\n        nautilus_file_info_providers_done (file);\n    }\n}\n\n\nstatic gboolean\ninfo_provider_idle_callback (gpointer user_data)\n{\n    InfoProviderResponse *response;\n    NautilusDirectory *directory;\n\n    response = user_data;\n    directory = response->directory;\n\n    if (response->handle != directory->details->extension_info_in_progress\n        || response->provider != directory->details->extension_info_provider)\n    {\n        g_warning (\"Unexpected plugin response.  This probably indicates a bug in a Nautilus extension: handle=%p\", response->handle);\n    }\n    else\n    {\n        NautilusFile *file;\n        async_job_end (directory, \"extension info\");\n\n        file = directory->details->extension_info_file;\n\n        directory->details->extension_info_file = NULL;\n        directory->details->extension_info_provider = NULL;\n        directory->details->extension_info_in_progress = NULL;\n        directory->details->extension_info_idle = 0;\n\n        finish_info_provider (directory, file, response->provider);\n    }\n\n    return FALSE;\n}\n\nstatic void\ninfo_provider_callback (NautilusInfoProvider    *provider,\n                        NautilusOperationHandle *handle,\n                        NautilusOperationResult  result,\n                        gpointer                 user_data)\n{\n    InfoProviderResponse *response;\n\n    response = g_new0 (InfoProviderResponse, 1);\n    response->provider = provider;\n    response->handle = handle;\n    response->result = result;\n    response->directory = NAUTILUS_DIRECTORY (user_data);\n\n    response->directory->details->extension_info_idle =\n        g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,\n                         info_provider_idle_callback, response,\n                         g_free);\n}\n\nstatic void\nextension_info_start (NautilusDirectory *directory,\n                      NautilusFile      *file,\n                      gboolean          *doing_io)\n{\n    NautilusInfoProvider *provider;\n    NautilusOperationResult result;\n    NautilusOperationHandle *handle;\n    GClosure *update_complete;\n\n    if (directory->details->extension_info_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file, lacks_extension_info, REQUEST_EXTENSION_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"extension info\"))\n    {\n        return;\n    }\n\n    provider = file->details->pending_info_providers->data;\n\n    update_complete = g_cclosure_new (G_CALLBACK (info_provider_callback),\n                                      directory,\n                                      NULL);\n    g_closure_set_marshal (update_complete,\n                           g_cclosure_marshal_generic);\n\n    result = nautilus_info_provider_update_file_info\n                 (provider,\n                 NAUTILUS_FILE_INFO (file),\n                 update_complete,\n                 &handle);\n\n    g_closure_unref (update_complete);\n\n    if (result == NAUTILUS_OPERATION_COMPLETE ||\n        result == NAUTILUS_OPERATION_FAILED)\n    {\n        finish_info_provider (directory, file, provider);\n        async_job_end (directory, \"extension info\");\n    }\n    else\n    {\n        directory->details->extension_info_in_progress = handle;\n        directory->details->extension_info_provider = provider;\n        directory->details->extension_info_file = file;\n    }\n}\n\nstatic void\nstart_or_stop_io (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n    gboolean doing_io;\n\n    /* Start or stop reading files. */\n    file_list_start_or_stop (directory);\n\n    /* Stop any no longer wanted attribute fetches. */\n    file_info_stop (directory);\n    directory_count_stop (directory);\n    deep_count_stop (directory);\n    mime_list_stop (directory);\n    link_info_stop (directory);\n    extension_info_stop (directory);\n    mount_stop (directory);\n    thumbnail_stop (directory);\n    filesystem_info_stop (directory);\n\n    doing_io = FALSE;\n    /* Take files that are all done off the queue. */\n    while (!nautilus_file_queue_is_empty (directory->details->high_priority_queue))\n    {\n        file = nautilus_file_queue_head (directory->details->high_priority_queue);\n\n        /* Start getting attributes if possible */\n        file_info_start (directory, file, &doing_io);\n        link_info_start (directory, file, &doing_io);\n\n        if (doing_io)\n        {\n            return;\n        }\n\n        move_file_to_low_priority_queue (directory, file);\n    }\n\n    /* High priority queue must be empty */\n    while (!nautilus_file_queue_is_empty (directory->details->low_priority_queue))\n    {\n        file = nautilus_file_queue_head (directory->details->low_priority_queue);\n\n        /* Start getting attributes if possible */\n        mount_start (directory, file, &doing_io);\n        directory_count_start (directory, file, &doing_io);\n        deep_count_start (directory, file, &doing_io);\n        mime_list_start (directory, file, &doing_io);\n        thumbnail_start (directory, file, &doing_io);\n        filesystem_info_start (directory, file, &doing_io);\n\n        if (doing_io)\n        {\n            return;\n        }\n\n        move_file_to_extension_queue (directory, file);\n    }\n\n    /* Low priority queue must be empty */\n    while (!nautilus_file_queue_is_empty (directory->details->extension_queue))\n    {\n        file = nautilus_file_queue_head (directory->details->extension_queue);\n\n        /* Start getting attributes if possible */\n        extension_info_start (directory, file, &doing_io);\n        if (doing_io)\n        {\n            return;\n        }\n\n        nautilus_directory_remove_file_from_work_queue (directory, file);\n    }\n}\n\n/* Call this when the monitor or call when ready list changes,\n * or when some I/O is completed.\n */\nvoid\nnautilus_directory_async_state_changed (NautilusDirectory *directory)\n{\n    /* Check if any callbacks are satisfied and call them if they\n     * are. Do this last so that any changes done in start or stop\n     * I/O functions immediately (not in callbacks) are taken into\n     * consideration. If any callbacks are called, consider the\n     * I/O state again so that we can release or cancel I/O that\n     * is not longer needed once the callbacks are satisfied.\n     */\n\n    if (directory->details->in_async_service_loop)\n    {\n        directory->details->state_changed = TRUE;\n        return;\n    }\n    directory->details->in_async_service_loop = TRUE;\n    nautilus_directory_ref (directory);\n    do\n    {\n        directory->details->state_changed = FALSE;\n        start_or_stop_io (directory);\n        if (call_ready_callbacks (directory))\n        {\n            directory->details->state_changed = TRUE;\n        }\n    }\n    while (directory->details->state_changed);\n    directory->details->in_async_service_loop = FALSE;\n    nautilus_directory_unref (directory);\n\n    /* Check if any directories should wake up. */\n    async_job_wake_up ();\n}\n\nvoid\nnautilus_directory_cancel (NautilusDirectory *directory)\n{\n    /* Arbitrary order (kept alphabetical). */\n    deep_count_cancel (directory);\n    directory_count_cancel (directory);\n    file_info_cancel (directory);\n    file_list_cancel (directory);\n    link_info_cancel (directory);\n    mime_list_cancel (directory);\n    new_files_cancel (directory);\n    extension_info_cancel (directory);\n    thumbnail_cancel (directory);\n    mount_cancel (directory);\n    filesystem_info_cancel (directory);\n\n    /* We aren't waiting for anything any more. */\n    if (waiting_directories != NULL)\n    {\n        g_hash_table_remove (waiting_directories, directory);\n    }\n\n    /* Check if any directories should wake up. */\n    async_job_wake_up ();\n}\n\nstatic void\ncancel_directory_count_for_file (NautilusDirectory *directory,\n                                 NautilusFile      *file)\n{\n    if (directory->details->count_in_progress != NULL &&\n        directory->details->count_in_progress->count_file == file)\n    {\n        directory_count_cancel (directory);\n    }\n}\n\nstatic void\ncancel_deep_counts_for_file (NautilusDirectory *directory,\n                             NautilusFile      *file)\n{\n    if (directory->details->deep_count_file == file)\n    {\n        deep_count_cancel (directory);\n    }\n}\n\nstatic void\ncancel_mime_list_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->mime_list_in_progress != NULL &&\n        directory->details->mime_list_in_progress->mime_list_file == file)\n    {\n        mime_list_cancel (directory);\n    }\n}\n\nstatic void\ncancel_file_info_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->get_info_file == file)\n    {\n        file_info_cancel (directory);\n    }\n}\n\nstatic void\ncancel_thumbnail_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->thumbnail_state != NULL &&\n        directory->details->thumbnail_state->file == file)\n    {\n        thumbnail_cancel (directory);\n    }\n}\n\nstatic void\ncancel_mount_for_file (NautilusDirectory *directory,\n                       NautilusFile      *file)\n{\n    if (directory->details->mount_state != NULL &&\n        directory->details->mount_state->file == file)\n    {\n        mount_cancel (directory);\n    }\n}\n\nstatic void\ncancel_filesystem_info_for_file (NautilusDirectory *directory,\n                                 NautilusFile      *file)\n{\n    if (directory->details->filesystem_info_state != NULL &&\n        directory->details->filesystem_info_state->file == file)\n    {\n        filesystem_info_cancel (directory);\n    }\n}\n\nstatic void\ncancel_link_info_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->link_info_read_state != NULL &&\n        directory->details->link_info_read_state->file == file)\n    {\n        link_info_cancel (directory);\n    }\n}\n\n\nstatic void\ncancel_loading_attributes (NautilusDirectory      *directory,\n                           NautilusFileAttributes  file_attributes)\n{\n    Request request;\n\n    request = nautilus_directory_set_up_request (file_attributes);\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))\n    {\n        directory_count_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))\n    {\n        deep_count_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))\n    {\n        mime_list_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))\n    {\n        file_info_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))\n    {\n        filesystem_info_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))\n    {\n        link_info_cancel (directory);\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_EXTENSION_INFO))\n    {\n        extension_info_cancel (directory);\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))\n    {\n        thumbnail_cancel (directory);\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))\n    {\n        mount_cancel (directory);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nvoid\nnautilus_directory_cancel_loading_file_attributes (NautilusDirectory      *directory,\n                                                   NautilusFile           *file,\n                                                   NautilusFileAttributes  file_attributes)\n{\n    Request request;\n\n    nautilus_directory_remove_file_from_work_queue (directory, file);\n\n    request = nautilus_directory_set_up_request (file_attributes);\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))\n    {\n        cancel_directory_count_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))\n    {\n        cancel_deep_counts_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))\n    {\n        cancel_mime_list_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))\n    {\n        cancel_file_info_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))\n    {\n        cancel_filesystem_info_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))\n    {\n        cancel_link_info_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))\n    {\n        cancel_thumbnail_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))\n    {\n        cancel_mount_for_file (directory, file);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nvoid\nnautilus_directory_add_file_to_work_queue (NautilusDirectory *directory,\n                                           NautilusFile      *file)\n{\n    g_return_if_fail (file->details->directory == directory);\n\n    nautilus_file_queue_enqueue (directory->details->high_priority_queue,\n                                 file);\n}\n\n\nstatic void\nadd_all_files_to_work_queue (NautilusDirectory *directory)\n{\n    GList *node;\n    NautilusFile *file;\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        file = NAUTILUS_FILE (node->data);\n\n        nautilus_directory_add_file_to_work_queue (directory, file);\n    }\n}\n\nvoid\nnautilus_directory_remove_file_from_work_queue (NautilusDirectory *directory,\n                                                NautilusFile      *file)\n{\n    nautilus_file_queue_remove (directory->details->high_priority_queue,\n                                file);\n    nautilus_file_queue_remove (directory->details->low_priority_queue,\n                                file);\n    nautilus_file_queue_remove (directory->details->extension_queue,\n                                file);\n}\n\n\nstatic void\nmove_file_to_low_priority_queue (NautilusDirectory *directory,\n                                 NautilusFile      *file)\n{\n    /* Must add before removing to avoid ref underflow */\n    nautilus_file_queue_enqueue (directory->details->low_priority_queue,\n                                 file);\n    nautilus_file_queue_remove (directory->details->high_priority_queue,\n                                file);\n}\n\nstatic void\nmove_file_to_extension_queue (NautilusDirectory *directory,\n                              NautilusFile      *file)\n{\n    /* Must add before removing to avoid ref underflow */\n    nautilus_file_queue_enqueue (directory->details->extension_queue,\n                                 file);\n    nautilus_file_queue_remove (directory->details->low_priority_queue,\n                                file);\n}\n", "/* nautilus-file-operations.c - Nautilus file operations.\n *\n *  Copyright (C) 1999, 2000 Free Software Foundation\n *  Copyright (C) 2000, 2001 Eazel, Inc.\n *  Copyright (C) 2007 Red Hat, Inc.\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public\n *  License along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n *  Authors: Alexander Larsson <alexl@redhat.com>\n *           Ettore Perazzoli <ettore@gnu.org>\n *           Pavel Cisler <pavel@eazel.com>\n */\n\n#include <config.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <math.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\n#include \"nautilus-file-operations.h\"\n\n#include \"nautilus-file-changes-queue.h\"\n#include \"nautilus-lib-self-check-functions.h\"\n\n#include \"nautilus-progress-info.h\"\n\n#include <eel/eel-glib-extensions.h>\n#include <eel/eel-gtk-extensions.h>\n#include <eel/eel-stock-dialogs.h>\n#include <eel/eel-vfs-extensions.h>\n\n#include <glib/gi18n.h>\n#include <glib/gstdio.h>\n#include <gdk/gdk.h>\n#include <gtk/gtk.h>\n#include <gio/gio.h>\n#include <glib.h>\n\n#include \"nautilus-operations-ui-manager.h\"\n#include \"nautilus-file-changes-queue.h\"\n#include \"nautilus-file-private.h\"\n#include \"nautilus-global-preferences.h\"\n#include \"nautilus-link.h\"\n#include \"nautilus-trash-monitor.h\"\n#include \"nautilus-file-utilities.h\"\n#include \"nautilus-file-undo-operations.h\"\n#include \"nautilus-file-undo-manager.h\"\n\n/* TODO: TESTING!!! */\n\ntypedef struct\n{\n    GTimer *time;\n    GtkWindow *parent_window;\n    int screen_num;\n    guint inhibit_cookie;\n    NautilusProgressInfo *progress;\n    GCancellable *cancellable;\n    GHashTable *skip_files;\n    GHashTable *skip_readdir_error;\n    NautilusFileUndoInfo *undo_info;\n    gboolean skip_all_error;\n    gboolean skip_all_conflict;\n    gboolean merge_all;\n    gboolean replace_all;\n    gboolean delete_all;\n} CommonJob;\n\ntypedef struct\n{\n    CommonJob common;\n    gboolean is_move;\n    GList *files;\n    GFile *destination;\n    GFile *desktop_location;\n    GFile *fake_display_source;\n    GdkPoint *icon_positions;\n    int n_icon_positions;\n    GHashTable *debuting_files;\n    gchar *target_name;\n    NautilusCopyCallback done_callback;\n    gpointer done_callback_data;\n} CopyMoveJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GList *files;\n    gboolean try_trash;\n    gboolean user_cancel;\n    NautilusDeleteCallback done_callback;\n    gpointer done_callback_data;\n} DeleteJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GFile *dest_dir;\n    char *filename;\n    gboolean make_dir;\n    GFile *src;\n    char *src_data;\n    int length;\n    GdkPoint position;\n    gboolean has_position;\n    GFile *created_file;\n    NautilusCreateCallback done_callback;\n    gpointer done_callback_data;\n} CreateJob;\n\n\ntypedef struct\n{\n    CommonJob common;\n    GList *trash_dirs;\n    gboolean should_confirm;\n    NautilusOpCallback done_callback;\n    gpointer done_callback_data;\n} EmptyTrashJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GFile *file;\n    gboolean interactive;\n    NautilusOpCallback done_callback;\n    gpointer done_callback_data;\n} MarkTrustedJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GFile *file;\n    NautilusOpCallback done_callback;\n    gpointer done_callback_data;\n    guint32 file_permissions;\n    guint32 file_mask;\n    guint32 dir_permissions;\n    guint32 dir_mask;\n} SetPermissionsJob;\n\ntypedef enum\n{\n    OP_KIND_COPY,\n    OP_KIND_MOVE,\n    OP_KIND_DELETE,\n    OP_KIND_TRASH,\n    OP_KIND_COMPRESS\n} OpKind;\n\ntypedef struct\n{\n    int num_files;\n    goffset num_bytes;\n    int num_files_since_progress;\n    OpKind op;\n} SourceInfo;\n\ntypedef struct\n{\n    int num_files;\n    goffset num_bytes;\n    OpKind op;\n    guint64 last_report_time;\n    int last_reported_files_left;\n} TransferInfo;\n\ntypedef struct\n{\n    CommonJob common;\n    GList *source_files;\n    GFile *destination_directory;\n    GList *output_files;\n\n    gdouble base_progress;\n\n    guint64 archive_compressed_size;\n    guint64 total_compressed_size;\n\n    NautilusExtractCallback done_callback;\n    gpointer done_callback_data;\n} ExtractJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GList *source_files;\n    GFile *output_file;\n\n    AutoarFormat format;\n    AutoarFilter filter;\n\n    guint64 total_size;\n    guint total_files;\n\n    gboolean success;\n\n    NautilusCreateCallback done_callback;\n    gpointer done_callback_data;\n} CompressJob;\n\n#define SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE 8\n#define NSEC_PER_MICROSEC 1000\n#define PROGRESS_NOTIFY_INTERVAL 100 * NSEC_PER_MICROSEC\n\n#define MAXIMUM_DISPLAYED_FILE_NAME_LENGTH 50\n\n#define IS_IO_ERROR(__error, KIND) (((__error)->domain == G_IO_ERROR && (__error)->code == G_IO_ERROR_ ## KIND))\n\n#define CANCEL _(\"_Cancel\")\n#define SKIP _(\"_Skip\")\n#define SKIP_ALL _(\"S_kip All\")\n#define RETRY _(\"_Retry\")\n#define DELETE _(\"_Delete\")\n#define DELETE_ALL _(\"Delete _All\")\n#define REPLACE _(\"_Replace\")\n#define REPLACE_ALL _(\"Replace _All\")\n#define MERGE _(\"_Merge\")\n#define MERGE_ALL _(\"Merge _All\")\n#define COPY_FORCE _(\"Copy _Anyway\")\n\nstatic void\nmark_desktop_file_trusted (CommonJob    *common,\n                           GCancellable *cancellable,\n                           GFile        *file,\n                           gboolean      interactive);\n\nstatic gboolean\nis_all_button_text (const char *button_text)\n{\n    g_assert (button_text != NULL);\n\n    return !strcmp (button_text, SKIP_ALL) ||\n           !strcmp (button_text, REPLACE_ALL) ||\n           !strcmp (button_text, DELETE_ALL) ||\n           !strcmp (button_text, MERGE_ALL);\n}\n\nstatic void scan_sources (GList      *files,\n                          SourceInfo *source_info,\n                          CommonJob  *job,\n                          OpKind      kind);\n\n\nstatic void empty_trash_thread_func (GTask        *task,\n                                     gpointer      source_object,\n                                     gpointer      task_data,\n                                     GCancellable *cancellable);\n\nstatic void empty_trash_task_done (GObject      *source_object,\n                                   GAsyncResult *res,\n                                   gpointer      user_data);\n\nstatic char *query_fs_type (GFile        *file,\n                            GCancellable *cancellable);\n\n/* keep in time with format_time()\n *\n * This counts and outputs the number of \u201ctime units\u201d\n * formatted and displayed by format_time().\n * For instance, if format_time outputs \u201c3 hours, 4 minutes\u201d\n * it yields 7.\n */\nstatic int\nseconds_count_format_time_units (int seconds)\n{\n    int minutes;\n    int hours;\n\n    if (seconds < 0)\n    {\n        /* Just to make sure... */\n        seconds = 0;\n    }\n\n    if (seconds < 60)\n    {\n        /* seconds */\n        return seconds;\n    }\n\n    if (seconds < 60 * 60)\n    {\n        /* minutes */\n        minutes = seconds / 60;\n        return minutes;\n    }\n\n    hours = seconds / (60 * 60);\n\n    if (seconds < 60 * 60 * 4)\n    {\n        /* minutes + hours */\n        minutes = (seconds - hours * 60 * 60) / 60;\n        return minutes + hours;\n    }\n\n    return hours;\n}\n\nstatic char *\nformat_time (int seconds)\n{\n    int minutes;\n    int hours;\n    char *res;\n\n    if (seconds < 0)\n    {\n        /* Just to make sure... */\n        seconds = 0;\n    }\n\n    if (seconds < 60)\n    {\n        return g_strdup_printf (ngettext (\"%'d second\", \"%'d seconds\", (int) seconds), (int) seconds);\n    }\n\n    if (seconds < 60 * 60)\n    {\n        minutes = seconds / 60;\n        return g_strdup_printf (ngettext (\"%'d minute\", \"%'d minutes\", minutes), minutes);\n    }\n\n    hours = seconds / (60 * 60);\n\n    if (seconds < 60 * 60 * 4)\n    {\n        char *h, *m;\n\n        minutes = (seconds - hours * 60 * 60) / 60;\n\n        h = g_strdup_printf (ngettext (\"%'d hour\", \"%'d hours\", hours), hours);\n        m = g_strdup_printf (ngettext (\"%'d minute\", \"%'d minutes\", minutes), minutes);\n        res = g_strconcat (h, \", \", m, NULL);\n        g_free (h);\n        g_free (m);\n        return res;\n    }\n\n    return g_strdup_printf (ngettext (\"approximately %'d hour\",\n                                      \"approximately %'d hours\",\n                                      hours), hours);\n}\n\nstatic char *\nshorten_utf8_string (const char *base,\n                     int         reduce_by_num_bytes)\n{\n    int len;\n    char *ret;\n    const char *p;\n\n    len = strlen (base);\n    len -= reduce_by_num_bytes;\n\n    if (len <= 0)\n    {\n        return NULL;\n    }\n\n    ret = g_new (char, len + 1);\n\n    p = base;\n    while (len)\n    {\n        char *next;\n        next = g_utf8_next_char (p);\n        if (next - p > len || *next == '\\0')\n        {\n            break;\n        }\n\n        len -= next - p;\n        p = next;\n    }\n\n    if (p - base == 0)\n    {\n        g_free (ret);\n        return NULL;\n    }\n    else\n    {\n        memcpy (ret, base, p - base);\n        ret[p - base] = '\\0';\n        return ret;\n    }\n}\n\n/* Note that we have these two separate functions with separate format\n * strings for ease of localization.\n */\n\nstatic char *\nget_link_name (const char *name,\n               int         count,\n               int         max_length)\n{\n    const char *format;\n    char *result;\n    int unshortened_length;\n    gboolean use_count;\n\n    g_assert (name != NULL);\n\n    if (count < 0)\n    {\n        g_warning (\"bad count in get_link_name\");\n        count = 0;\n    }\n\n    if (count <= 2)\n    {\n        /* Handle special cases for low numbers.\n         * Perhaps for some locales we will need to add more.\n         */\n        switch (count)\n        {\n            default:\n            {\n                g_assert_not_reached ();\n                /* fall through */\n            }\n\n            case 0:\n            {\n                /* duplicate original file name */\n                format = \"%s\";\n            }\n            break;\n\n            case 1:\n            {\n                /* appended to new link file */\n                format = _(\"Link to %s\");\n            }\n            break;\n\n            case 2:\n            {\n                /* appended to new link file */\n                format = _(\"Another link to %s\");\n            }\n            break;\n        }\n\n        use_count = FALSE;\n    }\n    else\n    {\n        /* Handle special cases for the first few numbers of each ten.\n         * For locales where getting this exactly right is difficult,\n         * these can just be made all the same as the general case below.\n         */\n        switch (count % 10)\n        {\n            case 1:\n            {\n                /* Localizers: Feel free to leave out the \"st\" suffix\n                 * if there's no way to do that nicely for a\n                 * particular language.\n                 */\n                format = _(\"%'dst link to %s\");\n            }\n            break;\n\n            case 2:\n            {\n                /* appended to new link file */\n                format = _(\"%'dnd link to %s\");\n            }\n            break;\n\n            case 3:\n            {\n                /* appended to new link file */\n                format = _(\"%'drd link to %s\");\n            }\n            break;\n\n            default:\n            {\n                /* appended to new link file */\n                format = _(\"%'dth link to %s\");\n            }\n            break;\n        }\n\n        use_count = TRUE;\n    }\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n    if (use_count)\n    {\n        result = g_strdup_printf (format, count, name);\n    }\n    else\n    {\n        result = g_strdup_printf (format, name);\n    }\n\n    if (max_length > 0 && (unshortened_length = strlen (result)) > max_length)\n    {\n        char *new_name;\n\n        new_name = shorten_utf8_string (name, unshortened_length - max_length);\n        if (new_name)\n        {\n            g_free (result);\n\n            if (use_count)\n            {\n                result = g_strdup_printf (format, count, new_name);\n            }\n            else\n            {\n                result = g_strdup_printf (format, new_name);\n            }\n\n            g_assert (strlen (result) <= max_length);\n            g_free (new_name);\n        }\n    }\n#pragma GCC diagnostic pop\n    return result;\n}\n\n\n/* Localizers:\n * Feel free to leave out the st, nd, rd and th suffix or\n * make some or all of them match.\n */\n\n/* localizers: tag used to detect the first copy of a file */\nstatic const char untranslated_copy_duplicate_tag[] = N_(\" (copy)\");\n/* localizers: tag used to detect the second copy of a file */\nstatic const char untranslated_another_copy_duplicate_tag[] = N_(\" (another copy)\");\n\n/* localizers: tag used to detect the x11th copy of a file */\nstatic const char untranslated_x11th_copy_duplicate_tag[] = N_(\"th copy)\");\n/* localizers: tag used to detect the x12th copy of a file */\nstatic const char untranslated_x12th_copy_duplicate_tag[] = N_(\"th copy)\");\n/* localizers: tag used to detect the x13th copy of a file */\nstatic const char untranslated_x13th_copy_duplicate_tag[] = N_(\"th copy)\");\n\n/* localizers: tag used to detect the x1st copy of a file */\nstatic const char untranslated_st_copy_duplicate_tag[] = N_(\"st copy)\");\n/* localizers: tag used to detect the x2nd copy of a file */\nstatic const char untranslated_nd_copy_duplicate_tag[] = N_(\"nd copy)\");\n/* localizers: tag used to detect the x3rd copy of a file */\nstatic const char untranslated_rd_copy_duplicate_tag[] = N_(\"rd copy)\");\n\n/* localizers: tag used to detect the xxth copy of a file */\nstatic const char untranslated_th_copy_duplicate_tag[] = N_(\"th copy)\");\n\n#define COPY_DUPLICATE_TAG _(untranslated_copy_duplicate_tag)\n#define ANOTHER_COPY_DUPLICATE_TAG _(untranslated_another_copy_duplicate_tag)\n#define X11TH_COPY_DUPLICATE_TAG _(untranslated_x11th_copy_duplicate_tag)\n#define X12TH_COPY_DUPLICATE_TAG _(untranslated_x12th_copy_duplicate_tag)\n#define X13TH_COPY_DUPLICATE_TAG _(untranslated_x13th_copy_duplicate_tag)\n\n#define ST_COPY_DUPLICATE_TAG _(untranslated_st_copy_duplicate_tag)\n#define ND_COPY_DUPLICATE_TAG _(untranslated_nd_copy_duplicate_tag)\n#define RD_COPY_DUPLICATE_TAG _(untranslated_rd_copy_duplicate_tag)\n#define TH_COPY_DUPLICATE_TAG _(untranslated_th_copy_duplicate_tag)\n\n/* localizers: appended to first file copy */\nstatic const char untranslated_first_copy_duplicate_format[] = N_(\"%s (copy)%s\");\n/* localizers: appended to second file copy */\nstatic const char untranslated_second_copy_duplicate_format[] = N_(\"%s (another copy)%s\");\n\n/* localizers: appended to x11th file copy */\nstatic const char untranslated_x11th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n/* localizers: appended to x12th file copy */\nstatic const char untranslated_x12th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n/* localizers: appended to x13th file copy */\nstatic const char untranslated_x13th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n\n/* localizers: if in your language there's no difference between 1st, 2nd, 3rd and nth\n * plurals, you can leave the st, nd, rd suffixes out and just make all the translated\n * strings look like \"%s (copy %'d)%s\".\n */\n\n/* localizers: appended to x1st file copy */\nstatic const char untranslated_st_copy_duplicate_format[] = N_(\"%s (%'dst copy)%s\");\n/* localizers: appended to x2nd file copy */\nstatic const char untranslated_nd_copy_duplicate_format[] = N_(\"%s (%'dnd copy)%s\");\n/* localizers: appended to x3rd file copy */\nstatic const char untranslated_rd_copy_duplicate_format[] = N_(\"%s (%'drd copy)%s\");\n/* localizers: appended to xxth file copy */\nstatic const char untranslated_th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n\n#define FIRST_COPY_DUPLICATE_FORMAT _(untranslated_first_copy_duplicate_format)\n#define SECOND_COPY_DUPLICATE_FORMAT _(untranslated_second_copy_duplicate_format)\n#define X11TH_COPY_DUPLICATE_FORMAT _(untranslated_x11th_copy_duplicate_format)\n#define X12TH_COPY_DUPLICATE_FORMAT _(untranslated_x12th_copy_duplicate_format)\n#define X13TH_COPY_DUPLICATE_FORMAT _(untranslated_x13th_copy_duplicate_format)\n\n#define ST_COPY_DUPLICATE_FORMAT _(untranslated_st_copy_duplicate_format)\n#define ND_COPY_DUPLICATE_FORMAT _(untranslated_nd_copy_duplicate_format)\n#define RD_COPY_DUPLICATE_FORMAT _(untranslated_rd_copy_duplicate_format)\n#define TH_COPY_DUPLICATE_FORMAT _(untranslated_th_copy_duplicate_format)\n\nstatic char *\nextract_string_until (const char *original,\n                      const char *until_substring)\n{\n    char *result;\n\n    g_assert ((int) strlen (original) >= until_substring - original);\n    g_assert (until_substring - original >= 0);\n\n    result = g_malloc (until_substring - original + 1);\n    strncpy (result, original, until_substring - original);\n    result[until_substring - original] = '\\0';\n\n    return result;\n}\n\n/* Dismantle a file name, separating the base name, the file suffix and removing any\n * (xxxcopy), etc. string. Figure out the count that corresponds to the given\n * (xxxcopy) substring.\n */\nstatic void\nparse_previous_duplicate_name (const char  *name,\n                               char       **name_base,\n                               const char **suffix,\n                               int         *count)\n{\n    const char *tag;\n\n    g_assert (name[0] != '\\0');\n\n    *suffix = eel_filename_get_extension_offset (name);\n\n    if (*suffix == NULL || (*suffix)[1] == '\\0')\n    {\n        /* no suffix */\n        *suffix = \"\";\n    }\n\n    tag = strstr (name, COPY_DUPLICATE_TAG);\n    if (tag != NULL)\n    {\n        if (tag > *suffix)\n        {\n            /* handle case \"foo. (copy)\" */\n            *suffix = \"\";\n        }\n        *name_base = extract_string_until (name, tag);\n        *count = 1;\n        return;\n    }\n\n\n    tag = strstr (name, ANOTHER_COPY_DUPLICATE_TAG);\n    if (tag != NULL)\n    {\n        if (tag > *suffix)\n        {\n            /* handle case \"foo. (another copy)\" */\n            *suffix = \"\";\n        }\n        *name_base = extract_string_until (name, tag);\n        *count = 2;\n        return;\n    }\n\n\n    /* Check to see if we got one of st, nd, rd, th. */\n    tag = strstr (name, X11TH_COPY_DUPLICATE_TAG);\n\n    if (tag == NULL)\n    {\n        tag = strstr (name, X12TH_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, X13TH_COPY_DUPLICATE_TAG);\n    }\n\n    if (tag == NULL)\n    {\n        tag = strstr (name, ST_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, ND_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, RD_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, TH_COPY_DUPLICATE_TAG);\n    }\n\n    /* If we got one of st, nd, rd, th, fish out the duplicate number. */\n    if (tag != NULL)\n    {\n        /* localizers: opening parentheses to match the \"th copy)\" string */\n        tag = strstr (name, _(\" (\"));\n        if (tag != NULL)\n        {\n            if (tag > *suffix)\n            {\n                /* handle case \"foo. (22nd copy)\" */\n                *suffix = \"\";\n            }\n            *name_base = extract_string_until (name, tag);\n            /* localizers: opening parentheses of the \"th copy)\" string */\n            if (sscanf (tag, _(\" (%'d\"), count) == 1)\n            {\n                if (*count < 1 || *count > 1000000)\n                {\n                    /* keep the count within a reasonable range */\n                    *count = 0;\n                }\n                return;\n            }\n            *count = 0;\n            return;\n        }\n    }\n\n\n    *count = 0;\n    if (**suffix != '\\0')\n    {\n        *name_base = extract_string_until (name, *suffix);\n    }\n    else\n    {\n        *name_base = g_strdup (name);\n    }\n}\n\nstatic char *\nmake_next_duplicate_name (const char *base,\n                          const char *suffix,\n                          int         count,\n                          int         max_length)\n{\n    const char *format;\n    char *result;\n    int unshortened_length;\n    gboolean use_count;\n\n    if (count < 1)\n    {\n        g_warning (\"bad count %d in get_duplicate_name\", count);\n        count = 1;\n    }\n\n    if (count <= 2)\n    {\n        /* Handle special cases for low numbers.\n         * Perhaps for some locales we will need to add more.\n         */\n        switch (count)\n        {\n            default:\n            {\n                g_assert_not_reached ();\n                /* fall through */\n            }\n\n            case 1:\n            {\n                format = FIRST_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            case 2:\n            {\n                format = SECOND_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n        }\n\n        use_count = FALSE;\n    }\n    else\n    {\n        /* Handle special cases for the first few numbers of each ten.\n         * For locales where getting this exactly right is difficult,\n         * these can just be made all the same as the general case below.\n         */\n\n        /* Handle special cases for x11th - x20th.\n         */\n        switch (count % 100)\n        {\n            case 11:\n            {\n                format = X11TH_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            case 12:\n            {\n                format = X12TH_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            case 13:\n            {\n                format = X13TH_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            default:\n            {\n                format = NULL;\n            }\n            break;\n        }\n\n        if (format == NULL)\n        {\n            switch (count % 10)\n            {\n                case 1:\n                {\n                    format = ST_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n\n                case 2:\n                {\n                    format = ND_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n\n                case 3:\n                {\n                    format = RD_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n\n                default:\n                {\n                    /* The general case. */\n                    format = TH_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n            }\n        }\n\n        use_count = TRUE;\n    }\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n    if (use_count)\n    {\n        result = g_strdup_printf (format, base, count, suffix);\n    }\n    else\n    {\n        result = g_strdup_printf (format, base, suffix);\n    }\n\n    if (max_length > 0 && (unshortened_length = strlen (result)) > max_length)\n    {\n        char *new_base;\n\n        new_base = shorten_utf8_string (base, unshortened_length - max_length);\n        if (new_base)\n        {\n            g_free (result);\n\n            if (use_count)\n            {\n                result = g_strdup_printf (format, new_base, count, suffix);\n            }\n            else\n            {\n                result = g_strdup_printf (format, new_base, suffix);\n            }\n\n            g_assert (strlen (result) <= max_length);\n            g_free (new_base);\n        }\n    }\n#pragma GCC diagnostic pop\n\n    return result;\n}\n\nstatic char *\nget_duplicate_name (const char *name,\n                    int         count_increment,\n                    int         max_length)\n{\n    char *result;\n    char *name_base;\n    const char *suffix;\n    int count;\n\n    parse_previous_duplicate_name (name, &name_base, &suffix, &count);\n    result = make_next_duplicate_name (name_base, suffix, count + count_increment, max_length);\n\n    g_free (name_base);\n\n    return result;\n}\n\nstatic gboolean\nhas_invalid_xml_char (char *str)\n{\n    gunichar c;\n\n    while (*str != 0)\n    {\n        c = g_utf8_get_char (str);\n        /* characters XML permits */\n        if (!(c == 0x9 ||\n              c == 0xA ||\n              c == 0xD ||\n              (c >= 0x20 && c <= 0xD7FF) ||\n              (c >= 0xE000 && c <= 0xFFFD) ||\n              (c >= 0x10000 && c <= 0x10FFFF)))\n        {\n            return TRUE;\n        }\n        str = g_utf8_next_char (str);\n    }\n    return FALSE;\n}\n\n\nstatic char *\ncustom_full_name_to_string (char    *format,\n                            va_list  va)\n{\n    GFile *file;\n\n    file = va_arg (va, GFile *);\n\n    return g_file_get_parse_name (file);\n}\n\nstatic void\ncustom_full_name_skip (va_list *va)\n{\n    (void) va_arg (*va, GFile *);\n}\n\nstatic char *\ncustom_basename_to_string (char    *format,\n                           va_list  va)\n{\n    GFile *file;\n    GFileInfo *info;\n    char *name, *basename, *tmp;\n    GMount *mount;\n\n    file = va_arg (va, GFile *);\n\n    if ((mount = nautilus_get_mounted_mount_for_root (file)) != NULL)\n    {\n        name = g_mount_get_name (mount);\n        g_object_unref (mount);\n    }\n    else\n    {\n        info = g_file_query_info (file,\n                                  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                  0,\n                                  g_cancellable_get_current (),\n                                  NULL);\n        name = NULL;\n        if (info)\n        {\n            name = g_strdup (g_file_info_get_display_name (info));\n            g_object_unref (info);\n        }\n    }\n\n    if (name == NULL)\n    {\n        basename = g_file_get_basename (file);\n        if (g_utf8_validate (basename, -1, NULL))\n        {\n            name = basename;\n        }\n        else\n        {\n            name = g_uri_escape_string (basename, G_URI_RESERVED_CHARS_ALLOWED_IN_PATH, TRUE);\n            g_free (basename);\n        }\n    }\n\n    /* Some chars can't be put in the markup we use for the dialogs... */\n    if (has_invalid_xml_char (name))\n    {\n        tmp = name;\n        name = g_uri_escape_string (name, G_URI_RESERVED_CHARS_ALLOWED_IN_PATH, TRUE);\n        g_free (tmp);\n    }\n\n    /* Finally, if the string is too long, truncate it. */\n    if (name != NULL)\n    {\n        tmp = name;\n        name = eel_str_middle_truncate (tmp, MAXIMUM_DISPLAYED_FILE_NAME_LENGTH);\n        g_free (tmp);\n    }\n\n\n    return name;\n}\n\nstatic void\ncustom_basename_skip (va_list *va)\n{\n    (void) va_arg (*va, GFile *);\n}\n\n\nstatic char *\ncustom_size_to_string (char    *format,\n                       va_list  va)\n{\n    goffset size;\n\n    size = va_arg (va, goffset);\n    return g_format_size (size);\n}\n\nstatic void\ncustom_size_skip (va_list *va)\n{\n    (void) va_arg (*va, goffset);\n}\n\nstatic char *\ncustom_time_to_string (char    *format,\n                       va_list  va)\n{\n    int secs;\n\n    secs = va_arg (va, int);\n    return format_time (secs);\n}\n\nstatic void\ncustom_time_skip (va_list *va)\n{\n    (void) va_arg (*va, int);\n}\n\nstatic char *\ncustom_mount_to_string (char    *format,\n                        va_list  va)\n{\n    GMount *mount;\n\n    mount = va_arg (va, GMount *);\n    return g_mount_get_name (mount);\n}\n\nstatic void\ncustom_mount_skip (va_list *va)\n{\n    (void) va_arg (*va, GMount *);\n}\n\n\nstatic EelPrintfHandler handlers[] =\n{\n    { 'F', custom_full_name_to_string, custom_full_name_skip },\n    { 'B', custom_basename_to_string, custom_basename_skip },\n    { 'S', custom_size_to_string, custom_size_skip },\n    { 'T', custom_time_to_string, custom_time_skip },\n    { 'V', custom_mount_to_string, custom_mount_skip },\n    { 0 }\n};\n\n\nstatic char *\nf (const char *format,\n   ...)\n{\n    va_list va;\n    char *res;\n\n    va_start (va, format);\n    res = eel_strdup_vprintf_with_custom (handlers, format, va);\n    va_end (va);\n\n    return res;\n}\n\n#define op_job_new(__type, parent_window) ((__type *) (init_common (sizeof (__type), parent_window)))\n\nstatic gpointer\ninit_common (gsize      job_size,\n             GtkWindow *parent_window)\n{\n    CommonJob *common;\n    GdkScreen *screen;\n\n    common = g_malloc0 (job_size);\n\n    if (parent_window)\n    {\n        common->parent_window = parent_window;\n        g_object_add_weak_pointer (G_OBJECT (common->parent_window),\n                                   (gpointer *) &common->parent_window);\n    }\n    common->progress = nautilus_progress_info_new ();\n    common->cancellable = nautilus_progress_info_get_cancellable (common->progress);\n    common->time = g_timer_new ();\n    common->inhibit_cookie = 0;\n    common->screen_num = 0;\n    if (parent_window)\n    {\n        screen = gtk_widget_get_screen (GTK_WIDGET (parent_window));\n        common->screen_num = gdk_screen_get_number (screen);\n    }\n\n    return common;\n}\n\nstatic void\nfinalize_common (CommonJob *common)\n{\n    nautilus_progress_info_finish (common->progress);\n\n    if (common->inhibit_cookie != 0)\n    {\n        gtk_application_uninhibit (GTK_APPLICATION (g_application_get_default ()),\n                                   common->inhibit_cookie);\n    }\n\n    common->inhibit_cookie = 0;\n    g_timer_destroy (common->time);\n\n    if (common->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (common->parent_window),\n                                      (gpointer *) &common->parent_window);\n    }\n\n    if (common->skip_files)\n    {\n        g_hash_table_destroy (common->skip_files);\n    }\n    if (common->skip_readdir_error)\n    {\n        g_hash_table_destroy (common->skip_readdir_error);\n    }\n\n    if (common->undo_info != NULL)\n    {\n        nautilus_file_undo_manager_set_action (common->undo_info);\n        g_object_unref (common->undo_info);\n    }\n\n    g_object_unref (common->progress);\n    g_object_unref (common->cancellable);\n    g_free (common);\n}\n\nstatic void\nskip_file (CommonJob *common,\n           GFile     *file)\n{\n    if (common->skip_files == NULL)\n    {\n        common->skip_files =\n            g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n    }\n\n    g_hash_table_insert (common->skip_files, g_object_ref (file), file);\n}\n\nstatic void\nskip_readdir_error (CommonJob *common,\n                    GFile     *dir)\n{\n    if (common->skip_readdir_error == NULL)\n    {\n        common->skip_readdir_error =\n            g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n    }\n\n    g_hash_table_insert (common->skip_readdir_error, g_object_ref (dir), dir);\n}\n\nstatic gboolean\nshould_skip_file (CommonJob *common,\n                  GFile     *file)\n{\n    if (common->skip_files != NULL)\n    {\n        return g_hash_table_lookup (common->skip_files, file) != NULL;\n    }\n    return FALSE;\n}\n\nstatic gboolean\nshould_skip_readdir_error (CommonJob *common,\n                           GFile     *dir)\n{\n    if (common->skip_readdir_error != NULL)\n    {\n        return g_hash_table_lookup (common->skip_readdir_error, dir) != NULL;\n    }\n    return FALSE;\n}\n\nstatic gboolean\ncan_delete_without_confirm (GFile *file)\n{\n    if (g_file_has_uri_scheme (file, \"burn\") ||\n        g_file_has_uri_scheme (file, \"recent\") ||\n        g_file_has_uri_scheme (file, \"x-nautilus-desktop\"))\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic gboolean\ncan_delete_files_without_confirm (GList *files)\n{\n    g_assert (files != NULL);\n\n    while (files != NULL)\n    {\n        if (!can_delete_without_confirm (files->data))\n        {\n            return FALSE;\n        }\n\n        files = files->next;\n    }\n\n    return TRUE;\n}\n\ntypedef struct\n{\n    GtkWindow **parent_window;\n    gboolean ignore_close_box;\n    GtkMessageType message_type;\n    const char *primary_text;\n    const char *secondary_text;\n    const char *details_text;\n    const char **button_titles;\n    gboolean show_all;\n    int result;\n    /* Dialogs are ran from operation threads, which need to be blocked until\n     * the user gives a valid response\n     */\n    gboolean completed;\n    GMutex mutex;\n    GCond cond;\n} RunSimpleDialogData;\n\nstatic gboolean\ndo_run_simple_dialog (gpointer _data)\n{\n    RunSimpleDialogData *data = _data;\n    const char *button_title;\n    GtkWidget *dialog;\n    int result;\n    int response_id;\n\n    g_mutex_lock (&data->mutex);\n\n    /* Create the dialog. */\n    dialog = gtk_message_dialog_new (*data->parent_window,\n                                     0,\n                                     data->message_type,\n                                     GTK_BUTTONS_NONE,\n                                     NULL);\n\n    g_object_set (dialog,\n                  \"text\", data->primary_text,\n                  \"secondary-text\", data->secondary_text,\n                  NULL);\n\n    for (response_id = 0;\n         data->button_titles[response_id] != NULL;\n         response_id++)\n    {\n        button_title = data->button_titles[response_id];\n        if (!data->show_all && is_all_button_text (button_title))\n        {\n            continue;\n        }\n\n        gtk_dialog_add_button (GTK_DIALOG (dialog), button_title, response_id);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), response_id);\n    }\n\n    if (data->details_text)\n    {\n        eel_gtk_message_dialog_set_details_label (GTK_MESSAGE_DIALOG (dialog),\n                                                  data->details_text);\n    }\n\n    /* Run it. */\n    result = gtk_dialog_run (GTK_DIALOG (dialog));\n\n    while ((result == GTK_RESPONSE_NONE || result == GTK_RESPONSE_DELETE_EVENT) && data->ignore_close_box)\n    {\n        result = gtk_dialog_run (GTK_DIALOG (dialog));\n    }\n\n    gtk_widget_destroy (dialog);\n\n    data->result = result;\n    data->completed = TRUE;\n\n    g_cond_signal (&data->cond);\n    g_mutex_unlock (&data->mutex);\n\n    return FALSE;\n}\n\n/* NOTE: This frees the primary / secondary strings, in order to\n *  avoid doing that everywhere. So, make sure they are strduped */\n\nstatic int\nrun_simple_dialog_va (CommonJob      *job,\n                      gboolean        ignore_close_box,\n                      GtkMessageType  message_type,\n                      char           *primary_text,\n                      char           *secondary_text,\n                      const char     *details_text,\n                      gboolean        show_all,\n                      va_list         varargs)\n{\n    RunSimpleDialogData *data;\n    int res;\n    const char *button_title;\n    GPtrArray *ptr_array;\n\n    g_timer_stop (job->time);\n\n    data = g_new0 (RunSimpleDialogData, 1);\n    data->parent_window = &job->parent_window;\n    data->ignore_close_box = ignore_close_box;\n    data->message_type = message_type;\n    data->primary_text = primary_text;\n    data->secondary_text = secondary_text;\n    data->details_text = details_text;\n    data->show_all = show_all;\n    data->completed = FALSE;\n    g_mutex_init (&data->mutex);\n    g_cond_init (&data->cond);\n\n    ptr_array = g_ptr_array_new ();\n    while ((button_title = va_arg (varargs, const char *)) != NULL)\n    {\n        g_ptr_array_add (ptr_array, (char *) button_title);\n    }\n    g_ptr_array_add (ptr_array, NULL);\n    data->button_titles = (const char **) g_ptr_array_free (ptr_array, FALSE);\n\n    nautilus_progress_info_pause (job->progress);\n\n    g_mutex_lock (&data->mutex);\n\n    g_main_context_invoke (NULL,\n                           do_run_simple_dialog,\n                           data);\n\n    while (!data->completed)\n    {\n        g_cond_wait (&data->cond, &data->mutex);\n    }\n\n    nautilus_progress_info_resume (job->progress);\n    res = data->result;\n\n    g_mutex_unlock (&data->mutex);\n    g_mutex_clear (&data->mutex);\n    g_cond_clear (&data->cond);\n\n    g_free (data->button_titles);\n    g_free (data);\n\n    g_timer_continue (job->time);\n\n    g_free (primary_text);\n    g_free (secondary_text);\n\n    return res;\n}\n\n#if 0 /* Not used at the moment */\nstatic int\nrun_simple_dialog (CommonJob     *job,\n                   gboolean       ignore_close_box,\n                   GtkMessageType message_type,\n                   char          *primary_text,\n                   char          *secondary_text,\n                   const char    *details_text,\n                   ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, details_text);\n    res = run_simple_dialog_va (job,\n                                ignore_close_box,\n                                message_type,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n#endif\n\nstatic int\nrun_error (CommonJob  *job,\n           char       *primary_text,\n           char       *secondary_text,\n           const char *details_text,\n           gboolean    show_all,\n           ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, show_all);\n    res = run_simple_dialog_va (job,\n                                FALSE,\n                                GTK_MESSAGE_ERROR,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                show_all,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n\nstatic int\nrun_warning (CommonJob  *job,\n             char       *primary_text,\n             char       *secondary_text,\n             const char *details_text,\n             gboolean    show_all,\n             ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, show_all);\n    res = run_simple_dialog_va (job,\n                                FALSE,\n                                GTK_MESSAGE_WARNING,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                show_all,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n\nstatic int\nrun_question (CommonJob  *job,\n              char       *primary_text,\n              char       *secondary_text,\n              const char *details_text,\n              gboolean    show_all,\n              ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, show_all);\n    res = run_simple_dialog_va (job,\n                                FALSE,\n                                GTK_MESSAGE_QUESTION,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                show_all,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n\nstatic int\nrun_cancel_or_skip_warning (CommonJob  *job,\n                            char       *primary_text,\n                            char       *secondary_text,\n                            const char *details_text,\n                            int         total_operations,\n                            int         operations_remaining)\n{\n    int response;\n\n    if (total_operations == 1)\n    {\n        response = run_warning (job,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                FALSE,\n                                CANCEL,\n                                NULL);\n    }\n    else\n    {\n        response = run_warning (job,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                operations_remaining > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n    }\n\n    return response;\n}\n\nstatic void\ninhibit_power_manager (CommonJob  *job,\n                       const char *message)\n{\n    job->inhibit_cookie = gtk_application_inhibit (GTK_APPLICATION (g_application_get_default ()),\n                                                   GTK_WINDOW (job->parent_window),\n                                                   GTK_APPLICATION_INHIBIT_LOGOUT |\n                                                   GTK_APPLICATION_INHIBIT_SUSPEND,\n                                                   message);\n}\n\nstatic void\nabort_job (CommonJob *job)\n{\n    /* destroy the undo action data too */\n    g_clear_object (&job->undo_info);\n\n    g_cancellable_cancel (job->cancellable);\n}\n\nstatic gboolean\njob_aborted (CommonJob *job)\n{\n    return g_cancellable_is_cancelled (job->cancellable);\n}\n\n/* Since this happens on a thread we can't use the global prefs object */\nstatic gboolean\nshould_confirm_trash (void)\n{\n    GSettings *prefs;\n    gboolean confirm_trash;\n\n    prefs = g_settings_new (\"org.gnome.nautilus.preferences\");\n    confirm_trash = g_settings_get_boolean (prefs, NAUTILUS_PREFERENCES_CONFIRM_TRASH);\n    g_object_unref (prefs);\n    return confirm_trash;\n}\n\nstatic gboolean\nconfirm_delete_from_trash (CommonJob *job,\n                           GList     *files)\n{\n    char *prompt;\n    int file_count;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    file_count = g_list_length (files);\n    g_assert (file_count > 0);\n\n    if (file_count == 1)\n    {\n        prompt = f (_(\"Are you sure you want to permanently delete \u201c%B\u201d \"\n                      \"from the trash?\"), files->data);\n    }\n    else\n    {\n        prompt = f (ngettext (\"Are you sure you want to permanently delete \"\n                              \"the %'d selected item from the trash?\",\n                              \"Are you sure you want to permanently delete \"\n                              \"the %'d selected items from the trash?\",\n                              file_count),\n                    file_count);\n    }\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"If you delete an item, it will be permanently lost.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, DELETE,\n                            NULL);\n\n    return (response == 1);\n}\n\nstatic gboolean\nconfirm_empty_trash (CommonJob *job)\n{\n    char *prompt;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    prompt = f (_(\"Empty all items from Trash?\"));\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"All items in the Trash will be permanently deleted.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, _(\"Empty _Trash\"),\n                            NULL);\n\n    return (response == 1);\n}\n\nstatic gboolean\nconfirm_delete_directly (CommonJob *job,\n                         GList     *files)\n{\n    char *prompt;\n    int file_count;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    file_count = g_list_length (files);\n    g_assert (file_count > 0);\n\n    if (can_delete_files_without_confirm (files))\n    {\n        return TRUE;\n    }\n\n    if (file_count == 1)\n    {\n        prompt = f (_(\"Are you sure you want to permanently delete \u201c%B\u201d?\"),\n                    files->data);\n    }\n    else\n    {\n        prompt = f (ngettext (\"Are you sure you want to permanently delete \"\n                              \"the %'d selected item?\",\n                              \"Are you sure you want to permanently delete \"\n                              \"the %'d selected items?\", file_count),\n                    file_count);\n    }\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"If you delete an item, it will be permanently lost.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, DELETE,\n                            NULL);\n\n    return response == 1;\n}\n\nstatic void\nreport_delete_progress (CommonJob    *job,\n                        SourceInfo   *source_info,\n                        TransferInfo *transfer_info)\n{\n    int files_left;\n    double elapsed, transfer_rate;\n    int remaining_time;\n    gint64 now;\n    char *details;\n    char *status;\n    DeleteJob *delete_job;\n\n    delete_job = (DeleteJob *) job;\n    now = g_get_monotonic_time ();\n    files_left = source_info->num_files - transfer_info->num_files;\n\n    /* Races and whatnot could cause this to be negative... */\n    if (files_left < 0)\n    {\n        files_left = 0;\n    }\n\n    /* If the number of files left is 0, we want to update the status without\n     * considering this time, since we want to change the status to completed\n     * and probably we won't get more calls to this function */\n    if (transfer_info->last_report_time != 0 &&\n        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&\n        files_left > 0)\n    {\n        return;\n    }\n\n    transfer_info->last_report_time = now;\n\n    if (source_info->num_files == 1)\n    {\n        if (files_left == 0)\n        {\n            status = _(\"Deleted \u201c%B\u201d\");\n        }\n        else\n        {\n            status = _(\"Deleting \u201c%B\u201d\");\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               (GFile *) delete_job->files->data));\n    }\n    else\n    {\n        if (files_left == 0)\n        {\n            status = ngettext (\"Deleted %'d file\",\n                               \"Deleted %'d files\",\n                               source_info->num_files);\n        }\n        else\n        {\n            status = ngettext (\"Deleting %'d file\",\n                               \"Deleting %'d files\",\n                               source_info->num_files);\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               source_info->num_files));\n    }\n\n    elapsed = g_timer_elapsed (job->time, NULL);\n    transfer_rate = 0;\n    remaining_time = INT_MAX;\n    if (elapsed > 0)\n    {\n        transfer_rate = transfer_info->num_files / elapsed;\n        if (transfer_rate > 0)\n        {\n            remaining_time = (source_info->num_files - transfer_info->num_files) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE)\n    {\n        if (files_left > 0)\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files + 1,\n                         source_info->num_files);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    else\n    {\n        if (files_left > 0)\n        {\n            gchar *time_left_message;\n            gchar *files_per_second_message;\n            gchar *concat_detail;\n\n            /* To translators: %T will expand to a time duration like \"2 minutes\".\n             * So the whole thing will be something like \"1 / 5 -- 2 hours left (4 files/sec)\"\n             *\n             * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n             */\n            time_left_message = ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          \"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          seconds_count_format_time_units (remaining_time));\n            transfer_rate += 0.5;\n            files_per_second_message = ngettext (\"(%d file/sec)\",\n                                                 \"(%d files/sec)\",\n                                                 (int) transfer_rate);\n            concat_detail = g_strconcat (time_left_message, \" \", files_per_second_message, NULL);\n\n            details = f (concat_detail,\n                         transfer_info->num_files + 1, source_info->num_files,\n                         remaining_time,\n                         (int) transfer_rate);\n\n            g_free (concat_detail);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    nautilus_progress_info_take_details (job->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (job->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (job->progress,\n                                                 elapsed);\n    }\n\n    if (source_info->num_files != 0)\n    {\n        nautilus_progress_info_set_progress (job->progress, transfer_info->num_files, source_info->num_files);\n    }\n}\n\ntypedef void (*DeleteCallback) (GFile   *file,\n                                GError  *error,\n                                gpointer callback_data);\n\nstatic gboolean\ndelete_file_recursively (GFile          *file,\n                         GCancellable   *cancellable,\n                         DeleteCallback  callback,\n                         gpointer        callback_data)\n{\n    gboolean success;\n    g_autoptr (GError) error = NULL;\n\n    do\n    {\n        g_autoptr (GFileEnumerator) enumerator = NULL;\n\n        success = g_file_delete (file, cancellable, &error);\n        if (success ||\n            !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n            break;\n        }\n\n        g_clear_error (&error);\n\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                                G_FILE_QUERY_INFO_NONE,\n                                                cancellable, &error);\n\n        if (enumerator)\n        {\n            GFileInfo *info;\n\n            success = TRUE;\n\n            info = g_file_enumerator_next_file (enumerator,\n                                                cancellable,\n                                                &error);\n\n            while (info != NULL)\n            {\n                g_autoptr (GFile) child = NULL;\n\n                child = g_file_enumerator_get_child (enumerator, info);\n\n                success = success && delete_file_recursively (child,\n                                                              cancellable,\n                                                              callback,\n                                                              callback_data);\n\n                g_object_unref (info);\n\n                info = g_file_enumerator_next_file (enumerator,\n                                                    cancellable,\n                                                    &error);\n            }\n        }\n\n        if (error != NULL)\n        {\n            success = FALSE;\n        }\n    }\n    while (success);\n\n    if (callback)\n    {\n        callback (file, error, callback_data);\n    }\n\n    return success;\n}\n\ntypedef struct\n{\n    CommonJob *job;\n    SourceInfo *source_info;\n    TransferInfo *transfer_info;\n} DeleteData;\n\nstatic void\nfile_deleted_callback (GFile    *file,\n                       GError   *error,\n                       gpointer  callback_data)\n{\n    DeleteData *data = callback_data;\n    CommonJob *job;\n    SourceInfo *source_info;\n    TransferInfo *transfer_info;\n    GFileType file_type;\n    char *primary;\n    char *secondary;\n    char *details = NULL;\n    int response;\n\n    job = data->job;\n    source_info = data->source_info;\n    transfer_info = data->transfer_info;\n\n    data->transfer_info->num_files++;\n\n    if (error == NULL)\n    {\n        nautilus_file_changes_queue_file_removed (file);\n        report_delete_progress (data->job, data->source_info, data->transfer_info);\n\n        return;\n    }\n\n    if (job_aborted (job) ||\n        job->skip_all_error ||\n        should_skip_file (job, file) ||\n        should_skip_readdir_error (job, file))\n    {\n        return;\n    }\n\n    primary = f (_(\"Error while deleting.\"));\n\n    file_type = g_file_query_file_type (file,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        job->cancellable);\n\n    if (file_type == G_FILE_TYPE_DIRECTORY)\n    {\n        secondary = IS_IO_ERROR (error, PERMISSION_DENIED) ?\n                    f (_(\"There was an error deleting the folder \u201c%B\u201d.\"),\n                       file) :\n                    f (_(\"You do not have sufficient permissions to delete the folder \u201c%B\u201d.\"),\n                       file);\n    }\n    else\n    {\n        secondary = IS_IO_ERROR (error, PERMISSION_DENIED) ?\n                    f (_(\"There was an error deleting the file \u201c%B\u201d.\"),\n                       file) :\n                    f (_(\"You do not have sufficient permissions to delete the file \u201c%B\u201d.\"),\n                       file);\n    }\n\n    details = error->message;\n\n    response = run_cancel_or_skip_warning (job,\n                                           primary,\n                                           secondary,\n                                           details,\n                                           source_info->num_files,\n                                           source_info->num_files - transfer_info->num_files);\n\n    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n    {\n        abort_job (job);\n    }\n    else if (response == 1)\n    {\n        /* skip all */\n        job->skip_all_error = TRUE;\n    }\n}\n\nstatic void\ndelete_files (CommonJob *job,\n              GList     *files,\n              int       *files_skipped)\n{\n    GList *l;\n    GFile *file;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    DeleteData data;\n\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    scan_sources (files,\n                  &source_info,\n                  job,\n                  OP_KIND_DELETE);\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    g_timer_start (job->time);\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    report_delete_progress (job, &source_info, &transfer_info);\n\n    data.job = job;\n    data.source_info = &source_info;\n    data.transfer_info = &transfer_info;\n\n    for (l = files;\n         l != NULL && !job_aborted (job);\n         l = l->next)\n    {\n        gboolean success;\n\n        file = l->data;\n\n        if (should_skip_file (job, file))\n        {\n            (*files_skipped)++;\n            continue;\n        }\n\n        success = delete_file_recursively (file, job->cancellable,\n                                           file_deleted_callback,\n                                           &data);\n\n        if (!success)\n        {\n            (*files_skipped)++;\n        }\n    }\n}\n\nstatic void\nreport_trash_progress (CommonJob    *job,\n                       SourceInfo   *source_info,\n                       TransferInfo *transfer_info)\n{\n    int files_left;\n    double elapsed, transfer_rate;\n    int remaining_time;\n    gint64 now;\n    char *details;\n    char *status;\n    DeleteJob *delete_job;\n\n    delete_job = (DeleteJob *) job;\n    now = g_get_monotonic_time ();\n    files_left = source_info->num_files - transfer_info->num_files;\n\n    /* Races and whatnot could cause this to be negative... */\n    if (files_left < 0)\n    {\n        files_left = 0;\n    }\n\n    /* If the number of files left is 0, we want to update the status without\n     * considering this time, since we want to change the status to completed\n     * and probably we won't get more calls to this function */\n    if (transfer_info->last_report_time != 0 &&\n        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&\n        files_left > 0)\n    {\n        return;\n    }\n\n    transfer_info->last_report_time = now;\n\n    if (source_info->num_files == 1)\n    {\n        if (files_left > 0)\n        {\n            status = _(\"Trashing \u201c%B\u201d\");\n        }\n        else\n        {\n            status = _(\"Trashed \u201c%B\u201d\");\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               (GFile *) delete_job->files->data));\n    }\n    else\n    {\n        if (files_left > 0)\n        {\n            status = ngettext (\"Trashing %'d file\",\n                               \"Trashing %'d files\",\n                               source_info->num_files);\n        }\n        else\n        {\n            status = ngettext (\"Trashed %'d file\",\n                               \"Trashed %'d files\",\n                               source_info->num_files);\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               source_info->num_files));\n    }\n\n\n    elapsed = g_timer_elapsed (job->time, NULL);\n    transfer_rate = 0;\n    remaining_time = INT_MAX;\n    if (elapsed > 0)\n    {\n        transfer_rate = transfer_info->num_files / elapsed;\n        if (transfer_rate > 0)\n        {\n            remaining_time = (source_info->num_files - transfer_info->num_files) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE)\n    {\n        if (files_left > 0)\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files + 1,\n                         source_info->num_files);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    else\n    {\n        if (files_left > 0)\n        {\n            gchar *time_left_message;\n            gchar *files_per_second_message;\n            gchar *concat_detail;\n\n            /* To translators: %T will expand to a time duration like \"2 minutes\".\n             * So the whole thing will be something like \"1 / 5 -- 2 hours left (4 files/sec)\"\n             *\n             * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n             */\n            time_left_message = ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          \"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          seconds_count_format_time_units (remaining_time));\n            files_per_second_message = ngettext (\"(%d file/sec)\",\n                                                 \"(%d files/sec)\",\n                                                 (int) (transfer_rate + 0.5));\n            concat_detail = g_strconcat (time_left_message, \" \", files_per_second_message, NULL);\n\n            details = f (concat_detail,\n                         transfer_info->num_files + 1, source_info->num_files,\n                         remaining_time,\n                         (int) transfer_rate + 0.5);\n\n            g_free (concat_detail);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    nautilus_progress_info_set_details (job->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (job->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (job->progress,\n                                                 elapsed);\n    }\n\n    if (source_info->num_files != 0)\n    {\n        nautilus_progress_info_set_progress (job->progress, transfer_info->num_files, source_info->num_files);\n    }\n}\n\nstatic void\ntrash_file (CommonJob     *job,\n            GFile         *file,\n            gboolean      *skipped_file,\n            SourceInfo    *source_info,\n            TransferInfo  *transfer_info,\n            gboolean       toplevel,\n            GList        **to_delete)\n{\n    GError *error;\n    char *primary, *secondary, *details;\n    int response;\n\n    if (should_skip_file (job, file))\n    {\n        *skipped_file = TRUE;\n        return;\n    }\n\n    error = NULL;\n\n    if (g_file_trash (file, job->cancellable, &error))\n    {\n        transfer_info->num_files++;\n        nautilus_file_changes_queue_file_removed (file);\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_trash_add_file (NAUTILUS_FILE_UNDO_INFO_TRASH (job->undo_info), file);\n        }\n\n        report_trash_progress (job, source_info, transfer_info);\n        return;\n    }\n\n    if (job->skip_all_error)\n    {\n        *skipped_file = TRUE;\n        goto skip;\n    }\n\n    if (job->delete_all)\n    {\n        *to_delete = g_list_prepend (*to_delete, file);\n        goto skip;\n    }\n\n    /* Translators: %B is a file name */\n    primary = f (_(\"\u201c%B\u201d can\u2019t be put in the trash. Do you want to delete it immediately?\"), file);\n    details = NULL;\n    secondary = NULL;\n    if (!IS_IO_ERROR (error, NOT_SUPPORTED))\n    {\n        details = error->message;\n    }\n    else if (!g_file_is_native (file))\n    {\n        secondary = f (_(\"This remote location does not support sending items to the trash.\"));\n    }\n\n    response = run_question (job,\n                             primary,\n                             secondary,\n                             details,\n                             (source_info->num_files - transfer_info->num_files) > 1,\n                             CANCEL, SKIP_ALL, SKIP, DELETE_ALL, DELETE,\n                             NULL);\n\n    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n    {\n        ((DeleteJob *) job)->user_cancel = TRUE;\n        abort_job (job);\n    }\n    else if (response == 1)         /* skip all */\n    {\n        *skipped_file = TRUE;\n        job->skip_all_error = TRUE;\n    }\n    else if (response == 2)         /* skip */\n    {\n        *skipped_file = TRUE;\n        job->skip_all_error = TRUE;\n    }\n    else if (response == 3)         /* delete all */\n    {\n        *to_delete = g_list_prepend (*to_delete, file);\n        job->delete_all = TRUE;\n    }\n    else if (response == 4)         /* delete */\n    {\n        *to_delete = g_list_prepend (*to_delete, file);\n    }\n\nskip:\n    g_error_free (error);\n}\n\nstatic void\ntransfer_add_file_to_count (GFile        *file,\n                            CommonJob    *job,\n                            TransferInfo *transfer_info)\n{\n    g_autoptr (GFileInfo) file_info = NULL;\n\n    if (g_cancellable_is_cancelled (job->cancellable))\n    {\n        return;\n    }\n\n    file_info = g_file_query_info (file,\n                                   G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                   G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                   job->cancellable,\n                                   NULL);\n\n    transfer_info->num_files++;\n    if (file_info != NULL)\n    {\n        transfer_info->num_bytes += g_file_info_get_size (file_info);\n    }\n}\n\nstatic void\ntrash_files (CommonJob *job,\n             GList     *files,\n             int       *files_skipped)\n{\n    GList *l;\n    GFile *file;\n    GList *to_delete;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    gboolean skipped_file;\n\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    scan_sources (files,\n                  &source_info,\n                  job,\n                  OP_KIND_TRASH);\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    g_timer_start (job->time);\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    report_trash_progress (job, &source_info, &transfer_info);\n\n    to_delete = NULL;\n    for (l = files;\n         l != NULL && !job_aborted (job);\n         l = l->next)\n    {\n        file = l->data;\n\n        skipped_file = FALSE;\n        trash_file (job, file,\n                    &skipped_file,\n                    &source_info, &transfer_info,\n                    TRUE, &to_delete);\n        if (skipped_file)\n        {\n            (*files_skipped)++;\n            transfer_add_file_to_count (file, job, &transfer_info);\n            report_trash_progress (job, &source_info, &transfer_info);\n        }\n    }\n\n    if (to_delete)\n    {\n        to_delete = g_list_reverse (to_delete);\n        delete_files (job, to_delete, files_skipped);\n        g_list_free (to_delete);\n    }\n}\n\nstatic void\ndelete_task_done (GObject      *source_object,\n                  GAsyncResult *res,\n                  gpointer      user_data)\n{\n    DeleteJob *job;\n    GHashTable *debuting_uris;\n\n    job = user_data;\n\n    g_list_free_full (job->files, g_object_unref);\n\n    if (job->done_callback)\n    {\n        debuting_uris = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n        job->done_callback (debuting_uris, job->user_cancel, job->done_callback_data);\n        g_hash_table_unref (debuting_uris);\n    }\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ndelete_task_thread_func (GTask        *task,\n                         gpointer      source_object,\n                         gpointer      task_data,\n                         GCancellable *cancellable)\n{\n    DeleteJob *job = task_data;\n    GList *to_trash_files;\n    GList *to_delete_files;\n    GList *l;\n    GFile *file;\n    gboolean confirmed;\n    CommonJob *common;\n    gboolean must_confirm_delete_in_trash;\n    gboolean must_confirm_delete;\n    int files_skipped;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    to_trash_files = NULL;\n    to_delete_files = NULL;\n\n    must_confirm_delete_in_trash = FALSE;\n    must_confirm_delete = FALSE;\n    files_skipped = 0;\n\n    for (l = job->files; l != NULL; l = l->next)\n    {\n        file = l->data;\n\n        if (job->try_trash &&\n            g_file_has_uri_scheme (file, \"trash\"))\n        {\n            must_confirm_delete_in_trash = TRUE;\n            to_delete_files = g_list_prepend (to_delete_files, file);\n        }\n        else if (can_delete_without_confirm (file))\n        {\n            to_delete_files = g_list_prepend (to_delete_files, file);\n        }\n        else\n        {\n            if (job->try_trash)\n            {\n                to_trash_files = g_list_prepend (to_trash_files, file);\n            }\n            else\n            {\n                must_confirm_delete = TRUE;\n                to_delete_files = g_list_prepend (to_delete_files, file);\n            }\n        }\n    }\n\n    if (to_delete_files != NULL)\n    {\n        to_delete_files = g_list_reverse (to_delete_files);\n        confirmed = TRUE;\n        if (must_confirm_delete_in_trash)\n        {\n            confirmed = confirm_delete_from_trash (common, to_delete_files);\n        }\n        else if (must_confirm_delete)\n        {\n            confirmed = confirm_delete_directly (common, to_delete_files);\n        }\n        if (confirmed)\n        {\n            delete_files (common, to_delete_files, &files_skipped);\n        }\n        else\n        {\n            job->user_cancel = TRUE;\n        }\n    }\n\n    if (to_trash_files != NULL)\n    {\n        to_trash_files = g_list_reverse (to_trash_files);\n\n        trash_files (common, to_trash_files, &files_skipped);\n    }\n\n    g_list_free (to_trash_files);\n    g_list_free (to_delete_files);\n\n    if (files_skipped == g_list_length (job->files))\n    {\n        /* User has skipped all files, report user cancel */\n        job->user_cancel = TRUE;\n    }\n}\n\nstatic void\ntrash_or_delete_internal (GList                  *files,\n                          GtkWindow              *parent_window,\n                          gboolean                try_trash,\n                          NautilusDeleteCallback  done_callback,\n                          gpointer                done_callback_data)\n{\n    GTask *task;\n    DeleteJob *job;\n\n    /* TODO: special case desktop icon link files ... */\n\n    job = op_job_new (DeleteJob, parent_window);\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->try_trash = try_trash;\n    job->user_cancel = FALSE;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n\n    if (try_trash)\n    {\n        inhibit_power_manager ((CommonJob *) job, _(\"Trashing Files\"));\n    }\n    else\n    {\n        inhibit_power_manager ((CommonJob *) job, _(\"Deleting Files\"));\n    }\n\n    if (!nautilus_file_undo_manager_is_operating () && try_trash)\n    {\n        job->common.undo_info = nautilus_file_undo_info_trash_new (g_list_length (files));\n    }\n\n    task = g_task_new (NULL, NULL, delete_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, delete_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_trash_or_delete (GList                  *files,\n                                          GtkWindow              *parent_window,\n                                          NautilusDeleteCallback  done_callback,\n                                          gpointer                done_callback_data)\n{\n    trash_or_delete_internal (files, parent_window,\n                              TRUE,\n                              done_callback, done_callback_data);\n}\n\nvoid\nnautilus_file_operations_delete (GList                  *files,\n                                 GtkWindow              *parent_window,\n                                 NautilusDeleteCallback  done_callback,\n                                 gpointer                done_callback_data)\n{\n    trash_or_delete_internal (files, parent_window,\n                              FALSE,\n                              done_callback, done_callback_data);\n}\n\n\n\ntypedef struct\n{\n    gboolean eject;\n    GMount *mount;\n    GMountOperation *mount_operation;\n    GtkWindow *parent_window;\n    NautilusUnmountCallback callback;\n    gpointer callback_data;\n} UnmountData;\n\nstatic void\nunmount_data_free (UnmountData *data)\n{\n    if (data->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (data->parent_window),\n                                      (gpointer *) &data->parent_window);\n    }\n\n    g_clear_object (&data->mount_operation);\n    g_object_unref (data->mount);\n    g_free (data);\n}\n\nstatic void\nunmount_mount_callback (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    UnmountData *data = user_data;\n    GError *error;\n    char *primary;\n    gboolean unmounted;\n\n    error = NULL;\n    if (data->eject)\n    {\n        unmounted = g_mount_eject_with_operation_finish (G_MOUNT (source_object),\n                                                         res, &error);\n    }\n    else\n    {\n        unmounted = g_mount_unmount_with_operation_finish (G_MOUNT (source_object),\n                                                           res, &error);\n    }\n\n    if (!unmounted)\n    {\n        if (error->code != G_IO_ERROR_FAILED_HANDLED)\n        {\n            if (data->eject)\n            {\n                primary = f (_(\"Unable to eject %V\"), source_object);\n            }\n            else\n            {\n                primary = f (_(\"Unable to unmount %V\"), source_object);\n            }\n            eel_show_error_dialog (primary,\n                                   error->message,\n                                   data->parent_window);\n            g_free (primary);\n        }\n    }\n\n    if (data->callback)\n    {\n        data->callback (data->callback_data);\n    }\n\n    if (error != NULL)\n    {\n        g_error_free (error);\n    }\n\n    unmount_data_free (data);\n}\n\nstatic void\ndo_unmount (UnmountData *data)\n{\n    GMountOperation *mount_op;\n\n    if (data->mount_operation)\n    {\n        mount_op = g_object_ref (data->mount_operation);\n    }\n    else\n    {\n        mount_op = gtk_mount_operation_new (data->parent_window);\n    }\n    if (data->eject)\n    {\n        g_mount_eject_with_operation (data->mount,\n                                      0,\n                                      mount_op,\n                                      NULL,\n                                      unmount_mount_callback,\n                                      data);\n    }\n    else\n    {\n        g_mount_unmount_with_operation (data->mount,\n                                        0,\n                                        mount_op,\n                                        NULL,\n                                        unmount_mount_callback,\n                                        data);\n    }\n    g_object_unref (mount_op);\n}\n\nstatic gboolean\ndir_has_files (GFile *dir)\n{\n    GFileEnumerator *enumerator;\n    gboolean res;\n    GFileInfo *file_info;\n\n    res = FALSE;\n\n    enumerator = g_file_enumerate_children (dir,\n                                            G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                            0,\n                                            NULL, NULL);\n    if (enumerator)\n    {\n        file_info = g_file_enumerator_next_file (enumerator, NULL, NULL);\n        if (file_info != NULL)\n        {\n            res = TRUE;\n            g_object_unref (file_info);\n        }\n\n        g_file_enumerator_close (enumerator, NULL, NULL);\n        g_object_unref (enumerator);\n    }\n\n\n    return res;\n}\n\nstatic GList *\nget_trash_dirs_for_mount (GMount *mount)\n{\n    GFile *root;\n    GFile *trash;\n    char *relpath;\n    GList *list;\n\n    root = g_mount_get_root (mount);\n    if (root == NULL)\n    {\n        return NULL;\n    }\n\n    list = NULL;\n\n    if (g_file_is_native (root))\n    {\n        relpath = g_strdup_printf (\".Trash/%d\", getuid ());\n        trash = g_file_resolve_relative_path (root, relpath);\n        g_free (relpath);\n\n        list = g_list_prepend (list, g_file_get_child (trash, \"files\"));\n        list = g_list_prepend (list, g_file_get_child (trash, \"info\"));\n\n        g_object_unref (trash);\n\n        relpath = g_strdup_printf (\".Trash-%d\", getuid ());\n        trash = g_file_get_child (root, relpath);\n        g_free (relpath);\n\n        list = g_list_prepend (list, g_file_get_child (trash, \"files\"));\n        list = g_list_prepend (list, g_file_get_child (trash, \"info\"));\n\n        g_object_unref (trash);\n    }\n\n    g_object_unref (root);\n\n    return list;\n}\n\nstatic gboolean\nhas_trash_files (GMount *mount)\n{\n    GList *dirs, *l;\n    GFile *dir;\n    gboolean res;\n\n    dirs = get_trash_dirs_for_mount (mount);\n\n    res = FALSE;\n\n    for (l = dirs; l != NULL; l = l->next)\n    {\n        dir = l->data;\n\n        if (dir_has_files (dir))\n        {\n            res = TRUE;\n            break;\n        }\n    }\n\n    g_list_free_full (dirs, g_object_unref);\n\n    return res;\n}\n\n\nstatic gint\nprompt_empty_trash (GtkWindow *parent_window)\n{\n    gint result;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n\n    screen = NULL;\n    if (parent_window != NULL)\n    {\n        screen = gtk_widget_get_screen (GTK_WIDGET (parent_window));\n    }\n\n    /* Do we need to be modal ? */\n    dialog = gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL,\n                                     GTK_MESSAGE_QUESTION, GTK_BUTTONS_NONE,\n                                     _(\"Do you want to empty the trash before you unmount?\"));\n    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                              _(\"In order to regain the \"\n                                                \"free space on this volume \"\n                                                \"the trash must be emptied. \"\n                                                \"All trashed items on the volume \"\n                                                \"will be permanently lost.\"));\n    gtk_dialog_add_buttons (GTK_DIALOG (dialog),\n                            _(\"Do _not Empty Trash\"), GTK_RESPONSE_REJECT,\n                            CANCEL, GTK_RESPONSE_CANCEL,\n                            _(\"Empty _Trash\"), GTK_RESPONSE_ACCEPT, NULL);\n    gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_ACCEPT);\n    gtk_window_set_title (GTK_WINDOW (dialog), \"\");     /* as per HIG */\n    gtk_window_set_skip_taskbar_hint (GTK_WINDOW (dialog), TRUE);\n    if (screen)\n    {\n        gtk_window_set_screen (GTK_WINDOW (dialog), screen);\n    }\n    atk_object_set_role (gtk_widget_get_accessible (dialog), ATK_ROLE_ALERT);\n    gtk_window_set_wmclass (GTK_WINDOW (dialog), \"empty_trash\",\n                            \"Nautilus\");\n\n    /* Make transient for the window group */\n    gtk_widget_realize (dialog);\n    if (screen != NULL)\n    {\n        gdk_window_set_transient_for (gtk_widget_get_window (GTK_WIDGET (dialog)),\n                                      gdk_screen_get_root_window (screen));\n    }\n\n    result = gtk_dialog_run (GTK_DIALOG (dialog));\n    gtk_widget_destroy (dialog);\n    return result;\n}\n\nstatic void\nempty_trash_for_unmount_done (gboolean success,\n                              gpointer user_data)\n{\n    UnmountData *data = user_data;\n    do_unmount (data);\n}\n\nvoid\nnautilus_file_operations_unmount_mount_full (GtkWindow               *parent_window,\n                                             GMount                  *mount,\n                                             GMountOperation         *mount_operation,\n                                             gboolean                 eject,\n                                             gboolean                 check_trash,\n                                             NautilusUnmountCallback  callback,\n                                             gpointer                 callback_data)\n{\n    UnmountData *data;\n    int response;\n\n    data = g_new0 (UnmountData, 1);\n    data->callback = callback;\n    data->callback_data = callback_data;\n    if (parent_window)\n    {\n        data->parent_window = parent_window;\n        g_object_add_weak_pointer (G_OBJECT (data->parent_window),\n                                   (gpointer *) &data->parent_window);\n    }\n    if (mount_operation)\n    {\n        data->mount_operation = g_object_ref (mount_operation);\n    }\n    data->eject = eject;\n    data->mount = g_object_ref (mount);\n\n    if (check_trash && has_trash_files (mount))\n    {\n        response = prompt_empty_trash (parent_window);\n\n        if (response == GTK_RESPONSE_ACCEPT)\n        {\n            GTask *task;\n            EmptyTrashJob *job;\n\n            job = op_job_new (EmptyTrashJob, parent_window);\n            job->should_confirm = FALSE;\n            job->trash_dirs = get_trash_dirs_for_mount (mount);\n            job->done_callback = empty_trash_for_unmount_done;\n            job->done_callback_data = data;\n\n            task = g_task_new (NULL, NULL, empty_trash_task_done, job);\n            g_task_set_task_data (task, job, NULL);\n            g_task_run_in_thread (task, empty_trash_thread_func);\n            g_object_unref (task);\n            return;\n        }\n        else if (response == GTK_RESPONSE_CANCEL)\n        {\n            if (callback)\n            {\n                callback (callback_data);\n            }\n\n            unmount_data_free (data);\n            return;\n        }\n    }\n\n    do_unmount (data);\n}\n\nvoid\nnautilus_file_operations_unmount_mount (GtkWindow *parent_window,\n                                        GMount    *mount,\n                                        gboolean   eject,\n                                        gboolean   check_trash)\n{\n    nautilus_file_operations_unmount_mount_full (parent_window, mount, NULL, eject,\n                                                 check_trash, NULL, NULL);\n}\n\nstatic void\nmount_callback_data_notify (gpointer  data,\n                            GObject  *object)\n{\n    GMountOperation *mount_op;\n\n    mount_op = G_MOUNT_OPERATION (data);\n    g_object_set_data (G_OBJECT (mount_op), \"mount-callback\", NULL);\n    g_object_set_data (G_OBJECT (mount_op), \"mount-callback-data\", NULL);\n}\n\nstatic void\nvolume_mount_cb (GObject      *source_object,\n                 GAsyncResult *res,\n                 gpointer      user_data)\n{\n    NautilusMountCallback mount_callback;\n    GObject *mount_callback_data_object;\n    GMountOperation *mount_op = user_data;\n    GError *error;\n    char *primary;\n    char *name;\n    gboolean success;\n\n    success = TRUE;\n    error = NULL;\n    if (!g_volume_mount_finish (G_VOLUME (source_object), res, &error))\n    {\n        if (error->code != G_IO_ERROR_FAILED_HANDLED &&\n            error->code != G_IO_ERROR_ALREADY_MOUNTED)\n        {\n            GtkWindow *parent;\n\n            parent = gtk_mount_operation_get_parent (GTK_MOUNT_OPERATION (mount_op));\n            name = g_volume_get_name (G_VOLUME (source_object));\n            primary = g_strdup_printf (_(\"Unable to access \u201c%s\u201d\"), name);\n            g_free (name);\n            success = FALSE;\n            eel_show_error_dialog (primary,\n                                   error->message,\n                                   parent);\n            g_free (primary);\n        }\n        g_error_free (error);\n    }\n\n    mount_callback = (NautilusMountCallback)\n                     g_object_get_data (G_OBJECT (mount_op), \"mount-callback\");\n    mount_callback_data_object =\n        g_object_get_data (G_OBJECT (mount_op), \"mount-callback-data\");\n\n    if (mount_callback != NULL)\n    {\n        (*mount_callback)(G_VOLUME (source_object),\n                          success,\n                          mount_callback_data_object);\n\n        if (mount_callback_data_object != NULL)\n        {\n            g_object_weak_unref (mount_callback_data_object,\n                                 mount_callback_data_notify,\n                                 mount_op);\n        }\n    }\n\n    g_object_unref (mount_op);\n}\n\n\nvoid\nnautilus_file_operations_mount_volume (GtkWindow *parent_window,\n                                       GVolume   *volume)\n{\n    nautilus_file_operations_mount_volume_full (parent_window, volume,\n                                                NULL, NULL);\n}\n\nvoid\nnautilus_file_operations_mount_volume_full (GtkWindow             *parent_window,\n                                            GVolume               *volume,\n                                            NautilusMountCallback  mount_callback,\n                                            GObject               *mount_callback_data_object)\n{\n    GMountOperation *mount_op;\n\n    mount_op = gtk_mount_operation_new (parent_window);\n    g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);\n    g_object_set_data (G_OBJECT (mount_op),\n                       \"mount-callback\",\n                       mount_callback);\n\n    if (mount_callback != NULL &&\n        mount_callback_data_object != NULL)\n    {\n        g_object_weak_ref (mount_callback_data_object,\n                           mount_callback_data_notify,\n                           mount_op);\n    }\n    g_object_set_data (G_OBJECT (mount_op),\n                       \"mount-callback-data\",\n                       mount_callback_data_object);\n\n    g_volume_mount (volume, 0, mount_op, NULL, volume_mount_cb, mount_op);\n}\n\nstatic void\nreport_preparing_count_progress (CommonJob  *job,\n                                 SourceInfo *source_info)\n{\n    char *s;\n\n    switch (source_info->op)\n    {\n        default:\n        case OP_KIND_COPY:\n        {\n            s = f (ngettext (\"Preparing to copy %'d file (%S)\",\n                             \"Preparing to copy %'d files (%S)\",\n                             source_info->num_files),\n                   source_info->num_files, source_info->num_bytes);\n        }\n        break;\n\n        case OP_KIND_MOVE:\n        {\n            s = f (ngettext (\"Preparing to move %'d file (%S)\",\n                             \"Preparing to move %'d files (%S)\",\n                             source_info->num_files),\n                   source_info->num_files, source_info->num_bytes);\n        }\n        break;\n\n        case OP_KIND_DELETE:\n        {\n            s = f (ngettext (\"Preparing to delete %'d file (%S)\",\n                             \"Preparing to delete %'d files (%S)\",\n                             source_info->num_files),\n                   source_info->num_files, source_info->num_bytes);\n        }\n        break;\n\n        case OP_KIND_TRASH:\n        {\n            s = f (ngettext (\"Preparing to trash %'d file\",\n                             \"Preparing to trash %'d files\",\n                             source_info->num_files),\n                   source_info->num_files);\n        }\n        break;\n\n        case OP_KIND_COMPRESS:\n            s = f (ngettext (\"Preparing to compress %'d file\",\n                             \"Preparing to compress %'d files\",\n                             source_info->num_files),\n                   source_info->num_files);\n    }\n\n    nautilus_progress_info_take_details (job->progress, s);\n    nautilus_progress_info_pulse_progress (job->progress);\n}\n\nstatic void\ncount_file (GFileInfo  *info,\n            CommonJob  *job,\n            SourceInfo *source_info)\n{\n    source_info->num_files += 1;\n    source_info->num_bytes += g_file_info_get_size (info);\n\n    if (source_info->num_files_since_progress++ > 100)\n    {\n        report_preparing_count_progress (job, source_info);\n        source_info->num_files_since_progress = 0;\n    }\n}\n\nstatic char *\nget_scan_primary (OpKind kind)\n{\n    switch (kind)\n    {\n        default:\n        case OP_KIND_COPY:\n        {\n            return f (_(\"Error while copying.\"));\n        }\n\n        case OP_KIND_MOVE:\n        {\n            return f (_(\"Error while moving.\"));\n        }\n\n        case OP_KIND_DELETE:\n        {\n            return f (_(\"Error while deleting.\"));\n        }\n\n        case OP_KIND_TRASH:\n        {\n            return f (_(\"Error while moving files to trash.\"));\n        }\n\n        case OP_KIND_COMPRESS:\n            return f (_(\"Error while compressing files.\"));\n    }\n}\n\nstatic void\nscan_dir (GFile      *dir,\n          SourceInfo *source_info,\n          CommonJob  *job,\n          GQueue     *dirs,\n          GHashTable *scanned)\n{\n    GFileInfo *info;\n    GError *error;\n    GFile *subdir;\n    GFileEnumerator *enumerator;\n    char *primary, *secondary, *details;\n    int response;\n    SourceInfo saved_info;\n\n    saved_info = *source_info;\n\nretry:\n    error = NULL;\n    enumerator = g_file_enumerate_children (dir,\n                                            G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                            job->cancellable,\n                                            &error);\n    if (enumerator)\n    {\n        error = NULL;\n        while ((info = g_file_enumerator_next_file (enumerator, job->cancellable, &error)) != NULL)\n        {\n            g_autoptr (GFile) file = NULL;\n            g_autofree char *file_uri = NULL;\n\n            file = g_file_enumerator_get_child (enumerator, info);\n            file_uri = g_file_get_uri (file);\n\n            if (!g_hash_table_contains (scanned, file_uri))\n            {\n                g_hash_table_add (scanned, g_strdup (file_uri));\n\n                count_file (info, job, source_info);\n\n                if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n                {\n                    subdir = g_file_get_child (dir,\n                                               g_file_info_get_name (info));\n\n                    /* Push to head, since we want depth-first */\n                    g_queue_push_head (dirs, subdir);\n                }\n            }\n            g_object_unref (info);\n        }\n        g_file_enumerator_close (enumerator, job->cancellable, NULL);\n        g_object_unref (enumerator);\n\n        if (error && IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n        }\n        else if (error)\n        {\n            primary = get_scan_primary (source_info->op);\n            details = NULL;\n\n            if (IS_IO_ERROR (error, PERMISSION_DENIED))\n            {\n                secondary = f (_(\"Files in the folder \u201c%B\u201d cannot be handled because you do \"\n                                 \"not have permissions to see them.\"), dir);\n            }\n            else\n            {\n                secondary = f (_(\"There was an error getting information about the files in the folder \u201c%B\u201d.\"), dir);\n                details = error->message;\n            }\n\n            response = run_warning (job,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL, RETRY, SKIP,\n                                    NULL);\n\n            g_error_free (error);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 1)\n            {\n                *source_info = saved_info;\n                goto retry;\n            }\n            else if (response == 2)\n            {\n                skip_readdir_error (job, dir);\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n    }\n    else if (job->skip_all_error)\n    {\n        g_error_free (error);\n        skip_file (job, dir);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        primary = get_scan_primary (source_info->op);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The folder \u201c%B\u201d cannot be handled because you do not have \"\n                             \"permissions to read it.\"), dir);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error reading the folder \u201c%B\u201d.\"), dir);\n            details = error->message;\n        }\n        /* set show_all to TRUE here, as we don't know how many\n         * files we'll end up processing yet.\n         */\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                TRUE,\n                                CANCEL, SKIP_ALL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1 || response == 2)\n        {\n            if (response == 1)\n            {\n                job->skip_all_error = TRUE;\n            }\n            skip_file (job, dir);\n        }\n        else if (response == 3)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n}\n\nstatic void\nscan_file (GFile      *file,\n           SourceInfo *source_info,\n           CommonJob  *job,\n           GHashTable *scanned)\n{\n    GFileInfo *info;\n    GError *error;\n    GQueue *dirs;\n    GFile *dir;\n    char *primary;\n    char *secondary;\n    char *details;\n    int response;\n\n    dirs = g_queue_new ();\n\nretry:\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              job->cancellable,\n                              &error);\n\n    if (info)\n    {\n        g_autofree char *file_uri = NULL;\n\n        file_uri = g_file_get_uri (file);\n        if (!g_hash_table_contains (scanned, file_uri))\n        {\n            g_hash_table_add (scanned, g_strdup (file_uri));\n\n            count_file (info, job, source_info);\n\n            /* trashing operation doesn't recurse */\n            if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY &&\n                source_info->op != OP_KIND_TRASH)\n            {\n                g_queue_push_head (dirs, g_object_ref (file));\n            }\n        }\n        g_object_unref (info);\n    }\n    else if (job->skip_all_error)\n    {\n        g_error_free (error);\n        skip_file (job, file);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        primary = get_scan_primary (source_info->op);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The file \u201c%B\u201d cannot be handled because you do not have \"\n                             \"permissions to read it.\"), file);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error getting information about \u201c%B\u201d.\"), file);\n            details = error->message;\n        }\n        /* set show_all to TRUE here, as we don't know how many\n         * files we'll end up processing yet.\n         */\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                TRUE,\n                                CANCEL, SKIP_ALL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1 || response == 2)\n        {\n            if (response == 1)\n            {\n                job->skip_all_error = TRUE;\n            }\n            skip_file (job, file);\n        }\n        else if (response == 3)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\n    while (!job_aborted (job) &&\n           (dir = g_queue_pop_head (dirs)) != NULL)\n    {\n        scan_dir (dir, source_info, job, dirs, scanned);\n        g_object_unref (dir);\n    }\n\n    /* Free all from queue if we exited early */\n    g_queue_foreach (dirs, (GFunc) g_object_unref, NULL);\n    g_queue_free (dirs);\n}\n\nstatic void\nscan_sources (GList      *files,\n              SourceInfo *source_info,\n              CommonJob  *job,\n              OpKind      kind)\n{\n    GList *l;\n    GFile *file;\n    g_autoptr (GHashTable) scanned = NULL;\n\n    memset (source_info, 0, sizeof (SourceInfo));\n    source_info->op = kind;\n\n    scanned = g_hash_table_new_full (g_str_hash,\n                                     g_str_equal,\n                                     (GDestroyNotify) g_free,\n                                     NULL);\n\n    report_preparing_count_progress (job, source_info);\n\n    for (l = files; l != NULL && !job_aborted (job); l = l->next)\n    {\n        file = l->data;\n\n        scan_file (file,\n                   source_info,\n                   job,\n                   scanned);\n    }\n\n    /* Make sure we report the final count */\n    report_preparing_count_progress (job, source_info);\n}\n\nstatic void\nverify_destination (CommonJob  *job,\n                    GFile      *dest,\n                    char      **dest_fs_id,\n                    goffset     required_size)\n{\n    GFileInfo *info, *fsinfo;\n    GError *error;\n    guint64 free_size;\n    guint64 size_difference;\n    char *primary, *secondary, *details;\n    int response;\n    GFileType file_type;\n    gboolean dest_is_symlink = FALSE;\n\n    if (dest_fs_id)\n    {\n        *dest_fs_id = NULL;\n    }\n\nretry:\n\n    error = NULL;\n    info = g_file_query_info (dest,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                              dest_is_symlink ? G_FILE_QUERY_INFO_NONE : G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              job->cancellable,\n                              &error);\n\n    if (info == NULL)\n    {\n        if (IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n            return;\n        }\n\n        primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"You do not have permissions to access the destination folder.\"));\n        }\n        else\n        {\n            secondary = f (_(\"There was an error getting information about the destination.\"));\n            details = error->message;\n        }\n\n        response = run_error (job,\n                              primary,\n                              secondary,\n                              details,\n                              FALSE,\n                              CANCEL, RETRY,\n                              NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        return;\n    }\n\n    file_type = g_file_info_get_file_type (info);\n    if (!dest_is_symlink && file_type == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n        /* Record that destination is a symlink and do real stat() once again */\n        dest_is_symlink = TRUE;\n        g_object_unref (info);\n        goto retry;\n    }\n\n    if (dest_fs_id)\n    {\n        *dest_fs_id =\n            g_strdup (g_file_info_get_attribute_string (info,\n                                                        G_FILE_ATTRIBUTE_ID_FILESYSTEM));\n    }\n\n    g_object_unref (info);\n\n    if (file_type != G_FILE_TYPE_DIRECTORY)\n    {\n        primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n        secondary = f (_(\"The destination is not a folder.\"));\n\n        run_error (job,\n                   primary,\n                   secondary,\n                   NULL,\n                   FALSE,\n                   CANCEL,\n                   NULL);\n\n        abort_job (job);\n        return;\n    }\n\n    if (dest_is_symlink)\n    {\n        /* We can't reliably statfs() destination if it's a symlink, thus not doing any further checks. */\n        return;\n    }\n\n    fsinfo = g_file_query_filesystem_info (dest,\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_FREE \",\"\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_READONLY,\n                                           job->cancellable,\n                                           NULL);\n    if (fsinfo == NULL)\n    {\n        /* All sorts of things can go wrong getting the fs info (like not supported)\n         * only check these things if the fs returns them\n         */\n        return;\n    }\n\n    if (required_size > 0 &&\n        g_file_info_has_attribute (fsinfo, G_FILE_ATTRIBUTE_FILESYSTEM_FREE))\n    {\n        free_size = g_file_info_get_attribute_uint64 (fsinfo,\n                                                      G_FILE_ATTRIBUTE_FILESYSTEM_FREE);\n\n        if (free_size < required_size)\n        {\n            size_difference = required_size - free_size;\n            primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n            secondary = f (_(\"There is not enough space on the destination. Try to remove files to make space.\"));\n\n            details = f (_(\"%S more space is required to copy to the destination.\"), size_difference);\n\n            response = run_warning (job,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL,\n                                    COPY_FORCE,\n                                    RETRY,\n                                    NULL);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 2)\n            {\n                goto retry;\n            }\n            else if (response == 1)\n            {\n                /* We are forced to copy - just fall through ... */\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n    }\n\n    if (!job_aborted (job) &&\n        g_file_info_get_attribute_boolean (fsinfo,\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_READONLY))\n    {\n        primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n        secondary = f (_(\"The destination is read-only.\"));\n\n        run_error (job,\n                   primary,\n                   secondary,\n                   NULL,\n                   FALSE,\n                   CANCEL,\n                   NULL);\n\n        g_error_free (error);\n\n        abort_job (job);\n    }\n\n    g_object_unref (fsinfo);\n}\n\nstatic void\nreport_copy_progress (CopyMoveJob  *copy_job,\n                      SourceInfo   *source_info,\n                      TransferInfo *transfer_info)\n{\n    int files_left;\n    goffset total_size;\n    double elapsed, transfer_rate;\n    int remaining_time;\n    guint64 now;\n    CommonJob *job;\n    gboolean is_move;\n    gchar *status;\n    char *details;\n\n    job = (CommonJob *) copy_job;\n\n    is_move = copy_job->is_move;\n\n    now = g_get_monotonic_time ();\n\n    files_left = source_info->num_files - transfer_info->num_files;\n\n    /* Races and whatnot could cause this to be negative... */\n    if (files_left < 0)\n    {\n        files_left = 0;\n    }\n\n    /* If the number of files left is 0, we want to update the status without\n     * considering this time, since we want to change the status to completed\n     * and probably we won't get more calls to this function */\n    if (transfer_info->last_report_time != 0 &&\n        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&\n        files_left > 0)\n    {\n        return;\n    }\n    transfer_info->last_report_time = now;\n\n    if (files_left != transfer_info->last_reported_files_left ||\n        transfer_info->last_reported_files_left == 0)\n    {\n        /* Avoid changing this unless files_left changed since last time */\n        transfer_info->last_reported_files_left = files_left;\n\n        if (source_info->num_files == 1)\n        {\n            if (copy_job->destination != NULL)\n            {\n                if (is_move)\n                {\n                    if (files_left > 0)\n                    {\n                        status = _(\"Moving \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                    else\n                    {\n                        status = _(\"Moved \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                }\n                else\n                {\n                    if (files_left > 0)\n                    {\n                        status = _(\"Copying \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                    else\n                    {\n                        status = _(\"Copied \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                }\n                nautilus_progress_info_take_status (job->progress,\n                                                    f (status,\n                                                       copy_job->fake_display_source != NULL ?\n                                                       copy_job->fake_display_source :\n                                                       (GFile *) copy_job->files->data,\n                                                       copy_job->destination));\n            }\n            else\n            {\n                if (files_left > 0)\n                {\n                    status = _(\"Duplicating \u201c%B\u201d\");\n                }\n                else\n                {\n                    status = _(\"Duplicated \u201c%B\u201d\");\n                }\n                nautilus_progress_info_take_status (job->progress,\n                                                    f (status,\n                                                       (GFile *) copy_job->files->data));\n            }\n        }\n        else if (copy_job->files != NULL)\n        {\n            if (copy_job->destination != NULL)\n            {\n                if (files_left > 0)\n                {\n                    if (is_move)\n                    {\n                        status = ngettext (\"Moving %'d file to \u201c%B\u201d\",\n                                           \"Moving %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    else\n                    {\n                        status = ngettext (\"Copying %'d file to \u201c%B\u201d\",\n                                           \"Copying %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           (GFile *) copy_job->destination));\n                }\n                else\n                {\n                    if (is_move)\n                    {\n                        status = ngettext (\"Moved %'d file to \u201c%B\u201d\",\n                                           \"Moved %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    else\n                    {\n                        status = ngettext (\"Copied %'d file to \u201c%B\u201d\",\n                                           \"Copied %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           (GFile *) copy_job->destination));\n                }\n            }\n            else\n            {\n                GFile *parent;\n\n                parent = g_file_get_parent (copy_job->files->data);\n                if (files_left > 0)\n                {\n                    status = ngettext (\"Duplicating %'d file in \u201c%B\u201d\",\n                                       \"Duplicating %'d files in \u201c%B\u201d\",\n                                       source_info->num_files);\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           parent));\n                }\n                else\n                {\n                    status = ngettext (\"Duplicated %'d file in \u201c%B\u201d\",\n                                       \"Duplicated %'d files in \u201c%B\u201d\",\n                                       source_info->num_files);\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           parent));\n                }\n                g_object_unref (parent);\n            }\n        }\n    }\n\n    total_size = MAX (source_info->num_bytes, transfer_info->num_bytes);\n\n    elapsed = g_timer_elapsed (job->time, NULL);\n    transfer_rate = 0;\n    remaining_time = INT_MAX;\n    if (elapsed > 0)\n    {\n        transfer_rate = transfer_info->num_bytes / elapsed;\n        if (transfer_rate > 0)\n        {\n            remaining_time = (total_size - transfer_info->num_bytes) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE &&\n        transfer_rate > 0)\n    {\n        if (source_info->num_files == 1)\n        {\n            /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", so something like \"4 kb / 4 MB\" */\n            details = f (_(\"%S / %S\"), transfer_info->num_bytes, total_size);\n        }\n        else\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             transfer_info->num_files + 1,\n                             source_info->num_files);\n            }\n            else\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             transfer_info->num_files,\n                             source_info->num_files);\n            }\n        }\n    }\n    else\n    {\n        if (source_info->num_files == 1)\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", %T to a time duration like\n                 * \"2 minutes\". So the whole thing will be something like \"2 kb / 4 MB -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             transfer_info->num_bytes, total_size,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\". */\n                details = f (_(\"%S / %S\"),\n                             transfer_info->num_bytes,\n                             total_size);\n            }\n        }\n        else\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %T will expand to a time duration like \"2 minutes\".\n                 * So the whole thing will be something like \"1 / 5 -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             transfer_info->num_files + 1, source_info->num_files,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             transfer_info->num_files,\n                             source_info->num_files);\n            }\n        }\n    }\n    nautilus_progress_info_take_details (job->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (job->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (job->progress,\n                                                 elapsed);\n    }\n\n    nautilus_progress_info_set_progress (job->progress, transfer_info->num_bytes, total_size);\n}\n\nstatic int\nget_max_name_length (GFile *file_dir)\n{\n    int max_length;\n    char *dir;\n    long max_path;\n    long max_name;\n\n    max_length = -1;\n\n    if (!g_file_has_uri_scheme (file_dir, \"file\"))\n    {\n        return max_length;\n    }\n\n    dir = g_file_get_path (file_dir);\n    if (!dir)\n    {\n        return max_length;\n    }\n\n    max_path = pathconf (dir, _PC_PATH_MAX);\n    max_name = pathconf (dir, _PC_NAME_MAX);\n\n    if (max_name == -1 && max_path == -1)\n    {\n        max_length = -1;\n    }\n    else if (max_name == -1 && max_path != -1)\n    {\n        max_length = max_path - (strlen (dir) + 1);\n    }\n    else if (max_name != -1 && max_path == -1)\n    {\n        max_length = max_name;\n    }\n    else\n    {\n        int leftover;\n\n        leftover = max_path - (strlen (dir) + 1);\n\n        max_length = MIN (leftover, max_name);\n    }\n\n    g_free (dir);\n\n    return max_length;\n}\n\n#define FAT_FORBIDDEN_CHARACTERS \"/:;*?\\\"<>\"\n\nstatic gboolean\nfat_str_replace (char *str,\n                 char  replacement)\n{\n    gboolean success;\n    int i;\n\n    success = FALSE;\n    for (i = 0; str[i] != '\\0'; i++)\n    {\n        if (strchr (FAT_FORBIDDEN_CHARACTERS, str[i]) ||\n            str[i] < 32)\n        {\n            success = TRUE;\n            str[i] = replacement;\n        }\n    }\n\n    return success;\n}\n\nstatic gboolean\nmake_file_name_valid_for_dest_fs (char       *filename,\n                                  const char *dest_fs_type)\n{\n    if (dest_fs_type != NULL && filename != NULL)\n    {\n        if (!strcmp (dest_fs_type, \"fat\") ||\n            !strcmp (dest_fs_type, \"vfat\") ||\n            !strcmp (dest_fs_type, \"msdos\") ||\n            !strcmp (dest_fs_type, \"msdosfs\"))\n        {\n            gboolean ret;\n            int i, old_len;\n\n            ret = fat_str_replace (filename, '_');\n\n            old_len = strlen (filename);\n            for (i = 0; i < old_len; i++)\n            {\n                if (filename[i] != ' ')\n                {\n                    g_strchomp (filename);\n                    ret |= (old_len != strlen (filename));\n                    break;\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    return FALSE;\n}\n\nstatic GFile *\nget_unique_target_file (GFile      *src,\n                        GFile      *dest_dir,\n                        gboolean    same_fs,\n                        const char *dest_fs_type,\n                        int         count)\n{\n    const char *editname, *end;\n    char *basename, *new_name;\n    GFileInfo *info;\n    GFile *dest;\n    int max_length;\n\n    max_length = get_max_name_length (dest_dir);\n\n    dest = NULL;\n    info = g_file_query_info (src,\n                              G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,\n                              0, NULL, NULL);\n    if (info != NULL)\n    {\n        editname = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME);\n\n        if (editname != NULL)\n        {\n            new_name = get_duplicate_name (editname, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        g_object_unref (info);\n    }\n\n    if (dest == NULL)\n    {\n        basename = g_file_get_basename (src);\n\n        if (g_utf8_validate (basename, -1, NULL))\n        {\n            new_name = get_duplicate_name (basename, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        if (dest == NULL)\n        {\n            end = strrchr (basename, '.');\n            if (end != NULL)\n            {\n                count += atoi (end + 1);\n            }\n            new_name = g_strdup_printf (\"%s.%d\", basename, count);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child (dest_dir, new_name);\n            g_free (new_name);\n        }\n\n        g_free (basename);\n    }\n\n    return dest;\n}\n\nstatic GFile *\nget_target_file_for_link (GFile      *src,\n                          GFile      *dest_dir,\n                          const char *dest_fs_type,\n                          int         count)\n{\n    const char *editname;\n    char *basename, *new_name;\n    GFileInfo *info;\n    GFile *dest;\n    int max_length;\n\n    max_length = get_max_name_length (dest_dir);\n\n    dest = NULL;\n    info = g_file_query_info (src,\n                              G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,\n                              0, NULL, NULL);\n    if (info != NULL)\n    {\n        editname = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME);\n\n        if (editname != NULL)\n        {\n            new_name = get_link_name (editname, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        g_object_unref (info);\n    }\n\n    if (dest == NULL)\n    {\n        basename = g_file_get_basename (src);\n        make_file_name_valid_for_dest_fs (basename, dest_fs_type);\n\n        if (g_utf8_validate (basename, -1, NULL))\n        {\n            new_name = get_link_name (basename, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        if (dest == NULL)\n        {\n            if (count == 1)\n            {\n                new_name = g_strdup_printf (\"%s.lnk\", basename);\n            }\n            else\n            {\n                new_name = g_strdup_printf (\"%s.lnk%d\", basename, count);\n            }\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child (dest_dir, new_name);\n            g_free (new_name);\n        }\n\n        g_free (basename);\n    }\n\n    return dest;\n}\n\nstatic GFile *\nget_target_file_with_custom_name (GFile       *src,\n                                  GFile       *dest_dir,\n                                  const char  *dest_fs_type,\n                                  gboolean     same_fs,\n                                  const gchar *custom_name)\n{\n    char *basename;\n    GFile *dest;\n    GFileInfo *info;\n    char *copyname;\n\n    dest = NULL;\n\n    if (custom_name != NULL)\n    {\n        copyname = g_strdup (custom_name);\n        make_file_name_valid_for_dest_fs (copyname, dest_fs_type);\n        dest = g_file_get_child_for_display_name (dest_dir, copyname, NULL);\n\n        g_free (copyname);\n    }\n\n    if (dest == NULL && !same_fs)\n    {\n        info = g_file_query_info (src,\n                                  G_FILE_ATTRIBUTE_STANDARD_COPY_NAME \",\"\n                                  G_FILE_ATTRIBUTE_TRASH_ORIG_PATH,\n                                  0, NULL, NULL);\n\n        if (info)\n        {\n            copyname = NULL;\n\n            /* if file is being restored from trash make sure it uses its original name */\n            if (g_file_has_uri_scheme (src, \"trash\"))\n            {\n                copyname = g_path_get_basename (g_file_info_get_attribute_byte_string (info, G_FILE_ATTRIBUTE_TRASH_ORIG_PATH));\n            }\n\n            if (copyname == NULL)\n            {\n                copyname = g_strdup (g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_COPY_NAME));\n            }\n\n            if (copyname)\n            {\n                make_file_name_valid_for_dest_fs (copyname, dest_fs_type);\n                dest = g_file_get_child_for_display_name (dest_dir, copyname, NULL);\n                g_free (copyname);\n            }\n\n            g_object_unref (info);\n        }\n    }\n\n    if (dest == NULL)\n    {\n        basename = g_file_get_basename (src);\n        make_file_name_valid_for_dest_fs (basename, dest_fs_type);\n        dest = g_file_get_child (dest_dir, basename);\n        g_free (basename);\n    }\n\n    return dest;\n}\n\nstatic GFile *\nget_target_file (GFile      *src,\n                 GFile      *dest_dir,\n                 const char *dest_fs_type,\n                 gboolean    same_fs)\n{\n    return get_target_file_with_custom_name (src, dest_dir, dest_fs_type, same_fs, NULL);\n}\n\nstatic gboolean\nhas_fs_id (GFile      *file,\n           const char *fs_id)\n{\n    const char *id;\n    GFileInfo *info;\n    gboolean res;\n\n    res = FALSE;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              NULL, NULL);\n\n    if (info)\n    {\n        id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);\n\n        if (id && strcmp (id, fs_id) == 0)\n        {\n            res = TRUE;\n        }\n\n        g_object_unref (info);\n    }\n\n    return res;\n}\n\nstatic gboolean\nis_dir (GFile *file)\n{\n    GFileInfo *info;\n    gboolean res;\n\n    res = FALSE;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              NULL, NULL);\n    if (info)\n    {\n        res = g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY;\n        g_object_unref (info);\n    }\n\n    return res;\n}\n\nstatic GFile *\nmap_possibly_volatile_file_to_real (GFile         *volatile_file,\n                                    GCancellable  *cancellable,\n                                    GError       **error)\n{\n    GFile *real_file = NULL;\n    GFileInfo *info = NULL;\n\n    info = g_file_query_info (volatile_file,\n                              G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              cancellable,\n                              error);\n    if (info == NULL)\n    {\n        return NULL;\n    }\n    else\n    {\n        gboolean is_volatile;\n\n        is_volatile = g_file_info_get_attribute_boolean (info,\n                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);\n        if (is_volatile)\n        {\n            const gchar *target;\n\n            target = g_file_info_get_symlink_target (info);\n            real_file = g_file_resolve_relative_path (volatile_file, target);\n        }\n    }\n\n    g_object_unref (info);\n\n    if (real_file == NULL)\n    {\n        real_file = g_object_ref (volatile_file);\n    }\n\n    return real_file;\n}\n\nstatic GFile *\nmap_possibly_volatile_file_to_real_on_write (GFile              *volatile_file,\n                                             GFileOutputStream  *stream,\n                                             GCancellable       *cancellable,\n                                             GError            **error)\n{\n    GFile *real_file = NULL;\n    GFileInfo *info = NULL;\n\n    info = g_file_output_stream_query_info (stream,\n                                            G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                            cancellable,\n                                            error);\n    if (info == NULL)\n    {\n        return NULL;\n    }\n    else\n    {\n        gboolean is_volatile;\n\n        is_volatile = g_file_info_get_attribute_boolean (info,\n                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);\n        if (is_volatile)\n        {\n            const gchar *target;\n\n            target = g_file_info_get_symlink_target (info);\n            real_file = g_file_resolve_relative_path (volatile_file, target);\n        }\n    }\n\n    g_object_unref (info);\n\n    if (real_file == NULL)\n    {\n        real_file = g_object_ref (volatile_file);\n    }\n\n    return real_file;\n}\n\nstatic void copy_move_file (CopyMoveJob  *job,\n                            GFile        *src,\n                            GFile        *dest_dir,\n                            gboolean      same_fs,\n                            gboolean      unique_names,\n                            char        **dest_fs_type,\n                            SourceInfo   *source_info,\n                            TransferInfo *transfer_info,\n                            GHashTable   *debuting_files,\n                            GdkPoint     *point,\n                            gboolean      overwrite,\n                            gboolean     *skipped_file,\n                            gboolean      readonly_source_fs);\n\ntypedef enum\n{\n    CREATE_DEST_DIR_RETRY,\n    CREATE_DEST_DIR_FAILED,\n    CREATE_DEST_DIR_SUCCESS\n} CreateDestDirResult;\n\nstatic CreateDestDirResult\ncreate_dest_dir (CommonJob  *job,\n                 GFile      *src,\n                 GFile     **dest,\n                 gboolean    same_fs,\n                 char      **dest_fs_type)\n{\n    GError *error;\n    GFile *new_dest, *dest_dir;\n    char *primary, *secondary, *details;\n    int response;\n    gboolean handled_invalid_filename;\n    gboolean res;\n\n    handled_invalid_filename = *dest_fs_type != NULL;\n\nretry:\n    /* First create the directory, then copy stuff to it before\n     *  copying the attributes, because we need to be sure we can write to it */\n\n    error = NULL;\n    res = g_file_make_directory (*dest, job->cancellable, &error);\n\n    if (res)\n    {\n        GFile *real;\n\n        real = map_possibly_volatile_file_to_real (*dest, job->cancellable, &error);\n        if (real == NULL)\n        {\n            res = FALSE;\n        }\n        else\n        {\n            g_object_unref (*dest);\n            *dest = real;\n        }\n    }\n\n    if (!res)\n    {\n        if (IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n            return CREATE_DEST_DIR_FAILED;\n        }\n        else if (IS_IO_ERROR (error, INVALID_FILENAME) &&\n                 !handled_invalid_filename)\n        {\n            handled_invalid_filename = TRUE;\n\n            g_assert (*dest_fs_type == NULL);\n\n            dest_dir = g_file_get_parent (*dest);\n\n            if (dest_dir != NULL)\n            {\n                *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n                new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n                g_object_unref (dest_dir);\n\n                if (!g_file_equal (*dest, new_dest))\n                {\n                    g_object_unref (*dest);\n                    *dest = new_dest;\n                    g_error_free (error);\n                    return CREATE_DEST_DIR_RETRY;\n                }\n                else\n                {\n                    g_object_unref (new_dest);\n                }\n            }\n        }\n\n        primary = f (_(\"Error while copying.\"));\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The folder \u201c%B\u201d cannot be copied because you do not have \"\n                             \"permissions to create it in the destination.\"), src);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error creating the folder \u201c%B\u201d.\"), src);\n            details = error->message;\n        }\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                FALSE,\n                                CANCEL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)\n        {\n            /* Skip: Do Nothing  */\n        }\n        else if (response == 2)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n        return CREATE_DEST_DIR_FAILED;\n    }\n    nautilus_file_changes_queue_file_added (*dest);\n\n    if (job->undo_info != NULL)\n    {\n        nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                            src, *dest);\n    }\n\n    return CREATE_DEST_DIR_SUCCESS;\n}\n\n/* a return value of FALSE means retry, i.e.\n * the destination has changed and the source\n * is expected to re-try the preceding\n * g_file_move() or g_file_copy() call with\n * the new destination.\n */\nstatic gboolean\ncopy_move_directory (CopyMoveJob   *copy_job,\n                     GFile         *src,\n                     GFile        **dest,\n                     gboolean       same_fs,\n                     gboolean       create_dest,\n                     char         **parent_dest_fs_type,\n                     SourceInfo    *source_info,\n                     TransferInfo  *transfer_info,\n                     GHashTable    *debuting_files,\n                     gboolean      *skipped_file,\n                     gboolean       readonly_source_fs)\n{\n    GFileInfo *info;\n    GError *error;\n    GFile *src_file;\n    GFileEnumerator *enumerator;\n    char *primary, *secondary, *details;\n    char *dest_fs_type;\n    int response;\n    gboolean skip_error;\n    gboolean local_skipped_file;\n    CommonJob *job;\n    GFileCopyFlags flags;\n\n    job = (CommonJob *) copy_job;\n\n    if (create_dest)\n    {\n        switch (create_dest_dir (job, src, dest, same_fs, parent_dest_fs_type))\n        {\n            case CREATE_DEST_DIR_RETRY:\n            {\n                /* next time copy_move_directory() is called,\n                 * create_dest will be FALSE if a directory already\n                 * exists under the new name (i.e. WOULD_RECURSE)\n                 */\n                return FALSE;\n            }\n\n            case CREATE_DEST_DIR_FAILED:\n            {\n                *skipped_file = TRUE;\n                return TRUE;\n            }\n\n            case CREATE_DEST_DIR_SUCCESS:\n            default:\n            {\n            }\n            break;\n        }\n\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (*dest), GINT_TO_POINTER (TRUE));\n        }\n    }\n\n    local_skipped_file = FALSE;\n    dest_fs_type = NULL;\n\n    skip_error = should_skip_readdir_error (job, src);\nretry:\n    error = NULL;\n    enumerator = g_file_enumerate_children (src,\n                                            G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                            job->cancellable,\n                                            &error);\n    if (enumerator)\n    {\n        error = NULL;\n\n        while (!job_aborted (job) &&\n               (info = g_file_enumerator_next_file (enumerator, job->cancellable, skip_error ? NULL : &error)) != NULL)\n        {\n            src_file = g_file_get_child (src,\n                                         g_file_info_get_name (info));\n            copy_move_file (copy_job, src_file, *dest, same_fs, FALSE, &dest_fs_type,\n                            source_info, transfer_info, NULL, NULL, FALSE, &local_skipped_file,\n                            readonly_source_fs);\n\n            if (local_skipped_file)\n            {\n                transfer_add_file_to_count (src_file, job, transfer_info);\n                report_copy_progress (copy_job, source_info, transfer_info);\n            }\n\n            g_object_unref (src_file);\n            g_object_unref (info);\n        }\n        g_file_enumerator_close (enumerator, job->cancellable, NULL);\n        g_object_unref (enumerator);\n\n        if (error && IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n        }\n        else if (error)\n        {\n            if (copy_job->is_move)\n            {\n                primary = f (_(\"Error while moving.\"));\n            }\n            else\n            {\n                primary = f (_(\"Error while copying.\"));\n            }\n            details = NULL;\n\n            if (IS_IO_ERROR (error, PERMISSION_DENIED))\n            {\n                secondary = f (_(\"Files in the folder \u201c%B\u201d cannot be copied because you do \"\n                                 \"not have permissions to see them.\"), src);\n            }\n            else\n            {\n                secondary = f (_(\"There was an error getting information about the files in the folder \u201c%B\u201d.\"), src);\n                details = error->message;\n            }\n\n            response = run_warning (job,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL, _(\"_Skip files\"),\n                                    NULL);\n\n            g_error_free (error);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 1)\n            {\n                /* Skip: Do Nothing */\n                local_skipped_file = TRUE;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n\n        /* Count the copied directory as a file */\n        transfer_info->num_files++;\n        report_copy_progress (copy_job, source_info, transfer_info);\n\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (*dest), GINT_TO_POINTER (create_dest));\n        }\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        if (copy_job->is_move)\n        {\n            primary = f (_(\"Error while moving.\"));\n        }\n        else\n        {\n            primary = f (_(\"Error while copying.\"));\n        }\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The folder \u201c%B\u201d cannot be copied because you do not have \"\n                             \"permissions to read it.\"), src);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error reading the folder \u201c%B\u201d.\"), src);\n            details = error->message;\n        }\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                FALSE,\n                                CANCEL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)\n        {\n            /* Skip: Do Nothing  */\n            local_skipped_file = TRUE;\n        }\n        else if (response == 2)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\n    if (create_dest)\n    {\n        flags = (readonly_source_fs) ? G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_TARGET_DEFAULT_PERMS\n                : G_FILE_COPY_NOFOLLOW_SYMLINKS;\n        /* Ignore errors here. Failure to copy metadata is not a hard error */\n        g_file_copy_attributes (src, *dest,\n                                flags,\n                                job->cancellable, NULL);\n    }\n\n    if (!job_aborted (job) && copy_job->is_move &&\n        /* Don't delete source if there was a skipped file */\n        !local_skipped_file)\n    {\n        if (!g_file_delete (src, job->cancellable, &error))\n        {\n            if (job->skip_all_error)\n            {\n                goto skip;\n            }\n            primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n            secondary = f (_(\"Could not remove the source folder.\"));\n            details = error->message;\n\n            response = run_cancel_or_skip_warning (job,\n                                                   primary,\n                                                   secondary,\n                                                   details,\n                                                   source_info->num_files,\n                                                   source_info->num_files - transfer_info->num_files);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 1)                 /* skip all */\n            {\n                job->skip_all_error = TRUE;\n                local_skipped_file = TRUE;\n            }\n            else if (response == 2)                 /* skip */\n            {\n                local_skipped_file = TRUE;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\nskip:\n            g_error_free (error);\n        }\n    }\n\n    if (local_skipped_file)\n    {\n        *skipped_file = TRUE;\n    }\n\n    g_free (dest_fs_type);\n    return TRUE;\n}\n\n\ntypedef struct\n{\n    CommonJob *job;\n    GFile *source;\n} DeleteExistingFileData;\n\nstatic void\nexisting_file_removed_callback (GFile    *file,\n                                GError   *error,\n                                gpointer  callback_data)\n{\n    DeleteExistingFileData *data = callback_data;\n    CommonJob *job;\n    GFile *source;\n    GFileType file_type;\n    char *primary;\n    char *secondary;\n    char *details = NULL;\n    int response;\n\n    job = data->job;\n    source = data->source;\n\n    if (error == NULL)\n    {\n        nautilus_file_changes_queue_file_removed (file);\n\n        return;\n    }\n\n    if (job_aborted (job) || job->skip_all_error)\n    {\n        return;\n    }\n\n    primary = f (_(\"Error while copying \u201c%B\u201d.\"), source);\n\n    file_type = g_file_query_file_type (file,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        job->cancellable);\n\n    if (file_type == G_FILE_TYPE_DIRECTORY)\n    {\n        secondary = f (_(\"Could not remove the already existing folder %F.\"),\n                       file);\n    }\n    else\n    {\n        secondary = f (_(\"Could not remove the already existing file %F.\"),\n                       file);\n    }\n\n    details = error->message;\n\n    /* set show_all to TRUE here, as we don't know how many\n     * files we'll end up processing yet.\n     */\n    response = run_warning (job,\n                            primary,\n                            secondary,\n                            details,\n                            TRUE,\n                            CANCEL, SKIP_ALL, SKIP,\n                            NULL);\n\n    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n    {\n        abort_job (job);\n    }\n    else if (response == 1)\n    {\n        /* skip all */\n        job->skip_all_error = TRUE;\n    }\n}\n\ntypedef struct\n{\n    CopyMoveJob *job;\n    goffset last_size;\n    SourceInfo *source_info;\n    TransferInfo *transfer_info;\n} ProgressData;\n\nstatic void\ncopy_file_progress_callback (goffset  current_num_bytes,\n                             goffset  total_num_bytes,\n                             gpointer user_data)\n{\n    ProgressData *pdata;\n    goffset new_size;\n\n    pdata = user_data;\n\n    new_size = current_num_bytes - pdata->last_size;\n\n    if (new_size > 0)\n    {\n        pdata->transfer_info->num_bytes += new_size;\n        pdata->last_size = current_num_bytes;\n        report_copy_progress (pdata->job,\n                              pdata->source_info,\n                              pdata->transfer_info);\n    }\n}\n\nstatic gboolean\ntest_dir_is_parent (GFile *child,\n                    GFile *root)\n{\n    GFile *f, *tmp;\n\n    f = g_file_dup (child);\n    while (f)\n    {\n        if (g_file_equal (f, root))\n        {\n            g_object_unref (f);\n            return TRUE;\n        }\n        tmp = f;\n        f = g_file_get_parent (f);\n        g_object_unref (tmp);\n    }\n    if (f)\n    {\n        g_object_unref (f);\n    }\n    return FALSE;\n}\n\nstatic char *\nquery_fs_type (GFile        *file,\n               GCancellable *cancellable)\n{\n    GFileInfo *fsinfo;\n    char *ret;\n\n    ret = NULL;\n\n    fsinfo = g_file_query_filesystem_info (file,\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,\n                                           cancellable,\n                                           NULL);\n    if (fsinfo != NULL)\n    {\n        ret = g_strdup (g_file_info_get_attribute_string (fsinfo, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE));\n        g_object_unref (fsinfo);\n    }\n\n    if (ret == NULL)\n    {\n        /* ensure that we don't attempt to query\n         * the FS type for each file in a given\n         * directory, if it can't be queried. */\n        ret = g_strdup (\"\");\n    }\n\n    return ret;\n}\n\nstatic gboolean\nis_trusted_desktop_file (GFile        *file,\n                         GCancellable *cancellable)\n{\n    char *basename;\n    gboolean res;\n    GFileInfo *info;\n\n    /* Don't trust non-local files */\n    if (!g_file_is_native (file))\n    {\n        return FALSE;\n    }\n\n    basename = g_file_get_basename (file);\n    if (!g_str_has_suffix (basename, \".desktop\"))\n    {\n        g_free (basename);\n        return FALSE;\n    }\n    g_free (basename);\n\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              cancellable,\n                              NULL);\n\n    if (info == NULL)\n    {\n        return FALSE;\n    }\n\n    res = FALSE;\n\n    /* Weird file => not trusted,\n     *  Already executable => no need to mark trusted */\n    if (g_file_info_get_file_type (info) == G_FILE_TYPE_REGULAR &&\n        !g_file_info_get_attribute_boolean (info,\n                                            G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE) &&\n        nautilus_is_in_system_dir (file))\n    {\n        res = TRUE;\n    }\n    g_object_unref (info);\n\n    return res;\n}\n\nstatic FileConflictResponse *\nhandle_copy_move_conflict (CommonJob *job,\n                           GFile     *src,\n                           GFile     *dest,\n                           GFile     *dest_dir)\n{\n    FileConflictResponse *response;\n\n    g_timer_stop (job->time);\n    nautilus_progress_info_pause (job->progress);\n\n    response = copy_move_conflict_ask_user_action (job->parent_window,\n                                                   src,\n                                                   dest,\n                                                   dest_dir);\n\n    nautilus_progress_info_resume (job->progress);\n    g_timer_continue (job->time);\n\n    return response;\n}\n\nstatic GFile *\nget_target_file_for_display_name (GFile       *dir,\n                                  const gchar *name)\n{\n    GFile *dest;\n\n    dest = NULL;\n    dest = g_file_get_child_for_display_name (dir, name, NULL);\n\n    if (dest == NULL)\n    {\n        dest = g_file_get_child (dir, name);\n    }\n\n    return dest;\n}\n\n/* Debuting files is non-NULL only for toplevel items */\nstatic void\ncopy_move_file (CopyMoveJob   *copy_job,\n                GFile         *src,\n                GFile         *dest_dir,\n                gboolean       same_fs,\n                gboolean       unique_names,\n                char         **dest_fs_type,\n                SourceInfo    *source_info,\n                TransferInfo  *transfer_info,\n                GHashTable    *debuting_files,\n                GdkPoint      *position,\n                gboolean       overwrite,\n                gboolean      *skipped_file,\n                gboolean       readonly_source_fs)\n{\n    GFile *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    GError *error;\n    GFileCopyFlags flags;\n    char *primary, *secondary, *details;\n    int response;\n    ProgressData pdata;\n    gboolean would_recurse, is_merge;\n    CommonJob *job;\n    gboolean res;\n    int unique_name_nr;\n    gboolean handled_invalid_filename;\n\n    job = (CommonJob *) copy_job;\n\n    if (should_skip_file (job, src))\n    {\n        *skipped_file = TRUE;\n        return;\n    }\n\n    unique_name_nr = 1;\n\n    /* another file in the same directory might have handled the invalid\n     * filename condition for us\n     */\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    if (unique_names)\n    {\n        dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n    }\n    else if (copy_job->target_name != NULL)\n    {\n        dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,\n                                                 copy_job->target_name);\n    }\n    else\n    {\n        dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n    }\n\n    /* Don't allow recursive move/copy into itself.\n     * (We would get a file system error if we proceeded but it is nicer to\n     * detect and report it at this level) */\n    if (test_dir_is_parent (dest_dir, src))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = copy_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n                  : g_strdup (_(\"You cannot copy a folder into itself.\"));\n        secondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               NULL,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n    /* Don't allow copying over the source or one of the parents of the source.\n     */\n    if (test_dir_is_parent (src, dest))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = copy_job->is_move ? g_strdup (_(\"You cannot move a file over itself.\"))\n                  : g_strdup (_(\"You cannot copy a file over itself.\"));\n        secondary = g_strdup (_(\"The source file would be overwritten by the destination.\"));\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               NULL,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\nretry:\n\n    error = NULL;\n    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;\n    if (overwrite)\n    {\n        flags |= G_FILE_COPY_OVERWRITE;\n    }\n    if (readonly_source_fs)\n    {\n        flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;\n    }\n\n    pdata.job = copy_job;\n    pdata.last_size = 0;\n    pdata.source_info = source_info;\n    pdata.transfer_info = transfer_info;\n\n    if (copy_job->is_move)\n    {\n        res = g_file_move (src, dest,\n                           flags,\n                           job->cancellable,\n                           copy_file_progress_callback,\n                           &pdata,\n                           &error);\n    }\n    else\n    {\n        res = g_file_copy (src, dest,\n                           flags,\n                           job->cancellable,\n                           copy_file_progress_callback,\n                           &pdata,\n                           &error);\n    }\n\n    if (res)\n    {\n        GFile *real;\n\n        real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);\n        if (real == NULL)\n        {\n            res = FALSE;\n        }\n        else\n        {\n            g_object_unref (dest);\n            dest = real;\n        }\n    }\n\n    if (res)\n    {\n        transfer_info->num_files++;\n        report_copy_progress (copy_job, source_info, transfer_info);\n\n        if (debuting_files)\n        {\n            dest_uri = g_file_get_uri (dest);\n            if (position)\n            {\n                nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n            }\n            else if (eel_uri_is_desktop (dest_uri))\n            {\n                nautilus_file_changes_queue_schedule_position_remove (dest);\n            }\n\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n        if (copy_job->is_move)\n        {\n            nautilus_file_changes_queue_file_moved (src, dest);\n        }\n        else\n        {\n            nautilus_file_changes_queue_file_added (dest);\n        }\n\n        /* If copying a trusted desktop file to the desktop,\n         *  mark it as trusted. */\n        if (copy_job->desktop_location != NULL &&\n            g_file_equal (copy_job->desktop_location, dest_dir) &&\n            is_trusted_desktop_file (src, job->cancellable))\n        {\n            mark_desktop_file_trusted (job,\n                                       job->cancellable,\n                                       dest,\n                                       FALSE);\n        }\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                                src, dest);\n        }\n\n        g_object_unref (dest);\n        return;\n    }\n\n    if (!handled_invalid_filename &&\n        IS_IO_ERROR (error, INVALID_FILENAME))\n    {\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n        if (unique_names)\n        {\n            new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);\n        }\n        else\n        {\n            new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n        }\n\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n\n            g_error_free (error);\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n\n    /* Conflict */\n    if (!overwrite &&\n        IS_IO_ERROR (error, EXISTS))\n    {\n        gboolean is_merge;\n        FileConflictResponse *response;\n\n        g_error_free (error);\n\n        if (unique_names)\n        {\n            g_object_unref (dest);\n            dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n            goto retry;\n        }\n\n        is_merge = FALSE;\n\n        if (is_dir (dest) && is_dir (src))\n        {\n            is_merge = TRUE;\n        }\n\n        if ((is_merge && job->merge_all) ||\n            (!is_merge && job->replace_all))\n        {\n            overwrite = TRUE;\n            goto retry;\n        }\n\n        if (job->skip_all_conflict)\n        {\n            goto out;\n        }\n\n        response = handle_copy_move_conflict (job, src, dest, dest_dir);\n\n        if (response->id == GTK_RESPONSE_CANCEL ||\n            response->id == GTK_RESPONSE_DELETE_EVENT)\n        {\n            file_conflict_response_free (response);\n            abort_job (job);\n        }\n        else if (response->id == CONFLICT_RESPONSE_SKIP)\n        {\n            if (response->apply_to_all)\n            {\n                job->skip_all_conflict = TRUE;\n            }\n            file_conflict_response_free (response);\n        }\n        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */\n        {\n            if (response->apply_to_all)\n            {\n                if (is_merge)\n                {\n                    job->merge_all = TRUE;\n                }\n                else\n                {\n                    job->replace_all = TRUE;\n                }\n            }\n            overwrite = TRUE;\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else if (response->id == CONFLICT_RESPONSE_RENAME)\n        {\n            g_object_unref (dest);\n            dest = get_target_file_for_display_name (dest_dir,\n                                                     response->new_name);\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n    else if (overwrite &&\n             IS_IO_ERROR (error, IS_DIRECTORY))\n    {\n        gboolean existing_file_deleted;\n        DeleteExistingFileData data;\n\n        g_error_free (error);\n\n        data.job = job;\n        data.source = src;\n\n        existing_file_deleted =\n            delete_file_recursively (dest,\n                                     job->cancellable,\n                                     existing_file_removed_callback,\n                                     &data);\n\n        if (existing_file_deleted)\n        {\n            goto retry;\n        }\n    }\n    /* Needs to recurse */\n    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n             IS_IO_ERROR (error, WOULD_MERGE))\n    {\n        is_merge = error->code == G_IO_ERROR_WOULD_MERGE;\n        would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;\n        g_error_free (error);\n\n        if (overwrite && would_recurse)\n        {\n            error = NULL;\n\n            /* Copying a dir onto file, first remove the file */\n            if (!g_file_delete (dest, job->cancellable, &error) &&\n                !IS_IO_ERROR (error, NOT_FOUND))\n            {\n                if (job->skip_all_error)\n                {\n                    g_error_free (error);\n                    goto out;\n                }\n                if (copy_job->is_move)\n                {\n                    primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n                }\n                else\n                {\n                    primary = f (_(\"Error while copying \u201c%B\u201d.\"), src);\n                }\n                secondary = f (_(\"Could not remove the already existing file with the same name in %F.\"), dest_dir);\n                details = error->message;\n\n                /* setting TRUE on show_all here, as we could have\n                 * another error on the same file later.\n                 */\n                response = run_warning (job,\n                                        primary,\n                                        secondary,\n                                        details,\n                                        TRUE,\n                                        CANCEL, SKIP_ALL, SKIP,\n                                        NULL);\n\n                g_error_free (error);\n\n                if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n                {\n                    abort_job (job);\n                }\n                else if (response == 1)                     /* skip all */\n                {\n                    job->skip_all_error = TRUE;\n                }\n                else if (response == 2)                     /* skip */\n                {                       /* do nothing */\n                }\n                else\n                {\n                    g_assert_not_reached ();\n                }\n                goto out;\n            }\n            if (error)\n            {\n                g_error_free (error);\n                error = NULL;\n            }\n            nautilus_file_changes_queue_file_removed (dest);\n        }\n\n        if (is_merge)\n        {\n            /* On merge we now write in the target directory, which may not\n             *   be in the same directory as the source, even if the parent is\n             *   (if the merged directory is a mountpoint). This could cause\n             *   problems as we then don't transcode filenames.\n             *   We just set same_fs to FALSE which is safe but a bit slower. */\n            same_fs = FALSE;\n        }\n\n        if (!copy_move_directory (copy_job, src, &dest, same_fs,\n                                  would_recurse, dest_fs_type,\n                                  source_info, transfer_info,\n                                  debuting_files, skipped_file,\n                                  readonly_source_fs))\n        {\n            /* destination changed, since it was an invalid file name */\n            g_assert (*dest_fs_type != NULL);\n            handled_invalid_filename = TRUE;\n            goto retry;\n        }\n\n        g_object_unref (dest);\n        return;\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else\n    {\n        if (job->skip_all_error)\n        {\n            g_error_free (error);\n            goto out;\n        }\n        primary = f (_(\"Error while copying \u201c%B\u201d.\"), src);\n        secondary = f (_(\"There was an error copying the file into %F.\"), dest_dir);\n        details = error->message;\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               details,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\nout:\n    *skipped_file = TRUE;     /* Or aborted, but same-same */\n    g_object_unref (dest);\n}\n\nstatic void\ncopy_files (CopyMoveJob  *job,\n            const char   *dest_fs_id,\n            SourceInfo   *source_info,\n            TransferInfo *transfer_info)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    gboolean skipped_file;\n    gboolean unique_names;\n    GFile *dest;\n    GFile *source_dir;\n    char *dest_fs_type;\n    GFileInfo *inf;\n    gboolean readonly_source_fs;\n\n    dest_fs_type = NULL;\n    readonly_source_fs = FALSE;\n\n    common = &job->common;\n\n    report_copy_progress (job, source_info, transfer_info);\n\n    /* Query the source dir, not the file because if it's a symlink we'll follow it */\n    source_dir = g_file_get_parent ((GFile *) job->files->data);\n    if (source_dir)\n    {\n        inf = g_file_query_filesystem_info (source_dir, \"filesystem::readonly\", NULL, NULL);\n        if (inf != NULL)\n        {\n            readonly_source_fs = g_file_info_get_attribute_boolean (inf, \"filesystem::readonly\");\n            g_object_unref (inf);\n        }\n        g_object_unref (source_dir);\n    }\n\n    unique_names = (job->destination == NULL);\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        if (job->destination)\n        {\n            dest = g_object_ref (job->destination);\n        }\n        else\n        {\n            dest = g_file_get_parent (src);\n        }\n        if (dest)\n        {\n            skipped_file = FALSE;\n            copy_move_file (job, src, dest,\n                            same_fs, unique_names,\n                            &dest_fs_type,\n                            source_info, transfer_info,\n                            job->debuting_files,\n                            point, FALSE, &skipped_file,\n                            readonly_source_fs);\n            g_object_unref (dest);\n\n            if (skipped_file)\n            {\n                transfer_add_file_to_count (src, common, transfer_info);\n                report_copy_progress (job, source_info, transfer_info);\n            }\n        }\n        i++;\n    }\n\n    g_free (dest_fs_type);\n}\n\nstatic void\ncopy_task_done (GObject      *source_object,\n                GAsyncResult *res,\n                gpointer      user_data)\n{\n    CopyMoveJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->debuting_files,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_list_free_full (job->files, g_object_unref);\n    if (job->destination)\n    {\n        g_object_unref (job->destination);\n    }\n    if (job->desktop_location)\n    {\n        g_object_unref (job->desktop_location);\n    }\n    g_hash_table_unref (job->debuting_files);\n    g_free (job->icon_positions);\n    g_free (job->target_name);\n\n    g_clear_object (&job->fake_display_source);\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ncopy_task_thread_func (GTask        *task,\n                       gpointer      source_object,\n                       gpointer      task_data,\n                       GCancellable *cancellable)\n{\n    CopyMoveJob *job;\n    CommonJob *common;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    char *dest_fs_id;\n    GFile *dest;\n\n    job = task_data;\n    common = &job->common;\n\n    dest_fs_id = NULL;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    scan_sources (job->files,\n                  &source_info,\n                  common,\n                  OP_KIND_COPY);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    if (job->destination)\n    {\n        dest = g_object_ref (job->destination);\n    }\n    else\n    {\n        /* Duplication, no dest,\n         * use source for free size, etc\n         */\n        dest = g_file_get_parent (job->files->data);\n    }\n\n    verify_destination (&job->common,\n                        dest,\n                        &dest_fs_id,\n                        source_info.num_bytes);\n    g_object_unref (dest);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    g_timer_start (job->common.time);\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    copy_files (job,\n                dest_fs_id,\n                &source_info, &transfer_info);\n\naborted:\n\n    g_free (dest_fs_id);\n}\n\nvoid\nnautilus_file_operations_copy_file (GFile                *source_file,\n                                    GFile                *target_dir,\n                                    const gchar          *source_display_name,\n                                    const gchar          *new_name,\n                                    GtkWindow            *parent_window,\n                                    NautilusCopyCallback  done_callback,\n                                    gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_append (NULL, g_object_ref (source_file));\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    job->target_name = g_strdup (new_name);\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    if (source_display_name != NULL)\n    {\n        gchar *path;\n\n        path = g_build_filename (\"/\", source_display_name, NULL);\n        job->fake_display_source = g_file_new_for_path (path);\n\n        g_free (path);\n    }\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Copying Files\"));\n\n    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, copy_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_copy (GList                *files,\n                               GArray               *relative_item_points,\n                               GFile                *target_dir,\n                               GtkWindow            *parent_window,\n                               NautilusCopyCallback  done_callback,\n                               gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->desktop_location = nautilus_get_desktop_location ();\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Copying Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n        job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_COPY,\n                                                                 g_list_length (files),\n                                                                 src_dir, target_dir);\n\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, copy_task_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nreport_preparing_move_progress (CopyMoveJob *move_job,\n                                int          total,\n                                int          left)\n{\n    CommonJob *job;\n\n    job = (CommonJob *) move_job;\n\n    nautilus_progress_info_take_status (job->progress,\n                                        f (_(\"Preparing to move to \u201c%B\u201d\"),\n                                           move_job->destination));\n\n    nautilus_progress_info_take_details (job->progress,\n                                         f (ngettext (\"Preparing to move %'d file\",\n                                                      \"Preparing to move %'d files\",\n                                                      left), left));\n\n    nautilus_progress_info_pulse_progress (job->progress);\n}\n\ntypedef struct\n{\n    GFile *file;\n    gboolean overwrite;\n    gboolean has_position;\n    GdkPoint position;\n} MoveFileCopyFallback;\n\nstatic MoveFileCopyFallback *\nmove_copy_file_callback_new (GFile    *file,\n                             gboolean  overwrite,\n                             GdkPoint *position)\n{\n    MoveFileCopyFallback *fallback;\n\n    fallback = g_new (MoveFileCopyFallback, 1);\n    fallback->file = file;\n    fallback->overwrite = overwrite;\n    if (position)\n    {\n        fallback->has_position = TRUE;\n        fallback->position = *position;\n    }\n    else\n    {\n        fallback->has_position = FALSE;\n    }\n\n    return fallback;\n}\n\nstatic GList *\nget_files_from_fallbacks (GList *fallbacks)\n{\n    MoveFileCopyFallback *fallback;\n    GList *res, *l;\n\n    res = NULL;\n    for (l = fallbacks; l != NULL; l = l->next)\n    {\n        fallback = l->data;\n        res = g_list_prepend (res, fallback->file);\n    }\n    return g_list_reverse (res);\n}\n\nstatic void\nmove_file_prepare (CopyMoveJob  *move_job,\n                   GFile        *src,\n                   GFile        *dest_dir,\n                   gboolean      same_fs,\n                   char        **dest_fs_type,\n                   GHashTable   *debuting_files,\n                   GdkPoint     *position,\n                   GList       **fallback_files,\n                   int           files_left)\n{\n    GFile *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    GError *error;\n    CommonJob *job;\n    gboolean overwrite;\n    char *primary, *secondary, *details;\n    int response;\n    GFileCopyFlags flags;\n    MoveFileCopyFallback *fallback;\n    gboolean handled_invalid_filename;\n\n    overwrite = FALSE;\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    job = (CommonJob *) move_job;\n\n    dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n\n\n    /* Don't allow recursive move/copy into itself.\n     * (We would get a file system error if we proceeded but it is nicer to\n     * detect and report it at this level) */\n    if (test_dir_is_parent (dest_dir, src))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = move_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n                  : g_strdup (_(\"You cannot copy a folder into itself.\"));\n        secondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                NULL,\n                                files_left > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\nretry:\n\n    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_NO_FALLBACK_FOR_MOVE;\n    if (overwrite)\n    {\n        flags |= G_FILE_COPY_OVERWRITE;\n    }\n\n    error = NULL;\n    if (g_file_move (src, dest,\n                     flags,\n                     job->cancellable,\n                     NULL,\n                     NULL,\n                     &error))\n    {\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n\n        nautilus_file_changes_queue_file_moved (src, dest);\n\n        dest_uri = g_file_get_uri (dest);\n        if (position)\n        {\n            nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n        }\n        else if (eel_uri_is_desktop (dest_uri))\n        {\n            nautilus_file_changes_queue_schedule_position_remove (dest);\n        }\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                                src, dest);\n        }\n\n        return;\n    }\n\n    if (IS_IO_ERROR (error, INVALID_FILENAME) &&\n        !handled_invalid_filename)\n    {\n        g_error_free (error);\n\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n        new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n    /* Conflict */\n    else if (!overwrite &&\n             IS_IO_ERROR (error, EXISTS))\n    {\n        gboolean is_merge;\n        FileConflictResponse *response;\n\n        g_error_free (error);\n\n        is_merge = FALSE;\n        if (is_dir (dest) && is_dir (src))\n        {\n            is_merge = TRUE;\n        }\n\n        if ((is_merge && job->merge_all) ||\n            (!is_merge && job->replace_all))\n        {\n            overwrite = TRUE;\n            goto retry;\n        }\n\n        if (job->skip_all_conflict)\n        {\n            goto out;\n        }\n\n        response = handle_copy_move_conflict (job, src, dest, dest_dir);\n\n        if (response->id == GTK_RESPONSE_CANCEL ||\n            response->id == GTK_RESPONSE_DELETE_EVENT)\n        {\n            file_conflict_response_free (response);\n            abort_job (job);\n        }\n        else if (response->id == CONFLICT_RESPONSE_SKIP)\n        {\n            if (response->apply_to_all)\n            {\n                job->skip_all_conflict = TRUE;\n            }\n            file_conflict_response_free (response);\n        }\n        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */\n        {\n            if (response->apply_to_all)\n            {\n                if (is_merge)\n                {\n                    job->merge_all = TRUE;\n                }\n                else\n                {\n                    job->replace_all = TRUE;\n                }\n            }\n            overwrite = TRUE;\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else if (response->id == CONFLICT_RESPONSE_RENAME)\n        {\n            g_object_unref (dest);\n            dest = get_target_file_for_display_name (dest_dir,\n                                                     response->new_name);\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n             IS_IO_ERROR (error, WOULD_MERGE) ||\n             IS_IO_ERROR (error, NOT_SUPPORTED) ||\n             (overwrite && IS_IO_ERROR (error, IS_DIRECTORY)))\n    {\n        g_error_free (error);\n\n        fallback = move_copy_file_callback_new (src,\n                                                overwrite,\n                                                position);\n        *fallback_files = g_list_prepend (*fallback_files, fallback);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else\n    {\n        if (job->skip_all_error)\n        {\n            g_error_free (error);\n            goto out;\n        }\n        primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n        secondary = f (_(\"There was an error moving the file into %F.\"), dest_dir);\n        details = error->message;\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                files_left > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\nout:\n    g_object_unref (dest);\n}\n\nstatic void\nmove_files_prepare (CopyMoveJob  *job,\n                    const char   *dest_fs_id,\n                    char        **dest_fs_type,\n                    GList       **fallbacks)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    int total, left;\n\n    common = &job->common;\n\n    total = left = g_list_length (job->files);\n\n    report_preparing_move_progress (job, total, left);\n\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        move_file_prepare (job, src, job->destination,\n                           same_fs, dest_fs_type,\n                           job->debuting_files,\n                           point,\n                           fallbacks,\n                           left);\n        report_preparing_move_progress (job, total, --left);\n        i++;\n    }\n\n    *fallbacks = g_list_reverse (*fallbacks);\n}\n\nstatic void\nmove_files (CopyMoveJob   *job,\n            GList         *fallbacks,\n            const char    *dest_fs_id,\n            char         **dest_fs_type,\n            SourceInfo    *source_info,\n            TransferInfo  *transfer_info)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    gboolean skipped_file;\n    MoveFileCopyFallback *fallback;\n    common = &job->common;\n\n    report_copy_progress (job, source_info, transfer_info);\n\n    i = 0;\n    for (l = fallbacks;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        fallback = l->data;\n        src = fallback->file;\n\n        if (fallback->has_position)\n        {\n            point = &fallback->position;\n        }\n        else\n        {\n            point = NULL;\n        }\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        /* Set overwrite to true, as the user has\n         *  selected overwrite on all toplevel items */\n        skipped_file = FALSE;\n        copy_move_file (job, src, job->destination,\n                        same_fs, FALSE, dest_fs_type,\n                        source_info, transfer_info,\n                        job->debuting_files,\n                        point, fallback->overwrite, &skipped_file, FALSE);\n        i++;\n\n        if (skipped_file)\n        {\n            transfer_add_file_to_count (src, common, transfer_info);\n            report_copy_progress (job, source_info, transfer_info);\n        }\n    }\n}\n\n\nstatic void\nmove_task_done (GObject      *source_object,\n                GAsyncResult *res,\n                gpointer      user_data)\n{\n    CopyMoveJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->debuting_files,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_list_free_full (job->files, g_object_unref);\n    g_object_unref (job->destination);\n    g_hash_table_unref (job->debuting_files);\n    g_free (job->icon_positions);\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\nmove_task_thread_func (GTask        *task,\n                       gpointer      source_object,\n                       gpointer      task_data,\n                       GCancellable *cancellable)\n{\n    CopyMoveJob *job;\n    CommonJob *common;\n    GList *fallbacks;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    char *dest_fs_id;\n    char *dest_fs_type;\n    GList *fallback_files;\n\n    job = task_data;\n    common = &job->common;\n\n    dest_fs_id = NULL;\n    dest_fs_type = NULL;\n\n    fallbacks = NULL;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    verify_destination (&job->common,\n                        job->destination,\n                        &dest_fs_id,\n                        -1);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    /* This moves all files that we can do without copy + delete */\n    move_files_prepare (job, dest_fs_id, &dest_fs_type, &fallbacks);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    /* The rest we need to do deep copy + delete behind on,\n     *  so scan for size */\n\n    fallback_files = get_files_from_fallbacks (fallbacks);\n    scan_sources (fallback_files,\n                  &source_info,\n                  common,\n                  OP_KIND_MOVE);\n\n    g_list_free (fallback_files);\n\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    verify_destination (&job->common,\n                        job->destination,\n                        NULL,\n                        source_info.num_bytes);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    move_files (job,\n                fallbacks,\n                dest_fs_id, &dest_fs_type,\n                &source_info, &transfer_info);\n\naborted:\n    g_list_free_full (fallbacks, g_free);\n\n    g_free (dest_fs_id);\n    g_free (dest_fs_type);\n}\n\nvoid\nnautilus_file_operations_move (GList                *files,\n                               GArray               *relative_item_points,\n                               GFile                *target_dir,\n                               GtkWindow            *parent_window,\n                               NautilusCopyCallback  done_callback,\n                               gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->is_move = TRUE;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Moving Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n\n        if (g_file_has_uri_scheme (g_list_first (files)->data, \"trash\"))\n        {\n            job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_RESTORE_FROM_TRASH,\n                                                                     g_list_length (files),\n                                                                     src_dir, target_dir);\n        }\n        else\n        {\n            job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_MOVE,\n                                                                     g_list_length (files),\n                                                                     src_dir, target_dir);\n        }\n\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, move_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, move_task_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nreport_preparing_link_progress (CopyMoveJob *link_job,\n                                int          total,\n                                int          left)\n{\n    CommonJob *job;\n\n    job = (CommonJob *) link_job;\n\n    nautilus_progress_info_take_status (job->progress,\n                                        f (_(\"Creating links in \u201c%B\u201d\"),\n                                           link_job->destination));\n\n    nautilus_progress_info_take_details (job->progress,\n                                         f (ngettext (\"Making link to %'d file\",\n                                                      \"Making links to %'d files\",\n                                                      left), left));\n\n    nautilus_progress_info_set_progress (job->progress, left, total);\n}\n\nstatic char *\nget_abs_path_for_symlink (GFile *file,\n                          GFile *destination)\n{\n    GFile *root, *parent;\n    char *relative, *abs;\n\n    if (g_file_is_native (file) || g_file_is_native (destination))\n    {\n        return g_file_get_path (file);\n    }\n\n    root = g_object_ref (file);\n    while ((parent = g_file_get_parent (root)) != NULL)\n    {\n        g_object_unref (root);\n        root = parent;\n    }\n\n    relative = g_file_get_relative_path (root, file);\n    g_object_unref (root);\n    abs = g_strconcat (\"/\", relative, NULL);\n    g_free (relative);\n    return abs;\n}\n\n\nstatic void\nlink_file (CopyMoveJob  *job,\n           GFile        *src,\n           GFile        *dest_dir,\n           char        **dest_fs_type,\n           GHashTable   *debuting_files,\n           GdkPoint     *position,\n           int           files_left)\n{\n    GFile *src_dir, *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    int count;\n    char *path;\n    gboolean not_local;\n    GError *error;\n    CommonJob *common;\n    char *primary, *secondary, *details;\n    int response;\n    gboolean handled_invalid_filename;\n\n    common = (CommonJob *) job;\n\n    count = 0;\n\n    src_dir = g_file_get_parent (src);\n    if (g_file_equal (src_dir, dest_dir))\n    {\n        count = 1;\n    }\n    g_object_unref (src_dir);\n\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count);\n\nretry:\n    error = NULL;\n    not_local = FALSE;\n\n    path = get_abs_path_for_symlink (src, dest);\n    if (path == NULL)\n    {\n        not_local = TRUE;\n    }\n    else if (g_file_make_symbolic_link (dest,\n                                        path,\n                                        common->cancellable,\n                                        &error))\n    {\n        if (common->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (common->undo_info),\n                                                                src, dest);\n        }\n\n        g_free (path);\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n\n        nautilus_file_changes_queue_file_added (dest);\n        dest_uri = g_file_get_uri (dest);\n        if (position)\n        {\n            nautilus_file_changes_queue_schedule_position_set (dest, *position, common->screen_num);\n        }\n        else if (eel_uri_is_desktop (dest_uri))\n        {\n            nautilus_file_changes_queue_schedule_position_remove (dest);\n        }\n\n        g_object_unref (dest);\n\n        return;\n    }\n    g_free (path);\n\n    if (error != NULL &&\n        IS_IO_ERROR (error, INVALID_FILENAME) &&\n        !handled_invalid_filename)\n    {\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, common->cancellable);\n\n        new_dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count);\n\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n            g_error_free (error);\n\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n    /* Conflict */\n    if (error != NULL && IS_IO_ERROR (error, EXISTS))\n    {\n        g_object_unref (dest);\n        dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count++);\n        g_error_free (error);\n        goto retry;\n    }\n    else if (error != NULL && IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else if (error != NULL)\n    {\n        if (common->skip_all_error)\n        {\n            goto out;\n        }\n        primary = f (_(\"Error while creating link to %B.\"), src);\n        if (not_local)\n        {\n            secondary = f (_(\"Symbolic links only supported for local files\"));\n            details = NULL;\n        }\n        else if (IS_IO_ERROR (error, NOT_SUPPORTED))\n        {\n            secondary = f (_(\"The target doesn\u2019t support symbolic links.\"));\n            details = NULL;\n        }\n        else\n        {\n            secondary = f (_(\"There was an error creating the symlink in %F.\"), dest_dir);\n            details = error->message;\n        }\n\n        response = run_warning (common,\n                                primary,\n                                secondary,\n                                details,\n                                files_left > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n\n        if (error)\n        {\n            g_error_free (error);\n        }\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            common->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\nout:\n    g_object_unref (dest);\n}\n\nstatic void\nlink_task_done (GObject      *source_object,\n                GAsyncResult *res,\n                gpointer      user_data)\n{\n    CopyMoveJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->debuting_files,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_list_free_full (job->files, g_object_unref);\n    g_object_unref (job->destination);\n    g_hash_table_unref (job->debuting_files);\n    g_free (job->icon_positions);\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\nlink_task_thread_func (GTask        *task,\n                       gpointer      source_object,\n                       gpointer      task_data,\n                       GCancellable *cancellable)\n{\n    CopyMoveJob *job;\n    CommonJob *common;\n    GFile *src;\n    GdkPoint *point;\n    char *dest_fs_type;\n    int total, left;\n    int i;\n    GList *l;\n\n    job = task_data;\n    common = &job->common;\n\n    dest_fs_type = NULL;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    verify_destination (&job->common,\n                        job->destination,\n                        NULL,\n                        -1);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    total = left = g_list_length (job->files);\n\n    report_preparing_link_progress (job, total, left);\n\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        link_file (job, src, job->destination,\n                   &dest_fs_type, job->debuting_files,\n                   point, left);\n        report_preparing_link_progress (job, total, --left);\n        i++;\n    }\n\naborted:\n    g_free (dest_fs_type);\n}\n\nvoid\nnautilus_file_operations_link (GList                *files,\n                               GArray               *relative_item_points,\n                               GFile                *target_dir,\n                               GtkWindow            *parent_window,\n                               NautilusCopyCallback  done_callback,\n                               gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n        job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_CREATE_LINK,\n                                                                 g_list_length (files),\n                                                                 src_dir, target_dir);\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, link_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, link_task_thread_func);\n    g_object_unref (task);\n}\n\n\nvoid\nnautilus_file_operations_duplicate (GList                *files,\n                                    GArray               *relative_item_points,\n                                    GtkWindow            *parent_window,\n                                    NautilusCopyCallback  done_callback,\n                                    gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n    GFile *parent;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = NULL;\n    /* Duplicate files doesn't have a destination, since is the same as source.\n     * For that set as destination the source parent folder */\n    parent = g_file_get_parent (files->data);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, parent);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n        job->common.undo_info =\n            nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_DUPLICATE,\n                                             g_list_length (files),\n                                             src_dir, src_dir);\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, copy_task_thread_func);\n    g_object_unref (task);\n\n    g_object_unref (parent);\n}\n\nstatic void\nset_permissions_task_done (GObject      *source_object,\n                           GAsyncResult *res,\n                           gpointer      user_data)\n{\n    SetPermissionsJob *job;\n\n    job = user_data;\n\n    g_object_unref (job->file);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}\n\nstatic void\nset_permissions_file (SetPermissionsJob *job,\n                      GFile             *file,\n                      GFileInfo         *info)\n{\n    CommonJob *common;\n    GFileInfo *child_info;\n    gboolean free_info;\n    guint32 current;\n    guint32 value;\n    guint32 mask;\n    GFileEnumerator *enumerator;\n    GFile *child;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_pulse_progress (common->progress);\n\n    free_info = FALSE;\n    if (info == NULL)\n    {\n        free_info = TRUE;\n        info = g_file_query_info (file,\n                                  G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                  G_FILE_ATTRIBUTE_UNIX_MODE,\n                                  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                  common->cancellable,\n                                  NULL);\n        /* Ignore errors */\n        if (info == NULL)\n        {\n            return;\n        }\n    }\n\n    if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n    {\n        value = job->dir_permissions;\n        mask = job->dir_mask;\n    }\n    else\n    {\n        value = job->file_permissions;\n        mask = job->file_mask;\n    }\n\n\n    if (!job_aborted (common) &&\n        g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n\n        if (common->undo_info != NULL)\n        {\n            nautilus_file_undo_info_rec_permissions_add_file (NAUTILUS_FILE_UNDO_INFO_REC_PERMISSIONS (common->undo_info),\n                                                              file, current);\n        }\n\n        current = (current & ~mask) | value;\n\n        g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                     current, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                     common->cancellable, NULL);\n    }\n\n    if (!job_aborted (common) &&\n        g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n    {\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                                G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                                G_FILE_ATTRIBUTE_UNIX_MODE,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                common->cancellable,\n                                                NULL);\n        if (enumerator)\n        {\n            while (!job_aborted (common) &&\n                   (child_info = g_file_enumerator_next_file (enumerator, common->cancellable, NULL)) != NULL)\n            {\n                child = g_file_get_child (file,\n                                          g_file_info_get_name (child_info));\n                set_permissions_file (job, child, child_info);\n                g_object_unref (child);\n                g_object_unref (child_info);\n            }\n            g_file_enumerator_close (enumerator, common->cancellable, NULL);\n            g_object_unref (enumerator);\n        }\n    }\n    if (free_info)\n    {\n        g_object_unref (info);\n    }\n}\n\n\nstatic void\nset_permissions_thread_func (GTask        *task,\n                             gpointer      source_object,\n                             gpointer      task_data,\n                             GCancellable *cancellable)\n{\n    SetPermissionsJob *job = task_data;\n    CommonJob *common;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_set_status (common->progress,\n                                       _(\"Setting permissions\"));\n\n    nautilus_progress_info_start (job->common.progress);\n\n    set_permissions_file (job, job->file, NULL);\n}\n\n\n\nvoid\nnautilus_file_set_permissions_recursive (const char         *directory,\n                                         guint32             file_permissions,\n                                         guint32             file_mask,\n                                         guint32             dir_permissions,\n                                         guint32             dir_mask,\n                                         NautilusOpCallback  callback,\n                                         gpointer            callback_data)\n{\n    GTask *task;\n    SetPermissionsJob *job;\n\n    job = op_job_new (SetPermissionsJob, NULL);\n    job->file = g_file_new_for_uri (directory);\n    job->file_permissions = file_permissions;\n    job->file_mask = file_mask;\n    job->dir_permissions = dir_permissions;\n    job->dir_mask = dir_mask;\n    job->done_callback = callback;\n    job->done_callback_data = callback_data;\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info =\n            nautilus_file_undo_info_rec_permissions_new (job->file,\n                                                         file_permissions, file_mask,\n                                                         dir_permissions, dir_mask);\n    }\n\n    task = g_task_new (NULL, NULL, set_permissions_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, set_permissions_thread_func);\n    g_object_unref (task);\n}\n\nstatic GList *\nlocation_list_from_uri_list (const GList *uris)\n{\n    const GList *l;\n    GList *files;\n    GFile *f;\n\n    files = NULL;\n    for (l = uris; l != NULL; l = l->next)\n    {\n        f = g_file_new_for_uri (l->data);\n        files = g_list_prepend (files, f);\n    }\n\n    return g_list_reverse (files);\n}\n\ntypedef struct\n{\n    NautilusCopyCallback real_callback;\n    gpointer real_data;\n} MoveTrashCBData;\n\nstatic void\ncallback_for_move_to_trash (GHashTable      *debuting_uris,\n                            gboolean         user_cancelled,\n                            MoveTrashCBData *data)\n{\n    if (data->real_callback)\n    {\n        data->real_callback (debuting_uris, !user_cancelled, data->real_data);\n    }\n    g_slice_free (MoveTrashCBData, data);\n}\n\nvoid\nnautilus_file_operations_copy_move (const GList          *item_uris,\n                                    GArray               *relative_item_points,\n                                    const char           *target_dir,\n                                    GdkDragAction         copy_action,\n                                    GtkWidget            *parent_view,\n                                    NautilusCopyCallback  done_callback,\n                                    gpointer              done_callback_data)\n{\n    GList *locations;\n    GList *p;\n    GFile *dest, *src_dir;\n    GtkWindow *parent_window;\n    gboolean target_is_mapping;\n    gboolean have_nonmapping_source;\n\n    dest = NULL;\n    target_is_mapping = FALSE;\n    have_nonmapping_source = FALSE;\n\n    if (target_dir)\n    {\n        dest = g_file_new_for_uri (target_dir);\n        if (g_file_has_uri_scheme (dest, \"burn\"))\n        {\n            target_is_mapping = TRUE;\n        }\n    }\n\n    locations = location_list_from_uri_list (item_uris);\n\n    for (p = locations; p != NULL; p = p->next)\n    {\n        if (!g_file_has_uri_scheme ((GFile * ) p->data, \"burn\"))\n        {\n            have_nonmapping_source = TRUE;\n        }\n    }\n\n    if (target_is_mapping && have_nonmapping_source && copy_action == GDK_ACTION_MOVE)\n    {\n        /* never move to \"burn:///\", but fall back to copy.\n         * This is a workaround, because otherwise the source files would be removed.\n         */\n        copy_action = GDK_ACTION_COPY;\n    }\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    if (copy_action == GDK_ACTION_COPY)\n    {\n        src_dir = g_file_get_parent (locations->data);\n        if (target_dir == NULL ||\n            (src_dir != NULL &&\n             g_file_equal (src_dir, dest)))\n        {\n            nautilus_file_operations_duplicate (locations,\n                                                relative_item_points,\n                                                parent_window,\n                                                done_callback, done_callback_data);\n        }\n        else\n        {\n            nautilus_file_operations_copy (locations,\n                                           relative_item_points,\n                                           dest,\n                                           parent_window,\n                                           done_callback, done_callback_data);\n        }\n        if (src_dir)\n        {\n            g_object_unref (src_dir);\n        }\n    }\n    else if (copy_action == GDK_ACTION_MOVE)\n    {\n        if (g_file_has_uri_scheme (dest, \"trash\"))\n        {\n            MoveTrashCBData *cb_data;\n\n            cb_data = g_slice_new0 (MoveTrashCBData);\n            cb_data->real_callback = done_callback;\n            cb_data->real_data = done_callback_data;\n\n            nautilus_file_operations_trash_or_delete (locations,\n                                                      parent_window,\n                                                      (NautilusDeleteCallback) callback_for_move_to_trash,\n                                                      cb_data);\n        }\n        else\n        {\n            nautilus_file_operations_move (locations,\n                                           relative_item_points,\n                                           dest,\n                                           parent_window,\n                                           done_callback, done_callback_data);\n        }\n    }\n    else\n    {\n        nautilus_file_operations_link (locations,\n                                       relative_item_points,\n                                       dest,\n                                       parent_window,\n                                       done_callback, done_callback_data);\n    }\n\n    g_list_free_full (locations, g_object_unref);\n    if (dest)\n    {\n        g_object_unref (dest);\n    }\n}\n\nstatic void\ncreate_task_done (GObject      *source_object,\n                  GAsyncResult *res,\n                  gpointer      user_data)\n{\n    CreateJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->created_file,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_object_unref (job->dest_dir);\n    if (job->src)\n    {\n        g_object_unref (job->src);\n    }\n    g_free (job->src_data);\n    g_free (job->filename);\n    if (job->created_file)\n    {\n        g_object_unref (job->created_file);\n    }\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ncreate_task_thread_func (GTask        *task,\n                         gpointer      source_object,\n                         gpointer      task_data,\n                         GCancellable *cancellable)\n{\n    CreateJob *job;\n    CommonJob *common;\n    int count;\n    GFile *dest;\n    g_autofree gchar *dest_uri = NULL;\n    char *basename;\n    char *filename, *filename2, *new_filename;\n    char *filename_base, *suffix;\n    char *dest_fs_type;\n    GError *error;\n    gboolean res;\n    gboolean filename_is_utf8;\n    char *primary, *secondary, *details;\n    int response;\n    char *data;\n    int length;\n    GFileOutputStream *out;\n    gboolean handled_invalid_filename;\n    int max_length, offset;\n\n    job = task_data;\n    common = &job->common;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    handled_invalid_filename = FALSE;\n\n    dest_fs_type = NULL;\n    filename = NULL;\n    dest = NULL;\n\n    max_length = get_max_name_length (job->dest_dir);\n\n    verify_destination (common,\n                        job->dest_dir,\n                        NULL, -1);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    filename = g_strdup (job->filename);\n    filename_is_utf8 = FALSE;\n    if (filename)\n    {\n        filename_is_utf8 = g_utf8_validate (filename, -1, NULL);\n    }\n    if (filename == NULL)\n    {\n        if (job->make_dir)\n        {\n            /* localizers: the initial name of a new folder  */\n            filename = g_strdup (_(\"Untitled Folder\"));\n            filename_is_utf8 = TRUE;             /* Pass in utf8 */\n        }\n        else\n        {\n            if (job->src != NULL)\n            {\n                basename = g_file_get_basename (job->src);\n                /* localizers: the initial name of a new template document */\n                filename = g_strdup_printf (\"%s\", basename);\n\n                g_free (basename);\n            }\n            if (filename == NULL)\n            {\n                /* localizers: the initial name of a new empty document */\n                filename = g_strdup (_(\"Untitled Document\"));\n                filename_is_utf8 = TRUE;                 /* Pass in utf8 */\n            }\n        }\n    }\n\n    make_file_name_valid_for_dest_fs (filename, dest_fs_type);\n    if (filename_is_utf8)\n    {\n        dest = g_file_get_child_for_display_name (job->dest_dir, filename, NULL);\n    }\n    if (dest == NULL)\n    {\n        dest = g_file_get_child (job->dest_dir, filename);\n    }\n    count = 1;\n\nretry:\n\n    error = NULL;\n    if (job->make_dir)\n    {\n        res = g_file_make_directory (dest,\n                                     common->cancellable,\n                                     &error);\n\n        if (res)\n        {\n            GFile *real;\n\n            real = map_possibly_volatile_file_to_real (dest, common->cancellable, &error);\n            if (real == NULL)\n            {\n                res = FALSE;\n            }\n            else\n            {\n                g_object_unref (dest);\n                dest = real;\n            }\n        }\n\n        if (res && common->undo_info != NULL)\n        {\n            nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),\n                                                     dest, NULL, 0);\n        }\n    }\n    else\n    {\n        if (job->src)\n        {\n            res = g_file_copy (job->src,\n                               dest,\n                               G_FILE_COPY_NONE,\n                               common->cancellable,\n                               NULL, NULL,\n                               &error);\n\n            if (res)\n            {\n                GFile *real;\n\n                real = map_possibly_volatile_file_to_real (dest, common->cancellable, &error);\n                if (real == NULL)\n                {\n                    res = FALSE;\n                }\n                else\n                {\n                    g_object_unref (dest);\n                    dest = real;\n                }\n            }\n\n            if (res && common->undo_info != NULL)\n            {\n                gchar *uri;\n\n                uri = g_file_get_uri (job->src);\n                nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),\n                                                         dest, uri, 0);\n\n                g_free (uri);\n            }\n        }\n        else\n        {\n            data = \"\";\n            length = 0;\n            if (job->src_data)\n            {\n                data = job->src_data;\n                length = job->length;\n            }\n\n            out = g_file_create (dest,\n                                 G_FILE_CREATE_NONE,\n                                 common->cancellable,\n                                 &error);\n            if (out)\n            {\n                GFile *real;\n\n                real = map_possibly_volatile_file_to_real_on_write (dest,\n                                                                    out,\n                                                                    common->cancellable,\n                                                                    &error);\n                if (real == NULL)\n                {\n                    res = FALSE;\n                    g_object_unref (out);\n                }\n                else\n                {\n                    g_object_unref (dest);\n                    dest = real;\n\n                    res = g_output_stream_write_all (G_OUTPUT_STREAM (out),\n                                                     data, length,\n                                                     NULL,\n                                                     common->cancellable,\n                                                     &error);\n                    if (res)\n                    {\n                        res = g_output_stream_close (G_OUTPUT_STREAM (out),\n                                                     common->cancellable,\n                                                     &error);\n\n                        if (res && common->undo_info != NULL)\n                        {\n                            nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),\n                                                                     dest, data, length);\n                        }\n                    }\n\n                    /* This will close if the write failed and we didn't close */\n                    g_object_unref (out);\n                }\n            }\n            else\n            {\n                res = FALSE;\n            }\n        }\n    }\n\n    if (res)\n    {\n        job->created_file = g_object_ref (dest);\n        nautilus_file_changes_queue_file_added (dest);\n        dest_uri = g_file_get_uri (dest);\n        if (job->has_position)\n        {\n            nautilus_file_changes_queue_schedule_position_set (dest, job->position, common->screen_num);\n        }\n        else if (eel_uri_is_desktop (dest_uri))\n        {\n            nautilus_file_changes_queue_schedule_position_remove (dest);\n        }\n    }\n    else\n    {\n        g_assert (error != NULL);\n\n        if (IS_IO_ERROR (error, INVALID_FILENAME) &&\n            !handled_invalid_filename)\n        {\n            handled_invalid_filename = TRUE;\n\n            g_assert (dest_fs_type == NULL);\n            dest_fs_type = query_fs_type (job->dest_dir, common->cancellable);\n\n            if (count == 1)\n            {\n                new_filename = g_strdup (filename);\n            }\n            else\n            {\n                filename_base = eel_filename_strip_extension (filename);\n                offset = strlen (filename_base);\n                suffix = g_strdup (filename + offset);\n\n                filename2 = g_strdup_printf (\"%s %d%s\", filename_base, count, suffix);\n\n                new_filename = NULL;\n                if (max_length > 0 && strlen (filename2) > max_length)\n                {\n                    new_filename = shorten_utf8_string (filename2, strlen (filename2) - max_length);\n                }\n\n                if (new_filename == NULL)\n                {\n                    new_filename = g_strdup (filename2);\n                }\n\n                g_free (filename2);\n                g_free (suffix);\n            }\n\n            if (make_file_name_valid_for_dest_fs (new_filename, dest_fs_type))\n            {\n                g_object_unref (dest);\n\n                if (filename_is_utf8)\n                {\n                    dest = g_file_get_child_for_display_name (job->dest_dir, new_filename, NULL);\n                }\n                if (dest == NULL)\n                {\n                    dest = g_file_get_child (job->dest_dir, new_filename);\n                }\n\n                g_free (new_filename);\n                g_error_free (error);\n                goto retry;\n            }\n            g_free (new_filename);\n        }\n\n        if (IS_IO_ERROR (error, EXISTS))\n        {\n            g_object_unref (dest);\n            dest = NULL;\n            filename_base = eel_filename_strip_extension (filename);\n            offset = strlen (filename_base);\n            suffix = g_strdup (filename + offset);\n\n            filename2 = g_strdup_printf (\"%s %d%s\", filename_base, ++count, suffix);\n\n            if (max_length > 0 && strlen (filename2) > max_length)\n            {\n                new_filename = shorten_utf8_string (filename2, strlen (filename2) - max_length);\n                if (new_filename != NULL)\n                {\n                    g_free (filename2);\n                    filename2 = new_filename;\n                }\n            }\n\n            make_file_name_valid_for_dest_fs (filename2, dest_fs_type);\n            if (filename_is_utf8)\n            {\n                dest = g_file_get_child_for_display_name (job->dest_dir, filename2, NULL);\n            }\n            if (dest == NULL)\n            {\n                dest = g_file_get_child (job->dest_dir, filename2);\n            }\n            g_free (filename2);\n            g_free (suffix);\n            g_error_free (error);\n            goto retry;\n        }\n        else if (IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n        }\n        /* Other error */\n        else\n        {\n            if (job->make_dir)\n            {\n                primary = f (_(\"Error while creating directory %B.\"), dest);\n            }\n            else\n            {\n                primary = f (_(\"Error while creating file %B.\"), dest);\n            }\n            secondary = f (_(\"There was an error creating the directory in %F.\"), job->dest_dir);\n            details = error->message;\n\n            response = run_warning (common,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL, SKIP,\n                                    NULL);\n\n            g_error_free (error);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)                 /* skip */\n            {                   /* do nothing */\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n    }\n\naborted:\n    if (dest)\n    {\n        g_object_unref (dest);\n    }\n    g_free (filename);\n    g_free (dest_fs_type);\n}\n\nvoid\nnautilus_file_operations_new_folder (GtkWidget              *parent_view,\n                                     GdkPoint               *target_point,\n                                     const char             *parent_dir,\n                                     const char             *folder_name,\n                                     NautilusCreateCallback  done_callback,\n                                     gpointer                done_callback_data)\n{\n    GTask *task;\n    CreateJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (CreateJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->dest_dir = g_file_new_for_uri (parent_dir);\n    job->filename = g_strdup (folder_name);\n    job->make_dir = TRUE;\n    if (target_point != NULL)\n    {\n        job->position = *target_point;\n        job->has_position = TRUE;\n    }\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_FOLDER);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, create_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_new_file_from_template (GtkWidget              *parent_view,\n                                                 GdkPoint               *target_point,\n                                                 const char             *parent_dir,\n                                                 const char             *target_filename,\n                                                 const char             *template_uri,\n                                                 NautilusCreateCallback  done_callback,\n                                                 gpointer                done_callback_data)\n{\n    GTask *task;\n    CreateJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (CreateJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->dest_dir = g_file_new_for_uri (parent_dir);\n    if (target_point != NULL)\n    {\n        job->position = *target_point;\n        job->has_position = TRUE;\n    }\n    job->filename = g_strdup (target_filename);\n\n    if (template_uri)\n    {\n        job->src = g_file_new_for_uri (template_uri);\n    }\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_FILE_FROM_TEMPLATE);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, create_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_new_file (GtkWidget              *parent_view,\n                                   GdkPoint               *target_point,\n                                   const char             *parent_dir,\n                                   const char             *target_filename,\n                                   const char             *initial_contents,\n                                   int                     length,\n                                   NautilusCreateCallback  done_callback,\n                                   gpointer                done_callback_data)\n{\n    GTask *task;\n    CreateJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (CreateJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->dest_dir = g_file_new_for_uri (parent_dir);\n    if (target_point != NULL)\n    {\n        job->position = *target_point;\n        job->has_position = TRUE;\n    }\n    job->src_data = g_memdup (initial_contents, length);\n    job->length = length;\n    job->filename = g_strdup (target_filename);\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_EMPTY_FILE);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, create_task_thread_func);\n    g_object_unref (task);\n}\n\n\n\nstatic void\ndelete_trash_file (CommonJob *job,\n                   GFile     *file,\n                   gboolean   del_file,\n                   gboolean   del_children)\n{\n    GFileInfo *info;\n    GFile *child;\n    GFileEnumerator *enumerator;\n\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    if (del_children)\n    {\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                job->cancellable,\n                                                NULL);\n        if (enumerator)\n        {\n            while (!job_aborted (job) &&\n                   (info = g_file_enumerator_next_file (enumerator, job->cancellable, NULL)) != NULL)\n            {\n                child = g_file_get_child (file,\n                                          g_file_info_get_name (info));\n                delete_trash_file (job, child, TRUE,\n                                   g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY);\n                g_object_unref (child);\n                g_object_unref (info);\n            }\n            g_file_enumerator_close (enumerator, job->cancellable, NULL);\n            g_object_unref (enumerator);\n        }\n    }\n\n    if (!job_aborted (job) && del_file)\n    {\n        g_file_delete (file, job->cancellable, NULL);\n    }\n}\n\nstatic void\nempty_trash_task_done (GObject      *source_object,\n                       GAsyncResult *res,\n                       gpointer      user_data)\n{\n    EmptyTrashJob *job;\n\n    job = user_data;\n\n    g_list_free_full (job->trash_dirs, g_object_unref);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}\n\nstatic void\nempty_trash_thread_func (GTask        *task,\n                         gpointer      source_object,\n                         gpointer      task_data,\n                         GCancellable *cancellable)\n{\n    EmptyTrashJob *job = task_data;\n    CommonJob *common;\n    GList *l;\n    gboolean confirmed;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    if (job->should_confirm)\n    {\n        confirmed = confirm_empty_trash (common);\n    }\n    else\n    {\n        confirmed = TRUE;\n    }\n    if (confirmed)\n    {\n        for (l = job->trash_dirs;\n             l != NULL && !job_aborted (common);\n             l = l->next)\n        {\n            delete_trash_file (common, l->data, FALSE, TRUE);\n        }\n    }\n}\n\nvoid\nnautilus_file_operations_empty_trash (GtkWidget *parent_view)\n{\n    GTask *task;\n    EmptyTrashJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (EmptyTrashJob, parent_window);\n    job->trash_dirs = g_list_prepend (job->trash_dirs,\n                                      g_file_new_for_uri (\"trash:\"));\n    job->should_confirm = TRUE;\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Emptying Trash\"));\n\n    task = g_task_new (NULL, NULL, empty_trash_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, empty_trash_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nmark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n\n    g_object_unref (job->file);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}\n\n#define TRUSTED_SHEBANG \"#!/usr/bin/env xdg-open\\n\"\n\nstatic void\nmark_desktop_file_trusted (CommonJob    *common,\n                           GCancellable *cancellable,\n                           GFile        *file,\n                           gboolean      interactive)\n{\n    char *contents, *new_contents;\n    gsize length, new_length;\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\n\nretry:\n    error = NULL;\n    if (!g_file_load_contents (file,\n                               cancellable,\n                               &contents, &length,\n                               NULL, &error))\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n    if (!g_str_has_prefix (contents, \"#!\"))\n    {\n        new_length = length + strlen (TRUSTED_SHEBANG);\n        new_contents = g_malloc (new_length);\n\n        strcpy (new_contents, TRUSTED_SHEBANG);\n        memcpy (new_contents + strlen (TRUSTED_SHEBANG),\n                contents, length);\n\n        if (!g_file_replace_contents (file,\n                                      new_contents,\n                                      new_length,\n                                      NULL,\n                                      FALSE, 0,\n                                      NULL, cancellable, &error))\n        {\n            g_free (contents);\n            g_free (new_contents);\n\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\n            goto out;\n        }\n        g_free (new_contents);\n    }\n    g_free (contents);\n\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}\n\nstatic void\nmark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}\n\nvoid\nnautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nextract_task_done (GObject      *source_object,\n                   GAsyncResult *res,\n                   gpointer      user_data)\n{\n    ExtractJob *extract_job;\n\n    extract_job = user_data;\n\n    if (extract_job->done_callback)\n    {\n        extract_job->done_callback (extract_job->output_files,\n                                    extract_job->done_callback_data);\n    }\n\n    g_list_free_full (extract_job->source_files, g_object_unref);\n    g_list_free_full (extract_job->output_files, g_object_unref);\n    g_object_unref (extract_job->destination_directory);\n\n    finalize_common ((CommonJob *) extract_job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic GFile *\nextract_job_on_decide_destination (AutoarExtractor *extractor,\n                                   GFile           *destination,\n                                   GList           *files,\n                                   gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *decided_destination;\n    g_autofree char *basename = NULL;\n\n    nautilus_progress_info_set_details (extract_job->common.progress,\n                                        _(\"Verifying destination\"));\n\n    basename = g_file_get_basename (destination);\n    decided_destination = nautilus_generate_unique_file_in_directory (extract_job->destination_directory,\n                                                                      basename);\n\n    if (job_aborted ((CommonJob *) extract_job))\n    {\n        g_object_unref (decided_destination);\n        return NULL;\n    }\n\n    extract_job->output_files = g_list_prepend (extract_job->output_files,\n                                                decided_destination);\n\n    return g_object_ref (decided_destination);\n}\n\nstatic void\nextract_job_on_progress (AutoarExtractor *extractor,\n                         guint64          archive_current_decompressed_size,\n                         guint            archive_current_decompressed_files,\n                         gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    CommonJob *common = user_data;\n    GFile *source_file;\n    char *details;\n    double elapsed;\n    double transfer_rate;\n    int remaining_time;\n    guint64 archive_total_decompressed_size;\n    gdouble archive_weight;\n    gdouble archive_decompress_progress;\n    guint64 job_completed_size;\n    gdouble job_progress;\n\n    source_file = autoar_extractor_get_source_file (extractor);\n\n    nautilus_progress_info_take_status (common->progress,\n                                        f (_(\"Extracting \u201c%B\u201d\"), source_file));\n\n    archive_total_decompressed_size = autoar_extractor_get_total_size (extractor);\n\n    archive_decompress_progress = (gdouble) archive_current_decompressed_size /\n                                  (gdouble) archive_total_decompressed_size;\n\n    archive_weight = 0;\n    if (extract_job->total_compressed_size)\n    {\n        archive_weight = (gdouble) extract_job->archive_compressed_size /\n                         (gdouble) extract_job->total_compressed_size;\n    }\n\n    job_progress = archive_decompress_progress * archive_weight + extract_job->base_progress;\n\n    elapsed = g_timer_elapsed (common->time, NULL);\n\n    transfer_rate = 0;\n    remaining_time = -1;\n\n    job_completed_size = job_progress * extract_job->total_compressed_size;\n\n    if (elapsed > 0)\n    {\n        transfer_rate = job_completed_size / elapsed;\n    }\n    if (transfer_rate > 0)\n    {\n        remaining_time = (extract_job->total_compressed_size - job_completed_size) /\n                         transfer_rate;\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ||\n        transfer_rate == 0)\n    {\n        /* To translators: %S will expand to a size like \"2 bytes\" or\n         * \"3 MB\", so something like \"4 kb / 4 MB\"\n         */\n        details = f (_(\"%S / %S\"), job_completed_size, extract_job->total_compressed_size);\n    }\n    else\n    {\n        /* To translators: %S will expand to a size like \"2 bytes\" or\n         * \"3 MB\", %T to a time duration like \"2 minutes\". So the whole\n         * thing will be something like\n         * \"2 kb / 4 MB -- 2 hours left (4kb/sec)\"\n         *\n         * The singular/plural form will be used depending on the\n         * remaining time (i.e. the %T argument).\n         */\n        details = f (ngettext (\"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                               \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                               seconds_count_format_time_units (remaining_time)),\n                     job_completed_size, extract_job->total_compressed_size,\n                     remaining_time,\n                     (goffset) transfer_rate);\n    }\n\n    nautilus_progress_info_take_details (common->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (common->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (common->progress,\n                                                 elapsed);\n    }\n\n    nautilus_progress_info_set_progress (common->progress, job_progress, 1);\n}\n\nstatic void\nextract_job_on_error (AutoarExtractor *extractor,\n                      GError          *error,\n                      gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *source_file;\n    gint response_id;\n\n    source_file = autoar_extractor_get_source_file (extractor);\n\n    if (IS_IO_ERROR (error, NOT_SUPPORTED))\n    {\n        handle_unsupported_compressed_file (extract_job->common.parent_window,\n                                            source_file);\n\n        return;\n    }\n\n    nautilus_progress_info_take_status (extract_job->common.progress,\n                                        f (_(\"Error extracting \u201c%B\u201d\"),\n                                           source_file));\n\n    response_id = run_warning ((CommonJob *) extract_job,\n                               f (_(\"There was an error while extracting \u201c%B\u201d.\"),\n                                  source_file),\n                               g_strdup (error->message),\n                               NULL,\n                               FALSE,\n                               CANCEL,\n                               SKIP,\n                               NULL);\n\n    if (response_id == 0 || response_id == GTK_RESPONSE_DELETE_EVENT)\n    {\n        abort_job ((CommonJob *) extract_job);\n    }\n}\n\nstatic void\nextract_job_on_completed (AutoarExtractor *extractor,\n                          gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *output_file;\n\n    output_file = G_FILE (extract_job->output_files->data);\n\n    nautilus_file_changes_queue_file_added (output_file);\n}\n\nstatic void\nreport_extract_final_progress (ExtractJob *extract_job,\n                               gint        total_files)\n{\n    char *status;\n\n    nautilus_progress_info_set_destination (extract_job->common.progress,\n                                            extract_job->destination_directory);\n\n    if (total_files == 1)\n    {\n        GFile *source_file;\n\n        source_file = G_FILE (extract_job->source_files->data);\n        status = f (_(\"Extracted \u201c%B\u201d to \u201c%B\u201d\"),\n                    source_file,\n                    extract_job->destination_directory);\n    }\n    else\n    {\n        status = f (ngettext (\"Extracted %'d file to \u201c%B\u201d\",\n                              \"Extracted %'d files to \u201c%B\u201d\",\n                              total_files),\n                    total_files,\n                    extract_job->destination_directory);\n    }\n\n    nautilus_progress_info_take_status (extract_job->common.progress,\n                                        status);\n    nautilus_progress_info_take_details (extract_job->common.progress,\n                                         f (_(\"%S / %S\"),\n                                            extract_job->total_compressed_size,\n                                            extract_job->total_compressed_size));\n}\n\nstatic void\nextract_task_thread_func (GTask        *task,\n                          gpointer      source_object,\n                          gpointer      task_data,\n                          GCancellable *cancellable)\n{\n    ExtractJob *extract_job = task_data;\n    GList *l;\n    GList *existing_output_files = NULL;\n    gint total_files;\n    g_autofree guint64 *archive_compressed_sizes = NULL;\n    gint i;\n\n    g_timer_start (extract_job->common.time);\n\n    nautilus_progress_info_start (extract_job->common.progress);\n\n    nautilus_progress_info_set_details (extract_job->common.progress,\n                                        _(\"Preparing to extract\"));\n\n    total_files = g_list_length (extract_job->source_files);\n\n    archive_compressed_sizes = g_malloc0_n (total_files, sizeof (guint64));\n    extract_job->total_compressed_size = 0;\n\n    for (l = extract_job->source_files, i = 0;\n         l != NULL && !job_aborted ((CommonJob *) extract_job);\n         l = l->next, i++)\n    {\n        GFile *source_file;\n        g_autoptr (GFileInfo) info = NULL;\n\n        source_file = G_FILE (l->data);\n        info = g_file_query_info (source_file,\n                                  G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                  extract_job->common.cancellable,\n                                  NULL);\n\n        if (info)\n        {\n            archive_compressed_sizes[i] = g_file_info_get_size (info);\n            extract_job->total_compressed_size += archive_compressed_sizes[i];\n        }\n    }\n\n    extract_job->base_progress = 0;\n\n    for (l = extract_job->source_files, i = 0;\n         l != NULL && !job_aborted ((CommonJob *) extract_job);\n         l = l->next, i++)\n    {\n        g_autoptr (AutoarExtractor) extractor = NULL;\n\n        extractor = autoar_extractor_new (G_FILE (l->data),\n                                          extract_job->destination_directory);\n\n        autoar_extractor_set_notify_interval (extractor,\n                                              PROGRESS_NOTIFY_INTERVAL);\n\n        g_signal_connect (extractor, \"error\",\n                          G_CALLBACK (extract_job_on_error),\n                          extract_job);\n        g_signal_connect (extractor, \"decide-destination\",\n                          G_CALLBACK (extract_job_on_decide_destination),\n                          extract_job);\n        g_signal_connect (extractor, \"progress\",\n                          G_CALLBACK (extract_job_on_progress),\n                          extract_job);\n        g_signal_connect (extractor, \"completed\",\n                          G_CALLBACK (extract_job_on_completed),\n                          extract_job);\n\n        extract_job->archive_compressed_size = archive_compressed_sizes[i];\n\n        autoar_extractor_start (extractor,\n                                extract_job->common.cancellable);\n\n        g_signal_handlers_disconnect_by_data (extractor,\n                                              extract_job);\n\n        extract_job->base_progress += (gdouble) extract_job->archive_compressed_size /\n                                      (gdouble) extract_job->total_compressed_size;\n    }\n\n    if (!job_aborted ((CommonJob *) extract_job))\n    {\n        report_extract_final_progress (extract_job, total_files);\n    }\n\n    for (l = extract_job->output_files; l != NULL; l = l->next)\n    {\n        GFile *output_file;\n\n        output_file = G_FILE (l->data);\n\n        if (g_file_query_exists (output_file, NULL))\n        {\n            existing_output_files = g_list_prepend (existing_output_files,\n                                                    g_object_ref (output_file));\n        }\n    }\n\n    g_list_free_full (extract_job->output_files, g_object_unref);\n\n    extract_job->output_files = existing_output_files;\n\n    if (extract_job->common.undo_info)\n    {\n        if (extract_job->output_files)\n        {\n            NautilusFileUndoInfoExtract *undo_info;\n\n            undo_info = NAUTILUS_FILE_UNDO_INFO_EXTRACT (extract_job->common.undo_info);\n\n            nautilus_file_undo_info_extract_set_outputs (undo_info,\n                                                         extract_job->output_files);\n        }\n        else\n        {\n            /* There is nothing to undo if there is no output */\n            g_clear_object (&extract_job->common.undo_info);\n        }\n    }\n}\n\nvoid\nnautilus_file_operations_extract_files (GList                   *files,\n                                        GFile                   *destination_directory,\n                                        GtkWindow               *parent_window,\n                                        NautilusExtractCallback  done_callback,\n                                        gpointer                 done_callback_data)\n{\n    ExtractJob *extract_job;\n    g_autoptr (GTask) task = NULL;\n\n    extract_job = op_job_new (ExtractJob, parent_window);\n    extract_job->source_files = g_list_copy_deep (files,\n                                                  (GCopyFunc) g_object_ref,\n                                                  NULL);\n    extract_job->destination_directory = g_object_ref (destination_directory);\n    extract_job->done_callback = done_callback;\n    extract_job->done_callback_data = done_callback_data;\n\n    inhibit_power_manager ((CommonJob *) extract_job, _(\"Extracting Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        extract_job->common.undo_info = nautilus_file_undo_info_extract_new (files,\n                                                                             destination_directory);\n    }\n\n    task = g_task_new (NULL, extract_job->common.cancellable,\n                       extract_task_done, extract_job);\n    g_task_set_task_data (task, extract_job, NULL);\n    g_task_run_in_thread (task, extract_task_thread_func);\n}\n\nstatic void\ncompress_task_done (GObject      *source_object,\n                    GAsyncResult *res,\n                    gpointer      user_data)\n{\n    CompressJob *compress_job = user_data;\n\n    if (compress_job->done_callback)\n    {\n        compress_job->done_callback (compress_job->output_file,\n                                     compress_job->success,\n                                     compress_job->done_callback_data);\n    }\n\n    g_object_unref (compress_job->output_file);\n    g_list_free_full (compress_job->source_files, g_object_unref);\n\n    finalize_common ((CommonJob *) compress_job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ncompress_job_on_progress (AutoarCompressor *compressor,\n                          guint64           completed_size,\n                          guint             completed_files,\n                          gpointer          user_data)\n{\n    CompressJob *compress_job = user_data;\n    CommonJob *common = user_data;\n    char *status;\n    char *details;\n    int files_left;\n    double elapsed;\n    double transfer_rate;\n    int remaining_time;\n\n    files_left = compress_job->total_files - completed_files;\n\n    if (compress_job->total_files == 1)\n    {\n        status = f (_(\"Compressing \u201c%B\u201d into \u201c%B\u201d\"),\n                    G_FILE (compress_job->source_files->data),\n                    compress_job->output_file);\n    }\n    else\n    {\n        status = f (ngettext (\"Compressing %'d file into \u201c%B\u201d\",\n                              \"Compressing %'d files into \u201c%B\u201d\",\n                              compress_job->total_files),\n                    compress_job->total_files,\n                    compress_job->output_file);\n    }\n\n    nautilus_progress_info_take_status (common->progress, status);\n\n    elapsed = g_timer_elapsed (common->time, NULL);\n\n    transfer_rate = 0;\n    remaining_time = -1;\n\n    if (elapsed > 0)\n    {\n        if (completed_size > 0)\n        {\n            transfer_rate = completed_size / elapsed;\n            remaining_time = (compress_job->total_size - completed_size) / transfer_rate;\n        }\n        else if (completed_files > 0)\n        {\n            transfer_rate = completed_files / elapsed;\n            remaining_time = (compress_job->total_files - completed_files) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ||\n        transfer_rate == 0)\n    {\n        if (compress_job->total_files == 1)\n        {\n            /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", so something like \"4 kb / 4 MB\" */\n            details = f (_(\"%S / %S\"), completed_size, compress_job->total_size);\n        }\n        else\n        {\n            details = f (_(\"%'d / %'d\"),\n                         files_left > 0 ? completed_files + 1 : completed_files,\n                         compress_job->total_files);\n        }\n    }\n    else\n    {\n        if (compress_job->total_files == 1)\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", %T to a time duration like\n                 * \"2 minutes\". So the whole thing will be something like \"2 kb / 4 MB -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             completed_size, compress_job->total_size,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\". */\n                details = f (_(\"%S / %S\"),\n                             completed_size,\n                             compress_job->total_size);\n            }\n        }\n        else\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %T will expand to a time duration like \"2 minutes\".\n                 * So the whole thing will be something like \"1 / 5 -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             completed_files + 1, compress_job->total_files,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             completed_files,\n                             compress_job->total_files);\n            }\n        }\n    }\n\n    nautilus_progress_info_take_details (common->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (common->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (common->progress,\n                                                 elapsed);\n    }\n\n    nautilus_progress_info_set_progress (common->progress,\n                                         completed_size,\n                                         compress_job->total_size);\n}\n\nstatic void\ncompress_job_on_error (AutoarCompressor *compressor,\n                       GError           *error,\n                       gpointer          user_data)\n{\n    CompressJob *compress_job = user_data;\n    char *status;\n\n    if (compress_job->total_files == 1)\n    {\n        status = f (_(\"Error compressing \u201c%B\u201d into \u201c%B\u201d\"),\n                    G_FILE (compress_job->source_files->data),\n                    compress_job->output_file);\n    }\n    else\n    {\n        status = f (ngettext (\"Error compressing %'d file into \u201c%B\u201d\",\n                              \"Error compressing %'d files into \u201c%B\u201d\",\n                              compress_job->total_files),\n                    compress_job->total_files,\n                    compress_job->output_file);\n    }\n\n    nautilus_progress_info_take_status (compress_job->common.progress,\n                                        status);\n\n    run_error ((CommonJob *) compress_job,\n               g_strdup (_(\"There was an error while compressing files.\")),\n               g_strdup (error->message),\n               NULL,\n               FALSE,\n               CANCEL,\n               NULL);\n\n    abort_job ((CommonJob *) compress_job);\n}\n\nstatic void\ncompress_job_on_completed (AutoarCompressor *compressor,\n                           gpointer          user_data)\n{\n    CompressJob *compress_job = user_data;\n    g_autoptr (GFile) destination_directory = NULL;\n    char *status;\n\n    if (compress_job->total_files == 1)\n    {\n        status = f (_(\"Compressed \u201c%B\u201d into \u201c%B\u201d\"),\n                    G_FILE (compress_job->source_files->data),\n                    compress_job->output_file);\n    }\n    else\n    {\n        status = f (ngettext (\"Compressed %'d file into \u201c%B\u201d\",\n                              \"Compressed %'d files into \u201c%B\u201d\",\n                              compress_job->total_files),\n                    compress_job->total_files,\n                    compress_job->output_file);\n    }\n\n    nautilus_progress_info_take_status (compress_job->common.progress,\n                                        status);\n\n    nautilus_file_changes_queue_file_added (compress_job->output_file);\n\n    destination_directory = g_file_get_parent (compress_job->output_file);\n    nautilus_progress_info_set_destination (compress_job->common.progress,\n                                            destination_directory);\n}\n\nstatic void\ncompress_task_thread_func (GTask        *task,\n                           gpointer      source_object,\n                           gpointer      task_data,\n                           GCancellable *cancellable)\n{\n    CompressJob *compress_job = task_data;\n    SourceInfo source_info;\n    g_autoptr (AutoarCompressor) compressor = NULL;\n\n    g_timer_start (compress_job->common.time);\n\n    nautilus_progress_info_start (compress_job->common.progress);\n\n    scan_sources (compress_job->source_files,\n                  &source_info,\n                  (CommonJob *) compress_job,\n                  OP_KIND_COMPRESS);\n\n    compress_job->total_files = source_info.num_files;\n    compress_job->total_size = source_info.num_bytes;\n\n    compressor = autoar_compressor_new (compress_job->source_files,\n                                        compress_job->output_file,\n                                        compress_job->format,\n                                        compress_job->filter,\n                                        FALSE);\n\n    autoar_compressor_set_output_is_dest (compressor, TRUE);\n\n    autoar_compressor_set_notify_interval (compressor,\n                                           PROGRESS_NOTIFY_INTERVAL);\n\n    g_signal_connect (compressor, \"progress\",\n                      G_CALLBACK (compress_job_on_progress), compress_job);\n    g_signal_connect (compressor, \"error\",\n                      G_CALLBACK (compress_job_on_error), compress_job);\n    g_signal_connect (compressor, \"completed\",\n                      G_CALLBACK (compress_job_on_completed), compress_job);\n    autoar_compressor_start (compressor,\n                             compress_job->common.cancellable);\n\n    compress_job->success = g_file_query_exists (compress_job->output_file,\n                                                 NULL);\n\n    /* There is nothing to undo if the output was not created */\n    if (compress_job->common.undo_info != NULL && !compress_job->success)\n    {\n        g_clear_object (&compress_job->common.undo_info);\n    }\n}\n\nvoid\nnautilus_file_operations_compress (GList                  *files,\n                                   GFile                  *output,\n                                   AutoarFormat            format,\n                                   AutoarFilter            filter,\n                                   GtkWindow              *parent_window,\n                                   NautilusCreateCallback  done_callback,\n                                   gpointer                done_callback_data)\n{\n    g_autoptr (GTask) task = NULL;\n    CompressJob *compress_job;\n\n    compress_job = op_job_new (CompressJob, parent_window);\n    compress_job->source_files = g_list_copy_deep (files,\n                                                   (GCopyFunc) g_object_ref,\n                                                   NULL);\n    compress_job->output_file = g_object_ref (output);\n    compress_job->format = format;\n    compress_job->filter = filter;\n    compress_job->done_callback = done_callback;\n    compress_job->done_callback_data = done_callback_data;\n\n    inhibit_power_manager ((CommonJob *) compress_job, _(\"Compressing Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        compress_job->common.undo_info = nautilus_file_undo_info_compress_new (files,\n                                                                               output,\n                                                                               format,\n                                                                               filter);\n    }\n\n    task = g_task_new (NULL, compress_job->common.cancellable,\n                       compress_task_done, compress_job);\n    g_task_set_task_data (task, compress_job, NULL);\n    g_task_run_in_thread (task, compress_task_thread_func);\n}\n\n#if !defined (NAUTILUS_OMIT_SELF_CHECK)\n\nvoid\nnautilus_self_check_file_operations (void)\n{\n    setlocale (LC_MESSAGES, \"C\");\n\n\n    /* test the next duplicate name generator */\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\" (copy)\", 1, -1), \" (another copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo\", 1, -1), \"foo (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\".bashrc\", 1, -1), \".bashrc (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\".foo.txt\", 1, -1), \".foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo\", 1, -1), \"foo foo (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo.txt\", 1, -1), \"foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo.txt\", 1, -1), \"foo foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo.txt txt\", 1, -1), \"foo foo (copy).txt txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo...txt\", 1, -1), \"foo.. (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo...\", 1, -1), \"foo... (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo. (copy)\", 1, -1), \"foo. (another copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (copy)\", 1, -1), \"foo (another copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (copy).txt\", 1, -1), \"foo (another copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (another copy)\", 1, -1), \"foo (3rd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (another copy).txt\", 1, -1), \"foo (3rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (another copy).txt\", 1, -1), \"foo foo (3rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (13th copy)\", 1, -1), \"foo (14th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (13th copy).txt\", 1, -1), \"foo (14th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (21st copy)\", 1, -1), \"foo (22nd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (21st copy).txt\", 1, -1), \"foo (22nd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (22nd copy)\", 1, -1), \"foo (23rd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (22nd copy).txt\", 1, -1), \"foo (23rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (23rd copy)\", 1, -1), \"foo (24th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (23rd copy).txt\", 1, -1), \"foo (24th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (24th copy)\", 1, -1), \"foo (25th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (24th copy).txt\", 1, -1), \"foo (25th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (24th copy)\", 1, -1), \"foo foo (25th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (24th copy).txt\", 1, -1), \"foo foo (25th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (100000000000000th copy).txt\", 1, -1), \"foo foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (10th copy)\", 1, -1), \"foo (11th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (10th copy).txt\", 1, -1), \"foo (11th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (11th copy)\", 1, -1), \"foo (12th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (11th copy).txt\", 1, -1), \"foo (12th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (12th copy)\", 1, -1), \"foo (13th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (12th copy).txt\", 1, -1), \"foo (13th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (110th copy)\", 1, -1), \"foo (111th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (110th copy).txt\", 1, -1), \"foo (111th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (122nd copy)\", 1, -1), \"foo (123rd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (122nd copy).txt\", 1, -1), \"foo (123rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (123rd copy)\", 1, -1), \"foo (124th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (123rd copy).txt\", 1, -1), \"foo (124th copy).txt\");\n\n    setlocale (LC_MESSAGES, \"\");\n}\n\n#endif\n", "\n/* nautilus-file-operations: execute file operations.\n\n   Copyright (C) 1999, 2000 Free Software Foundation\n   Copyright (C) 2000, 2001 Eazel, Inc.\n\n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n   \n   You should have received a copy of the GNU General Public\n   License along with this program; if not, see <http://www.gnu.org/licenses/>.\n   \n   Authors: Ettore Perazzoli <ettore@gnu.org>,\n            Pavel Cisler <pavel@eazel.com>\n*/\n\n#ifndef NAUTILUS_FILE_OPERATIONS_H\n#define NAUTILUS_FILE_OPERATIONS_H\n\n#include <gtk/gtk.h>\n#include <gio/gio.h>\n#include <gnome-autoar/gnome-autoar.h>\n\n\n#define SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE 1\n\ntypedef void (* NautilusCopyCallback)      (GHashTable *debuting_uris,\n\t\t\t\t\t    gboolean    success,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusCreateCallback)    (GFile      *new_file,\n\t\t\t\t\t    gboolean    success,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusOpCallback)        (gboolean    success,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusDeleteCallback)    (GHashTable *debuting_uris,\n\t\t\t\t\t    gboolean    user_cancel,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusMountCallback)     (GVolume    *volume,\n\t\t\t\t\t    gboolean    success,\n\t\t\t\t\t    GObject    *callback_data_object);\ntypedef void (* NautilusUnmountCallback)   (gpointer    callback_data);\ntypedef void (* NautilusExtractCallback)   (GList    *outputs,\n                                            gpointer  callback_data);\n\n/* FIXME: int copy_action should be an enum */\n\nvoid nautilus_file_operations_copy_move   (const GList               *item_uris,\n\t\t\t\t\t   GArray                    *relative_item_points,\n\t\t\t\t\t   const char                *target_dir_uri,\n\t\t\t\t\t   GdkDragAction              copy_action,\n\t\t\t\t\t   GtkWidget                 *parent_view,\n\t\t\t\t\t   NautilusCopyCallback       done_callback,\n\t\t\t\t\t   gpointer                   done_callback_data);\nvoid nautilus_file_operations_copy_file (GFile *source_file,\n\t\t\t\t\t GFile *target_dir,\n\t\t\t\t\t const gchar *source_display_name,\n\t\t\t\t\t const gchar *new_name,\n\t\t\t\t\t GtkWindow *parent_window,\n\t\t\t\t\t NautilusCopyCallback done_callback,\n\t\t\t\t\t gpointer done_callback_data);\nvoid nautilus_file_operations_empty_trash (GtkWidget                 *parent_view);\nvoid nautilus_file_operations_new_folder  (GtkWidget                 *parent_view,\n\t\t\t\t\t   GdkPoint                  *target_point,\n\t\t\t\t\t   const char                *parent_dir_uri,\n\t\t\t\t\t   const char                *folder_name,\n\t\t\t\t\t   NautilusCreateCallback     done_callback,\n\t\t\t\t\t   gpointer                   done_callback_data);\nvoid nautilus_file_operations_new_file    (GtkWidget                 *parent_view,\n\t\t\t\t\t   GdkPoint                  *target_point,\n\t\t\t\t\t   const char                *parent_dir,\n\t\t\t\t\t   const char                *target_filename,\n\t\t\t\t\t   const char                *initial_contents,\n\t\t\t\t\t   int                        length,\n\t\t\t\t\t   NautilusCreateCallback     done_callback,\n\t\t\t\t\t   gpointer                   data);\nvoid nautilus_file_operations_new_file_from_template (GtkWidget               *parent_view,\n\t\t\t\t\t   \t      GdkPoint                *target_point,\n\t\t\t\t\t\t      const char              *parent_dir,\n\t\t\t\t\t\t      const char              *target_filename,\n\t\t\t\t\t\t      const char              *template_uri,\n\t\t\t\t\t\t      NautilusCreateCallback   done_callback,\n\t\t\t\t\t\t      gpointer                 data);\n\nvoid nautilus_file_operations_delete          (GList                  *files,\n\t\t\t\t\t       GtkWindow              *parent_window,\n\t\t\t\t\t       NautilusDeleteCallback  done_callback,\n\t\t\t\t\t       gpointer                done_callback_data);\nvoid nautilus_file_operations_trash_or_delete (GList                  *files,\n\t\t\t\t\t       GtkWindow              *parent_window,\n\t\t\t\t\t       NautilusDeleteCallback  done_callback,\n\t\t\t\t\t       gpointer                done_callback_data);\n\nvoid nautilus_file_set_permissions_recursive (const char                     *directory,\n\t\t\t\t\t      guint32                         file_permissions,\n\t\t\t\t\t      guint32                         file_mask,\n\t\t\t\t\t      guint32                         folder_permissions,\n\t\t\t\t\t      guint32                         folder_mask,\n\t\t\t\t\t      NautilusOpCallback              callback,\n\t\t\t\t\t      gpointer                        callback_data);\n\nvoid nautilus_file_operations_unmount_mount (GtkWindow                      *parent_window,\n\t\t\t\t\t     GMount                         *mount,\n\t\t\t\t\t     gboolean                        eject,\n\t\t\t\t\t     gboolean                        check_trash);\nvoid nautilus_file_operations_unmount_mount_full (GtkWindow                 *parent_window,\n\t\t\t\t\t\t  GMount                    *mount,\n\t\t\t\t\t\t  GMountOperation           *mount_operation,\n\t\t\t\t\t\t  gboolean                   eject,\n\t\t\t\t\t\t  gboolean                   check_trash,\n\t\t\t\t\t\t  NautilusUnmountCallback    callback,\n\t\t\t\t\t\t  gpointer                   callback_data);\nvoid nautilus_file_operations_mount_volume  (GtkWindow                      *parent_window,\n\t\t\t\t\t     GVolume                        *volume);\nvoid nautilus_file_operations_mount_volume_full (GtkWindow                      *parent_window,\n\t\t\t\t\t\t GVolume                        *volume,\n\t\t\t\t\t\t NautilusMountCallback           mount_callback,\n\t\t\t\t\t\t GObject                        *mount_callback_data_object);\n\nvoid nautilus_file_operations_copy      (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GFile                *target_dir,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_operations_move      (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GFile                *target_dir,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_operations_duplicate (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_operations_link      (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GFile                *target_dir,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_mark_desktop_file_trusted (GFile           *file,\n\t\t\t\t\t      GtkWindow        *parent_window,\n\t\t\t\t\t      gboolean          interactive,\n\t\t\t\t\t      NautilusOpCallback done_callback,\n\t\t\t\t\t      gpointer          done_callback_data);\nvoid nautilus_file_operations_extract_files (GList                   *files,\n                                             GFile                   *destination_directory,\n                                             GtkWindow               *parent_window,\n                                             NautilusExtractCallback  done_callback,\n                                             gpointer                 done_callback_data);\nvoid nautilus_file_operations_compress (GList                  *files,\n                                        GFile                  *output,\n                                        AutoarFormat            format,\n                                        AutoarFilter            filter,\n                                        GtkWindow              *parent_window,\n                                        NautilusCreateCallback  done_callback,\n                                        gpointer                done_callback_data);\n\n\n#endif /* NAUTILUS_FILE_OPERATIONS_H */\n", "/* nautilus-metadata.c - metadata utils\n *\n * Copyright (C) 2009 Red Hatl, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include \"nautilus-metadata.h\"\n#include <glib.h>\n\nstatic char *used_metadata_names[] =\n{\n    NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_COLOR,\n    NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_IMAGE,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_AUTO_LAYOUT,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_BY,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_REVERSED,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_KEEP_ALIGNED,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_LAYOUT_TIMESTAMP,\n    NAUTILUS_METADATA_KEY_DESKTOP_ICON_SIZE,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_COLUMN,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_REVERSED,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_VISIBLE_COLUMNS,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_COLUMN_ORDER,\n    NAUTILUS_METADATA_KEY_WINDOW_GEOMETRY,\n    NAUTILUS_METADATA_KEY_WINDOW_SCROLL_POSITION,\n    NAUTILUS_METADATA_KEY_WINDOW_SHOW_HIDDEN_FILES,\n    NAUTILUS_METADATA_KEY_WINDOW_MAXIMIZED,\n    NAUTILUS_METADATA_KEY_WINDOW_STICKY,\n    NAUTILUS_METADATA_KEY_WINDOW_KEEP_ABOVE,\n    NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_COLOR,\n    NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_IMAGE,\n    NAUTILUS_METADATA_KEY_SIDEBAR_BUTTONS,\n    NAUTILUS_METADATA_KEY_ANNOTATION,\n    NAUTILUS_METADATA_KEY_ICON_POSITION,\n    NAUTILUS_METADATA_KEY_ICON_POSITION_TIMESTAMP,\n    NAUTILUS_METADATA_KEY_ICON_SCALE,\n    NAUTILUS_METADATA_KEY_CUSTOM_ICON,\n    NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME,\n    NAUTILUS_METADATA_KEY_SCREEN,\n    NAUTILUS_METADATA_KEY_EMBLEMS,\n    NULL\n};\n\nguint\nnautilus_metadata_get_id (const char *metadata)\n{\n    static GHashTable *hash;\n    int i;\n\n    if (hash == NULL)\n    {\n        hash = g_hash_table_new (g_str_hash, g_str_equal);\n        for (i = 0; used_metadata_names[i] != NULL; i++)\n        {\n            g_hash_table_insert (hash,\n                                 used_metadata_names[i],\n                                 GINT_TO_POINTER (i + 1));\n        }\n    }\n\n    return GPOINTER_TO_INT (g_hash_table_lookup (hash, metadata));\n}\n", "/*\n   nautilus-metadata.h: #defines and other metadata-related info\n \n   Copyright (C) 2000 Eazel, Inc.\n  \n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n  \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n  \n   You should have received a copy of the GNU General Public\n   License along with this program; if not, see <http://www.gnu.org/licenses/>.\n  \n   Author: John Sullivan <sullivan@eazel.com>\n*/\n\n#ifndef NAUTILUS_METADATA_H\n#define NAUTILUS_METADATA_H\n\n/* Keys for getting/setting Nautilus metadata. All metadata used in Nautilus\n * should define its key here, so we can keep track of the whole set easily.\n * Any updates here needs to be added in nautilus-metadata.c too.\n */\n\n#include <glib.h>\n\n/* Per-file */\n\n#define NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_COLOR \t\"folder-background-color\"\n#define NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_IMAGE \t\"folder-background-image\"\n\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_AUTO_LAYOUT      \t\"nautilus-icon-view-auto-layout\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_BY          \t\"nautilus-icon-view-sort-by\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_REVERSED    \t\"nautilus-icon-view-sort-reversed\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_KEEP_ALIGNED            \"nautilus-icon-view-keep-aligned\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_LAYOUT_TIMESTAMP\t\"nautilus-icon-view-layout-timestamp\"\n\n#define NAUTILUS_METADATA_KEY_DESKTOP_ICON_SIZE           \"nautilus-desktop-icon-size\"\n\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_COLUMN      \t\"nautilus-list-view-sort-column\"\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_REVERSED    \t\"nautilus-list-view-sort-reversed\"\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_VISIBLE_COLUMNS    \t\"nautilus-list-view-visible-columns\"\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_COLUMN_ORDER    \t\"nautilus-list-view-column-order\"\n\n#define NAUTILUS_METADATA_KEY_WINDOW_GEOMETRY\t\t\t\"nautilus-window-geometry\"\n#define NAUTILUS_METADATA_KEY_WINDOW_SCROLL_POSITION\t\t\"nautilus-window-scroll-position\"\n#define NAUTILUS_METADATA_KEY_WINDOW_SHOW_HIDDEN_FILES\t\t\"nautilus-window-show-hidden-files\"\n#define NAUTILUS_METADATA_KEY_WINDOW_MAXIMIZED\t\t\t\"nautilus-window-maximized\"\n#define NAUTILUS_METADATA_KEY_WINDOW_STICKY\t\t\t\"nautilus-window-sticky\"\n#define NAUTILUS_METADATA_KEY_WINDOW_KEEP_ABOVE\t\t\t\"nautilus-window-keep-above\"\n\n#define NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_COLOR   \t\"nautilus-sidebar-background-color\"\n#define NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_IMAGE   \t\"nautilus-sidebar-background-image\"\n#define NAUTILUS_METADATA_KEY_SIDEBAR_BUTTONS\t\t\t\"nautilus-sidebar-buttons\"\n\n#define NAUTILUS_METADATA_KEY_ICON_POSITION              \t\"nautilus-icon-position\"\n#define NAUTILUS_METADATA_KEY_ICON_POSITION_TIMESTAMP\t\t\"nautilus-icon-position-timestamp\"\n#define NAUTILUS_METADATA_KEY_ANNOTATION                 \t\"annotation\"\n#define NAUTILUS_METADATA_KEY_ICON_SCALE                 \t\"icon-scale\"\n#define NAUTILUS_METADATA_KEY_CUSTOM_ICON                \t\"custom-icon\"\n#define NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME                \t\"custom-icon-name\"\n#define NAUTILUS_METADATA_KEY_SCREEN\t\t\t\t\"screen\"\n#define NAUTILUS_METADATA_KEY_EMBLEMS\t\t\t\t\"emblems\"\n\nguint nautilus_metadata_get_id (const char *metadata);\n\n#endif /* NAUTILUS_METADATA_H */\n", "/* nautilus-mime-actions.c - uri-specific versions of mime action functions\n *\n *  Copyright (C) 2000, 2001 Eazel, Inc.\n *\n *  The Gnome Library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Library General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  The Gnome Library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Library General Public License for more details.\n *\n *  You should have received a copy of the GNU Library General Public\n *  License along with the Gnome Library; see the file COPYING.LIB.  If not,\n *  see <http://www.gnu.org/licenses/>.\n *\n *  Authors: Maciej Stachowiak <mjs@eazel.com>\n */\n\n#include <config.h>\n\n#include \"nautilus-mime-actions.h\"\n\n#include \"nautilus-window-slot.h\"\n#include \"nautilus-application.h\"\n\n#include <eel/eel-glib-extensions.h>\n#include <eel/eel-stock-dialogs.h>\n#include <eel/eel-string.h>\n#include <glib.h>\n#include <glib/gi18n.h>\n#include <glib/gstdio.h>\n#include <string.h>\n#include <gdk/gdkx.h>\n\n#include \"nautilus-file-attributes.h\"\n#include \"nautilus-file.h\"\n#include \"nautilus-file-operations.h\"\n#include \"nautilus-metadata.h\"\n#include \"nautilus-program-choosing.h\"\n#include \"nautilus-global-preferences.h\"\n#include \"nautilus-signaller.h\"\n\n#define DEBUG_FLAG NAUTILUS_DEBUG_MIME\n#include \"nautilus-debug.h\"\n\ntypedef enum\n{\n    ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE,\n    ACTIVATION_ACTION_ASK,\n    ACTIVATION_ACTION_LAUNCH,\n    ACTIVATION_ACTION_LAUNCH_IN_TERMINAL,\n    ACTIVATION_ACTION_OPEN_IN_VIEW,\n    ACTIVATION_ACTION_OPEN_IN_APPLICATION,\n    ACTIVATION_ACTION_EXTRACT,\n    ACTIVATION_ACTION_DO_NOTHING,\n} ActivationAction;\n\ntypedef struct\n{\n    NautilusFile *file;\n    char *uri;\n} LaunchLocation;\n\ntypedef struct\n{\n    GAppInfo *application;\n    GList *uris;\n} ApplicationLaunchParameters;\n\ntypedef struct\n{\n    NautilusWindowSlot *slot;\n    gpointer window;\n    GtkWindow *parent_window;\n    GCancellable *cancellable;\n    GList *locations;\n    GList *mountables;\n    GList *start_mountables;\n    GList *not_mounted;\n    NautilusWindowOpenFlags flags;\n    char *timed_wait_prompt;\n    gboolean timed_wait_active;\n    NautilusFileListHandle *files_handle;\n    gboolean tried_mounting;\n    char *activation_directory;\n    gboolean user_confirmation;\n} ActivateParameters;\n\nstruct\n{\n    char *name;\n    char *mimetypes[20];\n} mimetype_groups[] =\n{\n    {\n        N_(\"Anything\"),\n        { NULL }\n    },\n    {\n        N_(\"Files\"),\n        { \"application/octet-stream\",\n          \"text/plain\",\n          NULL}\n    },\n    {\n        N_(\"Folders\"),\n        { \"inode/directory\",\n          NULL}\n    },\n    { N_(\"Documents\"),\n      { \"application/rtf\",\n        \"application/msword\",\n        \"application/vnd.sun.xml.writer\",\n        \"application/vnd.sun.xml.writer.global\",\n        \"application/vnd.sun.xml.writer.template\",\n        \"application/vnd.oasis.opendocument.text\",\n        \"application/vnd.oasis.opendocument.text-template\",\n        \"application/x-abiword\",\n        \"application/x-applix-word\",\n        \"application/x-mswrite\",\n        \"application/docbook+xml\",\n        \"application/x-kword\",\n        \"application/x-kword-crypt\",\n        \"application/x-lyx\",\n        NULL}},\n    { N_(\"Illustration\"),\n      { \"application/illustrator\",\n        \"application/vnd.corel-draw\",\n        \"application/vnd.stardivision.draw\",\n        \"application/vnd.oasis.opendocument.graphics\",\n        \"application/x-dia-diagram\",\n        \"application/x-karbon\",\n        \"application/x-killustrator\",\n        \"application/x-kivio\",\n        \"application/x-kontour\",\n        \"application/x-wpg\",\n        NULL}},\n    { N_(\"Music\"),\n      { \"application/ogg\",\n        \"audio/x-vorbis+ogg\",\n        \"audio/ac3\",\n        \"audio/basic\",\n        \"audio/midi\",\n        \"audio/x-flac\",\n        \"audio/mp4\",\n        \"audio/mpeg\",\n        \"audio/x-mpeg\",\n        \"audio/x-ms-asx\",\n        \"audio/x-pn-realaudio\",\n        NULL}},\n    { N_(\"PDF / PostScript\"),\n      { \"application/pdf\",\n        \"application/postscript\",\n        \"application/x-dvi\",\n        \"image/x-eps\",\n        NULL}},\n    { N_(\"Picture\"),\n      { \"application/vnd.oasis.opendocument.image\",\n        \"application/x-krita\",\n        \"image/bmp\",\n        \"image/cgm\",\n        \"image/gif\",\n        \"image/jpeg\",\n        \"image/jpeg2000\",\n        \"image/png\",\n        \"image/svg+xml\",\n        \"image/tiff\",\n        \"image/x-compressed-xcf\",\n        \"image/x-pcx\",\n        \"image/x-photo-cd\",\n        \"image/x-psd\",\n        \"image/x-tga\",\n        \"image/x-xcf\",\n        NULL}},\n    { N_(\"Presentation\"),\n      { \"application/vnd.ms-powerpoint\",\n        \"application/vnd.sun.xml.impress\",\n        \"application/vnd.oasis.opendocument.presentation\",\n        \"application/x-magicpoint\",\n        \"application/x-kpresenter\",\n        NULL}},\n    { N_(\"Spreadsheet\"),\n      { \"application/vnd.lotus-1-2-3\",\n        \"application/vnd.ms-excel\",\n        \"application/vnd.stardivision.calc\",\n        \"application/vnd.sun.xml.calc\",\n        \"application/vnd.oasis.opendocument.spreadsheet\",\n        \"application/x-applix-spreadsheet\",\n        \"application/x-gnumeric\",\n        \"application/x-kspread\",\n        \"application/x-kspread-crypt\",\n        \"application/x-quattropro\",\n        \"application/x-sc\",\n        \"application/x-siag\",\n        NULL}},\n    { N_(\"Text File\"),\n      { \"text/plain\",\n        NULL}},\n    { N_(\"Video\"),\n      { \"video/mp4\",\n        \"video/3gpp\",\n        \"video/mpeg\",\n        \"video/quicktime\",\n        \"video/vivo\",\n        \"video/x-avi\",\n        \"video/x-mng\",\n        \"video/x-ms-asf\",\n        \"video/x-ms-wmv\",\n        \"video/x-msvideo\",\n        \"video/x-nsv\",\n        \"video/x-real-video\",\n        NULL}}\n};\n\n/* Number of seconds until cancel dialog shows up */\n#define DELAY_UNTIL_CANCEL_MSECS 5000\n\n#define RESPONSE_RUN 1000\n#define RESPONSE_DISPLAY 1001\n#define RESPONSE_RUN_IN_TERMINAL 1002\n#define RESPONSE_MARK_TRUSTED 1003\n\n#define SILENT_WINDOW_OPEN_LIMIT 5\n#define SILENT_OPEN_LIMIT 5\n\n/* This number controls a maximum character count for a URL that is\n * displayed as part of a dialog. It's fairly arbitrary -- big enough\n * to allow most \"normal\" URIs to display in full, but small enough to\n * prevent the dialog from getting insanely wide.\n */\n#define MAX_URI_IN_DIALOG_LENGTH 60\n\nstatic void cancel_activate_callback (gpointer callback_data);\nstatic void activate_activation_uris_ready_callback (GList   *files,\n                                                     gpointer callback_data);\nstatic void activation_mount_mountables (ActivateParameters *parameters);\nstatic void activation_start_mountables (ActivateParameters *parameters);\nstatic void activate_callback (GList   *files,\n                               gpointer callback_data);\nstatic void activation_mount_not_mounted (ActivateParameters *parameters);\n\n\nstatic void\nlaunch_location_free (LaunchLocation *location)\n{\n    nautilus_file_unref (location->file);\n    g_free (location->uri);\n    g_free (location);\n}\n\nstatic void\nlaunch_location_list_free (GList *list)\n{\n    g_list_foreach (list, (GFunc) launch_location_free, NULL);\n    g_list_free (list);\n}\n\nstatic GList *\nget_file_list_for_launch_locations (GList *locations)\n{\n    GList *files, *l;\n    LaunchLocation *location;\n\n    files = NULL;\n    for (l = locations; l != NULL; l = l->next)\n    {\n        location = l->data;\n\n        files = g_list_prepend (files,\n                                nautilus_file_ref (location->file));\n    }\n    return g_list_reverse (files);\n}\n\n\nstatic LaunchLocation *\nlaunch_location_from_file (NautilusFile *file)\n{\n    LaunchLocation *location;\n    location = g_new (LaunchLocation, 1);\n    location->file = nautilus_file_ref (file);\n    location->uri = nautilus_file_get_uri (file);\n\n    return location;\n}\n\nstatic void\nlaunch_location_update_from_file (LaunchLocation *location,\n                                  NautilusFile   *file)\n{\n    nautilus_file_unref (location->file);\n    g_free (location->uri);\n    location->file = nautilus_file_ref (file);\n    location->uri = nautilus_file_get_uri (file);\n}\n\nstatic void\nlaunch_location_update_from_uri (LaunchLocation *location,\n                                 const char     *uri)\n{\n    nautilus_file_unref (location->file);\n    g_free (location->uri);\n    location->file = nautilus_file_get_by_uri (uri);\n    location->uri = g_strdup (uri);\n}\n\nstatic LaunchLocation *\nfind_launch_location_for_file (GList        *list,\n                               NautilusFile *file)\n{\n    LaunchLocation *location;\n    GList *l;\n\n    for (l = list; l != NULL; l = l->next)\n    {\n        location = l->data;\n\n        if (location->file == file)\n        {\n            return location;\n        }\n    }\n    return NULL;\n}\n\nstatic GList *\nlaunch_locations_from_file_list (GList *list)\n{\n    GList *new;\n\n    new = NULL;\n    while (list)\n    {\n        new = g_list_prepend (new,\n                              launch_location_from_file (list->data));\n        list = list->next;\n    }\n    new = g_list_reverse (new);\n    return new;\n}\n\nstatic ApplicationLaunchParameters *\napplication_launch_parameters_new (GAppInfo *application,\n                                   GList    *uris)\n{\n    ApplicationLaunchParameters *result;\n\n    result = g_new0 (ApplicationLaunchParameters, 1);\n    result->application = g_object_ref (application);\n    result->uris = g_list_copy_deep (uris, (GCopyFunc) g_strdup, NULL);\n\n    return result;\n}\n\nstatic void\napplication_launch_parameters_free (ApplicationLaunchParameters *parameters)\n{\n    g_object_unref (parameters->application);\n    g_list_free_full (parameters->uris, g_free);\n\n    g_free (parameters);\n}\n\nstatic gboolean\nnautilus_mime_actions_check_if_required_attributes_ready (NautilusFile *file)\n{\n    NautilusFileAttributes attributes;\n    gboolean ready;\n\n    attributes = nautilus_mime_actions_get_required_file_attributes ();\n    ready = nautilus_file_check_if_ready (file, attributes);\n\n    return ready;\n}\n\nNautilusFileAttributes\nnautilus_mime_actions_get_required_file_attributes (void)\n{\n    return NAUTILUS_FILE_ATTRIBUTE_INFO |\n           NAUTILUS_FILE_ATTRIBUTE_LINK_INFO;\n}\n\nGAppInfo *\nnautilus_mime_get_default_application_for_file (NautilusFile *file)\n{\n    GAppInfo *app;\n    char *mime_type;\n    char *uri_scheme;\n\n    if (!nautilus_mime_actions_check_if_required_attributes_ready (file))\n    {\n        return NULL;\n    }\n\n    mime_type = nautilus_file_get_mime_type (file);\n    app = g_app_info_get_default_for_type (mime_type,\n                                           !nautilus_file_is_local_or_fuse (file));\n    g_free (mime_type);\n\n    if (app == NULL)\n    {\n        uri_scheme = nautilus_file_get_uri_scheme (file);\n        if (uri_scheme != NULL)\n        {\n            app = g_app_info_get_default_for_uri_scheme (uri_scheme);\n            g_free (uri_scheme);\n        }\n    }\n\n    return app;\n}\n\nstatic int\nfile_compare_by_mime_type (NautilusFile *file_a,\n                           NautilusFile *file_b)\n{\n    char *mime_type_a, *mime_type_b;\n    int ret;\n\n    mime_type_a = nautilus_file_get_mime_type (file_a);\n    mime_type_b = nautilus_file_get_mime_type (file_b);\n\n    ret = strcmp (mime_type_a, mime_type_b);\n\n    g_free (mime_type_a);\n    g_free (mime_type_b);\n\n    return ret;\n}\n\nstatic int\nfile_compare_by_parent_uri (NautilusFile *file_a,\n                            NautilusFile *file_b)\n{\n    char *parent_uri_a, *parent_uri_b;\n    int ret;\n\n    parent_uri_a = nautilus_file_get_parent_uri (file_a);\n    parent_uri_b = nautilus_file_get_parent_uri (file_b);\n\n    ret = strcmp (parent_uri_a, parent_uri_b);\n\n    g_free (parent_uri_a);\n    g_free (parent_uri_b);\n\n    return ret;\n}\n\nGAppInfo *\nnautilus_mime_get_default_application_for_files (GList *files)\n{\n    GList *l, *sorted_files;\n    NautilusFile *file;\n    GAppInfo *app, *one_app;\n\n    g_assert (files != NULL);\n\n    sorted_files = g_list_sort (g_list_copy (files), (GCompareFunc) file_compare_by_mime_type);\n\n    app = NULL;\n    for (l = sorted_files; l != NULL; l = l->next)\n    {\n        file = l->data;\n\n        if (l->prev &&\n            file_compare_by_mime_type (file, l->prev->data) == 0 &&\n            file_compare_by_parent_uri (file, l->prev->data) == 0)\n        {\n            continue;\n        }\n\n        one_app = nautilus_mime_get_default_application_for_file (file);\n        if (one_app == NULL || (app != NULL && !g_app_info_equal (app, one_app)))\n        {\n            if (app)\n            {\n                g_object_unref (app);\n            }\n            if (one_app)\n            {\n                g_object_unref (one_app);\n            }\n            app = NULL;\n            break;\n        }\n\n        if (app == NULL)\n        {\n            app = one_app;\n        }\n        else\n        {\n            g_object_unref (one_app);\n        }\n    }\n\n    g_list_free (sorted_files);\n\n    return app;\n}\n\nstatic void\ntrash_or_delete_files (GtkWindow   *parent_window,\n                       const GList *files,\n                       gboolean     delete_if_all_already_in_trash)\n{\n    GList *locations;\n    const GList *node;\n\n    locations = NULL;\n    for (node = files; node != NULL; node = node->next)\n    {\n        locations = g_list_prepend (locations,\n                                    nautilus_file_get_location ((NautilusFile *) node->data));\n    }\n\n    locations = g_list_reverse (locations);\n\n    nautilus_file_operations_trash_or_delete (locations,\n                                              parent_window,\n                                              NULL, NULL);\n    g_list_free_full (locations, g_object_unref);\n}\n\nstatic void\nreport_broken_symbolic_link (GtkWindow    *parent_window,\n                             NautilusFile *file)\n{\n    char *target_path;\n    char *display_name;\n    char *prompt;\n    char *detail;\n    GtkDialog *dialog;\n    GList file_as_list;\n    int response;\n    gboolean can_trash;\n\n    g_assert (nautilus_file_is_broken_symbolic_link (file));\n\n    display_name = nautilus_file_get_display_name (file);\n    can_trash = nautilus_file_can_trash (file) && !nautilus_file_is_in_trash (file);\n\n    if (can_trash)\n    {\n        prompt = g_strdup_printf (_(\"The link \u201c%s\u201d is broken. Move it to Trash?\"), display_name);\n    }\n    else\n    {\n        prompt = g_strdup_printf (_(\"The link \u201c%s\u201d is broken.\"), display_name);\n    }\n    g_free (display_name);\n\n    target_path = nautilus_file_get_symbolic_link_target_path (file);\n    if (target_path == NULL)\n    {\n        detail = g_strdup (_(\"This link cannot be used because it has no target.\"));\n    }\n    else\n    {\n        detail = g_strdup_printf (_(\"This link cannot be used because its target \"\n                                    \"\u201c%s\u201d doesn\u2019t exist.\"), target_path);\n    }\n\n    if (!can_trash)\n    {\n        eel_run_simple_dialog (GTK_WIDGET (parent_window), FALSE, GTK_MESSAGE_WARNING,\n                               prompt, detail, _(\"_Cancel\"), NULL);\n        goto out;\n    }\n\n    dialog = eel_show_yes_no_dialog (prompt, detail, _(\"Mo_ve to Trash\"), _(\"_Cancel\"),\n                                     parent_window);\n\n    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);\n\n    /* Make this modal to avoid problems with reffing the view & file\n     * to keep them around in case the view changes, which would then\n     * cause the old view not to be destroyed, which would cause its\n     * merged Bonobo items not to be un-merged. Maybe we need to unmerge\n     * explicitly when disconnecting views instead of relying on the\n     * unmerge in Destroy. But since BonoboUIHandler is probably going\n     * to change wildly, I don't want to mess with this now.\n     */\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    if (response == GTK_RESPONSE_YES)\n    {\n        file_as_list.data = file;\n        file_as_list.next = NULL;\n        file_as_list.prev = NULL;\n        trash_or_delete_files (parent_window, &file_as_list, TRUE);\n    }\n\nout:\n    g_free (prompt);\n    g_free (target_path);\n    g_free (detail);\n}\n\nstatic ActivationAction\nget_executable_text_file_action (GtkWindow    *parent_window,\n                                 NautilusFile *file)\n{\n    GtkDialog *dialog;\n    char *file_name;\n    char *prompt;\n    char *detail;\n    int preferences_value;\n    int response;\n\n    g_assert (nautilus_file_contains_text (file));\n\n    preferences_value = g_settings_get_enum (nautilus_preferences,\n                                             NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION);\n    switch (preferences_value)\n    {\n        case NAUTILUS_EXECUTABLE_TEXT_LAUNCH:\n        {\n            return ACTIVATION_ACTION_LAUNCH;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_DISPLAY:\n        {\n            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_ASK:\n        {\n        }\n        break;\n\n        default:\n            /* Complain non-fatally, since preference data can't be trusted */\n            g_warning (\"Unknown value %d for NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION\",\n                       preferences_value);\n    }\n\n\n    file_name = nautilus_file_get_display_name (file);\n    prompt = g_strdup_printf (_(\"Do you want to run \u201c%s\u201d, or display its contents?\"),\n                              file_name);\n    detail = g_strdup_printf (_(\"\u201c%s\u201d is an executable text file.\"),\n                              file_name);\n    g_free (file_name);\n\n    dialog = eel_create_question_dialog (prompt,\n                                         detail,\n                                         _(\"Run in _Terminal\"), RESPONSE_RUN_IN_TERMINAL,\n                                         _(\"_Display\"), RESPONSE_DISPLAY,\n                                         parent_window);\n    gtk_dialog_add_button (dialog, _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n    gtk_dialog_add_button (dialog, _(\"_Run\"), RESPONSE_RUN);\n    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);\n    gtk_widget_show (GTK_WIDGET (dialog));\n\n    g_free (prompt);\n    g_free (detail);\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    switch (response)\n    {\n        case RESPONSE_RUN:\n        {\n            return ACTIVATION_ACTION_LAUNCH;\n        }\n\n        case RESPONSE_RUN_IN_TERMINAL:\n        {\n            return ACTIVATION_ACTION_LAUNCH_IN_TERMINAL;\n        }\n\n        case RESPONSE_DISPLAY:\n        {\n            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n\n        default:\n            return ACTIVATION_ACTION_DO_NOTHING;\n    }\n}\n\nstatic ActivationAction\nget_default_executable_text_file_action (void)\n{\n    int preferences_value;\n\n    preferences_value = g_settings_get_enum (nautilus_preferences,\n                                             NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION);\n    switch (preferences_value)\n    {\n        case NAUTILUS_EXECUTABLE_TEXT_LAUNCH:\n        {\n            return ACTIVATION_ACTION_LAUNCH;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_DISPLAY:\n        {\n            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_ASK:\n        default:\n            return ACTIVATION_ACTION_ASK;\n    }\n}\n\nstatic ActivationAction\nget_activation_action (NautilusFile *file)\n{\n    ActivationAction action;\n    char *activation_uri;\n    gboolean can_extract;\n    can_extract = g_settings_get_boolean (nautilus_preferences,\n                                          NAUTILUS_PREFERENCES_AUTOMATIC_DECOMPRESSION);\n\n    if (can_extract && nautilus_file_is_archive (file))\n    {\n        return ACTIVATION_ACTION_EXTRACT;\n    }\n\n    if (nautilus_file_is_nautilus_link (file))\n    {\n        return ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE;\n    }\n\n    activation_uri = nautilus_file_get_activation_uri (file);\n    if (activation_uri == NULL)\n    {\n        activation_uri = nautilus_file_get_uri (file);\n    }\n\n    action = ACTIVATION_ACTION_DO_NOTHING;\n    if (nautilus_file_is_launchable (file))\n    {\n        char *executable_path;\n\n        action = ACTIVATION_ACTION_LAUNCH;\n\n        executable_path = g_filename_from_uri (activation_uri, NULL, NULL);\n        if (!executable_path)\n        {\n            action = ACTIVATION_ACTION_DO_NOTHING;\n        }\n        else if (nautilus_file_contains_text (file))\n        {\n            action = get_default_executable_text_file_action ();\n        }\n        g_free (executable_path);\n    }\n\n    if (action == ACTIVATION_ACTION_DO_NOTHING)\n    {\n        if (nautilus_file_opens_in_view (file))\n        {\n            action = ACTIVATION_ACTION_OPEN_IN_VIEW;\n        }\n        else\n        {\n            action = ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n    }\n    g_free (activation_uri);\n\n    return action;\n}\n\ngboolean\nnautilus_mime_file_extracts (NautilusFile *file)\n{\n    return get_activation_action (file) == ACTIVATION_ACTION_EXTRACT;\n}\n\ngboolean\nnautilus_mime_file_launches (NautilusFile *file)\n{\n    ActivationAction activation_action;\n\n    activation_action = get_activation_action (file);\n\n    return (activation_action == ACTIVATION_ACTION_LAUNCH);\n}\n\ngboolean\nnautilus_mime_file_opens_in_external_app (NautilusFile *file)\n{\n    ActivationAction activation_action;\n\n    activation_action = get_activation_action (file);\n\n    return (activation_action == ACTIVATION_ACTION_OPEN_IN_APPLICATION);\n}\n\n\nstatic unsigned int\nmime_application_hash (GAppInfo *app)\n{\n    const char *id;\n\n    id = g_app_info_get_id (app);\n\n    if (id == NULL)\n    {\n        return GPOINTER_TO_UINT (app);\n    }\n\n    return g_str_hash (id);\n}\n\nstatic void\nlist_to_parameters_foreach (GAppInfo  *application,\n                            GList     *uris,\n                            GList    **ret)\n{\n    ApplicationLaunchParameters *parameters;\n\n    uris = g_list_reverse (uris);\n\n    parameters = application_launch_parameters_new\n                     (application, uris);\n    *ret = g_list_prepend (*ret, parameters);\n}\n\n\n/**\n * make_activation_parameters\n *\n * Construct a list of ApplicationLaunchParameters from a list of NautilusFiles,\n * where files that have the same default application are put into the same\n * launch parameter, and others are put into the unhandled_files list.\n *\n * @files: Files to use for construction.\n * @unhandled_files: Files without any default application will be put here.\n *\n * Return value: Newly allocated list of ApplicationLaunchParameters.\n **/\nstatic GList *\nmake_activation_parameters (GList  *uris,\n                            GList **unhandled_uris)\n{\n    GList *ret, *l, *app_uris;\n    NautilusFile *file;\n    GAppInfo *app, *old_app;\n    GHashTable *app_table;\n    char *uri;\n\n    ret = NULL;\n    *unhandled_uris = NULL;\n\n    app_table = g_hash_table_new_full\n                    ((GHashFunc) mime_application_hash,\n                    (GEqualFunc) g_app_info_equal,\n                    (GDestroyNotify) g_object_unref,\n                    (GDestroyNotify) g_list_free);\n\n    for (l = uris; l != NULL; l = l->next)\n    {\n        uri = l->data;\n        file = nautilus_file_get_by_uri (uri);\n\n        app = nautilus_mime_get_default_application_for_file (file);\n        if (app != NULL)\n        {\n            app_uris = NULL;\n\n            if (g_hash_table_lookup_extended (app_table, app,\n                                              (gpointer *) &old_app,\n                                              (gpointer *) &app_uris))\n            {\n                g_hash_table_steal (app_table, old_app);\n\n                app_uris = g_list_prepend (app_uris, uri);\n\n                g_object_unref (app);\n                app = old_app;\n            }\n            else\n            {\n                app_uris = g_list_prepend (NULL, uri);\n            }\n\n            g_hash_table_insert (app_table, app, app_uris);\n        }\n        else\n        {\n            *unhandled_uris = g_list_prepend (*unhandled_uris, uri);\n        }\n        nautilus_file_unref (file);\n    }\n\n    g_hash_table_foreach (app_table,\n                          (GHFunc) list_to_parameters_foreach,\n                          &ret);\n\n    g_hash_table_destroy (app_table);\n\n    *unhandled_uris = g_list_reverse (*unhandled_uris);\n\n    return g_list_reverse (ret);\n}\n\nstatic gboolean\nfile_was_cancelled (NautilusFile *file)\n{\n    GError *error;\n\n    error = nautilus_file_get_file_info_error (file);\n    return\n        error != NULL &&\n        error->domain == G_IO_ERROR &&\n        error->code == G_IO_ERROR_CANCELLED;\n}\n\nstatic gboolean\nfile_was_not_mounted (NautilusFile *file)\n{\n    GError *error;\n\n    error = nautilus_file_get_file_info_error (file);\n    return\n        error != NULL &&\n        error->domain == G_IO_ERROR &&\n        error->code == G_IO_ERROR_NOT_MOUNTED;\n}\n\nstatic void\nactivation_parameters_free (ActivateParameters *parameters)\n{\n    if (parameters->timed_wait_active)\n    {\n        eel_timed_wait_stop (cancel_activate_callback, parameters);\n    }\n\n    if (parameters->slot)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters->slot), (gpointer *) &parameters->slot);\n    }\n    if (parameters->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters->parent_window), (gpointer *) &parameters->parent_window);\n    }\n    g_object_unref (parameters->cancellable);\n    launch_location_list_free (parameters->locations);\n    nautilus_file_list_free (parameters->mountables);\n    nautilus_file_list_free (parameters->start_mountables);\n    nautilus_file_list_free (parameters->not_mounted);\n    g_free (parameters->activation_directory);\n    g_free (parameters->timed_wait_prompt);\n    g_assert (parameters->files_handle == NULL);\n    g_free (parameters);\n}\n\nstatic void\ncancel_activate_callback (gpointer callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n\n    parameters->timed_wait_active = FALSE;\n\n    g_cancellable_cancel (parameters->cancellable);\n\n    if (parameters->files_handle)\n    {\n        nautilus_file_list_cancel_call_when_ready (parameters->files_handle);\n        parameters->files_handle = NULL;\n        activation_parameters_free (parameters);\n    }\n}\n\nstatic void\nactivation_start_timed_cancel (ActivateParameters *parameters)\n{\n    parameters->timed_wait_active = TRUE;\n    eel_timed_wait_start_with_duration\n        (DELAY_UNTIL_CANCEL_MSECS,\n        cancel_activate_callback,\n        parameters,\n        parameters->timed_wait_prompt,\n        parameters->parent_window);\n}\n\nstatic void\npause_activation_timed_cancel (ActivateParameters *parameters)\n{\n    if (parameters->timed_wait_active)\n    {\n        eel_timed_wait_stop (cancel_activate_callback, parameters);\n        parameters->timed_wait_active = FALSE;\n    }\n}\n\nstatic void\nunpause_activation_timed_cancel (ActivateParameters *parameters)\n{\n    if (!parameters->timed_wait_active)\n    {\n        activation_start_timed_cancel (parameters);\n    }\n}\n\n\nstatic void\nactivate_mount_op_active (GtkMountOperation  *operation,\n                          GParamSpec         *pspec,\n                          ActivateParameters *parameters)\n{\n    gboolean is_active;\n\n    g_object_get (operation, \"is-showing\", &is_active, NULL);\n\n    if (is_active)\n    {\n        pause_activation_timed_cancel (parameters);\n    }\n    else\n    {\n        unpause_activation_timed_cancel (parameters);\n    }\n}\n\nstatic gboolean\nconfirm_multiple_windows (GtkWindow *parent_window,\n                          int        count,\n                          gboolean   use_tabs)\n{\n    GtkDialog *dialog;\n    char *prompt;\n    char *detail;\n    int response;\n\n    if (count <= SILENT_WINDOW_OPEN_LIMIT)\n    {\n        return TRUE;\n    }\n\n    prompt = _(\"Are you sure you want to open all files?\");\n    if (use_tabs)\n    {\n        detail = g_strdup_printf (ngettext (\"This will open %d separate tab.\",\n                                            \"This will open %d separate tabs.\", count), count);\n    }\n    else\n    {\n        detail = g_strdup_printf (ngettext (\"This will open %d separate window.\",\n                                            \"This will open %d separate windows.\", count), count);\n    }\n    dialog = eel_show_yes_no_dialog (prompt, detail,\n                                     _(\"_OK\"), _(\"_Cancel\"),\n                                     parent_window);\n    g_free (detail);\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    return response == GTK_RESPONSE_YES;\n}\n\ntypedef struct\n{\n    NautilusWindowSlot *slot;\n    GtkWindow *parent_window;\n    NautilusFile *file;\n    GList *files;\n    NautilusWindowOpenFlags flags;\n    char *activation_directory;\n    gboolean user_confirmation;\n    char *uri;\n    GDBusProxy *proxy;\n    GtkWidget *dialog;\n} ActivateParametersInstall;\n\nstatic void\nactivate_parameters_install_free (ActivateParametersInstall *parameters_install)\n{\n    if (parameters_install->slot)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters_install->slot), (gpointer *) &parameters_install->slot);\n    }\n    if (parameters_install->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *) &parameters_install->parent_window);\n    }\n\n    if (parameters_install->proxy != NULL)\n    {\n        g_object_unref (parameters_install->proxy);\n    }\n\n    nautilus_file_unref (parameters_install->file);\n    nautilus_file_list_free (parameters_install->files);\n    g_free (parameters_install->activation_directory);\n    g_free (parameters_install->uri);\n    g_free (parameters_install);\n}\n\nstatic char *\nget_application_no_mime_type_handler_message (NautilusFile *file,\n                                              char         *uri)\n{\n    char *uri_for_display;\n    char *name;\n    char *error_message;\n\n    name = nautilus_file_get_display_name (file);\n\n    /* Truncate the URI so it doesn't get insanely wide. Note that even\n     * though the dialog uses wrapped text, if the URI doesn't contain\n     * white space then the text-wrapping code is too stupid to wrap it.\n     */\n    uri_for_display = eel_str_middle_truncate (name, MAX_URI_IN_DIALOG_LENGTH);\n    error_message = g_strdup_printf (_(\"Could not display \u201c%s\u201d.\"), uri_for_display);\n    g_free (uri_for_display);\n    g_free (name);\n\n    return error_message;\n}\n\nstatic void\nopen_with_response_cb (GtkDialog *dialog,\n                       gint       response_id,\n                       gpointer   user_data)\n{\n    GtkWindow *parent_window;\n    NautilusFile *file;\n    GList files;\n    GAppInfo *info;\n    ActivateParametersInstall *parameters = user_data;\n\n    if (response_id != GTK_RESPONSE_OK)\n    {\n        gtk_widget_destroy (GTK_WIDGET (dialog));\n        return;\n    }\n\n    parent_window = parameters->parent_window;\n    file = g_object_get_data (G_OBJECT (dialog), \"mime-action:file\");\n    info = gtk_app_chooser_get_app_info (GTK_APP_CHOOSER (dialog));\n\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    g_signal_emit_by_name (nautilus_signaller_get_current (), \"mime-data-changed\");\n\n    files.next = NULL;\n    files.prev = NULL;\n    files.data = file;\n    nautilus_launch_application (info, &files, parent_window);\n\n    g_object_unref (info);\n\n    activate_parameters_install_free (parameters);\n}\n\nstatic void\nchoose_program (GtkDialog *message_dialog,\n                int        response,\n                gpointer   callback_data)\n{\n    GtkWidget *dialog;\n    NautilusFile *file;\n    GFile *location;\n    ActivateParametersInstall *parameters = callback_data;\n\n    if (response != GTK_RESPONSE_ACCEPT)\n    {\n        gtk_widget_destroy (GTK_WIDGET (message_dialog));\n        activate_parameters_install_free (parameters);\n        return;\n    }\n\n    file = g_object_get_data (G_OBJECT (message_dialog), \"mime-action:file\");\n\n    g_assert (NAUTILUS_IS_FILE (file));\n\n    location = nautilus_file_get_location (file);\n    nautilus_file_ref (file);\n\n    /* Destroy the message dialog after ref:ing the file */\n    gtk_widget_destroy (GTK_WIDGET (message_dialog));\n\n    dialog = gtk_app_chooser_dialog_new (parameters->parent_window,\n                                         GTK_DIALOG_MODAL,\n                                         location);\n    g_object_set_data_full (G_OBJECT (dialog),\n                            \"mime-action:file\",\n                            nautilus_file_ref (file),\n                            (GDestroyNotify) nautilus_file_unref);\n\n    gtk_widget_show (dialog);\n\n    g_signal_connect (dialog,\n                      \"response\",\n                      G_CALLBACK (open_with_response_cb),\n                      parameters);\n\n    g_object_unref (location);\n    nautilus_file_unref (file);\n}\n\nstatic void\nshow_unhandled_type_error (ActivateParametersInstall *parameters)\n{\n    GtkWidget *dialog;\n\n    char *mime_type = nautilus_file_get_mime_type (parameters->file);\n    char *error_message = get_application_no_mime_type_handler_message (parameters->file, parameters->uri);\n    if (g_content_type_is_unknown (mime_type))\n    {\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,\n                                         GTK_MESSAGE_ERROR,\n                                         0,\n                                         \"%s\", error_message);\n        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                                  _(\"The file is of an unknown type\"));\n    }\n    else\n    {\n        char *text;\n        text = g_strdup_printf (_(\"There is no application installed for \u201c%s\u201d files\"), g_content_type_get_description (mime_type));\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,\n                                         GTK_MESSAGE_ERROR,\n                                         0,\n                                         \"%s\", error_message);\n        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                                  \"%s\", text);\n\n        g_free (text);\n    }\n\n    gtk_dialog_add_button (GTK_DIALOG (dialog), _(\"_Select Application\"), GTK_RESPONSE_ACCEPT);\n\n    gtk_dialog_add_button (GTK_DIALOG (dialog), _(\"_OK\"), GTK_RESPONSE_OK);\n\n    gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_OK);\n\n    g_object_set_data_full (G_OBJECT (dialog),\n                            \"mime-action:file\",\n                            nautilus_file_ref (parameters->file),\n                            (GDestroyNotify) nautilus_file_unref);\n\n    gtk_widget_show (GTK_WIDGET (dialog));\n\n    g_signal_connect (dialog, \"response\",\n                      G_CALLBACK (choose_program), parameters);\n\n    g_free (error_message);\n    g_free (mime_type);\n}\n\nstatic void\nsearch_for_application_dbus_call_notify_cb (GDBusProxy   *proxy,\n                                            GAsyncResult *result,\n                                            gpointer      user_data)\n{\n    ActivateParametersInstall *parameters_install = user_data;\n    GVariant *variant;\n    GError *error = NULL;\n\n    variant = g_dbus_proxy_call_finish (proxy, result, &error);\n    if (variant == NULL)\n    {\n        if (!g_dbus_error_is_remote_error (error) ||\n            g_strcmp0 (g_dbus_error_get_remote_error (error), \"org.freedesktop.PackageKit.Modify.Failed\") == 0)\n        {\n            char *message;\n\n            message = g_strdup_printf (\"%s\\n%s\",\n                                       _(\"There was an internal error trying to search for applications:\"),\n                                       error->message);\n            eel_show_error_dialog (_(\"Unable to search for application\"), message,\n                                   parameters_install->parent_window);\n            g_free (message);\n        }\n        else\n        {\n            g_warning (\"Error while trying to search for applications: %s\",\n                       error->message);\n        }\n\n        g_error_free (error);\n        activate_parameters_install_free (parameters_install);\n        return;\n    }\n\n    g_variant_unref (variant);\n\n    /* activate the file again */\n    nautilus_mime_activate_files (parameters_install->parent_window,\n                                  parameters_install->slot,\n                                  parameters_install->files,\n                                  parameters_install->activation_directory,\n                                  parameters_install->flags,\n                                  parameters_install->user_confirmation);\n\n    activate_parameters_install_free (parameters_install);\n}\n\nstatic void\nsearch_for_application_mime_type (ActivateParametersInstall *parameters_install,\n                                  const gchar               *mime_type)\n{\n    GdkWindow *window;\n    guint xid = 0;\n    const char *mime_types[2];\n\n    g_assert (parameters_install->proxy != NULL);\n\n    /* get XID from parent window */\n    window = gtk_widget_get_window (GTK_WIDGET (parameters_install->parent_window));\n    if (window != NULL)\n    {\n        xid = GDK_WINDOW_XID (window);\n    }\n\n    mime_types[0] = mime_type;\n    mime_types[1] = NULL;\n\n    g_dbus_proxy_call (parameters_install->proxy,\n                       \"InstallMimeTypes\",\n                       g_variant_new (\"(u^ass)\",\n                                      xid,\n                                      mime_types,\n                                      \"hide-confirm-search\"),\n                       G_DBUS_CALL_FLAGS_NONE,\n                       G_MAXINT /* no timeout */,\n                       NULL /* cancellable */,\n                       (GAsyncReadyCallback) search_for_application_dbus_call_notify_cb,\n                       parameters_install);\n\n    DEBUG (\"InstallMimeType method invoked for %s\", mime_type);\n}\n\nstatic void\napplication_unhandled_file_install (GtkDialog                 *dialog,\n                                    gint                       response_id,\n                                    ActivateParametersInstall *parameters_install)\n{\n    char *mime_type;\n\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    parameters_install->dialog = NULL;\n\n    if (response_id == GTK_RESPONSE_YES)\n    {\n        mime_type = nautilus_file_get_mime_type (parameters_install->file);\n        search_for_application_mime_type (parameters_install, mime_type);\n        g_free (mime_type);\n    }\n    else\n    {\n        /* free as we're not going to get the async dbus callback */\n        activate_parameters_install_free (parameters_install);\n    }\n}\n\nstatic gboolean\ndelete_cb (GtkDialog *dialog)\n{\n    gtk_dialog_response (dialog, GTK_RESPONSE_DELETE_EVENT);\n    return TRUE;\n}\n\nstatic void\npk_proxy_appeared_cb (GObject      *source,\n                      GAsyncResult *res,\n                      gpointer      user_data)\n{\n    ActivateParametersInstall *parameters_install = user_data;\n    char *mime_type, *name_owner;\n    char *error_message;\n    GtkWidget *dialog;\n    GDBusProxy *proxy;\n    GError *error = NULL;\n\n    proxy = g_dbus_proxy_new_for_bus_finish (res, &error);\n    name_owner = g_dbus_proxy_get_name_owner (proxy);\n\n    if (error != NULL || name_owner == NULL)\n    {\n        g_warning (\"Couldn't call Modify on the PackageKit interface: %s\",\n                   error != NULL ? error->message : \"no owner for PackageKit\");\n        g_clear_error (&error);\n\n        /* show an unhelpful dialog */\n        show_unhandled_type_error (parameters_install);\n\n        return;\n    }\n\n    g_free (name_owner);\n\n    mime_type = nautilus_file_get_mime_type (parameters_install->file);\n    error_message = get_application_no_mime_type_handler_message (parameters_install->file,\n                                                                  parameters_install->uri);\n    /* use a custom dialog to prompt the user to install new software */\n    dialog = gtk_message_dialog_new (parameters_install->parent_window, 0,\n                                     GTK_MESSAGE_ERROR,\n                                     GTK_BUTTONS_YES_NO,\n                                     \"%s\", error_message);\n    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                              _(\"There is no application installed for \u201c%s\u201d files.\\n\"\n                                                \"Do you want to search for an application to open this file?\"),\n                                              g_content_type_get_description (mime_type));\n    gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n    parameters_install->dialog = dialog;\n    parameters_install->proxy = proxy;\n\n    g_signal_connect (dialog, \"response\",\n                      G_CALLBACK (application_unhandled_file_install),\n                      parameters_install);\n    g_signal_connect (dialog, \"delete-event\",\n                      G_CALLBACK (delete_cb), NULL);\n    gtk_widget_show_all (dialog);\n    g_free (mime_type);\n}\n\nstatic void\napplication_unhandled_uri (ActivateParameters *parameters,\n                           char               *uri)\n{\n    gboolean show_install_mime;\n    char *mime_type;\n    NautilusFile *file;\n    ActivateParametersInstall *parameters_install;\n\n    file = nautilus_file_get_by_uri (uri);\n\n    mime_type = nautilus_file_get_mime_type (file);\n\n    /* copy the parts of parameters we are interested in as the orignal will be unref'd */\n    parameters_install = g_new0 (ActivateParametersInstall, 1);\n    parameters_install->slot = parameters->slot;\n    g_object_add_weak_pointer (G_OBJECT (parameters_install->slot), (gpointer *) &parameters_install->slot);\n    if (parameters->parent_window)\n    {\n        parameters_install->parent_window = parameters->parent_window;\n        g_object_add_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *) &parameters_install->parent_window);\n    }\n    parameters_install->activation_directory = g_strdup (parameters->activation_directory);\n    parameters_install->file = file;\n    parameters_install->files = get_file_list_for_launch_locations (parameters->locations);\n    parameters_install->flags = parameters->flags;\n    parameters_install->user_confirmation = parameters->user_confirmation;\n    parameters_install->uri = g_strdup (uri);\n\n#ifdef ENABLE_PACKAGEKIT\n    /* allow an admin to disable the PackageKit search functionality */\n    show_install_mime = g_settings_get_boolean (nautilus_preferences, NAUTILUS_PREFERENCES_INSTALL_MIME_ACTIVATION);\n#else\n    /* we have no install functionality */\n    show_install_mime = FALSE;\n#endif\n    /* There is no use trying to look for handlers of application/octet-stream */\n    if (g_content_type_is_unknown (mime_type))\n    {\n        show_install_mime = FALSE;\n    }\n\n    g_free (mime_type);\n\n    if (!show_install_mime)\n    {\n        goto out;\n    }\n\n    g_dbus_proxy_new_for_bus (G_BUS_TYPE_SESSION,\n                              G_DBUS_PROXY_FLAGS_NONE,\n                              NULL,\n                              \"org.freedesktop.PackageKit\",\n                              \"/org/freedesktop/PackageKit\",\n                              \"org.freedesktop.PackageKit.Modify\",\n                              NULL,\n                              pk_proxy_appeared_cb,\n                              parameters_install);\n\n    return;\n\nout:\n    /* show an unhelpful dialog */\n    show_unhandled_type_error (parameters_install);\n}\n\ntypedef struct\n{\n    GtkWindow *parent_window;\n    NautilusFile *file;\n} ActivateParametersDesktop;\n\nstatic void\nactivate_parameters_desktop_free (ActivateParametersDesktop *parameters_desktop)\n{\n    if (parameters_desktop->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n    }\n    nautilus_file_unref (parameters_desktop->file);\n    g_free (parameters_desktop);\n}\n\nstatic void\nuntrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n\n        default:\n        {\n            /* Just destroy dialog */\n        }\n        break;\n    }\n\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}\n\nstatic void\nactivate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        /* copy the parts of parameters we are interested in as the orignal will be freed */\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher \u201c%s\u201d has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}\n\nstatic void\nactivate_files (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    NautilusWindow *window;\n    NautilusWindowOpenFlags flags;\n    g_autoptr (GList) open_in_app_parameters = NULL;\n    g_autoptr (GList) unhandled_open_in_app_uris = NULL;\n    ApplicationLaunchParameters *one_parameters;\n    int count;\n    g_autofree char *old_working_dir = NULL;\n    GdkScreen *screen;\n    gint num_apps;\n    gint num_unhandled;\n    gint num_files;\n    gboolean open_files;\n    gboolean closed_window;\n    g_autoptr (GQueue) launch_desktop_files = NULL;\n    g_autoptr (GQueue) launch_files = NULL;\n    g_autoptr (GQueue) launch_in_terminal_files = NULL;\n    g_autoptr (GQueue) open_in_app_uris = NULL;\n    g_autoptr (GQueue) open_in_view_files = NULL;\n    GList *l;\n    ActivationAction action;\n    LaunchLocation *location;\n\n    launch_desktop_files = g_queue_new ();\n    launch_files = g_queue_new ();\n    launch_in_terminal_files = g_queue_new ();\n    open_in_view_files = g_queue_new ();\n    open_in_app_uris = g_queue_new ();\n\n    for (l = parameters->locations; l != NULL; l = l->next)\n    {\n        location = l->data;\n        file = location->file;\n\n        if (file_was_cancelled (file))\n        {\n            continue;\n        }\n\n        action = get_activation_action (file);\n        if (action == ACTIVATION_ACTION_ASK)\n        {\n            /* Special case for executable text files, since it might be\n             * dangerous & unexpected to launch these.\n             */\n            pause_activation_timed_cancel (parameters);\n            action = get_executable_text_file_action (parameters->parent_window, file);\n            unpause_activation_timed_cancel (parameters);\n        }\n\n        switch (action)\n        {\n            case ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE:\n            {\n                g_queue_push_tail (launch_desktop_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_LAUNCH:\n            {\n                g_queue_push_tail (launch_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_LAUNCH_IN_TERMINAL:\n            {\n                g_queue_push_tail (launch_in_terminal_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_OPEN_IN_VIEW:\n            {\n                g_queue_push_tail (open_in_view_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_OPEN_IN_APPLICATION:\n            {\n                g_queue_push_tail (open_in_app_uris, location->uri);\n            }\n            break;\n\n            case ACTIVATION_ACTION_DO_NOTHING:\n            {\n            }\n            break;\n\n            case ACTIVATION_ACTION_EXTRACT:\n            {\n                /* Extraction of files should be handled in the view */\n                g_assert_not_reached ();\n            }\n            break;\n\n            case ACTIVATION_ACTION_ASK:\n            {\n                g_assert_not_reached ();\n            }\n            break;\n        }\n    }\n\n    for (l = g_queue_peek_head_link (launch_desktop_files); l != NULL; l = l->next)\n    {\n        file = NAUTILUS_FILE (l->data);\n\n        activate_desktop_file (parameters, file);\n    }\n\n    if (parameters->activation_directory &&\n        (!g_queue_is_empty (launch_files) ||\n         !g_queue_is_empty (launch_in_terminal_files)))\n    {\n        old_working_dir = g_get_current_dir ();\n        g_chdir (parameters->activation_directory);\n    }\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    for (l = g_queue_peek_head_link (launch_files); l != NULL; l = l->next)\n    {\n        g_autofree char *uri = NULL;\n        g_autofree char *executable_path = NULL;\n        g_autofree char *quoted_path = NULL;\n\n        file = NAUTILUS_FILE (l->data);\n\n        uri = nautilus_file_get_activation_uri (file);\n        executable_path = g_filename_from_uri (uri, NULL, NULL);\n        quoted_path = g_shell_quote (executable_path);\n\n        DEBUG (\"Launching file path %s\", quoted_path);\n\n        nautilus_launch_application_from_command (screen, quoted_path, FALSE, NULL);\n    }\n\n    for (l = g_queue_peek_head_link (launch_in_terminal_files); l != NULL; l = l->next)\n    {\n        g_autofree char *uri = NULL;\n        g_autofree char *executable_path = NULL;\n        g_autofree char *quoted_path = NULL;\n\n        file = NAUTILUS_FILE (l->data);\n\n        uri = nautilus_file_get_activation_uri (file);\n        executable_path = g_filename_from_uri (uri, NULL, NULL);\n        quoted_path = g_shell_quote (executable_path);\n\n        DEBUG (\"Launching in terminal file quoted path %s\", quoted_path);\n\n        nautilus_launch_application_from_command (screen, quoted_path, TRUE, NULL);\n    }\n\n    if (old_working_dir != NULL)\n    {\n        g_chdir (old_working_dir);\n    }\n\n    count = g_queue_get_length (open_in_view_files);\n\n    flags = parameters->flags;\n    if (count > 1)\n    {\n        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0)\n        {\n            /* if CLOSE_BEHIND is set and we have a directory to be activated, we\n             * will first have to open a new window and after that we can open the\n             * rest of files in tabs */\n            if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)\n            {\n                flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n            }\n            else\n            {\n                flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;\n            }\n        }\n        else\n        {\n            flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n        }\n    }\n    else\n    {\n        /* if we want to close the window and activate a single directory, then we will need\n         * the NEW_WINDOW flag set */\n        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)\n        {\n            flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n        }\n    }\n\n    if (parameters->slot != NULL &&\n        (!parameters->user_confirmation ||\n         confirm_multiple_windows (parameters->parent_window, count,\n                                   (flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0)))\n    {\n        if ((flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0 &&\n            g_settings_get_enum (nautilus_preferences, NAUTILUS_PREFERENCES_NEW_TAB_POSITION) ==\n            NAUTILUS_NEW_TAB_POSITION_AFTER_CURRENT_TAB)\n        {\n            /* When inserting N tabs after the current one,\n             * we first open tab N, then tab N-1, ..., then tab 0.\n             * Each of them is appended to the current tab, i.e.\n             * prepended to the list of tabs to open.\n             */\n            g_queue_reverse (open_in_view_files);\n        }\n\n        closed_window = FALSE;\n\n        for (l = g_queue_peek_head_link (open_in_view_files); l != NULL; l = l->next)\n        {\n            g_autofree char *uri = NULL;\n            g_autoptr (GFile) location = NULL;\n            g_autoptr (GFile) location_with_permissions = NULL;\n            /* The ui should ask for navigation or object windows\n             * depending on what the current one is */\n            file = NAUTILUS_FILE (l->data);\n            uri = nautilus_file_get_activation_uri (file);\n            location = g_file_new_for_uri (uri);\n            if (g_file_is_native (location) &&\n                (nautilus_file_is_in_admin (file) ||\n                 !nautilus_file_can_read (file) ||\n                 !nautilus_file_can_execute (file)))\n            {\n                g_autofree gchar *file_path = NULL;\n\n                g_free (uri);\n\n                file_path = g_file_get_path (location);\n                uri = g_strconcat (\"admin://\", file_path, NULL);\n            }\n\n            location_with_permissions = g_file_new_for_uri (uri);\n            /* FIXME: we need to pass the parent_window, but we only use it for the current active window,\n             * which nautilus-application should take care of. However is not working and creating regressions\n             * in some cases. Until we figure out what's going on, continue to use the parameters->slot\n             * to make splicit the window we want to use for activating the files */\n            nautilus_application_open_location_full (NAUTILUS_APPLICATION (g_application_get_default ()),\n                                                     location_with_permissions, flags, NULL, NULL, parameters->slot);\n\n            /* close only the window from which the action was launched and then open\n             * tabs/windows (depending on parameters->flags) */\n            if (!closed_window && (flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)\n            {\n                flags &= (~NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND);\n\n                /* if NEW_WINDOW is set, we want all files in new windows, not in tabs */\n                if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0)\n                {\n                    flags &= (~NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW);\n                    flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;\n                }\n\n                closed_window = TRUE;\n            }\n        }\n    }\n\n    if (open_in_app_uris != NULL)\n    {\n        open_in_app_parameters = make_activation_parameters (g_queue_peek_head_link (open_in_app_uris),\n                                                             &unhandled_open_in_app_uris);\n    }\n\n    num_apps = g_list_length (open_in_app_parameters);\n    num_unhandled = g_list_length (unhandled_open_in_app_uris);\n    num_files = g_queue_get_length (open_in_app_uris);\n    open_files = TRUE;\n\n    if (g_queue_is_empty (open_in_app_uris) &&\n        (!parameters->user_confirmation ||\n         num_files + num_unhandled > SILENT_OPEN_LIMIT) &&\n        num_apps > 1)\n    {\n        GtkDialog *dialog;\n        char *prompt;\n        g_autofree char *detail = NULL;\n        int response;\n\n        pause_activation_timed_cancel (parameters);\n\n        prompt = _(\"Are you sure you want to open all files?\");\n        detail = g_strdup_printf (ngettext (\"This will open %d separate application.\",\n                                            \"This will open %d separate applications.\", num_apps), num_apps);\n        dialog = eel_show_yes_no_dialog (prompt, detail,\n                                         _(\"_OK\"), _(\"_Cancel\"),\n                                         parameters->parent_window);\n        response = gtk_dialog_run (dialog);\n        gtk_widget_destroy (GTK_WIDGET (dialog));\n\n        unpause_activation_timed_cancel (parameters);\n\n        if (response != GTK_RESPONSE_YES)\n        {\n            open_files = FALSE;\n        }\n    }\n\n    if (open_files)\n    {\n        for (l = open_in_app_parameters; l != NULL; l = l->next)\n        {\n            one_parameters = l->data;\n\n            nautilus_launch_application_by_uri (one_parameters->application,\n                                                one_parameters->uris,\n                                                parameters->parent_window);\n            application_launch_parameters_free (one_parameters);\n        }\n\n        for (l = unhandled_open_in_app_uris; l != NULL; l = l->next)\n        {\n            char *uri = l->data;\n\n            /* this does not block */\n            application_unhandled_uri (parameters, uri);\n        }\n    }\n\n    window = NULL;\n    if (parameters->slot != NULL)\n    {\n        window = nautilus_window_slot_get_window (parameters->slot);\n    }\n\n    if (open_in_app_parameters != NULL ||\n        unhandled_open_in_app_uris != NULL)\n    {\n        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0 &&\n            window != NULL)\n        {\n            nautilus_window_close (window);\n        }\n    }\n\n    activation_parameters_free (parameters);\n}\n\nstatic void\nactivation_mount_not_mounted_callback (GObject      *source_object,\n                                       GAsyncResult *res,\n                                       gpointer      user_data)\n{\n    ActivateParameters *parameters = user_data;\n    GError *error;\n    NautilusFile *file;\n    LaunchLocation *loc;\n\n    file = parameters->not_mounted->data;\n\n    error = NULL;\n    if (!g_file_mount_enclosing_volume_finish (G_FILE (source_object), res, &error))\n    {\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_CANCELLED &&\n             error->code != G_IO_ERROR_FAILED_HANDLED &&\n             error->code != G_IO_ERROR_ALREADY_MOUNTED))\n        {\n            eel_show_error_dialog (_(\"Unable to access location\"), error->message, parameters->parent_window);\n        }\n\n        if (error->domain != G_IO_ERROR ||\n            error->code != G_IO_ERROR_ALREADY_MOUNTED)\n        {\n            loc = find_launch_location_for_file (parameters->locations,\n                                                 file);\n            if (loc)\n            {\n                parameters->locations =\n                    g_list_remove (parameters->locations, loc);\n                launch_location_free (loc);\n            }\n        }\n\n        g_error_free (error);\n    }\n\n    parameters->not_mounted = g_list_delete_link (parameters->not_mounted,\n                                                  parameters->not_mounted);\n    nautilus_file_unref (file);\n\n    activation_mount_not_mounted (parameters);\n}\n\nstatic void\nactivation_mount_not_mounted (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    GFile *location;\n    LaunchLocation *loc;\n    GMountOperation *mount_op;\n    GList *l, *next, *files;\n\n    if (parameters->not_mounted != NULL)\n    {\n        file = parameters->not_mounted->data;\n        mount_op = gtk_mount_operation_new (parameters->parent_window);\n        g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);\n        g_signal_connect (mount_op, \"notify::is-showing\",\n                          G_CALLBACK (activate_mount_op_active), parameters);\n        location = nautilus_file_get_location (file);\n        g_file_mount_enclosing_volume (location, 0, mount_op, parameters->cancellable,\n                                       activation_mount_not_mounted_callback, parameters);\n        g_object_unref (location);\n        /* unref mount_op here - g_file_mount_enclosing_volume() does ref for itself */\n        g_object_unref (mount_op);\n        return;\n    }\n\n    parameters->tried_mounting = TRUE;\n\n    if (parameters->locations == NULL)\n    {\n        activation_parameters_free (parameters);\n        return;\n    }\n\n    /*  once the mount is finished, refresh all attributes        */\n    /*  - fixes new windows not appearing after successful mount  */\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        loc = l->data;\n        next = l->next;\n        nautilus_file_invalidate_all_attributes (loc->file);\n    }\n\n    files = get_file_list_for_launch_locations (parameters->locations);\n    nautilus_file_list_call_when_ready\n        (files,\n        nautilus_mime_actions_get_required_file_attributes (),\n        &parameters->files_handle,\n        activate_callback, parameters);\n    nautilus_file_list_free (files);\n}\n\n\nstatic void\nactivate_callback (GList    *files,\n                   gpointer  callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    GList *l, *next;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    parameters->files_handle = NULL;\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n\n        if (file_was_not_mounted (file))\n        {\n            if (parameters->tried_mounting)\n            {\n                launch_location_free (location);\n                parameters->locations = g_list_delete_link (parameters->locations, l);\n            }\n            else\n            {\n                parameters->not_mounted = g_list_prepend (parameters->not_mounted,\n                                                          nautilus_file_ref (file));\n            }\n            continue;\n        }\n    }\n\n\n    if (parameters->not_mounted != NULL)\n    {\n        activation_mount_not_mounted (parameters);\n    }\n    else\n    {\n        activate_files (parameters);\n    }\n}\n\nstatic void\nactivate_activation_uris_ready_callback (GList    *files_ignore,\n                                         gpointer  callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    GList *l, *next, *files;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    parameters->files_handle = NULL;\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n\n        if (nautilus_file_is_broken_symbolic_link (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            pause_activation_timed_cancel (parameters);\n            report_broken_symbolic_link (parameters->parent_window, file);\n            unpause_activation_timed_cancel (parameters);\n            continue;\n        }\n\n        if (nautilus_file_get_file_type (file) == G_FILE_TYPE_MOUNTABLE &&\n            !nautilus_file_has_activation_uri (file))\n        {\n            /* Don't launch these... There is nothing we\n             *  can do */\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n    }\n\n    if (parameters->locations == NULL)\n    {\n        activation_parameters_free (parameters);\n        return;\n    }\n\n    /* Convert the files to the actual activation uri files */\n    for (l = parameters->locations; l != NULL; l = l->next)\n    {\n        char *uri;\n        location = l->data;\n\n        /* We want the file for the activation URI since we care\n         * about the attributes for that, not for the original file.\n         */\n        uri = nautilus_file_get_activation_uri (location->file);\n        if (uri != NULL)\n        {\n            launch_location_update_from_uri (location, uri);\n        }\n        g_free (uri);\n    }\n\n\n    /* get the parameters for the actual files */\n    files = get_file_list_for_launch_locations (parameters->locations);\n    nautilus_file_list_call_when_ready\n        (files,\n        nautilus_mime_actions_get_required_file_attributes (),\n        &parameters->files_handle,\n        activate_callback, parameters);\n    nautilus_file_list_free (files);\n}\n\nstatic void\nactivation_get_activation_uris (ActivateParameters *parameters)\n{\n    GList *l, *files;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    /* link target info might be stale, re-read it */\n    for (l = parameters->locations; l != NULL; l = l->next)\n    {\n        location = l->data;\n        file = location->file;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n    }\n\n    if (parameters->locations == NULL)\n    {\n        activation_parameters_free (parameters);\n        return;\n    }\n\n    files = get_file_list_for_launch_locations (parameters->locations);\n    nautilus_file_list_call_when_ready\n        (files, nautilus_mime_actions_get_required_file_attributes (),\n        &parameters->files_handle,\n        activate_activation_uris_ready_callback, parameters);\n    nautilus_file_list_free (files);\n}\n\nstatic void\nactivation_mountable_mounted (NautilusFile *file,\n                              GFile        *result_location,\n                              GError       *error,\n                              gpointer      callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    NautilusFile *target_file;\n    LaunchLocation *location;\n\n    /* Remove from list of files that have to be mounted */\n    parameters->mountables = g_list_remove (parameters->mountables, file);\n    nautilus_file_unref (file);\n\n\n    if (error == NULL)\n    {\n        /* Replace file with the result of the mount */\n        target_file = nautilus_file_get (result_location);\n\n        location = find_launch_location_for_file (parameters->locations,\n                                                  file);\n        if (location)\n        {\n            launch_location_update_from_file (location, target_file);\n        }\n        nautilus_file_unref (target_file);\n    }\n    else\n    {\n        /* Remove failed file */\n\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_FAILED_HANDLED &&\n             error->code != G_IO_ERROR_ALREADY_MOUNTED))\n        {\n            location = find_launch_location_for_file (parameters->locations,\n                                                      file);\n            if (location)\n            {\n                parameters->locations =\n                    g_list_remove (parameters->locations,\n                                   location);\n                launch_location_free (location);\n            }\n        }\n\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_CANCELLED &&\n             error->code != G_IO_ERROR_FAILED_HANDLED &&\n             error->code != G_IO_ERROR_ALREADY_MOUNTED))\n        {\n            eel_show_error_dialog (_(\"Unable to access location\"),\n                                   error->message, parameters->parent_window);\n        }\n\n        if (error->code == G_IO_ERROR_CANCELLED)\n        {\n            activation_parameters_free (parameters);\n            return;\n        }\n    }\n\n    /* Mount more mountables */\n    activation_mount_mountables (parameters);\n}\n\n\nstatic void\nactivation_mount_mountables (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    GMountOperation *mount_op;\n\n    if (parameters->mountables != NULL)\n    {\n        file = parameters->mountables->data;\n        mount_op = gtk_mount_operation_new (parameters->parent_window);\n        g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);\n        g_signal_connect (mount_op, \"notify::is-showing\",\n                          G_CALLBACK (activate_mount_op_active), parameters);\n        nautilus_file_mount (file,\n                             mount_op,\n                             parameters->cancellable,\n                             activation_mountable_mounted,\n                             parameters);\n        g_object_unref (mount_op);\n        return;\n    }\n\n    if (parameters->mountables == NULL && parameters->start_mountables == NULL)\n    {\n        activation_get_activation_uris (parameters);\n    }\n}\n\n\nstatic void\nactivation_mountable_started (NautilusFile *file,\n                              GFile        *gfile_of_file,\n                              GError       *error,\n                              gpointer      callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    LaunchLocation *location;\n\n    /* Remove from list of files that have to be mounted */\n    parameters->start_mountables = g_list_remove (parameters->start_mountables, file);\n    nautilus_file_unref (file);\n\n    if (error == NULL)\n    {\n        /* Remove file */\n        location = find_launch_location_for_file (parameters->locations, file);\n        if (location != NULL)\n        {\n            parameters->locations = g_list_remove (parameters->locations, location);\n            launch_location_free (location);\n        }\n    }\n    else\n    {\n        /* Remove failed file */\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_FAILED_HANDLED))\n        {\n            location = find_launch_location_for_file (parameters->locations,\n                                                      file);\n            if (location)\n            {\n                parameters->locations =\n                    g_list_remove (parameters->locations,\n                                   location);\n                launch_location_free (location);\n            }\n        }\n\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_CANCELLED &&\n             error->code != G_IO_ERROR_FAILED_HANDLED))\n        {\n            eel_show_error_dialog (_(\"Unable to start location\"),\n                                   error->message, NULL);\n        }\n\n        if (error->code == G_IO_ERROR_CANCELLED)\n        {\n            activation_parameters_free (parameters);\n            return;\n        }\n    }\n\n    /* Start more mountables */\n    activation_start_mountables (parameters);\n}\n\nstatic void\nactivation_start_mountables (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    GMountOperation *start_op;\n\n    if (parameters->start_mountables != NULL)\n    {\n        file = parameters->start_mountables->data;\n        start_op = gtk_mount_operation_new (parameters->parent_window);\n        g_signal_connect (start_op, \"notify::is-showing\",\n                          G_CALLBACK (activate_mount_op_active), parameters);\n        nautilus_file_start (file,\n                             start_op,\n                             parameters->cancellable,\n                             activation_mountable_started,\n                             parameters);\n        g_object_unref (start_op);\n        return;\n    }\n\n    if (parameters->mountables == NULL && parameters->start_mountables == NULL)\n    {\n        activation_get_activation_uris (parameters);\n    }\n}\n\n/**\n * nautilus_mime_activate_files:\n *\n * Activate a list of files. Each one might launch with an application or\n * with a component. This is normally called only by subclasses.\n * @view: FMDirectoryView in question.\n * @files: A GList of NautilusFiles to activate.\n *\n **/\nvoid\nnautilus_mime_activate_files (GtkWindow               *parent_window,\n                              NautilusWindowSlot      *slot,\n                              GList                   *files,\n                              const char              *launch_directory,\n                              NautilusWindowOpenFlags  flags,\n                              gboolean                 user_confirmation)\n{\n    ActivateParameters *parameters;\n    char *file_name;\n    int file_count;\n    GList *l, *next;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    if (files == NULL)\n    {\n        return;\n    }\n\n    DEBUG_FILES (files, \"Calling activate_files() with files:\");\n\n    parameters = g_new0 (ActivateParameters, 1);\n    parameters->slot = slot;\n    g_object_add_weak_pointer (G_OBJECT (parameters->slot), (gpointer *) &parameters->slot);\n    if (parent_window)\n    {\n        parameters->parent_window = parent_window;\n        g_object_add_weak_pointer (G_OBJECT (parameters->parent_window), (gpointer *) &parameters->parent_window);\n    }\n    parameters->cancellable = g_cancellable_new ();\n    parameters->activation_directory = g_strdup (launch_directory);\n    parameters->locations = launch_locations_from_file_list (files);\n    parameters->flags = flags;\n    parameters->user_confirmation = user_confirmation;\n\n    file_count = g_list_length (files);\n    if (file_count == 1)\n    {\n        file_name = nautilus_file_get_display_name (files->data);\n        parameters->timed_wait_prompt = g_strdup_printf (_(\"Opening \u201c%s\u201d.\"), file_name);\n        g_free (file_name);\n    }\n    else\n    {\n        parameters->timed_wait_prompt = g_strdup_printf (ngettext (\"Opening %d item.\",\n                                                                   \"Opening %d items.\",\n                                                                   file_count),\n                                                         file_count);\n    }\n\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (nautilus_file_can_mount (file))\n        {\n            parameters->mountables = g_list_prepend (parameters->mountables,\n                                                     nautilus_file_ref (file));\n        }\n\n        if (nautilus_file_can_start (file))\n        {\n            parameters->start_mountables = g_list_prepend (parameters->start_mountables,\n                                                           nautilus_file_ref (file));\n        }\n    }\n\n    activation_start_timed_cancel (parameters);\n    if (parameters->mountables != NULL)\n    {\n        activation_mount_mountables (parameters);\n    }\n    if (parameters->start_mountables != NULL)\n    {\n        activation_start_mountables (parameters);\n    }\n    if (parameters->mountables == NULL && parameters->start_mountables == NULL)\n    {\n        activation_get_activation_uris (parameters);\n    }\n}\n\n/**\n * nautilus_mime_activate_file:\n *\n * Activate a file in this view. This might involve switching the displayed\n * location for the current window, or launching an application.\n * @view: FMDirectoryView in question.\n * @file: A NautilusFile representing the file in this view to activate.\n * @use_new_window: Should this item be opened in a new window?\n *\n **/\n\nvoid\nnautilus_mime_activate_file (GtkWindow               *parent_window,\n                             NautilusWindowSlot      *slot,\n                             NautilusFile            *file,\n                             const char              *launch_directory,\n                             NautilusWindowOpenFlags  flags)\n{\n    GList *files;\n\n    g_return_if_fail (NAUTILUS_IS_FILE (file));\n\n    files = g_list_prepend (NULL, file);\n    nautilus_mime_activate_files (parent_window, slot, files, launch_directory, flags, FALSE);\n    g_list_free (files);\n}\n\ngint\nnautilus_mime_types_get_number_of_groups (void)\n{\n    return G_N_ELEMENTS (mimetype_groups);\n}\n\nconst gchar *\nnautilus_mime_types_group_get_name (gint group_index)\n{\n    g_return_val_if_fail (group_index < G_N_ELEMENTS (mimetype_groups), NULL);\n\n    return gettext (mimetype_groups[group_index].name);\n}\n\nGList *\nnautilus_mime_types_group_get_mimetypes (gint group_index)\n{\n    GList *mimetypes;\n    gint i;\n\n    g_return_val_if_fail (group_index < G_N_ELEMENTS (mimetype_groups), NULL);\n\n    mimetypes = NULL;\n\n    /* Setup the new mimetypes set */\n    for (i = 0; mimetype_groups[group_index].mimetypes[i]; i++)\n    {\n        mimetypes = g_list_append (mimetypes, mimetype_groups[group_index].mimetypes[i]);\n    }\n\n    return mimetypes;\n}\n"], "fixing_code": ["/*\n *  nautilus-directory-async.c: Nautilus directory model state machine.\n *\n *  Copyright (C) 1999, 2000, 2001 Eazel, Inc.\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public\n *  License along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n *  Author: Darin Adler <darin@bentspoon.com>\n */\n\n#include <config.h>\n\n#include \"nautilus-directory-notify.h\"\n#include \"nautilus-directory-private.h\"\n#include \"nautilus-file-attributes.h\"\n#include \"nautilus-file-private.h\"\n#include \"nautilus-file-utilities.h\"\n#include \"nautilus-signaller.h\"\n#include \"nautilus-global-preferences.h\"\n#include \"nautilus-link.h\"\n#include \"nautilus-profile.h\"\n#include \"nautilus-metadata.h\"\n#include <eel/eel-glib-extensions.h>\n#include <gtk/gtk.h>\n#include <libxml/parser.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/* turn this on to see messages about each load_directory call: */\n#if 0\n#define DEBUG_LOAD_DIRECTORY\n#endif\n\n/* turn this on to check if async. job calls are balanced */\n#if 0\n#define DEBUG_ASYNC_JOBS\n#endif\n\n/* turn this on to log things starting and stopping */\n#if 0\n#define DEBUG_START_STOP\n#endif\n\n#define DIRECTORY_LOAD_ITEMS_PER_CALLBACK 100\n\n/* Keep async. jobs down to this number for all directories. */\n#define MAX_ASYNC_JOBS 10\n\nstruct TopLeftTextReadState\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n    gboolean large;\n    GCancellable *cancellable;\n};\n\nstruct LinkInfoReadState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n};\n\nstruct ThumbnailState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n    gboolean trying_original;\n    gboolean tried_original;\n};\n\nstruct MountState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n};\n\nstruct FilesystemInfoState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    NautilusFile *file;\n};\n\nstruct DirectoryLoadState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    GHashTable *load_mime_list_hash;\n    NautilusFile *load_directory_file;\n    int load_file_count;\n};\n\nstruct MimeListState\n{\n    NautilusDirectory *directory;\n    NautilusFile *mime_list_file;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    GHashTable *mime_list_hash;\n};\n\nstruct GetInfoState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n};\n\nstruct NewFilesState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    int count;\n};\n\nstruct DirectoryCountState\n{\n    NautilusDirectory *directory;\n    NautilusFile *count_file;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    int file_count;\n};\n\nstruct DeepCountState\n{\n    NautilusDirectory *directory;\n    GCancellable *cancellable;\n    GFileEnumerator *enumerator;\n    GFile *deep_count_location;\n    GList *deep_count_subdirectories;\n    GArray *seen_deep_count_inodes;\n    char *fs_id;\n};\n\n\n\ntypedef struct\n{\n    NautilusFile *file;     /* Which file, NULL means all. */\n    union\n    {\n        NautilusDirectoryCallback directory;\n        NautilusFileCallback file;\n    } callback;\n    gpointer callback_data;\n    Request request;\n    gboolean active;     /* Set to FALSE when the callback is triggered and\n                          * scheduled to be called at idle, its still kept\n                          * in the list so we can kill it when the file\n                          * goes away.\n                          */\n} ReadyCallback;\n\ntypedef struct\n{\n    NautilusFile *file;     /* Which file, NULL means all. */\n    gboolean monitor_hidden_files;     /* defines whether \"all\" includes hidden files */\n    gconstpointer client;\n    Request request;\n} Monitor;\n\ntypedef struct\n{\n    NautilusDirectory *directory;\n    NautilusInfoProvider *provider;\n    NautilusOperationHandle *handle;\n    NautilusOperationResult result;\n} InfoProviderResponse;\n\ntypedef gboolean (*RequestCheck) (Request);\ntypedef gboolean (*FileCheck) (NautilusFile *);\n\n/* Current number of async. jobs. */\nstatic int async_job_count;\nstatic GHashTable *waiting_directories;\n#ifdef DEBUG_ASYNC_JOBS\nstatic GHashTable *async_jobs;\n#endif\n\n/* Forward declarations for functions that need them. */\nstatic void     deep_count_load (DeepCountState *state,\n                                 GFile          *location);\nstatic gboolean request_is_satisfied (NautilusDirectory *directory,\n                                      NautilusFile      *file,\n                                      Request            request);\nstatic void     cancel_loading_attributes (NautilusDirectory     *directory,\n                                           NautilusFileAttributes file_attributes);\nstatic void     add_all_files_to_work_queue (NautilusDirectory *directory);\nstatic void     link_info_done (NautilusDirectory *directory,\n                                NautilusFile      *file,\n                                const char        *uri,\n                                const char        *name,\n                                GIcon             *icon,\n                                gboolean           is_launcher,\n                                gboolean           is_foreign);\nstatic void     move_file_to_low_priority_queue (NautilusDirectory *directory,\n                                                 NautilusFile      *file);\nstatic void     move_file_to_extension_queue (NautilusDirectory *directory,\n                                              NautilusFile      *file);\nstatic void     nautilus_directory_invalidate_file_attributes (NautilusDirectory     *directory,\n                                                               NautilusFileAttributes file_attributes);\n\n/* Some helpers for case-insensitive strings.\n * Move to nautilus-glib-extensions?\n */\n\nstatic gboolean\nistr_equal (gconstpointer v,\n            gconstpointer v2)\n{\n    return g_ascii_strcasecmp (v, v2) == 0;\n}\n\nstatic guint\nistr_hash (gconstpointer key)\n{\n    const char *p;\n    guint h;\n\n    h = 0;\n    for (p = key; *p != '\\0'; p++)\n    {\n        h = (h << 5) - h + g_ascii_tolower (*p);\n    }\n\n    return h;\n}\n\nstatic GHashTable *\nistr_set_new (void)\n{\n    return g_hash_table_new_full (istr_hash, istr_equal, g_free, NULL);\n}\n\nstatic void\nistr_set_insert (GHashTable *table,\n                 const char *istr)\n{\n    char *key;\n\n    key = g_strdup (istr);\n    g_hash_table_replace (table, key, key);\n}\n\nstatic void\nadd_istr_to_list (gpointer key,\n                  gpointer value,\n                  gpointer callback_data)\n{\n    GList **list;\n\n    list = callback_data;\n    *list = g_list_prepend (*list, g_strdup (key));\n}\n\nstatic GList *\nistr_set_get_as_list (GHashTable *table)\n{\n    GList *list;\n\n    list = NULL;\n    g_hash_table_foreach (table, add_istr_to_list, &list);\n    return list;\n}\n\nstatic void\nistr_set_destroy (GHashTable *table)\n{\n    g_hash_table_destroy (table);\n}\n\nstatic void\nrequest_counter_add_request (RequestCounter counter,\n                             Request        request)\n{\n    guint i;\n\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (REQUEST_WANTS_TYPE (request, i))\n        {\n            counter[i]++;\n        }\n    }\n}\n\nstatic void\nrequest_counter_remove_request (RequestCounter counter,\n                                Request        request)\n{\n    guint i;\n\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (REQUEST_WANTS_TYPE (request, i))\n        {\n            counter[i]--;\n        }\n    }\n}\n\n#if 0\nstatic void\nnautilus_directory_verify_request_counts (NautilusDirectory *directory)\n{\n    GList *l;\n    RequestCounter counters;\n    int i;\n    gboolean fail;\n\n    fail = FALSE;\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        counters[i] = 0;\n    }\n    for (l = directory->details->monitor_list; l != NULL; l = l->next)\n    {\n        Monitor *monitor = l->data;\n        request_counter_add_request (counters, monitor->request);\n    }\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (counters[i] != directory->details->monitor_counters[i])\n        {\n            g_warning (\"monitor counter for %i is wrong, expecting %d but found %d\",\n                       i, counters[i], directory->details->monitor_counters[i]);\n            fail = TRUE;\n        }\n    }\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        counters[i] = 0;\n    }\n    for (l = directory->details->call_when_ready_list; l != NULL; l = l->next)\n    {\n        ReadyCallback *callback = l->data;\n        request_counter_add_request (counters, callback->request);\n    }\n    for (i = 0; i < REQUEST_TYPE_LAST; i++)\n    {\n        if (counters[i] != directory->details->call_when_ready_counters[i])\n        {\n            g_warning (\"call when ready counter for %i is wrong, expecting %d but found %d\",\n                       i, counters[i], directory->details->call_when_ready_counters[i]);\n            fail = TRUE;\n        }\n    }\n    g_assert (!fail);\n}\n#endif\n\n/* Start a job. This is really just a way of limiting the number of\n * async. requests that we issue at any given time. Without this, the\n * number of requests is unbounded.\n */\nstatic gboolean\nasync_job_start (NautilusDirectory *directory,\n                 const char        *job)\n{\n#ifdef DEBUG_ASYNC_JOBS\n    char *key;\n#endif\n\n#ifdef DEBUG_START_STOP\n    g_message (\"starting %s in %p\", job, directory->details->location);\n#endif\n\n    g_assert (async_job_count >= 0);\n    g_assert (async_job_count <= MAX_ASYNC_JOBS);\n\n    if (async_job_count >= MAX_ASYNC_JOBS)\n    {\n        if (waiting_directories == NULL)\n        {\n            waiting_directories = g_hash_table_new (NULL, NULL);\n        }\n\n        g_hash_table_insert (waiting_directories,\n                             directory,\n                             directory);\n\n        return FALSE;\n    }\n\n#ifdef DEBUG_ASYNC_JOBS\n    {\n        char *uri;\n        if (async_jobs == NULL)\n        {\n            async_jobs = g_hash_table_new (g_str_hash, g_str_equal);\n        }\n        uri = nautilus_directory_get_uri (directory);\n        key = g_strconcat (uri, \": \", job, NULL);\n        if (g_hash_table_lookup (async_jobs, key) != NULL)\n        {\n            g_warning (\"same job twice: %s in %s\",\n                       job, uri);\n        }\n        g_free (uri);\n        g_hash_table_insert (async_jobs, key, directory);\n    }\n#endif\n\n    async_job_count += 1;\n    return TRUE;\n}\n\n/* End a job. */\nstatic void\nasync_job_end (NautilusDirectory *directory,\n               const char        *job)\n{\n#ifdef DEBUG_ASYNC_JOBS\n    char *key;\n    gpointer table_key, value;\n#endif\n\n#ifdef DEBUG_START_STOP\n    g_message (\"stopping %s in %p\", job, directory->details->location);\n#endif\n\n    g_assert (async_job_count > 0);\n\n#ifdef DEBUG_ASYNC_JOBS\n    {\n        char *uri;\n        uri = nautilus_directory_get_uri (directory);\n        g_assert (async_jobs != NULL);\n        key = g_strconcat (uri, \": \", job, NULL);\n        if (!g_hash_table_lookup_extended (async_jobs, key, &table_key, &value))\n        {\n            g_warning (\"ending job we didn't start: %s in %s\",\n                       job, uri);\n        }\n        else\n        {\n            g_hash_table_remove (async_jobs, key);\n            g_free (table_key);\n        }\n        g_free (uri);\n        g_free (key);\n    }\n#endif\n\n    async_job_count -= 1;\n}\n\n/* Helper to get one value from a hash table. */\nstatic void\nget_one_value_callback (gpointer key,\n                        gpointer value,\n                        gpointer callback_data)\n{\n    gpointer *returned_value;\n\n    returned_value = callback_data;\n    *returned_value = value;\n}\n\n/* return a single value from a hash table. */\nstatic gpointer\nget_one_value (GHashTable *table)\n{\n    gpointer value;\n\n    value = NULL;\n    if (table != NULL)\n    {\n        g_hash_table_foreach (table, get_one_value_callback, &value);\n    }\n    return value;\n}\n\n/* Wake up directories that are \"blocked\" as long as there are job\n * slots available.\n */\nstatic void\nasync_job_wake_up (void)\n{\n    static gboolean already_waking_up = FALSE;\n    gpointer value;\n\n    g_assert (async_job_count >= 0);\n    g_assert (async_job_count <= MAX_ASYNC_JOBS);\n\n    if (already_waking_up)\n    {\n        return;\n    }\n\n    already_waking_up = TRUE;\n    while (async_job_count < MAX_ASYNC_JOBS)\n    {\n        value = get_one_value (waiting_directories);\n        if (value == NULL)\n        {\n            break;\n        }\n        g_hash_table_remove (waiting_directories, value);\n        nautilus_directory_async_state_changed\n            (NAUTILUS_DIRECTORY (value));\n    }\n    already_waking_up = FALSE;\n}\n\nstatic void\ndirectory_count_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->count_in_progress != NULL)\n    {\n        g_cancellable_cancel (directory->details->count_in_progress->cancellable);\n        directory->details->count_in_progress = NULL;\n    }\n}\n\nstatic void\ndeep_count_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        g_assert (NAUTILUS_IS_FILE (directory->details->deep_count_file));\n\n        g_cancellable_cancel (directory->details->deep_count_in_progress->cancellable);\n\n        directory->details->deep_count_file->details->deep_counts_status = NAUTILUS_REQUEST_NOT_STARTED;\n\n        directory->details->deep_count_in_progress->directory = NULL;\n        directory->details->deep_count_in_progress = NULL;\n        directory->details->deep_count_file = NULL;\n\n        async_job_end (directory, \"deep count\");\n    }\n}\n\nstatic void\nmime_list_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->mime_list_in_progress != NULL)\n    {\n        g_cancellable_cancel (directory->details->mime_list_in_progress->cancellable);\n    }\n}\n\nstatic void\nlink_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->link_info_read_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->link_info_read_state->cancellable);\n        directory->details->link_info_read_state->directory = NULL;\n        directory->details->link_info_read_state = NULL;\n        async_job_end (directory, \"link info\");\n    }\n}\n\nstatic void\nthumbnail_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->thumbnail_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->thumbnail_state->cancellable);\n        directory->details->thumbnail_state->directory = NULL;\n        directory->details->thumbnail_state = NULL;\n        async_job_end (directory, \"thumbnail\");\n    }\n}\n\nstatic void\nmount_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->mount_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->mount_state->cancellable);\n        directory->details->mount_state->directory = NULL;\n        directory->details->mount_state = NULL;\n        async_job_end (directory, \"mount\");\n    }\n}\n\nstatic void\nfile_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->get_info_in_progress != NULL)\n    {\n        g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);\n        directory->details->get_info_in_progress->directory = NULL;\n        directory->details->get_info_in_progress = NULL;\n        directory->details->get_info_file = NULL;\n\n        async_job_end (directory, \"file info\");\n    }\n}\n\nstatic void\nnew_files_cancel (NautilusDirectory *directory)\n{\n    GList *l;\n    NewFilesState *state;\n\n    if (directory->details->new_files_in_progress != NULL)\n    {\n        for (l = directory->details->new_files_in_progress; l != NULL; l = l->next)\n        {\n            state = l->data;\n            g_cancellable_cancel (state->cancellable);\n            state->directory = NULL;\n        }\n        g_list_free (directory->details->new_files_in_progress);\n        directory->details->new_files_in_progress = NULL;\n    }\n}\n\nstatic int\nmonitor_key_compare (gconstpointer a,\n                     gconstpointer data)\n{\n    const Monitor *monitor;\n    const Monitor *compare_monitor;\n\n    monitor = a;\n    compare_monitor = data;\n\n    if (monitor->client < compare_monitor->client)\n    {\n        return -1;\n    }\n    if (monitor->client > compare_monitor->client)\n    {\n        return +1;\n    }\n\n    if (monitor->file < compare_monitor->file)\n    {\n        return -1;\n    }\n    if (monitor->file > compare_monitor->file)\n    {\n        return +1;\n    }\n\n    return 0;\n}\n\nstatic GList *\nfind_monitor (NautilusDirectory *directory,\n              NautilusFile      *file,\n              gconstpointer      client)\n{\n    Monitor monitor;\n\n    monitor.client = client;\n    monitor.file = file;\n\n    return g_list_find_custom (directory->details->monitor_list,\n                               &monitor,\n                               monitor_key_compare);\n}\n\nstatic void\nremove_monitor_link (NautilusDirectory *directory,\n                     GList             *link)\n{\n    Monitor *monitor;\n\n    if (link != NULL)\n    {\n        monitor = link->data;\n        request_counter_remove_request (directory->details->monitor_counters,\n                                        monitor->request);\n        directory->details->monitor_list =\n            g_list_remove_link (directory->details->monitor_list, link);\n        g_free (monitor);\n        g_list_free_1 (link);\n    }\n}\n\nstatic void\nremove_monitor (NautilusDirectory *directory,\n                NautilusFile      *file,\n                gconstpointer      client)\n{\n    remove_monitor_link (directory, find_monitor (directory, file, client));\n}\n\nRequest\nnautilus_directory_set_up_request (NautilusFileAttributes file_attributes)\n{\n    Request request;\n\n    request = 0;\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_DIRECTORY_COUNT);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DEEP_COUNTS) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_DEEP_COUNT);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_MIME_LIST);\n    }\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_INFO) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_LINK_INFO)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n        REQUEST_SET_TYPE (request, REQUEST_LINK_INFO);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_EXTENSION_INFO) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_EXTENSION_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_THUMBNAIL)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_THUMBNAIL);\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_MOUNT)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_MOUNT);\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_FILESYSTEM_INFO)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILESYSTEM_INFO);\n    }\n\n    return request;\n}\n\nstatic void\nmime_db_changed_callback (GObject           *ignore,\n                          NautilusDirectory *dir)\n{\n    NautilusFileAttributes attrs;\n\n    g_assert (dir != NULL);\n    g_assert (dir->details != NULL);\n\n    attrs = NAUTILUS_FILE_ATTRIBUTE_INFO |\n            NAUTILUS_FILE_ATTRIBUTE_LINK_INFO |\n            NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;\n\n    nautilus_directory_force_reload_internal (dir, attrs);\n}\n\nvoid\nnautilus_directory_monitor_add_internal (NautilusDirectory         *directory,\n                                         NautilusFile              *file,\n                                         gconstpointer              client,\n                                         gboolean                   monitor_hidden_files,\n                                         NautilusFileAttributes     file_attributes,\n                                         NautilusDirectoryCallback  callback,\n                                         gpointer                   callback_data)\n{\n    Monitor *monitor;\n    GList *file_list;\n    char *file_uri = NULL;\n    char *dir_uri = NULL;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n\n    if (file != NULL)\n    {\n        file_uri = nautilus_file_get_uri (file);\n    }\n    if (directory != NULL)\n    {\n        dir_uri = nautilus_directory_get_uri (directory);\n    }\n    nautilus_profile_start (\"uri %s file-uri %s client %p\", dir_uri, file_uri, client);\n    g_free (dir_uri);\n    g_free (file_uri);\n\n    /* Replace any current monitor for this client/file pair. */\n    remove_monitor (directory, file, client);\n\n    /* Add the new monitor. */\n    monitor = g_new (Monitor, 1);\n    monitor->file = file;\n    monitor->monitor_hidden_files = monitor_hidden_files;\n    monitor->client = client;\n    monitor->request = nautilus_directory_set_up_request (file_attributes);\n\n    if (file == NULL)\n    {\n        REQUEST_SET_TYPE (monitor->request, REQUEST_FILE_LIST);\n    }\n    directory->details->monitor_list =\n        g_list_prepend (directory->details->monitor_list, monitor);\n    request_counter_add_request (directory->details->monitor_counters,\n                                 monitor->request);\n\n    if (callback != NULL)\n    {\n        file_list = nautilus_directory_get_file_list (directory);\n        (*callback)(directory, file_list, callback_data);\n        nautilus_file_list_free (file_list);\n    }\n\n    /* Start the \"real\" monitoring (FAM or whatever). */\n    /* We always monitor the whole directory since in practice\n     * nautilus almost always shows the whole directory anyway, and\n     * it allows us to avoid one file monitor per file in a directory.\n     */\n    if (directory->details->monitor == NULL)\n    {\n        directory->details->monitor = nautilus_monitor_directory (directory->details->location);\n    }\n\n\n    if (REQUEST_WANTS_TYPE (monitor->request, REQUEST_FILE_INFO) &&\n        directory->details->mime_db_monitor == 0)\n    {\n        directory->details->mime_db_monitor =\n            g_signal_connect_object (nautilus_signaller_get_current (),\n                                     \"mime-data-changed\",\n                                     G_CALLBACK (mime_db_changed_callback), directory, 0);\n    }\n\n    /* Put the monitor file or all the files on the work queue. */\n    if (file != NULL)\n    {\n        nautilus_directory_add_file_to_work_queue (directory, file);\n    }\n    else\n    {\n        add_all_files_to_work_queue (directory);\n    }\n\n    /* Kick off I/O. */\n    nautilus_directory_async_state_changed (directory);\n    nautilus_profile_end (NULL);\n}\n\nstatic void\nset_file_unconfirmed (NautilusFile *file,\n                      gboolean      unconfirmed)\n{\n    NautilusDirectory *directory;\n\n    g_assert (NAUTILUS_IS_FILE (file));\n    g_assert (unconfirmed == FALSE || unconfirmed == TRUE);\n\n    if (file->details->unconfirmed == unconfirmed)\n    {\n        return;\n    }\n    file->details->unconfirmed = unconfirmed;\n\n    directory = file->details->directory;\n    if (unconfirmed)\n    {\n        directory->details->confirmed_file_count--;\n    }\n    else\n    {\n        directory->details->confirmed_file_count++;\n    }\n}\n\nstatic gboolean show_hidden_files = TRUE;\n\nstatic void\nshow_hidden_files_changed_callback (gpointer callback_data)\n{\n    show_hidden_files = g_settings_get_boolean (gtk_filechooser_preferences, NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES);\n}\n\nstatic gboolean\nshould_skip_file (NautilusDirectory *directory,\n                  GFileInfo         *info)\n{\n    static gboolean show_hidden_files_changed_callback_installed = FALSE;\n\n    /* Add the callback once for the life of our process */\n    if (!show_hidden_files_changed_callback_installed)\n    {\n        g_signal_connect_swapped (gtk_filechooser_preferences,\n                                  \"changed::\" NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES,\n                                  G_CALLBACK (show_hidden_files_changed_callback),\n                                  NULL);\n\n        show_hidden_files_changed_callback_installed = TRUE;\n\n        /* Peek for the first time */\n        show_hidden_files_changed_callback (NULL);\n    }\n\n    if (!show_hidden_files &&\n        (g_file_info_get_is_hidden (info) ||\n         g_file_info_get_is_backup (info)))\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic gboolean\ndequeue_pending_idle_callback (gpointer callback_data)\n{\n    NautilusDirectory *directory;\n    GList *pending_file_info;\n    GList *node, *next;\n    NautilusFile *file;\n    GList *changed_files, *added_files;\n    GFileInfo *file_info;\n    const char *mimetype, *name;\n    DirectoryLoadState *dir_load_state;\n\n    directory = NAUTILUS_DIRECTORY (callback_data);\n\n    nautilus_directory_ref (directory);\n\n    nautilus_profile_start (\"nitems %d\", g_list_length (directory->details->pending_file_info));\n\n    directory->details->dequeue_pending_idle_id = 0;\n\n    /* Handle the files in the order we saw them. */\n    pending_file_info = g_list_reverse (directory->details->pending_file_info);\n    directory->details->pending_file_info = NULL;\n\n    /* If we are no longer monitoring, then throw away these. */\n    if (!nautilus_directory_is_file_list_monitored (directory))\n    {\n        nautilus_directory_async_state_changed (directory);\n        goto drain;\n    }\n\n    added_files = NULL;\n    changed_files = NULL;\n\n    dir_load_state = directory->details->directory_load_in_progress;\n\n    /* Build a list of NautilusFile objects. */\n    for (node = pending_file_info; node != NULL; node = node->next)\n    {\n        file_info = node->data;\n\n        name = g_file_info_get_name (file_info);\n\n        /* Update the file count. */\n        /* FIXME bugzilla.gnome.org 45063: This could count a\n         * file twice if we get it from both load_directory\n         * and from new_files_callback. Not too hard to fix by\n         * moving this into the actual callback instead of\n         * waiting for the idle function.\n         */\n        if (dir_load_state &&\n            !should_skip_file (directory, file_info))\n        {\n            dir_load_state->load_file_count += 1;\n\n            /* Add the MIME type to the set. */\n            mimetype = g_file_info_get_content_type (file_info);\n            if (mimetype != NULL)\n            {\n                istr_set_insert (dir_load_state->load_mime_list_hash,\n                                 mimetype);\n            }\n        }\n\n        /* check if the file already exists */\n        file = nautilus_directory_find_file_by_name (directory, name);\n        if (file != NULL)\n        {\n            /* file already exists in dir, check if we still need to\n             *  emit file_added or if it changed */\n            set_file_unconfirmed (file, FALSE);\n            if (!file->details->is_added)\n            {\n                /* We consider this newly added even if its in the list.\n                 * This can happen if someone called nautilus_file_get_by_uri()\n                 * on a file in the folder before the add signal was\n                 * emitted */\n                nautilus_file_ref (file);\n                file->details->is_added = TRUE;\n                added_files = g_list_prepend (added_files, file);\n            }\n            else if (nautilus_file_update_info (file, file_info))\n            {\n                /* File changed, notify about the change. */\n                nautilus_file_ref (file);\n                changed_files = g_list_prepend (changed_files, file);\n            }\n        }\n        else\n        {\n            /* new file, create a nautilus file object and add it to the list */\n            file = nautilus_file_new_from_info (directory, file_info);\n            nautilus_directory_add_file (directory, file);\n            file->details->is_added = TRUE;\n            added_files = g_list_prepend (added_files, file);\n        }\n    }\n\n    /* If we are done loading, then we assume that any unconfirmed\n     * files are gone.\n     */\n    if (directory->details->directory_loaded)\n    {\n        for (node = directory->details->file_list;\n             node != NULL; node = next)\n        {\n            file = NAUTILUS_FILE (node->data);\n            next = node->next;\n\n            if (file->details->unconfirmed)\n            {\n                nautilus_file_ref (file);\n                changed_files = g_list_prepend (changed_files, file);\n\n                nautilus_file_mark_gone (file);\n            }\n        }\n    }\n\n    /* Send the changed and added signals. */\n    nautilus_directory_emit_change_signals (directory, changed_files);\n    nautilus_file_list_free (changed_files);\n    nautilus_directory_emit_files_added (directory, added_files);\n    nautilus_file_list_free (added_files);\n\n    if (directory->details->directory_loaded &&\n        !directory->details->directory_loaded_sent_notification)\n    {\n        /* Send the done_loading signal. */\n        nautilus_directory_emit_done_loading (directory);\n\n        if (dir_load_state)\n        {\n            file = dir_load_state->load_directory_file;\n\n            file->details->directory_count = dir_load_state->load_file_count;\n            file->details->directory_count_is_up_to_date = TRUE;\n            file->details->got_directory_count = TRUE;\n\n            file->details->got_mime_list = TRUE;\n            file->details->mime_list_is_up_to_date = TRUE;\n            g_list_free_full (file->details->mime_list, g_free);\n            file->details->mime_list = istr_set_get_as_list\n                                           (dir_load_state->load_mime_list_hash);\n\n            nautilus_file_changed (file);\n        }\n\n        nautilus_directory_async_state_changed (directory);\n\n        directory->details->directory_loaded_sent_notification = TRUE;\n    }\n\ndrain:\n    g_list_free_full (pending_file_info, g_object_unref);\n\n    /* Get the state machine running again. */\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_profile_end (NULL);\n\n    nautilus_directory_unref (directory);\n    return FALSE;\n}\n\nvoid\nnautilus_directory_schedule_dequeue_pending (NautilusDirectory *directory)\n{\n    if (directory->details->dequeue_pending_idle_id == 0)\n    {\n        directory->details->dequeue_pending_idle_id\n            = g_idle_add (dequeue_pending_idle_callback, directory);\n    }\n}\n\nstatic void\ndirectory_load_one (NautilusDirectory *directory,\n                    GFileInfo         *info)\n{\n    if (info == NULL)\n    {\n        return;\n    }\n\n    if (g_file_info_get_name (info) == NULL)\n    {\n        char *uri;\n\n        uri = nautilus_directory_get_uri (directory);\n        g_warning (\"Got GFileInfo with NULL name in %s, ignoring. This shouldn't happen unless the gvfs backend is broken.\\n\", uri);\n        g_free (uri);\n\n        return;\n    }\n\n    /* Arrange for the \"loading\" part of the work. */\n    g_object_ref (info);\n    directory->details->pending_file_info\n        = g_list_prepend (directory->details->pending_file_info, info);\n    nautilus_directory_schedule_dequeue_pending (directory);\n}\n\nstatic void\ndirectory_load_cancel (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n    DirectoryLoadState *state;\n\n    state = directory->details->directory_load_in_progress;\n    if (state != NULL)\n    {\n        file = state->load_directory_file;\n        file->details->loading_directory = FALSE;\n        if (file->details->directory != directory)\n        {\n            nautilus_directory_async_state_changed (file->details->directory);\n        }\n\n        g_cancellable_cancel (state->cancellable);\n        state->directory = NULL;\n        directory->details->directory_load_in_progress = NULL;\n        async_job_end (directory, \"file list\");\n    }\n}\n\nstatic void\nfile_list_cancel (NautilusDirectory *directory)\n{\n    directory_load_cancel (directory);\n\n    if (directory->details->dequeue_pending_idle_id != 0)\n    {\n        g_source_remove (directory->details->dequeue_pending_idle_id);\n        directory->details->dequeue_pending_idle_id = 0;\n    }\n\n    if (directory->details->pending_file_info != NULL)\n    {\n        g_list_free_full (directory->details->pending_file_info, g_object_unref);\n        directory->details->pending_file_info = NULL;\n    }\n}\n\nstatic void\ndirectory_load_done (NautilusDirectory *directory,\n                     GError            *error)\n{\n    GList *node;\n\n    nautilus_profile_start (NULL);\n    g_object_ref (directory);\n\n    directory->details->directory_loaded = TRUE;\n    directory->details->directory_loaded_sent_notification = FALSE;\n\n    if (error != NULL)\n    {\n        /* The load did not complete successfully. This means\n         * we don't know the status of the files in this directory.\n         * We clear the unconfirmed bit on each file here so that\n         * they won't be marked \"gone\" later -- we don't know enough\n         * about them to know whether they are really gone.\n         */\n        for (node = directory->details->file_list;\n             node != NULL; node = node->next)\n        {\n            set_file_unconfirmed (NAUTILUS_FILE (node->data), FALSE);\n        }\n\n        nautilus_directory_emit_load_error (directory, error);\n    }\n\n    /* Call the idle function right away. */\n    if (directory->details->dequeue_pending_idle_id != 0)\n    {\n        g_source_remove (directory->details->dequeue_pending_idle_id);\n    }\n    dequeue_pending_idle_callback (directory);\n\n    directory_load_cancel (directory);\n\n    g_object_unref (directory);\n    nautilus_profile_end (NULL);\n}\n\nvoid\nnautilus_directory_monitor_remove_internal (NautilusDirectory *directory,\n                                            NautilusFile      *file,\n                                            gconstpointer      client)\n{\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (client != NULL);\n\n    remove_monitor (directory, file, client);\n\n    if (directory->details->monitor != NULL\n        && directory->details->monitor_list == NULL)\n    {\n        nautilus_monitor_cancel (directory->details->monitor);\n        directory->details->monitor = NULL;\n    }\n\n    /* XXX - do we need to remove anything from the work queue? */\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nFileMonitors *\nnautilus_directory_remove_file_monitors (NautilusDirectory *directory,\n                                         NautilusFile      *file)\n{\n    GList *result, **list, *node, *next;\n    Monitor *monitor;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (NAUTILUS_IS_FILE (file));\n    g_assert (file->details->directory == directory);\n\n    result = NULL;\n\n    list = &directory->details->monitor_list;\n    for (node = directory->details->monitor_list; node != NULL; node = next)\n    {\n        next = node->next;\n        monitor = node->data;\n\n        if (monitor->file == file)\n        {\n            *list = g_list_remove_link (*list, node);\n            result = g_list_concat (node, result);\n            request_counter_remove_request (directory->details->monitor_counters,\n                                            monitor->request);\n        }\n    }\n\n    /* XXX - do we need to remove anything from the work queue? */\n\n    nautilus_directory_async_state_changed (directory);\n\n    return (FileMonitors *) result;\n}\n\nvoid\nnautilus_directory_add_file_monitors (NautilusDirectory *directory,\n                                      NautilusFile      *file,\n                                      FileMonitors      *monitors)\n{\n    GList **list;\n    GList *l;\n    Monitor *monitor;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (NAUTILUS_IS_FILE (file));\n    g_assert (file->details->directory == directory);\n\n    if (monitors == NULL)\n    {\n        return;\n    }\n\n    for (l = (GList *) monitors; l != NULL; l = l->next)\n    {\n        monitor = l->data;\n        request_counter_add_request (directory->details->monitor_counters,\n                                     monitor->request);\n    }\n\n    list = &directory->details->monitor_list;\n    *list = g_list_concat (*list, (GList *) monitors);\n\n    nautilus_directory_add_file_to_work_queue (directory, file);\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic int\nready_callback_key_compare (gconstpointer a,\n                            gconstpointer b)\n{\n    const ReadyCallback *callback_a, *callback_b;\n\n    callback_a = a;\n    callback_b = b;\n\n    if (callback_a->file < callback_b->file)\n    {\n        return -1;\n    }\n    if (callback_a->file > callback_b->file)\n    {\n        return 1;\n    }\n    if (callback_a->file == NULL)\n    {\n        /* ANSI C doesn't allow ordered compares of function pointers, so we cast them to\n         * normal pointers to make some overly pedantic compilers (*cough* HP-UX *cough*)\n         * compile this. Of course, on any compiler where ordered function pointers actually\n         * break this probably won't work, but at least it will compile on platforms where it\n         * works, but stupid compilers won't let you use it.\n         */\n        if ((void *) callback_a->callback.directory < (void *) callback_b->callback.directory)\n        {\n            return -1;\n        }\n        if ((void *) callback_a->callback.directory > (void *) callback_b->callback.directory)\n        {\n            return 1;\n        }\n    }\n    else\n    {\n        if ((void *) callback_a->callback.file < (void *) callback_b->callback.file)\n        {\n            return -1;\n        }\n        if ((void *) callback_a->callback.file > (void *) callback_b->callback.file)\n        {\n            return 1;\n        }\n    }\n    if (callback_a->callback_data < callback_b->callback_data)\n    {\n        return -1;\n    }\n    if (callback_a->callback_data > callback_b->callback_data)\n    {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int\nready_callback_key_compare_only_active (gconstpointer a,\n                                        gconstpointer b)\n{\n    const ReadyCallback *callback_a;\n\n    callback_a = a;\n\n    /* Non active callbacks never match */\n    if (!callback_a->active)\n    {\n        return -1;\n    }\n\n    return ready_callback_key_compare (a, b);\n}\n\nstatic void\nready_callback_call (NautilusDirectory   *directory,\n                     const ReadyCallback *callback)\n{\n    GList *file_list;\n\n    /* Call the callback. */\n    if (callback->file != NULL)\n    {\n        if (callback->callback.file)\n        {\n            (*callback->callback.file)(callback->file,\n                                       callback->callback_data);\n        }\n    }\n    else if (callback->callback.directory != NULL)\n    {\n        if (directory == NULL ||\n            !REQUEST_WANTS_TYPE (callback->request, REQUEST_FILE_LIST))\n        {\n            file_list = NULL;\n        }\n        else\n        {\n            file_list = nautilus_directory_get_file_list (directory);\n        }\n\n        /* Pass back the file list if the user was waiting for it. */\n        (*callback->callback.directory)(directory,\n                                        file_list,\n                                        callback->callback_data);\n\n        nautilus_file_list_free (file_list);\n    }\n}\n\nvoid\nnautilus_directory_call_when_ready_internal (NautilusDirectory         *directory,\n                                             NautilusFile              *file,\n                                             NautilusFileAttributes     file_attributes,\n                                             gboolean                   wait_for_file_list,\n                                             NautilusDirectoryCallback  directory_callback,\n                                             NautilusFileCallback       file_callback,\n                                             gpointer                   callback_data)\n{\n    ReadyCallback callback;\n\n    g_assert (directory == NULL || NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (file != NULL || directory_callback != NULL);\n\n    /* Construct a callback object. */\n    callback.active = TRUE;\n    callback.file = file;\n    if (file == NULL)\n    {\n        callback.callback.directory = directory_callback;\n    }\n    else\n    {\n        callback.callback.file = file_callback;\n    }\n    callback.callback_data = callback_data;\n    callback.request = nautilus_directory_set_up_request (file_attributes);\n    if (wait_for_file_list)\n    {\n        REQUEST_SET_TYPE (callback.request, REQUEST_FILE_LIST);\n    }\n\n    /* Handle the NULL case. */\n    if (directory == NULL)\n    {\n        ready_callback_call (NULL, &callback);\n        return;\n    }\n\n    /* Check if the callback is already there. */\n    if (g_list_find_custom (directory->details->call_when_ready_list,\n                            &callback,\n                            ready_callback_key_compare_only_active) != NULL)\n    {\n        if (file_callback != NULL && directory_callback != NULL)\n        {\n            g_warning (\"tried to add a new callback while an old one was pending\");\n        }\n        /* NULL callback means, just read it. Conflicts are ok. */\n        return;\n    }\n\n    /* Add the new callback to the list. */\n    directory->details->call_when_ready_list = g_list_prepend\n                                                   (directory->details->call_when_ready_list,\n                                                   g_memdup (&callback, sizeof (callback)));\n    request_counter_add_request (directory->details->call_when_ready_counters,\n                                 callback.request);\n\n    /* Put the callback file or all the files on the work queue. */\n    if (file != NULL)\n    {\n        nautilus_directory_add_file_to_work_queue (directory, file);\n    }\n    else\n    {\n        add_all_files_to_work_queue (directory);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\ngboolean\nnautilus_directory_check_if_ready_internal (NautilusDirectory      *directory,\n                                            NautilusFile           *file,\n                                            NautilusFileAttributes  file_attributes)\n{\n    Request request;\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n\n    request = nautilus_directory_set_up_request (file_attributes);\n    return request_is_satisfied (directory, file, request);\n}\n\nstatic void\nremove_callback_link_keep_data (NautilusDirectory *directory,\n                                GList             *link)\n{\n    ReadyCallback *callback;\n\n    callback = link->data;\n\n    directory->details->call_when_ready_list = g_list_remove_link\n                                                   (directory->details->call_when_ready_list, link);\n\n    request_counter_remove_request (directory->details->call_when_ready_counters,\n                                    callback->request);\n    g_list_free_1 (link);\n}\n\nstatic void\nremove_callback_link (NautilusDirectory *directory,\n                      GList             *link)\n{\n    ReadyCallback *callback;\n\n    callback = link->data;\n    remove_callback_link_keep_data (directory, link);\n    g_free (callback);\n}\n\nvoid\nnautilus_directory_cancel_callback_internal (NautilusDirectory         *directory,\n                                             NautilusFile              *file,\n                                             NautilusDirectoryCallback  directory_callback,\n                                             NautilusFileCallback       file_callback,\n                                             gpointer                   callback_data)\n{\n    ReadyCallback callback;\n    GList *node;\n\n    if (directory == NULL)\n    {\n        return;\n    }\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (file != NULL || directory_callback != NULL);\n    g_assert (file == NULL || file_callback != NULL);\n\n    /* Construct a callback object. */\n    callback.file = file;\n    if (file == NULL)\n    {\n        callback.callback.directory = directory_callback;\n    }\n    else\n    {\n        callback.callback.file = file_callback;\n    }\n    callback.callback_data = callback_data;\n\n    /* Remove all queued callback from the list (including non-active). */\n    do\n    {\n        node = g_list_find_custom (directory->details->call_when_ready_list,\n                                   &callback,\n                                   ready_callback_key_compare);\n        if (node != NULL)\n        {\n            remove_callback_link (directory, node);\n\n            nautilus_directory_async_state_changed (directory);\n        }\n    }\n    while (node != NULL);\n}\n\nstatic void\nnew_files_state_unref (NewFilesState *state)\n{\n    state->count--;\n\n    if (state->count == 0)\n    {\n        if (state->directory)\n        {\n            state->directory->details->new_files_in_progress =\n                g_list_remove (state->directory->details->new_files_in_progress,\n                               state);\n        }\n\n        g_object_unref (state->cancellable);\n        g_free (state);\n    }\n}\n\nstatic void\nnew_files_callback (GObject      *source_object,\n                    GAsyncResult *res,\n                    gpointer      user_data)\n{\n    NautilusDirectory *directory;\n    GFileInfo *info;\n    NewFilesState *state;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        new_files_state_unref (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    /* Queue up the new file. */\n    info = g_file_query_info_finish (G_FILE (source_object), res, NULL);\n    if (info != NULL)\n    {\n        directory_load_one (directory, info);\n        g_object_unref (info);\n    }\n\n    new_files_state_unref (state);\n\n    nautilus_directory_unref (directory);\n}\n\nvoid\nnautilus_directory_get_info_for_new_files (NautilusDirectory *directory,\n                                           GList             *location_list)\n{\n    NewFilesState *state;\n    GFile *location;\n    GList *l;\n\n    if (location_list == NULL)\n    {\n        return;\n    }\n\n    state = g_new (NewFilesState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->count = 0;\n\n    for (l = location_list; l != NULL; l = l->next)\n    {\n        location = l->data;\n\n        state->count++;\n\n        g_file_query_info_async (location,\n                                 NAUTILUS_FILE_DEFAULT_ATTRIBUTES,\n                                 0,\n                                 G_PRIORITY_DEFAULT,\n                                 state->cancellable,\n                                 new_files_callback, state);\n    }\n\n    directory->details->new_files_in_progress\n        = g_list_prepend (directory->details->new_files_in_progress,\n                          state);\n}\n\nvoid\nnautilus_async_destroying_file (NautilusFile *file)\n{\n    NautilusDirectory *directory;\n    gboolean changed;\n    GList *node, *next;\n    ReadyCallback *callback;\n    Monitor *monitor;\n\n    directory = file->details->directory;\n    changed = FALSE;\n\n    /* Check for callbacks. */\n    for (node = directory->details->call_when_ready_list; node != NULL; node = next)\n    {\n        next = node->next;\n        callback = node->data;\n\n        if (callback->file == file)\n        {\n            /* Client should have cancelled callback. */\n            if (callback->active)\n            {\n                g_warning (\"destroyed file has call_when_ready pending\");\n            }\n            remove_callback_link (directory, node);\n            changed = TRUE;\n        }\n    }\n\n    /* Check for monitors. */\n    for (node = directory->details->monitor_list; node != NULL; node = next)\n    {\n        next = node->next;\n        monitor = node->data;\n\n        if (monitor->file == file)\n        {\n            /* Client should have removed monitor earlier. */\n            g_warning (\"destroyed file still being monitored\");\n            remove_monitor_link (directory, node);\n            changed = TRUE;\n        }\n    }\n\n    /* Check if it's a file that's currently being worked on.\n     * If so, make that NULL so it gets canceled right away.\n     */\n    if (directory->details->count_in_progress != NULL &&\n        directory->details->count_in_progress->count_file == file)\n    {\n        directory->details->count_in_progress->count_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->deep_count_file == file)\n    {\n        directory->details->deep_count_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->mime_list_in_progress != NULL &&\n        directory->details->mime_list_in_progress->mime_list_file == file)\n    {\n        directory->details->mime_list_in_progress->mime_list_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->get_info_file == file)\n    {\n        directory->details->get_info_file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->link_info_read_state != NULL &&\n        directory->details->link_info_read_state->file == file)\n    {\n        directory->details->link_info_read_state->file = NULL;\n        changed = TRUE;\n    }\n    if (directory->details->extension_info_file == file)\n    {\n        directory->details->extension_info_file = NULL;\n        changed = TRUE;\n    }\n\n    if (directory->details->thumbnail_state != NULL &&\n        directory->details->thumbnail_state->file == file)\n    {\n        directory->details->thumbnail_state->file = NULL;\n        changed = TRUE;\n    }\n\n    if (directory->details->mount_state != NULL &&\n        directory->details->mount_state->file == file)\n    {\n        directory->details->mount_state->file = NULL;\n        changed = TRUE;\n    }\n\n    if (directory->details->filesystem_info_state != NULL &&\n        directory->details->filesystem_info_state->file == file)\n    {\n        directory->details->filesystem_info_state->file = NULL;\n        changed = TRUE;\n    }\n\n    /* Let the directory take care of the rest. */\n    if (changed)\n    {\n        nautilus_directory_async_state_changed (directory);\n    }\n}\n\nstatic gboolean\nlacks_directory_count (NautilusFile *file)\n{\n    return !file->details->directory_count_is_up_to_date\n           && nautilus_file_should_show_directory_item_count (file);\n}\n\nstatic gboolean\nshould_get_directory_count_now (NautilusFile *file)\n{\n    return lacks_directory_count (file)\n           && !file->details->loading_directory;\n}\n\nstatic gboolean\nlacks_info (NautilusFile *file)\n{\n    return !file->details->file_info_is_up_to_date\n           && !file->details->is_gone;\n}\n\nstatic gboolean\nlacks_filesystem_info (NautilusFile *file)\n{\n    return !file->details->filesystem_info_is_up_to_date;\n}\n\nstatic gboolean\nlacks_deep_count (NautilusFile *file)\n{\n    return file->details->deep_counts_status != NAUTILUS_REQUEST_DONE;\n}\n\nstatic gboolean\nlacks_mime_list (NautilusFile *file)\n{\n    return !file->details->mime_list_is_up_to_date;\n}\n\nstatic gboolean\nshould_get_mime_list (NautilusFile *file)\n{\n    return lacks_mime_list (file)\n           && !file->details->loading_directory;\n}\n\nstatic gboolean\nlacks_link_info (NautilusFile *file)\n{\n    if (file->details->file_info_is_up_to_date &&\n        !file->details->link_info_is_up_to_date)\n    {\n        if (nautilus_file_is_nautilus_link (file))\n        {\n            return TRUE;\n        }\n        else\n        {\n            link_info_done (file->details->directory, file, NULL, NULL, NULL, FALSE, FALSE);\n            return FALSE;\n        }\n    }\n    else\n    {\n        return FALSE;\n    }\n}\n\nstatic gboolean\nlacks_extension_info (NautilusFile *file)\n{\n    return file->details->pending_info_providers != NULL;\n}\n\nstatic gboolean\nlacks_thumbnail (NautilusFile *file)\n{\n    return nautilus_file_should_show_thumbnail (file) &&\n           file->details->thumbnail_path != NULL &&\n           !file->details->thumbnail_is_up_to_date;\n}\n\nstatic gboolean\nlacks_mount (NautilusFile *file)\n{\n    return (!file->details->mount_is_up_to_date &&\n            (\n                /* Unix mountpoint, could be a GMount */\n                file->details->is_mountpoint ||\n\n                /* The toplevel directory of something */\n                (file->details->type == G_FILE_TYPE_DIRECTORY &&\n                 nautilus_file_is_self_owned (file)) ||\n\n                /* Mountable, could be a mountpoint */\n                (file->details->type == G_FILE_TYPE_MOUNTABLE)\n\n            )\n            );\n}\n\nstatic gboolean\nhas_problem (NautilusDirectory *directory,\n             NautilusFile      *file,\n             FileCheck          problem)\n{\n    GList *node;\n\n    if (file != NULL)\n    {\n        return (*problem)(file);\n    }\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        if ((*problem)(node->data))\n        {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\nstatic gboolean\nrequest_is_satisfied (NautilusDirectory *directory,\n                      NautilusFile      *file,\n                      Request            request)\n{\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_LIST) &&\n        !(directory->details->directory_loaded &&\n          directory->details->directory_loaded_sent_notification))\n    {\n        return FALSE;\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))\n    {\n        if (has_problem (directory, file, lacks_directory_count))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))\n    {\n        if (has_problem (directory, file, lacks_info))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))\n    {\n        if (has_problem (directory, file, lacks_filesystem_info))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))\n    {\n        if (has_problem (directory, file, lacks_deep_count))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))\n    {\n        if (has_problem (directory, file, lacks_thumbnail))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))\n    {\n        if (has_problem (directory, file, lacks_mount))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))\n    {\n        if (has_problem (directory, file, lacks_mime_list))\n        {\n            return FALSE;\n        }\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))\n    {\n        if (has_problem (directory, file, lacks_link_info))\n        {\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic gboolean\ncall_ready_callbacks_at_idle (gpointer callback_data)\n{\n    NautilusDirectory *directory;\n    GList *node, *next;\n    ReadyCallback *callback;\n\n    directory = NAUTILUS_DIRECTORY (callback_data);\n    directory->details->call_ready_idle_id = 0;\n\n    nautilus_directory_ref (directory);\n\n    callback = NULL;\n    while (1)\n    {\n        /* Check if any callbacks are non-active and call them if they are. */\n        for (node = directory->details->call_when_ready_list;\n             node != NULL; node = next)\n        {\n            next = node->next;\n            callback = node->data;\n            if (!callback->active)\n            {\n                /* Non-active, remove and call */\n                break;\n            }\n        }\n        if (node == NULL)\n        {\n            break;\n        }\n\n        /* Callbacks are one-shots, so remove it now. */\n        remove_callback_link_keep_data (directory, node);\n\n        /* Call the callback. */\n        ready_callback_call (directory, callback);\n        g_free (callback);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_directory_unref (directory);\n\n    return FALSE;\n}\n\nstatic void\nschedule_call_ready_callbacks (NautilusDirectory *directory)\n{\n    if (directory->details->call_ready_idle_id == 0)\n    {\n        directory->details->call_ready_idle_id\n            = g_idle_add (call_ready_callbacks_at_idle, directory);\n    }\n}\n\n/* Marks all callbacks that are ready as non-active and\n * calls them at idle time, unless they are removed\n * before then */\nstatic gboolean\ncall_ready_callbacks (NautilusDirectory *directory)\n{\n    gboolean found_any;\n    GList *node, *next;\n    ReadyCallback *callback;\n\n    found_any = FALSE;\n\n    /* Check if any callbacks are satisifed and mark them for call them if they are. */\n    for (node = directory->details->call_when_ready_list;\n         node != NULL; node = next)\n    {\n        next = node->next;\n        callback = node->data;\n        if (callback->active &&\n            request_is_satisfied (directory, callback->file, callback->request))\n        {\n            callback->active = FALSE;\n            found_any = TRUE;\n        }\n    }\n\n    if (found_any)\n    {\n        schedule_call_ready_callbacks (directory);\n    }\n\n    return found_any;\n}\n\ngboolean\nnautilus_directory_has_active_request_for_file (NautilusDirectory *directory,\n                                                NautilusFile      *file)\n{\n    GList *node;\n    ReadyCallback *callback;\n    Monitor *monitor;\n\n    for (node = directory->details->call_when_ready_list;\n         node != NULL; node = node->next)\n    {\n        callback = node->data;\n        if (callback->file == file ||\n            callback->file == NULL)\n        {\n            return TRUE;\n        }\n    }\n\n    for (node = directory->details->monitor_list;\n         node != NULL; node = node->next)\n    {\n        monitor = node->data;\n        if (monitor->file == file ||\n            monitor->file == NULL)\n        {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n\n/* This checks if there's a request for monitoring the file list. */\ngboolean\nnautilus_directory_is_anyone_monitoring_file_list (NautilusDirectory *directory)\n{\n    if (directory->details->call_when_ready_counters[REQUEST_FILE_LIST] > 0)\n    {\n        return TRUE;\n    }\n\n    if (directory->details->monitor_counters[REQUEST_FILE_LIST] > 0)\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\n/* This checks if the file list being monitored. */\ngboolean\nnautilus_directory_is_file_list_monitored (NautilusDirectory *directory)\n{\n    return directory->details->file_list_monitored;\n}\n\nstatic void\nmark_all_files_unconfirmed (NautilusDirectory *directory)\n{\n    GList *node;\n    NautilusFile *file;\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        file = node->data;\n        set_file_unconfirmed (file, TRUE);\n    }\n}\n\nstatic void\ndirectory_load_state_free (DirectoryLoadState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n\n    if (state->load_mime_list_hash != NULL)\n    {\n        istr_set_destroy (state->load_mime_list_hash);\n    }\n    nautilus_file_unref (state->load_directory_file);\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\nmore_files_callback (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    DirectoryLoadState *state;\n    NautilusDirectory *directory;\n    GError *error;\n    GList *files, *l;\n    GFileInfo *info;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        directory_load_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    g_assert (directory->details->directory_load_in_progress != NULL);\n    g_assert (directory->details->directory_load_in_progress == state);\n\n    error = NULL;\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, &error);\n\n    for (l = files; l != NULL; l = l->next)\n    {\n        info = l->data;\n        directory_load_one (directory, info);\n        g_object_unref (info);\n    }\n\n    if (files == NULL)\n    {\n        directory_load_done (directory, error);\n        directory_load_state_free (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            more_files_callback,\n                                            state);\n    }\n\n    nautilus_directory_unref (directory);\n\n    if (error)\n    {\n        g_error_free (error);\n    }\n\n    g_list_free (files);\n}\n\nstatic void\nenumerate_children_callback (GObject      *source_object,\n                             GAsyncResult *res,\n                             gpointer      user_data)\n{\n    DirectoryLoadState *state;\n    GFileEnumerator *enumerator;\n    GError *error;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        directory_load_state_free (state);\n        return;\n    }\n\n    error = NULL;\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),\n                                                   res, &error);\n\n    if (enumerator == NULL)\n    {\n        directory_load_done (state->directory, error);\n        g_error_free (error);\n        directory_load_state_free (state);\n        return;\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            more_files_callback,\n                                            state);\n    }\n}\n\n\n/* Start monitoring the file list if it isn't already. */\nstatic void\nstart_monitoring_file_list (NautilusDirectory *directory)\n{\n    DirectoryLoadState *state;\n\n    if (!directory->details->file_list_monitored)\n    {\n        g_assert (!directory->details->directory_load_in_progress);\n        directory->details->file_list_monitored = TRUE;\n        nautilus_file_list_ref (directory->details->file_list);\n    }\n\n    if (directory->details->directory_loaded ||\n        directory->details->directory_load_in_progress != NULL)\n    {\n        return;\n    }\n\n    if (!async_job_start (directory, \"file list\"))\n    {\n        return;\n    }\n\n    mark_all_files_unconfirmed (directory);\n\n    state = g_new0 (DirectoryLoadState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->load_mime_list_hash = istr_set_new ();\n    state->load_file_count = 0;\n\n    g_assert (directory->details->location != NULL);\n    state->load_directory_file =\n        nautilus_directory_get_corresponding_file (directory);\n    state->load_directory_file->details->loading_directory = TRUE;\n\n\n#ifdef DEBUG_LOAD_DIRECTORY\n    g_message (\"load_directory called to monitor file list of %p\", directory->details->location);\n#endif\n\n    directory->details->directory_load_in_progress = state;\n\n    g_file_enumerate_children_async (directory->details->location,\n                                     NAUTILUS_FILE_DEFAULT_ATTRIBUTES,\n                                     0,     /* flags */\n                                     G_PRIORITY_DEFAULT,     /* prio */\n                                     state->cancellable,\n                                     enumerate_children_callback,\n                                     state);\n}\n\n/* Stop monitoring the file list if it is being monitored. */\nvoid\nnautilus_directory_stop_monitoring_file_list (NautilusDirectory *directory)\n{\n    if (!directory->details->file_list_monitored)\n    {\n        g_assert (directory->details->directory_load_in_progress == NULL);\n        return;\n    }\n\n    directory->details->file_list_monitored = FALSE;\n    file_list_cancel (directory);\n    nautilus_file_list_unref (directory->details->file_list);\n    directory->details->directory_loaded = FALSE;\n}\n\nstatic void\nfile_list_start_or_stop (NautilusDirectory *directory)\n{\n    if (nautilus_directory_is_anyone_monitoring_file_list (directory))\n    {\n        start_monitoring_file_list (directory);\n    }\n    else\n    {\n        nautilus_directory_stop_monitoring_file_list (directory);\n    }\n}\n\nvoid\nnautilus_file_invalidate_count_and_mime_list (NautilusFile *file)\n{\n    NautilusFileAttributes attributes;\n\n    attributes = NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT |\n                 NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;\n\n    nautilus_file_invalidate_attributes (file, attributes);\n}\n\n\n/* Reset count and mime list. Invalidating deep counts is handled by\n * itself elsewhere because it's a relatively heavyweight and\n * special-purpose operation (see bug 5863). Also, the shallow count\n * needs to be refreshed when filtering changes, but the deep count\n * deliberately does not take filtering into account.\n */\nvoid\nnautilus_directory_invalidate_count_and_mime_list (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    file = nautilus_directory_get_existing_corresponding_file (directory);\n    if (file != NULL)\n    {\n        nautilus_file_invalidate_count_and_mime_list (file);\n    }\n\n    nautilus_file_unref (file);\n}\n\nstatic void\nnautilus_directory_invalidate_file_attributes (NautilusDirectory      *directory,\n                                               NautilusFileAttributes  file_attributes)\n{\n    GList *node;\n\n    cancel_loading_attributes (directory, file_attributes);\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        nautilus_file_invalidate_attributes_internal (NAUTILUS_FILE (node->data),\n                                                      file_attributes);\n    }\n\n    if (directory->details->as_file != NULL)\n    {\n        nautilus_file_invalidate_attributes_internal (directory->details->as_file,\n                                                      file_attributes);\n    }\n}\n\nvoid\nnautilus_directory_force_reload_internal (NautilusDirectory      *directory,\n                                          NautilusFileAttributes  file_attributes)\n{\n    nautilus_profile_start (NULL);\n\n    /* invalidate attributes that are getting reloaded for all files */\n    nautilus_directory_invalidate_file_attributes (directory, file_attributes);\n\n    /* Start a new directory load. */\n    file_list_cancel (directory);\n    directory->details->directory_loaded = FALSE;\n\n    /* Start a new directory count. */\n    nautilus_directory_invalidate_count_and_mime_list (directory);\n\n    add_all_files_to_work_queue (directory);\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_profile_end (NULL);\n}\n\nstatic gboolean\nmonitor_includes_file (const Monitor *monitor,\n                       NautilusFile  *file)\n{\n    if (monitor->file == file)\n    {\n        return TRUE;\n    }\n    if (monitor->file != NULL)\n    {\n        return FALSE;\n    }\n    if (file == file->details->directory->details->as_file)\n    {\n        return FALSE;\n    }\n    return nautilus_file_should_show (file,\n                                      monitor->monitor_hidden_files,\n                                      TRUE);\n}\n\nstatic gboolean\nis_needy (NautilusFile *file,\n          FileCheck     check_missing,\n          RequestType   request_type_wanted)\n{\n    NautilusDirectory *directory;\n    GList *node;\n    ReadyCallback *callback;\n    Monitor *monitor;\n\n    if (!(*check_missing)(file))\n    {\n        return FALSE;\n    }\n\n    directory = file->details->directory;\n    if (directory->details->call_when_ready_counters[request_type_wanted] > 0)\n    {\n        for (node = directory->details->call_when_ready_list;\n             node != NULL; node = node->next)\n        {\n            callback = node->data;\n            if (callback->active &&\n                REQUEST_WANTS_TYPE (callback->request, request_type_wanted))\n            {\n                if (callback->file == file)\n                {\n                    return TRUE;\n                }\n                if (callback->file == NULL\n                    && file != directory->details->as_file)\n                {\n                    return TRUE;\n                }\n            }\n        }\n    }\n\n    if (directory->details->monitor_counters[request_type_wanted] > 0)\n    {\n        for (node = directory->details->monitor_list;\n             node != NULL; node = node->next)\n        {\n            monitor = node->data;\n            if (REQUEST_WANTS_TYPE (monitor->request, request_type_wanted))\n            {\n                if (monitor_includes_file (monitor, file))\n                {\n                    return TRUE;\n                }\n            }\n        }\n    }\n    return FALSE;\n}\n\nstatic void\ndirectory_count_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->count_in_progress != NULL)\n    {\n        file = directory->details->count_in_progress->count_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          should_get_directory_count_now,\n                          REQUEST_DIRECTORY_COUNT))\n            {\n                return;\n            }\n        }\n\n        /* The count is not wanted, so stop it. */\n        directory_count_cancel (directory);\n    }\n}\n\nstatic guint\ncount_non_skipped_files (GList *list)\n{\n    guint count;\n    GList *node;\n    GFileInfo *info;\n\n    count = 0;\n    for (node = list; node != NULL; node = node->next)\n    {\n        info = node->data;\n        if (!should_skip_file (NULL, info))\n        {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nstatic void\ncount_children_done (NautilusDirectory *directory,\n                     NautilusFile      *count_file,\n                     gboolean           succeeded,\n                     int                count)\n{\n    g_assert (NAUTILUS_IS_FILE (count_file));\n\n    count_file->details->directory_count_is_up_to_date = TRUE;\n\n    /* Record either a failure or success. */\n    if (!succeeded)\n    {\n        count_file->details->directory_count_failed = TRUE;\n        count_file->details->got_directory_count = FALSE;\n        count_file->details->directory_count = 0;\n    }\n    else\n    {\n        count_file->details->directory_count_failed = FALSE;\n        count_file->details->got_directory_count = TRUE;\n        count_file->details->directory_count = count;\n    }\n    directory->details->count_in_progress = NULL;\n\n    /* Send file-changed even if count failed, so interested parties can\n     * distinguish between unknowable and not-yet-known cases.\n     */\n    nautilus_file_changed (count_file);\n\n    /* Start up the next one. */\n    async_job_end (directory, \"directory count\");\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\ndirectory_count_state_free (DirectoryCountState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n    g_object_unref (state->cancellable);\n    nautilus_directory_unref (state->directory);\n    g_free (state);\n}\n\nstatic void\ncount_more_files_callback (GObject      *source_object,\n                           GAsyncResult *res,\n                           gpointer      user_data)\n{\n    DirectoryCountState *state;\n    NautilusDirectory *directory;\n    GError *error;\n    GList *files;\n\n    state = user_data;\n    directory = state->directory;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n\n        async_job_end (directory, \"directory count\");\n        nautilus_directory_async_state_changed (directory);\n\n        directory_count_state_free (state);\n\n        return;\n    }\n\n    g_assert (directory->details->count_in_progress != NULL);\n    g_assert (directory->details->count_in_progress == state);\n\n    error = NULL;\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, &error);\n\n    state->file_count += count_non_skipped_files (files);\n\n    if (files == NULL)\n    {\n        count_children_done (directory, state->count_file,\n                             TRUE, state->file_count);\n        directory_count_state_free (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            count_more_files_callback,\n                                            state);\n    }\n\n    g_list_free_full (files, g_object_unref);\n\n    if (error)\n    {\n        g_error_free (error);\n    }\n}\n\nstatic void\ncount_children_callback (GObject      *source_object,\n                         GAsyncResult *res,\n                         gpointer      user_data)\n{\n    DirectoryCountState *state;\n    GFileEnumerator *enumerator;\n    NautilusDirectory *directory;\n    GError *error;\n\n    state = user_data;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n        directory = state->directory;\n\n        async_job_end (directory, \"directory count\");\n        nautilus_directory_async_state_changed (directory);\n\n        directory_count_state_free (state);\n\n        return;\n    }\n\n    error = NULL;\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),\n                                                   res, &error);\n\n    if (enumerator == NULL)\n    {\n        count_children_done (state->directory,\n                             state->count_file,\n                             FALSE, 0);\n        g_error_free (error);\n        directory_count_state_free (state);\n        return;\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            count_more_files_callback,\n                                            state);\n    }\n}\n\nstatic void\ndirectory_count_start (NautilusDirectory *directory,\n                       NautilusFile      *file,\n                       gboolean          *doing_io)\n{\n    DirectoryCountState *state;\n    GFile *location;\n\n    if (directory->details->count_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   should_get_directory_count_now,\n                   REQUEST_DIRECTORY_COUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        file->details->directory_count_is_up_to_date = TRUE;\n        file->details->directory_count_failed = FALSE;\n        file->details->got_directory_count = FALSE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"directory count\"))\n    {\n        return;\n    }\n\n    /* Start counting. */\n    state = g_new0 (DirectoryCountState, 1);\n    state->count_file = file;\n    state->directory = nautilus_directory_ref (directory);\n    state->cancellable = g_cancellable_new ();\n\n    directory->details->count_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n#ifdef DEBUG_LOAD_DIRECTORY\n    {\n        char *uri;\n        uri = g_file_get_uri (location);\n        g_message (\"load_directory called to get shallow file count for %s\", uri);\n        g_free (uri);\n    }\n#endif\n\n    g_file_enumerate_children_async (location,\n                                     G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP,\n                                     G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,     /* flags */\n                                     G_PRIORITY_DEFAULT,     /* prio */\n                                     state->cancellable,\n                                     count_children_callback,\n                                     state);\n    g_object_unref (location);\n}\n\nstatic inline gboolean\nseen_inode (DeepCountState *state,\n            GFileInfo      *info)\n{\n    guint64 inode, inode2;\n    guint i;\n\n    inode = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_UNIX_INODE);\n\n    if (inode != 0)\n    {\n        for (i = 0; i < state->seen_deep_count_inodes->len; i++)\n        {\n            inode2 = g_array_index (state->seen_deep_count_inodes, guint64, i);\n            if (inode == inode2)\n            {\n                return TRUE;\n            }\n        }\n    }\n\n    return FALSE;\n}\n\nstatic inline void\nmark_inode_as_seen (DeepCountState *state,\n                    GFileInfo      *info)\n{\n    guint64 inode;\n\n    inode = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_UNIX_INODE);\n    if (inode != 0)\n    {\n        g_array_append_val (state->seen_deep_count_inodes, inode);\n    }\n}\n\nstatic void\ndeep_count_one (DeepCountState *state,\n                GFileInfo      *info)\n{\n    NautilusFile *file;\n    GFile *subdir;\n    gboolean is_seen_inode;\n    const char *fs_id;\n\n    if (should_skip_file (NULL, info))\n    {\n        return;\n    }\n\n    is_seen_inode = seen_inode (state, info);\n    if (!is_seen_inode)\n    {\n        mark_inode_as_seen (state, info);\n    }\n\n    file = state->directory->details->deep_count_file;\n\n    if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n    {\n        /* Count the directory. */\n        file->details->deep_directory_count += 1;\n\n        /* Record the fact that we have to descend into this directory. */\n        fs_id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);\n        if (g_strcmp0 (fs_id, state->fs_id) == 0)\n        {\n            /* only if it is on the same filesystem */\n            subdir = g_file_get_child (state->deep_count_location, g_file_info_get_name (info));\n            state->deep_count_subdirectories = g_list_prepend\n                                                   (state->deep_count_subdirectories, subdir);\n        }\n    }\n    else\n    {\n        /* Even non-regular files count as files. */\n        file->details->deep_file_count += 1;\n    }\n\n    /* Count the size. */\n    if (!is_seen_inode && g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_STANDARD_SIZE))\n    {\n        file->details->deep_size += g_file_info_get_size (info);\n    }\n}\n\nstatic void\ndeep_count_state_free (DeepCountState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n    g_object_unref (state->cancellable);\n    if (state->deep_count_location)\n    {\n        g_object_unref (state->deep_count_location);\n    }\n    g_list_free_full (state->deep_count_subdirectories, g_object_unref);\n    g_array_free (state->seen_deep_count_inodes, TRUE);\n    g_free (state->fs_id);\n    g_free (state);\n}\n\nstatic void\ndeep_count_next_dir (DeepCountState *state)\n{\n    GFile *location;\n    NautilusFile *file;\n    NautilusDirectory *directory;\n    gboolean done;\n\n    directory = state->directory;\n\n    g_object_unref (state->deep_count_location);\n    state->deep_count_location = NULL;\n\n    done = FALSE;\n    file = directory->details->deep_count_file;\n\n    if (state->deep_count_subdirectories != NULL)\n    {\n        /* Work on a new directory. */\n        location = state->deep_count_subdirectories->data;\n        state->deep_count_subdirectories = g_list_remove\n                                               (state->deep_count_subdirectories, location);\n        deep_count_load (state, location);\n        g_object_unref (location);\n    }\n    else\n    {\n        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;\n        directory->details->deep_count_file = NULL;\n        directory->details->deep_count_in_progress = NULL;\n        deep_count_state_free (state);\n        done = TRUE;\n    }\n\n    nautilus_file_updated_deep_count_in_progress (file);\n\n    if (done)\n    {\n        nautilus_file_changed (file);\n        async_job_end (directory, \"deep count\");\n        nautilus_directory_async_state_changed (directory);\n    }\n}\n\nstatic void\ndeep_count_more_files_callback (GObject      *source_object,\n                                GAsyncResult *res,\n                                gpointer      user_data)\n{\n    DeepCountState *state;\n    NautilusDirectory *directory;\n    GList *files, *l;\n    GFileInfo *info;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        deep_count_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    g_assert (directory->details->deep_count_in_progress != NULL);\n    g_assert (directory->details->deep_count_in_progress == state);\n\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, NULL);\n\n    for (l = files; l != NULL; l = l->next)\n    {\n        info = l->data;\n        deep_count_one (state, info);\n        g_object_unref (info);\n    }\n\n    if (files == NULL)\n    {\n        g_file_enumerator_close_async (state->enumerator, 0, NULL, NULL, NULL);\n        g_object_unref (state->enumerator);\n        state->enumerator = NULL;\n\n        deep_count_next_dir (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_LOW,\n                                            state->cancellable,\n                                            deep_count_more_files_callback,\n                                            state);\n    }\n\n    g_list_free (files);\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\ndeep_count_callback (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    DeepCountState *state;\n    GFileEnumerator *enumerator;\n    NautilusFile *file;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        deep_count_state_free (state);\n        return;\n    }\n\n    file = state->directory->details->deep_count_file;\n\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object), res, NULL);\n\n    if (enumerator == NULL)\n    {\n        file->details->deep_unreadable_count += 1;\n\n        deep_count_next_dir (state);\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_LOW,\n                                            state->cancellable,\n                                            deep_count_more_files_callback,\n                                            state);\n    }\n}\n\n\nstatic void\ndeep_count_load (DeepCountState *state,\n                 GFile          *location)\n{\n    state->deep_count_location = g_object_ref (location);\n\n#ifdef DEBUG_LOAD_DIRECTORY\n    g_message (\"load_directory called to get deep file count for %p\", location);\n#endif\n    g_file_enumerate_children_async (state->deep_count_location,\n                                     G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_SIZE \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN \",\"\n                                     G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP \",\"\n                                     G_FILE_ATTRIBUTE_ID_FILESYSTEM \",\"\n                                     G_FILE_ATTRIBUTE_UNIX_INODE,\n                                     G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,     /* flags */\n                                     G_PRIORITY_LOW,     /* prio */\n                                     state->cancellable,\n                                     deep_count_callback,\n                                     state);\n}\n\nstatic void\ndeep_count_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        file = directory->details->deep_count_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_deep_count,\n                          REQUEST_DEEP_COUNT))\n            {\n                return;\n            }\n        }\n\n        /* The count is not wanted, so stop it. */\n        deep_count_cancel (directory);\n    }\n}\n\nstatic void\ndeep_count_got_info (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    GFileInfo *info;\n    const char *id;\n    GFile *file = (GFile *) source_object;\n    DeepCountState *state = (DeepCountState *) user_data;\n\n    info = g_file_query_info_finish (file, res, NULL);\n    if (info != NULL)\n    {\n        id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);\n        state->fs_id = g_strdup (id);\n        g_object_unref (info);\n    }\n    deep_count_load (state, file);\n}\n\nstatic void\ndeep_count_start (NautilusDirectory *directory,\n                  NautilusFile      *file,\n                  gboolean          *doing_io)\n{\n    GFile *location;\n    DeepCountState *state;\n\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_deep_count,\n                   REQUEST_DEEP_COUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"deep count\"))\n    {\n        return;\n    }\n\n    /* Start counting. */\n    file->details->deep_counts_status = NAUTILUS_REQUEST_IN_PROGRESS;\n    file->details->deep_directory_count = 0;\n    file->details->deep_file_count = 0;\n    file->details->deep_unreadable_count = 0;\n    file->details->deep_size = 0;\n    directory->details->deep_count_file = file;\n\n    state = g_new0 (DeepCountState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->seen_deep_count_inodes = g_array_new (FALSE, TRUE, sizeof (guint64));\n    state->fs_id = NULL;\n\n    directory->details->deep_count_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n    g_file_query_info_async (location,\n                             G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                             G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                             G_PRIORITY_DEFAULT,\n                             NULL,\n                             deep_count_got_info,\n                             state);\n    g_object_unref (location);\n}\n\nstatic void\nmime_list_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->mime_list_in_progress != NULL)\n    {\n        file = directory->details->mime_list_in_progress->mime_list_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          should_get_mime_list,\n                          REQUEST_MIME_LIST))\n            {\n                return;\n            }\n        }\n\n        /* The count is not wanted, so stop it. */\n        mime_list_cancel (directory);\n    }\n}\n\nstatic void\nmime_list_state_free (MimeListState *state)\n{\n    if (state->enumerator)\n    {\n        if (!g_file_enumerator_is_closed (state->enumerator))\n        {\n            g_file_enumerator_close_async (state->enumerator,\n                                           0, NULL, NULL, NULL);\n        }\n        g_object_unref (state->enumerator);\n    }\n    g_object_unref (state->cancellable);\n    istr_set_destroy (state->mime_list_hash);\n    nautilus_directory_unref (state->directory);\n    g_free (state);\n}\n\n\nstatic void\nmime_list_done (MimeListState *state,\n                gboolean       success)\n{\n    NautilusFile *file;\n    NautilusDirectory *directory;\n\n    directory = state->directory;\n    g_assert (directory != NULL);\n\n    file = state->mime_list_file;\n\n    file->details->mime_list_is_up_to_date = TRUE;\n    g_list_free_full (file->details->mime_list, g_free);\n    if (success)\n    {\n        file->details->mime_list_failed = TRUE;\n        file->details->mime_list = NULL;\n    }\n    else\n    {\n        file->details->got_mime_list = TRUE;\n        file->details->mime_list = istr_set_get_as_list (state->mime_list_hash);\n    }\n    directory->details->mime_list_in_progress = NULL;\n\n    /* Send file-changed even if getting the item type list\n     * failed, so interested parties can distinguish between\n     * unknowable and not-yet-known cases.\n     */\n    nautilus_file_changed (file);\n\n    /* Start up the next one. */\n    async_job_end (directory, \"MIME list\");\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\nmime_list_one (MimeListState *state,\n               GFileInfo     *info)\n{\n    const char *mime_type;\n\n    if (should_skip_file (NULL, info))\n    {\n        g_object_unref (info);\n        return;\n    }\n\n    mime_type = g_file_info_get_content_type (info);\n    if (mime_type != NULL)\n    {\n        istr_set_insert (state->mime_list_hash, mime_type);\n    }\n}\n\nstatic void\nmime_list_callback (GObject      *source_object,\n                    GAsyncResult *res,\n                    gpointer      user_data)\n{\n    MimeListState *state;\n    NautilusDirectory *directory;\n    GError *error;\n    GList *files, *l;\n    GFileInfo *info;\n\n    state = user_data;\n    directory = state->directory;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n        directory->details->mime_list_in_progress = NULL;\n\n        async_job_end (directory, \"MIME list\");\n        nautilus_directory_async_state_changed (directory);\n\n        mime_list_state_free (state);\n\n        return;\n    }\n\n    g_assert (directory->details->mime_list_in_progress != NULL);\n    g_assert (directory->details->mime_list_in_progress == state);\n\n    error = NULL;\n    files = g_file_enumerator_next_files_finish (state->enumerator,\n                                                 res, &error);\n\n    for (l = files; l != NULL; l = l->next)\n    {\n        info = l->data;\n        mime_list_one (state, info);\n        g_object_unref (info);\n    }\n\n    if (files == NULL)\n    {\n        mime_list_done (state, error != NULL);\n        mime_list_state_free (state);\n    }\n    else\n    {\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            mime_list_callback,\n                                            state);\n    }\n\n    g_list_free (files);\n\n    if (error)\n    {\n        g_error_free (error);\n    }\n}\n\nstatic void\nlist_mime_enum_callback (GObject      *source_object,\n                         GAsyncResult *res,\n                         gpointer      user_data)\n{\n    MimeListState *state;\n    GFileEnumerator *enumerator;\n    NautilusDirectory *directory;\n    GError *error;\n\n    state = user_data;\n\n    if (g_cancellable_is_cancelled (state->cancellable))\n    {\n        /* Operation was cancelled. Bail out */\n        directory = state->directory;\n        directory->details->mime_list_in_progress = NULL;\n\n        async_job_end (directory, \"MIME list\");\n        nautilus_directory_async_state_changed (directory);\n\n        mime_list_state_free (state);\n\n        return;\n    }\n\n    error = NULL;\n    enumerator = g_file_enumerate_children_finish (G_FILE (source_object),\n                                                   res, &error);\n\n    if (enumerator == NULL)\n    {\n        mime_list_done (state, FALSE);\n        g_error_free (error);\n        mime_list_state_free (state);\n        return;\n    }\n    else\n    {\n        state->enumerator = enumerator;\n        g_file_enumerator_next_files_async (state->enumerator,\n                                            DIRECTORY_LOAD_ITEMS_PER_CALLBACK,\n                                            G_PRIORITY_DEFAULT,\n                                            state->cancellable,\n                                            mime_list_callback,\n                                            state);\n    }\n}\n\nstatic void\nmime_list_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    MimeListState *state;\n    GFile *location;\n\n    mime_list_stop (directory);\n\n    if (directory->details->mime_list_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    /* Figure out which file to get a mime list for. */\n    if (!is_needy (file,\n                   should_get_mime_list,\n                   REQUEST_MIME_LIST))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        g_list_free (file->details->mime_list);\n        file->details->mime_list_failed = FALSE;\n        file->details->got_mime_list = FALSE;\n        file->details->mime_list_is_up_to_date = TRUE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"MIME list\"))\n    {\n        return;\n    }\n\n\n    state = g_new0 (MimeListState, 1);\n    state->mime_list_file = file;\n    state->directory = nautilus_directory_ref (directory);\n    state->cancellable = g_cancellable_new ();\n    state->mime_list_hash = istr_set_new ();\n\n    directory->details->mime_list_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n#ifdef DEBUG_LOAD_DIRECTORY\n    {\n        char *uri;\n        uri = g_file_get_uri (location);\n        g_message (\"load_directory called to get MIME list of %s\", uri);\n        g_free (uri);\n    }\n#endif\n\n    g_file_enumerate_children_async (location,\n                                     G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,\n                                     0,     /* flags */\n                                     G_PRIORITY_LOW,     /* prio */\n                                     state->cancellable,\n                                     list_mime_enum_callback,\n                                     state);\n    g_object_unref (location);\n}\n\nstatic void\nget_info_state_free (GetInfoState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\nquery_info_callback (GObject      *source_object,\n                     GAsyncResult *res,\n                     gpointer      user_data)\n{\n    NautilusDirectory *directory;\n    NautilusFile *get_info_file;\n    GFileInfo *info;\n    GetInfoState *state;\n    GError *error;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        get_info_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    get_info_file = directory->details->get_info_file;\n    g_assert (NAUTILUS_IS_FILE (get_info_file));\n\n    directory->details->get_info_file = NULL;\n    directory->details->get_info_in_progress = NULL;\n\n    /* ref here because we might be removing the last ref when we\n     * mark the file gone below, but we need to keep a ref at\n     * least long enough to send the change notification.\n     */\n    nautilus_file_ref (get_info_file);\n\n    error = NULL;\n    info = g_file_query_info_finish (G_FILE (source_object), res, &error);\n\n    if (info == NULL)\n    {\n        if (error->domain == G_IO_ERROR && error->code == G_IO_ERROR_NOT_FOUND)\n        {\n            /* mark file as gone */\n            nautilus_file_mark_gone (get_info_file);\n        }\n        get_info_file->details->file_info_is_up_to_date = TRUE;\n        nautilus_file_clear_info (get_info_file);\n        get_info_file->details->get_info_failed = TRUE;\n        get_info_file->details->get_info_error = error;\n    }\n    else\n    {\n        nautilus_file_update_info (get_info_file, info);\n        g_object_unref (info);\n    }\n\n    nautilus_file_changed (get_info_file);\n    nautilus_file_unref (get_info_file);\n\n    async_job_end (directory, \"file info\");\n    nautilus_directory_async_state_changed (directory);\n\n    nautilus_directory_unref (directory);\n\n    get_info_state_free (state);\n}\n\nstatic void\nfile_info_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->get_info_in_progress != NULL)\n    {\n        file = directory->details->get_info_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file, lacks_info, REQUEST_FILE_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The info is not wanted, so stop it. */\n        file_info_cancel (directory);\n    }\n}\n\nstatic void\nfile_info_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    GetInfoState *state;\n\n    file_info_stop (directory);\n\n    if (directory->details->get_info_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file, lacks_info, REQUEST_FILE_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"file info\"))\n    {\n        return;\n    }\n\n    directory->details->get_info_file = file;\n    file->details->get_info_failed = FALSE;\n    if (file->details->get_info_error)\n    {\n        g_error_free (file->details->get_info_error);\n        file->details->get_info_error = NULL;\n    }\n\n    state = g_new (GetInfoState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n\n    directory->details->get_info_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n    g_file_query_info_async (location,\n                             NAUTILUS_FILE_DEFAULT_ATTRIBUTES,\n                             0,\n                             G_PRIORITY_DEFAULT,\n                             state->cancellable, query_info_callback, state);\n    g_object_unref (location);\n}\n\nstatic gboolean\nis_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    g_autofree gchar* trusted = NULL;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    trusted = nautilus_file_get_metadata (file,\n                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                          NULL);\n    if (nautilus_file_can_execute (file) && trusted != NULL)\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}\n\nstatic void\nlink_info_done (NautilusDirectory *directory,\n                NautilusFile      *file,\n                const char        *uri,\n                const char        *name,\n                GIcon             *icon,\n                gboolean           is_launcher,\n                gboolean           is_foreign)\n{\n    gboolean is_trusted;\n\n    file->details->link_info_is_up_to_date = TRUE;\n\n    is_trusted = is_link_trusted (file, is_launcher);\n\n    if (is_trusted)\n    {\n        nautilus_file_set_display_name (file, name, name, TRUE);\n    }\n    else\n    {\n        nautilus_file_set_display_name (file, NULL, NULL, TRUE);\n    }\n\n    file->details->got_link_info = TRUE;\n    g_clear_object (&file->details->custom_icon);\n\n    if (uri)\n    {\n        g_free (file->details->activation_uri);\n        file->details->activation_uri = NULL;\n        file->details->got_custom_activation_uri = TRUE;\n        file->details->activation_uri = g_strdup (uri);\n    }\n    if (is_trusted && (icon != NULL))\n    {\n        file->details->custom_icon = g_object_ref (icon);\n    }\n    file->details->is_launcher = is_launcher;\n    file->details->is_foreign_link = is_foreign;\n    file->details->is_trusted_link = is_trusted;\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\nlink_info_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->link_info_read_state != NULL)\n    {\n        file = directory->details->link_info_read_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_link_info,\n                          REQUEST_LINK_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The link info is not wanted, so stop it. */\n        link_info_cancel (directory);\n    }\n}\n\nstatic void\nlink_info_got_data (NautilusDirectory *directory,\n                    NautilusFile      *file,\n                    gboolean           result,\n                    goffset            bytes_read,\n                    char              *file_contents)\n{\n    char *link_uri, *uri, *name;\n    GIcon *icon;\n    gboolean is_launcher;\n    gboolean is_foreign;\n\n    nautilus_directory_ref (directory);\n\n    uri = NULL;\n    name = NULL;\n    icon = NULL;\n    is_launcher = FALSE;\n    is_foreign = FALSE;\n\n    /* Handle the case where we read the Nautilus link. */\n    if (result)\n    {\n        link_uri = nautilus_file_get_uri (file);\n        nautilus_link_get_link_info_given_file_contents (file_contents, bytes_read, link_uri,\n                                                         &uri, &name, &icon, &is_launcher, &is_foreign);\n        g_free (link_uri);\n    }\n    else\n    {\n        /* FIXME bugzilla.gnome.org 42433: We should report this error to the user. */\n    }\n\n    nautilus_file_ref (file);\n    link_info_done (directory, file, uri, name, icon, is_launcher, is_foreign);\n    nautilus_file_changed (file);\n    nautilus_file_unref (file);\n\n    g_free (uri);\n    g_free (name);\n\n    if (icon != NULL)\n    {\n        g_object_unref (icon);\n    }\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nlink_info_read_state_free (LinkInfoReadState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\nlink_info_nautilus_link_read_callback (GObject      *source_object,\n                                       GAsyncResult *res,\n                                       gpointer      user_data)\n{\n    LinkInfoReadState *state;\n    gsize file_size;\n    char *file_contents;\n    gboolean result;\n    NautilusDirectory *directory;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        link_info_read_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    result = g_file_load_contents_finish (G_FILE (source_object),\n                                          res,\n                                          &file_contents, &file_size,\n                                          NULL, NULL);\n\n    state->directory->details->link_info_read_state = NULL;\n    async_job_end (state->directory, \"link info\");\n\n    link_info_got_data (state->directory, state->file, result, file_size, file_contents);\n\n    if (result)\n    {\n        g_free (file_contents);\n    }\n\n    link_info_read_state_free (state);\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nlink_info_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    gboolean nautilus_style_link;\n    LinkInfoReadState *state;\n\n    if (directory->details->link_info_read_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_link_info,\n                   REQUEST_LINK_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    /* Figure out if it is a link. */\n    nautilus_style_link = nautilus_file_is_nautilus_link (file);\n    location = nautilus_file_get_location (file);\n\n    /* If it's not a link we are done. If it is, we need to read it. */\n    if (!nautilus_style_link)\n    {\n        link_info_done (directory, file, NULL, NULL, NULL, FALSE, FALSE);\n    }\n    else\n    {\n        if (!async_job_start (directory, \"link info\"))\n        {\n            g_object_unref (location);\n            return;\n        }\n\n        state = g_new0 (LinkInfoReadState, 1);\n        state->directory = directory;\n        state->file = file;\n        state->cancellable = g_cancellable_new ();\n\n        directory->details->link_info_read_state = state;\n\n        g_file_load_contents_async (location,\n                                    state->cancellable,\n                                    link_info_nautilus_link_read_callback,\n                                    state);\n    }\n    g_object_unref (location);\n}\n\nstatic void\nthumbnail_done (NautilusDirectory *directory,\n                NautilusFile      *file,\n                GdkPixbuf         *pixbuf,\n                gboolean           tried_original)\n{\n    const char *thumb_mtime_str;\n    time_t thumb_mtime = 0;\n\n    file->details->thumbnail_is_up_to_date = TRUE;\n    file->details->thumbnail_tried_original = tried_original;\n    if (file->details->thumbnail)\n    {\n        g_object_unref (file->details->thumbnail);\n        file->details->thumbnail = NULL;\n    }\n    if (file->details->scaled_thumbnail)\n    {\n        g_object_unref (file->details->scaled_thumbnail);\n        file->details->scaled_thumbnail = NULL;\n    }\n\n    if (pixbuf)\n    {\n        if (tried_original)\n        {\n            thumb_mtime = file->details->mtime;\n        }\n        else\n        {\n            thumb_mtime_str = gdk_pixbuf_get_option (pixbuf, \"tEXt::Thumb::MTime\");\n            if (thumb_mtime_str)\n            {\n                thumb_mtime = atol (thumb_mtime_str);\n            }\n        }\n\n        if (thumb_mtime == 0 ||\n            thumb_mtime == file->details->mtime)\n        {\n            file->details->thumbnail = g_object_ref (pixbuf);\n            file->details->thumbnail_mtime = thumb_mtime;\n        }\n        else\n        {\n            g_free (file->details->thumbnail_path);\n            file->details->thumbnail_path = NULL;\n        }\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nstatic void\nthumbnail_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->thumbnail_state != NULL)\n    {\n        file = directory->details->thumbnail_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_thumbnail,\n                          REQUEST_THUMBNAIL))\n            {\n                return;\n            }\n        }\n\n        /* The link info is not wanted, so stop it. */\n        thumbnail_cancel (directory);\n    }\n}\n\nstatic void\nthumbnail_got_pixbuf (NautilusDirectory *directory,\n                      NautilusFile      *file,\n                      GdkPixbuf         *pixbuf,\n                      gboolean           tried_original)\n{\n    nautilus_directory_ref (directory);\n\n    nautilus_file_ref (file);\n    thumbnail_done (directory, file, pixbuf, tried_original);\n    nautilus_file_changed (file);\n    nautilus_file_unref (file);\n\n    if (pixbuf)\n    {\n        g_object_unref (pixbuf);\n    }\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nthumbnail_state_free (ThumbnailState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nextern int cached_thumbnail_size;\n\n/* scale very large images down to the max. size we need */\nstatic void\nthumbnail_loader_size_prepared (GdkPixbufLoader *loader,\n                                int              width,\n                                int              height,\n                                gpointer         user_data)\n{\n    int max_thumbnail_size;\n    double aspect_ratio;\n\n    aspect_ratio = ((double) width) / height;\n\n    /* cf. nautilus_file_get_icon() */\n    max_thumbnail_size = NAUTILUS_CANVAS_ICON_SIZE_LARGER * cached_thumbnail_size / NAUTILUS_CANVAS_ICON_SIZE_SMALL;\n    if (MAX (width, height) > max_thumbnail_size)\n    {\n        if (width > height)\n        {\n            width = max_thumbnail_size;\n            height = width / aspect_ratio;\n        }\n        else\n        {\n            height = max_thumbnail_size;\n            width = height * aspect_ratio;\n        }\n\n        gdk_pixbuf_loader_set_size (loader, width, height);\n    }\n}\n\nstatic GdkPixbuf *\nget_pixbuf_for_content (goffset  file_len,\n                        char    *file_contents)\n{\n    gboolean res;\n    GdkPixbuf *pixbuf, *pixbuf2;\n    GdkPixbufLoader *loader;\n    gsize chunk_len;\n    pixbuf = NULL;\n\n    loader = gdk_pixbuf_loader_new ();\n    g_signal_connect (loader, \"size-prepared\",\n                      G_CALLBACK (thumbnail_loader_size_prepared),\n                      NULL);\n\n    /* For some reason we have to write in chunks, or gdk-pixbuf fails */\n    res = TRUE;\n    while (res && file_len > 0)\n    {\n        chunk_len = file_len;\n        res = gdk_pixbuf_loader_write (loader, (guchar *) file_contents, chunk_len, NULL);\n        file_contents += chunk_len;\n        file_len -= chunk_len;\n    }\n    if (res)\n    {\n        res = gdk_pixbuf_loader_close (loader, NULL);\n    }\n    if (res)\n    {\n        pixbuf = g_object_ref (gdk_pixbuf_loader_get_pixbuf (loader));\n    }\n    g_object_unref (G_OBJECT (loader));\n\n    if (pixbuf)\n    {\n        pixbuf2 = gdk_pixbuf_apply_embedded_orientation (pixbuf);\n        g_object_unref (pixbuf);\n        pixbuf = pixbuf2;\n    }\n    return pixbuf;\n}\n\n\nstatic void\nthumbnail_read_callback (GObject      *source_object,\n                         GAsyncResult *res,\n                         gpointer      user_data)\n{\n    ThumbnailState *state;\n    gsize file_size;\n    char *file_contents;\n    gboolean result;\n    NautilusDirectory *directory;\n    GdkPixbuf *pixbuf;\n    GFile *location;\n\n    state = user_data;\n\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        thumbnail_state_free (state);\n        return;\n    }\n\n    directory = nautilus_directory_ref (state->directory);\n\n    result = g_file_load_contents_finish (G_FILE (source_object),\n                                          res,\n                                          &file_contents, &file_size,\n                                          NULL, NULL);\n\n    pixbuf = NULL;\n    if (result)\n    {\n        pixbuf = get_pixbuf_for_content (file_size, file_contents);\n        g_free (file_contents);\n    }\n\n    if (pixbuf == NULL && state->trying_original)\n    {\n        state->trying_original = FALSE;\n\n        location = g_file_new_for_path (state->file->details->thumbnail_path);\n        g_file_load_contents_async (location,\n                                    state->cancellable,\n                                    thumbnail_read_callback,\n                                    state);\n        g_object_unref (location);\n    }\n    else\n    {\n        state->directory->details->thumbnail_state = NULL;\n        async_job_end (state->directory, \"thumbnail\");\n\n        thumbnail_got_pixbuf (state->directory, state->file, pixbuf, state->tried_original);\n\n        thumbnail_state_free (state);\n    }\n\n    nautilus_directory_unref (directory);\n}\n\nstatic void\nthumbnail_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    ThumbnailState *state;\n\n    if (directory->details->thumbnail_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_thumbnail,\n                   REQUEST_THUMBNAIL))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"thumbnail\"))\n    {\n        return;\n    }\n\n    state = g_new0 (ThumbnailState, 1);\n    state->directory = directory;\n    state->file = file;\n    state->cancellable = g_cancellable_new ();\n\n    if (file->details->thumbnail_wants_original)\n    {\n        state->tried_original = TRUE;\n        state->trying_original = TRUE;\n        location = nautilus_file_get_location (file);\n    }\n    else\n    {\n        location = g_file_new_for_path (file->details->thumbnail_path);\n    }\n\n    directory->details->thumbnail_state = state;\n\n    g_file_load_contents_async (location,\n                                state->cancellable,\n                                thumbnail_read_callback,\n                                state);\n    g_object_unref (location);\n}\n\nstatic void\nmount_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->mount_state != NULL)\n    {\n        file = directory->details->mount_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_mount,\n                          REQUEST_MOUNT))\n            {\n                return;\n            }\n        }\n\n        /* The link info is not wanted, so stop it. */\n        mount_cancel (directory);\n    }\n}\n\nstatic void\nmount_state_free (MountState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\ngot_mount (MountState *state,\n           GMount     *mount)\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n\n    directory = nautilus_directory_ref (state->directory);\n\n    state->directory->details->mount_state = NULL;\n    async_job_end (state->directory, \"mount\");\n\n    file = nautilus_file_ref (state->file);\n\n    file->details->mount_is_up_to_date = TRUE;\n    nautilus_file_set_mount (file, mount);\n\n    nautilus_directory_async_state_changed (directory);\n    nautilus_file_changed (file);\n\n    nautilus_file_unref (file);\n\n    nautilus_directory_unref (directory);\n\n    mount_state_free (state);\n}\n\nstatic void\nfind_enclosing_mount_callback (GObject      *source_object,\n                               GAsyncResult *res,\n                               gpointer      user_data)\n{\n    GMount *mount;\n    MountState *state;\n    GFile *location, *root;\n\n    state = user_data;\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        mount_state_free (state);\n        return;\n    }\n\n    mount = g_file_find_enclosing_mount_finish (G_FILE (source_object),\n                                                res, NULL);\n\n    if (mount)\n    {\n        root = g_mount_get_root (mount);\n        location = nautilus_file_get_location (state->file);\n        if (!g_file_equal (location, root))\n        {\n            g_object_unref (mount);\n            mount = NULL;\n        }\n        g_object_unref (root);\n        g_object_unref (location);\n    }\n\n    got_mount (state, mount);\n\n    if (mount)\n    {\n        g_object_unref (mount);\n    }\n}\n\nstatic GMount *\nget_mount_at (GFile *target)\n{\n    GVolumeMonitor *monitor;\n    GFile *root;\n    GList *mounts, *l;\n    GMount *found;\n\n    monitor = g_volume_monitor_get ();\n    mounts = g_volume_monitor_get_mounts (monitor);\n\n    found = NULL;\n    for (l = mounts; l != NULL; l = l->next)\n    {\n        GMount *mount = G_MOUNT (l->data);\n\n        if (g_mount_is_shadowed (mount))\n        {\n            continue;\n        }\n\n        root = g_mount_get_root (mount);\n\n        if (g_file_equal (target, root))\n        {\n            found = g_object_ref (mount);\n            break;\n        }\n\n        g_object_unref (root);\n    }\n\n    g_list_free_full (mounts, g_object_unref);\n\n    g_object_unref (monitor);\n\n    return found;\n}\n\nstatic void\nmount_start (NautilusDirectory *directory,\n             NautilusFile      *file,\n             gboolean          *doing_io)\n{\n    GFile *location;\n    MountState *state;\n\n    if (directory->details->mount_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_mount,\n                   REQUEST_MOUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"mount\"))\n    {\n        return;\n    }\n\n    state = g_new0 (MountState, 1);\n    state->directory = directory;\n    state->file = file;\n    state->cancellable = g_cancellable_new ();\n\n    location = nautilus_file_get_location (file);\n\n    directory->details->mount_state = state;\n\n    if (file->details->type == G_FILE_TYPE_MOUNTABLE)\n    {\n        GFile *target;\n        GMount *mount;\n\n        mount = NULL;\n        target = nautilus_file_get_activation_location (file);\n        if (target != NULL)\n        {\n            mount = get_mount_at (target);\n            g_object_unref (target);\n        }\n\n        got_mount (state, mount);\n\n        if (mount)\n        {\n            g_object_unref (mount);\n        }\n    }\n    else\n    {\n        g_file_find_enclosing_mount_async (location,\n                                           G_PRIORITY_DEFAULT,\n                                           state->cancellable,\n                                           find_enclosing_mount_callback,\n                                           state);\n    }\n    g_object_unref (location);\n}\n\nstatic void\nfilesystem_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->filesystem_info_state != NULL)\n    {\n        g_cancellable_cancel (directory->details->filesystem_info_state->cancellable);\n        directory->details->filesystem_info_state->directory = NULL;\n        directory->details->filesystem_info_state = NULL;\n        async_job_end (directory, \"filesystem info\");\n    }\n}\n\nstatic void\nfilesystem_info_stop (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n\n    if (directory->details->filesystem_info_state != NULL)\n    {\n        file = directory->details->filesystem_info_state->file;\n\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file,\n                          lacks_filesystem_info,\n                          REQUEST_FILESYSTEM_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The filesystem info is not wanted, so stop it. */\n        filesystem_info_cancel (directory);\n    }\n}\n\nstatic void\nfilesystem_info_state_free (FilesystemInfoState *state)\n{\n    g_object_unref (state->cancellable);\n    g_free (state);\n}\n\nstatic void\ngot_filesystem_info (FilesystemInfoState *state,\n                     GFileInfo           *info)\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n    const char *filesystem_type;\n\n    /* careful here, info may be NULL */\n\n    directory = nautilus_directory_ref (state->directory);\n\n    state->directory->details->filesystem_info_state = NULL;\n    async_job_end (state->directory, \"filesystem info\");\n\n    file = nautilus_file_ref (state->file);\n\n    file->details->filesystem_info_is_up_to_date = TRUE;\n    if (info != NULL)\n    {\n        file->details->filesystem_use_preview =\n            g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW);\n        file->details->filesystem_readonly =\n            g_file_info_get_attribute_boolean (info, G_FILE_ATTRIBUTE_FILESYSTEM_READONLY);\n        filesystem_type = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE);\n        if (g_strcmp0 (eel_ref_str_peek (file->details->filesystem_type), filesystem_type) != 0)\n        {\n            eel_ref_str_unref (file->details->filesystem_type);\n            file->details->filesystem_type = eel_ref_str_get_unique (filesystem_type);\n        }\n    }\n\n    nautilus_directory_async_state_changed (directory);\n    nautilus_file_changed (file);\n\n    nautilus_file_unref (file);\n\n    nautilus_directory_unref (directory);\n\n    filesystem_info_state_free (state);\n}\n\nstatic void\nquery_filesystem_info_callback (GObject      *source_object,\n                                GAsyncResult *res,\n                                gpointer      user_data)\n{\n    GFileInfo *info;\n    FilesystemInfoState *state;\n\n    state = user_data;\n    if (state->directory == NULL)\n    {\n        /* Operation was cancelled. Bail out */\n        filesystem_info_state_free (state);\n        return;\n    }\n\n    info = g_file_query_filesystem_info_finish (G_FILE (source_object), res, NULL);\n\n    got_filesystem_info (state, info);\n\n    if (info != NULL)\n    {\n        g_object_unref (info);\n    }\n}\n\nstatic void\nfilesystem_info_start (NautilusDirectory *directory,\n                       NautilusFile      *file,\n                       gboolean          *doing_io)\n{\n    GFile *location;\n    FilesystemInfoState *state;\n\n    if (directory->details->filesystem_info_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_filesystem_info,\n                   REQUEST_FILESYSTEM_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"filesystem info\"))\n    {\n        return;\n    }\n\n    state = g_new0 (FilesystemInfoState, 1);\n    state->directory = directory;\n    state->file = file;\n    state->cancellable = g_cancellable_new ();\n\n    location = nautilus_file_get_location (file);\n\n    directory->details->filesystem_info_state = state;\n\n    g_file_query_filesystem_info_async (location,\n                                        G_FILE_ATTRIBUTE_FILESYSTEM_READONLY \",\"\n                                        G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW \",\"\n                                        G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,\n                                        G_PRIORITY_DEFAULT,\n                                        state->cancellable,\n                                        query_filesystem_info_callback,\n                                        state);\n    g_object_unref (location);\n}\n\nstatic void\nextension_info_cancel (NautilusDirectory *directory)\n{\n    if (directory->details->extension_info_in_progress != NULL)\n    {\n        if (directory->details->extension_info_idle)\n        {\n            g_source_remove (directory->details->extension_info_idle);\n        }\n        else\n        {\n            nautilus_info_provider_cancel_update\n                (directory->details->extension_info_provider,\n                directory->details->extension_info_in_progress);\n        }\n\n        directory->details->extension_info_in_progress = NULL;\n        directory->details->extension_info_file = NULL;\n        directory->details->extension_info_provider = NULL;\n        directory->details->extension_info_idle = 0;\n\n        async_job_end (directory, \"extension info\");\n    }\n}\n\nstatic void\nextension_info_stop (NautilusDirectory *directory)\n{\n    if (directory->details->extension_info_in_progress != NULL)\n    {\n        NautilusFile *file;\n\n        file = directory->details->extension_info_file;\n        if (file != NULL)\n        {\n            g_assert (NAUTILUS_IS_FILE (file));\n            g_assert (file->details->directory == directory);\n            if (is_needy (file, lacks_extension_info, REQUEST_EXTENSION_INFO))\n            {\n                return;\n            }\n        }\n\n        /* The info is not wanted, so stop it. */\n        extension_info_cancel (directory);\n    }\n}\n\nstatic void\nfinish_info_provider (NautilusDirectory    *directory,\n                      NautilusFile         *file,\n                      NautilusInfoProvider *provider)\n{\n    file->details->pending_info_providers =\n        g_list_remove (file->details->pending_info_providers,\n                       provider);\n    g_object_unref (provider);\n\n    nautilus_directory_async_state_changed (directory);\n\n    if (file->details->pending_info_providers == NULL)\n    {\n        nautilus_file_info_providers_done (file);\n    }\n}\n\n\nstatic gboolean\ninfo_provider_idle_callback (gpointer user_data)\n{\n    InfoProviderResponse *response;\n    NautilusDirectory *directory;\n\n    response = user_data;\n    directory = response->directory;\n\n    if (response->handle != directory->details->extension_info_in_progress\n        || response->provider != directory->details->extension_info_provider)\n    {\n        g_warning (\"Unexpected plugin response.  This probably indicates a bug in a Nautilus extension: handle=%p\", response->handle);\n    }\n    else\n    {\n        NautilusFile *file;\n        async_job_end (directory, \"extension info\");\n\n        file = directory->details->extension_info_file;\n\n        directory->details->extension_info_file = NULL;\n        directory->details->extension_info_provider = NULL;\n        directory->details->extension_info_in_progress = NULL;\n        directory->details->extension_info_idle = 0;\n\n        finish_info_provider (directory, file, response->provider);\n    }\n\n    return FALSE;\n}\n\nstatic void\ninfo_provider_callback (NautilusInfoProvider    *provider,\n                        NautilusOperationHandle *handle,\n                        NautilusOperationResult  result,\n                        gpointer                 user_data)\n{\n    InfoProviderResponse *response;\n\n    response = g_new0 (InfoProviderResponse, 1);\n    response->provider = provider;\n    response->handle = handle;\n    response->result = result;\n    response->directory = NAUTILUS_DIRECTORY (user_data);\n\n    response->directory->details->extension_info_idle =\n        g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,\n                         info_provider_idle_callback, response,\n                         g_free);\n}\n\nstatic void\nextension_info_start (NautilusDirectory *directory,\n                      NautilusFile      *file,\n                      gboolean          *doing_io)\n{\n    NautilusInfoProvider *provider;\n    NautilusOperationResult result;\n    NautilusOperationHandle *handle;\n    GClosure *update_complete;\n\n    if (directory->details->extension_info_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file, lacks_extension_info, REQUEST_EXTENSION_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!async_job_start (directory, \"extension info\"))\n    {\n        return;\n    }\n\n    provider = file->details->pending_info_providers->data;\n\n    update_complete = g_cclosure_new (G_CALLBACK (info_provider_callback),\n                                      directory,\n                                      NULL);\n    g_closure_set_marshal (update_complete,\n                           g_cclosure_marshal_generic);\n\n    result = nautilus_info_provider_update_file_info\n                 (provider,\n                 NAUTILUS_FILE_INFO (file),\n                 update_complete,\n                 &handle);\n\n    g_closure_unref (update_complete);\n\n    if (result == NAUTILUS_OPERATION_COMPLETE ||\n        result == NAUTILUS_OPERATION_FAILED)\n    {\n        finish_info_provider (directory, file, provider);\n        async_job_end (directory, \"extension info\");\n    }\n    else\n    {\n        directory->details->extension_info_in_progress = handle;\n        directory->details->extension_info_provider = provider;\n        directory->details->extension_info_file = file;\n    }\n}\n\nstatic void\nstart_or_stop_io (NautilusDirectory *directory)\n{\n    NautilusFile *file;\n    gboolean doing_io;\n\n    /* Start or stop reading files. */\n    file_list_start_or_stop (directory);\n\n    /* Stop any no longer wanted attribute fetches. */\n    file_info_stop (directory);\n    directory_count_stop (directory);\n    deep_count_stop (directory);\n    mime_list_stop (directory);\n    link_info_stop (directory);\n    extension_info_stop (directory);\n    mount_stop (directory);\n    thumbnail_stop (directory);\n    filesystem_info_stop (directory);\n\n    doing_io = FALSE;\n    /* Take files that are all done off the queue. */\n    while (!nautilus_file_queue_is_empty (directory->details->high_priority_queue))\n    {\n        file = nautilus_file_queue_head (directory->details->high_priority_queue);\n\n        /* Start getting attributes if possible */\n        file_info_start (directory, file, &doing_io);\n        link_info_start (directory, file, &doing_io);\n\n        if (doing_io)\n        {\n            return;\n        }\n\n        move_file_to_low_priority_queue (directory, file);\n    }\n\n    /* High priority queue must be empty */\n    while (!nautilus_file_queue_is_empty (directory->details->low_priority_queue))\n    {\n        file = nautilus_file_queue_head (directory->details->low_priority_queue);\n\n        /* Start getting attributes if possible */\n        mount_start (directory, file, &doing_io);\n        directory_count_start (directory, file, &doing_io);\n        deep_count_start (directory, file, &doing_io);\n        mime_list_start (directory, file, &doing_io);\n        thumbnail_start (directory, file, &doing_io);\n        filesystem_info_start (directory, file, &doing_io);\n\n        if (doing_io)\n        {\n            return;\n        }\n\n        move_file_to_extension_queue (directory, file);\n    }\n\n    /* Low priority queue must be empty */\n    while (!nautilus_file_queue_is_empty (directory->details->extension_queue))\n    {\n        file = nautilus_file_queue_head (directory->details->extension_queue);\n\n        /* Start getting attributes if possible */\n        extension_info_start (directory, file, &doing_io);\n        if (doing_io)\n        {\n            return;\n        }\n\n        nautilus_directory_remove_file_from_work_queue (directory, file);\n    }\n}\n\n/* Call this when the monitor or call when ready list changes,\n * or when some I/O is completed.\n */\nvoid\nnautilus_directory_async_state_changed (NautilusDirectory *directory)\n{\n    /* Check if any callbacks are satisfied and call them if they\n     * are. Do this last so that any changes done in start or stop\n     * I/O functions immediately (not in callbacks) are taken into\n     * consideration. If any callbacks are called, consider the\n     * I/O state again so that we can release or cancel I/O that\n     * is not longer needed once the callbacks are satisfied.\n     */\n\n    if (directory->details->in_async_service_loop)\n    {\n        directory->details->state_changed = TRUE;\n        return;\n    }\n    directory->details->in_async_service_loop = TRUE;\n    nautilus_directory_ref (directory);\n    do\n    {\n        directory->details->state_changed = FALSE;\n        start_or_stop_io (directory);\n        if (call_ready_callbacks (directory))\n        {\n            directory->details->state_changed = TRUE;\n        }\n    }\n    while (directory->details->state_changed);\n    directory->details->in_async_service_loop = FALSE;\n    nautilus_directory_unref (directory);\n\n    /* Check if any directories should wake up. */\n    async_job_wake_up ();\n}\n\nvoid\nnautilus_directory_cancel (NautilusDirectory *directory)\n{\n    /* Arbitrary order (kept alphabetical). */\n    deep_count_cancel (directory);\n    directory_count_cancel (directory);\n    file_info_cancel (directory);\n    file_list_cancel (directory);\n    link_info_cancel (directory);\n    mime_list_cancel (directory);\n    new_files_cancel (directory);\n    extension_info_cancel (directory);\n    thumbnail_cancel (directory);\n    mount_cancel (directory);\n    filesystem_info_cancel (directory);\n\n    /* We aren't waiting for anything any more. */\n    if (waiting_directories != NULL)\n    {\n        g_hash_table_remove (waiting_directories, directory);\n    }\n\n    /* Check if any directories should wake up. */\n    async_job_wake_up ();\n}\n\nstatic void\ncancel_directory_count_for_file (NautilusDirectory *directory,\n                                 NautilusFile      *file)\n{\n    if (directory->details->count_in_progress != NULL &&\n        directory->details->count_in_progress->count_file == file)\n    {\n        directory_count_cancel (directory);\n    }\n}\n\nstatic void\ncancel_deep_counts_for_file (NautilusDirectory *directory,\n                             NautilusFile      *file)\n{\n    if (directory->details->deep_count_file == file)\n    {\n        deep_count_cancel (directory);\n    }\n}\n\nstatic void\ncancel_mime_list_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->mime_list_in_progress != NULL &&\n        directory->details->mime_list_in_progress->mime_list_file == file)\n    {\n        mime_list_cancel (directory);\n    }\n}\n\nstatic void\ncancel_file_info_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->get_info_file == file)\n    {\n        file_info_cancel (directory);\n    }\n}\n\nstatic void\ncancel_thumbnail_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->thumbnail_state != NULL &&\n        directory->details->thumbnail_state->file == file)\n    {\n        thumbnail_cancel (directory);\n    }\n}\n\nstatic void\ncancel_mount_for_file (NautilusDirectory *directory,\n                       NautilusFile      *file)\n{\n    if (directory->details->mount_state != NULL &&\n        directory->details->mount_state->file == file)\n    {\n        mount_cancel (directory);\n    }\n}\n\nstatic void\ncancel_filesystem_info_for_file (NautilusDirectory *directory,\n                                 NautilusFile      *file)\n{\n    if (directory->details->filesystem_info_state != NULL &&\n        directory->details->filesystem_info_state->file == file)\n    {\n        filesystem_info_cancel (directory);\n    }\n}\n\nstatic void\ncancel_link_info_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->link_info_read_state != NULL &&\n        directory->details->link_info_read_state->file == file)\n    {\n        link_info_cancel (directory);\n    }\n}\n\n\nstatic void\ncancel_loading_attributes (NautilusDirectory      *directory,\n                           NautilusFileAttributes  file_attributes)\n{\n    Request request;\n\n    request = nautilus_directory_set_up_request (file_attributes);\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))\n    {\n        directory_count_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))\n    {\n        deep_count_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))\n    {\n        mime_list_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))\n    {\n        file_info_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))\n    {\n        filesystem_info_cancel (directory);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))\n    {\n        link_info_cancel (directory);\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_EXTENSION_INFO))\n    {\n        extension_info_cancel (directory);\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))\n    {\n        thumbnail_cancel (directory);\n    }\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))\n    {\n        mount_cancel (directory);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nvoid\nnautilus_directory_cancel_loading_file_attributes (NautilusDirectory      *directory,\n                                                   NautilusFile           *file,\n                                                   NautilusFileAttributes  file_attributes)\n{\n    Request request;\n\n    nautilus_directory_remove_file_from_work_queue (directory, file);\n\n    request = nautilus_directory_set_up_request (file_attributes);\n\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DIRECTORY_COUNT))\n    {\n        cancel_directory_count_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_DEEP_COUNT))\n    {\n        cancel_deep_counts_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MIME_LIST))\n    {\n        cancel_mime_list_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILE_INFO))\n    {\n        cancel_file_info_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_FILESYSTEM_INFO))\n    {\n        cancel_filesystem_info_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_LINK_INFO))\n    {\n        cancel_link_info_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_THUMBNAIL))\n    {\n        cancel_thumbnail_for_file (directory, file);\n    }\n    if (REQUEST_WANTS_TYPE (request, REQUEST_MOUNT))\n    {\n        cancel_mount_for_file (directory, file);\n    }\n\n    nautilus_directory_async_state_changed (directory);\n}\n\nvoid\nnautilus_directory_add_file_to_work_queue (NautilusDirectory *directory,\n                                           NautilusFile      *file)\n{\n    g_return_if_fail (file->details->directory == directory);\n\n    nautilus_file_queue_enqueue (directory->details->high_priority_queue,\n                                 file);\n}\n\n\nstatic void\nadd_all_files_to_work_queue (NautilusDirectory *directory)\n{\n    GList *node;\n    NautilusFile *file;\n\n    for (node = directory->details->file_list; node != NULL; node = node->next)\n    {\n        file = NAUTILUS_FILE (node->data);\n\n        nautilus_directory_add_file_to_work_queue (directory, file);\n    }\n}\n\nvoid\nnautilus_directory_remove_file_from_work_queue (NautilusDirectory *directory,\n                                                NautilusFile      *file)\n{\n    nautilus_file_queue_remove (directory->details->high_priority_queue,\n                                file);\n    nautilus_file_queue_remove (directory->details->low_priority_queue,\n                                file);\n    nautilus_file_queue_remove (directory->details->extension_queue,\n                                file);\n}\n\n\nstatic void\nmove_file_to_low_priority_queue (NautilusDirectory *directory,\n                                 NautilusFile      *file)\n{\n    /* Must add before removing to avoid ref underflow */\n    nautilus_file_queue_enqueue (directory->details->low_priority_queue,\n                                 file);\n    nautilus_file_queue_remove (directory->details->high_priority_queue,\n                                file);\n}\n\nstatic void\nmove_file_to_extension_queue (NautilusDirectory *directory,\n                              NautilusFile      *file)\n{\n    /* Must add before removing to avoid ref underflow */\n    nautilus_file_queue_enqueue (directory->details->extension_queue,\n                                 file);\n    nautilus_file_queue_remove (directory->details->low_priority_queue,\n                                file);\n}\n", "/* nautilus-file-operations.c - Nautilus file operations.\n *\n *  Copyright (C) 1999, 2000 Free Software Foundation\n *  Copyright (C) 2000, 2001 Eazel, Inc.\n *  Copyright (C) 2007 Red Hat, Inc.\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public\n *  License along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n *  Authors: Alexander Larsson <alexl@redhat.com>\n *           Ettore Perazzoli <ettore@gnu.org>\n *           Pavel Cisler <pavel@eazel.com>\n */\n\n#include <config.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <math.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\n#include \"nautilus-file-operations.h\"\n\n#include \"nautilus-file-changes-queue.h\"\n#include \"nautilus-lib-self-check-functions.h\"\n\n#include \"nautilus-progress-info.h\"\n\n#include <eel/eel-glib-extensions.h>\n#include <eel/eel-gtk-extensions.h>\n#include <eel/eel-stock-dialogs.h>\n#include <eel/eel-vfs-extensions.h>\n\n#include <glib/gi18n.h>\n#include <glib/gstdio.h>\n#include <gdk/gdk.h>\n#include <gtk/gtk.h>\n#include <gio/gio.h>\n#include <glib.h>\n\n#include \"nautilus-operations-ui-manager.h\"\n#include \"nautilus-file-changes-queue.h\"\n#include \"nautilus-file-private.h\"\n#include \"nautilus-global-preferences.h\"\n#include \"nautilus-link.h\"\n#include \"nautilus-trash-monitor.h\"\n#include \"nautilus-file-utilities.h\"\n#include \"nautilus-file-undo-operations.h\"\n#include \"nautilus-file-undo-manager.h\"\n\n/* TODO: TESTING!!! */\n\ntypedef struct\n{\n    GTimer *time;\n    GtkWindow *parent_window;\n    int screen_num;\n    guint inhibit_cookie;\n    NautilusProgressInfo *progress;\n    GCancellable *cancellable;\n    GHashTable *skip_files;\n    GHashTable *skip_readdir_error;\n    NautilusFileUndoInfo *undo_info;\n    gboolean skip_all_error;\n    gboolean skip_all_conflict;\n    gboolean merge_all;\n    gboolean replace_all;\n    gboolean delete_all;\n} CommonJob;\n\ntypedef struct\n{\n    CommonJob common;\n    gboolean is_move;\n    GList *files;\n    GFile *destination;\n    GFile *desktop_location;\n    GFile *fake_display_source;\n    GdkPoint *icon_positions;\n    int n_icon_positions;\n    GHashTable *debuting_files;\n    gchar *target_name;\n    NautilusCopyCallback done_callback;\n    gpointer done_callback_data;\n} CopyMoveJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GList *files;\n    gboolean try_trash;\n    gboolean user_cancel;\n    NautilusDeleteCallback done_callback;\n    gpointer done_callback_data;\n} DeleteJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GFile *dest_dir;\n    char *filename;\n    gboolean make_dir;\n    GFile *src;\n    char *src_data;\n    int length;\n    GdkPoint position;\n    gboolean has_position;\n    GFile *created_file;\n    NautilusCreateCallback done_callback;\n    gpointer done_callback_data;\n} CreateJob;\n\n\ntypedef struct\n{\n    CommonJob common;\n    GList *trash_dirs;\n    gboolean should_confirm;\n    NautilusOpCallback done_callback;\n    gpointer done_callback_data;\n} EmptyTrashJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GFile *file;\n    gboolean interactive;\n    NautilusOpCallback done_callback;\n    gpointer done_callback_data;\n} MarkTrustedJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GFile *file;\n    NautilusOpCallback done_callback;\n    gpointer done_callback_data;\n    guint32 file_permissions;\n    guint32 file_mask;\n    guint32 dir_permissions;\n    guint32 dir_mask;\n} SetPermissionsJob;\n\ntypedef enum\n{\n    OP_KIND_COPY,\n    OP_KIND_MOVE,\n    OP_KIND_DELETE,\n    OP_KIND_TRASH,\n    OP_KIND_COMPRESS\n} OpKind;\n\ntypedef struct\n{\n    int num_files;\n    goffset num_bytes;\n    int num_files_since_progress;\n    OpKind op;\n} SourceInfo;\n\ntypedef struct\n{\n    int num_files;\n    goffset num_bytes;\n    OpKind op;\n    guint64 last_report_time;\n    int last_reported_files_left;\n} TransferInfo;\n\ntypedef struct\n{\n    CommonJob common;\n    GList *source_files;\n    GFile *destination_directory;\n    GList *output_files;\n\n    gdouble base_progress;\n\n    guint64 archive_compressed_size;\n    guint64 total_compressed_size;\n\n    NautilusExtractCallback done_callback;\n    gpointer done_callback_data;\n} ExtractJob;\n\ntypedef struct\n{\n    CommonJob common;\n    GList *source_files;\n    GFile *output_file;\n\n    AutoarFormat format;\n    AutoarFilter filter;\n\n    guint64 total_size;\n    guint total_files;\n\n    gboolean success;\n\n    NautilusCreateCallback done_callback;\n    gpointer done_callback_data;\n} CompressJob;\n\n#define SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE 8\n#define NSEC_PER_MICROSEC 1000\n#define PROGRESS_NOTIFY_INTERVAL 100 * NSEC_PER_MICROSEC\n\n#define MAXIMUM_DISPLAYED_FILE_NAME_LENGTH 50\n\n#define IS_IO_ERROR(__error, KIND) (((__error)->domain == G_IO_ERROR && (__error)->code == G_IO_ERROR_ ## KIND))\n\n#define CANCEL _(\"_Cancel\")\n#define SKIP _(\"_Skip\")\n#define SKIP_ALL _(\"S_kip All\")\n#define RETRY _(\"_Retry\")\n#define DELETE _(\"_Delete\")\n#define DELETE_ALL _(\"Delete _All\")\n#define REPLACE _(\"_Replace\")\n#define REPLACE_ALL _(\"Replace _All\")\n#define MERGE _(\"_Merge\")\n#define MERGE_ALL _(\"Merge _All\")\n#define COPY_FORCE _(\"Copy _Anyway\")\n\nstatic void\nmark_desktop_file_executable (CommonJob    *common,\n                              GCancellable *cancellable,\n                              GFile        *file,\n                              gboolean      interactive);\n\nstatic gboolean\nis_all_button_text (const char *button_text)\n{\n    g_assert (button_text != NULL);\n\n    return !strcmp (button_text, SKIP_ALL) ||\n           !strcmp (button_text, REPLACE_ALL) ||\n           !strcmp (button_text, DELETE_ALL) ||\n           !strcmp (button_text, MERGE_ALL);\n}\n\nstatic void scan_sources (GList      *files,\n                          SourceInfo *source_info,\n                          CommonJob  *job,\n                          OpKind      kind);\n\n\nstatic void empty_trash_thread_func (GTask        *task,\n                                     gpointer      source_object,\n                                     gpointer      task_data,\n                                     GCancellable *cancellable);\n\nstatic void empty_trash_task_done (GObject      *source_object,\n                                   GAsyncResult *res,\n                                   gpointer      user_data);\n\nstatic char *query_fs_type (GFile        *file,\n                            GCancellable *cancellable);\n\n/* keep in time with format_time()\n *\n * This counts and outputs the number of \u201ctime units\u201d\n * formatted and displayed by format_time().\n * For instance, if format_time outputs \u201c3 hours, 4 minutes\u201d\n * it yields 7.\n */\nstatic int\nseconds_count_format_time_units (int seconds)\n{\n    int minutes;\n    int hours;\n\n    if (seconds < 0)\n    {\n        /* Just to make sure... */\n        seconds = 0;\n    }\n\n    if (seconds < 60)\n    {\n        /* seconds */\n        return seconds;\n    }\n\n    if (seconds < 60 * 60)\n    {\n        /* minutes */\n        minutes = seconds / 60;\n        return minutes;\n    }\n\n    hours = seconds / (60 * 60);\n\n    if (seconds < 60 * 60 * 4)\n    {\n        /* minutes + hours */\n        minutes = (seconds - hours * 60 * 60) / 60;\n        return minutes + hours;\n    }\n\n    return hours;\n}\n\nstatic char *\nformat_time (int seconds)\n{\n    int minutes;\n    int hours;\n    char *res;\n\n    if (seconds < 0)\n    {\n        /* Just to make sure... */\n        seconds = 0;\n    }\n\n    if (seconds < 60)\n    {\n        return g_strdup_printf (ngettext (\"%'d second\", \"%'d seconds\", (int) seconds), (int) seconds);\n    }\n\n    if (seconds < 60 * 60)\n    {\n        minutes = seconds / 60;\n        return g_strdup_printf (ngettext (\"%'d minute\", \"%'d minutes\", minutes), minutes);\n    }\n\n    hours = seconds / (60 * 60);\n\n    if (seconds < 60 * 60 * 4)\n    {\n        char *h, *m;\n\n        minutes = (seconds - hours * 60 * 60) / 60;\n\n        h = g_strdup_printf (ngettext (\"%'d hour\", \"%'d hours\", hours), hours);\n        m = g_strdup_printf (ngettext (\"%'d minute\", \"%'d minutes\", minutes), minutes);\n        res = g_strconcat (h, \", \", m, NULL);\n        g_free (h);\n        g_free (m);\n        return res;\n    }\n\n    return g_strdup_printf (ngettext (\"approximately %'d hour\",\n                                      \"approximately %'d hours\",\n                                      hours), hours);\n}\n\nstatic char *\nshorten_utf8_string (const char *base,\n                     int         reduce_by_num_bytes)\n{\n    int len;\n    char *ret;\n    const char *p;\n\n    len = strlen (base);\n    len -= reduce_by_num_bytes;\n\n    if (len <= 0)\n    {\n        return NULL;\n    }\n\n    ret = g_new (char, len + 1);\n\n    p = base;\n    while (len)\n    {\n        char *next;\n        next = g_utf8_next_char (p);\n        if (next - p > len || *next == '\\0')\n        {\n            break;\n        }\n\n        len -= next - p;\n        p = next;\n    }\n\n    if (p - base == 0)\n    {\n        g_free (ret);\n        return NULL;\n    }\n    else\n    {\n        memcpy (ret, base, p - base);\n        ret[p - base] = '\\0';\n        return ret;\n    }\n}\n\n/* Note that we have these two separate functions with separate format\n * strings for ease of localization.\n */\n\nstatic char *\nget_link_name (const char *name,\n               int         count,\n               int         max_length)\n{\n    const char *format;\n    char *result;\n    int unshortened_length;\n    gboolean use_count;\n\n    g_assert (name != NULL);\n\n    if (count < 0)\n    {\n        g_warning (\"bad count in get_link_name\");\n        count = 0;\n    }\n\n    if (count <= 2)\n    {\n        /* Handle special cases for low numbers.\n         * Perhaps for some locales we will need to add more.\n         */\n        switch (count)\n        {\n            default:\n            {\n                g_assert_not_reached ();\n                /* fall through */\n            }\n\n            case 0:\n            {\n                /* duplicate original file name */\n                format = \"%s\";\n            }\n            break;\n\n            case 1:\n            {\n                /* appended to new link file */\n                format = _(\"Link to %s\");\n            }\n            break;\n\n            case 2:\n            {\n                /* appended to new link file */\n                format = _(\"Another link to %s\");\n            }\n            break;\n        }\n\n        use_count = FALSE;\n    }\n    else\n    {\n        /* Handle special cases for the first few numbers of each ten.\n         * For locales where getting this exactly right is difficult,\n         * these can just be made all the same as the general case below.\n         */\n        switch (count % 10)\n        {\n            case 1:\n            {\n                /* Localizers: Feel free to leave out the \"st\" suffix\n                 * if there's no way to do that nicely for a\n                 * particular language.\n                 */\n                format = _(\"%'dst link to %s\");\n            }\n            break;\n\n            case 2:\n            {\n                /* appended to new link file */\n                format = _(\"%'dnd link to %s\");\n            }\n            break;\n\n            case 3:\n            {\n                /* appended to new link file */\n                format = _(\"%'drd link to %s\");\n            }\n            break;\n\n            default:\n            {\n                /* appended to new link file */\n                format = _(\"%'dth link to %s\");\n            }\n            break;\n        }\n\n        use_count = TRUE;\n    }\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n    if (use_count)\n    {\n        result = g_strdup_printf (format, count, name);\n    }\n    else\n    {\n        result = g_strdup_printf (format, name);\n    }\n\n    if (max_length > 0 && (unshortened_length = strlen (result)) > max_length)\n    {\n        char *new_name;\n\n        new_name = shorten_utf8_string (name, unshortened_length - max_length);\n        if (new_name)\n        {\n            g_free (result);\n\n            if (use_count)\n            {\n                result = g_strdup_printf (format, count, new_name);\n            }\n            else\n            {\n                result = g_strdup_printf (format, new_name);\n            }\n\n            g_assert (strlen (result) <= max_length);\n            g_free (new_name);\n        }\n    }\n#pragma GCC diagnostic pop\n    return result;\n}\n\n\n/* Localizers:\n * Feel free to leave out the st, nd, rd and th suffix or\n * make some or all of them match.\n */\n\n/* localizers: tag used to detect the first copy of a file */\nstatic const char untranslated_copy_duplicate_tag[] = N_(\" (copy)\");\n/* localizers: tag used to detect the second copy of a file */\nstatic const char untranslated_another_copy_duplicate_tag[] = N_(\" (another copy)\");\n\n/* localizers: tag used to detect the x11th copy of a file */\nstatic const char untranslated_x11th_copy_duplicate_tag[] = N_(\"th copy)\");\n/* localizers: tag used to detect the x12th copy of a file */\nstatic const char untranslated_x12th_copy_duplicate_tag[] = N_(\"th copy)\");\n/* localizers: tag used to detect the x13th copy of a file */\nstatic const char untranslated_x13th_copy_duplicate_tag[] = N_(\"th copy)\");\n\n/* localizers: tag used to detect the x1st copy of a file */\nstatic const char untranslated_st_copy_duplicate_tag[] = N_(\"st copy)\");\n/* localizers: tag used to detect the x2nd copy of a file */\nstatic const char untranslated_nd_copy_duplicate_tag[] = N_(\"nd copy)\");\n/* localizers: tag used to detect the x3rd copy of a file */\nstatic const char untranslated_rd_copy_duplicate_tag[] = N_(\"rd copy)\");\n\n/* localizers: tag used to detect the xxth copy of a file */\nstatic const char untranslated_th_copy_duplicate_tag[] = N_(\"th copy)\");\n\n#define COPY_DUPLICATE_TAG _(untranslated_copy_duplicate_tag)\n#define ANOTHER_COPY_DUPLICATE_TAG _(untranslated_another_copy_duplicate_tag)\n#define X11TH_COPY_DUPLICATE_TAG _(untranslated_x11th_copy_duplicate_tag)\n#define X12TH_COPY_DUPLICATE_TAG _(untranslated_x12th_copy_duplicate_tag)\n#define X13TH_COPY_DUPLICATE_TAG _(untranslated_x13th_copy_duplicate_tag)\n\n#define ST_COPY_DUPLICATE_TAG _(untranslated_st_copy_duplicate_tag)\n#define ND_COPY_DUPLICATE_TAG _(untranslated_nd_copy_duplicate_tag)\n#define RD_COPY_DUPLICATE_TAG _(untranslated_rd_copy_duplicate_tag)\n#define TH_COPY_DUPLICATE_TAG _(untranslated_th_copy_duplicate_tag)\n\n/* localizers: appended to first file copy */\nstatic const char untranslated_first_copy_duplicate_format[] = N_(\"%s (copy)%s\");\n/* localizers: appended to second file copy */\nstatic const char untranslated_second_copy_duplicate_format[] = N_(\"%s (another copy)%s\");\n\n/* localizers: appended to x11th file copy */\nstatic const char untranslated_x11th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n/* localizers: appended to x12th file copy */\nstatic const char untranslated_x12th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n/* localizers: appended to x13th file copy */\nstatic const char untranslated_x13th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n\n/* localizers: if in your language there's no difference between 1st, 2nd, 3rd and nth\n * plurals, you can leave the st, nd, rd suffixes out and just make all the translated\n * strings look like \"%s (copy %'d)%s\".\n */\n\n/* localizers: appended to x1st file copy */\nstatic const char untranslated_st_copy_duplicate_format[] = N_(\"%s (%'dst copy)%s\");\n/* localizers: appended to x2nd file copy */\nstatic const char untranslated_nd_copy_duplicate_format[] = N_(\"%s (%'dnd copy)%s\");\n/* localizers: appended to x3rd file copy */\nstatic const char untranslated_rd_copy_duplicate_format[] = N_(\"%s (%'drd copy)%s\");\n/* localizers: appended to xxth file copy */\nstatic const char untranslated_th_copy_duplicate_format[] = N_(\"%s (%'dth copy)%s\");\n\n#define FIRST_COPY_DUPLICATE_FORMAT _(untranslated_first_copy_duplicate_format)\n#define SECOND_COPY_DUPLICATE_FORMAT _(untranslated_second_copy_duplicate_format)\n#define X11TH_COPY_DUPLICATE_FORMAT _(untranslated_x11th_copy_duplicate_format)\n#define X12TH_COPY_DUPLICATE_FORMAT _(untranslated_x12th_copy_duplicate_format)\n#define X13TH_COPY_DUPLICATE_FORMAT _(untranslated_x13th_copy_duplicate_format)\n\n#define ST_COPY_DUPLICATE_FORMAT _(untranslated_st_copy_duplicate_format)\n#define ND_COPY_DUPLICATE_FORMAT _(untranslated_nd_copy_duplicate_format)\n#define RD_COPY_DUPLICATE_FORMAT _(untranslated_rd_copy_duplicate_format)\n#define TH_COPY_DUPLICATE_FORMAT _(untranslated_th_copy_duplicate_format)\n\nstatic char *\nextract_string_until (const char *original,\n                      const char *until_substring)\n{\n    char *result;\n\n    g_assert ((int) strlen (original) >= until_substring - original);\n    g_assert (until_substring - original >= 0);\n\n    result = g_malloc (until_substring - original + 1);\n    strncpy (result, original, until_substring - original);\n    result[until_substring - original] = '\\0';\n\n    return result;\n}\n\n/* Dismantle a file name, separating the base name, the file suffix and removing any\n * (xxxcopy), etc. string. Figure out the count that corresponds to the given\n * (xxxcopy) substring.\n */\nstatic void\nparse_previous_duplicate_name (const char  *name,\n                               char       **name_base,\n                               const char **suffix,\n                               int         *count)\n{\n    const char *tag;\n\n    g_assert (name[0] != '\\0');\n\n    *suffix = eel_filename_get_extension_offset (name);\n\n    if (*suffix == NULL || (*suffix)[1] == '\\0')\n    {\n        /* no suffix */\n        *suffix = \"\";\n    }\n\n    tag = strstr (name, COPY_DUPLICATE_TAG);\n    if (tag != NULL)\n    {\n        if (tag > *suffix)\n        {\n            /* handle case \"foo. (copy)\" */\n            *suffix = \"\";\n        }\n        *name_base = extract_string_until (name, tag);\n        *count = 1;\n        return;\n    }\n\n\n    tag = strstr (name, ANOTHER_COPY_DUPLICATE_TAG);\n    if (tag != NULL)\n    {\n        if (tag > *suffix)\n        {\n            /* handle case \"foo. (another copy)\" */\n            *suffix = \"\";\n        }\n        *name_base = extract_string_until (name, tag);\n        *count = 2;\n        return;\n    }\n\n\n    /* Check to see if we got one of st, nd, rd, th. */\n    tag = strstr (name, X11TH_COPY_DUPLICATE_TAG);\n\n    if (tag == NULL)\n    {\n        tag = strstr (name, X12TH_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, X13TH_COPY_DUPLICATE_TAG);\n    }\n\n    if (tag == NULL)\n    {\n        tag = strstr (name, ST_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, ND_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, RD_COPY_DUPLICATE_TAG);\n    }\n    if (tag == NULL)\n    {\n        tag = strstr (name, TH_COPY_DUPLICATE_TAG);\n    }\n\n    /* If we got one of st, nd, rd, th, fish out the duplicate number. */\n    if (tag != NULL)\n    {\n        /* localizers: opening parentheses to match the \"th copy)\" string */\n        tag = strstr (name, _(\" (\"));\n        if (tag != NULL)\n        {\n            if (tag > *suffix)\n            {\n                /* handle case \"foo. (22nd copy)\" */\n                *suffix = \"\";\n            }\n            *name_base = extract_string_until (name, tag);\n            /* localizers: opening parentheses of the \"th copy)\" string */\n            if (sscanf (tag, _(\" (%'d\"), count) == 1)\n            {\n                if (*count < 1 || *count > 1000000)\n                {\n                    /* keep the count within a reasonable range */\n                    *count = 0;\n                }\n                return;\n            }\n            *count = 0;\n            return;\n        }\n    }\n\n\n    *count = 0;\n    if (**suffix != '\\0')\n    {\n        *name_base = extract_string_until (name, *suffix);\n    }\n    else\n    {\n        *name_base = g_strdup (name);\n    }\n}\n\nstatic char *\nmake_next_duplicate_name (const char *base,\n                          const char *suffix,\n                          int         count,\n                          int         max_length)\n{\n    const char *format;\n    char *result;\n    int unshortened_length;\n    gboolean use_count;\n\n    if (count < 1)\n    {\n        g_warning (\"bad count %d in get_duplicate_name\", count);\n        count = 1;\n    }\n\n    if (count <= 2)\n    {\n        /* Handle special cases for low numbers.\n         * Perhaps for some locales we will need to add more.\n         */\n        switch (count)\n        {\n            default:\n            {\n                g_assert_not_reached ();\n                /* fall through */\n            }\n\n            case 1:\n            {\n                format = FIRST_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            case 2:\n            {\n                format = SECOND_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n        }\n\n        use_count = FALSE;\n    }\n    else\n    {\n        /* Handle special cases for the first few numbers of each ten.\n         * For locales where getting this exactly right is difficult,\n         * these can just be made all the same as the general case below.\n         */\n\n        /* Handle special cases for x11th - x20th.\n         */\n        switch (count % 100)\n        {\n            case 11:\n            {\n                format = X11TH_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            case 12:\n            {\n                format = X12TH_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            case 13:\n            {\n                format = X13TH_COPY_DUPLICATE_FORMAT;\n            }\n            break;\n\n            default:\n            {\n                format = NULL;\n            }\n            break;\n        }\n\n        if (format == NULL)\n        {\n            switch (count % 10)\n            {\n                case 1:\n                {\n                    format = ST_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n\n                case 2:\n                {\n                    format = ND_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n\n                case 3:\n                {\n                    format = RD_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n\n                default:\n                {\n                    /* The general case. */\n                    format = TH_COPY_DUPLICATE_FORMAT;\n                }\n                break;\n            }\n        }\n\n        use_count = TRUE;\n    }\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n    if (use_count)\n    {\n        result = g_strdup_printf (format, base, count, suffix);\n    }\n    else\n    {\n        result = g_strdup_printf (format, base, suffix);\n    }\n\n    if (max_length > 0 && (unshortened_length = strlen (result)) > max_length)\n    {\n        char *new_base;\n\n        new_base = shorten_utf8_string (base, unshortened_length - max_length);\n        if (new_base)\n        {\n            g_free (result);\n\n            if (use_count)\n            {\n                result = g_strdup_printf (format, new_base, count, suffix);\n            }\n            else\n            {\n                result = g_strdup_printf (format, new_base, suffix);\n            }\n\n            g_assert (strlen (result) <= max_length);\n            g_free (new_base);\n        }\n    }\n#pragma GCC diagnostic pop\n\n    return result;\n}\n\nstatic char *\nget_duplicate_name (const char *name,\n                    int         count_increment,\n                    int         max_length)\n{\n    char *result;\n    char *name_base;\n    const char *suffix;\n    int count;\n\n    parse_previous_duplicate_name (name, &name_base, &suffix, &count);\n    result = make_next_duplicate_name (name_base, suffix, count + count_increment, max_length);\n\n    g_free (name_base);\n\n    return result;\n}\n\nstatic gboolean\nhas_invalid_xml_char (char *str)\n{\n    gunichar c;\n\n    while (*str != 0)\n    {\n        c = g_utf8_get_char (str);\n        /* characters XML permits */\n        if (!(c == 0x9 ||\n              c == 0xA ||\n              c == 0xD ||\n              (c >= 0x20 && c <= 0xD7FF) ||\n              (c >= 0xE000 && c <= 0xFFFD) ||\n              (c >= 0x10000 && c <= 0x10FFFF)))\n        {\n            return TRUE;\n        }\n        str = g_utf8_next_char (str);\n    }\n    return FALSE;\n}\n\n\nstatic char *\ncustom_full_name_to_string (char    *format,\n                            va_list  va)\n{\n    GFile *file;\n\n    file = va_arg (va, GFile *);\n\n    return g_file_get_parse_name (file);\n}\n\nstatic void\ncustom_full_name_skip (va_list *va)\n{\n    (void) va_arg (*va, GFile *);\n}\n\nstatic char *\ncustom_basename_to_string (char    *format,\n                           va_list  va)\n{\n    GFile *file;\n    GFileInfo *info;\n    char *name, *basename, *tmp;\n    GMount *mount;\n\n    file = va_arg (va, GFile *);\n\n    if ((mount = nautilus_get_mounted_mount_for_root (file)) != NULL)\n    {\n        name = g_mount_get_name (mount);\n        g_object_unref (mount);\n    }\n    else\n    {\n        info = g_file_query_info (file,\n                                  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                  0,\n                                  g_cancellable_get_current (),\n                                  NULL);\n        name = NULL;\n        if (info)\n        {\n            name = g_strdup (g_file_info_get_display_name (info));\n            g_object_unref (info);\n        }\n    }\n\n    if (name == NULL)\n    {\n        basename = g_file_get_basename (file);\n        if (g_utf8_validate (basename, -1, NULL))\n        {\n            name = basename;\n        }\n        else\n        {\n            name = g_uri_escape_string (basename, G_URI_RESERVED_CHARS_ALLOWED_IN_PATH, TRUE);\n            g_free (basename);\n        }\n    }\n\n    /* Some chars can't be put in the markup we use for the dialogs... */\n    if (has_invalid_xml_char (name))\n    {\n        tmp = name;\n        name = g_uri_escape_string (name, G_URI_RESERVED_CHARS_ALLOWED_IN_PATH, TRUE);\n        g_free (tmp);\n    }\n\n    /* Finally, if the string is too long, truncate it. */\n    if (name != NULL)\n    {\n        tmp = name;\n        name = eel_str_middle_truncate (tmp, MAXIMUM_DISPLAYED_FILE_NAME_LENGTH);\n        g_free (tmp);\n    }\n\n\n    return name;\n}\n\nstatic void\ncustom_basename_skip (va_list *va)\n{\n    (void) va_arg (*va, GFile *);\n}\n\n\nstatic char *\ncustom_size_to_string (char    *format,\n                       va_list  va)\n{\n    goffset size;\n\n    size = va_arg (va, goffset);\n    return g_format_size (size);\n}\n\nstatic void\ncustom_size_skip (va_list *va)\n{\n    (void) va_arg (*va, goffset);\n}\n\nstatic char *\ncustom_time_to_string (char    *format,\n                       va_list  va)\n{\n    int secs;\n\n    secs = va_arg (va, int);\n    return format_time (secs);\n}\n\nstatic void\ncustom_time_skip (va_list *va)\n{\n    (void) va_arg (*va, int);\n}\n\nstatic char *\ncustom_mount_to_string (char    *format,\n                        va_list  va)\n{\n    GMount *mount;\n\n    mount = va_arg (va, GMount *);\n    return g_mount_get_name (mount);\n}\n\nstatic void\ncustom_mount_skip (va_list *va)\n{\n    (void) va_arg (*va, GMount *);\n}\n\n\nstatic EelPrintfHandler handlers[] =\n{\n    { 'F', custom_full_name_to_string, custom_full_name_skip },\n    { 'B', custom_basename_to_string, custom_basename_skip },\n    { 'S', custom_size_to_string, custom_size_skip },\n    { 'T', custom_time_to_string, custom_time_skip },\n    { 'V', custom_mount_to_string, custom_mount_skip },\n    { 0 }\n};\n\n\nstatic char *\nf (const char *format,\n   ...)\n{\n    va_list va;\n    char *res;\n\n    va_start (va, format);\n    res = eel_strdup_vprintf_with_custom (handlers, format, va);\n    va_end (va);\n\n    return res;\n}\n\n#define op_job_new(__type, parent_window) ((__type *) (init_common (sizeof (__type), parent_window)))\n\nstatic gpointer\ninit_common (gsize      job_size,\n             GtkWindow *parent_window)\n{\n    CommonJob *common;\n    GdkScreen *screen;\n\n    common = g_malloc0 (job_size);\n\n    if (parent_window)\n    {\n        common->parent_window = parent_window;\n        g_object_add_weak_pointer (G_OBJECT (common->parent_window),\n                                   (gpointer *) &common->parent_window);\n    }\n    common->progress = nautilus_progress_info_new ();\n    common->cancellable = nautilus_progress_info_get_cancellable (common->progress);\n    common->time = g_timer_new ();\n    common->inhibit_cookie = 0;\n    common->screen_num = 0;\n    if (parent_window)\n    {\n        screen = gtk_widget_get_screen (GTK_WIDGET (parent_window));\n        common->screen_num = gdk_screen_get_number (screen);\n    }\n\n    return common;\n}\n\nstatic void\nfinalize_common (CommonJob *common)\n{\n    nautilus_progress_info_finish (common->progress);\n\n    if (common->inhibit_cookie != 0)\n    {\n        gtk_application_uninhibit (GTK_APPLICATION (g_application_get_default ()),\n                                   common->inhibit_cookie);\n    }\n\n    common->inhibit_cookie = 0;\n    g_timer_destroy (common->time);\n\n    if (common->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (common->parent_window),\n                                      (gpointer *) &common->parent_window);\n    }\n\n    if (common->skip_files)\n    {\n        g_hash_table_destroy (common->skip_files);\n    }\n    if (common->skip_readdir_error)\n    {\n        g_hash_table_destroy (common->skip_readdir_error);\n    }\n\n    if (common->undo_info != NULL)\n    {\n        nautilus_file_undo_manager_set_action (common->undo_info);\n        g_object_unref (common->undo_info);\n    }\n\n    g_object_unref (common->progress);\n    g_object_unref (common->cancellable);\n    g_free (common);\n}\n\nstatic void\nskip_file (CommonJob *common,\n           GFile     *file)\n{\n    if (common->skip_files == NULL)\n    {\n        common->skip_files =\n            g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n    }\n\n    g_hash_table_insert (common->skip_files, g_object_ref (file), file);\n}\n\nstatic void\nskip_readdir_error (CommonJob *common,\n                    GFile     *dir)\n{\n    if (common->skip_readdir_error == NULL)\n    {\n        common->skip_readdir_error =\n            g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n    }\n\n    g_hash_table_insert (common->skip_readdir_error, g_object_ref (dir), dir);\n}\n\nstatic gboolean\nshould_skip_file (CommonJob *common,\n                  GFile     *file)\n{\n    if (common->skip_files != NULL)\n    {\n        return g_hash_table_lookup (common->skip_files, file) != NULL;\n    }\n    return FALSE;\n}\n\nstatic gboolean\nshould_skip_readdir_error (CommonJob *common,\n                           GFile     *dir)\n{\n    if (common->skip_readdir_error != NULL)\n    {\n        return g_hash_table_lookup (common->skip_readdir_error, dir) != NULL;\n    }\n    return FALSE;\n}\n\nstatic gboolean\ncan_delete_without_confirm (GFile *file)\n{\n    if (g_file_has_uri_scheme (file, \"burn\") ||\n        g_file_has_uri_scheme (file, \"recent\") ||\n        g_file_has_uri_scheme (file, \"x-nautilus-desktop\"))\n    {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\nstatic gboolean\ncan_delete_files_without_confirm (GList *files)\n{\n    g_assert (files != NULL);\n\n    while (files != NULL)\n    {\n        if (!can_delete_without_confirm (files->data))\n        {\n            return FALSE;\n        }\n\n        files = files->next;\n    }\n\n    return TRUE;\n}\n\ntypedef struct\n{\n    GtkWindow **parent_window;\n    gboolean ignore_close_box;\n    GtkMessageType message_type;\n    const char *primary_text;\n    const char *secondary_text;\n    const char *details_text;\n    const char **button_titles;\n    gboolean show_all;\n    int result;\n    /* Dialogs are ran from operation threads, which need to be blocked until\n     * the user gives a valid response\n     */\n    gboolean completed;\n    GMutex mutex;\n    GCond cond;\n} RunSimpleDialogData;\n\nstatic gboolean\ndo_run_simple_dialog (gpointer _data)\n{\n    RunSimpleDialogData *data = _data;\n    const char *button_title;\n    GtkWidget *dialog;\n    int result;\n    int response_id;\n\n    g_mutex_lock (&data->mutex);\n\n    /* Create the dialog. */\n    dialog = gtk_message_dialog_new (*data->parent_window,\n                                     0,\n                                     data->message_type,\n                                     GTK_BUTTONS_NONE,\n                                     NULL);\n\n    g_object_set (dialog,\n                  \"text\", data->primary_text,\n                  \"secondary-text\", data->secondary_text,\n                  NULL);\n\n    for (response_id = 0;\n         data->button_titles[response_id] != NULL;\n         response_id++)\n    {\n        button_title = data->button_titles[response_id];\n        if (!data->show_all && is_all_button_text (button_title))\n        {\n            continue;\n        }\n\n        gtk_dialog_add_button (GTK_DIALOG (dialog), button_title, response_id);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), response_id);\n    }\n\n    if (data->details_text)\n    {\n        eel_gtk_message_dialog_set_details_label (GTK_MESSAGE_DIALOG (dialog),\n                                                  data->details_text);\n    }\n\n    /* Run it. */\n    result = gtk_dialog_run (GTK_DIALOG (dialog));\n\n    while ((result == GTK_RESPONSE_NONE || result == GTK_RESPONSE_DELETE_EVENT) && data->ignore_close_box)\n    {\n        result = gtk_dialog_run (GTK_DIALOG (dialog));\n    }\n\n    gtk_widget_destroy (dialog);\n\n    data->result = result;\n    data->completed = TRUE;\n\n    g_cond_signal (&data->cond);\n    g_mutex_unlock (&data->mutex);\n\n    return FALSE;\n}\n\n/* NOTE: This frees the primary / secondary strings, in order to\n *  avoid doing that everywhere. So, make sure they are strduped */\n\nstatic int\nrun_simple_dialog_va (CommonJob      *job,\n                      gboolean        ignore_close_box,\n                      GtkMessageType  message_type,\n                      char           *primary_text,\n                      char           *secondary_text,\n                      const char     *details_text,\n                      gboolean        show_all,\n                      va_list         varargs)\n{\n    RunSimpleDialogData *data;\n    int res;\n    const char *button_title;\n    GPtrArray *ptr_array;\n\n    g_timer_stop (job->time);\n\n    data = g_new0 (RunSimpleDialogData, 1);\n    data->parent_window = &job->parent_window;\n    data->ignore_close_box = ignore_close_box;\n    data->message_type = message_type;\n    data->primary_text = primary_text;\n    data->secondary_text = secondary_text;\n    data->details_text = details_text;\n    data->show_all = show_all;\n    data->completed = FALSE;\n    g_mutex_init (&data->mutex);\n    g_cond_init (&data->cond);\n\n    ptr_array = g_ptr_array_new ();\n    while ((button_title = va_arg (varargs, const char *)) != NULL)\n    {\n        g_ptr_array_add (ptr_array, (char *) button_title);\n    }\n    g_ptr_array_add (ptr_array, NULL);\n    data->button_titles = (const char **) g_ptr_array_free (ptr_array, FALSE);\n\n    nautilus_progress_info_pause (job->progress);\n\n    g_mutex_lock (&data->mutex);\n\n    g_main_context_invoke (NULL,\n                           do_run_simple_dialog,\n                           data);\n\n    while (!data->completed)\n    {\n        g_cond_wait (&data->cond, &data->mutex);\n    }\n\n    nautilus_progress_info_resume (job->progress);\n    res = data->result;\n\n    g_mutex_unlock (&data->mutex);\n    g_mutex_clear (&data->mutex);\n    g_cond_clear (&data->cond);\n\n    g_free (data->button_titles);\n    g_free (data);\n\n    g_timer_continue (job->time);\n\n    g_free (primary_text);\n    g_free (secondary_text);\n\n    return res;\n}\n\n#if 0 /* Not used at the moment */\nstatic int\nrun_simple_dialog (CommonJob     *job,\n                   gboolean       ignore_close_box,\n                   GtkMessageType message_type,\n                   char          *primary_text,\n                   char          *secondary_text,\n                   const char    *details_text,\n                   ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, details_text);\n    res = run_simple_dialog_va (job,\n                                ignore_close_box,\n                                message_type,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n#endif\n\nstatic int\nrun_error (CommonJob  *job,\n           char       *primary_text,\n           char       *secondary_text,\n           const char *details_text,\n           gboolean    show_all,\n           ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, show_all);\n    res = run_simple_dialog_va (job,\n                                FALSE,\n                                GTK_MESSAGE_ERROR,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                show_all,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n\nstatic int\nrun_warning (CommonJob  *job,\n             char       *primary_text,\n             char       *secondary_text,\n             const char *details_text,\n             gboolean    show_all,\n             ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, show_all);\n    res = run_simple_dialog_va (job,\n                                FALSE,\n                                GTK_MESSAGE_WARNING,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                show_all,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n\nstatic int\nrun_question (CommonJob  *job,\n              char       *primary_text,\n              char       *secondary_text,\n              const char *details_text,\n              gboolean    show_all,\n              ...)\n{\n    va_list varargs;\n    int res;\n\n    va_start (varargs, show_all);\n    res = run_simple_dialog_va (job,\n                                FALSE,\n                                GTK_MESSAGE_QUESTION,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                show_all,\n                                varargs);\n    va_end (varargs);\n    return res;\n}\n\nstatic int\nrun_cancel_or_skip_warning (CommonJob  *job,\n                            char       *primary_text,\n                            char       *secondary_text,\n                            const char *details_text,\n                            int         total_operations,\n                            int         operations_remaining)\n{\n    int response;\n\n    if (total_operations == 1)\n    {\n        response = run_warning (job,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                FALSE,\n                                CANCEL,\n                                NULL);\n    }\n    else\n    {\n        response = run_warning (job,\n                                primary_text,\n                                secondary_text,\n                                details_text,\n                                operations_remaining > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n    }\n\n    return response;\n}\n\nstatic void\ninhibit_power_manager (CommonJob  *job,\n                       const char *message)\n{\n    job->inhibit_cookie = gtk_application_inhibit (GTK_APPLICATION (g_application_get_default ()),\n                                                   GTK_WINDOW (job->parent_window),\n                                                   GTK_APPLICATION_INHIBIT_LOGOUT |\n                                                   GTK_APPLICATION_INHIBIT_SUSPEND,\n                                                   message);\n}\n\nstatic void\nabort_job (CommonJob *job)\n{\n    /* destroy the undo action data too */\n    g_clear_object (&job->undo_info);\n\n    g_cancellable_cancel (job->cancellable);\n}\n\nstatic gboolean\njob_aborted (CommonJob *job)\n{\n    return g_cancellable_is_cancelled (job->cancellable);\n}\n\n/* Since this happens on a thread we can't use the global prefs object */\nstatic gboolean\nshould_confirm_trash (void)\n{\n    GSettings *prefs;\n    gboolean confirm_trash;\n\n    prefs = g_settings_new (\"org.gnome.nautilus.preferences\");\n    confirm_trash = g_settings_get_boolean (prefs, NAUTILUS_PREFERENCES_CONFIRM_TRASH);\n    g_object_unref (prefs);\n    return confirm_trash;\n}\n\nstatic gboolean\nconfirm_delete_from_trash (CommonJob *job,\n                           GList     *files)\n{\n    char *prompt;\n    int file_count;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    file_count = g_list_length (files);\n    g_assert (file_count > 0);\n\n    if (file_count == 1)\n    {\n        prompt = f (_(\"Are you sure you want to permanently delete \u201c%B\u201d \"\n                      \"from the trash?\"), files->data);\n    }\n    else\n    {\n        prompt = f (ngettext (\"Are you sure you want to permanently delete \"\n                              \"the %'d selected item from the trash?\",\n                              \"Are you sure you want to permanently delete \"\n                              \"the %'d selected items from the trash?\",\n                              file_count),\n                    file_count);\n    }\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"If you delete an item, it will be permanently lost.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, DELETE,\n                            NULL);\n\n    return (response == 1);\n}\n\nstatic gboolean\nconfirm_empty_trash (CommonJob *job)\n{\n    char *prompt;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    prompt = f (_(\"Empty all items from Trash?\"));\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"All items in the Trash will be permanently deleted.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, _(\"Empty _Trash\"),\n                            NULL);\n\n    return (response == 1);\n}\n\nstatic gboolean\nconfirm_delete_directly (CommonJob *job,\n                         GList     *files)\n{\n    char *prompt;\n    int file_count;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    file_count = g_list_length (files);\n    g_assert (file_count > 0);\n\n    if (can_delete_files_without_confirm (files))\n    {\n        return TRUE;\n    }\n\n    if (file_count == 1)\n    {\n        prompt = f (_(\"Are you sure you want to permanently delete \u201c%B\u201d?\"),\n                    files->data);\n    }\n    else\n    {\n        prompt = f (ngettext (\"Are you sure you want to permanently delete \"\n                              \"the %'d selected item?\",\n                              \"Are you sure you want to permanently delete \"\n                              \"the %'d selected items?\", file_count),\n                    file_count);\n    }\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"If you delete an item, it will be permanently lost.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, DELETE,\n                            NULL);\n\n    return response == 1;\n}\n\nstatic void\nreport_delete_progress (CommonJob    *job,\n                        SourceInfo   *source_info,\n                        TransferInfo *transfer_info)\n{\n    int files_left;\n    double elapsed, transfer_rate;\n    int remaining_time;\n    gint64 now;\n    char *details;\n    char *status;\n    DeleteJob *delete_job;\n\n    delete_job = (DeleteJob *) job;\n    now = g_get_monotonic_time ();\n    files_left = source_info->num_files - transfer_info->num_files;\n\n    /* Races and whatnot could cause this to be negative... */\n    if (files_left < 0)\n    {\n        files_left = 0;\n    }\n\n    /* If the number of files left is 0, we want to update the status without\n     * considering this time, since we want to change the status to completed\n     * and probably we won't get more calls to this function */\n    if (transfer_info->last_report_time != 0 &&\n        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&\n        files_left > 0)\n    {\n        return;\n    }\n\n    transfer_info->last_report_time = now;\n\n    if (source_info->num_files == 1)\n    {\n        if (files_left == 0)\n        {\n            status = _(\"Deleted \u201c%B\u201d\");\n        }\n        else\n        {\n            status = _(\"Deleting \u201c%B\u201d\");\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               (GFile *) delete_job->files->data));\n    }\n    else\n    {\n        if (files_left == 0)\n        {\n            status = ngettext (\"Deleted %'d file\",\n                               \"Deleted %'d files\",\n                               source_info->num_files);\n        }\n        else\n        {\n            status = ngettext (\"Deleting %'d file\",\n                               \"Deleting %'d files\",\n                               source_info->num_files);\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               source_info->num_files));\n    }\n\n    elapsed = g_timer_elapsed (job->time, NULL);\n    transfer_rate = 0;\n    remaining_time = INT_MAX;\n    if (elapsed > 0)\n    {\n        transfer_rate = transfer_info->num_files / elapsed;\n        if (transfer_rate > 0)\n        {\n            remaining_time = (source_info->num_files - transfer_info->num_files) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE)\n    {\n        if (files_left > 0)\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files + 1,\n                         source_info->num_files);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    else\n    {\n        if (files_left > 0)\n        {\n            gchar *time_left_message;\n            gchar *files_per_second_message;\n            gchar *concat_detail;\n\n            /* To translators: %T will expand to a time duration like \"2 minutes\".\n             * So the whole thing will be something like \"1 / 5 -- 2 hours left (4 files/sec)\"\n             *\n             * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n             */\n            time_left_message = ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          \"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          seconds_count_format_time_units (remaining_time));\n            transfer_rate += 0.5;\n            files_per_second_message = ngettext (\"(%d file/sec)\",\n                                                 \"(%d files/sec)\",\n                                                 (int) transfer_rate);\n            concat_detail = g_strconcat (time_left_message, \" \", files_per_second_message, NULL);\n\n            details = f (concat_detail,\n                         transfer_info->num_files + 1, source_info->num_files,\n                         remaining_time,\n                         (int) transfer_rate);\n\n            g_free (concat_detail);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    nautilus_progress_info_take_details (job->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (job->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (job->progress,\n                                                 elapsed);\n    }\n\n    if (source_info->num_files != 0)\n    {\n        nautilus_progress_info_set_progress (job->progress, transfer_info->num_files, source_info->num_files);\n    }\n}\n\ntypedef void (*DeleteCallback) (GFile   *file,\n                                GError  *error,\n                                gpointer callback_data);\n\nstatic gboolean\ndelete_file_recursively (GFile          *file,\n                         GCancellable   *cancellable,\n                         DeleteCallback  callback,\n                         gpointer        callback_data)\n{\n    gboolean success;\n    g_autoptr (GError) error = NULL;\n\n    do\n    {\n        g_autoptr (GFileEnumerator) enumerator = NULL;\n\n        success = g_file_delete (file, cancellable, &error);\n        if (success ||\n            !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n            break;\n        }\n\n        g_clear_error (&error);\n\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                                G_FILE_QUERY_INFO_NONE,\n                                                cancellable, &error);\n\n        if (enumerator)\n        {\n            GFileInfo *info;\n\n            success = TRUE;\n\n            info = g_file_enumerator_next_file (enumerator,\n                                                cancellable,\n                                                &error);\n\n            while (info != NULL)\n            {\n                g_autoptr (GFile) child = NULL;\n\n                child = g_file_enumerator_get_child (enumerator, info);\n\n                success = success && delete_file_recursively (child,\n                                                              cancellable,\n                                                              callback,\n                                                              callback_data);\n\n                g_object_unref (info);\n\n                info = g_file_enumerator_next_file (enumerator,\n                                                    cancellable,\n                                                    &error);\n            }\n        }\n\n        if (error != NULL)\n        {\n            success = FALSE;\n        }\n    }\n    while (success);\n\n    if (callback)\n    {\n        callback (file, error, callback_data);\n    }\n\n    return success;\n}\n\ntypedef struct\n{\n    CommonJob *job;\n    SourceInfo *source_info;\n    TransferInfo *transfer_info;\n} DeleteData;\n\nstatic void\nfile_deleted_callback (GFile    *file,\n                       GError   *error,\n                       gpointer  callback_data)\n{\n    DeleteData *data = callback_data;\n    CommonJob *job;\n    SourceInfo *source_info;\n    TransferInfo *transfer_info;\n    GFileType file_type;\n    char *primary;\n    char *secondary;\n    char *details = NULL;\n    int response;\n\n    job = data->job;\n    source_info = data->source_info;\n    transfer_info = data->transfer_info;\n\n    data->transfer_info->num_files++;\n\n    if (error == NULL)\n    {\n        nautilus_file_changes_queue_file_removed (file);\n        report_delete_progress (data->job, data->source_info, data->transfer_info);\n\n        return;\n    }\n\n    if (job_aborted (job) ||\n        job->skip_all_error ||\n        should_skip_file (job, file) ||\n        should_skip_readdir_error (job, file))\n    {\n        return;\n    }\n\n    primary = f (_(\"Error while deleting.\"));\n\n    file_type = g_file_query_file_type (file,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        job->cancellable);\n\n    if (file_type == G_FILE_TYPE_DIRECTORY)\n    {\n        secondary = IS_IO_ERROR (error, PERMISSION_DENIED) ?\n                    f (_(\"There was an error deleting the folder \u201c%B\u201d.\"),\n                       file) :\n                    f (_(\"You do not have sufficient permissions to delete the folder \u201c%B\u201d.\"),\n                       file);\n    }\n    else\n    {\n        secondary = IS_IO_ERROR (error, PERMISSION_DENIED) ?\n                    f (_(\"There was an error deleting the file \u201c%B\u201d.\"),\n                       file) :\n                    f (_(\"You do not have sufficient permissions to delete the file \u201c%B\u201d.\"),\n                       file);\n    }\n\n    details = error->message;\n\n    response = run_cancel_or_skip_warning (job,\n                                           primary,\n                                           secondary,\n                                           details,\n                                           source_info->num_files,\n                                           source_info->num_files - transfer_info->num_files);\n\n    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n    {\n        abort_job (job);\n    }\n    else if (response == 1)\n    {\n        /* skip all */\n        job->skip_all_error = TRUE;\n    }\n}\n\nstatic void\ndelete_files (CommonJob *job,\n              GList     *files,\n              int       *files_skipped)\n{\n    GList *l;\n    GFile *file;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    DeleteData data;\n\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    scan_sources (files,\n                  &source_info,\n                  job,\n                  OP_KIND_DELETE);\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    g_timer_start (job->time);\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    report_delete_progress (job, &source_info, &transfer_info);\n\n    data.job = job;\n    data.source_info = &source_info;\n    data.transfer_info = &transfer_info;\n\n    for (l = files;\n         l != NULL && !job_aborted (job);\n         l = l->next)\n    {\n        gboolean success;\n\n        file = l->data;\n\n        if (should_skip_file (job, file))\n        {\n            (*files_skipped)++;\n            continue;\n        }\n\n        success = delete_file_recursively (file, job->cancellable,\n                                           file_deleted_callback,\n                                           &data);\n\n        if (!success)\n        {\n            (*files_skipped)++;\n        }\n    }\n}\n\nstatic void\nreport_trash_progress (CommonJob    *job,\n                       SourceInfo   *source_info,\n                       TransferInfo *transfer_info)\n{\n    int files_left;\n    double elapsed, transfer_rate;\n    int remaining_time;\n    gint64 now;\n    char *details;\n    char *status;\n    DeleteJob *delete_job;\n\n    delete_job = (DeleteJob *) job;\n    now = g_get_monotonic_time ();\n    files_left = source_info->num_files - transfer_info->num_files;\n\n    /* Races and whatnot could cause this to be negative... */\n    if (files_left < 0)\n    {\n        files_left = 0;\n    }\n\n    /* If the number of files left is 0, we want to update the status without\n     * considering this time, since we want to change the status to completed\n     * and probably we won't get more calls to this function */\n    if (transfer_info->last_report_time != 0 &&\n        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&\n        files_left > 0)\n    {\n        return;\n    }\n\n    transfer_info->last_report_time = now;\n\n    if (source_info->num_files == 1)\n    {\n        if (files_left > 0)\n        {\n            status = _(\"Trashing \u201c%B\u201d\");\n        }\n        else\n        {\n            status = _(\"Trashed \u201c%B\u201d\");\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               (GFile *) delete_job->files->data));\n    }\n    else\n    {\n        if (files_left > 0)\n        {\n            status = ngettext (\"Trashing %'d file\",\n                               \"Trashing %'d files\",\n                               source_info->num_files);\n        }\n        else\n        {\n            status = ngettext (\"Trashed %'d file\",\n                               \"Trashed %'d files\",\n                               source_info->num_files);\n        }\n        nautilus_progress_info_take_status (job->progress,\n                                            f (status,\n                                               source_info->num_files));\n    }\n\n\n    elapsed = g_timer_elapsed (job->time, NULL);\n    transfer_rate = 0;\n    remaining_time = INT_MAX;\n    if (elapsed > 0)\n    {\n        transfer_rate = transfer_info->num_files / elapsed;\n        if (transfer_rate > 0)\n        {\n            remaining_time = (source_info->num_files - transfer_info->num_files) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE)\n    {\n        if (files_left > 0)\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files + 1,\n                         source_info->num_files);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    else\n    {\n        if (files_left > 0)\n        {\n            gchar *time_left_message;\n            gchar *files_per_second_message;\n            gchar *concat_detail;\n\n            /* To translators: %T will expand to a time duration like \"2 minutes\".\n             * So the whole thing will be something like \"1 / 5 -- 2 hours left (4 files/sec)\"\n             *\n             * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n             */\n            time_left_message = ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          \"%'d / %'d \\xE2\\x80\\x94 %T left\",\n                                          seconds_count_format_time_units (remaining_time));\n            files_per_second_message = ngettext (\"(%d file/sec)\",\n                                                 \"(%d files/sec)\",\n                                                 (int) (transfer_rate + 0.5));\n            concat_detail = g_strconcat (time_left_message, \" \", files_per_second_message, NULL);\n\n            details = f (concat_detail,\n                         transfer_info->num_files + 1, source_info->num_files,\n                         remaining_time,\n                         (int) transfer_rate + 0.5);\n\n            g_free (concat_detail);\n        }\n        else\n        {\n            /* To translators: %'d is the number of files completed for the operation,\n             * so it will be something like 2/14. */\n            details = f (_(\"%'d / %'d\"),\n                         transfer_info->num_files,\n                         source_info->num_files);\n        }\n    }\n    nautilus_progress_info_set_details (job->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (job->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (job->progress,\n                                                 elapsed);\n    }\n\n    if (source_info->num_files != 0)\n    {\n        nautilus_progress_info_set_progress (job->progress, transfer_info->num_files, source_info->num_files);\n    }\n}\n\nstatic void\ntrash_file (CommonJob     *job,\n            GFile         *file,\n            gboolean      *skipped_file,\n            SourceInfo    *source_info,\n            TransferInfo  *transfer_info,\n            gboolean       toplevel,\n            GList        **to_delete)\n{\n    GError *error;\n    char *primary, *secondary, *details;\n    int response;\n\n    if (should_skip_file (job, file))\n    {\n        *skipped_file = TRUE;\n        return;\n    }\n\n    error = NULL;\n\n    if (g_file_trash (file, job->cancellable, &error))\n    {\n        transfer_info->num_files++;\n        nautilus_file_changes_queue_file_removed (file);\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_trash_add_file (NAUTILUS_FILE_UNDO_INFO_TRASH (job->undo_info), file);\n        }\n\n        report_trash_progress (job, source_info, transfer_info);\n        return;\n    }\n\n    if (job->skip_all_error)\n    {\n        *skipped_file = TRUE;\n        goto skip;\n    }\n\n    if (job->delete_all)\n    {\n        *to_delete = g_list_prepend (*to_delete, file);\n        goto skip;\n    }\n\n    /* Translators: %B is a file name */\n    primary = f (_(\"\u201c%B\u201d can\u2019t be put in the trash. Do you want to delete it immediately?\"), file);\n    details = NULL;\n    secondary = NULL;\n    if (!IS_IO_ERROR (error, NOT_SUPPORTED))\n    {\n        details = error->message;\n    }\n    else if (!g_file_is_native (file))\n    {\n        secondary = f (_(\"This remote location does not support sending items to the trash.\"));\n    }\n\n    response = run_question (job,\n                             primary,\n                             secondary,\n                             details,\n                             (source_info->num_files - transfer_info->num_files) > 1,\n                             CANCEL, SKIP_ALL, SKIP, DELETE_ALL, DELETE,\n                             NULL);\n\n    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n    {\n        ((DeleteJob *) job)->user_cancel = TRUE;\n        abort_job (job);\n    }\n    else if (response == 1)         /* skip all */\n    {\n        *skipped_file = TRUE;\n        job->skip_all_error = TRUE;\n    }\n    else if (response == 2)         /* skip */\n    {\n        *skipped_file = TRUE;\n        job->skip_all_error = TRUE;\n    }\n    else if (response == 3)         /* delete all */\n    {\n        *to_delete = g_list_prepend (*to_delete, file);\n        job->delete_all = TRUE;\n    }\n    else if (response == 4)         /* delete */\n    {\n        *to_delete = g_list_prepend (*to_delete, file);\n    }\n\nskip:\n    g_error_free (error);\n}\n\nstatic void\ntransfer_add_file_to_count (GFile        *file,\n                            CommonJob    *job,\n                            TransferInfo *transfer_info)\n{\n    g_autoptr (GFileInfo) file_info = NULL;\n\n    if (g_cancellable_is_cancelled (job->cancellable))\n    {\n        return;\n    }\n\n    file_info = g_file_query_info (file,\n                                   G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                   G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                   job->cancellable,\n                                   NULL);\n\n    transfer_info->num_files++;\n    if (file_info != NULL)\n    {\n        transfer_info->num_bytes += g_file_info_get_size (file_info);\n    }\n}\n\nstatic void\ntrash_files (CommonJob *job,\n             GList     *files,\n             int       *files_skipped)\n{\n    GList *l;\n    GFile *file;\n    GList *to_delete;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    gboolean skipped_file;\n\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    scan_sources (files,\n                  &source_info,\n                  job,\n                  OP_KIND_TRASH);\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    g_timer_start (job->time);\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    report_trash_progress (job, &source_info, &transfer_info);\n\n    to_delete = NULL;\n    for (l = files;\n         l != NULL && !job_aborted (job);\n         l = l->next)\n    {\n        file = l->data;\n\n        skipped_file = FALSE;\n        trash_file (job, file,\n                    &skipped_file,\n                    &source_info, &transfer_info,\n                    TRUE, &to_delete);\n        if (skipped_file)\n        {\n            (*files_skipped)++;\n            transfer_add_file_to_count (file, job, &transfer_info);\n            report_trash_progress (job, &source_info, &transfer_info);\n        }\n    }\n\n    if (to_delete)\n    {\n        to_delete = g_list_reverse (to_delete);\n        delete_files (job, to_delete, files_skipped);\n        g_list_free (to_delete);\n    }\n}\n\nstatic void\ndelete_task_done (GObject      *source_object,\n                  GAsyncResult *res,\n                  gpointer      user_data)\n{\n    DeleteJob *job;\n    GHashTable *debuting_uris;\n\n    job = user_data;\n\n    g_list_free_full (job->files, g_object_unref);\n\n    if (job->done_callback)\n    {\n        debuting_uris = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n        job->done_callback (debuting_uris, job->user_cancel, job->done_callback_data);\n        g_hash_table_unref (debuting_uris);\n    }\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ndelete_task_thread_func (GTask        *task,\n                         gpointer      source_object,\n                         gpointer      task_data,\n                         GCancellable *cancellable)\n{\n    DeleteJob *job = task_data;\n    GList *to_trash_files;\n    GList *to_delete_files;\n    GList *l;\n    GFile *file;\n    gboolean confirmed;\n    CommonJob *common;\n    gboolean must_confirm_delete_in_trash;\n    gboolean must_confirm_delete;\n    int files_skipped;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    to_trash_files = NULL;\n    to_delete_files = NULL;\n\n    must_confirm_delete_in_trash = FALSE;\n    must_confirm_delete = FALSE;\n    files_skipped = 0;\n\n    for (l = job->files; l != NULL; l = l->next)\n    {\n        file = l->data;\n\n        if (job->try_trash &&\n            g_file_has_uri_scheme (file, \"trash\"))\n        {\n            must_confirm_delete_in_trash = TRUE;\n            to_delete_files = g_list_prepend (to_delete_files, file);\n        }\n        else if (can_delete_without_confirm (file))\n        {\n            to_delete_files = g_list_prepend (to_delete_files, file);\n        }\n        else\n        {\n            if (job->try_trash)\n            {\n                to_trash_files = g_list_prepend (to_trash_files, file);\n            }\n            else\n            {\n                must_confirm_delete = TRUE;\n                to_delete_files = g_list_prepend (to_delete_files, file);\n            }\n        }\n    }\n\n    if (to_delete_files != NULL)\n    {\n        to_delete_files = g_list_reverse (to_delete_files);\n        confirmed = TRUE;\n        if (must_confirm_delete_in_trash)\n        {\n            confirmed = confirm_delete_from_trash (common, to_delete_files);\n        }\n        else if (must_confirm_delete)\n        {\n            confirmed = confirm_delete_directly (common, to_delete_files);\n        }\n        if (confirmed)\n        {\n            delete_files (common, to_delete_files, &files_skipped);\n        }\n        else\n        {\n            job->user_cancel = TRUE;\n        }\n    }\n\n    if (to_trash_files != NULL)\n    {\n        to_trash_files = g_list_reverse (to_trash_files);\n\n        trash_files (common, to_trash_files, &files_skipped);\n    }\n\n    g_list_free (to_trash_files);\n    g_list_free (to_delete_files);\n\n    if (files_skipped == g_list_length (job->files))\n    {\n        /* User has skipped all files, report user cancel */\n        job->user_cancel = TRUE;\n    }\n}\n\nstatic void\ntrash_or_delete_internal (GList                  *files,\n                          GtkWindow              *parent_window,\n                          gboolean                try_trash,\n                          NautilusDeleteCallback  done_callback,\n                          gpointer                done_callback_data)\n{\n    GTask *task;\n    DeleteJob *job;\n\n    /* TODO: special case desktop icon link files ... */\n\n    job = op_job_new (DeleteJob, parent_window);\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->try_trash = try_trash;\n    job->user_cancel = FALSE;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n\n    if (try_trash)\n    {\n        inhibit_power_manager ((CommonJob *) job, _(\"Trashing Files\"));\n    }\n    else\n    {\n        inhibit_power_manager ((CommonJob *) job, _(\"Deleting Files\"));\n    }\n\n    if (!nautilus_file_undo_manager_is_operating () && try_trash)\n    {\n        job->common.undo_info = nautilus_file_undo_info_trash_new (g_list_length (files));\n    }\n\n    task = g_task_new (NULL, NULL, delete_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, delete_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_trash_or_delete (GList                  *files,\n                                          GtkWindow              *parent_window,\n                                          NautilusDeleteCallback  done_callback,\n                                          gpointer                done_callback_data)\n{\n    trash_or_delete_internal (files, parent_window,\n                              TRUE,\n                              done_callback, done_callback_data);\n}\n\nvoid\nnautilus_file_operations_delete (GList                  *files,\n                                 GtkWindow              *parent_window,\n                                 NautilusDeleteCallback  done_callback,\n                                 gpointer                done_callback_data)\n{\n    trash_or_delete_internal (files, parent_window,\n                              FALSE,\n                              done_callback, done_callback_data);\n}\n\n\n\ntypedef struct\n{\n    gboolean eject;\n    GMount *mount;\n    GMountOperation *mount_operation;\n    GtkWindow *parent_window;\n    NautilusUnmountCallback callback;\n    gpointer callback_data;\n} UnmountData;\n\nstatic void\nunmount_data_free (UnmountData *data)\n{\n    if (data->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (data->parent_window),\n                                      (gpointer *) &data->parent_window);\n    }\n\n    g_clear_object (&data->mount_operation);\n    g_object_unref (data->mount);\n    g_free (data);\n}\n\nstatic void\nunmount_mount_callback (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    UnmountData *data = user_data;\n    GError *error;\n    char *primary;\n    gboolean unmounted;\n\n    error = NULL;\n    if (data->eject)\n    {\n        unmounted = g_mount_eject_with_operation_finish (G_MOUNT (source_object),\n                                                         res, &error);\n    }\n    else\n    {\n        unmounted = g_mount_unmount_with_operation_finish (G_MOUNT (source_object),\n                                                           res, &error);\n    }\n\n    if (!unmounted)\n    {\n        if (error->code != G_IO_ERROR_FAILED_HANDLED)\n        {\n            if (data->eject)\n            {\n                primary = f (_(\"Unable to eject %V\"), source_object);\n            }\n            else\n            {\n                primary = f (_(\"Unable to unmount %V\"), source_object);\n            }\n            eel_show_error_dialog (primary,\n                                   error->message,\n                                   data->parent_window);\n            g_free (primary);\n        }\n    }\n\n    if (data->callback)\n    {\n        data->callback (data->callback_data);\n    }\n\n    if (error != NULL)\n    {\n        g_error_free (error);\n    }\n\n    unmount_data_free (data);\n}\n\nstatic void\ndo_unmount (UnmountData *data)\n{\n    GMountOperation *mount_op;\n\n    if (data->mount_operation)\n    {\n        mount_op = g_object_ref (data->mount_operation);\n    }\n    else\n    {\n        mount_op = gtk_mount_operation_new (data->parent_window);\n    }\n    if (data->eject)\n    {\n        g_mount_eject_with_operation (data->mount,\n                                      0,\n                                      mount_op,\n                                      NULL,\n                                      unmount_mount_callback,\n                                      data);\n    }\n    else\n    {\n        g_mount_unmount_with_operation (data->mount,\n                                        0,\n                                        mount_op,\n                                        NULL,\n                                        unmount_mount_callback,\n                                        data);\n    }\n    g_object_unref (mount_op);\n}\n\nstatic gboolean\ndir_has_files (GFile *dir)\n{\n    GFileEnumerator *enumerator;\n    gboolean res;\n    GFileInfo *file_info;\n\n    res = FALSE;\n\n    enumerator = g_file_enumerate_children (dir,\n                                            G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                            0,\n                                            NULL, NULL);\n    if (enumerator)\n    {\n        file_info = g_file_enumerator_next_file (enumerator, NULL, NULL);\n        if (file_info != NULL)\n        {\n            res = TRUE;\n            g_object_unref (file_info);\n        }\n\n        g_file_enumerator_close (enumerator, NULL, NULL);\n        g_object_unref (enumerator);\n    }\n\n\n    return res;\n}\n\nstatic GList *\nget_trash_dirs_for_mount (GMount *mount)\n{\n    GFile *root;\n    GFile *trash;\n    char *relpath;\n    GList *list;\n\n    root = g_mount_get_root (mount);\n    if (root == NULL)\n    {\n        return NULL;\n    }\n\n    list = NULL;\n\n    if (g_file_is_native (root))\n    {\n        relpath = g_strdup_printf (\".Trash/%d\", getuid ());\n        trash = g_file_resolve_relative_path (root, relpath);\n        g_free (relpath);\n\n        list = g_list_prepend (list, g_file_get_child (trash, \"files\"));\n        list = g_list_prepend (list, g_file_get_child (trash, \"info\"));\n\n        g_object_unref (trash);\n\n        relpath = g_strdup_printf (\".Trash-%d\", getuid ());\n        trash = g_file_get_child (root, relpath);\n        g_free (relpath);\n\n        list = g_list_prepend (list, g_file_get_child (trash, \"files\"));\n        list = g_list_prepend (list, g_file_get_child (trash, \"info\"));\n\n        g_object_unref (trash);\n    }\n\n    g_object_unref (root);\n\n    return list;\n}\n\nstatic gboolean\nhas_trash_files (GMount *mount)\n{\n    GList *dirs, *l;\n    GFile *dir;\n    gboolean res;\n\n    dirs = get_trash_dirs_for_mount (mount);\n\n    res = FALSE;\n\n    for (l = dirs; l != NULL; l = l->next)\n    {\n        dir = l->data;\n\n        if (dir_has_files (dir))\n        {\n            res = TRUE;\n            break;\n        }\n    }\n\n    g_list_free_full (dirs, g_object_unref);\n\n    return res;\n}\n\n\nstatic gint\nprompt_empty_trash (GtkWindow *parent_window)\n{\n    gint result;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n\n    screen = NULL;\n    if (parent_window != NULL)\n    {\n        screen = gtk_widget_get_screen (GTK_WIDGET (parent_window));\n    }\n\n    /* Do we need to be modal ? */\n    dialog = gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL,\n                                     GTK_MESSAGE_QUESTION, GTK_BUTTONS_NONE,\n                                     _(\"Do you want to empty the trash before you unmount?\"));\n    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                              _(\"In order to regain the \"\n                                                \"free space on this volume \"\n                                                \"the trash must be emptied. \"\n                                                \"All trashed items on the volume \"\n                                                \"will be permanently lost.\"));\n    gtk_dialog_add_buttons (GTK_DIALOG (dialog),\n                            _(\"Do _not Empty Trash\"), GTK_RESPONSE_REJECT,\n                            CANCEL, GTK_RESPONSE_CANCEL,\n                            _(\"Empty _Trash\"), GTK_RESPONSE_ACCEPT, NULL);\n    gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_ACCEPT);\n    gtk_window_set_title (GTK_WINDOW (dialog), \"\");     /* as per HIG */\n    gtk_window_set_skip_taskbar_hint (GTK_WINDOW (dialog), TRUE);\n    if (screen)\n    {\n        gtk_window_set_screen (GTK_WINDOW (dialog), screen);\n    }\n    atk_object_set_role (gtk_widget_get_accessible (dialog), ATK_ROLE_ALERT);\n    gtk_window_set_wmclass (GTK_WINDOW (dialog), \"empty_trash\",\n                            \"Nautilus\");\n\n    /* Make transient for the window group */\n    gtk_widget_realize (dialog);\n    if (screen != NULL)\n    {\n        gdk_window_set_transient_for (gtk_widget_get_window (GTK_WIDGET (dialog)),\n                                      gdk_screen_get_root_window (screen));\n    }\n\n    result = gtk_dialog_run (GTK_DIALOG (dialog));\n    gtk_widget_destroy (dialog);\n    return result;\n}\n\nstatic void\nempty_trash_for_unmount_done (gboolean success,\n                              gpointer user_data)\n{\n    UnmountData *data = user_data;\n    do_unmount (data);\n}\n\nvoid\nnautilus_file_operations_unmount_mount_full (GtkWindow               *parent_window,\n                                             GMount                  *mount,\n                                             GMountOperation         *mount_operation,\n                                             gboolean                 eject,\n                                             gboolean                 check_trash,\n                                             NautilusUnmountCallback  callback,\n                                             gpointer                 callback_data)\n{\n    UnmountData *data;\n    int response;\n\n    data = g_new0 (UnmountData, 1);\n    data->callback = callback;\n    data->callback_data = callback_data;\n    if (parent_window)\n    {\n        data->parent_window = parent_window;\n        g_object_add_weak_pointer (G_OBJECT (data->parent_window),\n                                   (gpointer *) &data->parent_window);\n    }\n    if (mount_operation)\n    {\n        data->mount_operation = g_object_ref (mount_operation);\n    }\n    data->eject = eject;\n    data->mount = g_object_ref (mount);\n\n    if (check_trash && has_trash_files (mount))\n    {\n        response = prompt_empty_trash (parent_window);\n\n        if (response == GTK_RESPONSE_ACCEPT)\n        {\n            GTask *task;\n            EmptyTrashJob *job;\n\n            job = op_job_new (EmptyTrashJob, parent_window);\n            job->should_confirm = FALSE;\n            job->trash_dirs = get_trash_dirs_for_mount (mount);\n            job->done_callback = empty_trash_for_unmount_done;\n            job->done_callback_data = data;\n\n            task = g_task_new (NULL, NULL, empty_trash_task_done, job);\n            g_task_set_task_data (task, job, NULL);\n            g_task_run_in_thread (task, empty_trash_thread_func);\n            g_object_unref (task);\n            return;\n        }\n        else if (response == GTK_RESPONSE_CANCEL)\n        {\n            if (callback)\n            {\n                callback (callback_data);\n            }\n\n            unmount_data_free (data);\n            return;\n        }\n    }\n\n    do_unmount (data);\n}\n\nvoid\nnautilus_file_operations_unmount_mount (GtkWindow *parent_window,\n                                        GMount    *mount,\n                                        gboolean   eject,\n                                        gboolean   check_trash)\n{\n    nautilus_file_operations_unmount_mount_full (parent_window, mount, NULL, eject,\n                                                 check_trash, NULL, NULL);\n}\n\nstatic void\nmount_callback_data_notify (gpointer  data,\n                            GObject  *object)\n{\n    GMountOperation *mount_op;\n\n    mount_op = G_MOUNT_OPERATION (data);\n    g_object_set_data (G_OBJECT (mount_op), \"mount-callback\", NULL);\n    g_object_set_data (G_OBJECT (mount_op), \"mount-callback-data\", NULL);\n}\n\nstatic void\nvolume_mount_cb (GObject      *source_object,\n                 GAsyncResult *res,\n                 gpointer      user_data)\n{\n    NautilusMountCallback mount_callback;\n    GObject *mount_callback_data_object;\n    GMountOperation *mount_op = user_data;\n    GError *error;\n    char *primary;\n    char *name;\n    gboolean success;\n\n    success = TRUE;\n    error = NULL;\n    if (!g_volume_mount_finish (G_VOLUME (source_object), res, &error))\n    {\n        if (error->code != G_IO_ERROR_FAILED_HANDLED &&\n            error->code != G_IO_ERROR_ALREADY_MOUNTED)\n        {\n            GtkWindow *parent;\n\n            parent = gtk_mount_operation_get_parent (GTK_MOUNT_OPERATION (mount_op));\n            name = g_volume_get_name (G_VOLUME (source_object));\n            primary = g_strdup_printf (_(\"Unable to access \u201c%s\u201d\"), name);\n            g_free (name);\n            success = FALSE;\n            eel_show_error_dialog (primary,\n                                   error->message,\n                                   parent);\n            g_free (primary);\n        }\n        g_error_free (error);\n    }\n\n    mount_callback = (NautilusMountCallback)\n                     g_object_get_data (G_OBJECT (mount_op), \"mount-callback\");\n    mount_callback_data_object =\n        g_object_get_data (G_OBJECT (mount_op), \"mount-callback-data\");\n\n    if (mount_callback != NULL)\n    {\n        (*mount_callback)(G_VOLUME (source_object),\n                          success,\n                          mount_callback_data_object);\n\n        if (mount_callback_data_object != NULL)\n        {\n            g_object_weak_unref (mount_callback_data_object,\n                                 mount_callback_data_notify,\n                                 mount_op);\n        }\n    }\n\n    g_object_unref (mount_op);\n}\n\n\nvoid\nnautilus_file_operations_mount_volume (GtkWindow *parent_window,\n                                       GVolume   *volume)\n{\n    nautilus_file_operations_mount_volume_full (parent_window, volume,\n                                                NULL, NULL);\n}\n\nvoid\nnautilus_file_operations_mount_volume_full (GtkWindow             *parent_window,\n                                            GVolume               *volume,\n                                            NautilusMountCallback  mount_callback,\n                                            GObject               *mount_callback_data_object)\n{\n    GMountOperation *mount_op;\n\n    mount_op = gtk_mount_operation_new (parent_window);\n    g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);\n    g_object_set_data (G_OBJECT (mount_op),\n                       \"mount-callback\",\n                       mount_callback);\n\n    if (mount_callback != NULL &&\n        mount_callback_data_object != NULL)\n    {\n        g_object_weak_ref (mount_callback_data_object,\n                           mount_callback_data_notify,\n                           mount_op);\n    }\n    g_object_set_data (G_OBJECT (mount_op),\n                       \"mount-callback-data\",\n                       mount_callback_data_object);\n\n    g_volume_mount (volume, 0, mount_op, NULL, volume_mount_cb, mount_op);\n}\n\nstatic void\nreport_preparing_count_progress (CommonJob  *job,\n                                 SourceInfo *source_info)\n{\n    char *s;\n\n    switch (source_info->op)\n    {\n        default:\n        case OP_KIND_COPY:\n        {\n            s = f (ngettext (\"Preparing to copy %'d file (%S)\",\n                             \"Preparing to copy %'d files (%S)\",\n                             source_info->num_files),\n                   source_info->num_files, source_info->num_bytes);\n        }\n        break;\n\n        case OP_KIND_MOVE:\n        {\n            s = f (ngettext (\"Preparing to move %'d file (%S)\",\n                             \"Preparing to move %'d files (%S)\",\n                             source_info->num_files),\n                   source_info->num_files, source_info->num_bytes);\n        }\n        break;\n\n        case OP_KIND_DELETE:\n        {\n            s = f (ngettext (\"Preparing to delete %'d file (%S)\",\n                             \"Preparing to delete %'d files (%S)\",\n                             source_info->num_files),\n                   source_info->num_files, source_info->num_bytes);\n        }\n        break;\n\n        case OP_KIND_TRASH:\n        {\n            s = f (ngettext (\"Preparing to trash %'d file\",\n                             \"Preparing to trash %'d files\",\n                             source_info->num_files),\n                   source_info->num_files);\n        }\n        break;\n\n        case OP_KIND_COMPRESS:\n            s = f (ngettext (\"Preparing to compress %'d file\",\n                             \"Preparing to compress %'d files\",\n                             source_info->num_files),\n                   source_info->num_files);\n    }\n\n    nautilus_progress_info_take_details (job->progress, s);\n    nautilus_progress_info_pulse_progress (job->progress);\n}\n\nstatic void\ncount_file (GFileInfo  *info,\n            CommonJob  *job,\n            SourceInfo *source_info)\n{\n    source_info->num_files += 1;\n    source_info->num_bytes += g_file_info_get_size (info);\n\n    if (source_info->num_files_since_progress++ > 100)\n    {\n        report_preparing_count_progress (job, source_info);\n        source_info->num_files_since_progress = 0;\n    }\n}\n\nstatic char *\nget_scan_primary (OpKind kind)\n{\n    switch (kind)\n    {\n        default:\n        case OP_KIND_COPY:\n        {\n            return f (_(\"Error while copying.\"));\n        }\n\n        case OP_KIND_MOVE:\n        {\n            return f (_(\"Error while moving.\"));\n        }\n\n        case OP_KIND_DELETE:\n        {\n            return f (_(\"Error while deleting.\"));\n        }\n\n        case OP_KIND_TRASH:\n        {\n            return f (_(\"Error while moving files to trash.\"));\n        }\n\n        case OP_KIND_COMPRESS:\n            return f (_(\"Error while compressing files.\"));\n    }\n}\n\nstatic void\nscan_dir (GFile      *dir,\n          SourceInfo *source_info,\n          CommonJob  *job,\n          GQueue     *dirs,\n          GHashTable *scanned)\n{\n    GFileInfo *info;\n    GError *error;\n    GFile *subdir;\n    GFileEnumerator *enumerator;\n    char *primary, *secondary, *details;\n    int response;\n    SourceInfo saved_info;\n\n    saved_info = *source_info;\n\nretry:\n    error = NULL;\n    enumerator = g_file_enumerate_children (dir,\n                                            G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                            job->cancellable,\n                                            &error);\n    if (enumerator)\n    {\n        error = NULL;\n        while ((info = g_file_enumerator_next_file (enumerator, job->cancellable, &error)) != NULL)\n        {\n            g_autoptr (GFile) file = NULL;\n            g_autofree char *file_uri = NULL;\n\n            file = g_file_enumerator_get_child (enumerator, info);\n            file_uri = g_file_get_uri (file);\n\n            if (!g_hash_table_contains (scanned, file_uri))\n            {\n                g_hash_table_add (scanned, g_strdup (file_uri));\n\n                count_file (info, job, source_info);\n\n                if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n                {\n                    subdir = g_file_get_child (dir,\n                                               g_file_info_get_name (info));\n\n                    /* Push to head, since we want depth-first */\n                    g_queue_push_head (dirs, subdir);\n                }\n            }\n            g_object_unref (info);\n        }\n        g_file_enumerator_close (enumerator, job->cancellable, NULL);\n        g_object_unref (enumerator);\n\n        if (error && IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n        }\n        else if (error)\n        {\n            primary = get_scan_primary (source_info->op);\n            details = NULL;\n\n            if (IS_IO_ERROR (error, PERMISSION_DENIED))\n            {\n                secondary = f (_(\"Files in the folder \u201c%B\u201d cannot be handled because you do \"\n                                 \"not have permissions to see them.\"), dir);\n            }\n            else\n            {\n                secondary = f (_(\"There was an error getting information about the files in the folder \u201c%B\u201d.\"), dir);\n                details = error->message;\n            }\n\n            response = run_warning (job,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL, RETRY, SKIP,\n                                    NULL);\n\n            g_error_free (error);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 1)\n            {\n                *source_info = saved_info;\n                goto retry;\n            }\n            else if (response == 2)\n            {\n                skip_readdir_error (job, dir);\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n    }\n    else if (job->skip_all_error)\n    {\n        g_error_free (error);\n        skip_file (job, dir);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        primary = get_scan_primary (source_info->op);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The folder \u201c%B\u201d cannot be handled because you do not have \"\n                             \"permissions to read it.\"), dir);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error reading the folder \u201c%B\u201d.\"), dir);\n            details = error->message;\n        }\n        /* set show_all to TRUE here, as we don't know how many\n         * files we'll end up processing yet.\n         */\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                TRUE,\n                                CANCEL, SKIP_ALL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1 || response == 2)\n        {\n            if (response == 1)\n            {\n                job->skip_all_error = TRUE;\n            }\n            skip_file (job, dir);\n        }\n        else if (response == 3)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n}\n\nstatic void\nscan_file (GFile      *file,\n           SourceInfo *source_info,\n           CommonJob  *job,\n           GHashTable *scanned)\n{\n    GFileInfo *info;\n    GError *error;\n    GQueue *dirs;\n    GFile *dir;\n    char *primary;\n    char *secondary;\n    char *details;\n    int response;\n\n    dirs = g_queue_new ();\n\nretry:\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              job->cancellable,\n                              &error);\n\n    if (info)\n    {\n        g_autofree char *file_uri = NULL;\n\n        file_uri = g_file_get_uri (file);\n        if (!g_hash_table_contains (scanned, file_uri))\n        {\n            g_hash_table_add (scanned, g_strdup (file_uri));\n\n            count_file (info, job, source_info);\n\n            /* trashing operation doesn't recurse */\n            if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY &&\n                source_info->op != OP_KIND_TRASH)\n            {\n                g_queue_push_head (dirs, g_object_ref (file));\n            }\n        }\n        g_object_unref (info);\n    }\n    else if (job->skip_all_error)\n    {\n        g_error_free (error);\n        skip_file (job, file);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        primary = get_scan_primary (source_info->op);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The file \u201c%B\u201d cannot be handled because you do not have \"\n                             \"permissions to read it.\"), file);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error getting information about \u201c%B\u201d.\"), file);\n            details = error->message;\n        }\n        /* set show_all to TRUE here, as we don't know how many\n         * files we'll end up processing yet.\n         */\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                TRUE,\n                                CANCEL, SKIP_ALL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1 || response == 2)\n        {\n            if (response == 1)\n            {\n                job->skip_all_error = TRUE;\n            }\n            skip_file (job, file);\n        }\n        else if (response == 3)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\n    while (!job_aborted (job) &&\n           (dir = g_queue_pop_head (dirs)) != NULL)\n    {\n        scan_dir (dir, source_info, job, dirs, scanned);\n        g_object_unref (dir);\n    }\n\n    /* Free all from queue if we exited early */\n    g_queue_foreach (dirs, (GFunc) g_object_unref, NULL);\n    g_queue_free (dirs);\n}\n\nstatic void\nscan_sources (GList      *files,\n              SourceInfo *source_info,\n              CommonJob  *job,\n              OpKind      kind)\n{\n    GList *l;\n    GFile *file;\n    g_autoptr (GHashTable) scanned = NULL;\n\n    memset (source_info, 0, sizeof (SourceInfo));\n    source_info->op = kind;\n\n    scanned = g_hash_table_new_full (g_str_hash,\n                                     g_str_equal,\n                                     (GDestroyNotify) g_free,\n                                     NULL);\n\n    report_preparing_count_progress (job, source_info);\n\n    for (l = files; l != NULL && !job_aborted (job); l = l->next)\n    {\n        file = l->data;\n\n        scan_file (file,\n                   source_info,\n                   job,\n                   scanned);\n    }\n\n    /* Make sure we report the final count */\n    report_preparing_count_progress (job, source_info);\n}\n\nstatic void\nverify_destination (CommonJob  *job,\n                    GFile      *dest,\n                    char      **dest_fs_id,\n                    goffset     required_size)\n{\n    GFileInfo *info, *fsinfo;\n    GError *error;\n    guint64 free_size;\n    guint64 size_difference;\n    char *primary, *secondary, *details;\n    int response;\n    GFileType file_type;\n    gboolean dest_is_symlink = FALSE;\n\n    if (dest_fs_id)\n    {\n        *dest_fs_id = NULL;\n    }\n\nretry:\n\n    error = NULL;\n    info = g_file_query_info (dest,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                              dest_is_symlink ? G_FILE_QUERY_INFO_NONE : G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              job->cancellable,\n                              &error);\n\n    if (info == NULL)\n    {\n        if (IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n            return;\n        }\n\n        primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"You do not have permissions to access the destination folder.\"));\n        }\n        else\n        {\n            secondary = f (_(\"There was an error getting information about the destination.\"));\n            details = error->message;\n        }\n\n        response = run_error (job,\n                              primary,\n                              secondary,\n                              details,\n                              FALSE,\n                              CANCEL, RETRY,\n                              NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        return;\n    }\n\n    file_type = g_file_info_get_file_type (info);\n    if (!dest_is_symlink && file_type == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n        /* Record that destination is a symlink and do real stat() once again */\n        dest_is_symlink = TRUE;\n        g_object_unref (info);\n        goto retry;\n    }\n\n    if (dest_fs_id)\n    {\n        *dest_fs_id =\n            g_strdup (g_file_info_get_attribute_string (info,\n                                                        G_FILE_ATTRIBUTE_ID_FILESYSTEM));\n    }\n\n    g_object_unref (info);\n\n    if (file_type != G_FILE_TYPE_DIRECTORY)\n    {\n        primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n        secondary = f (_(\"The destination is not a folder.\"));\n\n        run_error (job,\n                   primary,\n                   secondary,\n                   NULL,\n                   FALSE,\n                   CANCEL,\n                   NULL);\n\n        abort_job (job);\n        return;\n    }\n\n    if (dest_is_symlink)\n    {\n        /* We can't reliably statfs() destination if it's a symlink, thus not doing any further checks. */\n        return;\n    }\n\n    fsinfo = g_file_query_filesystem_info (dest,\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_FREE \",\"\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_READONLY,\n                                           job->cancellable,\n                                           NULL);\n    if (fsinfo == NULL)\n    {\n        /* All sorts of things can go wrong getting the fs info (like not supported)\n         * only check these things if the fs returns them\n         */\n        return;\n    }\n\n    if (required_size > 0 &&\n        g_file_info_has_attribute (fsinfo, G_FILE_ATTRIBUTE_FILESYSTEM_FREE))\n    {\n        free_size = g_file_info_get_attribute_uint64 (fsinfo,\n                                                      G_FILE_ATTRIBUTE_FILESYSTEM_FREE);\n\n        if (free_size < required_size)\n        {\n            size_difference = required_size - free_size;\n            primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n            secondary = f (_(\"There is not enough space on the destination. Try to remove files to make space.\"));\n\n            details = f (_(\"%S more space is required to copy to the destination.\"), size_difference);\n\n            response = run_warning (job,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL,\n                                    COPY_FORCE,\n                                    RETRY,\n                                    NULL);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 2)\n            {\n                goto retry;\n            }\n            else if (response == 1)\n            {\n                /* We are forced to copy - just fall through ... */\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n    }\n\n    if (!job_aborted (job) &&\n        g_file_info_get_attribute_boolean (fsinfo,\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_READONLY))\n    {\n        primary = f (_(\"Error while copying to \u201c%B\u201d.\"), dest);\n        secondary = f (_(\"The destination is read-only.\"));\n\n        run_error (job,\n                   primary,\n                   secondary,\n                   NULL,\n                   FALSE,\n                   CANCEL,\n                   NULL);\n\n        g_error_free (error);\n\n        abort_job (job);\n    }\n\n    g_object_unref (fsinfo);\n}\n\nstatic void\nreport_copy_progress (CopyMoveJob  *copy_job,\n                      SourceInfo   *source_info,\n                      TransferInfo *transfer_info)\n{\n    int files_left;\n    goffset total_size;\n    double elapsed, transfer_rate;\n    int remaining_time;\n    guint64 now;\n    CommonJob *job;\n    gboolean is_move;\n    gchar *status;\n    char *details;\n\n    job = (CommonJob *) copy_job;\n\n    is_move = copy_job->is_move;\n\n    now = g_get_monotonic_time ();\n\n    files_left = source_info->num_files - transfer_info->num_files;\n\n    /* Races and whatnot could cause this to be negative... */\n    if (files_left < 0)\n    {\n        files_left = 0;\n    }\n\n    /* If the number of files left is 0, we want to update the status without\n     * considering this time, since we want to change the status to completed\n     * and probably we won't get more calls to this function */\n    if (transfer_info->last_report_time != 0 &&\n        ABS ((gint64) (transfer_info->last_report_time - now)) < 100 * NSEC_PER_MICROSEC &&\n        files_left > 0)\n    {\n        return;\n    }\n    transfer_info->last_report_time = now;\n\n    if (files_left != transfer_info->last_reported_files_left ||\n        transfer_info->last_reported_files_left == 0)\n    {\n        /* Avoid changing this unless files_left changed since last time */\n        transfer_info->last_reported_files_left = files_left;\n\n        if (source_info->num_files == 1)\n        {\n            if (copy_job->destination != NULL)\n            {\n                if (is_move)\n                {\n                    if (files_left > 0)\n                    {\n                        status = _(\"Moving \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                    else\n                    {\n                        status = _(\"Moved \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                }\n                else\n                {\n                    if (files_left > 0)\n                    {\n                        status = _(\"Copying \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                    else\n                    {\n                        status = _(\"Copied \u201c%B\u201d to \u201c%B\u201d\");\n                    }\n                }\n                nautilus_progress_info_take_status (job->progress,\n                                                    f (status,\n                                                       copy_job->fake_display_source != NULL ?\n                                                       copy_job->fake_display_source :\n                                                       (GFile *) copy_job->files->data,\n                                                       copy_job->destination));\n            }\n            else\n            {\n                if (files_left > 0)\n                {\n                    status = _(\"Duplicating \u201c%B\u201d\");\n                }\n                else\n                {\n                    status = _(\"Duplicated \u201c%B\u201d\");\n                }\n                nautilus_progress_info_take_status (job->progress,\n                                                    f (status,\n                                                       (GFile *) copy_job->files->data));\n            }\n        }\n        else if (copy_job->files != NULL)\n        {\n            if (copy_job->destination != NULL)\n            {\n                if (files_left > 0)\n                {\n                    if (is_move)\n                    {\n                        status = ngettext (\"Moving %'d file to \u201c%B\u201d\",\n                                           \"Moving %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    else\n                    {\n                        status = ngettext (\"Copying %'d file to \u201c%B\u201d\",\n                                           \"Copying %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           (GFile *) copy_job->destination));\n                }\n                else\n                {\n                    if (is_move)\n                    {\n                        status = ngettext (\"Moved %'d file to \u201c%B\u201d\",\n                                           \"Moved %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    else\n                    {\n                        status = ngettext (\"Copied %'d file to \u201c%B\u201d\",\n                                           \"Copied %'d files to \u201c%B\u201d\",\n                                           source_info->num_files);\n                    }\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           (GFile *) copy_job->destination));\n                }\n            }\n            else\n            {\n                GFile *parent;\n\n                parent = g_file_get_parent (copy_job->files->data);\n                if (files_left > 0)\n                {\n                    status = ngettext (\"Duplicating %'d file in \u201c%B\u201d\",\n                                       \"Duplicating %'d files in \u201c%B\u201d\",\n                                       source_info->num_files);\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           parent));\n                }\n                else\n                {\n                    status = ngettext (\"Duplicated %'d file in \u201c%B\u201d\",\n                                       \"Duplicated %'d files in \u201c%B\u201d\",\n                                       source_info->num_files);\n                    nautilus_progress_info_take_status (job->progress,\n                                                        f (status,\n                                                           source_info->num_files,\n                                                           parent));\n                }\n                g_object_unref (parent);\n            }\n        }\n    }\n\n    total_size = MAX (source_info->num_bytes, transfer_info->num_bytes);\n\n    elapsed = g_timer_elapsed (job->time, NULL);\n    transfer_rate = 0;\n    remaining_time = INT_MAX;\n    if (elapsed > 0)\n    {\n        transfer_rate = transfer_info->num_bytes / elapsed;\n        if (transfer_rate > 0)\n        {\n            remaining_time = (total_size - transfer_info->num_bytes) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE &&\n        transfer_rate > 0)\n    {\n        if (source_info->num_files == 1)\n        {\n            /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", so something like \"4 kb / 4 MB\" */\n            details = f (_(\"%S / %S\"), transfer_info->num_bytes, total_size);\n        }\n        else\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             transfer_info->num_files + 1,\n                             source_info->num_files);\n            }\n            else\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             transfer_info->num_files,\n                             source_info->num_files);\n            }\n        }\n    }\n    else\n    {\n        if (source_info->num_files == 1)\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", %T to a time duration like\n                 * \"2 minutes\". So the whole thing will be something like \"2 kb / 4 MB -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             transfer_info->num_bytes, total_size,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\". */\n                details = f (_(\"%S / %S\"),\n                             transfer_info->num_bytes,\n                             total_size);\n            }\n        }\n        else\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %T will expand to a time duration like \"2 minutes\".\n                 * So the whole thing will be something like \"1 / 5 -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             transfer_info->num_files + 1, source_info->num_files,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             transfer_info->num_files,\n                             source_info->num_files);\n            }\n        }\n    }\n    nautilus_progress_info_take_details (job->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (job->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (job->progress,\n                                                 elapsed);\n    }\n\n    nautilus_progress_info_set_progress (job->progress, transfer_info->num_bytes, total_size);\n}\n\nstatic int\nget_max_name_length (GFile *file_dir)\n{\n    int max_length;\n    char *dir;\n    long max_path;\n    long max_name;\n\n    max_length = -1;\n\n    if (!g_file_has_uri_scheme (file_dir, \"file\"))\n    {\n        return max_length;\n    }\n\n    dir = g_file_get_path (file_dir);\n    if (!dir)\n    {\n        return max_length;\n    }\n\n    max_path = pathconf (dir, _PC_PATH_MAX);\n    max_name = pathconf (dir, _PC_NAME_MAX);\n\n    if (max_name == -1 && max_path == -1)\n    {\n        max_length = -1;\n    }\n    else if (max_name == -1 && max_path != -1)\n    {\n        max_length = max_path - (strlen (dir) + 1);\n    }\n    else if (max_name != -1 && max_path == -1)\n    {\n        max_length = max_name;\n    }\n    else\n    {\n        int leftover;\n\n        leftover = max_path - (strlen (dir) + 1);\n\n        max_length = MIN (leftover, max_name);\n    }\n\n    g_free (dir);\n\n    return max_length;\n}\n\n#define FAT_FORBIDDEN_CHARACTERS \"/:;*?\\\"<>\"\n\nstatic gboolean\nfat_str_replace (char *str,\n                 char  replacement)\n{\n    gboolean success;\n    int i;\n\n    success = FALSE;\n    for (i = 0; str[i] != '\\0'; i++)\n    {\n        if (strchr (FAT_FORBIDDEN_CHARACTERS, str[i]) ||\n            str[i] < 32)\n        {\n            success = TRUE;\n            str[i] = replacement;\n        }\n    }\n\n    return success;\n}\n\nstatic gboolean\nmake_file_name_valid_for_dest_fs (char       *filename,\n                                  const char *dest_fs_type)\n{\n    if (dest_fs_type != NULL && filename != NULL)\n    {\n        if (!strcmp (dest_fs_type, \"fat\") ||\n            !strcmp (dest_fs_type, \"vfat\") ||\n            !strcmp (dest_fs_type, \"msdos\") ||\n            !strcmp (dest_fs_type, \"msdosfs\"))\n        {\n            gboolean ret;\n            int i, old_len;\n\n            ret = fat_str_replace (filename, '_');\n\n            old_len = strlen (filename);\n            for (i = 0; i < old_len; i++)\n            {\n                if (filename[i] != ' ')\n                {\n                    g_strchomp (filename);\n                    ret |= (old_len != strlen (filename));\n                    break;\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    return FALSE;\n}\n\nstatic GFile *\nget_unique_target_file (GFile      *src,\n                        GFile      *dest_dir,\n                        gboolean    same_fs,\n                        const char *dest_fs_type,\n                        int         count)\n{\n    const char *editname, *end;\n    char *basename, *new_name;\n    GFileInfo *info;\n    GFile *dest;\n    int max_length;\n\n    max_length = get_max_name_length (dest_dir);\n\n    dest = NULL;\n    info = g_file_query_info (src,\n                              G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,\n                              0, NULL, NULL);\n    if (info != NULL)\n    {\n        editname = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME);\n\n        if (editname != NULL)\n        {\n            new_name = get_duplicate_name (editname, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        g_object_unref (info);\n    }\n\n    if (dest == NULL)\n    {\n        basename = g_file_get_basename (src);\n\n        if (g_utf8_validate (basename, -1, NULL))\n        {\n            new_name = get_duplicate_name (basename, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        if (dest == NULL)\n        {\n            end = strrchr (basename, '.');\n            if (end != NULL)\n            {\n                count += atoi (end + 1);\n            }\n            new_name = g_strdup_printf (\"%s.%d\", basename, count);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child (dest_dir, new_name);\n            g_free (new_name);\n        }\n\n        g_free (basename);\n    }\n\n    return dest;\n}\n\nstatic GFile *\nget_target_file_for_link (GFile      *src,\n                          GFile      *dest_dir,\n                          const char *dest_fs_type,\n                          int         count)\n{\n    const char *editname;\n    char *basename, *new_name;\n    GFileInfo *info;\n    GFile *dest;\n    int max_length;\n\n    max_length = get_max_name_length (dest_dir);\n\n    dest = NULL;\n    info = g_file_query_info (src,\n                              G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME,\n                              0, NULL, NULL);\n    if (info != NULL)\n    {\n        editname = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME);\n\n        if (editname != NULL)\n        {\n            new_name = get_link_name (editname, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        g_object_unref (info);\n    }\n\n    if (dest == NULL)\n    {\n        basename = g_file_get_basename (src);\n        make_file_name_valid_for_dest_fs (basename, dest_fs_type);\n\n        if (g_utf8_validate (basename, -1, NULL))\n        {\n            new_name = get_link_name (basename, count, max_length);\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child_for_display_name (dest_dir, new_name, NULL);\n            g_free (new_name);\n        }\n\n        if (dest == NULL)\n        {\n            if (count == 1)\n            {\n                new_name = g_strdup_printf (\"%s.lnk\", basename);\n            }\n            else\n            {\n                new_name = g_strdup_printf (\"%s.lnk%d\", basename, count);\n            }\n            make_file_name_valid_for_dest_fs (new_name, dest_fs_type);\n            dest = g_file_get_child (dest_dir, new_name);\n            g_free (new_name);\n        }\n\n        g_free (basename);\n    }\n\n    return dest;\n}\n\nstatic GFile *\nget_target_file_with_custom_name (GFile       *src,\n                                  GFile       *dest_dir,\n                                  const char  *dest_fs_type,\n                                  gboolean     same_fs,\n                                  const gchar *custom_name)\n{\n    char *basename;\n    GFile *dest;\n    GFileInfo *info;\n    char *copyname;\n\n    dest = NULL;\n\n    if (custom_name != NULL)\n    {\n        copyname = g_strdup (custom_name);\n        make_file_name_valid_for_dest_fs (copyname, dest_fs_type);\n        dest = g_file_get_child_for_display_name (dest_dir, copyname, NULL);\n\n        g_free (copyname);\n    }\n\n    if (dest == NULL && !same_fs)\n    {\n        info = g_file_query_info (src,\n                                  G_FILE_ATTRIBUTE_STANDARD_COPY_NAME \",\"\n                                  G_FILE_ATTRIBUTE_TRASH_ORIG_PATH,\n                                  0, NULL, NULL);\n\n        if (info)\n        {\n            copyname = NULL;\n\n            /* if file is being restored from trash make sure it uses its original name */\n            if (g_file_has_uri_scheme (src, \"trash\"))\n            {\n                copyname = g_path_get_basename (g_file_info_get_attribute_byte_string (info, G_FILE_ATTRIBUTE_TRASH_ORIG_PATH));\n            }\n\n            if (copyname == NULL)\n            {\n                copyname = g_strdup (g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_STANDARD_COPY_NAME));\n            }\n\n            if (copyname)\n            {\n                make_file_name_valid_for_dest_fs (copyname, dest_fs_type);\n                dest = g_file_get_child_for_display_name (dest_dir, copyname, NULL);\n                g_free (copyname);\n            }\n\n            g_object_unref (info);\n        }\n    }\n\n    if (dest == NULL)\n    {\n        basename = g_file_get_basename (src);\n        make_file_name_valid_for_dest_fs (basename, dest_fs_type);\n        dest = g_file_get_child (dest_dir, basename);\n        g_free (basename);\n    }\n\n    return dest;\n}\n\nstatic GFile *\nget_target_file (GFile      *src,\n                 GFile      *dest_dir,\n                 const char *dest_fs_type,\n                 gboolean    same_fs)\n{\n    return get_target_file_with_custom_name (src, dest_dir, dest_fs_type, same_fs, NULL);\n}\n\nstatic gboolean\nhas_fs_id (GFile      *file,\n           const char *fs_id)\n{\n    const char *id;\n    GFileInfo *info;\n    gboolean res;\n\n    res = FALSE;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              NULL, NULL);\n\n    if (info)\n    {\n        id = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_ID_FILESYSTEM);\n\n        if (id && strcmp (id, fs_id) == 0)\n        {\n            res = TRUE;\n        }\n\n        g_object_unref (info);\n    }\n\n    return res;\n}\n\nstatic gboolean\nis_dir (GFile *file)\n{\n    GFileInfo *info;\n    gboolean res;\n\n    res = FALSE;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              NULL, NULL);\n    if (info)\n    {\n        res = g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY;\n        g_object_unref (info);\n    }\n\n    return res;\n}\n\nstatic GFile *\nmap_possibly_volatile_file_to_real (GFile         *volatile_file,\n                                    GCancellable  *cancellable,\n                                    GError       **error)\n{\n    GFile *real_file = NULL;\n    GFileInfo *info = NULL;\n\n    info = g_file_query_info (volatile_file,\n                              G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              cancellable,\n                              error);\n    if (info == NULL)\n    {\n        return NULL;\n    }\n    else\n    {\n        gboolean is_volatile;\n\n        is_volatile = g_file_info_get_attribute_boolean (info,\n                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);\n        if (is_volatile)\n        {\n            const gchar *target;\n\n            target = g_file_info_get_symlink_target (info);\n            real_file = g_file_resolve_relative_path (volatile_file, target);\n        }\n    }\n\n    g_object_unref (info);\n\n    if (real_file == NULL)\n    {\n        real_file = g_object_ref (volatile_file);\n    }\n\n    return real_file;\n}\n\nstatic GFile *\nmap_possibly_volatile_file_to_real_on_write (GFile              *volatile_file,\n                                             GFileOutputStream  *stream,\n                                             GCancellable       *cancellable,\n                                             GError            **error)\n{\n    GFile *real_file = NULL;\n    GFileInfo *info = NULL;\n\n    info = g_file_output_stream_query_info (stream,\n                                            G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                            cancellable,\n                                            error);\n    if (info == NULL)\n    {\n        return NULL;\n    }\n    else\n    {\n        gboolean is_volatile;\n\n        is_volatile = g_file_info_get_attribute_boolean (info,\n                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);\n        if (is_volatile)\n        {\n            const gchar *target;\n\n            target = g_file_info_get_symlink_target (info);\n            real_file = g_file_resolve_relative_path (volatile_file, target);\n        }\n    }\n\n    g_object_unref (info);\n\n    if (real_file == NULL)\n    {\n        real_file = g_object_ref (volatile_file);\n    }\n\n    return real_file;\n}\n\nstatic void copy_move_file (CopyMoveJob  *job,\n                            GFile        *src,\n                            GFile        *dest_dir,\n                            gboolean      same_fs,\n                            gboolean      unique_names,\n                            char        **dest_fs_type,\n                            SourceInfo   *source_info,\n                            TransferInfo *transfer_info,\n                            GHashTable   *debuting_files,\n                            GdkPoint     *point,\n                            gboolean      overwrite,\n                            gboolean     *skipped_file,\n                            gboolean      readonly_source_fs);\n\ntypedef enum\n{\n    CREATE_DEST_DIR_RETRY,\n    CREATE_DEST_DIR_FAILED,\n    CREATE_DEST_DIR_SUCCESS\n} CreateDestDirResult;\n\nstatic CreateDestDirResult\ncreate_dest_dir (CommonJob  *job,\n                 GFile      *src,\n                 GFile     **dest,\n                 gboolean    same_fs,\n                 char      **dest_fs_type)\n{\n    GError *error;\n    GFile *new_dest, *dest_dir;\n    char *primary, *secondary, *details;\n    int response;\n    gboolean handled_invalid_filename;\n    gboolean res;\n\n    handled_invalid_filename = *dest_fs_type != NULL;\n\nretry:\n    /* First create the directory, then copy stuff to it before\n     *  copying the attributes, because we need to be sure we can write to it */\n\n    error = NULL;\n    res = g_file_make_directory (*dest, job->cancellable, &error);\n\n    if (res)\n    {\n        GFile *real;\n\n        real = map_possibly_volatile_file_to_real (*dest, job->cancellable, &error);\n        if (real == NULL)\n        {\n            res = FALSE;\n        }\n        else\n        {\n            g_object_unref (*dest);\n            *dest = real;\n        }\n    }\n\n    if (!res)\n    {\n        if (IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n            return CREATE_DEST_DIR_FAILED;\n        }\n        else if (IS_IO_ERROR (error, INVALID_FILENAME) &&\n                 !handled_invalid_filename)\n        {\n            handled_invalid_filename = TRUE;\n\n            g_assert (*dest_fs_type == NULL);\n\n            dest_dir = g_file_get_parent (*dest);\n\n            if (dest_dir != NULL)\n            {\n                *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n                new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n                g_object_unref (dest_dir);\n\n                if (!g_file_equal (*dest, new_dest))\n                {\n                    g_object_unref (*dest);\n                    *dest = new_dest;\n                    g_error_free (error);\n                    return CREATE_DEST_DIR_RETRY;\n                }\n                else\n                {\n                    g_object_unref (new_dest);\n                }\n            }\n        }\n\n        primary = f (_(\"Error while copying.\"));\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The folder \u201c%B\u201d cannot be copied because you do not have \"\n                             \"permissions to create it in the destination.\"), src);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error creating the folder \u201c%B\u201d.\"), src);\n            details = error->message;\n        }\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                FALSE,\n                                CANCEL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)\n        {\n            /* Skip: Do Nothing  */\n        }\n        else if (response == 2)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n        return CREATE_DEST_DIR_FAILED;\n    }\n    nautilus_file_changes_queue_file_added (*dest);\n\n    if (job->undo_info != NULL)\n    {\n        nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                            src, *dest);\n    }\n\n    return CREATE_DEST_DIR_SUCCESS;\n}\n\n/* a return value of FALSE means retry, i.e.\n * the destination has changed and the source\n * is expected to re-try the preceding\n * g_file_move() or g_file_copy() call with\n * the new destination.\n */\nstatic gboolean\ncopy_move_directory (CopyMoveJob   *copy_job,\n                     GFile         *src,\n                     GFile        **dest,\n                     gboolean       same_fs,\n                     gboolean       create_dest,\n                     char         **parent_dest_fs_type,\n                     SourceInfo    *source_info,\n                     TransferInfo  *transfer_info,\n                     GHashTable    *debuting_files,\n                     gboolean      *skipped_file,\n                     gboolean       readonly_source_fs)\n{\n    GFileInfo *info;\n    GError *error;\n    GFile *src_file;\n    GFileEnumerator *enumerator;\n    char *primary, *secondary, *details;\n    char *dest_fs_type;\n    int response;\n    gboolean skip_error;\n    gboolean local_skipped_file;\n    CommonJob *job;\n    GFileCopyFlags flags;\n\n    job = (CommonJob *) copy_job;\n\n    if (create_dest)\n    {\n        switch (create_dest_dir (job, src, dest, same_fs, parent_dest_fs_type))\n        {\n            case CREATE_DEST_DIR_RETRY:\n            {\n                /* next time copy_move_directory() is called,\n                 * create_dest will be FALSE if a directory already\n                 * exists under the new name (i.e. WOULD_RECURSE)\n                 */\n                return FALSE;\n            }\n\n            case CREATE_DEST_DIR_FAILED:\n            {\n                *skipped_file = TRUE;\n                return TRUE;\n            }\n\n            case CREATE_DEST_DIR_SUCCESS:\n            default:\n            {\n            }\n            break;\n        }\n\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (*dest), GINT_TO_POINTER (TRUE));\n        }\n    }\n\n    local_skipped_file = FALSE;\n    dest_fs_type = NULL;\n\n    skip_error = should_skip_readdir_error (job, src);\nretry:\n    error = NULL;\n    enumerator = g_file_enumerate_children (src,\n                                            G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                            job->cancellable,\n                                            &error);\n    if (enumerator)\n    {\n        error = NULL;\n\n        while (!job_aborted (job) &&\n               (info = g_file_enumerator_next_file (enumerator, job->cancellable, skip_error ? NULL : &error)) != NULL)\n        {\n            src_file = g_file_get_child (src,\n                                         g_file_info_get_name (info));\n            copy_move_file (copy_job, src_file, *dest, same_fs, FALSE, &dest_fs_type,\n                            source_info, transfer_info, NULL, NULL, FALSE, &local_skipped_file,\n                            readonly_source_fs);\n\n            if (local_skipped_file)\n            {\n                transfer_add_file_to_count (src_file, job, transfer_info);\n                report_copy_progress (copy_job, source_info, transfer_info);\n            }\n\n            g_object_unref (src_file);\n            g_object_unref (info);\n        }\n        g_file_enumerator_close (enumerator, job->cancellable, NULL);\n        g_object_unref (enumerator);\n\n        if (error && IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n        }\n        else if (error)\n        {\n            if (copy_job->is_move)\n            {\n                primary = f (_(\"Error while moving.\"));\n            }\n            else\n            {\n                primary = f (_(\"Error while copying.\"));\n            }\n            details = NULL;\n\n            if (IS_IO_ERROR (error, PERMISSION_DENIED))\n            {\n                secondary = f (_(\"Files in the folder \u201c%B\u201d cannot be copied because you do \"\n                                 \"not have permissions to see them.\"), src);\n            }\n            else\n            {\n                secondary = f (_(\"There was an error getting information about the files in the folder \u201c%B\u201d.\"), src);\n                details = error->message;\n            }\n\n            response = run_warning (job,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL, _(\"_Skip files\"),\n                                    NULL);\n\n            g_error_free (error);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 1)\n            {\n                /* Skip: Do Nothing */\n                local_skipped_file = TRUE;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n\n        /* Count the copied directory as a file */\n        transfer_info->num_files++;\n        report_copy_progress (copy_job, source_info, transfer_info);\n\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (*dest), GINT_TO_POINTER (create_dest));\n        }\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        if (copy_job->is_move)\n        {\n            primary = f (_(\"Error while moving.\"));\n        }\n        else\n        {\n            primary = f (_(\"Error while copying.\"));\n        }\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The folder \u201c%B\u201d cannot be copied because you do not have \"\n                             \"permissions to read it.\"), src);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error reading the folder \u201c%B\u201d.\"), src);\n            details = error->message;\n        }\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                FALSE,\n                                CANCEL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)\n        {\n            /* Skip: Do Nothing  */\n            local_skipped_file = TRUE;\n        }\n        else if (response == 2)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\n    if (create_dest)\n    {\n        flags = (readonly_source_fs) ? G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_TARGET_DEFAULT_PERMS\n                : G_FILE_COPY_NOFOLLOW_SYMLINKS;\n        /* Ignore errors here. Failure to copy metadata is not a hard error */\n        g_file_copy_attributes (src, *dest,\n                                flags,\n                                job->cancellable, NULL);\n    }\n\n    if (!job_aborted (job) && copy_job->is_move &&\n        /* Don't delete source if there was a skipped file */\n        !local_skipped_file)\n    {\n        if (!g_file_delete (src, job->cancellable, &error))\n        {\n            if (job->skip_all_error)\n            {\n                goto skip;\n            }\n            primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n            secondary = f (_(\"Could not remove the source folder.\"));\n            details = error->message;\n\n            response = run_cancel_or_skip_warning (job,\n                                                   primary,\n                                                   secondary,\n                                                   details,\n                                                   source_info->num_files,\n                                                   source_info->num_files - transfer_info->num_files);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (job);\n            }\n            else if (response == 1)                 /* skip all */\n            {\n                job->skip_all_error = TRUE;\n                local_skipped_file = TRUE;\n            }\n            else if (response == 2)                 /* skip */\n            {\n                local_skipped_file = TRUE;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\nskip:\n            g_error_free (error);\n        }\n    }\n\n    if (local_skipped_file)\n    {\n        *skipped_file = TRUE;\n    }\n\n    g_free (dest_fs_type);\n    return TRUE;\n}\n\n\ntypedef struct\n{\n    CommonJob *job;\n    GFile *source;\n} DeleteExistingFileData;\n\nstatic void\nexisting_file_removed_callback (GFile    *file,\n                                GError   *error,\n                                gpointer  callback_data)\n{\n    DeleteExistingFileData *data = callback_data;\n    CommonJob *job;\n    GFile *source;\n    GFileType file_type;\n    char *primary;\n    char *secondary;\n    char *details = NULL;\n    int response;\n\n    job = data->job;\n    source = data->source;\n\n    if (error == NULL)\n    {\n        nautilus_file_changes_queue_file_removed (file);\n\n        return;\n    }\n\n    if (job_aborted (job) || job->skip_all_error)\n    {\n        return;\n    }\n\n    primary = f (_(\"Error while copying \u201c%B\u201d.\"), source);\n\n    file_type = g_file_query_file_type (file,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        job->cancellable);\n\n    if (file_type == G_FILE_TYPE_DIRECTORY)\n    {\n        secondary = f (_(\"Could not remove the already existing folder %F.\"),\n                       file);\n    }\n    else\n    {\n        secondary = f (_(\"Could not remove the already existing file %F.\"),\n                       file);\n    }\n\n    details = error->message;\n\n    /* set show_all to TRUE here, as we don't know how many\n     * files we'll end up processing yet.\n     */\n    response = run_warning (job,\n                            primary,\n                            secondary,\n                            details,\n                            TRUE,\n                            CANCEL, SKIP_ALL, SKIP,\n                            NULL);\n\n    if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n    {\n        abort_job (job);\n    }\n    else if (response == 1)\n    {\n        /* skip all */\n        job->skip_all_error = TRUE;\n    }\n}\n\ntypedef struct\n{\n    CopyMoveJob *job;\n    goffset last_size;\n    SourceInfo *source_info;\n    TransferInfo *transfer_info;\n} ProgressData;\n\nstatic void\ncopy_file_progress_callback (goffset  current_num_bytes,\n                             goffset  total_num_bytes,\n                             gpointer user_data)\n{\n    ProgressData *pdata;\n    goffset new_size;\n\n    pdata = user_data;\n\n    new_size = current_num_bytes - pdata->last_size;\n\n    if (new_size > 0)\n    {\n        pdata->transfer_info->num_bytes += new_size;\n        pdata->last_size = current_num_bytes;\n        report_copy_progress (pdata->job,\n                              pdata->source_info,\n                              pdata->transfer_info);\n    }\n}\n\nstatic gboolean\ntest_dir_is_parent (GFile *child,\n                    GFile *root)\n{\n    GFile *f, *tmp;\n\n    f = g_file_dup (child);\n    while (f)\n    {\n        if (g_file_equal (f, root))\n        {\n            g_object_unref (f);\n            return TRUE;\n        }\n        tmp = f;\n        f = g_file_get_parent (f);\n        g_object_unref (tmp);\n    }\n    if (f)\n    {\n        g_object_unref (f);\n    }\n    return FALSE;\n}\n\nstatic char *\nquery_fs_type (GFile        *file,\n               GCancellable *cancellable)\n{\n    GFileInfo *fsinfo;\n    char *ret;\n\n    ret = NULL;\n\n    fsinfo = g_file_query_filesystem_info (file,\n                                           G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,\n                                           cancellable,\n                                           NULL);\n    if (fsinfo != NULL)\n    {\n        ret = g_strdup (g_file_info_get_attribute_string (fsinfo, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE));\n        g_object_unref (fsinfo);\n    }\n\n    if (ret == NULL)\n    {\n        /* ensure that we don't attempt to query\n         * the FS type for each file in a given\n         * directory, if it can't be queried. */\n        ret = g_strdup (\"\");\n    }\n\n    return ret;\n}\n\nstatic gboolean\nis_trusted_desktop_file (GFile        *file,\n                         GCancellable *cancellable)\n{\n    char *basename;\n    gboolean res;\n    GFileInfo *info;\n\n    /* Don't trust non-local files */\n    if (!g_file_is_native (file))\n    {\n        return FALSE;\n    }\n\n    basename = g_file_get_basename (file);\n    if (!g_str_has_suffix (basename, \".desktop\"))\n    {\n        g_free (basename);\n        return FALSE;\n    }\n    g_free (basename);\n\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              cancellable,\n                              NULL);\n\n    if (info == NULL)\n    {\n        return FALSE;\n    }\n\n    res = FALSE;\n\n    /* Weird file => not trusted,\n     *  Already executable => no need to mark trusted */\n    if (g_file_info_get_file_type (info) == G_FILE_TYPE_REGULAR &&\n        !g_file_info_get_attribute_boolean (info,\n                                            G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE) &&\n        nautilus_is_in_system_dir (file))\n    {\n        res = TRUE;\n    }\n    g_object_unref (info);\n\n    return res;\n}\n\nstatic FileConflictResponse *\nhandle_copy_move_conflict (CommonJob *job,\n                           GFile     *src,\n                           GFile     *dest,\n                           GFile     *dest_dir)\n{\n    FileConflictResponse *response;\n\n    g_timer_stop (job->time);\n    nautilus_progress_info_pause (job->progress);\n\n    response = copy_move_conflict_ask_user_action (job->parent_window,\n                                                   src,\n                                                   dest,\n                                                   dest_dir);\n\n    nautilus_progress_info_resume (job->progress);\n    g_timer_continue (job->time);\n\n    return response;\n}\n\nstatic GFile *\nget_target_file_for_display_name (GFile       *dir,\n                                  const gchar *name)\n{\n    GFile *dest;\n\n    dest = NULL;\n    dest = g_file_get_child_for_display_name (dir, name, NULL);\n\n    if (dest == NULL)\n    {\n        dest = g_file_get_child (dir, name);\n    }\n\n    return dest;\n}\n\n/* Debuting files is non-NULL only for toplevel items */\nstatic void\ncopy_move_file (CopyMoveJob   *copy_job,\n                GFile         *src,\n                GFile         *dest_dir,\n                gboolean       same_fs,\n                gboolean       unique_names,\n                char         **dest_fs_type,\n                SourceInfo    *source_info,\n                TransferInfo  *transfer_info,\n                GHashTable    *debuting_files,\n                GdkPoint      *position,\n                gboolean       overwrite,\n                gboolean      *skipped_file,\n                gboolean       readonly_source_fs)\n{\n    GFile *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    GError *error;\n    GFileCopyFlags flags;\n    char *primary, *secondary, *details;\n    int response;\n    ProgressData pdata;\n    gboolean would_recurse, is_merge;\n    CommonJob *job;\n    gboolean res;\n    int unique_name_nr;\n    gboolean handled_invalid_filename;\n\n    job = (CommonJob *) copy_job;\n\n    if (should_skip_file (job, src))\n    {\n        *skipped_file = TRUE;\n        return;\n    }\n\n    unique_name_nr = 1;\n\n    /* another file in the same directory might have handled the invalid\n     * filename condition for us\n     */\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    if (unique_names)\n    {\n        dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n    }\n    else if (copy_job->target_name != NULL)\n    {\n        dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,\n                                                 copy_job->target_name);\n    }\n    else\n    {\n        dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n    }\n\n    /* Don't allow recursive move/copy into itself.\n     * (We would get a file system error if we proceeded but it is nicer to\n     * detect and report it at this level) */\n    if (test_dir_is_parent (dest_dir, src))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = copy_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n                  : g_strdup (_(\"You cannot copy a folder into itself.\"));\n        secondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               NULL,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n    /* Don't allow copying over the source or one of the parents of the source.\n     */\n    if (test_dir_is_parent (src, dest))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = copy_job->is_move ? g_strdup (_(\"You cannot move a file over itself.\"))\n                  : g_strdup (_(\"You cannot copy a file over itself.\"));\n        secondary = g_strdup (_(\"The source file would be overwritten by the destination.\"));\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               NULL,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\nretry:\n\n    error = NULL;\n    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;\n    if (overwrite)\n    {\n        flags |= G_FILE_COPY_OVERWRITE;\n    }\n    if (readonly_source_fs)\n    {\n        flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;\n    }\n\n    pdata.job = copy_job;\n    pdata.last_size = 0;\n    pdata.source_info = source_info;\n    pdata.transfer_info = transfer_info;\n\n    if (copy_job->is_move)\n    {\n        res = g_file_move (src, dest,\n                           flags,\n                           job->cancellable,\n                           copy_file_progress_callback,\n                           &pdata,\n                           &error);\n    }\n    else\n    {\n        res = g_file_copy (src, dest,\n                           flags,\n                           job->cancellable,\n                           copy_file_progress_callback,\n                           &pdata,\n                           &error);\n    }\n\n    if (res)\n    {\n        GFile *real;\n\n        real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);\n        if (real == NULL)\n        {\n            res = FALSE;\n        }\n        else\n        {\n            g_object_unref (dest);\n            dest = real;\n        }\n    }\n\n    if (res)\n    {\n        transfer_info->num_files++;\n        report_copy_progress (copy_job, source_info, transfer_info);\n\n        if (debuting_files)\n        {\n            dest_uri = g_file_get_uri (dest);\n            if (position)\n            {\n                nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n            }\n            else if (eel_uri_is_desktop (dest_uri))\n            {\n                nautilus_file_changes_queue_schedule_position_remove (dest);\n            }\n\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n        if (copy_job->is_move)\n        {\n            nautilus_file_changes_queue_file_moved (src, dest);\n        }\n        else\n        {\n            nautilus_file_changes_queue_file_added (dest);\n        }\n\n        /* If copying a trusted desktop file to the desktop,\n         *  mark it as trusted. */\n        if (copy_job->desktop_location != NULL &&\n            g_file_equal (copy_job->desktop_location, dest_dir) &&\n            is_trusted_desktop_file (src, job->cancellable))\n        {\n            mark_desktop_file_executable (job,\n                                          job->cancellable,\n                                          dest,\n                                          FALSE);\n        }\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                                src, dest);\n        }\n\n        g_object_unref (dest);\n        return;\n    }\n\n    if (!handled_invalid_filename &&\n        IS_IO_ERROR (error, INVALID_FILENAME))\n    {\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n        if (unique_names)\n        {\n            new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);\n        }\n        else\n        {\n            new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n        }\n\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n\n            g_error_free (error);\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n\n    /* Conflict */\n    if (!overwrite &&\n        IS_IO_ERROR (error, EXISTS))\n    {\n        gboolean is_merge;\n        FileConflictResponse *response;\n\n        g_error_free (error);\n\n        if (unique_names)\n        {\n            g_object_unref (dest);\n            dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n            goto retry;\n        }\n\n        is_merge = FALSE;\n\n        if (is_dir (dest) && is_dir (src))\n        {\n            is_merge = TRUE;\n        }\n\n        if ((is_merge && job->merge_all) ||\n            (!is_merge && job->replace_all))\n        {\n            overwrite = TRUE;\n            goto retry;\n        }\n\n        if (job->skip_all_conflict)\n        {\n            goto out;\n        }\n\n        response = handle_copy_move_conflict (job, src, dest, dest_dir);\n\n        if (response->id == GTK_RESPONSE_CANCEL ||\n            response->id == GTK_RESPONSE_DELETE_EVENT)\n        {\n            file_conflict_response_free (response);\n            abort_job (job);\n        }\n        else if (response->id == CONFLICT_RESPONSE_SKIP)\n        {\n            if (response->apply_to_all)\n            {\n                job->skip_all_conflict = TRUE;\n            }\n            file_conflict_response_free (response);\n        }\n        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */\n        {\n            if (response->apply_to_all)\n            {\n                if (is_merge)\n                {\n                    job->merge_all = TRUE;\n                }\n                else\n                {\n                    job->replace_all = TRUE;\n                }\n            }\n            overwrite = TRUE;\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else if (response->id == CONFLICT_RESPONSE_RENAME)\n        {\n            g_object_unref (dest);\n            dest = get_target_file_for_display_name (dest_dir,\n                                                     response->new_name);\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n    else if (overwrite &&\n             IS_IO_ERROR (error, IS_DIRECTORY))\n    {\n        gboolean existing_file_deleted;\n        DeleteExistingFileData data;\n\n        g_error_free (error);\n\n        data.job = job;\n        data.source = src;\n\n        existing_file_deleted =\n            delete_file_recursively (dest,\n                                     job->cancellable,\n                                     existing_file_removed_callback,\n                                     &data);\n\n        if (existing_file_deleted)\n        {\n            goto retry;\n        }\n    }\n    /* Needs to recurse */\n    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n             IS_IO_ERROR (error, WOULD_MERGE))\n    {\n        is_merge = error->code == G_IO_ERROR_WOULD_MERGE;\n        would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;\n        g_error_free (error);\n\n        if (overwrite && would_recurse)\n        {\n            error = NULL;\n\n            /* Copying a dir onto file, first remove the file */\n            if (!g_file_delete (dest, job->cancellable, &error) &&\n                !IS_IO_ERROR (error, NOT_FOUND))\n            {\n                if (job->skip_all_error)\n                {\n                    g_error_free (error);\n                    goto out;\n                }\n                if (copy_job->is_move)\n                {\n                    primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n                }\n                else\n                {\n                    primary = f (_(\"Error while copying \u201c%B\u201d.\"), src);\n                }\n                secondary = f (_(\"Could not remove the already existing file with the same name in %F.\"), dest_dir);\n                details = error->message;\n\n                /* setting TRUE on show_all here, as we could have\n                 * another error on the same file later.\n                 */\n                response = run_warning (job,\n                                        primary,\n                                        secondary,\n                                        details,\n                                        TRUE,\n                                        CANCEL, SKIP_ALL, SKIP,\n                                        NULL);\n\n                g_error_free (error);\n\n                if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n                {\n                    abort_job (job);\n                }\n                else if (response == 1)                     /* skip all */\n                {\n                    job->skip_all_error = TRUE;\n                }\n                else if (response == 2)                     /* skip */\n                {                       /* do nothing */\n                }\n                else\n                {\n                    g_assert_not_reached ();\n                }\n                goto out;\n            }\n            if (error)\n            {\n                g_error_free (error);\n                error = NULL;\n            }\n            nautilus_file_changes_queue_file_removed (dest);\n        }\n\n        if (is_merge)\n        {\n            /* On merge we now write in the target directory, which may not\n             *   be in the same directory as the source, even if the parent is\n             *   (if the merged directory is a mountpoint). This could cause\n             *   problems as we then don't transcode filenames.\n             *   We just set same_fs to FALSE which is safe but a bit slower. */\n            same_fs = FALSE;\n        }\n\n        if (!copy_move_directory (copy_job, src, &dest, same_fs,\n                                  would_recurse, dest_fs_type,\n                                  source_info, transfer_info,\n                                  debuting_files, skipped_file,\n                                  readonly_source_fs))\n        {\n            /* destination changed, since it was an invalid file name */\n            g_assert (*dest_fs_type != NULL);\n            handled_invalid_filename = TRUE;\n            goto retry;\n        }\n\n        g_object_unref (dest);\n        return;\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else\n    {\n        if (job->skip_all_error)\n        {\n            g_error_free (error);\n            goto out;\n        }\n        primary = f (_(\"Error while copying \u201c%B\u201d.\"), src);\n        secondary = f (_(\"There was an error copying the file into %F.\"), dest_dir);\n        details = error->message;\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               details,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\nout:\n    *skipped_file = TRUE;     /* Or aborted, but same-same */\n    g_object_unref (dest);\n}\n\nstatic void\ncopy_files (CopyMoveJob  *job,\n            const char   *dest_fs_id,\n            SourceInfo   *source_info,\n            TransferInfo *transfer_info)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    gboolean skipped_file;\n    gboolean unique_names;\n    GFile *dest;\n    GFile *source_dir;\n    char *dest_fs_type;\n    GFileInfo *inf;\n    gboolean readonly_source_fs;\n\n    dest_fs_type = NULL;\n    readonly_source_fs = FALSE;\n\n    common = &job->common;\n\n    report_copy_progress (job, source_info, transfer_info);\n\n    /* Query the source dir, not the file because if it's a symlink we'll follow it */\n    source_dir = g_file_get_parent ((GFile *) job->files->data);\n    if (source_dir)\n    {\n        inf = g_file_query_filesystem_info (source_dir, \"filesystem::readonly\", NULL, NULL);\n        if (inf != NULL)\n        {\n            readonly_source_fs = g_file_info_get_attribute_boolean (inf, \"filesystem::readonly\");\n            g_object_unref (inf);\n        }\n        g_object_unref (source_dir);\n    }\n\n    unique_names = (job->destination == NULL);\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        if (job->destination)\n        {\n            dest = g_object_ref (job->destination);\n        }\n        else\n        {\n            dest = g_file_get_parent (src);\n        }\n        if (dest)\n        {\n            skipped_file = FALSE;\n            copy_move_file (job, src, dest,\n                            same_fs, unique_names,\n                            &dest_fs_type,\n                            source_info, transfer_info,\n                            job->debuting_files,\n                            point, FALSE, &skipped_file,\n                            readonly_source_fs);\n            g_object_unref (dest);\n\n            if (skipped_file)\n            {\n                transfer_add_file_to_count (src, common, transfer_info);\n                report_copy_progress (job, source_info, transfer_info);\n            }\n        }\n        i++;\n    }\n\n    g_free (dest_fs_type);\n}\n\nstatic void\ncopy_task_done (GObject      *source_object,\n                GAsyncResult *res,\n                gpointer      user_data)\n{\n    CopyMoveJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->debuting_files,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_list_free_full (job->files, g_object_unref);\n    if (job->destination)\n    {\n        g_object_unref (job->destination);\n    }\n    if (job->desktop_location)\n    {\n        g_object_unref (job->desktop_location);\n    }\n    g_hash_table_unref (job->debuting_files);\n    g_free (job->icon_positions);\n    g_free (job->target_name);\n\n    g_clear_object (&job->fake_display_source);\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ncopy_task_thread_func (GTask        *task,\n                       gpointer      source_object,\n                       gpointer      task_data,\n                       GCancellable *cancellable)\n{\n    CopyMoveJob *job;\n    CommonJob *common;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    char *dest_fs_id;\n    GFile *dest;\n\n    job = task_data;\n    common = &job->common;\n\n    dest_fs_id = NULL;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    scan_sources (job->files,\n                  &source_info,\n                  common,\n                  OP_KIND_COPY);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    if (job->destination)\n    {\n        dest = g_object_ref (job->destination);\n    }\n    else\n    {\n        /* Duplication, no dest,\n         * use source for free size, etc\n         */\n        dest = g_file_get_parent (job->files->data);\n    }\n\n    verify_destination (&job->common,\n                        dest,\n                        &dest_fs_id,\n                        source_info.num_bytes);\n    g_object_unref (dest);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    g_timer_start (job->common.time);\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    copy_files (job,\n                dest_fs_id,\n                &source_info, &transfer_info);\n\naborted:\n\n    g_free (dest_fs_id);\n}\n\nvoid\nnautilus_file_operations_copy_file (GFile                *source_file,\n                                    GFile                *target_dir,\n                                    const gchar          *source_display_name,\n                                    const gchar          *new_name,\n                                    GtkWindow            *parent_window,\n                                    NautilusCopyCallback  done_callback,\n                                    gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_append (NULL, g_object_ref (source_file));\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    job->target_name = g_strdup (new_name);\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    if (source_display_name != NULL)\n    {\n        gchar *path;\n\n        path = g_build_filename (\"/\", source_display_name, NULL);\n        job->fake_display_source = g_file_new_for_path (path);\n\n        g_free (path);\n    }\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Copying Files\"));\n\n    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, copy_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_copy (GList                *files,\n                               GArray               *relative_item_points,\n                               GFile                *target_dir,\n                               GtkWindow            *parent_window,\n                               NautilusCopyCallback  done_callback,\n                               gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->desktop_location = nautilus_get_desktop_location ();\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Copying Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n        job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_COPY,\n                                                                 g_list_length (files),\n                                                                 src_dir, target_dir);\n\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, copy_task_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nreport_preparing_move_progress (CopyMoveJob *move_job,\n                                int          total,\n                                int          left)\n{\n    CommonJob *job;\n\n    job = (CommonJob *) move_job;\n\n    nautilus_progress_info_take_status (job->progress,\n                                        f (_(\"Preparing to move to \u201c%B\u201d\"),\n                                           move_job->destination));\n\n    nautilus_progress_info_take_details (job->progress,\n                                         f (ngettext (\"Preparing to move %'d file\",\n                                                      \"Preparing to move %'d files\",\n                                                      left), left));\n\n    nautilus_progress_info_pulse_progress (job->progress);\n}\n\ntypedef struct\n{\n    GFile *file;\n    gboolean overwrite;\n    gboolean has_position;\n    GdkPoint position;\n} MoveFileCopyFallback;\n\nstatic MoveFileCopyFallback *\nmove_copy_file_callback_new (GFile    *file,\n                             gboolean  overwrite,\n                             GdkPoint *position)\n{\n    MoveFileCopyFallback *fallback;\n\n    fallback = g_new (MoveFileCopyFallback, 1);\n    fallback->file = file;\n    fallback->overwrite = overwrite;\n    if (position)\n    {\n        fallback->has_position = TRUE;\n        fallback->position = *position;\n    }\n    else\n    {\n        fallback->has_position = FALSE;\n    }\n\n    return fallback;\n}\n\nstatic GList *\nget_files_from_fallbacks (GList *fallbacks)\n{\n    MoveFileCopyFallback *fallback;\n    GList *res, *l;\n\n    res = NULL;\n    for (l = fallbacks; l != NULL; l = l->next)\n    {\n        fallback = l->data;\n        res = g_list_prepend (res, fallback->file);\n    }\n    return g_list_reverse (res);\n}\n\nstatic void\nmove_file_prepare (CopyMoveJob  *move_job,\n                   GFile        *src,\n                   GFile        *dest_dir,\n                   gboolean      same_fs,\n                   char        **dest_fs_type,\n                   GHashTable   *debuting_files,\n                   GdkPoint     *position,\n                   GList       **fallback_files,\n                   int           files_left)\n{\n    GFile *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    GError *error;\n    CommonJob *job;\n    gboolean overwrite;\n    char *primary, *secondary, *details;\n    int response;\n    GFileCopyFlags flags;\n    MoveFileCopyFallback *fallback;\n    gboolean handled_invalid_filename;\n\n    overwrite = FALSE;\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    job = (CommonJob *) move_job;\n\n    dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n\n\n    /* Don't allow recursive move/copy into itself.\n     * (We would get a file system error if we proceeded but it is nicer to\n     * detect and report it at this level) */\n    if (test_dir_is_parent (dest_dir, src))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = move_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n                  : g_strdup (_(\"You cannot copy a folder into itself.\"));\n        secondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                NULL,\n                                files_left > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\nretry:\n\n    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS | G_FILE_COPY_NO_FALLBACK_FOR_MOVE;\n    if (overwrite)\n    {\n        flags |= G_FILE_COPY_OVERWRITE;\n    }\n\n    error = NULL;\n    if (g_file_move (src, dest,\n                     flags,\n                     job->cancellable,\n                     NULL,\n                     NULL,\n                     &error))\n    {\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n\n        nautilus_file_changes_queue_file_moved (src, dest);\n\n        dest_uri = g_file_get_uri (dest);\n        if (position)\n        {\n            nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n        }\n        else if (eel_uri_is_desktop (dest_uri))\n        {\n            nautilus_file_changes_queue_schedule_position_remove (dest);\n        }\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                                src, dest);\n        }\n\n        return;\n    }\n\n    if (IS_IO_ERROR (error, INVALID_FILENAME) &&\n        !handled_invalid_filename)\n    {\n        g_error_free (error);\n\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n        new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n    /* Conflict */\n    else if (!overwrite &&\n             IS_IO_ERROR (error, EXISTS))\n    {\n        gboolean is_merge;\n        FileConflictResponse *response;\n\n        g_error_free (error);\n\n        is_merge = FALSE;\n        if (is_dir (dest) && is_dir (src))\n        {\n            is_merge = TRUE;\n        }\n\n        if ((is_merge && job->merge_all) ||\n            (!is_merge && job->replace_all))\n        {\n            overwrite = TRUE;\n            goto retry;\n        }\n\n        if (job->skip_all_conflict)\n        {\n            goto out;\n        }\n\n        response = handle_copy_move_conflict (job, src, dest, dest_dir);\n\n        if (response->id == GTK_RESPONSE_CANCEL ||\n            response->id == GTK_RESPONSE_DELETE_EVENT)\n        {\n            file_conflict_response_free (response);\n            abort_job (job);\n        }\n        else if (response->id == CONFLICT_RESPONSE_SKIP)\n        {\n            if (response->apply_to_all)\n            {\n                job->skip_all_conflict = TRUE;\n            }\n            file_conflict_response_free (response);\n        }\n        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */\n        {\n            if (response->apply_to_all)\n            {\n                if (is_merge)\n                {\n                    job->merge_all = TRUE;\n                }\n                else\n                {\n                    job->replace_all = TRUE;\n                }\n            }\n            overwrite = TRUE;\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else if (response->id == CONFLICT_RESPONSE_RENAME)\n        {\n            g_object_unref (dest);\n            dest = get_target_file_for_display_name (dest_dir,\n                                                     response->new_name);\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n             IS_IO_ERROR (error, WOULD_MERGE) ||\n             IS_IO_ERROR (error, NOT_SUPPORTED) ||\n             (overwrite && IS_IO_ERROR (error, IS_DIRECTORY)))\n    {\n        g_error_free (error);\n\n        fallback = move_copy_file_callback_new (src,\n                                                overwrite,\n                                                position);\n        *fallback_files = g_list_prepend (*fallback_files, fallback);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else\n    {\n        if (job->skip_all_error)\n        {\n            g_error_free (error);\n            goto out;\n        }\n        primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n        secondary = f (_(\"There was an error moving the file into %F.\"), dest_dir);\n        details = error->message;\n\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                files_left > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\nout:\n    g_object_unref (dest);\n}\n\nstatic void\nmove_files_prepare (CopyMoveJob  *job,\n                    const char   *dest_fs_id,\n                    char        **dest_fs_type,\n                    GList       **fallbacks)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    int total, left;\n\n    common = &job->common;\n\n    total = left = g_list_length (job->files);\n\n    report_preparing_move_progress (job, total, left);\n\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        move_file_prepare (job, src, job->destination,\n                           same_fs, dest_fs_type,\n                           job->debuting_files,\n                           point,\n                           fallbacks,\n                           left);\n        report_preparing_move_progress (job, total, --left);\n        i++;\n    }\n\n    *fallbacks = g_list_reverse (*fallbacks);\n}\n\nstatic void\nmove_files (CopyMoveJob   *job,\n            GList         *fallbacks,\n            const char    *dest_fs_id,\n            char         **dest_fs_type,\n            SourceInfo    *source_info,\n            TransferInfo  *transfer_info)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    gboolean skipped_file;\n    MoveFileCopyFallback *fallback;\n    common = &job->common;\n\n    report_copy_progress (job, source_info, transfer_info);\n\n    i = 0;\n    for (l = fallbacks;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        fallback = l->data;\n        src = fallback->file;\n\n        if (fallback->has_position)\n        {\n            point = &fallback->position;\n        }\n        else\n        {\n            point = NULL;\n        }\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        /* Set overwrite to true, as the user has\n         *  selected overwrite on all toplevel items */\n        skipped_file = FALSE;\n        copy_move_file (job, src, job->destination,\n                        same_fs, FALSE, dest_fs_type,\n                        source_info, transfer_info,\n                        job->debuting_files,\n                        point, fallback->overwrite, &skipped_file, FALSE);\n        i++;\n\n        if (skipped_file)\n        {\n            transfer_add_file_to_count (src, common, transfer_info);\n            report_copy_progress (job, source_info, transfer_info);\n        }\n    }\n}\n\n\nstatic void\nmove_task_done (GObject      *source_object,\n                GAsyncResult *res,\n                gpointer      user_data)\n{\n    CopyMoveJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->debuting_files,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_list_free_full (job->files, g_object_unref);\n    g_object_unref (job->destination);\n    g_hash_table_unref (job->debuting_files);\n    g_free (job->icon_positions);\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\nmove_task_thread_func (GTask        *task,\n                       gpointer      source_object,\n                       gpointer      task_data,\n                       GCancellable *cancellable)\n{\n    CopyMoveJob *job;\n    CommonJob *common;\n    GList *fallbacks;\n    SourceInfo source_info;\n    TransferInfo transfer_info;\n    char *dest_fs_id;\n    char *dest_fs_type;\n    GList *fallback_files;\n\n    job = task_data;\n    common = &job->common;\n\n    dest_fs_id = NULL;\n    dest_fs_type = NULL;\n\n    fallbacks = NULL;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    verify_destination (&job->common,\n                        job->destination,\n                        &dest_fs_id,\n                        -1);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    /* This moves all files that we can do without copy + delete */\n    move_files_prepare (job, dest_fs_id, &dest_fs_type, &fallbacks);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    /* The rest we need to do deep copy + delete behind on,\n     *  so scan for size */\n\n    fallback_files = get_files_from_fallbacks (fallbacks);\n    scan_sources (fallback_files,\n                  &source_info,\n                  common,\n                  OP_KIND_MOVE);\n\n    g_list_free (fallback_files);\n\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    verify_destination (&job->common,\n                        job->destination,\n                        NULL,\n                        source_info.num_bytes);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    memset (&transfer_info, 0, sizeof (transfer_info));\n    move_files (job,\n                fallbacks,\n                dest_fs_id, &dest_fs_type,\n                &source_info, &transfer_info);\n\naborted:\n    g_list_free_full (fallbacks, g_free);\n\n    g_free (dest_fs_id);\n    g_free (dest_fs_type);\n}\n\nvoid\nnautilus_file_operations_move (GList                *files,\n                               GArray               *relative_item_points,\n                               GFile                *target_dir,\n                               GtkWindow            *parent_window,\n                               NautilusCopyCallback  done_callback,\n                               gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->is_move = TRUE;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Moving Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n\n        if (g_file_has_uri_scheme (g_list_first (files)->data, \"trash\"))\n        {\n            job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_RESTORE_FROM_TRASH,\n                                                                     g_list_length (files),\n                                                                     src_dir, target_dir);\n        }\n        else\n        {\n            job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_MOVE,\n                                                                     g_list_length (files),\n                                                                     src_dir, target_dir);\n        }\n\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, move_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, move_task_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nreport_preparing_link_progress (CopyMoveJob *link_job,\n                                int          total,\n                                int          left)\n{\n    CommonJob *job;\n\n    job = (CommonJob *) link_job;\n\n    nautilus_progress_info_take_status (job->progress,\n                                        f (_(\"Creating links in \u201c%B\u201d\"),\n                                           link_job->destination));\n\n    nautilus_progress_info_take_details (job->progress,\n                                         f (ngettext (\"Making link to %'d file\",\n                                                      \"Making links to %'d files\",\n                                                      left), left));\n\n    nautilus_progress_info_set_progress (job->progress, left, total);\n}\n\nstatic char *\nget_abs_path_for_symlink (GFile *file,\n                          GFile *destination)\n{\n    GFile *root, *parent;\n    char *relative, *abs;\n\n    if (g_file_is_native (file) || g_file_is_native (destination))\n    {\n        return g_file_get_path (file);\n    }\n\n    root = g_object_ref (file);\n    while ((parent = g_file_get_parent (root)) != NULL)\n    {\n        g_object_unref (root);\n        root = parent;\n    }\n\n    relative = g_file_get_relative_path (root, file);\n    g_object_unref (root);\n    abs = g_strconcat (\"/\", relative, NULL);\n    g_free (relative);\n    return abs;\n}\n\n\nstatic void\nlink_file (CopyMoveJob  *job,\n           GFile        *src,\n           GFile        *dest_dir,\n           char        **dest_fs_type,\n           GHashTable   *debuting_files,\n           GdkPoint     *position,\n           int           files_left)\n{\n    GFile *src_dir, *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    int count;\n    char *path;\n    gboolean not_local;\n    GError *error;\n    CommonJob *common;\n    char *primary, *secondary, *details;\n    int response;\n    gboolean handled_invalid_filename;\n\n    common = (CommonJob *) job;\n\n    count = 0;\n\n    src_dir = g_file_get_parent (src);\n    if (g_file_equal (src_dir, dest_dir))\n    {\n        count = 1;\n    }\n    g_object_unref (src_dir);\n\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count);\n\nretry:\n    error = NULL;\n    not_local = FALSE;\n\n    path = get_abs_path_for_symlink (src, dest);\n    if (path == NULL)\n    {\n        not_local = TRUE;\n    }\n    else if (g_file_make_symbolic_link (dest,\n                                        path,\n                                        common->cancellable,\n                                        &error))\n    {\n        if (common->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (common->undo_info),\n                                                                src, dest);\n        }\n\n        g_free (path);\n        if (debuting_files)\n        {\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n\n        nautilus_file_changes_queue_file_added (dest);\n        dest_uri = g_file_get_uri (dest);\n        if (position)\n        {\n            nautilus_file_changes_queue_schedule_position_set (dest, *position, common->screen_num);\n        }\n        else if (eel_uri_is_desktop (dest_uri))\n        {\n            nautilus_file_changes_queue_schedule_position_remove (dest);\n        }\n\n        g_object_unref (dest);\n\n        return;\n    }\n    g_free (path);\n\n    if (error != NULL &&\n        IS_IO_ERROR (error, INVALID_FILENAME) &&\n        !handled_invalid_filename)\n    {\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, common->cancellable);\n\n        new_dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count);\n\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n            g_error_free (error);\n\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n    /* Conflict */\n    if (error != NULL && IS_IO_ERROR (error, EXISTS))\n    {\n        g_object_unref (dest);\n        dest = get_target_file_for_link (src, dest_dir, *dest_fs_type, count++);\n        g_error_free (error);\n        goto retry;\n    }\n    else if (error != NULL && IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else if (error != NULL)\n    {\n        if (common->skip_all_error)\n        {\n            goto out;\n        }\n        primary = f (_(\"Error while creating link to %B.\"), src);\n        if (not_local)\n        {\n            secondary = f (_(\"Symbolic links only supported for local files\"));\n            details = NULL;\n        }\n        else if (IS_IO_ERROR (error, NOT_SUPPORTED))\n        {\n            secondary = f (_(\"The target doesn\u2019t support symbolic links.\"));\n            details = NULL;\n        }\n        else\n        {\n            secondary = f (_(\"There was an error creating the symlink in %F.\"), dest_dir);\n            details = error->message;\n        }\n\n        response = run_warning (common,\n                                primary,\n                                secondary,\n                                details,\n                                files_left > 1,\n                                CANCEL, SKIP_ALL, SKIP,\n                                NULL);\n\n        if (error)\n        {\n            g_error_free (error);\n        }\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            common->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\nout:\n    g_object_unref (dest);\n}\n\nstatic void\nlink_task_done (GObject      *source_object,\n                GAsyncResult *res,\n                gpointer      user_data)\n{\n    CopyMoveJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->debuting_files,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_list_free_full (job->files, g_object_unref);\n    g_object_unref (job->destination);\n    g_hash_table_unref (job->debuting_files);\n    g_free (job->icon_positions);\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\nlink_task_thread_func (GTask        *task,\n                       gpointer      source_object,\n                       gpointer      task_data,\n                       GCancellable *cancellable)\n{\n    CopyMoveJob *job;\n    CommonJob *common;\n    GFile *src;\n    GdkPoint *point;\n    char *dest_fs_type;\n    int total, left;\n    int i;\n    GList *l;\n\n    job = task_data;\n    common = &job->common;\n\n    dest_fs_type = NULL;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    verify_destination (&job->common,\n                        job->destination,\n                        NULL,\n                        -1);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    total = left = g_list_length (job->files);\n\n    report_preparing_link_progress (job, total, left);\n\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        link_file (job, src, job->destination,\n                   &dest_fs_type, job->debuting_files,\n                   point, left);\n        report_preparing_link_progress (job, total, --left);\n        i++;\n    }\n\naborted:\n    g_free (dest_fs_type);\n}\n\nvoid\nnautilus_file_operations_link (GList                *files,\n                               GArray               *relative_item_points,\n                               GFile                *target_dir,\n                               GtkWindow            *parent_window,\n                               NautilusCopyCallback  done_callback,\n                               gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = g_object_ref (target_dir);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, target_dir);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n        job->common.undo_info = nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_CREATE_LINK,\n                                                                 g_list_length (files),\n                                                                 src_dir, target_dir);\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, link_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, link_task_thread_func);\n    g_object_unref (task);\n}\n\n\nvoid\nnautilus_file_operations_duplicate (GList                *files,\n                                    GArray               *relative_item_points,\n                                    GtkWindow            *parent_window,\n                                    NautilusCopyCallback  done_callback,\n                                    gpointer              done_callback_data)\n{\n    GTask *task;\n    CopyMoveJob *job;\n    GFile *parent;\n\n    job = op_job_new (CopyMoveJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);\n    job->destination = NULL;\n    /* Duplicate files doesn't have a destination, since is the same as source.\n     * For that set as destination the source parent folder */\n    parent = g_file_get_parent (files->data);\n    /* Need to indicate the destination for the operation notification open\n     * button. */\n    nautilus_progress_info_set_destination (((CommonJob *) job)->progress, parent);\n    if (relative_item_points != NULL &&\n        relative_item_points->len > 0)\n    {\n        job->icon_positions =\n            g_memdup (relative_item_points->data,\n                      sizeof (GdkPoint) * relative_item_points->len);\n        job->n_icon_positions = relative_item_points->len;\n    }\n    job->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        GFile *src_dir;\n\n        src_dir = g_file_get_parent (files->data);\n        job->common.undo_info =\n            nautilus_file_undo_info_ext_new (NAUTILUS_FILE_UNDO_OP_DUPLICATE,\n                                             g_list_length (files),\n                                             src_dir, src_dir);\n        g_object_unref (src_dir);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, copy_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, copy_task_thread_func);\n    g_object_unref (task);\n\n    g_object_unref (parent);\n}\n\nstatic void\nset_permissions_task_done (GObject      *source_object,\n                           GAsyncResult *res,\n                           gpointer      user_data)\n{\n    SetPermissionsJob *job;\n\n    job = user_data;\n\n    g_object_unref (job->file);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}\n\nstatic void\nset_permissions_file (SetPermissionsJob *job,\n                      GFile             *file,\n                      GFileInfo         *info)\n{\n    CommonJob *common;\n    GFileInfo *child_info;\n    gboolean free_info;\n    guint32 current;\n    guint32 value;\n    guint32 mask;\n    GFileEnumerator *enumerator;\n    GFile *child;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_pulse_progress (common->progress);\n\n    free_info = FALSE;\n    if (info == NULL)\n    {\n        free_info = TRUE;\n        info = g_file_query_info (file,\n                                  G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                  G_FILE_ATTRIBUTE_UNIX_MODE,\n                                  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                  common->cancellable,\n                                  NULL);\n        /* Ignore errors */\n        if (info == NULL)\n        {\n            return;\n        }\n    }\n\n    if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n    {\n        value = job->dir_permissions;\n        mask = job->dir_mask;\n    }\n    else\n    {\n        value = job->file_permissions;\n        mask = job->file_mask;\n    }\n\n\n    if (!job_aborted (common) &&\n        g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n\n        if (common->undo_info != NULL)\n        {\n            nautilus_file_undo_info_rec_permissions_add_file (NAUTILUS_FILE_UNDO_INFO_REC_PERMISSIONS (common->undo_info),\n                                                              file, current);\n        }\n\n        current = (current & ~mask) | value;\n\n        g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                     current, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                     common->cancellable, NULL);\n    }\n\n    if (!job_aborted (common) &&\n        g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n    {\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                                G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                                G_FILE_ATTRIBUTE_UNIX_MODE,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                common->cancellable,\n                                                NULL);\n        if (enumerator)\n        {\n            while (!job_aborted (common) &&\n                   (child_info = g_file_enumerator_next_file (enumerator, common->cancellable, NULL)) != NULL)\n            {\n                child = g_file_get_child (file,\n                                          g_file_info_get_name (child_info));\n                set_permissions_file (job, child, child_info);\n                g_object_unref (child);\n                g_object_unref (child_info);\n            }\n            g_file_enumerator_close (enumerator, common->cancellable, NULL);\n            g_object_unref (enumerator);\n        }\n    }\n    if (free_info)\n    {\n        g_object_unref (info);\n    }\n}\n\n\nstatic void\nset_permissions_thread_func (GTask        *task,\n                             gpointer      source_object,\n                             gpointer      task_data,\n                             GCancellable *cancellable)\n{\n    SetPermissionsJob *job = task_data;\n    CommonJob *common;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_set_status (common->progress,\n                                       _(\"Setting permissions\"));\n\n    nautilus_progress_info_start (job->common.progress);\n\n    set_permissions_file (job, job->file, NULL);\n}\n\n\n\nvoid\nnautilus_file_set_permissions_recursive (const char         *directory,\n                                         guint32             file_permissions,\n                                         guint32             file_mask,\n                                         guint32             dir_permissions,\n                                         guint32             dir_mask,\n                                         NautilusOpCallback  callback,\n                                         gpointer            callback_data)\n{\n    GTask *task;\n    SetPermissionsJob *job;\n\n    job = op_job_new (SetPermissionsJob, NULL);\n    job->file = g_file_new_for_uri (directory);\n    job->file_permissions = file_permissions;\n    job->file_mask = file_mask;\n    job->dir_permissions = dir_permissions;\n    job->dir_mask = dir_mask;\n    job->done_callback = callback;\n    job->done_callback_data = callback_data;\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info =\n            nautilus_file_undo_info_rec_permissions_new (job->file,\n                                                         file_permissions, file_mask,\n                                                         dir_permissions, dir_mask);\n    }\n\n    task = g_task_new (NULL, NULL, set_permissions_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, set_permissions_thread_func);\n    g_object_unref (task);\n}\n\nstatic GList *\nlocation_list_from_uri_list (const GList *uris)\n{\n    const GList *l;\n    GList *files;\n    GFile *f;\n\n    files = NULL;\n    for (l = uris; l != NULL; l = l->next)\n    {\n        f = g_file_new_for_uri (l->data);\n        files = g_list_prepend (files, f);\n    }\n\n    return g_list_reverse (files);\n}\n\ntypedef struct\n{\n    NautilusCopyCallback real_callback;\n    gpointer real_data;\n} MoveTrashCBData;\n\nstatic void\ncallback_for_move_to_trash (GHashTable      *debuting_uris,\n                            gboolean         user_cancelled,\n                            MoveTrashCBData *data)\n{\n    if (data->real_callback)\n    {\n        data->real_callback (debuting_uris, !user_cancelled, data->real_data);\n    }\n    g_slice_free (MoveTrashCBData, data);\n}\n\nvoid\nnautilus_file_operations_copy_move (const GList          *item_uris,\n                                    GArray               *relative_item_points,\n                                    const char           *target_dir,\n                                    GdkDragAction         copy_action,\n                                    GtkWidget            *parent_view,\n                                    NautilusCopyCallback  done_callback,\n                                    gpointer              done_callback_data)\n{\n    GList *locations;\n    GList *p;\n    GFile *dest, *src_dir;\n    GtkWindow *parent_window;\n    gboolean target_is_mapping;\n    gboolean have_nonmapping_source;\n\n    dest = NULL;\n    target_is_mapping = FALSE;\n    have_nonmapping_source = FALSE;\n\n    if (target_dir)\n    {\n        dest = g_file_new_for_uri (target_dir);\n        if (g_file_has_uri_scheme (dest, \"burn\"))\n        {\n            target_is_mapping = TRUE;\n        }\n    }\n\n    locations = location_list_from_uri_list (item_uris);\n\n    for (p = locations; p != NULL; p = p->next)\n    {\n        if (!g_file_has_uri_scheme ((GFile * ) p->data, \"burn\"))\n        {\n            have_nonmapping_source = TRUE;\n        }\n    }\n\n    if (target_is_mapping && have_nonmapping_source && copy_action == GDK_ACTION_MOVE)\n    {\n        /* never move to \"burn:///\", but fall back to copy.\n         * This is a workaround, because otherwise the source files would be removed.\n         */\n        copy_action = GDK_ACTION_COPY;\n    }\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    if (copy_action == GDK_ACTION_COPY)\n    {\n        src_dir = g_file_get_parent (locations->data);\n        if (target_dir == NULL ||\n            (src_dir != NULL &&\n             g_file_equal (src_dir, dest)))\n        {\n            nautilus_file_operations_duplicate (locations,\n                                                relative_item_points,\n                                                parent_window,\n                                                done_callback, done_callback_data);\n        }\n        else\n        {\n            nautilus_file_operations_copy (locations,\n                                           relative_item_points,\n                                           dest,\n                                           parent_window,\n                                           done_callback, done_callback_data);\n        }\n        if (src_dir)\n        {\n            g_object_unref (src_dir);\n        }\n    }\n    else if (copy_action == GDK_ACTION_MOVE)\n    {\n        if (g_file_has_uri_scheme (dest, \"trash\"))\n        {\n            MoveTrashCBData *cb_data;\n\n            cb_data = g_slice_new0 (MoveTrashCBData);\n            cb_data->real_callback = done_callback;\n            cb_data->real_data = done_callback_data;\n\n            nautilus_file_operations_trash_or_delete (locations,\n                                                      parent_window,\n                                                      (NautilusDeleteCallback) callback_for_move_to_trash,\n                                                      cb_data);\n        }\n        else\n        {\n            nautilus_file_operations_move (locations,\n                                           relative_item_points,\n                                           dest,\n                                           parent_window,\n                                           done_callback, done_callback_data);\n        }\n    }\n    else\n    {\n        nautilus_file_operations_link (locations,\n                                       relative_item_points,\n                                       dest,\n                                       parent_window,\n                                       done_callback, done_callback_data);\n    }\n\n    g_list_free_full (locations, g_object_unref);\n    if (dest)\n    {\n        g_object_unref (dest);\n    }\n}\n\nstatic void\ncreate_task_done (GObject      *source_object,\n                  GAsyncResult *res,\n                  gpointer      user_data)\n{\n    CreateJob *job;\n\n    job = user_data;\n    if (job->done_callback)\n    {\n        job->done_callback (job->created_file,\n                            !job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    g_object_unref (job->dest_dir);\n    if (job->src)\n    {\n        g_object_unref (job->src);\n    }\n    g_free (job->src_data);\n    g_free (job->filename);\n    if (job->created_file)\n    {\n        g_object_unref (job->created_file);\n    }\n\n    finalize_common ((CommonJob *) job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ncreate_task_thread_func (GTask        *task,\n                         gpointer      source_object,\n                         gpointer      task_data,\n                         GCancellable *cancellable)\n{\n    CreateJob *job;\n    CommonJob *common;\n    int count;\n    GFile *dest;\n    g_autofree gchar *dest_uri = NULL;\n    char *basename;\n    char *filename, *filename2, *new_filename;\n    char *filename_base, *suffix;\n    char *dest_fs_type;\n    GError *error;\n    gboolean res;\n    gboolean filename_is_utf8;\n    char *primary, *secondary, *details;\n    int response;\n    char *data;\n    int length;\n    GFileOutputStream *out;\n    gboolean handled_invalid_filename;\n    int max_length, offset;\n\n    job = task_data;\n    common = &job->common;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    handled_invalid_filename = FALSE;\n\n    dest_fs_type = NULL;\n    filename = NULL;\n    dest = NULL;\n\n    max_length = get_max_name_length (job->dest_dir);\n\n    verify_destination (common,\n                        job->dest_dir,\n                        NULL, -1);\n    if (job_aborted (common))\n    {\n        goto aborted;\n    }\n\n    filename = g_strdup (job->filename);\n    filename_is_utf8 = FALSE;\n    if (filename)\n    {\n        filename_is_utf8 = g_utf8_validate (filename, -1, NULL);\n    }\n    if (filename == NULL)\n    {\n        if (job->make_dir)\n        {\n            /* localizers: the initial name of a new folder  */\n            filename = g_strdup (_(\"Untitled Folder\"));\n            filename_is_utf8 = TRUE;             /* Pass in utf8 */\n        }\n        else\n        {\n            if (job->src != NULL)\n            {\n                basename = g_file_get_basename (job->src);\n                /* localizers: the initial name of a new template document */\n                filename = g_strdup_printf (\"%s\", basename);\n\n                g_free (basename);\n            }\n            if (filename == NULL)\n            {\n                /* localizers: the initial name of a new empty document */\n                filename = g_strdup (_(\"Untitled Document\"));\n                filename_is_utf8 = TRUE;                 /* Pass in utf8 */\n            }\n        }\n    }\n\n    make_file_name_valid_for_dest_fs (filename, dest_fs_type);\n    if (filename_is_utf8)\n    {\n        dest = g_file_get_child_for_display_name (job->dest_dir, filename, NULL);\n    }\n    if (dest == NULL)\n    {\n        dest = g_file_get_child (job->dest_dir, filename);\n    }\n    count = 1;\n\nretry:\n\n    error = NULL;\n    if (job->make_dir)\n    {\n        res = g_file_make_directory (dest,\n                                     common->cancellable,\n                                     &error);\n\n        if (res)\n        {\n            GFile *real;\n\n            real = map_possibly_volatile_file_to_real (dest, common->cancellable, &error);\n            if (real == NULL)\n            {\n                res = FALSE;\n            }\n            else\n            {\n                g_object_unref (dest);\n                dest = real;\n            }\n        }\n\n        if (res && common->undo_info != NULL)\n        {\n            nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),\n                                                     dest, NULL, 0);\n        }\n    }\n    else\n    {\n        if (job->src)\n        {\n            res = g_file_copy (job->src,\n                               dest,\n                               G_FILE_COPY_NONE,\n                               common->cancellable,\n                               NULL, NULL,\n                               &error);\n\n            if (res)\n            {\n                GFile *real;\n\n                real = map_possibly_volatile_file_to_real (dest, common->cancellable, &error);\n                if (real == NULL)\n                {\n                    res = FALSE;\n                }\n                else\n                {\n                    g_object_unref (dest);\n                    dest = real;\n                }\n            }\n\n            if (res && common->undo_info != NULL)\n            {\n                gchar *uri;\n\n                uri = g_file_get_uri (job->src);\n                nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),\n                                                         dest, uri, 0);\n\n                g_free (uri);\n            }\n        }\n        else\n        {\n            data = \"\";\n            length = 0;\n            if (job->src_data)\n            {\n                data = job->src_data;\n                length = job->length;\n            }\n\n            out = g_file_create (dest,\n                                 G_FILE_CREATE_NONE,\n                                 common->cancellable,\n                                 &error);\n            if (out)\n            {\n                GFile *real;\n\n                real = map_possibly_volatile_file_to_real_on_write (dest,\n                                                                    out,\n                                                                    common->cancellable,\n                                                                    &error);\n                if (real == NULL)\n                {\n                    res = FALSE;\n                    g_object_unref (out);\n                }\n                else\n                {\n                    g_object_unref (dest);\n                    dest = real;\n\n                    res = g_output_stream_write_all (G_OUTPUT_STREAM (out),\n                                                     data, length,\n                                                     NULL,\n                                                     common->cancellable,\n                                                     &error);\n                    if (res)\n                    {\n                        res = g_output_stream_close (G_OUTPUT_STREAM (out),\n                                                     common->cancellable,\n                                                     &error);\n\n                        if (res && common->undo_info != NULL)\n                        {\n                            nautilus_file_undo_info_create_set_data (NAUTILUS_FILE_UNDO_INFO_CREATE (common->undo_info),\n                                                                     dest, data, length);\n                        }\n                    }\n\n                    /* This will close if the write failed and we didn't close */\n                    g_object_unref (out);\n                }\n            }\n            else\n            {\n                res = FALSE;\n            }\n        }\n    }\n\n    if (res)\n    {\n        job->created_file = g_object_ref (dest);\n        nautilus_file_changes_queue_file_added (dest);\n        dest_uri = g_file_get_uri (dest);\n        if (job->has_position)\n        {\n            nautilus_file_changes_queue_schedule_position_set (dest, job->position, common->screen_num);\n        }\n        else if (eel_uri_is_desktop (dest_uri))\n        {\n            nautilus_file_changes_queue_schedule_position_remove (dest);\n        }\n    }\n    else\n    {\n        g_assert (error != NULL);\n\n        if (IS_IO_ERROR (error, INVALID_FILENAME) &&\n            !handled_invalid_filename)\n        {\n            handled_invalid_filename = TRUE;\n\n            g_assert (dest_fs_type == NULL);\n            dest_fs_type = query_fs_type (job->dest_dir, common->cancellable);\n\n            if (count == 1)\n            {\n                new_filename = g_strdup (filename);\n            }\n            else\n            {\n                filename_base = eel_filename_strip_extension (filename);\n                offset = strlen (filename_base);\n                suffix = g_strdup (filename + offset);\n\n                filename2 = g_strdup_printf (\"%s %d%s\", filename_base, count, suffix);\n\n                new_filename = NULL;\n                if (max_length > 0 && strlen (filename2) > max_length)\n                {\n                    new_filename = shorten_utf8_string (filename2, strlen (filename2) - max_length);\n                }\n\n                if (new_filename == NULL)\n                {\n                    new_filename = g_strdup (filename2);\n                }\n\n                g_free (filename2);\n                g_free (suffix);\n            }\n\n            if (make_file_name_valid_for_dest_fs (new_filename, dest_fs_type))\n            {\n                g_object_unref (dest);\n\n                if (filename_is_utf8)\n                {\n                    dest = g_file_get_child_for_display_name (job->dest_dir, new_filename, NULL);\n                }\n                if (dest == NULL)\n                {\n                    dest = g_file_get_child (job->dest_dir, new_filename);\n                }\n\n                g_free (new_filename);\n                g_error_free (error);\n                goto retry;\n            }\n            g_free (new_filename);\n        }\n\n        if (IS_IO_ERROR (error, EXISTS))\n        {\n            g_object_unref (dest);\n            dest = NULL;\n            filename_base = eel_filename_strip_extension (filename);\n            offset = strlen (filename_base);\n            suffix = g_strdup (filename + offset);\n\n            filename2 = g_strdup_printf (\"%s %d%s\", filename_base, ++count, suffix);\n\n            if (max_length > 0 && strlen (filename2) > max_length)\n            {\n                new_filename = shorten_utf8_string (filename2, strlen (filename2) - max_length);\n                if (new_filename != NULL)\n                {\n                    g_free (filename2);\n                    filename2 = new_filename;\n                }\n            }\n\n            make_file_name_valid_for_dest_fs (filename2, dest_fs_type);\n            if (filename_is_utf8)\n            {\n                dest = g_file_get_child_for_display_name (job->dest_dir, filename2, NULL);\n            }\n            if (dest == NULL)\n            {\n                dest = g_file_get_child (job->dest_dir, filename2);\n            }\n            g_free (filename2);\n            g_free (suffix);\n            g_error_free (error);\n            goto retry;\n        }\n        else if (IS_IO_ERROR (error, CANCELLED))\n        {\n            g_error_free (error);\n        }\n        /* Other error */\n        else\n        {\n            if (job->make_dir)\n            {\n                primary = f (_(\"Error while creating directory %B.\"), dest);\n            }\n            else\n            {\n                primary = f (_(\"Error while creating file %B.\"), dest);\n            }\n            secondary = f (_(\"There was an error creating the directory in %F.\"), job->dest_dir);\n            details = error->message;\n\n            response = run_warning (common,\n                                    primary,\n                                    secondary,\n                                    details,\n                                    FALSE,\n                                    CANCEL, SKIP,\n                                    NULL);\n\n            g_error_free (error);\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)                 /* skip */\n            {                   /* do nothing */\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n        }\n    }\n\naborted:\n    if (dest)\n    {\n        g_object_unref (dest);\n    }\n    g_free (filename);\n    g_free (dest_fs_type);\n}\n\nvoid\nnautilus_file_operations_new_folder (GtkWidget              *parent_view,\n                                     GdkPoint               *target_point,\n                                     const char             *parent_dir,\n                                     const char             *folder_name,\n                                     NautilusCreateCallback  done_callback,\n                                     gpointer                done_callback_data)\n{\n    GTask *task;\n    CreateJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (CreateJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->dest_dir = g_file_new_for_uri (parent_dir);\n    job->filename = g_strdup (folder_name);\n    job->make_dir = TRUE;\n    if (target_point != NULL)\n    {\n        job->position = *target_point;\n        job->has_position = TRUE;\n    }\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_FOLDER);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, create_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_new_file_from_template (GtkWidget              *parent_view,\n                                                 GdkPoint               *target_point,\n                                                 const char             *parent_dir,\n                                                 const char             *target_filename,\n                                                 const char             *template_uri,\n                                                 NautilusCreateCallback  done_callback,\n                                                 gpointer                done_callback_data)\n{\n    GTask *task;\n    CreateJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (CreateJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->dest_dir = g_file_new_for_uri (parent_dir);\n    if (target_point != NULL)\n    {\n        job->position = *target_point;\n        job->has_position = TRUE;\n    }\n    job->filename = g_strdup (target_filename);\n\n    if (template_uri)\n    {\n        job->src = g_file_new_for_uri (template_uri);\n    }\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_FILE_FROM_TEMPLATE);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, create_task_thread_func);\n    g_object_unref (task);\n}\n\nvoid\nnautilus_file_operations_new_file (GtkWidget              *parent_view,\n                                   GdkPoint               *target_point,\n                                   const char             *parent_dir,\n                                   const char             *target_filename,\n                                   const char             *initial_contents,\n                                   int                     length,\n                                   NautilusCreateCallback  done_callback,\n                                   gpointer                done_callback_data)\n{\n    GTask *task;\n    CreateJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (CreateJob, parent_window);\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    job->dest_dir = g_file_new_for_uri (parent_dir);\n    if (target_point != NULL)\n    {\n        job->position = *target_point;\n        job->has_position = TRUE;\n    }\n    job->src_data = g_memdup (initial_contents, length);\n    job->length = length;\n    job->filename = g_strdup (target_filename);\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info = nautilus_file_undo_info_create_new (NAUTILUS_FILE_UNDO_OP_CREATE_EMPTY_FILE);\n    }\n\n    task = g_task_new (NULL, job->common.cancellable, create_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, create_task_thread_func);\n    g_object_unref (task);\n}\n\n\n\nstatic void\ndelete_trash_file (CommonJob *job,\n                   GFile     *file,\n                   gboolean   del_file,\n                   gboolean   del_children)\n{\n    GFileInfo *info;\n    GFile *child;\n    GFileEnumerator *enumerator;\n\n    if (job_aborted (job))\n    {\n        return;\n    }\n\n    if (del_children)\n    {\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                                G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                job->cancellable,\n                                                NULL);\n        if (enumerator)\n        {\n            while (!job_aborted (job) &&\n                   (info = g_file_enumerator_next_file (enumerator, job->cancellable, NULL)) != NULL)\n            {\n                child = g_file_get_child (file,\n                                          g_file_info_get_name (info));\n                delete_trash_file (job, child, TRUE,\n                                   g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY);\n                g_object_unref (child);\n                g_object_unref (info);\n            }\n            g_file_enumerator_close (enumerator, job->cancellable, NULL);\n            g_object_unref (enumerator);\n        }\n    }\n\n    if (!job_aborted (job) && del_file)\n    {\n        g_file_delete (file, job->cancellable, NULL);\n    }\n}\n\nstatic void\nempty_trash_task_done (GObject      *source_object,\n                       GAsyncResult *res,\n                       gpointer      user_data)\n{\n    EmptyTrashJob *job;\n\n    job = user_data;\n\n    g_list_free_full (job->trash_dirs, g_object_unref);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}\n\nstatic void\nempty_trash_thread_func (GTask        *task,\n                         gpointer      source_object,\n                         gpointer      task_data,\n                         GCancellable *cancellable)\n{\n    EmptyTrashJob *job = task_data;\n    CommonJob *common;\n    GList *l;\n    gboolean confirmed;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    if (job->should_confirm)\n    {\n        confirmed = confirm_empty_trash (common);\n    }\n    else\n    {\n        confirmed = TRUE;\n    }\n    if (confirmed)\n    {\n        for (l = job->trash_dirs;\n             l != NULL && !job_aborted (common);\n             l = l->next)\n        {\n            delete_trash_file (common, l->data, FALSE, TRUE);\n        }\n    }\n}\n\nvoid\nnautilus_file_operations_empty_trash (GtkWidget *parent_view)\n{\n    GTask *task;\n    EmptyTrashJob *job;\n    GtkWindow *parent_window;\n\n    parent_window = NULL;\n    if (parent_view)\n    {\n        parent_window = (GtkWindow *) gtk_widget_get_ancestor (parent_view, GTK_TYPE_WINDOW);\n    }\n\n    job = op_job_new (EmptyTrashJob, parent_window);\n    job->trash_dirs = g_list_prepend (job->trash_dirs,\n                                      g_file_new_for_uri (\"trash:\"));\n    job->should_confirm = TRUE;\n\n    inhibit_power_manager ((CommonJob *) job, _(\"Emptying Trash\"));\n\n    task = g_task_new (NULL, NULL, empty_trash_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, empty_trash_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nmark_desktop_file_executable_task_done (GObject      *source_object,\n                                        GAsyncResult *res,\n                                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n\n    g_object_unref (job->file);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}\n\n#define TRUSTED_SHEBANG \"#!/usr/bin/env xdg-open\\n\"\n\nstatic void\nmark_desktop_file_executable (CommonJob    *common,\n                              GCancellable *cancellable,\n                              GFile        *file,\n                              gboolean      interactive)\n{\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\n\nretry:\n\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}\n\nstatic void\nmark_desktop_file_executable_task_thread_func (GTask        *task,\n                                               gpointer      source_object,\n                                               gpointer      task_data,\n                                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    mark_desktop_file_executable (common,\n                                  cancellable,\n                                  job->file,\n                                  job->interactive);\n}\n\nvoid\nnautilus_file_mark_desktop_file_executable (GFile              *file,\n                                            GtkWindow          *parent_window,\n                                            gboolean            interactive,\n                                            NautilusOpCallback  done_callback,\n                                            gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n\n    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n    g_object_unref (task);\n}\n\nstatic void\nextract_task_done (GObject      *source_object,\n                   GAsyncResult *res,\n                   gpointer      user_data)\n{\n    ExtractJob *extract_job;\n\n    extract_job = user_data;\n\n    if (extract_job->done_callback)\n    {\n        extract_job->done_callback (extract_job->output_files,\n                                    extract_job->done_callback_data);\n    }\n\n    g_list_free_full (extract_job->source_files, g_object_unref);\n    g_list_free_full (extract_job->output_files, g_object_unref);\n    g_object_unref (extract_job->destination_directory);\n\n    finalize_common ((CommonJob *) extract_job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic GFile *\nextract_job_on_decide_destination (AutoarExtractor *extractor,\n                                   GFile           *destination,\n                                   GList           *files,\n                                   gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *decided_destination;\n    g_autofree char *basename = NULL;\n\n    nautilus_progress_info_set_details (extract_job->common.progress,\n                                        _(\"Verifying destination\"));\n\n    basename = g_file_get_basename (destination);\n    decided_destination = nautilus_generate_unique_file_in_directory (extract_job->destination_directory,\n                                                                      basename);\n\n    if (job_aborted ((CommonJob *) extract_job))\n    {\n        g_object_unref (decided_destination);\n        return NULL;\n    }\n\n    extract_job->output_files = g_list_prepend (extract_job->output_files,\n                                                decided_destination);\n\n    return g_object_ref (decided_destination);\n}\n\nstatic void\nextract_job_on_progress (AutoarExtractor *extractor,\n                         guint64          archive_current_decompressed_size,\n                         guint            archive_current_decompressed_files,\n                         gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    CommonJob *common = user_data;\n    GFile *source_file;\n    char *details;\n    double elapsed;\n    double transfer_rate;\n    int remaining_time;\n    guint64 archive_total_decompressed_size;\n    gdouble archive_weight;\n    gdouble archive_decompress_progress;\n    guint64 job_completed_size;\n    gdouble job_progress;\n\n    source_file = autoar_extractor_get_source_file (extractor);\n\n    nautilus_progress_info_take_status (common->progress,\n                                        f (_(\"Extracting \u201c%B\u201d\"), source_file));\n\n    archive_total_decompressed_size = autoar_extractor_get_total_size (extractor);\n\n    archive_decompress_progress = (gdouble) archive_current_decompressed_size /\n                                  (gdouble) archive_total_decompressed_size;\n\n    archive_weight = 0;\n    if (extract_job->total_compressed_size)\n    {\n        archive_weight = (gdouble) extract_job->archive_compressed_size /\n                         (gdouble) extract_job->total_compressed_size;\n    }\n\n    job_progress = archive_decompress_progress * archive_weight + extract_job->base_progress;\n\n    elapsed = g_timer_elapsed (common->time, NULL);\n\n    transfer_rate = 0;\n    remaining_time = -1;\n\n    job_completed_size = job_progress * extract_job->total_compressed_size;\n\n    if (elapsed > 0)\n    {\n        transfer_rate = job_completed_size / elapsed;\n    }\n    if (transfer_rate > 0)\n    {\n        remaining_time = (extract_job->total_compressed_size - job_completed_size) /\n                         transfer_rate;\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ||\n        transfer_rate == 0)\n    {\n        /* To translators: %S will expand to a size like \"2 bytes\" or\n         * \"3 MB\", so something like \"4 kb / 4 MB\"\n         */\n        details = f (_(\"%S / %S\"), job_completed_size, extract_job->total_compressed_size);\n    }\n    else\n    {\n        /* To translators: %S will expand to a size like \"2 bytes\" or\n         * \"3 MB\", %T to a time duration like \"2 minutes\". So the whole\n         * thing will be something like\n         * \"2 kb / 4 MB -- 2 hours left (4kb/sec)\"\n         *\n         * The singular/plural form will be used depending on the\n         * remaining time (i.e. the %T argument).\n         */\n        details = f (ngettext (\"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                               \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                               seconds_count_format_time_units (remaining_time)),\n                     job_completed_size, extract_job->total_compressed_size,\n                     remaining_time,\n                     (goffset) transfer_rate);\n    }\n\n    nautilus_progress_info_take_details (common->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (common->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (common->progress,\n                                                 elapsed);\n    }\n\n    nautilus_progress_info_set_progress (common->progress, job_progress, 1);\n}\n\nstatic void\nextract_job_on_error (AutoarExtractor *extractor,\n                      GError          *error,\n                      gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *source_file;\n    gint response_id;\n\n    source_file = autoar_extractor_get_source_file (extractor);\n\n    if (IS_IO_ERROR (error, NOT_SUPPORTED))\n    {\n        handle_unsupported_compressed_file (extract_job->common.parent_window,\n                                            source_file);\n\n        return;\n    }\n\n    nautilus_progress_info_take_status (extract_job->common.progress,\n                                        f (_(\"Error extracting \u201c%B\u201d\"),\n                                           source_file));\n\n    response_id = run_warning ((CommonJob *) extract_job,\n                               f (_(\"There was an error while extracting \u201c%B\u201d.\"),\n                                  source_file),\n                               g_strdup (error->message),\n                               NULL,\n                               FALSE,\n                               CANCEL,\n                               SKIP,\n                               NULL);\n\n    if (response_id == 0 || response_id == GTK_RESPONSE_DELETE_EVENT)\n    {\n        abort_job ((CommonJob *) extract_job);\n    }\n}\n\nstatic void\nextract_job_on_completed (AutoarExtractor *extractor,\n                          gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *output_file;\n\n    output_file = G_FILE (extract_job->output_files->data);\n\n    nautilus_file_changes_queue_file_added (output_file);\n}\n\nstatic void\nreport_extract_final_progress (ExtractJob *extract_job,\n                               gint        total_files)\n{\n    char *status;\n\n    nautilus_progress_info_set_destination (extract_job->common.progress,\n                                            extract_job->destination_directory);\n\n    if (total_files == 1)\n    {\n        GFile *source_file;\n\n        source_file = G_FILE (extract_job->source_files->data);\n        status = f (_(\"Extracted \u201c%B\u201d to \u201c%B\u201d\"),\n                    source_file,\n                    extract_job->destination_directory);\n    }\n    else\n    {\n        status = f (ngettext (\"Extracted %'d file to \u201c%B\u201d\",\n                              \"Extracted %'d files to \u201c%B\u201d\",\n                              total_files),\n                    total_files,\n                    extract_job->destination_directory);\n    }\n\n    nautilus_progress_info_take_status (extract_job->common.progress,\n                                        status);\n    nautilus_progress_info_take_details (extract_job->common.progress,\n                                         f (_(\"%S / %S\"),\n                                            extract_job->total_compressed_size,\n                                            extract_job->total_compressed_size));\n}\n\nstatic void\nextract_task_thread_func (GTask        *task,\n                          gpointer      source_object,\n                          gpointer      task_data,\n                          GCancellable *cancellable)\n{\n    ExtractJob *extract_job = task_data;\n    GList *l;\n    GList *existing_output_files = NULL;\n    gint total_files;\n    g_autofree guint64 *archive_compressed_sizes = NULL;\n    gint i;\n\n    g_timer_start (extract_job->common.time);\n\n    nautilus_progress_info_start (extract_job->common.progress);\n\n    nautilus_progress_info_set_details (extract_job->common.progress,\n                                        _(\"Preparing to extract\"));\n\n    total_files = g_list_length (extract_job->source_files);\n\n    archive_compressed_sizes = g_malloc0_n (total_files, sizeof (guint64));\n    extract_job->total_compressed_size = 0;\n\n    for (l = extract_job->source_files, i = 0;\n         l != NULL && !job_aborted ((CommonJob *) extract_job);\n         l = l->next, i++)\n    {\n        GFile *source_file;\n        g_autoptr (GFileInfo) info = NULL;\n\n        source_file = G_FILE (l->data);\n        info = g_file_query_info (source_file,\n                                  G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                  extract_job->common.cancellable,\n                                  NULL);\n\n        if (info)\n        {\n            archive_compressed_sizes[i] = g_file_info_get_size (info);\n            extract_job->total_compressed_size += archive_compressed_sizes[i];\n        }\n    }\n\n    extract_job->base_progress = 0;\n\n    for (l = extract_job->source_files, i = 0;\n         l != NULL && !job_aborted ((CommonJob *) extract_job);\n         l = l->next, i++)\n    {\n        g_autoptr (AutoarExtractor) extractor = NULL;\n\n        extractor = autoar_extractor_new (G_FILE (l->data),\n                                          extract_job->destination_directory);\n\n        autoar_extractor_set_notify_interval (extractor,\n                                              PROGRESS_NOTIFY_INTERVAL);\n\n        g_signal_connect (extractor, \"error\",\n                          G_CALLBACK (extract_job_on_error),\n                          extract_job);\n        g_signal_connect (extractor, \"decide-destination\",\n                          G_CALLBACK (extract_job_on_decide_destination),\n                          extract_job);\n        g_signal_connect (extractor, \"progress\",\n                          G_CALLBACK (extract_job_on_progress),\n                          extract_job);\n        g_signal_connect (extractor, \"completed\",\n                          G_CALLBACK (extract_job_on_completed),\n                          extract_job);\n\n        extract_job->archive_compressed_size = archive_compressed_sizes[i];\n\n        autoar_extractor_start (extractor,\n                                extract_job->common.cancellable);\n\n        g_signal_handlers_disconnect_by_data (extractor,\n                                              extract_job);\n\n        extract_job->base_progress += (gdouble) extract_job->archive_compressed_size /\n                                      (gdouble) extract_job->total_compressed_size;\n    }\n\n    if (!job_aborted ((CommonJob *) extract_job))\n    {\n        report_extract_final_progress (extract_job, total_files);\n    }\n\n    for (l = extract_job->output_files; l != NULL; l = l->next)\n    {\n        GFile *output_file;\n\n        output_file = G_FILE (l->data);\n\n        if (g_file_query_exists (output_file, NULL))\n        {\n            existing_output_files = g_list_prepend (existing_output_files,\n                                                    g_object_ref (output_file));\n        }\n    }\n\n    g_list_free_full (extract_job->output_files, g_object_unref);\n\n    extract_job->output_files = existing_output_files;\n\n    if (extract_job->common.undo_info)\n    {\n        if (extract_job->output_files)\n        {\n            NautilusFileUndoInfoExtract *undo_info;\n\n            undo_info = NAUTILUS_FILE_UNDO_INFO_EXTRACT (extract_job->common.undo_info);\n\n            nautilus_file_undo_info_extract_set_outputs (undo_info,\n                                                         extract_job->output_files);\n        }\n        else\n        {\n            /* There is nothing to undo if there is no output */\n            g_clear_object (&extract_job->common.undo_info);\n        }\n    }\n}\n\nvoid\nnautilus_file_operations_extract_files (GList                   *files,\n                                        GFile                   *destination_directory,\n                                        GtkWindow               *parent_window,\n                                        NautilusExtractCallback  done_callback,\n                                        gpointer                 done_callback_data)\n{\n    ExtractJob *extract_job;\n    g_autoptr (GTask) task = NULL;\n\n    extract_job = op_job_new (ExtractJob, parent_window);\n    extract_job->source_files = g_list_copy_deep (files,\n                                                  (GCopyFunc) g_object_ref,\n                                                  NULL);\n    extract_job->destination_directory = g_object_ref (destination_directory);\n    extract_job->done_callback = done_callback;\n    extract_job->done_callback_data = done_callback_data;\n\n    inhibit_power_manager ((CommonJob *) extract_job, _(\"Extracting Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        extract_job->common.undo_info = nautilus_file_undo_info_extract_new (files,\n                                                                             destination_directory);\n    }\n\n    task = g_task_new (NULL, extract_job->common.cancellable,\n                       extract_task_done, extract_job);\n    g_task_set_task_data (task, extract_job, NULL);\n    g_task_run_in_thread (task, extract_task_thread_func);\n}\n\nstatic void\ncompress_task_done (GObject      *source_object,\n                    GAsyncResult *res,\n                    gpointer      user_data)\n{\n    CompressJob *compress_job = user_data;\n\n    if (compress_job->done_callback)\n    {\n        compress_job->done_callback (compress_job->output_file,\n                                     compress_job->success,\n                                     compress_job->done_callback_data);\n    }\n\n    g_object_unref (compress_job->output_file);\n    g_list_free_full (compress_job->source_files, g_object_unref);\n\n    finalize_common ((CommonJob *) compress_job);\n\n    nautilus_file_changes_consume_changes (TRUE);\n}\n\nstatic void\ncompress_job_on_progress (AutoarCompressor *compressor,\n                          guint64           completed_size,\n                          guint             completed_files,\n                          gpointer          user_data)\n{\n    CompressJob *compress_job = user_data;\n    CommonJob *common = user_data;\n    char *status;\n    char *details;\n    int files_left;\n    double elapsed;\n    double transfer_rate;\n    int remaining_time;\n\n    files_left = compress_job->total_files - completed_files;\n\n    if (compress_job->total_files == 1)\n    {\n        status = f (_(\"Compressing \u201c%B\u201d into \u201c%B\u201d\"),\n                    G_FILE (compress_job->source_files->data),\n                    compress_job->output_file);\n    }\n    else\n    {\n        status = f (ngettext (\"Compressing %'d file into \u201c%B\u201d\",\n                              \"Compressing %'d files into \u201c%B\u201d\",\n                              compress_job->total_files),\n                    compress_job->total_files,\n                    compress_job->output_file);\n    }\n\n    nautilus_progress_info_take_status (common->progress, status);\n\n    elapsed = g_timer_elapsed (common->time, NULL);\n\n    transfer_rate = 0;\n    remaining_time = -1;\n\n    if (elapsed > 0)\n    {\n        if (completed_size > 0)\n        {\n            transfer_rate = completed_size / elapsed;\n            remaining_time = (compress_job->total_size - completed_size) / transfer_rate;\n        }\n        else if (completed_files > 0)\n        {\n            transfer_rate = completed_files / elapsed;\n            remaining_time = (compress_job->total_files - completed_files) / transfer_rate;\n        }\n    }\n\n    if (elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE ||\n        transfer_rate == 0)\n    {\n        if (compress_job->total_files == 1)\n        {\n            /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", so something like \"4 kb / 4 MB\" */\n            details = f (_(\"%S / %S\"), completed_size, compress_job->total_size);\n        }\n        else\n        {\n            details = f (_(\"%'d / %'d\"),\n                         files_left > 0 ? completed_files + 1 : completed_files,\n                         compress_job->total_files);\n        }\n    }\n    else\n    {\n        if (compress_job->total_files == 1)\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\", %T to a time duration like\n                 * \"2 minutes\". So the whole thing will be something like \"2 kb / 4 MB -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             completed_size, compress_job->total_size,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %S will expand to a size like \"2 bytes\" or \"3 MB\". */\n                details = f (_(\"%S / %S\"),\n                             completed_size,\n                             compress_job->total_size);\n            }\n        }\n        else\n        {\n            if (files_left > 0)\n            {\n                /* To translators: %T will expand to a time duration like \"2 minutes\".\n                 * So the whole thing will be something like \"1 / 5 -- 2 hours left (4kb/sec)\"\n                 *\n                 * The singular/plural form will be used depending on the remaining time (i.e. the %T argument).\n                 */\n                details = f (ngettext (\"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       \"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\",\n                                       seconds_count_format_time_units (remaining_time)),\n                             completed_files + 1, compress_job->total_files,\n                             remaining_time,\n                             (goffset) transfer_rate);\n            }\n            else\n            {\n                /* To translators: %'d is the number of files completed for the operation,\n                 * so it will be something like 2/14. */\n                details = f (_(\"%'d / %'d\"),\n                             completed_files,\n                             compress_job->total_files);\n            }\n        }\n    }\n\n    nautilus_progress_info_take_details (common->progress, details);\n\n    if (elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE)\n    {\n        nautilus_progress_info_set_remaining_time (common->progress,\n                                                   remaining_time);\n        nautilus_progress_info_set_elapsed_time (common->progress,\n                                                 elapsed);\n    }\n\n    nautilus_progress_info_set_progress (common->progress,\n                                         completed_size,\n                                         compress_job->total_size);\n}\n\nstatic void\ncompress_job_on_error (AutoarCompressor *compressor,\n                       GError           *error,\n                       gpointer          user_data)\n{\n    CompressJob *compress_job = user_data;\n    char *status;\n\n    if (compress_job->total_files == 1)\n    {\n        status = f (_(\"Error compressing \u201c%B\u201d into \u201c%B\u201d\"),\n                    G_FILE (compress_job->source_files->data),\n                    compress_job->output_file);\n    }\n    else\n    {\n        status = f (ngettext (\"Error compressing %'d file into \u201c%B\u201d\",\n                              \"Error compressing %'d files into \u201c%B\u201d\",\n                              compress_job->total_files),\n                    compress_job->total_files,\n                    compress_job->output_file);\n    }\n\n    nautilus_progress_info_take_status (compress_job->common.progress,\n                                        status);\n\n    run_error ((CommonJob *) compress_job,\n               g_strdup (_(\"There was an error while compressing files.\")),\n               g_strdup (error->message),\n               NULL,\n               FALSE,\n               CANCEL,\n               NULL);\n\n    abort_job ((CommonJob *) compress_job);\n}\n\nstatic void\ncompress_job_on_completed (AutoarCompressor *compressor,\n                           gpointer          user_data)\n{\n    CompressJob *compress_job = user_data;\n    g_autoptr (GFile) destination_directory = NULL;\n    char *status;\n\n    if (compress_job->total_files == 1)\n    {\n        status = f (_(\"Compressed \u201c%B\u201d into \u201c%B\u201d\"),\n                    G_FILE (compress_job->source_files->data),\n                    compress_job->output_file);\n    }\n    else\n    {\n        status = f (ngettext (\"Compressed %'d file into \u201c%B\u201d\",\n                              \"Compressed %'d files into \u201c%B\u201d\",\n                              compress_job->total_files),\n                    compress_job->total_files,\n                    compress_job->output_file);\n    }\n\n    nautilus_progress_info_take_status (compress_job->common.progress,\n                                        status);\n\n    nautilus_file_changes_queue_file_added (compress_job->output_file);\n\n    destination_directory = g_file_get_parent (compress_job->output_file);\n    nautilus_progress_info_set_destination (compress_job->common.progress,\n                                            destination_directory);\n}\n\nstatic void\ncompress_task_thread_func (GTask        *task,\n                           gpointer      source_object,\n                           gpointer      task_data,\n                           GCancellable *cancellable)\n{\n    CompressJob *compress_job = task_data;\n    SourceInfo source_info;\n    g_autoptr (AutoarCompressor) compressor = NULL;\n\n    g_timer_start (compress_job->common.time);\n\n    nautilus_progress_info_start (compress_job->common.progress);\n\n    scan_sources (compress_job->source_files,\n                  &source_info,\n                  (CommonJob *) compress_job,\n                  OP_KIND_COMPRESS);\n\n    compress_job->total_files = source_info.num_files;\n    compress_job->total_size = source_info.num_bytes;\n\n    compressor = autoar_compressor_new (compress_job->source_files,\n                                        compress_job->output_file,\n                                        compress_job->format,\n                                        compress_job->filter,\n                                        FALSE);\n\n    autoar_compressor_set_output_is_dest (compressor, TRUE);\n\n    autoar_compressor_set_notify_interval (compressor,\n                                           PROGRESS_NOTIFY_INTERVAL);\n\n    g_signal_connect (compressor, \"progress\",\n                      G_CALLBACK (compress_job_on_progress), compress_job);\n    g_signal_connect (compressor, \"error\",\n                      G_CALLBACK (compress_job_on_error), compress_job);\n    g_signal_connect (compressor, \"completed\",\n                      G_CALLBACK (compress_job_on_completed), compress_job);\n    autoar_compressor_start (compressor,\n                             compress_job->common.cancellable);\n\n    compress_job->success = g_file_query_exists (compress_job->output_file,\n                                                 NULL);\n\n    /* There is nothing to undo if the output was not created */\n    if (compress_job->common.undo_info != NULL && !compress_job->success)\n    {\n        g_clear_object (&compress_job->common.undo_info);\n    }\n}\n\nvoid\nnautilus_file_operations_compress (GList                  *files,\n                                   GFile                  *output,\n                                   AutoarFormat            format,\n                                   AutoarFilter            filter,\n                                   GtkWindow              *parent_window,\n                                   NautilusCreateCallback  done_callback,\n                                   gpointer                done_callback_data)\n{\n    g_autoptr (GTask) task = NULL;\n    CompressJob *compress_job;\n\n    compress_job = op_job_new (CompressJob, parent_window);\n    compress_job->source_files = g_list_copy_deep (files,\n                                                   (GCopyFunc) g_object_ref,\n                                                   NULL);\n    compress_job->output_file = g_object_ref (output);\n    compress_job->format = format;\n    compress_job->filter = filter;\n    compress_job->done_callback = done_callback;\n    compress_job->done_callback_data = done_callback_data;\n\n    inhibit_power_manager ((CommonJob *) compress_job, _(\"Compressing Files\"));\n\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        compress_job->common.undo_info = nautilus_file_undo_info_compress_new (files,\n                                                                               output,\n                                                                               format,\n                                                                               filter);\n    }\n\n    task = g_task_new (NULL, compress_job->common.cancellable,\n                       compress_task_done, compress_job);\n    g_task_set_task_data (task, compress_job, NULL);\n    g_task_run_in_thread (task, compress_task_thread_func);\n}\n\n#if !defined (NAUTILUS_OMIT_SELF_CHECK)\n\nvoid\nnautilus_self_check_file_operations (void)\n{\n    setlocale (LC_MESSAGES, \"C\");\n\n\n    /* test the next duplicate name generator */\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\" (copy)\", 1, -1), \" (another copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo\", 1, -1), \"foo (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\".bashrc\", 1, -1), \".bashrc (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\".foo.txt\", 1, -1), \".foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo\", 1, -1), \"foo foo (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo.txt\", 1, -1), \"foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo.txt\", 1, -1), \"foo foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo.txt txt\", 1, -1), \"foo foo (copy).txt txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo...txt\", 1, -1), \"foo.. (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo...\", 1, -1), \"foo... (copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo. (copy)\", 1, -1), \"foo. (another copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (copy)\", 1, -1), \"foo (another copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (copy).txt\", 1, -1), \"foo (another copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (another copy)\", 1, -1), \"foo (3rd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (another copy).txt\", 1, -1), \"foo (3rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (another copy).txt\", 1, -1), \"foo foo (3rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (13th copy)\", 1, -1), \"foo (14th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (13th copy).txt\", 1, -1), \"foo (14th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (21st copy)\", 1, -1), \"foo (22nd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (21st copy).txt\", 1, -1), \"foo (22nd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (22nd copy)\", 1, -1), \"foo (23rd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (22nd copy).txt\", 1, -1), \"foo (23rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (23rd copy)\", 1, -1), \"foo (24th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (23rd copy).txt\", 1, -1), \"foo (24th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (24th copy)\", 1, -1), \"foo (25th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (24th copy).txt\", 1, -1), \"foo (25th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (24th copy)\", 1, -1), \"foo foo (25th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (24th copy).txt\", 1, -1), \"foo foo (25th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo foo (100000000000000th copy).txt\", 1, -1), \"foo foo (copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (10th copy)\", 1, -1), \"foo (11th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (10th copy).txt\", 1, -1), \"foo (11th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (11th copy)\", 1, -1), \"foo (12th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (11th copy).txt\", 1, -1), \"foo (12th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (12th copy)\", 1, -1), \"foo (13th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (12th copy).txt\", 1, -1), \"foo (13th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (110th copy)\", 1, -1), \"foo (111th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (110th copy).txt\", 1, -1), \"foo (111th copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (122nd copy)\", 1, -1), \"foo (123rd copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (122nd copy).txt\", 1, -1), \"foo (123rd copy).txt\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (123rd copy)\", 1, -1), \"foo (124th copy)\");\n    EEL_CHECK_STRING_RESULT (get_duplicate_name (\"foo (123rd copy).txt\", 1, -1), \"foo (124th copy).txt\");\n\n    setlocale (LC_MESSAGES, \"\");\n}\n\n#endif\n", "\n/* nautilus-file-operations: execute file operations.\n\n   Copyright (C) 1999, 2000 Free Software Foundation\n   Copyright (C) 2000, 2001 Eazel, Inc.\n\n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n   \n   You should have received a copy of the GNU General Public\n   License along with this program; if not, see <http://www.gnu.org/licenses/>.\n   \n   Authors: Ettore Perazzoli <ettore@gnu.org>,\n            Pavel Cisler <pavel@eazel.com>\n*/\n\n#ifndef NAUTILUS_FILE_OPERATIONS_H\n#define NAUTILUS_FILE_OPERATIONS_H\n\n#include <gtk/gtk.h>\n#include <gio/gio.h>\n#include <gnome-autoar/gnome-autoar.h>\n\n\n#define SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE 1\n\ntypedef void (* NautilusCopyCallback)      (GHashTable *debuting_uris,\n\t\t\t\t\t    gboolean    success,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusCreateCallback)    (GFile      *new_file,\n\t\t\t\t\t    gboolean    success,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusOpCallback)        (gboolean    success,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusDeleteCallback)    (GHashTable *debuting_uris,\n\t\t\t\t\t    gboolean    user_cancel,\n\t\t\t\t\t    gpointer    callback_data);\ntypedef void (* NautilusMountCallback)     (GVolume    *volume,\n\t\t\t\t\t    gboolean    success,\n\t\t\t\t\t    GObject    *callback_data_object);\ntypedef void (* NautilusUnmountCallback)   (gpointer    callback_data);\ntypedef void (* NautilusExtractCallback)   (GList    *outputs,\n                                            gpointer  callback_data);\n\n/* FIXME: int copy_action should be an enum */\n\nvoid nautilus_file_operations_copy_move   (const GList               *item_uris,\n\t\t\t\t\t   GArray                    *relative_item_points,\n\t\t\t\t\t   const char                *target_dir_uri,\n\t\t\t\t\t   GdkDragAction              copy_action,\n\t\t\t\t\t   GtkWidget                 *parent_view,\n\t\t\t\t\t   NautilusCopyCallback       done_callback,\n\t\t\t\t\t   gpointer                   done_callback_data);\nvoid nautilus_file_operations_copy_file (GFile *source_file,\n\t\t\t\t\t GFile *target_dir,\n\t\t\t\t\t const gchar *source_display_name,\n\t\t\t\t\t const gchar *new_name,\n\t\t\t\t\t GtkWindow *parent_window,\n\t\t\t\t\t NautilusCopyCallback done_callback,\n\t\t\t\t\t gpointer done_callback_data);\nvoid nautilus_file_operations_empty_trash (GtkWidget                 *parent_view);\nvoid nautilus_file_operations_new_folder  (GtkWidget                 *parent_view,\n\t\t\t\t\t   GdkPoint                  *target_point,\n\t\t\t\t\t   const char                *parent_dir_uri,\n\t\t\t\t\t   const char                *folder_name,\n\t\t\t\t\t   NautilusCreateCallback     done_callback,\n\t\t\t\t\t   gpointer                   done_callback_data);\nvoid nautilus_file_operations_new_file    (GtkWidget                 *parent_view,\n\t\t\t\t\t   GdkPoint                  *target_point,\n\t\t\t\t\t   const char                *parent_dir,\n\t\t\t\t\t   const char                *target_filename,\n\t\t\t\t\t   const char                *initial_contents,\n\t\t\t\t\t   int                        length,\n\t\t\t\t\t   NautilusCreateCallback     done_callback,\n\t\t\t\t\t   gpointer                   data);\nvoid nautilus_file_operations_new_file_from_template (GtkWidget               *parent_view,\n\t\t\t\t\t   \t      GdkPoint                *target_point,\n\t\t\t\t\t\t      const char              *parent_dir,\n\t\t\t\t\t\t      const char              *target_filename,\n\t\t\t\t\t\t      const char              *template_uri,\n\t\t\t\t\t\t      NautilusCreateCallback   done_callback,\n\t\t\t\t\t\t      gpointer                 data);\n\nvoid nautilus_file_operations_delete          (GList                  *files,\n\t\t\t\t\t       GtkWindow              *parent_window,\n\t\t\t\t\t       NautilusDeleteCallback  done_callback,\n\t\t\t\t\t       gpointer                done_callback_data);\nvoid nautilus_file_operations_trash_or_delete (GList                  *files,\n\t\t\t\t\t       GtkWindow              *parent_window,\n\t\t\t\t\t       NautilusDeleteCallback  done_callback,\n\t\t\t\t\t       gpointer                done_callback_data);\n\nvoid nautilus_file_set_permissions_recursive (const char                     *directory,\n\t\t\t\t\t      guint32                         file_permissions,\n\t\t\t\t\t      guint32                         file_mask,\n\t\t\t\t\t      guint32                         folder_permissions,\n\t\t\t\t\t      guint32                         folder_mask,\n\t\t\t\t\t      NautilusOpCallback              callback,\n\t\t\t\t\t      gpointer                        callback_data);\n\nvoid nautilus_file_operations_unmount_mount (GtkWindow                      *parent_window,\n\t\t\t\t\t     GMount                         *mount,\n\t\t\t\t\t     gboolean                        eject,\n\t\t\t\t\t     gboolean                        check_trash);\nvoid nautilus_file_operations_unmount_mount_full (GtkWindow                 *parent_window,\n\t\t\t\t\t\t  GMount                    *mount,\n\t\t\t\t\t\t  GMountOperation           *mount_operation,\n\t\t\t\t\t\t  gboolean                   eject,\n\t\t\t\t\t\t  gboolean                   check_trash,\n\t\t\t\t\t\t  NautilusUnmountCallback    callback,\n\t\t\t\t\t\t  gpointer                   callback_data);\nvoid nautilus_file_operations_mount_volume  (GtkWindow                      *parent_window,\n\t\t\t\t\t     GVolume                        *volume);\nvoid nautilus_file_operations_mount_volume_full (GtkWindow                      *parent_window,\n\t\t\t\t\t\t GVolume                        *volume,\n\t\t\t\t\t\t NautilusMountCallback           mount_callback,\n\t\t\t\t\t\t GObject                        *mount_callback_data_object);\n\nvoid nautilus_file_operations_copy      (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GFile                *target_dir,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_operations_move      (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GFile                *target_dir,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_operations_duplicate (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_operations_link      (GList                *files,\n\t\t\t\t\t GArray               *relative_item_points,\n\t\t\t\t\t GFile                *target_dir,\n\t\t\t\t\t GtkWindow            *parent_window,\n\t\t\t\t\t NautilusCopyCallback  done_callback,\n\t\t\t\t\t gpointer              done_callback_data);\nvoid nautilus_file_mark_desktop_file_executable (GFile           *file,\n                                                 GtkWindow        *parent_window,\n                                                 gboolean          interactive,\n                                                 NautilusOpCallback done_callback,\n                                                 gpointer          done_callback_data);\nvoid nautilus_file_operations_extract_files (GList                   *files,\n                                             GFile                   *destination_directory,\n                                             GtkWindow               *parent_window,\n                                             NautilusExtractCallback  done_callback,\n                                             gpointer                 done_callback_data);\nvoid nautilus_file_operations_compress (GList                  *files,\n                                        GFile                  *output,\n                                        AutoarFormat            format,\n                                        AutoarFilter            filter,\n                                        GtkWindow              *parent_window,\n                                        NautilusCreateCallback  done_callback,\n                                        gpointer                done_callback_data);\n\n\n#endif /* NAUTILUS_FILE_OPERATIONS_H */\n", "/* nautilus-metadata.c - metadata utils\n *\n * Copyright (C) 2009 Red Hatl, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include \"nautilus-metadata.h\"\n#include <glib.h>\n\nstatic char *used_metadata_names[] =\n{\n    NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_COLOR,\n    NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_IMAGE,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_AUTO_LAYOUT,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_BY,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_REVERSED,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_KEEP_ALIGNED,\n    NAUTILUS_METADATA_KEY_ICON_VIEW_LAYOUT_TIMESTAMP,\n    NAUTILUS_METADATA_KEY_DESKTOP_ICON_SIZE,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_COLUMN,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_REVERSED,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_VISIBLE_COLUMNS,\n    NAUTILUS_METADATA_KEY_LIST_VIEW_COLUMN_ORDER,\n    NAUTILUS_METADATA_KEY_WINDOW_GEOMETRY,\n    NAUTILUS_METADATA_KEY_WINDOW_SCROLL_POSITION,\n    NAUTILUS_METADATA_KEY_WINDOW_SHOW_HIDDEN_FILES,\n    NAUTILUS_METADATA_KEY_WINDOW_MAXIMIZED,\n    NAUTILUS_METADATA_KEY_WINDOW_STICKY,\n    NAUTILUS_METADATA_KEY_WINDOW_KEEP_ABOVE,\n    NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_COLOR,\n    NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_IMAGE,\n    NAUTILUS_METADATA_KEY_SIDEBAR_BUTTONS,\n    NAUTILUS_METADATA_KEY_ANNOTATION,\n    NAUTILUS_METADATA_KEY_ICON_POSITION,\n    NAUTILUS_METADATA_KEY_ICON_POSITION_TIMESTAMP,\n    NAUTILUS_METADATA_KEY_ICON_SCALE,\n    NAUTILUS_METADATA_KEY_CUSTOM_ICON,\n    NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME,\n    NAUTILUS_METADATA_KEY_SCREEN,\n    NAUTILUS_METADATA_KEY_EMBLEMS,\n    NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n    NULL\n};\n\nguint\nnautilus_metadata_get_id (const char *metadata)\n{\n    static GHashTable *hash;\n    int i;\n\n    if (hash == NULL)\n    {\n        hash = g_hash_table_new (g_str_hash, g_str_equal);\n        for (i = 0; used_metadata_names[i] != NULL; i++)\n        {\n            g_hash_table_insert (hash,\n                                 used_metadata_names[i],\n                                 GINT_TO_POINTER (i + 1));\n        }\n    }\n\n    return GPOINTER_TO_INT (g_hash_table_lookup (hash, metadata));\n}\n", "/*\n   nautilus-metadata.h: #defines and other metadata-related info\n \n   Copyright (C) 2000 Eazel, Inc.\n  \n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n  \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n  \n   You should have received a copy of the GNU General Public\n   License along with this program; if not, see <http://www.gnu.org/licenses/>.\n  \n   Author: John Sullivan <sullivan@eazel.com>\n*/\n\n#ifndef NAUTILUS_METADATA_H\n#define NAUTILUS_METADATA_H\n\n/* Keys for getting/setting Nautilus metadata. All metadata used in Nautilus\n * should define its key here, so we can keep track of the whole set easily.\n * Any updates here needs to be added in nautilus-metadata.c too.\n */\n\n#include <glib.h>\n\n/* Per-file */\n\n#define NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_COLOR \t\"folder-background-color\"\n#define NAUTILUS_METADATA_KEY_LOCATION_BACKGROUND_IMAGE \t\"folder-background-image\"\n\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_AUTO_LAYOUT      \t\"nautilus-icon-view-auto-layout\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_BY          \t\"nautilus-icon-view-sort-by\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_SORT_REVERSED    \t\"nautilus-icon-view-sort-reversed\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_KEEP_ALIGNED            \"nautilus-icon-view-keep-aligned\"\n#define NAUTILUS_METADATA_KEY_ICON_VIEW_LAYOUT_TIMESTAMP\t\"nautilus-icon-view-layout-timestamp\"\n\n#define NAUTILUS_METADATA_KEY_DESKTOP_ICON_SIZE           \"nautilus-desktop-icon-size\"\n\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_COLUMN      \t\"nautilus-list-view-sort-column\"\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_SORT_REVERSED    \t\"nautilus-list-view-sort-reversed\"\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_VISIBLE_COLUMNS    \t\"nautilus-list-view-visible-columns\"\n#define NAUTILUS_METADATA_KEY_LIST_VIEW_COLUMN_ORDER    \t\"nautilus-list-view-column-order\"\n\n#define NAUTILUS_METADATA_KEY_WINDOW_GEOMETRY\t\t\t\"nautilus-window-geometry\"\n#define NAUTILUS_METADATA_KEY_WINDOW_SCROLL_POSITION\t\t\"nautilus-window-scroll-position\"\n#define NAUTILUS_METADATA_KEY_WINDOW_SHOW_HIDDEN_FILES\t\t\"nautilus-window-show-hidden-files\"\n#define NAUTILUS_METADATA_KEY_WINDOW_MAXIMIZED\t\t\t\"nautilus-window-maximized\"\n#define NAUTILUS_METADATA_KEY_WINDOW_STICKY\t\t\t\"nautilus-window-sticky\"\n#define NAUTILUS_METADATA_KEY_WINDOW_KEEP_ABOVE\t\t\t\"nautilus-window-keep-above\"\n\n#define NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_COLOR   \t\"nautilus-sidebar-background-color\"\n#define NAUTILUS_METADATA_KEY_SIDEBAR_BACKGROUND_IMAGE   \t\"nautilus-sidebar-background-image\"\n#define NAUTILUS_METADATA_KEY_SIDEBAR_BUTTONS\t\t\t\"nautilus-sidebar-buttons\"\n\n#define NAUTILUS_METADATA_KEY_ICON_POSITION              \t\"nautilus-icon-position\"\n#define NAUTILUS_METADATA_KEY_ICON_POSITION_TIMESTAMP\t\t\"nautilus-icon-position-timestamp\"\n#define NAUTILUS_METADATA_KEY_ANNOTATION                 \t\"annotation\"\n#define NAUTILUS_METADATA_KEY_ICON_SCALE                 \t\"icon-scale\"\n#define NAUTILUS_METADATA_KEY_CUSTOM_ICON                \t\"custom-icon\"\n#define NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME                \t\"custom-icon-name\"\n#define NAUTILUS_METADATA_KEY_SCREEN\t\t\t\t\"screen\"\n#define NAUTILUS_METADATA_KEY_EMBLEMS\t\t\t\t\"emblems\"\n\n#define NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED\t\t\t\t\"trusted\"\n\nguint nautilus_metadata_get_id (const char *metadata);\n\n#endif /* NAUTILUS_METADATA_H */\n", "/* nautilus-mime-actions.c - uri-specific versions of mime action functions\n *\n *  Copyright (C) 2000, 2001 Eazel, Inc.\n *\n *  The Gnome Library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Library General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  The Gnome Library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Library General Public License for more details.\n *\n *  You should have received a copy of the GNU Library General Public\n *  License along with the Gnome Library; see the file COPYING.LIB.  If not,\n *  see <http://www.gnu.org/licenses/>.\n *\n *  Authors: Maciej Stachowiak <mjs@eazel.com>\n */\n\n#include <config.h>\n\n#include \"nautilus-mime-actions.h\"\n\n#include \"nautilus-window-slot.h\"\n#include \"nautilus-application.h\"\n\n#include <eel/eel-glib-extensions.h>\n#include <eel/eel-stock-dialogs.h>\n#include <eel/eel-string.h>\n#include <glib.h>\n#include <glib/gi18n.h>\n#include <glib/gstdio.h>\n#include <string.h>\n#include <gdk/gdkx.h>\n\n#include \"nautilus-file-attributes.h\"\n#include \"nautilus-file.h\"\n#include \"nautilus-file-operations.h\"\n#include \"nautilus-metadata.h\"\n#include \"nautilus-program-choosing.h\"\n#include \"nautilus-global-preferences.h\"\n#include \"nautilus-signaller.h\"\n#include \"nautilus-metadata.h\"\n\n#define DEBUG_FLAG NAUTILUS_DEBUG_MIME\n#include \"nautilus-debug.h\"\n\ntypedef enum\n{\n    ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE,\n    ACTIVATION_ACTION_ASK,\n    ACTIVATION_ACTION_LAUNCH,\n    ACTIVATION_ACTION_LAUNCH_IN_TERMINAL,\n    ACTIVATION_ACTION_OPEN_IN_VIEW,\n    ACTIVATION_ACTION_OPEN_IN_APPLICATION,\n    ACTIVATION_ACTION_EXTRACT,\n    ACTIVATION_ACTION_DO_NOTHING,\n} ActivationAction;\n\ntypedef struct\n{\n    NautilusFile *file;\n    char *uri;\n} LaunchLocation;\n\ntypedef struct\n{\n    GAppInfo *application;\n    GList *uris;\n} ApplicationLaunchParameters;\n\ntypedef struct\n{\n    NautilusWindowSlot *slot;\n    gpointer window;\n    GtkWindow *parent_window;\n    GCancellable *cancellable;\n    GList *locations;\n    GList *mountables;\n    GList *start_mountables;\n    GList *not_mounted;\n    NautilusWindowOpenFlags flags;\n    char *timed_wait_prompt;\n    gboolean timed_wait_active;\n    NautilusFileListHandle *files_handle;\n    gboolean tried_mounting;\n    char *activation_directory;\n    gboolean user_confirmation;\n} ActivateParameters;\n\nstruct\n{\n    char *name;\n    char *mimetypes[20];\n} mimetype_groups[] =\n{\n    {\n        N_(\"Anything\"),\n        { NULL }\n    },\n    {\n        N_(\"Files\"),\n        { \"application/octet-stream\",\n          \"text/plain\",\n          NULL}\n    },\n    {\n        N_(\"Folders\"),\n        { \"inode/directory\",\n          NULL}\n    },\n    { N_(\"Documents\"),\n      { \"application/rtf\",\n        \"application/msword\",\n        \"application/vnd.sun.xml.writer\",\n        \"application/vnd.sun.xml.writer.global\",\n        \"application/vnd.sun.xml.writer.template\",\n        \"application/vnd.oasis.opendocument.text\",\n        \"application/vnd.oasis.opendocument.text-template\",\n        \"application/x-abiword\",\n        \"application/x-applix-word\",\n        \"application/x-mswrite\",\n        \"application/docbook+xml\",\n        \"application/x-kword\",\n        \"application/x-kword-crypt\",\n        \"application/x-lyx\",\n        NULL}},\n    { N_(\"Illustration\"),\n      { \"application/illustrator\",\n        \"application/vnd.corel-draw\",\n        \"application/vnd.stardivision.draw\",\n        \"application/vnd.oasis.opendocument.graphics\",\n        \"application/x-dia-diagram\",\n        \"application/x-karbon\",\n        \"application/x-killustrator\",\n        \"application/x-kivio\",\n        \"application/x-kontour\",\n        \"application/x-wpg\",\n        NULL}},\n    { N_(\"Music\"),\n      { \"application/ogg\",\n        \"audio/x-vorbis+ogg\",\n        \"audio/ac3\",\n        \"audio/basic\",\n        \"audio/midi\",\n        \"audio/x-flac\",\n        \"audio/mp4\",\n        \"audio/mpeg\",\n        \"audio/x-mpeg\",\n        \"audio/x-ms-asx\",\n        \"audio/x-pn-realaudio\",\n        NULL}},\n    { N_(\"PDF / PostScript\"),\n      { \"application/pdf\",\n        \"application/postscript\",\n        \"application/x-dvi\",\n        \"image/x-eps\",\n        NULL}},\n    { N_(\"Picture\"),\n      { \"application/vnd.oasis.opendocument.image\",\n        \"application/x-krita\",\n        \"image/bmp\",\n        \"image/cgm\",\n        \"image/gif\",\n        \"image/jpeg\",\n        \"image/jpeg2000\",\n        \"image/png\",\n        \"image/svg+xml\",\n        \"image/tiff\",\n        \"image/x-compressed-xcf\",\n        \"image/x-pcx\",\n        \"image/x-photo-cd\",\n        \"image/x-psd\",\n        \"image/x-tga\",\n        \"image/x-xcf\",\n        NULL}},\n    { N_(\"Presentation\"),\n      { \"application/vnd.ms-powerpoint\",\n        \"application/vnd.sun.xml.impress\",\n        \"application/vnd.oasis.opendocument.presentation\",\n        \"application/x-magicpoint\",\n        \"application/x-kpresenter\",\n        NULL}},\n    { N_(\"Spreadsheet\"),\n      { \"application/vnd.lotus-1-2-3\",\n        \"application/vnd.ms-excel\",\n        \"application/vnd.stardivision.calc\",\n        \"application/vnd.sun.xml.calc\",\n        \"application/vnd.oasis.opendocument.spreadsheet\",\n        \"application/x-applix-spreadsheet\",\n        \"application/x-gnumeric\",\n        \"application/x-kspread\",\n        \"application/x-kspread-crypt\",\n        \"application/x-quattropro\",\n        \"application/x-sc\",\n        \"application/x-siag\",\n        NULL}},\n    { N_(\"Text File\"),\n      { \"text/plain\",\n        NULL}},\n    { N_(\"Video\"),\n      { \"video/mp4\",\n        \"video/3gpp\",\n        \"video/mpeg\",\n        \"video/quicktime\",\n        \"video/vivo\",\n        \"video/x-avi\",\n        \"video/x-mng\",\n        \"video/x-ms-asf\",\n        \"video/x-ms-wmv\",\n        \"video/x-msvideo\",\n        \"video/x-nsv\",\n        \"video/x-real-video\",\n        NULL}}\n};\n\n/* Number of seconds until cancel dialog shows up */\n#define DELAY_UNTIL_CANCEL_MSECS 5000\n\n#define RESPONSE_RUN 1000\n#define RESPONSE_DISPLAY 1001\n#define RESPONSE_RUN_IN_TERMINAL 1002\n\n#define SILENT_WINDOW_OPEN_LIMIT 5\n#define SILENT_OPEN_LIMIT 5\n\n/* This number controls a maximum character count for a URL that is\n * displayed as part of a dialog. It's fairly arbitrary -- big enough\n * to allow most \"normal\" URIs to display in full, but small enough to\n * prevent the dialog from getting insanely wide.\n */\n#define MAX_URI_IN_DIALOG_LENGTH 60\n\nstatic void cancel_activate_callback (gpointer callback_data);\nstatic void activate_activation_uris_ready_callback (GList   *files,\n                                                     gpointer callback_data);\nstatic void activation_mount_mountables (ActivateParameters *parameters);\nstatic void activation_start_mountables (ActivateParameters *parameters);\nstatic void activate_callback (GList   *files,\n                               gpointer callback_data);\nstatic void activation_mount_not_mounted (ActivateParameters *parameters);\n\n\nstatic void\nlaunch_location_free (LaunchLocation *location)\n{\n    nautilus_file_unref (location->file);\n    g_free (location->uri);\n    g_free (location);\n}\n\nstatic void\nlaunch_location_list_free (GList *list)\n{\n    g_list_foreach (list, (GFunc) launch_location_free, NULL);\n    g_list_free (list);\n}\n\nstatic GList *\nget_file_list_for_launch_locations (GList *locations)\n{\n    GList *files, *l;\n    LaunchLocation *location;\n\n    files = NULL;\n    for (l = locations; l != NULL; l = l->next)\n    {\n        location = l->data;\n\n        files = g_list_prepend (files,\n                                nautilus_file_ref (location->file));\n    }\n    return g_list_reverse (files);\n}\n\n\nstatic LaunchLocation *\nlaunch_location_from_file (NautilusFile *file)\n{\n    LaunchLocation *location;\n    location = g_new (LaunchLocation, 1);\n    location->file = nautilus_file_ref (file);\n    location->uri = nautilus_file_get_uri (file);\n\n    return location;\n}\n\nstatic void\nlaunch_location_update_from_file (LaunchLocation *location,\n                                  NautilusFile   *file)\n{\n    nautilus_file_unref (location->file);\n    g_free (location->uri);\n    location->file = nautilus_file_ref (file);\n    location->uri = nautilus_file_get_uri (file);\n}\n\nstatic void\nlaunch_location_update_from_uri (LaunchLocation *location,\n                                 const char     *uri)\n{\n    nautilus_file_unref (location->file);\n    g_free (location->uri);\n    location->file = nautilus_file_get_by_uri (uri);\n    location->uri = g_strdup (uri);\n}\n\nstatic LaunchLocation *\nfind_launch_location_for_file (GList        *list,\n                               NautilusFile *file)\n{\n    LaunchLocation *location;\n    GList *l;\n\n    for (l = list; l != NULL; l = l->next)\n    {\n        location = l->data;\n\n        if (location->file == file)\n        {\n            return location;\n        }\n    }\n    return NULL;\n}\n\nstatic GList *\nlaunch_locations_from_file_list (GList *list)\n{\n    GList *new;\n\n    new = NULL;\n    while (list)\n    {\n        new = g_list_prepend (new,\n                              launch_location_from_file (list->data));\n        list = list->next;\n    }\n    new = g_list_reverse (new);\n    return new;\n}\n\nstatic ApplicationLaunchParameters *\napplication_launch_parameters_new (GAppInfo *application,\n                                   GList    *uris)\n{\n    ApplicationLaunchParameters *result;\n\n    result = g_new0 (ApplicationLaunchParameters, 1);\n    result->application = g_object_ref (application);\n    result->uris = g_list_copy_deep (uris, (GCopyFunc) g_strdup, NULL);\n\n    return result;\n}\n\nstatic void\napplication_launch_parameters_free (ApplicationLaunchParameters *parameters)\n{\n    g_object_unref (parameters->application);\n    g_list_free_full (parameters->uris, g_free);\n\n    g_free (parameters);\n}\n\nstatic gboolean\nnautilus_mime_actions_check_if_required_attributes_ready (NautilusFile *file)\n{\n    NautilusFileAttributes attributes;\n    gboolean ready;\n\n    attributes = nautilus_mime_actions_get_required_file_attributes ();\n    ready = nautilus_file_check_if_ready (file, attributes);\n\n    return ready;\n}\n\nNautilusFileAttributes\nnautilus_mime_actions_get_required_file_attributes (void)\n{\n    return NAUTILUS_FILE_ATTRIBUTE_INFO |\n           NAUTILUS_FILE_ATTRIBUTE_LINK_INFO;\n}\n\nGAppInfo *\nnautilus_mime_get_default_application_for_file (NautilusFile *file)\n{\n    GAppInfo *app;\n    char *mime_type;\n    char *uri_scheme;\n\n    if (!nautilus_mime_actions_check_if_required_attributes_ready (file))\n    {\n        return NULL;\n    }\n\n    mime_type = nautilus_file_get_mime_type (file);\n    app = g_app_info_get_default_for_type (mime_type,\n                                           !nautilus_file_is_local_or_fuse (file));\n    g_free (mime_type);\n\n    if (app == NULL)\n    {\n        uri_scheme = nautilus_file_get_uri_scheme (file);\n        if (uri_scheme != NULL)\n        {\n            app = g_app_info_get_default_for_uri_scheme (uri_scheme);\n            g_free (uri_scheme);\n        }\n    }\n\n    return app;\n}\n\nstatic int\nfile_compare_by_mime_type (NautilusFile *file_a,\n                           NautilusFile *file_b)\n{\n    char *mime_type_a, *mime_type_b;\n    int ret;\n\n    mime_type_a = nautilus_file_get_mime_type (file_a);\n    mime_type_b = nautilus_file_get_mime_type (file_b);\n\n    ret = strcmp (mime_type_a, mime_type_b);\n\n    g_free (mime_type_a);\n    g_free (mime_type_b);\n\n    return ret;\n}\n\nstatic int\nfile_compare_by_parent_uri (NautilusFile *file_a,\n                            NautilusFile *file_b)\n{\n    char *parent_uri_a, *parent_uri_b;\n    int ret;\n\n    parent_uri_a = nautilus_file_get_parent_uri (file_a);\n    parent_uri_b = nautilus_file_get_parent_uri (file_b);\n\n    ret = strcmp (parent_uri_a, parent_uri_b);\n\n    g_free (parent_uri_a);\n    g_free (parent_uri_b);\n\n    return ret;\n}\n\nGAppInfo *\nnautilus_mime_get_default_application_for_files (GList *files)\n{\n    GList *l, *sorted_files;\n    NautilusFile *file;\n    GAppInfo *app, *one_app;\n\n    g_assert (files != NULL);\n\n    sorted_files = g_list_sort (g_list_copy (files), (GCompareFunc) file_compare_by_mime_type);\n\n    app = NULL;\n    for (l = sorted_files; l != NULL; l = l->next)\n    {\n        file = l->data;\n\n        if (l->prev &&\n            file_compare_by_mime_type (file, l->prev->data) == 0 &&\n            file_compare_by_parent_uri (file, l->prev->data) == 0)\n        {\n            continue;\n        }\n\n        one_app = nautilus_mime_get_default_application_for_file (file);\n        if (one_app == NULL || (app != NULL && !g_app_info_equal (app, one_app)))\n        {\n            if (app)\n            {\n                g_object_unref (app);\n            }\n            if (one_app)\n            {\n                g_object_unref (one_app);\n            }\n            app = NULL;\n            break;\n        }\n\n        if (app == NULL)\n        {\n            app = one_app;\n        }\n        else\n        {\n            g_object_unref (one_app);\n        }\n    }\n\n    g_list_free (sorted_files);\n\n    return app;\n}\n\nstatic void\ntrash_or_delete_files (GtkWindow   *parent_window,\n                       const GList *files,\n                       gboolean     delete_if_all_already_in_trash)\n{\n    GList *locations;\n    const GList *node;\n\n    locations = NULL;\n    for (node = files; node != NULL; node = node->next)\n    {\n        locations = g_list_prepend (locations,\n                                    nautilus_file_get_location ((NautilusFile *) node->data));\n    }\n\n    locations = g_list_reverse (locations);\n\n    nautilus_file_operations_trash_or_delete (locations,\n                                              parent_window,\n                                              NULL, NULL);\n    g_list_free_full (locations, g_object_unref);\n}\n\nstatic void\nreport_broken_symbolic_link (GtkWindow    *parent_window,\n                             NautilusFile *file)\n{\n    char *target_path;\n    char *display_name;\n    char *prompt;\n    char *detail;\n    GtkDialog *dialog;\n    GList file_as_list;\n    int response;\n    gboolean can_trash;\n\n    g_assert (nautilus_file_is_broken_symbolic_link (file));\n\n    display_name = nautilus_file_get_display_name (file);\n    can_trash = nautilus_file_can_trash (file) && !nautilus_file_is_in_trash (file);\n\n    if (can_trash)\n    {\n        prompt = g_strdup_printf (_(\"The link \u201c%s\u201d is broken. Move it to Trash?\"), display_name);\n    }\n    else\n    {\n        prompt = g_strdup_printf (_(\"The link \u201c%s\u201d is broken.\"), display_name);\n    }\n    g_free (display_name);\n\n    target_path = nautilus_file_get_symbolic_link_target_path (file);\n    if (target_path == NULL)\n    {\n        detail = g_strdup (_(\"This link cannot be used because it has no target.\"));\n    }\n    else\n    {\n        detail = g_strdup_printf (_(\"This link cannot be used because its target \"\n                                    \"\u201c%s\u201d doesn\u2019t exist.\"), target_path);\n    }\n\n    if (!can_trash)\n    {\n        eel_run_simple_dialog (GTK_WIDGET (parent_window), FALSE, GTK_MESSAGE_WARNING,\n                               prompt, detail, _(\"_Cancel\"), NULL);\n        goto out;\n    }\n\n    dialog = eel_show_yes_no_dialog (prompt, detail, _(\"Mo_ve to Trash\"), _(\"_Cancel\"),\n                                     parent_window);\n\n    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);\n\n    /* Make this modal to avoid problems with reffing the view & file\n     * to keep them around in case the view changes, which would then\n     * cause the old view not to be destroyed, which would cause its\n     * merged Bonobo items not to be un-merged. Maybe we need to unmerge\n     * explicitly when disconnecting views instead of relying on the\n     * unmerge in Destroy. But since BonoboUIHandler is probably going\n     * to change wildly, I don't want to mess with this now.\n     */\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    if (response == GTK_RESPONSE_YES)\n    {\n        file_as_list.data = file;\n        file_as_list.next = NULL;\n        file_as_list.prev = NULL;\n        trash_or_delete_files (parent_window, &file_as_list, TRUE);\n    }\n\nout:\n    g_free (prompt);\n    g_free (target_path);\n    g_free (detail);\n}\n\nstatic ActivationAction\nget_executable_text_file_action (GtkWindow    *parent_window,\n                                 NautilusFile *file)\n{\n    GtkDialog *dialog;\n    char *file_name;\n    char *prompt;\n    char *detail;\n    int preferences_value;\n    int response;\n\n    g_assert (nautilus_file_contains_text (file));\n\n    preferences_value = g_settings_get_enum (nautilus_preferences,\n                                             NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION);\n    switch (preferences_value)\n    {\n        case NAUTILUS_EXECUTABLE_TEXT_LAUNCH:\n        {\n            return ACTIVATION_ACTION_LAUNCH;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_DISPLAY:\n        {\n            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_ASK:\n        {\n        }\n        break;\n\n        default:\n            /* Complain non-fatally, since preference data can't be trusted */\n            g_warning (\"Unknown value %d for NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION\",\n                       preferences_value);\n    }\n\n\n    file_name = nautilus_file_get_display_name (file);\n    prompt = g_strdup_printf (_(\"Do you want to run \u201c%s\u201d, or display its contents?\"),\n                              file_name);\n    detail = g_strdup_printf (_(\"\u201c%s\u201d is an executable text file.\"),\n                              file_name);\n    g_free (file_name);\n\n    dialog = eel_create_question_dialog (prompt,\n                                         detail,\n                                         _(\"Run in _Terminal\"), RESPONSE_RUN_IN_TERMINAL,\n                                         _(\"_Display\"), RESPONSE_DISPLAY,\n                                         parent_window);\n    gtk_dialog_add_button (dialog, _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n    gtk_dialog_add_button (dialog, _(\"_Run\"), RESPONSE_RUN);\n    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);\n    gtk_widget_show (GTK_WIDGET (dialog));\n\n    g_free (prompt);\n    g_free (detail);\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    switch (response)\n    {\n        case RESPONSE_RUN:\n        {\n            return ACTIVATION_ACTION_LAUNCH;\n        }\n\n        case RESPONSE_RUN_IN_TERMINAL:\n        {\n            return ACTIVATION_ACTION_LAUNCH_IN_TERMINAL;\n        }\n\n        case RESPONSE_DISPLAY:\n        {\n            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n\n        default:\n            return ACTIVATION_ACTION_DO_NOTHING;\n    }\n}\n\nstatic ActivationAction\nget_default_executable_text_file_action (void)\n{\n    int preferences_value;\n\n    preferences_value = g_settings_get_enum (nautilus_preferences,\n                                             NAUTILUS_PREFERENCES_EXECUTABLE_TEXT_ACTIVATION);\n    switch (preferences_value)\n    {\n        case NAUTILUS_EXECUTABLE_TEXT_LAUNCH:\n        {\n            return ACTIVATION_ACTION_LAUNCH;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_DISPLAY:\n        {\n            return ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n\n        case NAUTILUS_EXECUTABLE_TEXT_ASK:\n        default:\n            return ACTIVATION_ACTION_ASK;\n    }\n}\n\nstatic ActivationAction\nget_activation_action (NautilusFile *file)\n{\n    ActivationAction action;\n    char *activation_uri;\n    gboolean can_extract;\n    can_extract = g_settings_get_boolean (nautilus_preferences,\n                                          NAUTILUS_PREFERENCES_AUTOMATIC_DECOMPRESSION);\n\n    if (can_extract && nautilus_file_is_archive (file))\n    {\n        return ACTIVATION_ACTION_EXTRACT;\n    }\n\n    if (nautilus_file_is_nautilus_link (file))\n    {\n        return ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE;\n    }\n\n    activation_uri = nautilus_file_get_activation_uri (file);\n    if (activation_uri == NULL)\n    {\n        activation_uri = nautilus_file_get_uri (file);\n    }\n\n    action = ACTIVATION_ACTION_DO_NOTHING;\n    if (nautilus_file_is_launchable (file))\n    {\n        char *executable_path;\n\n        action = ACTIVATION_ACTION_LAUNCH;\n\n        executable_path = g_filename_from_uri (activation_uri, NULL, NULL);\n        if (!executable_path)\n        {\n            action = ACTIVATION_ACTION_DO_NOTHING;\n        }\n        else if (nautilus_file_contains_text (file))\n        {\n            action = get_default_executable_text_file_action ();\n        }\n        g_free (executable_path);\n    }\n\n    if (action == ACTIVATION_ACTION_DO_NOTHING)\n    {\n        if (nautilus_file_opens_in_view (file))\n        {\n            action = ACTIVATION_ACTION_OPEN_IN_VIEW;\n        }\n        else\n        {\n            action = ACTIVATION_ACTION_OPEN_IN_APPLICATION;\n        }\n    }\n    g_free (activation_uri);\n\n    return action;\n}\n\ngboolean\nnautilus_mime_file_extracts (NautilusFile *file)\n{\n    return get_activation_action (file) == ACTIVATION_ACTION_EXTRACT;\n}\n\ngboolean\nnautilus_mime_file_launches (NautilusFile *file)\n{\n    ActivationAction activation_action;\n\n    activation_action = get_activation_action (file);\n\n    return (activation_action == ACTIVATION_ACTION_LAUNCH);\n}\n\ngboolean\nnautilus_mime_file_opens_in_external_app (NautilusFile *file)\n{\n    ActivationAction activation_action;\n\n    activation_action = get_activation_action (file);\n\n    return (activation_action == ACTIVATION_ACTION_OPEN_IN_APPLICATION);\n}\n\n\nstatic unsigned int\nmime_application_hash (GAppInfo *app)\n{\n    const char *id;\n\n    id = g_app_info_get_id (app);\n\n    if (id == NULL)\n    {\n        return GPOINTER_TO_UINT (app);\n    }\n\n    return g_str_hash (id);\n}\n\nstatic void\nlist_to_parameters_foreach (GAppInfo  *application,\n                            GList     *uris,\n                            GList    **ret)\n{\n    ApplicationLaunchParameters *parameters;\n\n    uris = g_list_reverse (uris);\n\n    parameters = application_launch_parameters_new\n                     (application, uris);\n    *ret = g_list_prepend (*ret, parameters);\n}\n\n\n/**\n * make_activation_parameters\n *\n * Construct a list of ApplicationLaunchParameters from a list of NautilusFiles,\n * where files that have the same default application are put into the same\n * launch parameter, and others are put into the unhandled_files list.\n *\n * @files: Files to use for construction.\n * @unhandled_files: Files without any default application will be put here.\n *\n * Return value: Newly allocated list of ApplicationLaunchParameters.\n **/\nstatic GList *\nmake_activation_parameters (GList  *uris,\n                            GList **unhandled_uris)\n{\n    GList *ret, *l, *app_uris;\n    NautilusFile *file;\n    GAppInfo *app, *old_app;\n    GHashTable *app_table;\n    char *uri;\n\n    ret = NULL;\n    *unhandled_uris = NULL;\n\n    app_table = g_hash_table_new_full\n                    ((GHashFunc) mime_application_hash,\n                    (GEqualFunc) g_app_info_equal,\n                    (GDestroyNotify) g_object_unref,\n                    (GDestroyNotify) g_list_free);\n\n    for (l = uris; l != NULL; l = l->next)\n    {\n        uri = l->data;\n        file = nautilus_file_get_by_uri (uri);\n\n        app = nautilus_mime_get_default_application_for_file (file);\n        if (app != NULL)\n        {\n            app_uris = NULL;\n\n            if (g_hash_table_lookup_extended (app_table, app,\n                                              (gpointer *) &old_app,\n                                              (gpointer *) &app_uris))\n            {\n                g_hash_table_steal (app_table, old_app);\n\n                app_uris = g_list_prepend (app_uris, uri);\n\n                g_object_unref (app);\n                app = old_app;\n            }\n            else\n            {\n                app_uris = g_list_prepend (NULL, uri);\n            }\n\n            g_hash_table_insert (app_table, app, app_uris);\n        }\n        else\n        {\n            *unhandled_uris = g_list_prepend (*unhandled_uris, uri);\n        }\n        nautilus_file_unref (file);\n    }\n\n    g_hash_table_foreach (app_table,\n                          (GHFunc) list_to_parameters_foreach,\n                          &ret);\n\n    g_hash_table_destroy (app_table);\n\n    *unhandled_uris = g_list_reverse (*unhandled_uris);\n\n    return g_list_reverse (ret);\n}\n\nstatic gboolean\nfile_was_cancelled (NautilusFile *file)\n{\n    GError *error;\n\n    error = nautilus_file_get_file_info_error (file);\n    return\n        error != NULL &&\n        error->domain == G_IO_ERROR &&\n        error->code == G_IO_ERROR_CANCELLED;\n}\n\nstatic gboolean\nfile_was_not_mounted (NautilusFile *file)\n{\n    GError *error;\n\n    error = nautilus_file_get_file_info_error (file);\n    return\n        error != NULL &&\n        error->domain == G_IO_ERROR &&\n        error->code == G_IO_ERROR_NOT_MOUNTED;\n}\n\nstatic void\nactivation_parameters_free (ActivateParameters *parameters)\n{\n    if (parameters->timed_wait_active)\n    {\n        eel_timed_wait_stop (cancel_activate_callback, parameters);\n    }\n\n    if (parameters->slot)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters->slot), (gpointer *) &parameters->slot);\n    }\n    if (parameters->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters->parent_window), (gpointer *) &parameters->parent_window);\n    }\n    g_object_unref (parameters->cancellable);\n    launch_location_list_free (parameters->locations);\n    nautilus_file_list_free (parameters->mountables);\n    nautilus_file_list_free (parameters->start_mountables);\n    nautilus_file_list_free (parameters->not_mounted);\n    g_free (parameters->activation_directory);\n    g_free (parameters->timed_wait_prompt);\n    g_assert (parameters->files_handle == NULL);\n    g_free (parameters);\n}\n\nstatic void\ncancel_activate_callback (gpointer callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n\n    parameters->timed_wait_active = FALSE;\n\n    g_cancellable_cancel (parameters->cancellable);\n\n    if (parameters->files_handle)\n    {\n        nautilus_file_list_cancel_call_when_ready (parameters->files_handle);\n        parameters->files_handle = NULL;\n        activation_parameters_free (parameters);\n    }\n}\n\nstatic void\nactivation_start_timed_cancel (ActivateParameters *parameters)\n{\n    parameters->timed_wait_active = TRUE;\n    eel_timed_wait_start_with_duration\n        (DELAY_UNTIL_CANCEL_MSECS,\n        cancel_activate_callback,\n        parameters,\n        parameters->timed_wait_prompt,\n        parameters->parent_window);\n}\n\nstatic void\npause_activation_timed_cancel (ActivateParameters *parameters)\n{\n    if (parameters->timed_wait_active)\n    {\n        eel_timed_wait_stop (cancel_activate_callback, parameters);\n        parameters->timed_wait_active = FALSE;\n    }\n}\n\nstatic void\nunpause_activation_timed_cancel (ActivateParameters *parameters)\n{\n    if (!parameters->timed_wait_active)\n    {\n        activation_start_timed_cancel (parameters);\n    }\n}\n\n\nstatic void\nactivate_mount_op_active (GtkMountOperation  *operation,\n                          GParamSpec         *pspec,\n                          ActivateParameters *parameters)\n{\n    gboolean is_active;\n\n    g_object_get (operation, \"is-showing\", &is_active, NULL);\n\n    if (is_active)\n    {\n        pause_activation_timed_cancel (parameters);\n    }\n    else\n    {\n        unpause_activation_timed_cancel (parameters);\n    }\n}\n\nstatic gboolean\nconfirm_multiple_windows (GtkWindow *parent_window,\n                          int        count,\n                          gboolean   use_tabs)\n{\n    GtkDialog *dialog;\n    char *prompt;\n    char *detail;\n    int response;\n\n    if (count <= SILENT_WINDOW_OPEN_LIMIT)\n    {\n        return TRUE;\n    }\n\n    prompt = _(\"Are you sure you want to open all files?\");\n    if (use_tabs)\n    {\n        detail = g_strdup_printf (ngettext (\"This will open %d separate tab.\",\n                                            \"This will open %d separate tabs.\", count), count);\n    }\n    else\n    {\n        detail = g_strdup_printf (ngettext (\"This will open %d separate window.\",\n                                            \"This will open %d separate windows.\", count), count);\n    }\n    dialog = eel_show_yes_no_dialog (prompt, detail,\n                                     _(\"_OK\"), _(\"_Cancel\"),\n                                     parent_window);\n    g_free (detail);\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    return response == GTK_RESPONSE_YES;\n}\n\ntypedef struct\n{\n    NautilusWindowSlot *slot;\n    GtkWindow *parent_window;\n    NautilusFile *file;\n    GList *files;\n    NautilusWindowOpenFlags flags;\n    char *activation_directory;\n    gboolean user_confirmation;\n    char *uri;\n    GDBusProxy *proxy;\n    GtkWidget *dialog;\n} ActivateParametersInstall;\n\nstatic void\nactivate_parameters_install_free (ActivateParametersInstall *parameters_install)\n{\n    if (parameters_install->slot)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters_install->slot), (gpointer *) &parameters_install->slot);\n    }\n    if (parameters_install->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *) &parameters_install->parent_window);\n    }\n\n    if (parameters_install->proxy != NULL)\n    {\n        g_object_unref (parameters_install->proxy);\n    }\n\n    nautilus_file_unref (parameters_install->file);\n    nautilus_file_list_free (parameters_install->files);\n    g_free (parameters_install->activation_directory);\n    g_free (parameters_install->uri);\n    g_free (parameters_install);\n}\n\nstatic char *\nget_application_no_mime_type_handler_message (NautilusFile *file,\n                                              char         *uri)\n{\n    char *uri_for_display;\n    char *name;\n    char *error_message;\n\n    name = nautilus_file_get_display_name (file);\n\n    /* Truncate the URI so it doesn't get insanely wide. Note that even\n     * though the dialog uses wrapped text, if the URI doesn't contain\n     * white space then the text-wrapping code is too stupid to wrap it.\n     */\n    uri_for_display = eel_str_middle_truncate (name, MAX_URI_IN_DIALOG_LENGTH);\n    error_message = g_strdup_printf (_(\"Could not display \u201c%s\u201d.\"), uri_for_display);\n    g_free (uri_for_display);\n    g_free (name);\n\n    return error_message;\n}\n\nstatic void\nopen_with_response_cb (GtkDialog *dialog,\n                       gint       response_id,\n                       gpointer   user_data)\n{\n    GtkWindow *parent_window;\n    NautilusFile *file;\n    GList files;\n    GAppInfo *info;\n    ActivateParametersInstall *parameters = user_data;\n\n    if (response_id != GTK_RESPONSE_OK)\n    {\n        gtk_widget_destroy (GTK_WIDGET (dialog));\n        return;\n    }\n\n    parent_window = parameters->parent_window;\n    file = g_object_get_data (G_OBJECT (dialog), \"mime-action:file\");\n    info = gtk_app_chooser_get_app_info (GTK_APP_CHOOSER (dialog));\n\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    g_signal_emit_by_name (nautilus_signaller_get_current (), \"mime-data-changed\");\n\n    files.next = NULL;\n    files.prev = NULL;\n    files.data = file;\n    nautilus_launch_application (info, &files, parent_window);\n\n    g_object_unref (info);\n\n    activate_parameters_install_free (parameters);\n}\n\nstatic void\nchoose_program (GtkDialog *message_dialog,\n                int        response,\n                gpointer   callback_data)\n{\n    GtkWidget *dialog;\n    NautilusFile *file;\n    GFile *location;\n    ActivateParametersInstall *parameters = callback_data;\n\n    if (response != GTK_RESPONSE_ACCEPT)\n    {\n        gtk_widget_destroy (GTK_WIDGET (message_dialog));\n        activate_parameters_install_free (parameters);\n        return;\n    }\n\n    file = g_object_get_data (G_OBJECT (message_dialog), \"mime-action:file\");\n\n    g_assert (NAUTILUS_IS_FILE (file));\n\n    location = nautilus_file_get_location (file);\n    nautilus_file_ref (file);\n\n    /* Destroy the message dialog after ref:ing the file */\n    gtk_widget_destroy (GTK_WIDGET (message_dialog));\n\n    dialog = gtk_app_chooser_dialog_new (parameters->parent_window,\n                                         GTK_DIALOG_MODAL,\n                                         location);\n    g_object_set_data_full (G_OBJECT (dialog),\n                            \"mime-action:file\",\n                            nautilus_file_ref (file),\n                            (GDestroyNotify) nautilus_file_unref);\n\n    gtk_widget_show (dialog);\n\n    g_signal_connect (dialog,\n                      \"response\",\n                      G_CALLBACK (open_with_response_cb),\n                      parameters);\n\n    g_object_unref (location);\n    nautilus_file_unref (file);\n}\n\nstatic void\nshow_unhandled_type_error (ActivateParametersInstall *parameters)\n{\n    GtkWidget *dialog;\n\n    char *mime_type = nautilus_file_get_mime_type (parameters->file);\n    char *error_message = get_application_no_mime_type_handler_message (parameters->file, parameters->uri);\n    if (g_content_type_is_unknown (mime_type))\n    {\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,\n                                         GTK_MESSAGE_ERROR,\n                                         0,\n                                         \"%s\", error_message);\n        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                                  _(\"The file is of an unknown type\"));\n    }\n    else\n    {\n        char *text;\n        text = g_strdup_printf (_(\"There is no application installed for \u201c%s\u201d files\"), g_content_type_get_description (mime_type));\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,\n                                         GTK_MESSAGE_ERROR,\n                                         0,\n                                         \"%s\", error_message);\n        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                                  \"%s\", text);\n\n        g_free (text);\n    }\n\n    gtk_dialog_add_button (GTK_DIALOG (dialog), _(\"_Select Application\"), GTK_RESPONSE_ACCEPT);\n\n    gtk_dialog_add_button (GTK_DIALOG (dialog), _(\"_OK\"), GTK_RESPONSE_OK);\n\n    gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_OK);\n\n    g_object_set_data_full (G_OBJECT (dialog),\n                            \"mime-action:file\",\n                            nautilus_file_ref (parameters->file),\n                            (GDestroyNotify) nautilus_file_unref);\n\n    gtk_widget_show (GTK_WIDGET (dialog));\n\n    g_signal_connect (dialog, \"response\",\n                      G_CALLBACK (choose_program), parameters);\n\n    g_free (error_message);\n    g_free (mime_type);\n}\n\nstatic void\nsearch_for_application_dbus_call_notify_cb (GDBusProxy   *proxy,\n                                            GAsyncResult *result,\n                                            gpointer      user_data)\n{\n    ActivateParametersInstall *parameters_install = user_data;\n    GVariant *variant;\n    GError *error = NULL;\n\n    variant = g_dbus_proxy_call_finish (proxy, result, &error);\n    if (variant == NULL)\n    {\n        if (!g_dbus_error_is_remote_error (error) ||\n            g_strcmp0 (g_dbus_error_get_remote_error (error), \"org.freedesktop.PackageKit.Modify.Failed\") == 0)\n        {\n            char *message;\n\n            message = g_strdup_printf (\"%s\\n%s\",\n                                       _(\"There was an internal error trying to search for applications:\"),\n                                       error->message);\n            eel_show_error_dialog (_(\"Unable to search for application\"), message,\n                                   parameters_install->parent_window);\n            g_free (message);\n        }\n        else\n        {\n            g_warning (\"Error while trying to search for applications: %s\",\n                       error->message);\n        }\n\n        g_error_free (error);\n        activate_parameters_install_free (parameters_install);\n        return;\n    }\n\n    g_variant_unref (variant);\n\n    /* activate the file again */\n    nautilus_mime_activate_files (parameters_install->parent_window,\n                                  parameters_install->slot,\n                                  parameters_install->files,\n                                  parameters_install->activation_directory,\n                                  parameters_install->flags,\n                                  parameters_install->user_confirmation);\n\n    activate_parameters_install_free (parameters_install);\n}\n\nstatic void\nsearch_for_application_mime_type (ActivateParametersInstall *parameters_install,\n                                  const gchar               *mime_type)\n{\n    GdkWindow *window;\n    guint xid = 0;\n    const char *mime_types[2];\n\n    g_assert (parameters_install->proxy != NULL);\n\n    /* get XID from parent window */\n    window = gtk_widget_get_window (GTK_WIDGET (parameters_install->parent_window));\n    if (window != NULL)\n    {\n        xid = GDK_WINDOW_XID (window);\n    }\n\n    mime_types[0] = mime_type;\n    mime_types[1] = NULL;\n\n    g_dbus_proxy_call (parameters_install->proxy,\n                       \"InstallMimeTypes\",\n                       g_variant_new (\"(u^ass)\",\n                                      xid,\n                                      mime_types,\n                                      \"hide-confirm-search\"),\n                       G_DBUS_CALL_FLAGS_NONE,\n                       G_MAXINT /* no timeout */,\n                       NULL /* cancellable */,\n                       (GAsyncReadyCallback) search_for_application_dbus_call_notify_cb,\n                       parameters_install);\n\n    DEBUG (\"InstallMimeType method invoked for %s\", mime_type);\n}\n\nstatic void\napplication_unhandled_file_install (GtkDialog                 *dialog,\n                                    gint                       response_id,\n                                    ActivateParametersInstall *parameters_install)\n{\n    char *mime_type;\n\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    parameters_install->dialog = NULL;\n\n    if (response_id == GTK_RESPONSE_YES)\n    {\n        mime_type = nautilus_file_get_mime_type (parameters_install->file);\n        search_for_application_mime_type (parameters_install, mime_type);\n        g_free (mime_type);\n    }\n    else\n    {\n        /* free as we're not going to get the async dbus callback */\n        activate_parameters_install_free (parameters_install);\n    }\n}\n\nstatic gboolean\ndelete_cb (GtkDialog *dialog)\n{\n    gtk_dialog_response (dialog, GTK_RESPONSE_DELETE_EVENT);\n    return TRUE;\n}\n\nstatic void\npk_proxy_appeared_cb (GObject      *source,\n                      GAsyncResult *res,\n                      gpointer      user_data)\n{\n    ActivateParametersInstall *parameters_install = user_data;\n    char *mime_type, *name_owner;\n    char *error_message;\n    GtkWidget *dialog;\n    GDBusProxy *proxy;\n    GError *error = NULL;\n\n    proxy = g_dbus_proxy_new_for_bus_finish (res, &error);\n    name_owner = g_dbus_proxy_get_name_owner (proxy);\n\n    if (error != NULL || name_owner == NULL)\n    {\n        g_warning (\"Couldn't call Modify on the PackageKit interface: %s\",\n                   error != NULL ? error->message : \"no owner for PackageKit\");\n        g_clear_error (&error);\n\n        /* show an unhelpful dialog */\n        show_unhandled_type_error (parameters_install);\n\n        return;\n    }\n\n    g_free (name_owner);\n\n    mime_type = nautilus_file_get_mime_type (parameters_install->file);\n    error_message = get_application_no_mime_type_handler_message (parameters_install->file,\n                                                                  parameters_install->uri);\n    /* use a custom dialog to prompt the user to install new software */\n    dialog = gtk_message_dialog_new (parameters_install->parent_window, 0,\n                                     GTK_MESSAGE_ERROR,\n                                     GTK_BUTTONS_YES_NO,\n                                     \"%s\", error_message);\n    gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),\n                                              _(\"There is no application installed for \u201c%s\u201d files.\\n\"\n                                                \"Do you want to search for an application to open this file?\"),\n                                              g_content_type_get_description (mime_type));\n    gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n    parameters_install->dialog = dialog;\n    parameters_install->proxy = proxy;\n\n    g_signal_connect (dialog, \"response\",\n                      G_CALLBACK (application_unhandled_file_install),\n                      parameters_install);\n    g_signal_connect (dialog, \"delete-event\",\n                      G_CALLBACK (delete_cb), NULL);\n    gtk_widget_show_all (dialog);\n    g_free (mime_type);\n}\n\nstatic void\napplication_unhandled_uri (ActivateParameters *parameters,\n                           char               *uri)\n{\n    gboolean show_install_mime;\n    char *mime_type;\n    NautilusFile *file;\n    ActivateParametersInstall *parameters_install;\n\n    file = nautilus_file_get_by_uri (uri);\n\n    mime_type = nautilus_file_get_mime_type (file);\n\n    /* copy the parts of parameters we are interested in as the orignal will be unref'd */\n    parameters_install = g_new0 (ActivateParametersInstall, 1);\n    parameters_install->slot = parameters->slot;\n    g_object_add_weak_pointer (G_OBJECT (parameters_install->slot), (gpointer *) &parameters_install->slot);\n    if (parameters->parent_window)\n    {\n        parameters_install->parent_window = parameters->parent_window;\n        g_object_add_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *) &parameters_install->parent_window);\n    }\n    parameters_install->activation_directory = g_strdup (parameters->activation_directory);\n    parameters_install->file = file;\n    parameters_install->files = get_file_list_for_launch_locations (parameters->locations);\n    parameters_install->flags = parameters->flags;\n    parameters_install->user_confirmation = parameters->user_confirmation;\n    parameters_install->uri = g_strdup (uri);\n\n#ifdef ENABLE_PACKAGEKIT\n    /* allow an admin to disable the PackageKit search functionality */\n    show_install_mime = g_settings_get_boolean (nautilus_preferences, NAUTILUS_PREFERENCES_INSTALL_MIME_ACTIVATION);\n#else\n    /* we have no install functionality */\n    show_install_mime = FALSE;\n#endif\n    /* There is no use trying to look for handlers of application/octet-stream */\n    if (g_content_type_is_unknown (mime_type))\n    {\n        show_install_mime = FALSE;\n    }\n\n    g_free (mime_type);\n\n    if (!show_install_mime)\n    {\n        goto out;\n    }\n\n    g_dbus_proxy_new_for_bus (G_BUS_TYPE_SESSION,\n                              G_DBUS_PROXY_FLAGS_NONE,\n                              NULL,\n                              \"org.freedesktop.PackageKit\",\n                              \"/org/freedesktop/PackageKit\",\n                              \"org.freedesktop.PackageKit.Modify\",\n                              NULL,\n                              pk_proxy_appeared_cb,\n                              parameters_install);\n\n    return;\n\nout:\n    /* show an unhelpful dialog */\n    show_unhandled_type_error (parameters_install);\n}\n\ntypedef struct\n{\n    GtkWindow *parent_window;\n    NautilusFile *file;\n} ActivateParametersDesktop;\n\nstatic void\nactivate_parameters_desktop_free (ActivateParametersDesktop *parameters_desktop)\n{\n    if (parameters_desktop->parent_window)\n    {\n        g_object_remove_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n    }\n    nautilus_file_unref (parameters_desktop->file);\n    g_free (parameters_desktop);\n}\n\nstatic void\nuntrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case GTK_RESPONSE_OK:\n        {\n            file = nautilus_file_get_location (parameters->file);\n\n            /* We need to do this in order to prevent malicious desktop files\n             * with the executable bit already set.\n             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991\n             */\n            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                        NULL,\n                                        \"yes\");\n\n            nautilus_file_mark_desktop_file_executable (file,\n                                                        parameters->parent_window,\n                                                        TRUE,\n                                                        NULL, NULL);\n\n            /* Need to force a reload of the attributes so is_trusted is marked\n             * correctly. Not sure why the general monitor doesn't fire in this\n             * case when setting the metadata\n             */\n            nautilus_file_invalidate_all_attributes (parameters->file);\n\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n            g_object_unref (file);\n        }\n        break;\n\n        default:\n        {\n            /* Just destroy dialog */\n        }\n        break;\n    }\n\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}\n\nstatic void\nactivate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        /* copy the parts of parameters we are interested in as the orignal will be freed */\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher \u201c%s\u201d has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Trust and _Launch\"), GTK_RESPONSE_OK);\n        }\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}\n\nstatic void\nactivate_files (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    NautilusWindow *window;\n    NautilusWindowOpenFlags flags;\n    g_autoptr (GList) open_in_app_parameters = NULL;\n    g_autoptr (GList) unhandled_open_in_app_uris = NULL;\n    ApplicationLaunchParameters *one_parameters;\n    int count;\n    g_autofree char *old_working_dir = NULL;\n    GdkScreen *screen;\n    gint num_apps;\n    gint num_unhandled;\n    gint num_files;\n    gboolean open_files;\n    gboolean closed_window;\n    g_autoptr (GQueue) launch_desktop_files = NULL;\n    g_autoptr (GQueue) launch_files = NULL;\n    g_autoptr (GQueue) launch_in_terminal_files = NULL;\n    g_autoptr (GQueue) open_in_app_uris = NULL;\n    g_autoptr (GQueue) open_in_view_files = NULL;\n    GList *l;\n    ActivationAction action;\n    LaunchLocation *location;\n\n    launch_desktop_files = g_queue_new ();\n    launch_files = g_queue_new ();\n    launch_in_terminal_files = g_queue_new ();\n    open_in_view_files = g_queue_new ();\n    open_in_app_uris = g_queue_new ();\n\n    for (l = parameters->locations; l != NULL; l = l->next)\n    {\n        location = l->data;\n        file = location->file;\n\n        if (file_was_cancelled (file))\n        {\n            continue;\n        }\n\n        action = get_activation_action (file);\n        if (action == ACTIVATION_ACTION_ASK)\n        {\n            /* Special case for executable text files, since it might be\n             * dangerous & unexpected to launch these.\n             */\n            pause_activation_timed_cancel (parameters);\n            action = get_executable_text_file_action (parameters->parent_window, file);\n            unpause_activation_timed_cancel (parameters);\n        }\n\n        switch (action)\n        {\n            case ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE:\n            {\n                g_queue_push_tail (launch_desktop_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_LAUNCH:\n            {\n                g_queue_push_tail (launch_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_LAUNCH_IN_TERMINAL:\n            {\n                g_queue_push_tail (launch_in_terminal_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_OPEN_IN_VIEW:\n            {\n                g_queue_push_tail (open_in_view_files, file);\n            }\n            break;\n\n            case ACTIVATION_ACTION_OPEN_IN_APPLICATION:\n            {\n                g_queue_push_tail (open_in_app_uris, location->uri);\n            }\n            break;\n\n            case ACTIVATION_ACTION_DO_NOTHING:\n            {\n            }\n            break;\n\n            case ACTIVATION_ACTION_EXTRACT:\n            {\n                /* Extraction of files should be handled in the view */\n                g_assert_not_reached ();\n            }\n            break;\n\n            case ACTIVATION_ACTION_ASK:\n            {\n                g_assert_not_reached ();\n            }\n            break;\n        }\n    }\n\n    for (l = g_queue_peek_head_link (launch_desktop_files); l != NULL; l = l->next)\n    {\n        file = NAUTILUS_FILE (l->data);\n\n        activate_desktop_file (parameters, file);\n    }\n\n    if (parameters->activation_directory &&\n        (!g_queue_is_empty (launch_files) ||\n         !g_queue_is_empty (launch_in_terminal_files)))\n    {\n        old_working_dir = g_get_current_dir ();\n        g_chdir (parameters->activation_directory);\n    }\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    for (l = g_queue_peek_head_link (launch_files); l != NULL; l = l->next)\n    {\n        g_autofree char *uri = NULL;\n        g_autofree char *executable_path = NULL;\n        g_autofree char *quoted_path = NULL;\n\n        file = NAUTILUS_FILE (l->data);\n\n        uri = nautilus_file_get_activation_uri (file);\n        executable_path = g_filename_from_uri (uri, NULL, NULL);\n        quoted_path = g_shell_quote (executable_path);\n\n        DEBUG (\"Launching file path %s\", quoted_path);\n\n        nautilus_launch_application_from_command (screen, quoted_path, FALSE, NULL);\n    }\n\n    for (l = g_queue_peek_head_link (launch_in_terminal_files); l != NULL; l = l->next)\n    {\n        g_autofree char *uri = NULL;\n        g_autofree char *executable_path = NULL;\n        g_autofree char *quoted_path = NULL;\n\n        file = NAUTILUS_FILE (l->data);\n\n        uri = nautilus_file_get_activation_uri (file);\n        executable_path = g_filename_from_uri (uri, NULL, NULL);\n        quoted_path = g_shell_quote (executable_path);\n\n        DEBUG (\"Launching in terminal file quoted path %s\", quoted_path);\n\n        nautilus_launch_application_from_command (screen, quoted_path, TRUE, NULL);\n    }\n\n    if (old_working_dir != NULL)\n    {\n        g_chdir (old_working_dir);\n    }\n\n    count = g_queue_get_length (open_in_view_files);\n\n    flags = parameters->flags;\n    if (count > 1)\n    {\n        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0)\n        {\n            /* if CLOSE_BEHIND is set and we have a directory to be activated, we\n             * will first have to open a new window and after that we can open the\n             * rest of files in tabs */\n            if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)\n            {\n                flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n            }\n            else\n            {\n                flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;\n            }\n        }\n        else\n        {\n            flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n        }\n    }\n    else\n    {\n        /* if we want to close the window and activate a single directory, then we will need\n         * the NEW_WINDOW flag set */\n        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)\n        {\n            flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n        }\n    }\n\n    if (parameters->slot != NULL &&\n        (!parameters->user_confirmation ||\n         confirm_multiple_windows (parameters->parent_window, count,\n                                   (flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0)))\n    {\n        if ((flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0 &&\n            g_settings_get_enum (nautilus_preferences, NAUTILUS_PREFERENCES_NEW_TAB_POSITION) ==\n            NAUTILUS_NEW_TAB_POSITION_AFTER_CURRENT_TAB)\n        {\n            /* When inserting N tabs after the current one,\n             * we first open tab N, then tab N-1, ..., then tab 0.\n             * Each of them is appended to the current tab, i.e.\n             * prepended to the list of tabs to open.\n             */\n            g_queue_reverse (open_in_view_files);\n        }\n\n        closed_window = FALSE;\n\n        for (l = g_queue_peek_head_link (open_in_view_files); l != NULL; l = l->next)\n        {\n            g_autofree char *uri = NULL;\n            g_autoptr (GFile) location = NULL;\n            g_autoptr (GFile) location_with_permissions = NULL;\n            /* The ui should ask for navigation or object windows\n             * depending on what the current one is */\n            file = NAUTILUS_FILE (l->data);\n            uri = nautilus_file_get_activation_uri (file);\n            location = g_file_new_for_uri (uri);\n            if (g_file_is_native (location) &&\n                (nautilus_file_is_in_admin (file) ||\n                 !nautilus_file_can_read (file) ||\n                 !nautilus_file_can_execute (file)))\n            {\n                g_autofree gchar *file_path = NULL;\n\n                g_free (uri);\n\n                file_path = g_file_get_path (location);\n                uri = g_strconcat (\"admin://\", file_path, NULL);\n            }\n\n            location_with_permissions = g_file_new_for_uri (uri);\n            /* FIXME: we need to pass the parent_window, but we only use it for the current active window,\n             * which nautilus-application should take care of. However is not working and creating regressions\n             * in some cases. Until we figure out what's going on, continue to use the parameters->slot\n             * to make splicit the window we want to use for activating the files */\n            nautilus_application_open_location_full (NAUTILUS_APPLICATION (g_application_get_default ()),\n                                                     location_with_permissions, flags, NULL, NULL, parameters->slot);\n\n            /* close only the window from which the action was launched and then open\n             * tabs/windows (depending on parameters->flags) */\n            if (!closed_window && (flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0)\n            {\n                flags &= (~NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND);\n\n                /* if NEW_WINDOW is set, we want all files in new windows, not in tabs */\n                if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0)\n                {\n                    flags &= (~NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW);\n                    flags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;\n                }\n\n                closed_window = TRUE;\n            }\n        }\n    }\n\n    if (open_in_app_uris != NULL)\n    {\n        open_in_app_parameters = make_activation_parameters (g_queue_peek_head_link (open_in_app_uris),\n                                                             &unhandled_open_in_app_uris);\n    }\n\n    num_apps = g_list_length (open_in_app_parameters);\n    num_unhandled = g_list_length (unhandled_open_in_app_uris);\n    num_files = g_queue_get_length (open_in_app_uris);\n    open_files = TRUE;\n\n    if (g_queue_is_empty (open_in_app_uris) &&\n        (!parameters->user_confirmation ||\n         num_files + num_unhandled > SILENT_OPEN_LIMIT) &&\n        num_apps > 1)\n    {\n        GtkDialog *dialog;\n        char *prompt;\n        g_autofree char *detail = NULL;\n        int response;\n\n        pause_activation_timed_cancel (parameters);\n\n        prompt = _(\"Are you sure you want to open all files?\");\n        detail = g_strdup_printf (ngettext (\"This will open %d separate application.\",\n                                            \"This will open %d separate applications.\", num_apps), num_apps);\n        dialog = eel_show_yes_no_dialog (prompt, detail,\n                                         _(\"_OK\"), _(\"_Cancel\"),\n                                         parameters->parent_window);\n        response = gtk_dialog_run (dialog);\n        gtk_widget_destroy (GTK_WIDGET (dialog));\n\n        unpause_activation_timed_cancel (parameters);\n\n        if (response != GTK_RESPONSE_YES)\n        {\n            open_files = FALSE;\n        }\n    }\n\n    if (open_files)\n    {\n        for (l = open_in_app_parameters; l != NULL; l = l->next)\n        {\n            one_parameters = l->data;\n\n            nautilus_launch_application_by_uri (one_parameters->application,\n                                                one_parameters->uris,\n                                                parameters->parent_window);\n            application_launch_parameters_free (one_parameters);\n        }\n\n        for (l = unhandled_open_in_app_uris; l != NULL; l = l->next)\n        {\n            char *uri = l->data;\n\n            /* this does not block */\n            application_unhandled_uri (parameters, uri);\n        }\n    }\n\n    window = NULL;\n    if (parameters->slot != NULL)\n    {\n        window = nautilus_window_slot_get_window (parameters->slot);\n    }\n\n    if (open_in_app_parameters != NULL ||\n        unhandled_open_in_app_uris != NULL)\n    {\n        if ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0 &&\n            window != NULL)\n        {\n            nautilus_window_close (window);\n        }\n    }\n\n    activation_parameters_free (parameters);\n}\n\nstatic void\nactivation_mount_not_mounted_callback (GObject      *source_object,\n                                       GAsyncResult *res,\n                                       gpointer      user_data)\n{\n    ActivateParameters *parameters = user_data;\n    GError *error;\n    NautilusFile *file;\n    LaunchLocation *loc;\n\n    file = parameters->not_mounted->data;\n\n    error = NULL;\n    if (!g_file_mount_enclosing_volume_finish (G_FILE (source_object), res, &error))\n    {\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_CANCELLED &&\n             error->code != G_IO_ERROR_FAILED_HANDLED &&\n             error->code != G_IO_ERROR_ALREADY_MOUNTED))\n        {\n            eel_show_error_dialog (_(\"Unable to access location\"), error->message, parameters->parent_window);\n        }\n\n        if (error->domain != G_IO_ERROR ||\n            error->code != G_IO_ERROR_ALREADY_MOUNTED)\n        {\n            loc = find_launch_location_for_file (parameters->locations,\n                                                 file);\n            if (loc)\n            {\n                parameters->locations =\n                    g_list_remove (parameters->locations, loc);\n                launch_location_free (loc);\n            }\n        }\n\n        g_error_free (error);\n    }\n\n    parameters->not_mounted = g_list_delete_link (parameters->not_mounted,\n                                                  parameters->not_mounted);\n    nautilus_file_unref (file);\n\n    activation_mount_not_mounted (parameters);\n}\n\nstatic void\nactivation_mount_not_mounted (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    GFile *location;\n    LaunchLocation *loc;\n    GMountOperation *mount_op;\n    GList *l, *next, *files;\n\n    if (parameters->not_mounted != NULL)\n    {\n        file = parameters->not_mounted->data;\n        mount_op = gtk_mount_operation_new (parameters->parent_window);\n        g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);\n        g_signal_connect (mount_op, \"notify::is-showing\",\n                          G_CALLBACK (activate_mount_op_active), parameters);\n        location = nautilus_file_get_location (file);\n        g_file_mount_enclosing_volume (location, 0, mount_op, parameters->cancellable,\n                                       activation_mount_not_mounted_callback, parameters);\n        g_object_unref (location);\n        /* unref mount_op here - g_file_mount_enclosing_volume() does ref for itself */\n        g_object_unref (mount_op);\n        return;\n    }\n\n    parameters->tried_mounting = TRUE;\n\n    if (parameters->locations == NULL)\n    {\n        activation_parameters_free (parameters);\n        return;\n    }\n\n    /*  once the mount is finished, refresh all attributes        */\n    /*  - fixes new windows not appearing after successful mount  */\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        loc = l->data;\n        next = l->next;\n        nautilus_file_invalidate_all_attributes (loc->file);\n    }\n\n    files = get_file_list_for_launch_locations (parameters->locations);\n    nautilus_file_list_call_when_ready\n        (files,\n        nautilus_mime_actions_get_required_file_attributes (),\n        &parameters->files_handle,\n        activate_callback, parameters);\n    nautilus_file_list_free (files);\n}\n\n\nstatic void\nactivate_callback (GList    *files,\n                   gpointer  callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    GList *l, *next;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    parameters->files_handle = NULL;\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n\n        if (file_was_not_mounted (file))\n        {\n            if (parameters->tried_mounting)\n            {\n                launch_location_free (location);\n                parameters->locations = g_list_delete_link (parameters->locations, l);\n            }\n            else\n            {\n                parameters->not_mounted = g_list_prepend (parameters->not_mounted,\n                                                          nautilus_file_ref (file));\n            }\n            continue;\n        }\n    }\n\n\n    if (parameters->not_mounted != NULL)\n    {\n        activation_mount_not_mounted (parameters);\n    }\n    else\n    {\n        activate_files (parameters);\n    }\n}\n\nstatic void\nactivate_activation_uris_ready_callback (GList    *files_ignore,\n                                         gpointer  callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    GList *l, *next, *files;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    parameters->files_handle = NULL;\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n\n        if (nautilus_file_is_broken_symbolic_link (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            pause_activation_timed_cancel (parameters);\n            report_broken_symbolic_link (parameters->parent_window, file);\n            unpause_activation_timed_cancel (parameters);\n            continue;\n        }\n\n        if (nautilus_file_get_file_type (file) == G_FILE_TYPE_MOUNTABLE &&\n            !nautilus_file_has_activation_uri (file))\n        {\n            /* Don't launch these... There is nothing we\n             *  can do */\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n    }\n\n    if (parameters->locations == NULL)\n    {\n        activation_parameters_free (parameters);\n        return;\n    }\n\n    /* Convert the files to the actual activation uri files */\n    for (l = parameters->locations; l != NULL; l = l->next)\n    {\n        char *uri;\n        location = l->data;\n\n        /* We want the file for the activation URI since we care\n         * about the attributes for that, not for the original file.\n         */\n        uri = nautilus_file_get_activation_uri (location->file);\n        if (uri != NULL)\n        {\n            launch_location_update_from_uri (location, uri);\n        }\n        g_free (uri);\n    }\n\n\n    /* get the parameters for the actual files */\n    files = get_file_list_for_launch_locations (parameters->locations);\n    nautilus_file_list_call_when_ready\n        (files,\n        nautilus_mime_actions_get_required_file_attributes (),\n        &parameters->files_handle,\n        activate_callback, parameters);\n    nautilus_file_list_free (files);\n}\n\nstatic void\nactivation_get_activation_uris (ActivateParameters *parameters)\n{\n    GList *l, *files;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    /* link target info might be stale, re-read it */\n    for (l = parameters->locations; l != NULL; l = l->next)\n    {\n        location = l->data;\n        file = location->file;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n    }\n\n    if (parameters->locations == NULL)\n    {\n        activation_parameters_free (parameters);\n        return;\n    }\n\n    files = get_file_list_for_launch_locations (parameters->locations);\n    nautilus_file_list_call_when_ready\n        (files, nautilus_mime_actions_get_required_file_attributes (),\n        &parameters->files_handle,\n        activate_activation_uris_ready_callback, parameters);\n    nautilus_file_list_free (files);\n}\n\nstatic void\nactivation_mountable_mounted (NautilusFile *file,\n                              GFile        *result_location,\n                              GError       *error,\n                              gpointer      callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    NautilusFile *target_file;\n    LaunchLocation *location;\n\n    /* Remove from list of files that have to be mounted */\n    parameters->mountables = g_list_remove (parameters->mountables, file);\n    nautilus_file_unref (file);\n\n\n    if (error == NULL)\n    {\n        /* Replace file with the result of the mount */\n        target_file = nautilus_file_get (result_location);\n\n        location = find_launch_location_for_file (parameters->locations,\n                                                  file);\n        if (location)\n        {\n            launch_location_update_from_file (location, target_file);\n        }\n        nautilus_file_unref (target_file);\n    }\n    else\n    {\n        /* Remove failed file */\n\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_FAILED_HANDLED &&\n             error->code != G_IO_ERROR_ALREADY_MOUNTED))\n        {\n            location = find_launch_location_for_file (parameters->locations,\n                                                      file);\n            if (location)\n            {\n                parameters->locations =\n                    g_list_remove (parameters->locations,\n                                   location);\n                launch_location_free (location);\n            }\n        }\n\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_CANCELLED &&\n             error->code != G_IO_ERROR_FAILED_HANDLED &&\n             error->code != G_IO_ERROR_ALREADY_MOUNTED))\n        {\n            eel_show_error_dialog (_(\"Unable to access location\"),\n                                   error->message, parameters->parent_window);\n        }\n\n        if (error->code == G_IO_ERROR_CANCELLED)\n        {\n            activation_parameters_free (parameters);\n            return;\n        }\n    }\n\n    /* Mount more mountables */\n    activation_mount_mountables (parameters);\n}\n\n\nstatic void\nactivation_mount_mountables (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    GMountOperation *mount_op;\n\n    if (parameters->mountables != NULL)\n    {\n        file = parameters->mountables->data;\n        mount_op = gtk_mount_operation_new (parameters->parent_window);\n        g_mount_operation_set_password_save (mount_op, G_PASSWORD_SAVE_FOR_SESSION);\n        g_signal_connect (mount_op, \"notify::is-showing\",\n                          G_CALLBACK (activate_mount_op_active), parameters);\n        nautilus_file_mount (file,\n                             mount_op,\n                             parameters->cancellable,\n                             activation_mountable_mounted,\n                             parameters);\n        g_object_unref (mount_op);\n        return;\n    }\n\n    if (parameters->mountables == NULL && parameters->start_mountables == NULL)\n    {\n        activation_get_activation_uris (parameters);\n    }\n}\n\n\nstatic void\nactivation_mountable_started (NautilusFile *file,\n                              GFile        *gfile_of_file,\n                              GError       *error,\n                              gpointer      callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    LaunchLocation *location;\n\n    /* Remove from list of files that have to be mounted */\n    parameters->start_mountables = g_list_remove (parameters->start_mountables, file);\n    nautilus_file_unref (file);\n\n    if (error == NULL)\n    {\n        /* Remove file */\n        location = find_launch_location_for_file (parameters->locations, file);\n        if (location != NULL)\n        {\n            parameters->locations = g_list_remove (parameters->locations, location);\n            launch_location_free (location);\n        }\n    }\n    else\n    {\n        /* Remove failed file */\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_FAILED_HANDLED))\n        {\n            location = find_launch_location_for_file (parameters->locations,\n                                                      file);\n            if (location)\n            {\n                parameters->locations =\n                    g_list_remove (parameters->locations,\n                                   location);\n                launch_location_free (location);\n            }\n        }\n\n        if (error->domain != G_IO_ERROR ||\n            (error->code != G_IO_ERROR_CANCELLED &&\n             error->code != G_IO_ERROR_FAILED_HANDLED))\n        {\n            eel_show_error_dialog (_(\"Unable to start location\"),\n                                   error->message, NULL);\n        }\n\n        if (error->code == G_IO_ERROR_CANCELLED)\n        {\n            activation_parameters_free (parameters);\n            return;\n        }\n    }\n\n    /* Start more mountables */\n    activation_start_mountables (parameters);\n}\n\nstatic void\nactivation_start_mountables (ActivateParameters *parameters)\n{\n    NautilusFile *file;\n    GMountOperation *start_op;\n\n    if (parameters->start_mountables != NULL)\n    {\n        file = parameters->start_mountables->data;\n        start_op = gtk_mount_operation_new (parameters->parent_window);\n        g_signal_connect (start_op, \"notify::is-showing\",\n                          G_CALLBACK (activate_mount_op_active), parameters);\n        nautilus_file_start (file,\n                             start_op,\n                             parameters->cancellable,\n                             activation_mountable_started,\n                             parameters);\n        g_object_unref (start_op);\n        return;\n    }\n\n    if (parameters->mountables == NULL && parameters->start_mountables == NULL)\n    {\n        activation_get_activation_uris (parameters);\n    }\n}\n\n/**\n * nautilus_mime_activate_files:\n *\n * Activate a list of files. Each one might launch with an application or\n * with a component. This is normally called only by subclasses.\n * @view: FMDirectoryView in question.\n * @files: A GList of NautilusFiles to activate.\n *\n **/\nvoid\nnautilus_mime_activate_files (GtkWindow               *parent_window,\n                              NautilusWindowSlot      *slot,\n                              GList                   *files,\n                              const char              *launch_directory,\n                              NautilusWindowOpenFlags  flags,\n                              gboolean                 user_confirmation)\n{\n    ActivateParameters *parameters;\n    char *file_name;\n    int file_count;\n    GList *l, *next;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    if (files == NULL)\n    {\n        return;\n    }\n\n    DEBUG_FILES (files, \"Calling activate_files() with files:\");\n\n    parameters = g_new0 (ActivateParameters, 1);\n    parameters->slot = slot;\n    g_object_add_weak_pointer (G_OBJECT (parameters->slot), (gpointer *) &parameters->slot);\n    if (parent_window)\n    {\n        parameters->parent_window = parent_window;\n        g_object_add_weak_pointer (G_OBJECT (parameters->parent_window), (gpointer *) &parameters->parent_window);\n    }\n    parameters->cancellable = g_cancellable_new ();\n    parameters->activation_directory = g_strdup (launch_directory);\n    parameters->locations = launch_locations_from_file_list (files);\n    parameters->flags = flags;\n    parameters->user_confirmation = user_confirmation;\n\n    file_count = g_list_length (files);\n    if (file_count == 1)\n    {\n        file_name = nautilus_file_get_display_name (files->data);\n        parameters->timed_wait_prompt = g_strdup_printf (_(\"Opening \u201c%s\u201d.\"), file_name);\n        g_free (file_name);\n    }\n    else\n    {\n        parameters->timed_wait_prompt = g_strdup_printf (ngettext (\"Opening %d item.\",\n                                                                   \"Opening %d items.\",\n                                                                   file_count),\n                                                         file_count);\n    }\n\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (nautilus_file_can_mount (file))\n        {\n            parameters->mountables = g_list_prepend (parameters->mountables,\n                                                     nautilus_file_ref (file));\n        }\n\n        if (nautilus_file_can_start (file))\n        {\n            parameters->start_mountables = g_list_prepend (parameters->start_mountables,\n                                                           nautilus_file_ref (file));\n        }\n    }\n\n    activation_start_timed_cancel (parameters);\n    if (parameters->mountables != NULL)\n    {\n        activation_mount_mountables (parameters);\n    }\n    if (parameters->start_mountables != NULL)\n    {\n        activation_start_mountables (parameters);\n    }\n    if (parameters->mountables == NULL && parameters->start_mountables == NULL)\n    {\n        activation_get_activation_uris (parameters);\n    }\n}\n\n/**\n * nautilus_mime_activate_file:\n *\n * Activate a file in this view. This might involve switching the displayed\n * location for the current window, or launching an application.\n * @view: FMDirectoryView in question.\n * @file: A NautilusFile representing the file in this view to activate.\n * @use_new_window: Should this item be opened in a new window?\n *\n **/\n\nvoid\nnautilus_mime_activate_file (GtkWindow               *parent_window,\n                             NautilusWindowSlot      *slot,\n                             NautilusFile            *file,\n                             const char              *launch_directory,\n                             NautilusWindowOpenFlags  flags)\n{\n    GList *files;\n\n    g_return_if_fail (NAUTILUS_IS_FILE (file));\n\n    files = g_list_prepend (NULL, file);\n    nautilus_mime_activate_files (parent_window, slot, files, launch_directory, flags, FALSE);\n    g_list_free (files);\n}\n\ngint\nnautilus_mime_types_get_number_of_groups (void)\n{\n    return G_N_ELEMENTS (mimetype_groups);\n}\n\nconst gchar *\nnautilus_mime_types_group_get_name (gint group_index)\n{\n    g_return_val_if_fail (group_index < G_N_ELEMENTS (mimetype_groups), NULL);\n\n    return gettext (mimetype_groups[group_index].name);\n}\n\nGList *\nnautilus_mime_types_group_get_mimetypes (gint group_index)\n{\n    GList *mimetypes;\n    gint i;\n\n    g_return_val_if_fail (group_index < G_N_ELEMENTS (mimetype_groups), NULL);\n\n    mimetypes = NULL;\n\n    /* Setup the new mimetypes set */\n    for (i = 0; mimetype_groups[group_index].mimetypes[i]; i++)\n    {\n        mimetypes = g_list_append (mimetypes, mimetype_groups[group_index].mimetypes[i]);\n    }\n\n    return mimetypes;\n}\n"], "filenames": ["src/nautilus-directory-async.c", "src/nautilus-file-operations.c", "src/nautilus-file-operations.h", "src/nautilus-metadata.c", "src/nautilus-metadata.h", "src/nautilus-mime-actions.c"], "buggy_code_start_loc": [32, 238, 149, 53, 69, 44], "buggy_code_end_loc": [3590, 8141, 154, 53, 69, 1604], "fixing_code_start_loc": [33, 238, 149, 54, 70, 45], "fixing_code_end_loc": [3595, 8050, 154, 55, 72, 1614], "type": "CWE-20", "message": "GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious \"sh -c\" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.", "other": {"cve": {"id": "CVE-2017-14604", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-20T08:29:00.270", "lastModified": "2020-08-18T15:05:57.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious \"sh -c\" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field."}, {"lang": "es", "value": "GNOME Nautilus en versiones anteriores a la 3.23.90 permite que los atacantes suplanten un tipo de archivo mediante la extensi\u00f3n de archivo .desktop, tal y como se ve en un ataque en el cual el nombre de un archivo .desktop acaba en .pdf, pero el campo Exec de este archivo lanza un comando \"sh-c\" malicioso. En otras palabras, Nautilus no proporciona ninguna indicaci\u00f3n en la interfaz de usuario sobre si un archivo tiene realmente la extensi\u00f3n .desktop. En lugar de eso, la interfaz de usuario s\u00f3lo muestra la extensi\u00f3n .pdf. Un factor de mitigaci\u00f3n (leve) es que un ataque requiere que el archivo .desktop tenga permisos de ejecuci\u00f3n. La soluci\u00f3n es pedirle al usuario que confirme que el archivo debe ser tratado como un .desktop y despu\u00e9s recordar la respuesta del usuario en el campo metadata::trusted."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnome:nautilus:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.23.90", "matchCriteriaId": "4D9D36E9-BF92-413D-B951-D76D6DD04DE6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3994", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/101012", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0223", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=860268", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.gnome.org/show_bug.cgi?id=777991", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/GNOME/nautilus/commit/bc919205bf774f6af3fa7154506c46039af5a69b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/freedomofpress/securedrop/issues/2238", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://micahflee.com/2017/04/breaking-the-security-model-of-subgraph-os/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0"}}