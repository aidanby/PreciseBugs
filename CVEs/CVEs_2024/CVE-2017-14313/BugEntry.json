{"buggy_code": ["<?php\n/*\n Plugin Name: Shibboleth\n Plugin URI: http://wordpress.org/extend/plugins/shibboleth\n Description: Easily externalize user authentication to a <a href=\"http://shibboleth.internet2.edu\">Shibboleth</a> Service Provider\n Author: Will Norris, mitcho (Michael \u82b3\u8cb4 Erlewine)\n Version: 1.6\n License: Apache 2 (http://www.apache.org/licenses/LICENSE-2.0.html)\n */\n\ndefine ( 'SHIBBOLETH_PLUGIN_REVISION', preg_replace( '/\\$Rev: (.+) \\$/', '\\\\1',\n\t'$Rev$') ); // this needs to be on a separate line so that svn:keywords can work its magic\n\n\n// run activation function if new revision of plugin\n$shibboleth_plugin_revision = shibboleth_get_option('shibboleth_plugin_revision');\nif ($shibboleth_plugin_revision === false || SHIBBOLETH_PLUGIN_REVISION != $shibboleth_plugin_revision) {\n\tadd_action('admin_init', 'shibboleth_activate_plugin');\n}\n\n/**\n * Perform automatic login. This is based on the user not being logged in,\n * an active session and the option being set to true.\n */\nfunction shibboleth_auto_login() {\n\t$shibboleth_auto_login = shibboleth_get_option('shibboleth_auto_login');\n\tif ( !is_user_logged_in() && shibboleth_session_active() && $shibboleth_auto_login ) {\n\t\tdo_action('login_form_shibboleth');\n\n\t\t$userobj = wp_signon('', true);\n\t\tif ( is_wp_error($userobj) ) {\n\t\t\t// TODO: Proper error return.\n\t\t} else {\n\t\t\twp_safe_redirect($_SERVER['REQUEST_URI']);\n\t\t\texit();\n\t\t}\n\t}\n}\nadd_action('init', 'shibboleth_auto_login');\n\n/**\n * Activate the plugin.  This registers default values for all of the \n * Shibboleth options and attempts to add the appropriate mod_rewrite rules to \n * WordPress's .htaccess file.\n */\nfunction shibboleth_activate_plugin() {\n\tif ( function_exists('switch_to_blog') ) switch_to_blog($GLOBALS['current_site']->blog_id);\n\n\tshibboleth_add_option('shibboleth_login_url', get_option('home') . '/Shibboleth.sso/Login');\n\tshibboleth_add_option('shibboleth_default_login', false);\n\tshibboleth_add_option('shibboleth_auto_login', false);\n\tshibboleth_add_option('shibboleth_logout_url', get_option('home') . '/Shibboleth.sso/Logout');\n\n\t$headers = array(\n\t\t'username' => array( 'name' => 'eppn', 'managed' => false),\n\t\t'first_name' => array( 'name' => 'givenName', 'managed' => true),\n\t\t'last_name' => array( 'name' => 'sn', 'managed' => true),\n\t\t'nickname' => array( 'name' => 'eppn', 'managed' => true),\n\t\t'display_name' => array( 'name' => 'displayName', 'managed' => true),\n\t\t'email' => array( 'name' => 'mail', 'managed' => true),\n\t);\n\tshibboleth_add_option('shibboleth_headers', $headers);\n\n\t$roles = array(\n\t\t'administrator' => array(\n\t\t\t'header' => 'entitlement',\n\t\t\t'value' => 'urn:mace:example.edu:entitlement:wordpress:admin',\n\t\t),\n\t\t'author' => array(\n\t\t\t'header' => 'affiliation',\n\t\t\t'value' => 'faculty',\n\t\t),\n\t\t// TODO: this could likely do strange things if WordPress has an actual role named 'default'\n\t\t'default' => 'subscriber',\n\t);\n\tshibboleth_add_option('shibboleth_roles', $roles);\n\n\tshibboleth_add_option('shibboleth_update_roles', true);\n\n\tshibboleth_insert_htaccess();\n\n\tshibboleth_migrate_old_data();\n\n\tshibboleth_update_option('shibboleth_plugin_revision', SHIBBOLETH_PLUGIN_REVISION);\n\n\tif ( function_exists('restore_current_blog') ) restore_current_blog();\n}\nregister_activation_hook('shibboleth/shibboleth.php', 'shibboleth_activate_plugin');\n\n\n/**\n * Cleanup certain plugins options on deactivation.\n */\nfunction shibboleth_deactivate_plugin() {\n\tshibboleth_remove_htaccess();\n}\nregister_deactivation_hook('shibboleth/shibboleth.php', 'shibboleth_deactivate_plugin');\n\n\n/**\n * Migrate old data to newer formats.\n */\nfunction shibboleth_migrate_old_data() {\n\n\t// new header format, allowing each header to be marked as 'managed' individually\n\t$managed = shibboleth_get_option('shibboleth_update_users');\n\t$headers = shibboleth_get_option('shibboleth_headers');\n\t$updated = false;\n\n\tforeach ($headers as $key => $value) {\n\t\tif ( is_string($value) ) {\n\t\t\t$headers[$key] = array(\n\t\t\t\t'name' => $value,\n\t\t\t\t'managed' => $managed,\n\t\t\t);\n\t\t\t$updated = true;\n\t\t}\n\t}\n\n\tif ( $updated ) {\n\t\tshibboleth_update_option('shibboleth_headers', $headers);\n\t}\n\tshibboleth_delete_option('shibboleth_update_users');\n\n}\n\n/**\n * Load Shibboleth admin hooks only on admin page loads.  \n *\n * 'admin_init' is actually called *after* 'admin_menu', so we have to hook in \n * to the 'init' action for this.\n */\nfunction shibboleth_admin_hooks() {\n\tif ( defined('WP_ADMIN') && WP_ADMIN === true ) {\n\t\trequire_once dirname(__FILE__) . '/options-admin.php';\n\t\trequire_once dirname(__FILE__) . '/options-user.php';\n\t}\n}\nadd_action('init', 'shibboleth_admin_hooks');\n\n\n/**\n * Check if a Shibboleth session is active.\n *\n * @return boolean if session is active\n * @uses apply_filters calls 'shibboleth_session_active' before returning final result\n */\nfunction shibboleth_session_active() { \n\t$active = false;\n\n\t$session_headers = array('Shib-Session-ID', 'Shib_Session_ID', 'HTTP_SHIB_IDENTITY_PROVIDER');\n\tforeach ($session_headers as $header) {\n\t\tif ( array_key_exists($header, $_SERVER) && !empty($_SERVER[$header]) ) {\n\t\t\t$active = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t$active = apply_filters('shibboleth_session_active', $active);\n\treturn $active;\n}\n\n\n/**\n * Authenticate the user using Shibboleth.  If a Shibboleth session is active, \n * use the data provided by Shibboleth to log the user in.  If a Shibboleth \n * session is not active, redirect the user to the Shibboleth Session Initiator \n * URL to initiate the session.\n */\nfunction shibboleth_authenticate($user, $username, $password) {\n\tif ( shibboleth_session_active() ) {\n\t\treturn shibboleth_authenticate_user();\n\t} else {\n\t\t$initiator_url = shibboleth_session_initiator_url( $_REQUEST['redirect_to'] );\n\t\twp_redirect($initiator_url);\n\t\texit;\n\t}\n}\n\n\n/**\n * When wp-login.php is loaded with 'action=shibboleth', hook Shibboleth \n * into the WordPress authentication flow.\n */\nfunction shibboleth_login_form_shibboleth() {\n\tadd_filter('authenticate', 'shibboleth_authenticate', 10, 3);\n}\nadd_action('login_form_shibboleth', 'shibboleth_login_form_shibboleth');\n\n\n/**\n * If a Shibboleth user requests a password reset, and the Shibboleth password \n * reset URL is set, redirect the user there.\n */\nfunction shibboleth_retrieve_password( $user_login ) {\n\t$password_reset_url = shibboleth_get_option('shibboleth_password_reset_url');\n\n\tif ( !empty($password_reset_url) ) {\n\t\t$user = get_userdatabylogin($user_login);\n\t\tif ( $user && get_usermeta($user->ID, 'shibboleth_account') ) {\n\t\t\twp_redirect($password_reset_url);\n\t\t\texit;\n\t\t}\n\t}\n}\nadd_action('retrieve_password', 'shibboleth_retrieve_password');\n\n\n/**\n * If Shibboleth is the default login method, add 'action=shibboleth' to the \n * WordPress login URL.\n */\nfunction shibboleth_login_url($login_url) {\n\tif ( shibboleth_get_option('shibboleth_default_login') ) {\n\t\t$login_url = add_query_arg('action', 'shibboleth', $login_url);\n\t}\n\n\treturn $login_url;\n}\nadd_filter('login_url', 'shibboleth_login_url');\n\n\n/**\n * If the Shibboleth logout URL is set and the user has an active Shibboleth \n * session, log the user out of Shibboleth after logging them out of WordPress.\n */\nfunction shibboleth_logout() {\n\t$logout_url = shibboleth_get_option('shibboleth_logout_url');\n\n\tif ( !empty($logout_url) && shibboleth_session_active() ) {\n\t\twp_redirect($logout_url);\n\t\texit;\n\t}\n}\nadd_action('wp_logout', 'shibboleth_logout', 20);\n\n\n/**\n * Generate the URL to initiate Shibboleth login.\n *\n * @param string $redirect the final URL to redirect the user to after all login is complete\n * @return the URL to direct the user to in order to initiate Shibboleth login\n * @uses apply_filters() Calls 'shibboleth_session_initiator_url' before returning session intiator URL\n */\nfunction shibboleth_session_initiator_url($redirect = null) {\n\n\t// first build the target URL.  This is the WordPress URL the user will be returned to after Shibboleth \n\t// is done, and will handle actually logging the user into WordPress using the data provdied by Shibboleth \n\tif ( function_exists('switch_to_blog') ) switch_to_blog($GLOBALS['current_site']->blog_id);\n\t$target = site_url('wp-login.php');\n\tif ( function_exists('restore_current_blog') ) restore_current_blog();\n\n\t$target = add_query_arg('action', 'shibboleth', $target);\n\tif ( !empty($redirect) ) {\n\t\t$target = add_query_arg('redirect_to', urlencode($redirect), $target);\n\t}\n\n\t// now build the Shibboleth session initiator URL\n\t$initiator_url = shibboleth_get_option('shibboleth_login_url');\n\t$initiator_url = add_query_arg('target', urlencode($target), $initiator_url);\n\n\t$initiator_url = apply_filters('shibboleth_session_initiator_url', $initiator_url);\n\n\treturn $initiator_url;\n}\n\n\n/**\n * Authenticate the user based on the current Shibboleth headers.\n *\n * If the data available does not map to a WordPress role (based on the\n * configured role-mapping), the user will not be allowed to login.\n *\n * If this is the first time we've seen this user (based on the username\n * attribute), a new account will be created.\n *\n * Known users will have their profile data updated based on the Shibboleth\n * data present if the plugin is configured to do so.\n *\n * @return WP_User|WP_Error authenticated user or error if unable to authenticate\n */\nfunction shibboleth_authenticate_user() {\n\t$shib_headers = shibboleth_get_option('shibboleth_headers');\n\n\t// ensure user is authorized to login\n\t$user_role = shibboleth_get_user_role();\n\n\tif ( empty($user_role) ) {\n\t\treturn new WP_Error('no_access', __('You do not have sufficient access.'));\n\t}\n\n\t$username = $_SERVER[$shib_headers['username']['name']];\n\t$user = new WP_User($username);\n\n\tif ( $user->ID ) {\n\t\tif ( !get_usermeta($user->ID, 'shibboleth_account') ) {\n\t\t\t// TODO: what happens if non-shibboleth account by this name already exists?\n\t\t\t//return new WP_Error('invalid_username', __('Account already exists by this name.'));\n\t\t}\n\t}\n\n\t// create account if new user\n\tif ( !$user->ID ) {\n\t\t$user = shibboleth_create_new_user($username);\n\t}\n\n\tif ( !$user->ID ) {\n\t\t$error_message = 'Unable to create account based on data provided.';\n\t\tif (defined('WP_DEBUG') && WP_DEBUG) {\n\t\t\t$error_message .= '<!-- ' . print_r($_SERVER, true) . ' -->';\n\t\t}\n\t\treturn new WP_Error('missing_data', $error_message);\n\t}\n\n\t// update user data\n\tupdate_usermeta($user->ID, 'shibboleth_account', true);\n\tshibboleth_update_user_data($user->ID);\n\tif ( shibboleth_get_option('shibboleth_update_roles') ) {\n\t\t$user->set_role($user_role);\n\t\tdo_action( 'shibboleth_set_user_roles', $user );\n\t}\n\n\treturn $user;\n}\n\n\n/**\n * Create a new WordPress user account, and mark it as a Shibboleth account.\n *\n * @param string $user_login login name for the new user\n * @return object WP_User object for newly created user\n */\nfunction shibboleth_create_new_user($user_login) {\n\tif ( empty($user_login) ) return null;\n\n\t// create account and flag as a shibboleth acount\n\trequire_once( ABSPATH . WPINC . '/registration.php' );\n\t$user_id = wp_insert_user(array('user_login'=>$user_login));\n\t$user = new WP_User($user_id);\n\tupdate_usermeta($user->ID, 'shibboleth_account', true);\n\n\t// always update user data and role on account creation\n\tshibboleth_update_user_data($user->ID, true);\n\t$user_role = shibboleth_get_user_role();\n\t$user->set_role($user_role);\n\tdo_action( 'shibboleth_set_user_roles', $user );\n\n\treturn $user;\n}\n\n\n/**\n * Get the role the current user should have.  This is determined by the role\n * mapping configured for the plugin, and the Shibboleth headers present at the\n * time of login.\n *\n * @return string the role the current user should have\n * @uses apply_filters() Calls 'shibboleth_roles' after retrieving shibboleth_roles array\n * @uses apply_filters() Calls 'shibboleth_user_role' before returning final user role\n */\nfunction shibboleth_get_user_role() {\n\tglobal $wp_roles;\n\tif ( !$wp_roles ) $wp_roles = new WP_Roles();\n\n\t$shib_roles = apply_filters('shibboleth_roles', shibboleth_get_option('shibboleth_roles'));\n\t$user_role = $shib_roles['default'];\n\n\tforeach ( $wp_roles->role_names as $key => $name ) {\n\t\t$role_header = $shib_roles[$key]['header'];\n\t\t$role_value = $shib_roles[$key]['value'];\n\n\t\tif ( empty($role_header) || empty($role_value) ) continue;\n\n\t\t$values = split(';', $_SERVER[$role_header]);\n\t\tif ( in_array($role_value, $values) ) {\n\t\t\t$user_role = $key;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t$user_role = apply_filters('shibboleth_user_role', $user_role);\n\n\treturn $user_role;\n}\n\n\n/**\n * Get the user fields that are managed by Shibboleth.\n *\n * @return Array user fields managed by Shibboleth\n */\nfunction shibboleth_get_managed_user_fields() {\n\t$headers = shibboleth_get_option('shibboleth_headers');\n\t$managed = array();\n\n\tforeach ($headers as $name => $value) {\n\t\tif ( $value['managed'] ) {\n\t\t\t$managed[] = $name;\n\t\t}\n\t}\n\n\treturn $managed;\n}\n\n\n/**\n * Update the user data for the specified user based on the current Shibboleth headers.  Unless \n * the 'force_update' parameter is true, only the user fields marked as 'managed' fields will be \n * updated.\n *\n * @param int $user_id ID of the user to update\n * @param boolean $force_update force update of user data, regardless of 'managed' flag on fields\n * @uses apply_filters() Calls 'shibboleth_user_*' before setting user attributes, \n *       where '*' is one of: login, nicename, first_name, last_name, \n *       nickname, display_name, email\n */\nfunction shibboleth_update_user_data($user_id, $force_update = false) {\n\trequire_once( ABSPATH . WPINC . '/registration.php' );\n\n\t$shib_headers = shibboleth_get_option('shibboleth_headers');\n\n\t$user_fields = array(\n\t\t'user_login' => 'username',\n\t\t'user_nicename' => 'username',\n\t\t'first_name' => 'first_name',\n\t\t'last_name' => 'last_name',\n\t\t'nickname' => 'nickname',\n\t\t'display_name' => 'display_name',\n\t\t'user_email' => 'email'\n\t);\n\n\t$user_data = array(\n\t\t'ID' => $user_id,\n\t);\n\t\n\tforeach ($user_fields as $field => $header) {\n\t\tif ( $force_update || $shib_headers[$header]['managed'] ) {\n\t\t\t$filter = 'shibboleth_' . ( strpos($field, 'user_') === 0 ? '' : 'user_' ) . $field;\n\t\t\t$user_data[$field] = apply_filters($filter, $_SERVER[$shib_headers[$header]['name']]);\n\t\t}\n\t}\n\n\twp_update_user($user_data);\n}\n\n\n/**\n * Sanitize the nicename using sanitize_user\n * See discussion: http://wordpress.org/support/topic/377030\n * \n * @since 1.4\n */\nadd_filter( 'shibboleth_user_nicename', 'sanitize_user' );\n\n/**\n * Add a \"Login with Shibboleth\" link to the WordPress login form.  This link \n * will be wrapped in a <p> with an id value of \"shibboleth_login\" so that \n * deployers can style this however they choose.\n */\nfunction shibboleth_login_form() {\n\t$login_url = add_query_arg('action', 'shibboleth');\n\t$login_url = remove_query_arg('reauth', $login_url);\n\techo '<p id=\"shibboleth_login\"><a href=\"' . $login_url . '\">' . __('Login with Shibboleth', 'shibboleth') . '</a></p>';\n}\nadd_action('login_form', 'shibboleth_login_form');\n\n\n/**\n * Insert directives into .htaccess file to enable Shibboleth Lazy Sessions.\n */\nfunction shibboleth_insert_htaccess() {\n\tif ( got_mod_rewrite() ) {\n\t\t$htaccess = get_home_path() . '.htaccess';\n\t\t$rules = array('AuthType shibboleth', 'Require shibboleth');\n\t\tinsert_with_markers($htaccess, 'Shibboleth', $rules);\n\t}\n}\n\n\n/**\n * Remove directives from .htaccess file to enable Shibboleth Lazy Sessions.\n */\nfunction shibboleth_remove_htaccess() {\n\tif ( got_mod_rewrite() ) {\n\t\t$htaccess = get_home_path() . '.htaccess';\n\t\tinsert_with_markers($htaccess, 'Shibboleth', array());\n\t}\n}\n\n\n/* Custom option functions to correctly use WPMU *_site_option functions when available. */\nfunction shibboleth_get_option($key, $default = false ) {\n\treturn function_exists('get_site_option') ? get_site_option($key, $default) : get_option($key, $default);\n}\nfunction shibboleth_add_option($key, $value, $autoload = 'yes') {\n\tif (function_exists('add_site_option')) {\n\t\treturn add_site_option($key, $value);\n\t} else {\n\t\treturn add_option($key, $value, '', $autoload);\n\t}\n}\nfunction shibboleth_update_option($key, $value) {\n\treturn function_exists('update_site_option') ? update_site_option($key, $value) : update_option($key, $value);\n}\nfunction shibboleth_delete_option($key) {\n\treturn function_exists('delete_site_option') ? delete_site_option($key) : delete_option($key);\n}\n\n/**\n * Load localization files.\n */\nfunction shibboleth_load_textdomain() {\n\tload_plugin_textdomain('shibboleth', false, dirname( plugin_basename( __FILE__ ) ) . '/localization/');\n}\nadd_action('plugins_loaded', 'shibboleth_load_textdomain');\n"], "fixing_code": ["<?php\n/*\n Plugin Name: Shibboleth\n Plugin URI: http://wordpress.org/extend/plugins/shibboleth\n Description: Easily externalize user authentication to a <a href=\"http://shibboleth.internet2.edu\">Shibboleth</a> Service Provider\n Author: Will Norris, mitcho (Michael \u82b3\u8cb4 Erlewine)\n Version: 1.6\n License: Apache 2 (http://www.apache.org/licenses/LICENSE-2.0.html)\n */\n\ndefine ( 'SHIBBOLETH_PLUGIN_REVISION', preg_replace( '/\\$Rev: (.+) \\$/', '\\\\1',\n\t'$Rev$') ); // this needs to be on a separate line so that svn:keywords can work its magic\n\n\n// run activation function if new revision of plugin\n$shibboleth_plugin_revision = shibboleth_get_option('shibboleth_plugin_revision');\nif ($shibboleth_plugin_revision === false || SHIBBOLETH_PLUGIN_REVISION != $shibboleth_plugin_revision) {\n\tadd_action('admin_init', 'shibboleth_activate_plugin');\n}\n\n/**\n * Perform automatic login. This is based on the user not being logged in,\n * an active session and the option being set to true.\n */\nfunction shibboleth_auto_login() {\n\t$shibboleth_auto_login = shibboleth_get_option('shibboleth_auto_login');\n\tif ( !is_user_logged_in() && shibboleth_session_active() && $shibboleth_auto_login ) {\n\t\tdo_action('login_form_shibboleth');\n\n\t\t$userobj = wp_signon('', true);\n\t\tif ( is_wp_error($userobj) ) {\n\t\t\t// TODO: Proper error return.\n\t\t} else {\n\t\t\twp_safe_redirect($_SERVER['REQUEST_URI']);\n\t\t\texit();\n\t\t}\n\t}\n}\nadd_action('init', 'shibboleth_auto_login');\n\n/**\n * Activate the plugin.  This registers default values for all of the \n * Shibboleth options and attempts to add the appropriate mod_rewrite rules to \n * WordPress's .htaccess file.\n */\nfunction shibboleth_activate_plugin() {\n\tif ( function_exists('switch_to_blog') ) switch_to_blog($GLOBALS['current_site']->blog_id);\n\n\tshibboleth_add_option('shibboleth_login_url', get_option('home') . '/Shibboleth.sso/Login');\n\tshibboleth_add_option('shibboleth_default_login', false);\n\tshibboleth_add_option('shibboleth_auto_login', false);\n\tshibboleth_add_option('shibboleth_logout_url', get_option('home') . '/Shibboleth.sso/Logout');\n\n\t$headers = array(\n\t\t'username' => array( 'name' => 'eppn', 'managed' => false),\n\t\t'first_name' => array( 'name' => 'givenName', 'managed' => true),\n\t\t'last_name' => array( 'name' => 'sn', 'managed' => true),\n\t\t'nickname' => array( 'name' => 'eppn', 'managed' => true),\n\t\t'display_name' => array( 'name' => 'displayName', 'managed' => true),\n\t\t'email' => array( 'name' => 'mail', 'managed' => true),\n\t);\n\tshibboleth_add_option('shibboleth_headers', $headers);\n\n\t$roles = array(\n\t\t'administrator' => array(\n\t\t\t'header' => 'entitlement',\n\t\t\t'value' => 'urn:mace:example.edu:entitlement:wordpress:admin',\n\t\t),\n\t\t'author' => array(\n\t\t\t'header' => 'affiliation',\n\t\t\t'value' => 'faculty',\n\t\t),\n\t\t// TODO: this could likely do strange things if WordPress has an actual role named 'default'\n\t\t'default' => 'subscriber',\n\t);\n\tshibboleth_add_option('shibboleth_roles', $roles);\n\n\tshibboleth_add_option('shibboleth_update_roles', true);\n\n\tshibboleth_insert_htaccess();\n\n\tshibboleth_migrate_old_data();\n\n\tshibboleth_update_option('shibboleth_plugin_revision', SHIBBOLETH_PLUGIN_REVISION);\n\n\tif ( function_exists('restore_current_blog') ) restore_current_blog();\n}\nregister_activation_hook('shibboleth/shibboleth.php', 'shibboleth_activate_plugin');\n\n\n/**\n * Cleanup certain plugins options on deactivation.\n */\nfunction shibboleth_deactivate_plugin() {\n\tshibboleth_remove_htaccess();\n}\nregister_deactivation_hook('shibboleth/shibboleth.php', 'shibboleth_deactivate_plugin');\n\n\n/**\n * Migrate old data to newer formats.\n */\nfunction shibboleth_migrate_old_data() {\n\n\t// new header format, allowing each header to be marked as 'managed' individually\n\t$managed = shibboleth_get_option('shibboleth_update_users');\n\t$headers = shibboleth_get_option('shibboleth_headers');\n\t$updated = false;\n\n\tforeach ($headers as $key => $value) {\n\t\tif ( is_string($value) ) {\n\t\t\t$headers[$key] = array(\n\t\t\t\t'name' => $value,\n\t\t\t\t'managed' => $managed,\n\t\t\t);\n\t\t\t$updated = true;\n\t\t}\n\t}\n\n\tif ( $updated ) {\n\t\tshibboleth_update_option('shibboleth_headers', $headers);\n\t}\n\tshibboleth_delete_option('shibboleth_update_users');\n\n}\n\n/**\n * Load Shibboleth admin hooks only on admin page loads.  \n *\n * 'admin_init' is actually called *after* 'admin_menu', so we have to hook in \n * to the 'init' action for this.\n */\nfunction shibboleth_admin_hooks() {\n\tif ( defined('WP_ADMIN') && WP_ADMIN === true ) {\n\t\trequire_once dirname(__FILE__) . '/options-admin.php';\n\t\trequire_once dirname(__FILE__) . '/options-user.php';\n\t}\n}\nadd_action('init', 'shibboleth_admin_hooks');\n\n\n/**\n * Check if a Shibboleth session is active.\n *\n * @return boolean if session is active\n * @uses apply_filters calls 'shibboleth_session_active' before returning final result\n */\nfunction shibboleth_session_active() { \n\t$active = false;\n\n\t$session_headers = array('Shib-Session-ID', 'Shib_Session_ID', 'HTTP_SHIB_IDENTITY_PROVIDER');\n\tforeach ($session_headers as $header) {\n\t\tif ( array_key_exists($header, $_SERVER) && !empty($_SERVER[$header]) ) {\n\t\t\t$active = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t$active = apply_filters('shibboleth_session_active', $active);\n\treturn $active;\n}\n\n\n/**\n * Authenticate the user using Shibboleth.  If a Shibboleth session is active, \n * use the data provided by Shibboleth to log the user in.  If a Shibboleth \n * session is not active, redirect the user to the Shibboleth Session Initiator \n * URL to initiate the session.\n */\nfunction shibboleth_authenticate($user, $username, $password) {\n\tif ( shibboleth_session_active() ) {\n\t\treturn shibboleth_authenticate_user();\n\t} else {\n\t\t$initiator_url = shibboleth_session_initiator_url( $_REQUEST['redirect_to'] );\n\t\twp_redirect($initiator_url);\n\t\texit;\n\t}\n}\n\n\n/**\n * When wp-login.php is loaded with 'action=shibboleth', hook Shibboleth \n * into the WordPress authentication flow.\n */\nfunction shibboleth_login_form_shibboleth() {\n\tadd_filter('authenticate', 'shibboleth_authenticate', 10, 3);\n}\nadd_action('login_form_shibboleth', 'shibboleth_login_form_shibboleth');\n\n\n/**\n * If a Shibboleth user requests a password reset, and the Shibboleth password \n * reset URL is set, redirect the user there.\n */\nfunction shibboleth_retrieve_password( $user_login ) {\n\t$password_reset_url = shibboleth_get_option('shibboleth_password_reset_url');\n\n\tif ( !empty($password_reset_url) ) {\n\t\t$user = get_userdatabylogin($user_login);\n\t\tif ( $user && get_usermeta($user->ID, 'shibboleth_account') ) {\n\t\t\twp_redirect($password_reset_url);\n\t\t\texit;\n\t\t}\n\t}\n}\nadd_action('retrieve_password', 'shibboleth_retrieve_password');\n\n\n/**\n * If Shibboleth is the default login method, add 'action=shibboleth' to the \n * WordPress login URL.\n */\nfunction shibboleth_login_url($login_url) {\n\tif ( shibboleth_get_option('shibboleth_default_login') ) {\n\t\t$login_url = add_query_arg('action', 'shibboleth', $login_url);\n\t}\n\n\treturn $login_url;\n}\nadd_filter('login_url', 'shibboleth_login_url');\n\n\n/**\n * If the Shibboleth logout URL is set and the user has an active Shibboleth \n * session, log the user out of Shibboleth after logging them out of WordPress.\n */\nfunction shibboleth_logout() {\n\t$logout_url = shibboleth_get_option('shibboleth_logout_url');\n\n\tif ( !empty($logout_url) && shibboleth_session_active() ) {\n\t\twp_redirect($logout_url);\n\t\texit;\n\t}\n}\nadd_action('wp_logout', 'shibboleth_logout', 20);\n\n\n/**\n * Generate the URL to initiate Shibboleth login.\n *\n * @param string $redirect the final URL to redirect the user to after all login is complete\n * @return the URL to direct the user to in order to initiate Shibboleth login\n * @uses apply_filters() Calls 'shibboleth_session_initiator_url' before returning session intiator URL\n */\nfunction shibboleth_session_initiator_url($redirect = null) {\n\n\t// first build the target URL.  This is the WordPress URL the user will be returned to after Shibboleth \n\t// is done, and will handle actually logging the user into WordPress using the data provdied by Shibboleth \n\tif ( function_exists('switch_to_blog') ) switch_to_blog($GLOBALS['current_site']->blog_id);\n\t$target = site_url('wp-login.php');\n\tif ( function_exists('restore_current_blog') ) restore_current_blog();\n\n\t$target = add_query_arg('action', 'shibboleth', $target);\n\tif ( !empty($redirect) ) {\n\t\t$target = add_query_arg('redirect_to', urlencode($redirect), $target);\n\t}\n\n\t// now build the Shibboleth session initiator URL\n\t$initiator_url = shibboleth_get_option('shibboleth_login_url');\n\t$initiator_url = add_query_arg('target', urlencode($target), $initiator_url);\n\n\t$initiator_url = apply_filters('shibboleth_session_initiator_url', $initiator_url);\n\n\treturn $initiator_url;\n}\n\n\n/**\n * Authenticate the user based on the current Shibboleth headers.\n *\n * If the data available does not map to a WordPress role (based on the\n * configured role-mapping), the user will not be allowed to login.\n *\n * If this is the first time we've seen this user (based on the username\n * attribute), a new account will be created.\n *\n * Known users will have their profile data updated based on the Shibboleth\n * data present if the plugin is configured to do so.\n *\n * @return WP_User|WP_Error authenticated user or error if unable to authenticate\n */\nfunction shibboleth_authenticate_user() {\n\t$shib_headers = shibboleth_get_option('shibboleth_headers');\n\n\t// ensure user is authorized to login\n\t$user_role = shibboleth_get_user_role();\n\n\tif ( empty($user_role) ) {\n\t\treturn new WP_Error('no_access', __('You do not have sufficient access.'));\n\t}\n\n\t$username = $_SERVER[$shib_headers['username']['name']];\n\t$user = new WP_User($username);\n\n\tif ( $user->ID ) {\n\t\tif ( !get_usermeta($user->ID, 'shibboleth_account') ) {\n\t\t\t// TODO: what happens if non-shibboleth account by this name already exists?\n\t\t\t//return new WP_Error('invalid_username', __('Account already exists by this name.'));\n\t\t}\n\t}\n\n\t// create account if new user\n\tif ( !$user->ID ) {\n\t\t$user = shibboleth_create_new_user($username);\n\t}\n\n\tif ( !$user->ID ) {\n\t\t$error_message = 'Unable to create account based on data provided.';\n\t\tif (defined('WP_DEBUG') && WP_DEBUG) {\n\t\t\t$error_message .= '<!-- ' . print_r($_SERVER, true) . ' -->';\n\t\t}\n\t\treturn new WP_Error('missing_data', $error_message);\n\t}\n\n\t// update user data\n\tupdate_usermeta($user->ID, 'shibboleth_account', true);\n\tshibboleth_update_user_data($user->ID);\n\tif ( shibboleth_get_option('shibboleth_update_roles') ) {\n\t\t$user->set_role($user_role);\n\t\tdo_action( 'shibboleth_set_user_roles', $user );\n\t}\n\n\treturn $user;\n}\n\n\n/**\n * Create a new WordPress user account, and mark it as a Shibboleth account.\n *\n * @param string $user_login login name for the new user\n * @return object WP_User object for newly created user\n */\nfunction shibboleth_create_new_user($user_login) {\n\tif ( empty($user_login) ) return null;\n\n\t// create account and flag as a shibboleth acount\n\trequire_once( ABSPATH . WPINC . '/registration.php' );\n\t$user_id = wp_insert_user(array('user_login'=>$user_login));\n\t$user = new WP_User($user_id);\n\tupdate_usermeta($user->ID, 'shibboleth_account', true);\n\n\t// always update user data and role on account creation\n\tshibboleth_update_user_data($user->ID, true);\n\t$user_role = shibboleth_get_user_role();\n\t$user->set_role($user_role);\n\tdo_action( 'shibboleth_set_user_roles', $user );\n\n\treturn $user;\n}\n\n\n/**\n * Get the role the current user should have.  This is determined by the role\n * mapping configured for the plugin, and the Shibboleth headers present at the\n * time of login.\n *\n * @return string the role the current user should have\n * @uses apply_filters() Calls 'shibboleth_roles' after retrieving shibboleth_roles array\n * @uses apply_filters() Calls 'shibboleth_user_role' before returning final user role\n */\nfunction shibboleth_get_user_role() {\n\tglobal $wp_roles;\n\tif ( !$wp_roles ) $wp_roles = new WP_Roles();\n\n\t$shib_roles = apply_filters('shibboleth_roles', shibboleth_get_option('shibboleth_roles'));\n\t$user_role = $shib_roles['default'];\n\n\tforeach ( $wp_roles->role_names as $key => $name ) {\n\t\t$role_header = $shib_roles[$key]['header'];\n\t\t$role_value = $shib_roles[$key]['value'];\n\n\t\tif ( empty($role_header) || empty($role_value) ) continue;\n\n\t\t$values = split(';', $_SERVER[$role_header]);\n\t\tif ( in_array($role_value, $values) ) {\n\t\t\t$user_role = $key;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t$user_role = apply_filters('shibboleth_user_role', $user_role);\n\n\treturn $user_role;\n}\n\n\n/**\n * Get the user fields that are managed by Shibboleth.\n *\n * @return Array user fields managed by Shibboleth\n */\nfunction shibboleth_get_managed_user_fields() {\n\t$headers = shibboleth_get_option('shibboleth_headers');\n\t$managed = array();\n\n\tforeach ($headers as $name => $value) {\n\t\tif ( $value['managed'] ) {\n\t\t\t$managed[] = $name;\n\t\t}\n\t}\n\n\treturn $managed;\n}\n\n\n/**\n * Update the user data for the specified user based on the current Shibboleth headers.  Unless \n * the 'force_update' parameter is true, only the user fields marked as 'managed' fields will be \n * updated.\n *\n * @param int $user_id ID of the user to update\n * @param boolean $force_update force update of user data, regardless of 'managed' flag on fields\n * @uses apply_filters() Calls 'shibboleth_user_*' before setting user attributes, \n *       where '*' is one of: login, nicename, first_name, last_name, \n *       nickname, display_name, email\n */\nfunction shibboleth_update_user_data($user_id, $force_update = false) {\n\trequire_once( ABSPATH . WPINC . '/registration.php' );\n\n\t$shib_headers = shibboleth_get_option('shibboleth_headers');\n\n\t$user_fields = array(\n\t\t'user_login' => 'username',\n\t\t'user_nicename' => 'username',\n\t\t'first_name' => 'first_name',\n\t\t'last_name' => 'last_name',\n\t\t'nickname' => 'nickname',\n\t\t'display_name' => 'display_name',\n\t\t'user_email' => 'email'\n\t);\n\n\t$user_data = array(\n\t\t'ID' => $user_id,\n\t);\n\t\n\tforeach ($user_fields as $field => $header) {\n\t\tif ( $force_update || $shib_headers[$header]['managed'] ) {\n\t\t\t$filter = 'shibboleth_' . ( strpos($field, 'user_') === 0 ? '' : 'user_' ) . $field;\n\t\t\t$user_data[$field] = apply_filters($filter, $_SERVER[$shib_headers[$header]['name']]);\n\t\t}\n\t}\n\n\twp_update_user($user_data);\n}\n\n\n/**\n * Sanitize the nicename using sanitize_user\n * See discussion: http://wordpress.org/support/topic/377030\n * \n * @since 1.4\n */\nadd_filter( 'shibboleth_user_nicename', 'sanitize_user' );\n\n/**\n * Add a \"Login with Shibboleth\" link to the WordPress login form.  This link \n * will be wrapped in a <p> with an id value of \"shibboleth_login\" so that \n * deployers can style this however they choose.\n */\nfunction shibboleth_login_form() {\n\t$login_url = add_query_arg('action', 'shibboleth');\n\t$login_url = remove_query_arg('reauth', $login_url);\n\techo '<p id=\"shibboleth_login\"><a href=\"' . esc_url($login_url) . '\">' . __('Login with Shibboleth', 'shibboleth') . '</a></p>';\n}\nadd_action('login_form', 'shibboleth_login_form');\n\n\n/**\n * Insert directives into .htaccess file to enable Shibboleth Lazy Sessions.\n */\nfunction shibboleth_insert_htaccess() {\n\tif ( got_mod_rewrite() ) {\n\t\t$htaccess = get_home_path() . '.htaccess';\n\t\t$rules = array('AuthType shibboleth', 'Require shibboleth');\n\t\tinsert_with_markers($htaccess, 'Shibboleth', $rules);\n\t}\n}\n\n\n/**\n * Remove directives from .htaccess file to enable Shibboleth Lazy Sessions.\n */\nfunction shibboleth_remove_htaccess() {\n\tif ( got_mod_rewrite() ) {\n\t\t$htaccess = get_home_path() . '.htaccess';\n\t\tinsert_with_markers($htaccess, 'Shibboleth', array());\n\t}\n}\n\n\n/* Custom option functions to correctly use WPMU *_site_option functions when available. */\nfunction shibboleth_get_option($key, $default = false ) {\n\treturn function_exists('get_site_option') ? get_site_option($key, $default) : get_option($key, $default);\n}\nfunction shibboleth_add_option($key, $value, $autoload = 'yes') {\n\tif (function_exists('add_site_option')) {\n\t\treturn add_site_option($key, $value);\n\t} else {\n\t\treturn add_option($key, $value, '', $autoload);\n\t}\n}\nfunction shibboleth_update_option($key, $value) {\n\treturn function_exists('update_site_option') ? update_site_option($key, $value) : update_option($key, $value);\n}\nfunction shibboleth_delete_option($key) {\n\treturn function_exists('delete_site_option') ? delete_site_option($key) : delete_option($key);\n}\n\n/**\n * Load localization files.\n */\nfunction shibboleth_load_textdomain() {\n\tload_plugin_textdomain('shibboleth', false, dirname( plugin_basename( __FILE__ ) ) . '/localization/');\n}\nadd_action('plugins_loaded', 'shibboleth_load_textdomain');\n"], "filenames": ["shibboleth.php"], "buggy_code_start_loc": [463], "buggy_code_end_loc": [464], "fixing_code_start_loc": [463], "fixing_code_end_loc": [464], "type": "CWE-79", "message": "The shibboleth_login_form function in shibboleth.php in the Shibboleth plugin before 1.8 for WordPress is prone to an XSS vulnerability due to improper use of add_query_arg().", "other": {"cve": {"id": "CVE-2017-14313", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-12T00:29:00.193", "lastModified": "2017-11-04T01:29:35.990", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The shibboleth_login_form function in shibboleth.php in the Shibboleth plugin before 1.8 for WordPress is prone to an XSS vulnerability due to improper use of add_query_arg()."}, {"lang": "es", "value": "La funci\u00f3n shibboleth_login_form en shibboleth.php en el plugin Shibboleth en versiones anteriores a la 1.8 para WordPress es propenso a sufrir una vulnerabilidad XSS debido a un uso incorrecto de add_query_arg()."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:shibboleth_project:shibboleth:*:*:*:*:*:wordpress:*:*", "versionEndIncluding": "1.7", "matchCriteriaId": "5E2E423E-61BF-4BE9-903E-040CB84249BE"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3973", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/874416", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelryanmcneill/shibboleth/commit/1d65ad6786282d23ba1865f56e2fd19188e7c26a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/8901", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelryanmcneill/shibboleth/commit/1d65ad6786282d23ba1865f56e2fd19188e7c26a"}}