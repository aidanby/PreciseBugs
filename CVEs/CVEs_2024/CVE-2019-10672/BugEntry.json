{"buggy_code": ["/*\n\n  Copyright 2016 Christian Hoene, Symonics GmbH\n \n*/\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"reader.h\"\n\n/*\n *\n 00000370  42 54 4c 46 00 08 00 5b  01 00 00 00 2d 00 00 07  |BTLF...[....-...|\n 00000380  00 00 00 f8 ea 72 15 00  c9 03 00 00 00 26 00 00  |.....r.......&..|\n 00000390  14 00 00 00 32 32 7c 17  00 22 02 00 00 00 32 00  |....22|..\"....2.|\n 000003a0  00 0b 00 00 00 07 ef 9c  26 00 bb 01 00 00 00 46  |........&......F|\n 000003b0  00 00 09 00 00 00 e5 f6  ba 26 00 45 03 00 00 00  |.........&.E....|\n 000003c0  34 00 00 11 00 00 00 f6  71 f0 2e 00 a3 02 00 00  |4.......q.......|\n 000003d0  00 3e 00 00 0d 00 00 00  61 36 dc 36 00 79 03 00  |.>......a6.6.y..|\n 000003e0  00 00 35 00 00 12 00 00  00 97 1b 4e 45 00 88 01  |..5........NE...|\n 000003f0  00 00 00 33 00 00 08 00  00 00 56 d7 d0 47 00 ae  |...3......V..G..|\n 00000400  03 00 00 00 1b 00 00 13  00 00 00 2f 03 50 5a 00  |.........../.PZ.|\n 00000410  22 01 00 00 00 39 00 00  06 00 00 00 b7 88 37 66  |\"....9........7f|\n 00000420  00 01 03 00 00 00 28 00  00 0f 00 00 00 dc aa 47  |......(........G|\n 00000430  66 00 16 04 00 00 00 2c  00 00 15 00 00 00 6b 54  |f......,......kT|\n 00000440  7d 77 00 fd 00 00 00 00  25 00 00 05 00 00 00 7d  |}w......%......}|\n 00000450  0c 8c 9e 00 29 03 00 00  00 1c 00 00 10 00 00 00  |....)...........|\n 00000460  4c f3 0e a0 00 16 00 00  00 00 25 00 00 00 00 00  |L.........%.....|\n 00000470  00 e7 30 2d ab 00 01 02  00 00 00 21 00 00 0a 00  |..0-.......!....|\n 00000480  00 00 35 b5 69 b0 00 e1  02 00 00 00 20 00 00 0e  |..5.i....... ...|\n 00000490  00 00 00 2b c5 8b c4 00  3b 00 00 00 00 20 00 00  |...+....;.... ..|\n 000004a0  01 00 00 00 09 a0 74 cc  00 93 00 00 00 00 2f 00  |......t......./.|\n 000004b0  00 03 00 00 00 3f 48 ef  d6 00 5b 00 00 00 00 38  |.....?H...[....8|\n 000004c0  00 00 02 00 00 00 f1 7e  7d dd 00 54 02 00 00 00  |.......~}..T....|\n 000004d0  4f 00 00 0c 00 00 00 48  35 ff f5 00 c2 00 00 00  |O......H5.......|\n 000004e0  00 3b 00 00 04 00 00 00  ad 61 4e ff 63 42 f7 73  |.;.......aN.cB.s|\n 000004f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n *\n\n 00000570  42 54 4c 46 00 09 00 16  00 00 00 00 25 00 00 00  |BTLF........%...|\n 00000580  00 00 00 00 3b 00 00 00  00 20 00 00 01 00 00 00  |....;.... ......|\n 00000590  00 5b 00 00 00 00 38 00  00 02 00 00 00 00 93 00  |.[....8.........|\n 000005a0  00 00 00 2f 00 00 03 00  00 00 00 c2 00 00 00 00  |.../............|\n 000005b0  3b 00 00 04 00 00 00 00  fd 00 00 00 00 25 00 00  |;............%..|\n 000005c0  05 00 00 00 00 22 01 00  00 00 39 00 00 06 00 00  |.....\"....9.....|\n 000005d0  00 00 5b 01 00 00 00 2d  00 00 07 00 00 00 00 88  |..[....-........|\n 000005e0  01 00 00 00 33 00 00 08  00 00 00 00 bb 01 00 00  |....3...........|\n 000005f0  00 46 00 00 09 00 00 00  00 01 02 00 00 00 21 00  |.F............!.|\n 00000600  00 0a 00 00 00 00 22 02  00 00 00 32 00 00 0b 00  |......\"....2....|\n 00000610  00 00 00 54 02 00 00 00  4f 00 00 0c 00 00 00 00  |...T....O.......|\n 00000620  a3 02 00 00 00 3e 00 00  0d 00 00 00 00 e1 02 00  |.....>..........|\n 00000630  00 00 20 00 00 0e 00 00  00 00 01 03 00 00 00 28  |.. ............(|\n 00000640  00 00 0f 00 00 00 00 29  03 00 00 00 1c 00 00 10  |.......)........|\n 00000650  00 00 00 00 45 03 00 00  00 34 00 00 11 00 00 00  |....E....4......|\n 00000660  00 79 03 00 00 00 35 00  00 12 00 00 00 00 ae 03  |.y....5.........|\n 00000670  00 00 00 1b 00 00 13 00  00 00 00 c9 03 00 00 00  |................|\n 00000680  26 00 00 14 00 00 00 00  16 04 00 00 00 2c 00 00  |&............,..|\n 00000690  15 00 00 00 d3 c7 19 a0  00 00 00 00 00 00 00 00  |................|\n 000006a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n*/\n\nstatic int readBTLF(struct READER *reader, struct BTREE *btree,\n\t\t    int number_of_records, union RECORD *records) {\n\n\tint i;\n\n\tuint8_t type, message_flags;\n\tuint32_t creation_order, hash_of_name;\n\tuint64_t heap_id;\n\n\tchar buf[4];\n\n\tUNUSED(heap_id);\n\tUNUSED(hash_of_name);\n\tUNUSED(creation_order);\n\tUNUSED(message_flags);\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"BTLF\", 4)) {\n\t\tlog(\"cannot read signature of BTLF\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object BTLF must have version 0\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\ttype = (uint8_t)fgetc(reader->fhd);\n\n\tfor (i = 0; i < number_of_records; i++) {\n\n\t\tswitch (type) {\n\t\tcase 5:\n\t\t\trecords->type5.hash_of_name = (uint32_t)readValue(reader, 4);\n\t\t\trecords->type5.heap_id = readValue(reader, 7);\n\t\t\tlog(\" type5 %08X %14lX\\n\", records->type5.hash_of_name,\n\t\t\t    records->type5.heap_id);\n\t\t\trecords++;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\t/*creation_order = */readValue(reader, 8);\n\t\t\t/*heap_id = */readValue(reader, 7);\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\t/*heap_id = */readValue(reader, 8);\n\t\t\t/*message_flags = */fgetc(reader->fhd);\n\t\t\t/*creation_order = */readValue(reader, 4);\n\t\t\t/*hash_of_name = */readValue(reader, 4);\n\t\t\tbreak;\n\n\t\tcase 9:\n\t\t\t/*heap_id = */readValue(reader, 8);\n\t\t\t/*message_flags = */fgetc(reader->fhd);\n\t\t\t/*creation_order = */readValue(reader, 4);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog(\"object BTLF has unknown type %d\\n\", type);\n\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t}\n\t}\n\n/*\tfseeko(reader->fhd, bthd->root_node_address + bthd->node_size, SEEK_SET); skip checksum */\n\n\treturn MYSOFA_OK;\n}\n\n/*  III.A.2. Disk Format: Level 1A2 - Version 2 B-trees\n\n    000002d0  32 1d 42 54 48 44 00 08  00 02 00 00 11 00 00 00  |2.BTHD..........|\n    000002e0  64 28 70 03 00 00 00 00  00 00 16 00 16 00 00 00  |d(p.............|\n    000002f0  00 00 00 00 30 12 d9 6e  42 54 48 44 00 09 00 02  |....0..nBTHD....|\n    00000300  00 00 0d 00 00 00 64 28  70 05 00 00 00 00 00 00  |......d(p.......|\n    00000310  16 00 16 00 00 00 00 00  00 00 e2 0d 76 5c 46 53  |............v\\FS|\n\n*/\n\nint btreeRead(struct READER *reader, struct BTREE *btree) {\n\tchar buf[4];\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"BTHD\", 4)) {\n\t\tlog(\"cannot read signature of BTHD\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object BTHD must have version 0\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\tbtree->type = (uint8_t)fgetc(reader->fhd);\n\tbtree->node_size = (uint32_t)readValue(reader, 4);\n\tbtree->record_size = (uint16_t)readValue(reader, 2);\n\tbtree->depth = (uint16_t)readValue(reader, 2);\n\n\tbtree->split_percent = (uint8_t)fgetc(reader->fhd);\n\tbtree->merge_percent = (uint8_t)fgetc(reader->fhd);\n\tbtree->root_node_address = (uint64_t)readValue(reader,\n\t\t\t\t\t     reader->superblock.size_of_offsets);\n\tbtree->number_of_records = (uint16_t)readValue(reader, 2);\n\tif(btree->number_of_records>0x1000)\n\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\tbtree->total_number = (uint64_t)readValue(reader, reader->superblock.size_of_lengths);\n\n\t/*\tfseek(reader->fhd, 4, SEEK_CUR);  skip checksum */\n\n\tif(btree->total_number > 0x10000000)\n\t\treturn MYSOFA_NO_MEMORY;\n\tbtree->records = malloc(sizeof(btree->records[0]) * btree->total_number);\n\tif (!btree->records)\n\t\treturn MYSOFA_NO_MEMORY;\n\tmemset(btree->records, 0, sizeof(btree->records[0]) * btree->total_number);\n\n\t/* read records */\n\tif(fseek(reader->fhd, btree->root_node_address, SEEK_SET)<0)\n\t\treturn errno;\n\treturn readBTLF(reader, btree, btree->number_of_records, btree->records);\n}\n\nvoid btreeFree(struct BTREE *btree) {\n\tfree(btree->records);\n}\n\n/*  III.A.1. Disk Format: Level 1A1 - Version 1 B-trees\n *\n */\n\nint treeRead(struct READER *reader, struct DATAOBJECT *data) {\n\n\tint i, j, err, olen, elements, size, x, y, z, b, e, dy, dz, sx, sy, sz, dzy,\n\t\tszy;\n\tchar *input, *output;\n\n\tuint8_t node_type, node_level;\n\tuint16_t entries_used;\n\tuint32_t size_of_chunk;\n\tuint32_t filter_mask;\n\tuint64_t address_of_left_sibling, address_of_right_sibling, start[4],\n\t\tchild_pointer, key, store;\n\n\tchar buf[4];\n\n\tUNUSED(node_level);\n\tUNUSED(address_of_right_sibling);\n\tUNUSED(address_of_left_sibling);\n\tUNUSED(key);\n\n\tif (data->ds.dimensionality > 3) {\n\t\tlog(\"TREE dimensions > 3\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"TREE\", 4)) {\n\t\tlog(\"cannot read signature of TREE\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tnode_type = (uint8_t)fgetc(reader->fhd);\n\tnode_level = (uint8_t)fgetc(reader->fhd);\n\tentries_used = (uint16_t)readValue(reader, 2);\n\tif(entries_used>0x1000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\taddress_of_left_sibling = readValue(reader,\n\t\t\t\t\t    reader->superblock.size_of_offsets);\n\taddress_of_right_sibling = readValue(reader,\n\t\t\t\t\t     reader->superblock.size_of_offsets);\n\n\telements = 1;\n\tfor (j = 0; j < data->ds.dimensionality; j++)\n\t\telements *= data->datalayout_chunk[j];\n\tdy = data->datalayout_chunk[1];\n\tdz = data->datalayout_chunk[2];\n\tsx = data->ds.dimension_size[0];\n\tsy = data->ds.dimension_size[1];\n\tsz = data->ds.dimension_size[2];\n\tdzy = dz * dy;\n\tszy = sz * sy;\n\tsize = data->datalayout_chunk[data->ds.dimensionality];\n\n\tlog(\"elements %d size %d\\n\",elements,size);\n\n\tif (!(output = malloc(elements * size))) {\n\t\treturn MYSOFA_NO_MEMORY;\n\t}\n\n\tfor (e = 0; e < entries_used * 2; e++) {\n\t\tif (node_type == 0) {\n\t\t\tkey = readValue(reader, reader->superblock.size_of_lengths);\n\t\t} else {\n\t\t\tsize_of_chunk = (uint32_t)readValue(reader, 4);\n\t\t\tfilter_mask = (uint32_t)readValue(reader, 4);\n\t\t\tif (filter_mask) {\n\t\t\t\tlog(\"TREE all filters must be enabled\\n\");\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < data->ds.dimensionality; j++) {\n\t\t\t\tstart[j] = readValue(reader, 8);\n\t\t\t\tlog(\"start %d %lu\\n\",j,start[j]);\n\t\t\t}\n\n\t\t\tif (readValue(reader, 8)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchild_pointer = readValue(reader,\n\t\t\t\t\t\t  reader->superblock.size_of_offsets);\n\t\t\tlog(\" data at %lX len %u\\n\", child_pointer, size_of_chunk);\n\n\t\t\t/* read data */\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_pointer, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\tif (!(input = malloc(size_of_chunk))) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tif (fread(input, 1, size_of_chunk, reader->fhd) != size_of_chunk) {\n\t\t\t\tfree(output);\n\t\t\t\tfree(input);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tolen = elements * size;\n\t\t\terr = gunzip(size_of_chunk, input, &olen, output);\n\t\t\tfree(input);\n\n\t\t\tlog(\"   gunzip %d %d %d\\n\",err, olen, elements*size);\n\t\t\tif (err || olen != elements * size) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tswitch (data->ds.dimensionality) {\n\t\t\tcase 1:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements + start[0];\n\t\t\t\t\tif (x < sx) {\n\t\t\t\t\t\tj = x * size + b;\n\t\t\t\t\t\t((char*)data->data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n\t\t\t\t\ty = x % dy + start[1];\n\t\t\t\t\tx = x / dy + start[0];\n\t\t\t\t\tif (y < sy && x < sx) {\n\t\t\t\t\t\tj = ((x * sy + y) * size) + b;\n\t\t\t\t\t\t((char*)data->data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n\t\t\t\t\tz = x % dz + start[2];\n\t\t\t\t\ty = (x / dz) % dy + start[1];\n\t\t\t\t\tx = (x / dzy) + start[0];\n\t\t\t\t\tif (z < sz && y < sy && x < sx) {\n\t\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n\t\t\t\t\t\t((char*)data->data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog(\"invalid dim\\n\");\n\t\t\t\treturn MYSOFA_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tif(fseek(reader->fhd, store, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(output);\n\tif(fseek(reader->fhd, 4, SEEK_CUR)<0) /* skip checksum */\n\t\treturn errno;\n\n\treturn MYSOFA_OK;\n}\n"], "fixing_code": ["/*\n\n  Copyright 2016 Christian Hoene, Symonics GmbH\n \n*/\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"reader.h\"\n\n/*\n *\n 00000370  42 54 4c 46 00 08 00 5b  01 00 00 00 2d 00 00 07  |BTLF...[....-...|\n 00000380  00 00 00 f8 ea 72 15 00  c9 03 00 00 00 26 00 00  |.....r.......&..|\n 00000390  14 00 00 00 32 32 7c 17  00 22 02 00 00 00 32 00  |....22|..\"....2.|\n 000003a0  00 0b 00 00 00 07 ef 9c  26 00 bb 01 00 00 00 46  |........&......F|\n 000003b0  00 00 09 00 00 00 e5 f6  ba 26 00 45 03 00 00 00  |.........&.E....|\n 000003c0  34 00 00 11 00 00 00 f6  71 f0 2e 00 a3 02 00 00  |4.......q.......|\n 000003d0  00 3e 00 00 0d 00 00 00  61 36 dc 36 00 79 03 00  |.>......a6.6.y..|\n 000003e0  00 00 35 00 00 12 00 00  00 97 1b 4e 45 00 88 01  |..5........NE...|\n 000003f0  00 00 00 33 00 00 08 00  00 00 56 d7 d0 47 00 ae  |...3......V..G..|\n 00000400  03 00 00 00 1b 00 00 13  00 00 00 2f 03 50 5a 00  |.........../.PZ.|\n 00000410  22 01 00 00 00 39 00 00  06 00 00 00 b7 88 37 66  |\"....9........7f|\n 00000420  00 01 03 00 00 00 28 00  00 0f 00 00 00 dc aa 47  |......(........G|\n 00000430  66 00 16 04 00 00 00 2c  00 00 15 00 00 00 6b 54  |f......,......kT|\n 00000440  7d 77 00 fd 00 00 00 00  25 00 00 05 00 00 00 7d  |}w......%......}|\n 00000450  0c 8c 9e 00 29 03 00 00  00 1c 00 00 10 00 00 00  |....)...........|\n 00000460  4c f3 0e a0 00 16 00 00  00 00 25 00 00 00 00 00  |L.........%.....|\n 00000470  00 e7 30 2d ab 00 01 02  00 00 00 21 00 00 0a 00  |..0-.......!....|\n 00000480  00 00 35 b5 69 b0 00 e1  02 00 00 00 20 00 00 0e  |..5.i....... ...|\n 00000490  00 00 00 2b c5 8b c4 00  3b 00 00 00 00 20 00 00  |...+....;.... ..|\n 000004a0  01 00 00 00 09 a0 74 cc  00 93 00 00 00 00 2f 00  |......t......./.|\n 000004b0  00 03 00 00 00 3f 48 ef  d6 00 5b 00 00 00 00 38  |.....?H...[....8|\n 000004c0  00 00 02 00 00 00 f1 7e  7d dd 00 54 02 00 00 00  |.......~}..T....|\n 000004d0  4f 00 00 0c 00 00 00 48  35 ff f5 00 c2 00 00 00  |O......H5.......|\n 000004e0  00 3b 00 00 04 00 00 00  ad 61 4e ff 63 42 f7 73  |.;.......aN.cB.s|\n 000004f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n *\n\n 00000570  42 54 4c 46 00 09 00 16  00 00 00 00 25 00 00 00  |BTLF........%...|\n 00000580  00 00 00 00 3b 00 00 00  00 20 00 00 01 00 00 00  |....;.... ......|\n 00000590  00 5b 00 00 00 00 38 00  00 02 00 00 00 00 93 00  |.[....8.........|\n 000005a0  00 00 00 2f 00 00 03 00  00 00 00 c2 00 00 00 00  |.../............|\n 000005b0  3b 00 00 04 00 00 00 00  fd 00 00 00 00 25 00 00  |;............%..|\n 000005c0  05 00 00 00 00 22 01 00  00 00 39 00 00 06 00 00  |.....\"....9.....|\n 000005d0  00 00 5b 01 00 00 00 2d  00 00 07 00 00 00 00 88  |..[....-........|\n 000005e0  01 00 00 00 33 00 00 08  00 00 00 00 bb 01 00 00  |....3...........|\n 000005f0  00 46 00 00 09 00 00 00  00 01 02 00 00 00 21 00  |.F............!.|\n 00000600  00 0a 00 00 00 00 22 02  00 00 00 32 00 00 0b 00  |......\"....2....|\n 00000610  00 00 00 54 02 00 00 00  4f 00 00 0c 00 00 00 00  |...T....O.......|\n 00000620  a3 02 00 00 00 3e 00 00  0d 00 00 00 00 e1 02 00  |.....>..........|\n 00000630  00 00 20 00 00 0e 00 00  00 00 01 03 00 00 00 28  |.. ............(|\n 00000640  00 00 0f 00 00 00 00 29  03 00 00 00 1c 00 00 10  |.......)........|\n 00000650  00 00 00 00 45 03 00 00  00 34 00 00 11 00 00 00  |....E....4......|\n 00000660  00 79 03 00 00 00 35 00  00 12 00 00 00 00 ae 03  |.y....5.........|\n 00000670  00 00 00 1b 00 00 13 00  00 00 00 c9 03 00 00 00  |................|\n 00000680  26 00 00 14 00 00 00 00  16 04 00 00 00 2c 00 00  |&............,..|\n 00000690  15 00 00 00 d3 c7 19 a0  00 00 00 00 00 00 00 00  |................|\n 000006a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n\n*/\n\nstatic int readBTLF(struct READER *reader, struct BTREE *btree,\n\t\t    int number_of_records, union RECORD *records) {\n\n\tint i;\n\n\tuint8_t type, message_flags;\n\tuint32_t creation_order, hash_of_name;\n\tuint64_t heap_id;\n\n\tchar buf[4];\n\n\tUNUSED(heap_id);\n\tUNUSED(hash_of_name);\n\tUNUSED(creation_order);\n\tUNUSED(message_flags);\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"BTLF\", 4)) {\n\t\tlog(\"cannot read signature of BTLF\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object BTLF must have version 0\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\ttype = (uint8_t)fgetc(reader->fhd);\n\n\tfor (i = 0; i < number_of_records; i++) {\n\n\t\tswitch (type) {\n\t\tcase 5:\n\t\t\trecords->type5.hash_of_name = (uint32_t)readValue(reader, 4);\n\t\t\trecords->type5.heap_id = readValue(reader, 7);\n\t\t\tlog(\" type5 %08X %14lX\\n\", records->type5.hash_of_name,\n\t\t\t    records->type5.heap_id);\n\t\t\trecords++;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\t/*creation_order = */readValue(reader, 8);\n\t\t\t/*heap_id = */readValue(reader, 7);\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\t/*heap_id = */readValue(reader, 8);\n\t\t\t/*message_flags = */fgetc(reader->fhd);\n\t\t\t/*creation_order = */readValue(reader, 4);\n\t\t\t/*hash_of_name = */readValue(reader, 4);\n\t\t\tbreak;\n\n\t\tcase 9:\n\t\t\t/*heap_id = */readValue(reader, 8);\n\t\t\t/*message_flags = */fgetc(reader->fhd);\n\t\t\t/*creation_order = */readValue(reader, 4);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlog(\"object BTLF has unknown type %d\\n\", type);\n\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t}\n\t}\n\n/*\tfseeko(reader->fhd, bthd->root_node_address + bthd->node_size, SEEK_SET); skip checksum */\n\n\treturn MYSOFA_OK;\n}\n\n/*  III.A.2. Disk Format: Level 1A2 - Version 2 B-trees\n\n    000002d0  32 1d 42 54 48 44 00 08  00 02 00 00 11 00 00 00  |2.BTHD..........|\n    000002e0  64 28 70 03 00 00 00 00  00 00 16 00 16 00 00 00  |d(p.............|\n    000002f0  00 00 00 00 30 12 d9 6e  42 54 48 44 00 09 00 02  |....0..nBTHD....|\n    00000300  00 00 0d 00 00 00 64 28  70 05 00 00 00 00 00 00  |......d(p.......|\n    00000310  16 00 16 00 00 00 00 00  00 00 e2 0d 76 5c 46 53  |............v\\FS|\n\n*/\n\nint btreeRead(struct READER *reader, struct BTREE *btree) {\n\tchar buf[4];\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"BTHD\", 4)) {\n\t\tlog(\"cannot read signature of BTHD\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object BTHD must have version 0\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\tbtree->type = (uint8_t)fgetc(reader->fhd);\n\tbtree->node_size = (uint32_t)readValue(reader, 4);\n\tbtree->record_size = (uint16_t)readValue(reader, 2);\n\tbtree->depth = (uint16_t)readValue(reader, 2);\n\n\tbtree->split_percent = (uint8_t)fgetc(reader->fhd);\n\tbtree->merge_percent = (uint8_t)fgetc(reader->fhd);\n\tbtree->root_node_address = (uint64_t)readValue(reader,\n\t\t\t\t\t     reader->superblock.size_of_offsets);\n\tbtree->number_of_records = (uint16_t)readValue(reader, 2);\n\tif(btree->number_of_records>0x1000)\n\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\tbtree->total_number = (uint64_t)readValue(reader, reader->superblock.size_of_lengths);\n\n\t/*\tfseek(reader->fhd, 4, SEEK_CUR);  skip checksum */\n\n\tif(btree->total_number > 0x10000000)\n\t\treturn MYSOFA_NO_MEMORY;\n\tbtree->records = malloc(sizeof(btree->records[0]) * btree->total_number);\n\tif (!btree->records)\n\t\treturn MYSOFA_NO_MEMORY;\n\tmemset(btree->records, 0, sizeof(btree->records[0]) * btree->total_number);\n\n\t/* read records */\n\tif(fseek(reader->fhd, btree->root_node_address, SEEK_SET)<0)\n\t\treturn errno;\n\treturn readBTLF(reader, btree, btree->number_of_records, btree->records);\n}\n\nvoid btreeFree(struct BTREE *btree) {\n\tfree(btree->records);\n}\n\n/*  III.A.1. Disk Format: Level 1A1 - Version 1 B-trees\n *\n */\n\nint treeRead(struct READER *reader, struct DATAOBJECT *data) {\n\n\tint i, j, err, olen, elements, size, x, y, z, b, e, dy, dz, sx, sy, sz, dzy,\n\t\tszy;\n\tchar *input, *output;\n\n\tuint8_t node_type, node_level;\n\tuint16_t entries_used;\n\tuint32_t size_of_chunk;\n\tuint32_t filter_mask;\n\tuint64_t address_of_left_sibling, address_of_right_sibling, start[4],\n\t\tchild_pointer, key, store;\n\n\tchar buf[4];\n\n\tUNUSED(node_level);\n\tUNUSED(address_of_right_sibling);\n\tUNUSED(address_of_left_sibling);\n\tUNUSED(key);\n\n\tif (data->ds.dimensionality > 3) {\n\t\tlog(\"TREE dimensions > 3\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"TREE\", 4)) {\n\t\tlog(\"cannot read signature of TREE\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t} log(\"%08lX %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tnode_type = (uint8_t)fgetc(reader->fhd);\n\tnode_level = (uint8_t)fgetc(reader->fhd);\n\tentries_used = (uint16_t)readValue(reader, 2);\n\tif(entries_used>0x1000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\taddress_of_left_sibling = readValue(reader,\n\t\t\t\t\t    reader->superblock.size_of_offsets);\n\taddress_of_right_sibling = readValue(reader,\n\t\t\t\t\t     reader->superblock.size_of_offsets);\n\n\telements = 1;\n\tfor (j = 0; j < data->ds.dimensionality; j++)\n\t\telements *= data->datalayout_chunk[j];\n\tdy = data->datalayout_chunk[1];\n\tdz = data->datalayout_chunk[2];\n\tsx = data->ds.dimension_size[0];\n\tsy = data->ds.dimension_size[1];\n\tsz = data->ds.dimension_size[2];\n\tdzy = dz * dy;\n\tszy = sz * sy;\n\tsize = data->datalayout_chunk[data->ds.dimensionality];\n\n\tlog(\"elements %d size %d\\n\",elements,size);\n\n\tif (!(output = malloc(elements * size))) {\n\t\treturn MYSOFA_NO_MEMORY;\n\t}\n\n\tfor (e = 0; e < entries_used * 2; e++) {\n\t\tif (node_type == 0) {\n\t\t\tkey = readValue(reader, reader->superblock.size_of_lengths);\n\t\t} else {\n\t\t\tsize_of_chunk = (uint32_t)readValue(reader, 4);\n\t\t\tfilter_mask = (uint32_t)readValue(reader, 4);\n\t\t\tif (filter_mask) {\n\t\t\t\tlog(\"TREE all filters must be enabled\\n\");\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < data->ds.dimensionality; j++) {\n\t\t\t\tstart[j] = readValue(reader, 8);\n\t\t\t\tlog(\"start %d %lu\\n\",j,start[j]);\n\t\t\t}\n\n\t\t\tif (readValue(reader, 8)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchild_pointer = readValue(reader,\n\t\t\t\t\t\t  reader->superblock.size_of_offsets);\n\t\t\tlog(\" data at %lX len %u\\n\", child_pointer, size_of_chunk);\n\n\t\t\t/* read data */\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_pointer, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\tif (!(input = malloc(size_of_chunk))) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tif (fread(input, 1, size_of_chunk, reader->fhd) != size_of_chunk) {\n\t\t\t\tfree(output);\n\t\t\t\tfree(input);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tolen = elements * size;\n\t\t\terr = gunzip(size_of_chunk, input, &olen, output);\n\t\t\tfree(input);\n\n\t\t\tlog(\"   gunzip %d %d %d\\n\",err, olen, elements*size);\n\t\t\tif (err || olen != elements * size) {\n\t\t\t\tfree(output);\n\t\t\t\treturn MYSOFA_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tswitch (data->ds.dimensionality) {\n\t\t\tcase 1:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements + start[0];\n\t\t\t\t\tj = x * size + b;\n\t\t\t\t\tif (j>=0 && j < elements * size) {\n\t\t\t\t\t\t((char*)data->data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n\t\t\t\t\ty = x % dy + start[1];\n\t\t\t\t\tx = x / dy + start[0];\n\t\t\t\t\tj = ((x * sy + y) * size) + b;\n\t\t\t\t\tif (j>=0 && j < elements * size) {\n\t\t\t\t\t\t((char*)data->data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfor (i = 0; i < olen; i++) {\n\t\t\t\t\tb = i / elements;\n\t\t\t\t\tx = i % elements;\n\t\t\t\t\tz = x % dz + start[2];\n\t\t\t\t\ty = (x / dz) % dy + start[1];\n\t\t\t\t\tx = (x / dzy) + start[0];\n\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n\t\t\t\t\tif (j>=0 && j < elements * size) {\n\t\t\t\t\t\t((char*)data->data)[j] = output[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog(\"invalid dim\\n\");\n\t\t\t\treturn MYSOFA_INTERNAL_ERROR;\n\t\t\t}\n\n\t\t\tif(fseek(reader->fhd, store, SEEK_SET)<0) {\n\t\t\t\tfree(output);\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(output);\n\tif(fseek(reader->fhd, 4, SEEK_CUR)<0) /* skip checksum */\n\t\treturn errno;\n\n\treturn MYSOFA_OK;\n}\n"], "filenames": ["src/hdf/btree.c"], "buggy_code_start_loc": [310], "buggy_code_end_loc": [337], "fixing_code_start_loc": [310], "fixing_code_end_loc": [337], "type": "CWE-20", "message": "treeRead in hdf/btree.c in libmysofa before 0.7 does not properly validate multiplications and additions.", "other": {"cve": {"id": "CVE-2019-10672", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-31T17:29:00.243", "lastModified": "2020-01-08T14:41:45.080", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "treeRead in hdf/btree.c in libmysofa before 0.7 does not properly validate multiplications and additions."}, {"lang": "es", "value": "treeRead en hdf/btree.c en libmysofa no valida las multiplicaciones y adiciones de manera adecuada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:symonics:libmysofa:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7", "matchCriteriaId": "200E2420-73A4-47A7-9F2C-C99C647D1FB2"}]}]}], "references": [{"url": "https://github.com/hoene/libmysofa/commit/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hoene/libmysofa/compare/49aa1c7...2ed84bb", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/hoene/libmysofa/releases/tag/v0.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4033-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/hoene/libmysofa/commit/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1"}}