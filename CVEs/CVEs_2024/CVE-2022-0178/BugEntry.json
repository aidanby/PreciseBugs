{"buggy_code": ["<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\ImageUploadRequest;\nuse App\\Models\\Setting;\nuse Auth;\nuse Gate;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Image;\nuse Redirect;\nuse View;\n\n/**\n * This controller handles all actions related to User Profiles for\n * the Snipe-IT Asset Management application.\n *\n * @version    v1.0\n */\nclass ProfileController extends Controller\n{\n    /**\n     * Returns a view with the user's profile form for editing\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v1.0]\n     * @return \\Illuminate\\Contracts\\View\\View\n     */\n    public function getIndex()\n    {\n        $user = Auth::user();\n\n        return view('account/profile', compact('user'));\n    }\n\n    /**\n     * Validates and stores the user's update data.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v1.0]\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function postIndex(ImageUploadRequest $request)\n    {\n        $user = Auth::user();\n        $user->first_name = $request->input('first_name');\n        $user->last_name = $request->input('last_name');\n        $user->website = $request->input('website');\n        $user->gravatar = $request->input('gravatar');\n        $user->skin = $request->input('skin');\n        $user->phone = $request->input('phone');\n\n        if (! config('app.lock_passwords')) {\n            $user->locale = $request->input('locale', 'en');\n        }\n\n        if ((Gate::allows('self.two_factor')) && ((Setting::getSettings()->two_factor_enabled == '1') && (! config('app.lock_passwords')))) {\n            $user->two_factor_optin = $request->input('two_factor_optin', '0');\n        }\n\n        if (Gate::allows('self.edit_location') && (! config('app.lock_passwords'))) {\n            $user->location_id = $request->input('location_id');\n        }\n\n        if ($request->input('avatar_delete') == 1) {\n            $user->avatar = null;\n        }\n\n        if ($request->hasFile('avatar')) {\n            $path = 'avatars';\n\n            if (! Storage::disk('public')->exists($path)) {\n                Storage::disk('public')->makeDirectory($path, 775);\n            }\n\n            $upload = $image = $request->file('avatar');\n            $ext = $image->getClientOriginalExtension();\n            $file_name = 'avatar-'.str_random(18).'.'.$ext;\n\n            if ($image->getClientOriginalExtension() != 'svg') {\n                $upload = Image::make($image->getRealPath())->resize(84, 84);\n            }\n\n            // This requires a string instead of an object, so we use ($string)\n            Storage::disk('public')->put($path.'/'.$file_name, (string) $upload->encode());\n\n            // Remove Current image if exists\n            if (($user->avatar) && (Storage::disk('public')->exists($path.'/'.$user->avatar))) {\n                Storage::disk('public')->delete($path.'/'.$user->avatar);\n            }\n\n            $user->avatar = $file_name;\n        }\n\n        if ($user->save()) {\n            return redirect()->route('profile')->with('success', 'Account successfully updated');\n        }\n\n        return redirect()->back()->withInput()->withErrors($user->getErrors());\n    }\n\n    /**\n     * Returns a page with the API token generation interface.\n     *\n     * We created a controller method for this because closures aren't allowed\n     * in the routes file if you want to be able to cache the routes.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0]\n     * @return View\n     */\n    public function api()\n    {\n        return view('account/api');\n    }\n\n    /**\n     * User change email page.\n     *\n     * @return View\n     */\n    public function password()\n    {\n        $user = Auth::user();\n\n        return view('account/change-password', compact('user'));\n    }\n\n    /**\n     * Users change password form processing page.\n     *\n     * @return Redirect\n     */\n    public function passwordSave(Request $request)\n    {\n        if (config('app.lock_passwords')) {\n            return redirect()->route('account.password.index')->with('error', trans('admin/users/table.lock_passwords'));\n        }\n\n        $user = Auth::user();\n        if ($user->ldap_import == '1') {\n            return redirect()->route('account.password.index')->with('error', trans('admin/users/message.error.password_ldap'));\n        }\n\n        $rules = [\n            'current_password'     => 'required',\n            'password'         => Setting::passwordComplexityRulesSaving('store').'|confirmed',\n        ];\n\n        $validator = \\Validator::make($request->all(), $rules);\n        $validator->after(function ($validator) use ($request, $user) {\n            if (! Hash::check($request->input('current_password'), $user->password)) {\n                $validator->errors()->add('current_password', trans('validation.hashed_pass'));\n            }\n\n            // This checks to make sure that the user's password isn't the same as their username,\n            // email address, first name or last name (see https://github.com/snipe/snipe-it/issues/8661)\n            // While this is handled via SaveUserRequest form request in other places, we have to do this manually\n            // here because we don't have the username, etc form fields available in the profile password change\n            // form.\n\n            // There may be a more elegant way to do this in the future.\n\n            // First let's see if that option is enabled in the settings\n            if (strpos(Setting::passwordComplexityRulesSaving('store'), 'disallow_same_pwd_as_user_fields') !== false) {\n                if (($request->input('password') == $user->username) ||\n                    ($request->input('password') == $user->email) ||\n                    ($request->input('password') == $user->first_name) ||\n                    ($request->input('password') == $user->last_name)) {\n                    $validator->errors()->add('password', trans('validation.disallow_same_pwd_as_user_fields'));\n                }\n            }\n        });\n\n        if (! $validator->fails()) {\n            $user->password = Hash::make($request->input('password'));\n            $user->save();\n\n            return redirect()->route('account.password.index')->with('success', 'Password updated!');\n        }\n\n        return redirect()->back()->withInput()->withErrors($validator);\n    }\n\n    /**\n     * Save the menu state of open/closed when the user clicks on the hamburger\n     * menu.\n     *\n     * This URL is triggered via jquery in\n     * resources/views/layouts/default.blade.php\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0]\n     * @return View\n     */\n    public function getMenuState(Request $request)\n    {\n        if ($request->input('state') == 'open') {\n            $request->session()->put('menu_state', 'open');\n        } else {\n            $request->session()->put('menu_state', 'closed');\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\ImageUploadRequest;\nuse App\\Models\\Setting;\nuse Auth;\nuse Gate;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Image;\nuse Redirect;\nuse View;\n\n/**\n * This controller handles all actions related to User Profiles for\n * the Snipe-IT Asset Management application.\n *\n * @version    v1.0\n */\nclass ProfileController extends Controller\n{\n    /**\n     * Returns a view with the user's profile form for editing\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v1.0]\n     * @return \\Illuminate\\Contracts\\View\\View\n     */\n    public function getIndex()\n    {\n        $user = Auth::user();\n\n        return view('account/profile', compact('user'));\n    }\n\n    /**\n     * Validates and stores the user's update data.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v1.0]\n     * @return \\Illuminate\\Http\\RedirectResponse\n     */\n    public function postIndex(ImageUploadRequest $request)\n    {\n        $user = Auth::user();\n        $user->first_name = $request->input('first_name');\n        $user->last_name = $request->input('last_name');\n        $user->website = $request->input('website');\n        $user->gravatar = $request->input('gravatar');\n        $user->skin = $request->input('skin');\n        $user->phone = $request->input('phone');\n\n        if (! config('app.lock_passwords')) {\n            $user->locale = $request->input('locale', 'en');\n        }\n\n        if ((Gate::allows('self.two_factor')) && ((Setting::getSettings()->two_factor_enabled == '1') && (! config('app.lock_passwords')))) {\n            $user->two_factor_optin = $request->input('two_factor_optin', '0');\n        }\n\n        if (Gate::allows('self.edit_location') && (! config('app.lock_passwords'))) {\n            $user->location_id = $request->input('location_id');\n        }\n\n        if ($request->input('avatar_delete') == 1) {\n            $user->avatar = null;\n        }\n\n        if ($request->hasFile('avatar')) {\n            $path = 'avatars';\n\n            if (! Storage::disk('public')->exists($path)) {\n                Storage::disk('public')->makeDirectory($path, 775);\n            }\n\n            $upload = $image = $request->file('avatar');\n            $ext = $image->getClientOriginalExtension();\n            $file_name = 'avatar-'.str_random(18).'.'.$ext;\n\n            if ($image->getClientOriginalExtension() != 'svg') {\n                $upload = Image::make($image->getRealPath())->resize(84, 84);\n            }\n\n            // This requires a string instead of an object, so we use ($string)\n            Storage::disk('public')->put($path.'/'.$file_name, (string) $upload->encode());\n\n            // Remove Current image if exists\n            if (($user->avatar) && (Storage::disk('public')->exists($path.'/'.$user->avatar))) {\n                Storage::disk('public')->delete($path.'/'.$user->avatar);\n            }\n\n            $user->avatar = $file_name;\n        }\n\n        if ($user->save()) {\n            return redirect()->route('profile')->with('success', 'Account successfully updated');\n        }\n\n        return redirect()->back()->withInput()->withErrors($user->getErrors());\n    }\n\n    /**\n     * Returns a page with the API token generation interface.\n     *\n     * We created a controller method for this because closures aren't allowed\n     * in the routes file if you want to be able to cache the routes.\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0]\n     * @return View\n     */\n    public function api()\n    {\n\n        // Make sure the self.api permission has been granted\n        if (!Gate::allows('self.api')) {\n            abort(403);\n        }\n\n        return view('account/api');\n    }\n\n    /**\n     * User change email page.\n     *\n     * @return View\n     */\n    public function password()\n    {\n        $user = Auth::user();\n\n        return view('account/change-password', compact('user'));\n    }\n\n    /**\n     * Users change password form processing page.\n     *\n     * @return Redirect\n     */\n    public function passwordSave(Request $request)\n    {\n        if (config('app.lock_passwords')) {\n            return redirect()->route('account.password.index')->with('error', trans('admin/users/table.lock_passwords'));\n        }\n\n        $user = Auth::user();\n        if ($user->ldap_import == '1') {\n            return redirect()->route('account.password.index')->with('error', trans('admin/users/message.error.password_ldap'));\n        }\n\n        $rules = [\n            'current_password'     => 'required',\n            'password'         => Setting::passwordComplexityRulesSaving('store').'|confirmed',\n        ];\n\n        $validator = \\Validator::make($request->all(), $rules);\n        $validator->after(function ($validator) use ($request, $user) {\n            if (! Hash::check($request->input('current_password'), $user->password)) {\n                $validator->errors()->add('current_password', trans('validation.hashed_pass'));\n            }\n\n            // This checks to make sure that the user's password isn't the same as their username,\n            // email address, first name or last name (see https://github.com/snipe/snipe-it/issues/8661)\n            // While this is handled via SaveUserRequest form request in other places, we have to do this manually\n            // here because we don't have the username, etc form fields available in the profile password change\n            // form.\n\n            // There may be a more elegant way to do this in the future.\n\n            // First let's see if that option is enabled in the settings\n            if (strpos(Setting::passwordComplexityRulesSaving('store'), 'disallow_same_pwd_as_user_fields') !== false) {\n                if (($request->input('password') == $user->username) ||\n                    ($request->input('password') == $user->email) ||\n                    ($request->input('password') == $user->first_name) ||\n                    ($request->input('password') == $user->last_name)) {\n                    $validator->errors()->add('password', trans('validation.disallow_same_pwd_as_user_fields'));\n                }\n            }\n        });\n\n        if (! $validator->fails()) {\n            $user->password = Hash::make($request->input('password'));\n            $user->save();\n\n            return redirect()->route('account.password.index')->with('success', 'Password updated!');\n        }\n\n        return redirect()->back()->withInput()->withErrors($validator);\n    }\n\n    /**\n     * Save the menu state of open/closed when the user clicks on the hamburger\n     * menu.\n     *\n     * This URL is triggered via jquery in\n     * resources/views/layouts/default.blade.php\n     *\n     * @author [A. Gianotto] [<snipe@snipe.net>]\n     * @since [v4.0]\n     * @return View\n     */\n    public function getMenuState(Request $request)\n    {\n        if ($request->input('state') == 'open') {\n            $request->session()->put('menu_state', 'open');\n        } else {\n            $request->session()->put('menu_state', 'closed');\n        }\n    }\n}\n"], "filenames": ["app/Http/Controllers/ProfileController.php"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [115], "fixing_code_start_loc": [116], "fixing_code_end_loc": [122], "type": "CWE-284", "message": "snipe-it is vulnerable to Improper Access Control", "other": {"cve": {"id": "CVE-2022-0178", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-13T23:15:07.497", "lastModified": "2022-01-21T02:22:49.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snipe-it is vulnerable to Improper Access Control"}, {"lang": "es", "value": "snipe-it es vulnerable a un Control de Acceso Inapropiado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snipeitapp:snipe-it:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.8", "matchCriteriaId": "EF6A6473-761A-49EC-B29F-BDBEC2AC4CAB"}]}]}], "references": [{"url": "https://github.com/snipe/snipe-it/commit/0e5ef53c352754de2778ffa20c85da15fd6f7ae0", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/81c6b974-d0b3-410b-a902-8324a55b1368", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/snipe/snipe-it/commit/0e5ef53c352754de2778ffa20c85da15fd6f7ae0"}}