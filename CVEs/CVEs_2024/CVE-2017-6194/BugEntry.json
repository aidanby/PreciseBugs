{"buggy_code": ["/* radare - LGPL - Copyright 2016 - Oscar Salvador */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_io.h>\n#include \"bflt/bflt.h\"\n\nstatic void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}\n\nstatic int load(RBinFile *arch) {\n\tconst ut8 *bytes = r_buf_buffer (arch->buf);\n\tut64 sz = r_buf_size (arch->buf);\n\tarch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);\n\treturn arch->o->bin_obj ? true : false;\n}\n\nstatic RList *entries(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tRList *ret;\n\tRBinAddr *ptr;\n\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tptr = r_bflt_get_entry (obj);\n\tif (!ptr) {\n\t\treturn NULL;\n\t}\n\tr_list_append (ret, ptr);\n\treturn ret;\n}\n\nstatic void __patch_reloc(RBuffer *buf, ut32 addr_to_patch, ut32 data_offset) {\n\tut8 val[4] = { 0 };\n\tr_write_le32 (val, data_offset);\n\tr_buf_write_at (buf, addr_to_patch, (void *)val, sizeof (val));\n}\n\nstatic int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic RList *patch_relocs(RBin *b) {\n\tstruct r_bin_bflt_obj *bin = NULL;\n\tRList *list = NULL;\n\tRBinObject *obj;\n\tint i = 0;\n\tif (!b || !b->iob.io || !b->iob.io->desc) {\n\t\treturn NULL;\n\t}\n\tif (!b->iob.io->cached) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn list;\n\t}\n\t\n\tobj = r_bin_cur_object (b);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tbin = obj->bin_obj;\n\tlist = r_list_newf ((RListFree)free);\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\tif (bin->got_table) {\n\t\tstruct reloc_struct_t *got_table = bin->got_table;\n\t\tfor (i = 0; i < bin->n_got; i++) {\n\t\t\t__patch_reloc (bin->b, got_table[i].addr_to_patch,\n\t\t\t\t       got_table[i].data_offset);\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (reloc) {\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\treloc->paddr = got_table[i].addr_to_patch;\n\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\tr_list_append (list, reloc);\n\t\t\t}\n\t\t}\n\t\tR_FREE (bin->got_table);\n\t}\n\n\tif (bin->reloc_table) {\n\t\tstruct reloc_struct_t *reloc_table = bin->reloc_table;\n\t\tfor (i = 0; i < bin->hdr->reloc_count; i++) {\n\t\t\tint found = search_old_relocation (reloc_table, \n\t\t\t\t\t\treloc_table[i].addr_to_patch, \n\t\t\t\t\t\tbin->hdr->reloc_count);\n\t\t\tif (found != -1) {\n\t\t\t\t__patch_reloc (bin->b, reloc_table[found].addr_to_patch, \n\t\t\t\t\t\t\treloc_table[i].data_offset);\n\t\t\t} else {\n\t\t\t\t__patch_reloc (bin->b, reloc_table[i].addr_to_patch,\n\t\t\t\t\t\t\treloc_table[i].data_offset);\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (reloc) {\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\treloc->paddr = reloc_table[i].addr_to_patch;\n\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\tr_list_append (list, reloc);\n\t\t\t}\n\t\t}\n\t\tR_FREE (bin->reloc_table);\n\t}\n\tb->iob.write_at (b->iob.io, bin->b->base, bin->b->buf, bin->b->length);\n\treturn list;\n}\n\nstatic int get_ngot_entries(struct r_bin_bflt_obj *obj) {\n\tut32 data_size = obj->hdr->data_end - obj->hdr->data_start;\n\tint i = 0, n_got = 0;\n\tif (data_size > obj->size) {\n\t\treturn 0;\n\t}\n\tfor (i = 0, n_got = 0; i < data_size ; i+= 4, n_got++) {\n\t\tut32 entry, offset = obj->hdr->data_start;\n\t\tif (offset + i + sizeof (ut32) > obj->size ||\n\t\t    offset + i + sizeof (ut32) < offset) {\n\t\t\treturn 0;\n\t\t}\n\t\tint len = r_buf_read_at (obj->b, offset + i, (ut8 *)&entry,\n\t\t\t\t\t sizeof (ut32));\n\t\tif (len != sizeof (ut32)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!VALID_GOT_ENTRY (entry)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n_got;\n}\n\nstatic RList *relocs(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)free);\n\tint i, len, n_got, amount;\n\tif (!list || !obj) {\n\t\tr_list_free (list);\n\t\treturn NULL;\n\t}\n\tif (obj->hdr->flags & FLAT_FLAG_GOTPIC) {\n\t\tn_got = get_ngot_entries (obj);\n\t\tif (n_got) {\n\t\t\tamount = n_got *  sizeof (ut32);\n\t\t\tif (amount < n_got || amount > UT32_MAX) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tstruct reloc_struct_t *got_table = calloc (1, n_got * sizeof (ut32));\n\t\t\tif (got_table) {\n\t\t\t\tut32 offset = 0;\n\t\t\t\tfor (i = 0; i < n_got ; offset += 4, i++) {\n\t\t\t\t\tut32 got_entry;\n\t\t\t\t\tif (obj->hdr->data_start + offset + 4 > obj->size ||\n\t\t\t\t\t    obj->hdr->data_start + offset + 4 < offset) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlen = r_buf_read_at (obj->b, obj->hdr->data_start + offset,\n\t\t\t\t\t\t\t\t(ut8 *)&got_entry, sizeof (ut32));\n\t\t\t\t\tif (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgot_table[i].addr_to_patch = got_entry;\n\t\t\t\t\tgot_table[i].data_offset = got_entry + BFLT_HDR_SIZE;\n\t\t\t\t}\n\t\t\t\tobj->n_got = n_got;\n\t\t\t\tobj->got_table = got_table;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (obj->hdr->reloc_count > 0) {\n\t\tint n_reloc = obj->hdr->reloc_count; \n\n\t\tamount = n_reloc * sizeof (struct reloc_struct_t);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tgoto out_error;\t\n\t\t}\n\t\tstruct reloc_struct_t *reloc_table = calloc (1, amount + 1);\n\t\tif (!reloc_table) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tamount = n_reloc * sizeof (ut32);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tut32 *reloc_pointer_table = calloc (1, amount + 1);\n\t\tif (!reloc_pointer_table) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (obj->hdr->reloc_start + amount > obj->size ||\n\t\t    obj->hdr->reloc_start + amount < amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tlen = r_buf_read_at (obj->b, obj->hdr->reloc_start,\n\t\t\t\t     (ut8 *)reloc_pointer_table, amount);\n\t\tif (len != amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tfor (i = 0; i < obj->hdr->reloc_count; i++) {\n\t\t\t//XXX it doesn't take endian as consideration when swapping\n\t\t\tut32 reloc_offset =\n\t\t\t\tr_swap_ut32 (reloc_pointer_table[i]) +\n\t\t\t\tBFLT_HDR_SIZE;\n\n\t\t\tif (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) {\n\t\t\t\tut32 reloc_fixed, reloc_data_offset;\n\t\t\t\tif (reloc_offset + sizeof (ut32) > obj->size ||\n\t\t\t\t    reloc_offset + sizeof (ut32) < reloc_offset) {\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tlen = r_buf_read_at (obj->b, reloc_offset,\n\t\t\t\t\t\t     (ut8 *)&reloc_fixed,\n\t\t\t\t\t\t     sizeof (ut32));\n\t\t\t\tif (len != sizeof (ut32)) {\n\t\t\t\t\teprintf (\"problem while reading relocation entries\\n\");\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\treloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE;\n\t\t\t\treloc_table[i].addr_to_patch = reloc_offset;\n\t\t\t\treloc_table[i].data_offset = reloc_data_offset;\n\t\n\t\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\t\tif (reloc) {\n\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\treloc->paddr = reloc_table[i].addr_to_patch;\n\t\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\t\tr_list_append (list, reloc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (reloc_pointer_table);\n\t\tobj->reloc_table = reloc_table;\n\t}\n\treturn list;\nout_error:\n\tr_list_free (list);\n\treturn NULL;\t\n}\n\nstatic RBinInfo *info(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = NULL; \n\tRBinInfo *info = NULL; \n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tobj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tif (!(info = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tinfo->file = arch->file ? strdup (arch->file) : NULL;\n\tinfo->rclass = strdup (\"bflt\");\n\tinfo->bclass = strdup (\"bflt\" );\n\tinfo->type = strdup (\"bFLT (Executable file)\");\n\tinfo->os = strdup (\"Linux\");\n\tinfo->subsystem = strdup (\"Linux\");\n\tinfo->arch = strdup (\"arm\");\n\tinfo->big_endian = obj->endian;\n\tinfo->bits = 32;\n\tinfo->has_va = false;\n\tinfo->dbg_info = 0;\n\tinfo->machine = strdup (\"unknown\");\n\treturn info;\n}\n\nstatic int check_bytes(const ut8 *buf, ut64 length) {\n\treturn length > 4 && !memcmp (buf, \"bFLT\", 4);\n}\n\nstatic int check(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0; \n\tif (!bytes || !sz) {\n\t\treturn false;\n\t}\n\treturn check_bytes (bytes, sz);\n}\n\nstatic int destroy(RBinFile *arch) {\n\tr_bin_bflt_free ((struct r_bin_bflt_obj*)arch->o->bin_obj);\n\treturn true;\n}\n\nRBinPlugin r_bin_plugin_bflt = {\n\t.name = \"bflt\",\n\t.desc = \"bFLT format r_bin plugin\",\n\t.license = \"LGPL3\",\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.destroy = &destroy,\n\t.check = &check,\n\t.check_bytes = &check_bytes,\n\t.entries = &entries,\n\t.info = &info,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_bflt,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2016 - Oscar Salvador */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_io.h>\n#include \"bflt/bflt.h\"\n\nstatic void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}\n\nstatic int load(RBinFile *arch) {\n\tconst ut8 *bytes = r_buf_buffer (arch->buf);\n\tut64 sz = r_buf_size (arch->buf);\n\tarch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);\n\treturn arch->o->bin_obj ? true : false;\n}\n\nstatic RList *entries(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tRList *ret;\n\tRBinAddr *ptr;\n\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tptr = r_bflt_get_entry (obj);\n\tif (!ptr) {\n\t\treturn NULL;\n\t}\n\tr_list_append (ret, ptr);\n\treturn ret;\n}\n\nstatic void __patch_reloc(RBuffer *buf, ut32 addr_to_patch, ut32 data_offset) {\n\tut8 val[4] = { 0 };\n\tr_write_le32 (val, data_offset);\n\tr_buf_write_at (buf, addr_to_patch, (void *)val, sizeof (val));\n}\n\nstatic int search_old_relocation (struct reloc_struct_t *reloc_table,\n\t\t\t\t  ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic RList *patch_relocs(RBin *b) {\n\tstruct r_bin_bflt_obj *bin = NULL;\n\tRList *list = NULL;\n\tRBinObject *obj;\n\tint i = 0;\n\tif (!b || !b->iob.io || !b->iob.io->desc) {\n\t\treturn NULL;\n\t}\n\tif (!b->iob.io->cached) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn list;\n\t}\n\t\n\tobj = r_bin_cur_object (b);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tbin = obj->bin_obj;\n\tlist = r_list_newf ((RListFree)free);\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\tif (bin->got_table) {\n\t\tstruct reloc_struct_t *got_table = bin->got_table;\n\t\tfor (i = 0; i < bin->n_got; i++) {\n\t\t\t__patch_reloc (bin->b, got_table[i].addr_to_patch,\n\t\t\t\t       got_table[i].data_offset);\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (reloc) {\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\treloc->paddr = got_table[i].addr_to_patch;\n\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\tr_list_append (list, reloc);\n\t\t\t}\n\t\t}\n\t\tR_FREE (bin->got_table);\n\t}\n\n\tif (bin->reloc_table) {\n\t\tstruct reloc_struct_t *reloc_table = bin->reloc_table;\n\t\tfor (i = 0; i < bin->hdr->reloc_count; i++) {\n\t\t\tint found = search_old_relocation (reloc_table, \n\t\t\t\t\t\treloc_table[i].addr_to_patch, \n\t\t\t\t\t\tbin->hdr->reloc_count);\n\t\t\tif (found != -1) {\n\t\t\t\t__patch_reloc (bin->b, reloc_table[found].addr_to_patch, \n\t\t\t\t\t\t\treloc_table[i].data_offset);\n\t\t\t} else {\n\t\t\t\t__patch_reloc (bin->b, reloc_table[i].addr_to_patch,\n\t\t\t\t\t\t\treloc_table[i].data_offset);\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (reloc) {\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\treloc->paddr = reloc_table[i].addr_to_patch;\n\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\tr_list_append (list, reloc);\n\t\t\t}\n\t\t}\n\t\tR_FREE (bin->reloc_table);\n\t}\n\tb->iob.write_at (b->iob.io, bin->b->base, bin->b->buf, bin->b->length);\n\treturn list;\n}\n\nstatic int get_ngot_entries(struct r_bin_bflt_obj *obj) {\n\tut32 data_size = obj->hdr->data_end - obj->hdr->data_start;\n\tint i = 0, n_got = 0;\n\tif (data_size > obj->size) {\n\t\treturn 0;\n\t}\n\tfor (i = 0, n_got = 0; i < data_size ; i+= 4, n_got++) {\n\t\tut32 entry, offset = obj->hdr->data_start;\n\t\tif (offset + i + sizeof (ut32) > obj->size ||\n\t\t    offset + i + sizeof (ut32) < offset) {\n\t\t\treturn 0;\n\t\t}\n\t\tint len = r_buf_read_at (obj->b, offset + i, (ut8 *)&entry,\n\t\t\t\t\t sizeof (ut32));\n\t\tif (len != sizeof (ut32)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!VALID_GOT_ENTRY (entry)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n_got;\n}\n\nstatic RList *relocs(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)free);\n\tint i, len, n_got, amount;\n\tif (!list || !obj) {\n\t\tr_list_free (list);\n\t\treturn NULL;\n\t}\n\tif (obj->hdr->flags & FLAT_FLAG_GOTPIC) {\n\t\tn_got = get_ngot_entries (obj);\n\t\tif (n_got) {\n\t\t\tamount = n_got *  sizeof (ut32);\n\t\t\tif (amount < n_got || amount > UT32_MAX) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tstruct reloc_struct_t *got_table = calloc (\n\t\t\t\t1, n_got * sizeof (struct reloc_struct_t));\n\t\t\tif (got_table) {\n\t\t\t\tut32 offset = 0;\n\t\t\t\tfor (i = 0; i < n_got ; offset += 4, i++) {\n\t\t\t\t\tut32 got_entry;\n\t\t\t\t\tif (obj->hdr->data_start + offset + 4 > obj->size ||\n\t\t\t\t\t    obj->hdr->data_start + offset + 4 < offset) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlen = r_buf_read_at (obj->b, obj->hdr->data_start + offset,\n\t\t\t\t\t\t\t\t(ut8 *)&got_entry, sizeof (ut32));\n\t\t\t\t\tif (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgot_table[i].addr_to_patch = got_entry;\n\t\t\t\t\tgot_table[i].data_offset = got_entry + BFLT_HDR_SIZE;\n\t\t\t\t}\n\t\t\t\tobj->n_got = n_got;\n\t\t\t\tobj->got_table = got_table;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (obj->hdr->reloc_count > 0) {\n\t\tint n_reloc = obj->hdr->reloc_count; \n\n\t\tamount = n_reloc * sizeof (struct reloc_struct_t);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tgoto out_error;\t\n\t\t}\n\t\tstruct reloc_struct_t *reloc_table = calloc (1, amount + 1);\n\t\tif (!reloc_table) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tamount = n_reloc * sizeof (ut32);\n\t\tif (amount < n_reloc || amount > UT32_MAX) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tut32 *reloc_pointer_table = calloc (1, amount + 1);\n\t\tif (!reloc_pointer_table) {\n\t\t\tfree (reloc_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (obj->hdr->reloc_start + amount > obj->size ||\n\t\t    obj->hdr->reloc_start + amount < amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tlen = r_buf_read_at (obj->b, obj->hdr->reloc_start,\n\t\t\t\t     (ut8 *)reloc_pointer_table, amount);\n\t\tif (len != amount) {\n\t\t\tfree (reloc_table);\n\t\t\tfree (reloc_pointer_table);\n\t\t\tgoto out_error;\n\t\t}\n\t\tfor (i = 0; i < obj->hdr->reloc_count; i++) {\n\t\t\t//XXX it doesn't take endian as consideration when swapping\n\t\t\tut32 reloc_offset =\n\t\t\t\tr_swap_ut32 (reloc_pointer_table[i]) +\n\t\t\t\tBFLT_HDR_SIZE;\n\n\t\t\tif (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) {\n\t\t\t\tut32 reloc_fixed, reloc_data_offset;\n\t\t\t\tif (reloc_offset + sizeof (ut32) > obj->size ||\n\t\t\t\t    reloc_offset + sizeof (ut32) < reloc_offset) {\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tlen = r_buf_read_at (obj->b, reloc_offset,\n\t\t\t\t\t\t     (ut8 *)&reloc_fixed,\n\t\t\t\t\t\t     sizeof (ut32));\n\t\t\t\tif (len != sizeof (ut32)) {\n\t\t\t\t\teprintf (\"problem while reading relocation entries\\n\");\n\t\t\t\t\tfree (reloc_table);\n\t\t\t\t\tfree (reloc_pointer_table);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\treloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE;\n\t\t\t\treloc_table[i].addr_to_patch = reloc_offset;\n\t\t\t\treloc_table[i].data_offset = reloc_data_offset;\n\t\n\t\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\t\tif (reloc) {\n\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\treloc->paddr = reloc_table[i].addr_to_patch;\n\t\t\t\t\treloc->vaddr = reloc->paddr;\n\t\t\t\t\tr_list_append (list, reloc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (reloc_pointer_table);\n\t\tobj->reloc_table = reloc_table;\n\t}\n\treturn list;\nout_error:\n\tr_list_free (list);\n\treturn NULL;\t\n}\n\nstatic RBinInfo *info(RBinFile *arch) {\n\tstruct r_bin_bflt_obj *obj = NULL; \n\tRBinInfo *info = NULL; \n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tobj = (struct r_bin_bflt_obj*)arch->o->bin_obj;\n\tif (!(info = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tinfo->file = arch->file ? strdup (arch->file) : NULL;\n\tinfo->rclass = strdup (\"bflt\");\n\tinfo->bclass = strdup (\"bflt\" );\n\tinfo->type = strdup (\"bFLT (Executable file)\");\n\tinfo->os = strdup (\"Linux\");\n\tinfo->subsystem = strdup (\"Linux\");\n\tinfo->arch = strdup (\"arm\");\n\tinfo->big_endian = obj->endian;\n\tinfo->bits = 32;\n\tinfo->has_va = false;\n\tinfo->dbg_info = 0;\n\tinfo->machine = strdup (\"unknown\");\n\treturn info;\n}\n\nstatic int check_bytes(const ut8 *buf, ut64 length) {\n\treturn length > 4 && !memcmp (buf, \"bFLT\", 4);\n}\n\nstatic int check(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0; \n\tif (!bytes || !sz) {\n\t\treturn false;\n\t}\n\treturn check_bytes (bytes, sz);\n}\n\nstatic int destroy(RBinFile *arch) {\n\tr_bin_bflt_free ((struct r_bin_bflt_obj*)arch->o->bin_obj);\n\treturn true;\n}\n\nRBinPlugin r_bin_plugin_bflt = {\n\t.name = \"bflt\",\n\t.desc = \"bFLT format r_bin plugin\",\n\t.license = \"LGPL3\",\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.destroy = &destroy,\n\t.check = &check,\n\t.check_bytes = &check_bytes,\n\t.entries = &entries,\n\t.info = &info,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_bflt,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/p/bin_bflt.c"], "buggy_code_start_loc": [14], "buggy_code_end_loc": [167], "fixing_code_start_loc": [15], "fixing_code_end_loc": [172], "type": "CWE-119", "message": "The relocs function in libr/bin/p/bin_bflt.c in radare2 1.2.1 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.", "other": {"cve": {"id": "CVE-2017-6194", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-03T05:59:00.877", "lastModified": "2017-04-10T22:09:18.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The relocs function in libr/bin/p/bin_bflt.c in radare2 1.2.1 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file."}, {"lang": "es", "value": "La funci\u00f3n relocs en libr/bin/p/bin_bflt.c en radare2 1.2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica y ca\u00edda de la aplicaci\u00f3n) o posiblemente tener otros impactos inexpec\u00edficos a trav\u00e9s de archivos binarios manipulados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1E2BB74D-D369-43D4-9EDB-3F0DD27091B0"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97299", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/radare/radare2/issues/6829", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18"}}