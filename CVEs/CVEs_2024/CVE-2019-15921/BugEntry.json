{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * NETLINK      Generic Netlink Family\n *\n * \t\tAuthors:\tJamal Hadi Salim\n * \t\t\t\tThomas Graf <tgraf@suug.ch>\n *\t\t\t\tJohannes Berg <johannes@sipsolutions.net>\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/mutex.h>\n#include <linux/bitmap.h>\n#include <linux/rwsem.h>\n#include <linux/idr.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\nstatic DEFINE_MUTEX(genl_mutex); /* serialization of message processing */\nstatic DECLARE_RWSEM(cb_lock);\n\natomic_t genl_sk_destructing_cnt = ATOMIC_INIT(0);\nDECLARE_WAIT_QUEUE_HEAD(genl_sk_destructing_waitq);\n\nvoid genl_lock(void)\n{\n\tmutex_lock(&genl_mutex);\n}\nEXPORT_SYMBOL(genl_lock);\n\nvoid genl_unlock(void)\n{\n\tmutex_unlock(&genl_mutex);\n}\nEXPORT_SYMBOL(genl_unlock);\n\n#ifdef CONFIG_LOCKDEP\nbool lockdep_genl_is_held(void)\n{\n\treturn lockdep_is_held(&genl_mutex);\n}\nEXPORT_SYMBOL(lockdep_genl_is_held);\n#endif\n\nstatic void genl_lock_all(void)\n{\n\tdown_write(&cb_lock);\n\tgenl_lock();\n}\n\nstatic void genl_unlock_all(void)\n{\n\tgenl_unlock();\n\tup_write(&cb_lock);\n}\n\nstatic DEFINE_IDR(genl_fam_idr);\n\n/*\n * Bitmap of multicast groups that are currently in use.\n *\n * To avoid an allocation at boot of just one unsigned long,\n * declare it global instead.\n * Bit 0 is marked as already used since group 0 is invalid.\n * Bit 1 is marked as already used since the drop-monitor code\n * abuses the API and thinks it can statically use group 1.\n * That group will typically conflict with other groups that\n * any proper users use.\n * Bit 16 is marked as used since it's used for generic netlink\n * and the code no longer marks pre-reserved IDs as used.\n * Bit 17 is marked as already used since the VFS quota code\n * also abused this API and relied on family == group ID, we\n * cater to that by giving it a static family and group ID.\n * Bit 18 is marked as already used since the PMCRAID driver\n * did the same thing as the VFS quota code (maybe copied?)\n */\nstatic unsigned long mc_group_start = 0x3 | BIT(GENL_ID_CTRL) |\n\t\t\t\t      BIT(GENL_ID_VFS_DQUOT) |\n\t\t\t\t      BIT(GENL_ID_PMCRAID);\nstatic unsigned long *mc_groups = &mc_group_start;\nstatic unsigned long mc_groups_longs = 1;\n\nstatic int genl_ctrl_event(int event, const struct genl_family *family,\n\t\t\t   const struct genl_multicast_group *grp,\n\t\t\t   int grp_id);\n\nstatic const struct genl_family *genl_family_find_byid(unsigned int id)\n{\n\treturn idr_find(&genl_fam_idr, id);\n}\n\nstatic const struct genl_family *genl_family_find_byname(char *name)\n{\n\tconst struct genl_family *family;\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, family, id)\n\t\tif (strcmp(family->name, name) == 0)\n\t\t\treturn family;\n\n\treturn NULL;\n}\n\nstatic const struct genl_ops *genl_get_cmd(u8 cmd,\n\t\t\t\t\t   const struct genl_family *family)\n{\n\tint i;\n\n\tfor (i = 0; i < family->n_ops; i++)\n\t\tif (family->ops[i].cmd == cmd)\n\t\t\treturn &family->ops[i];\n\n\treturn NULL;\n}\n\nstatic int genl_allocate_reserve_groups(int n_groups, int *first_id)\n{\n\tunsigned long *new_groups;\n\tint start = 0;\n\tint i;\n\tint id;\n\tbool fits;\n\n\tdo {\n\t\tif (start == 0)\n\t\t\tid = find_first_zero_bit(mc_groups,\n\t\t\t\t\t\t mc_groups_longs *\n\t\t\t\t\t\t BITS_PER_LONG);\n\t\telse\n\t\t\tid = find_next_zero_bit(mc_groups,\n\t\t\t\t\t\tmc_groups_longs * BITS_PER_LONG,\n\t\t\t\t\t\tstart);\n\n\t\tfits = true;\n\t\tfor (i = id;\n\t\t     i < min_t(int, id + n_groups,\n\t\t\t       mc_groups_longs * BITS_PER_LONG);\n\t\t     i++) {\n\t\t\tif (test_bit(i, mc_groups)) {\n\t\t\t\tstart = i;\n\t\t\t\tfits = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (id + n_groups > mc_groups_longs * BITS_PER_LONG) {\n\t\t\tunsigned long new_longs = mc_groups_longs +\n\t\t\t\t\t\t  BITS_TO_LONGS(n_groups);\n\t\t\tsize_t nlen = new_longs * sizeof(unsigned long);\n\n\t\t\tif (mc_groups == &mc_group_start) {\n\t\t\t\tnew_groups = kzalloc(nlen, GFP_KERNEL);\n\t\t\t\tif (!new_groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmc_groups = new_groups;\n\t\t\t\t*mc_groups = mc_group_start;\n\t\t\t} else {\n\t\t\t\tnew_groups = krealloc(mc_groups, nlen,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\t\tif (!new_groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmc_groups = new_groups;\n\t\t\t\tfor (i = 0; i < BITS_TO_LONGS(n_groups); i++)\n\t\t\t\t\tmc_groups[mc_groups_longs + i] = 0;\n\t\t\t}\n\t\t\tmc_groups_longs = new_longs;\n\t\t}\n\t} while (!fits);\n\n\tfor (i = id; i < id + n_groups; i++)\n\t\tset_bit(i, mc_groups);\n\t*first_id = id;\n\treturn 0;\n}\n\nstatic struct genl_family genl_ctrl;\n\nstatic int genl_validate_assign_mc_groups(struct genl_family *family)\n{\n\tint first_id;\n\tint n_groups = family->n_mcgrps;\n\tint err = 0, i;\n\tbool groups_allocated = false;\n\n\tif (!n_groups)\n\t\treturn 0;\n\n\tfor (i = 0; i < n_groups; i++) {\n\t\tconst struct genl_multicast_group *grp = &family->mcgrps[i];\n\n\t\tif (WARN_ON(grp->name[0] == '\\0'))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(memchr(grp->name, '\\0', GENL_NAMSIZ) == NULL))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* special-case our own group and hacks */\n\tif (family == &genl_ctrl) {\n\t\tfirst_id = GENL_ID_CTRL;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (strcmp(family->name, \"NET_DM\") == 0) {\n\t\tfirst_id = 1;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (family->id == GENL_ID_VFS_DQUOT) {\n\t\tfirst_id = GENL_ID_VFS_DQUOT;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (family->id == GENL_ID_PMCRAID) {\n\t\tfirst_id = GENL_ID_PMCRAID;\n\t\tBUG_ON(n_groups != 1);\n\t} else {\n\t\tgroups_allocated = true;\n\t\terr = genl_allocate_reserve_groups(n_groups, &first_id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfamily->mcgrp_offset = first_id;\n\n\t/* if still initializing, can't and don't need to to realloc bitmaps */\n\tif (!init_net.genl_sock)\n\t\treturn 0;\n\n\tif (family->netnsok) {\n\t\tstruct net *net;\n\n\t\tnetlink_table_grab();\n\t\trcu_read_lock();\n\t\tfor_each_net_rcu(net) {\n\t\t\terr = __netlink_change_ngroups(net->genl_sock,\n\t\t\t\t\tmc_groups_longs * BITS_PER_LONG);\n\t\t\tif (err) {\n\t\t\t\t/*\n\t\t\t\t * No need to roll back, can only fail if\n\t\t\t\t * memory allocation fails and then the\n\t\t\t\t * number of _possible_ groups has been\n\t\t\t\t * increased on some sockets which is ok.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tnetlink_table_ungrab();\n\t} else {\n\t\terr = netlink_change_ngroups(init_net.genl_sock,\n\t\t\t\t\t     mc_groups_longs * BITS_PER_LONG);\n\t}\n\n\tif (groups_allocated && err) {\n\t\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\t\tclear_bit(family->mcgrp_offset + i, mc_groups);\n\t}\n\n\treturn err;\n}\n\nstatic void genl_unregister_mc_groups(const struct genl_family *family)\n{\n\tstruct net *net;\n\tint i;\n\n\tnetlink_table_grab();\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\t\t__netlink_clear_multicast_users(\n\t\t\t\tnet->genl_sock, family->mcgrp_offset + i);\n\t}\n\trcu_read_unlock();\n\tnetlink_table_ungrab();\n\n\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\tint grp_id = family->mcgrp_offset + i;\n\n\t\tif (grp_id != 1)\n\t\t\tclear_bit(grp_id, mc_groups);\n\t\tgenl_ctrl_event(CTRL_CMD_DELMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], grp_id);\n\t}\n}\n\nstatic int genl_validate_ops(const struct genl_family *family)\n{\n\tconst struct genl_ops *ops = family->ops;\n\tunsigned int n_ops = family->n_ops;\n\tint i, j;\n\n\tif (WARN_ON(n_ops && !ops))\n\t\treturn -EINVAL;\n\n\tif (!n_ops)\n\t\treturn 0;\n\n\tfor (i = 0; i < n_ops; i++) {\n\t\tif (ops[i].dumpit == NULL && ops[i].doit == NULL)\n\t\t\treturn -EINVAL;\n\t\tfor (j = i + 1; j < n_ops; j++)\n\t\t\tif (ops[i].cmd == ops[j].cmd)\n\t\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * genl_register_family - register a generic netlink family\n * @family: generic netlink family\n *\n * Registers the specified family after validating it first. Only one\n * family may be registered with the same family name or identifier.\n *\n * The family's ops, multicast groups and module pointer must already\n * be assigned.\n *\n * Return 0 on success or a negative error code.\n */\nint genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\n\tgenl_lock_all();\n\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\n\t/*\n\t * Sadly, a few cases need to be special-cased\n\t * due to them having previously abused the API\n\t * and having used their family ID also as their\n\t * multicast group ID, so we use reserved IDs\n\t * for both to be sure we can do that mapping.\n\t */\n\tif (family == &genl_ctrl) {\n\t\t/* and this needs to be special for initial family lookups */\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\n\tgenl_unlock_all();\n\n\t/* send all events */\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\n\treturn 0;\n\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}\nEXPORT_SYMBOL(genl_register_family);\n\n/**\n * genl_unregister_family - unregister generic netlink family\n * @family: generic netlink family\n *\n * Unregisters the specified family.\n *\n * Returns 0 on success or a negative error code.\n */\nint genl_unregister_family(const struct genl_family *family)\n{\n\tgenl_lock_all();\n\n\tif (!genl_family_find_byid(family->id)) {\n\t\tgenl_unlock_all();\n\t\treturn -ENOENT;\n\t}\n\n\tgenl_unregister_mc_groups(family);\n\n\tidr_remove(&genl_fam_idr, family->id);\n\n\tup_write(&cb_lock);\n\twait_event(genl_sk_destructing_waitq,\n\t\t   atomic_read(&genl_sk_destructing_cnt) == 0);\n\tgenl_unlock();\n\n\tkfree(family->attrbuf);\n\n\tgenl_ctrl_event(CTRL_CMD_DELFAMILY, family, NULL, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genl_unregister_family);\n\n/**\n * genlmsg_put - Add generic netlink header to netlink message\n * @skb: socket buffer holding the message\n * @portid: netlink portid the message is addressed to\n * @seq: sequence number (usually the one of the sender)\n * @family: generic netlink family\n * @flags: netlink message flags\n * @cmd: generic netlink command\n *\n * Returns pointer to user specific header\n */\nvoid *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t  const struct genl_family *family, int flags, u8 cmd)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct genlmsghdr *hdr;\n\n\tnlh = nlmsg_put(skb, portid, seq, family->id, GENL_HDRLEN +\n\t\t\tfamily->hdrsize, flags);\n\tif (nlh == NULL)\n\t\treturn NULL;\n\n\thdr = nlmsg_data(nlh);\n\thdr->cmd = cmd;\n\thdr->version = family->version;\n\thdr->reserved = 0;\n\n\treturn (char *) hdr + GENL_HDRLEN;\n}\nEXPORT_SYMBOL(genlmsg_put);\n\nstatic int genl_lock_start(struct netlink_callback *cb)\n{\n\t/* our ops are always const - netlink API doesn't propagate that */\n\tconst struct genl_ops *ops = cb->data;\n\tint rc = 0;\n\n\tif (ops->start) {\n\t\tgenl_lock();\n\t\trc = ops->start(cb);\n\t\tgenl_unlock();\n\t}\n\treturn rc;\n}\n\nstatic int genl_lock_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\t/* our ops are always const - netlink API doesn't propagate that */\n\tconst struct genl_ops *ops = cb->data;\n\tint rc;\n\n\tgenl_lock();\n\trc = ops->dumpit(skb, cb);\n\tgenl_unlock();\n\treturn rc;\n}\n\nstatic int genl_lock_done(struct netlink_callback *cb)\n{\n\t/* our ops are always const - netlink API doesn't propagate that */\n\tconst struct genl_ops *ops = cb->data;\n\tint rc = 0;\n\n\tif (ops->done) {\n\t\tgenl_lock();\n\t\trc = ops->done(cb);\n\t\tgenl_unlock();\n\t}\n\treturn rc;\n}\n\nstatic int genl_family_rcv_msg(const struct genl_family *family,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tconst struct genl_ops *ops;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct genl_info info;\n\tstruct genlmsghdr *hdr = nlmsg_data(nlh);\n\tstruct nlattr **attrbuf;\n\tint hdrlen, err;\n\n\t/* this family doesn't exist in this netns */\n\tif (!family->netnsok && !net_eq(net, &init_net))\n\t\treturn -ENOENT;\n\n\thdrlen = GENL_HDRLEN + family->hdrsize;\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\tops = genl_get_cmd(hdr->cmd, family);\n\tif (ops == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ops->flags & GENL_ADMIN_PERM) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((ops->flags & GENL_UNS_ADMIN_PERM) &&\n\t    !netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {\n\t\tint rc;\n\n\t\tif (ops->dumpit == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!family->parallel_ops) {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t/* we have const, but the netlink API doesn't */\n\t\t\t\t.data = (void *)ops,\n\t\t\t\t.start = genl_lock_start,\n\t\t\t\t.dump = genl_lock_dumpit,\n\t\t\t\t.done = genl_lock_done,\n\t\t\t};\n\n\t\t\tgenl_unlock();\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t\tgenl_lock();\n\n\t\t} else {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t.start = ops->start,\n\t\t\t\t.dump = ops->dumpit,\n\t\t\t\t.done = ops->done,\n\t\t\t};\n\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tif (ops->doit == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (family->maxattr && family->parallel_ops) {\n\t\tattrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (attrbuf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tattrbuf = family->attrbuf;\n\n\tif (attrbuf) {\n\t\terr = nlmsg_parse(nlh, hdrlen, attrbuf, family->maxattr,\n\t\t\t\t  ops->policy, extack);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tinfo.snd_seq = nlh->nlmsg_seq;\n\tinfo.snd_portid = NETLINK_CB(skb).portid;\n\tinfo.nlhdr = nlh;\n\tinfo.genlhdr = nlmsg_data(nlh);\n\tinfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;\n\tinfo.attrs = attrbuf;\n\tinfo.extack = extack;\n\tgenl_info_net_set(&info, net);\n\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\n\n\tif (family->pre_doit) {\n\t\terr = family->pre_doit(ops, skb, &info);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ops->doit(skb, &info);\n\n\tif (family->post_doit)\n\t\tfamily->post_doit(ops, skb, &info);\n\nout:\n\tif (family->parallel_ops)\n\t\tkfree(attrbuf);\n\n\treturn err;\n}\n\nstatic int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct genl_family *family;\n\tint err;\n\n\tfamily = genl_family_find_byid(nlh->nlmsg_type);\n\tif (family == NULL)\n\t\treturn -ENOENT;\n\n\tif (!family->parallel_ops)\n\t\tgenl_lock();\n\n\terr = genl_family_rcv_msg(family, skb, nlh, extack);\n\n\tif (!family->parallel_ops)\n\t\tgenl_unlock();\n\n\treturn err;\n}\n\nstatic void genl_rcv(struct sk_buff *skb)\n{\n\tdown_read(&cb_lock);\n\tnetlink_rcv_skb(skb, &genl_rcv_msg);\n\tup_read(&cb_lock);\n}\n\n/**************************************************************************\n * Controller\n **************************************************************************/\n\nstatic struct genl_family genl_ctrl;\n\nstatic int ctrl_fill_info(const struct genl_family *family, u32 portid, u32 seq,\n\t\t\t  u32 flags, struct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id) ||\n\t    nla_put_u32(skb, CTRL_ATTR_VERSION, family->version) ||\n\t    nla_put_u32(skb, CTRL_ATTR_HDRSIZE, family->hdrsize) ||\n\t    nla_put_u32(skb, CTRL_ATTR_MAXATTR, family->maxattr))\n\t\tgoto nla_put_failure;\n\n\tif (family->n_ops) {\n\t\tstruct nlattr *nla_ops;\n\t\tint i;\n\n\t\tnla_ops = nla_nest_start(skb, CTRL_ATTR_OPS);\n\t\tif (nla_ops == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_ops; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_ops *ops = &family->ops[i];\n\t\t\tu32 op_flags = ops->flags;\n\n\t\t\tif (ops->dumpit)\n\t\t\t\top_flags |= GENL_CMD_CAP_DUMP;\n\t\t\tif (ops->doit)\n\t\t\t\top_flags |= GENL_CMD_CAP_DO;\n\t\t\tif (ops->policy)\n\t\t\t\top_flags |= GENL_CMD_CAP_HASPOL;\n\n\t\t\tnest = nla_nest_start(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_OP_ID, ops->cmd) ||\n\t\t\t    nla_put_u32(skb, CTRL_ATTR_OP_FLAGS, op_flags))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\n\t\tnla_nest_end(skb, nla_ops);\n\t}\n\n\tif (family->n_mcgrps) {\n\t\tstruct nlattr *nla_grps;\n\t\tint i;\n\n\t\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\t\tif (nla_grps == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_multicast_group *grp;\n\n\t\t\tgrp = &family->mcgrps[i];\n\n\t\t\tnest = nla_nest_start(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID,\n\t\t\t\t\tfamily->mcgrp_offset + i) ||\n\t\t\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t\t\t   grp->name))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t\tnla_nest_end(skb, nla_grps);\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ctrl_fill_mcgrp_info(const struct genl_family *family,\n\t\t\t\tconst struct genl_multicast_group *grp,\n\t\t\t\tint grp_id, u32 portid, u32 seq, u32 flags,\n\t\t\t\tstruct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nla_grps;\n\tstruct nlattr *nest;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id))\n\t\tgoto nla_put_failure;\n\n\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\tif (nla_grps == NULL)\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, 1);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID, grp_id) ||\n\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t   grp->name))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\tnla_nest_end(skb, nla_grps);\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint n = 0;\n\tstruct genl_family *rt;\n\tstruct net *net = sock_net(skb->sk);\n\tint fams_to_skip = cb->args[0];\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, rt, id) {\n\t\tif (!rt->netnsok && !net_eq(net, &init_net))\n\t\t\tcontinue;\n\n\t\tif (n++ < fams_to_skip)\n\t\t\tcontinue;\n\n\t\tif (ctrl_fill_info(rt, NETLINK_CB(cb->skb).portid,\n\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t   skb, CTRL_CMD_NEWFAMILY) < 0) {\n\t\t\tn--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[0] = n;\n\treturn skb->len;\n}\n\nstatic struct sk_buff *ctrl_build_family_msg(const struct genl_family *family,\n\t\t\t\t\t     u32 portid, int seq, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\terr = ctrl_fill_info(family, portid, seq, 0, skb, cmd);\n\tif (err < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nctrl_build_mcgrp_msg(const struct genl_family *family,\n\t\t     const struct genl_multicast_group *grp,\n\t\t     int grp_id, u32 portid, int seq, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\terr = ctrl_fill_mcgrp_info(family, grp, grp_id, portid,\n\t\t\t\t   seq, 0, skb, cmd);\n\tif (err < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic const struct nla_policy ctrl_policy[CTRL_ATTR_MAX+1] = {\n\t[CTRL_ATTR_FAMILY_ID]\t= { .type = NLA_U16 },\n\t[CTRL_ATTR_FAMILY_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = GENL_NAMSIZ - 1 },\n};\n\nstatic int ctrl_getfamily(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tconst struct genl_family *res = NULL;\n\tint err = -EINVAL;\n\n\tif (info->attrs[CTRL_ATTR_FAMILY_ID]) {\n\t\tu16 id = nla_get_u16(info->attrs[CTRL_ATTR_FAMILY_ID]);\n\t\tres = genl_family_find_byid(id);\n\t\terr = -ENOENT;\n\t}\n\n\tif (info->attrs[CTRL_ATTR_FAMILY_NAME]) {\n\t\tchar *name;\n\n\t\tname = nla_data(info->attrs[CTRL_ATTR_FAMILY_NAME]);\n\t\tres = genl_family_find_byname(name);\n#ifdef CONFIG_MODULES\n\t\tif (res == NULL) {\n\t\t\tgenl_unlock();\n\t\t\tup_read(&cb_lock);\n\t\t\trequest_module(\"net-pf-%d-proto-%d-family-%s\",\n\t\t\t\t       PF_NETLINK, NETLINK_GENERIC, name);\n\t\t\tdown_read(&cb_lock);\n\t\t\tgenl_lock();\n\t\t\tres = genl_family_find_byname(name);\n\t\t}\n#endif\n\t\terr = -ENOENT;\n\t}\n\n\tif (res == NULL)\n\t\treturn err;\n\n\tif (!res->netnsok && !net_eq(genl_info_net(info), &init_net)) {\n\t\t/* family doesn't exist here */\n\t\treturn -ENOENT;\n\t}\n\n\tmsg = ctrl_build_family_msg(res, info->snd_portid, info->snd_seq,\n\t\t\t\t    CTRL_CMD_NEWFAMILY);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int genl_ctrl_event(int event, const struct genl_family *family,\n\t\t\t   const struct genl_multicast_group *grp,\n\t\t\t   int grp_id)\n{\n\tstruct sk_buff *msg;\n\n\t/* genl is still initialising */\n\tif (!init_net.genl_sock)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase CTRL_CMD_NEWFAMILY:\n\tcase CTRL_CMD_DELFAMILY:\n\t\tWARN_ON(grp);\n\t\tmsg = ctrl_build_family_msg(family, 0, 0, event);\n\t\tbreak;\n\tcase CTRL_CMD_NEWMCAST_GRP:\n\tcase CTRL_CMD_DELMCAST_GRP:\n\t\tBUG_ON(!grp);\n\t\tmsg = ctrl_build_mcgrp_msg(family, grp, grp_id, 0, 0, event);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tif (!family->netnsok) {\n\t\tgenlmsg_multicast_netns(&genl_ctrl, &init_net, msg, 0,\n\t\t\t\t\t0, GFP_KERNEL);\n\t} else {\n\t\trcu_read_lock();\n\t\tgenlmsg_multicast_allns(&genl_ctrl, msg, 0,\n\t\t\t\t\t0, GFP_ATOMIC);\n\t\trcu_read_unlock();\n\t}\n\n\treturn 0;\n}\n\nstatic const struct genl_ops genl_ctrl_ops[] = {\n\t{\n\t\t.cmd\t\t= CTRL_CMD_GETFAMILY,\n\t\t.doit\t\t= ctrl_getfamily,\n\t\t.dumpit\t\t= ctrl_dumpfamily,\n\t\t.policy\t\t= ctrl_policy,\n\t},\n};\n\nstatic const struct genl_multicast_group genl_ctrl_groups[] = {\n\t{ .name = \"notify\", },\n};\n\nstatic struct genl_family genl_ctrl __ro_after_init = {\n\t.module = THIS_MODULE,\n\t.ops = genl_ctrl_ops,\n\t.n_ops = ARRAY_SIZE(genl_ctrl_ops),\n\t.mcgrps = genl_ctrl_groups,\n\t.n_mcgrps = ARRAY_SIZE(genl_ctrl_groups),\n\t.id = GENL_ID_CTRL,\n\t.name = \"nlctrl\",\n\t.version = 0x2,\n\t.maxattr = CTRL_ATTR_MAX,\n\t.netnsok = true,\n};\n\nstatic int genl_bind(struct net *net, int group)\n{\n\tstruct genl_family *f;\n\tint err = -ENOENT;\n\tunsigned int id;\n\n\tdown_read(&cb_lock);\n\n\tidr_for_each_entry(&genl_fam_idr, f, id) {\n\t\tif (group >= f->mcgrp_offset &&\n\t\t    group < f->mcgrp_offset + f->n_mcgrps) {\n\t\t\tint fam_grp = group - f->mcgrp_offset;\n\n\t\t\tif (!f->netnsok && net != &init_net)\n\t\t\t\terr = -ENOENT;\n\t\t\telse if (f->mcast_bind)\n\t\t\t\terr = f->mcast_bind(net, fam_grp);\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cb_lock);\n\n\treturn err;\n}\n\nstatic void genl_unbind(struct net *net, int group)\n{\n\tstruct genl_family *f;\n\tunsigned int id;\n\n\tdown_read(&cb_lock);\n\n\tidr_for_each_entry(&genl_fam_idr, f, id) {\n\t\tif (group >= f->mcgrp_offset &&\n\t\t    group < f->mcgrp_offset + f->n_mcgrps) {\n\t\t\tint fam_grp = group - f->mcgrp_offset;\n\n\t\t\tif (f->mcast_unbind)\n\t\t\t\tf->mcast_unbind(net, fam_grp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cb_lock);\n}\n\nstatic int __net_init genl_pernet_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t\t= genl_rcv,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t\t.bind\t\t= genl_bind,\n\t\t.unbind\t\t= genl_unbind,\n\t};\n\n\t/* we'll bump the group number right afterwards */\n\tnet->genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &cfg);\n\n\tif (!net->genl_sock && net_eq(net, &init_net))\n\t\tpanic(\"GENL: Cannot initialize generic netlink\\n\");\n\n\tif (!net->genl_sock)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit genl_pernet_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->genl_sock);\n\tnet->genl_sock = NULL;\n}\n\nstatic struct pernet_operations genl_pernet_ops = {\n\t.init = genl_pernet_init,\n\t.exit = genl_pernet_exit,\n};\n\nstatic int __init genl_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&genl_ctrl);\n\tif (err < 0)\n\t\tgoto problem;\n\n\terr = register_pernet_subsys(&genl_pernet_ops);\n\tif (err)\n\t\tgoto problem;\n\n\treturn 0;\n\nproblem:\n\tpanic(\"GENL: Cannot register controller: %d\\n\", err);\n}\n\nsubsys_initcall(genl_init);\n\n/**\n * genl_family_attrbuf - return family's attrbuf\n * @family: the family\n *\n * Return the family's attrbuf, while validating that it's\n * actually valid to access it.\n *\n * You cannot use this function with a family that has parallel_ops\n * and you can only use it within (pre/post) doit/dumpit callbacks.\n */\nstruct nlattr **genl_family_attrbuf(const struct genl_family *family)\n{\n\tif (!WARN_ON(family->parallel_ops))\n\t\tlockdep_assert_held(&genl_mutex);\n\n\treturn family->attrbuf;\n}\nEXPORT_SYMBOL(genl_family_attrbuf);\n\nstatic int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,\n\t\t\t gfp_t flags)\n{\n\tstruct sk_buff *tmp;\n\tstruct net *net, *prev = NULL;\n\tbool delivered = false;\n\tint err;\n\n\tfor_each_net_rcu(net) {\n\t\tif (prev) {\n\t\t\ttmp = skb_clone(skb, flags);\n\t\t\tif (!tmp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = nlmsg_multicast(prev->genl_sock, tmp,\n\t\t\t\t\t      portid, group, flags);\n\t\t\tif (!err)\n\t\t\t\tdelivered = true;\n\t\t\telse if (err != -ESRCH)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tprev = net;\n\t}\n\n\terr = nlmsg_multicast(prev->genl_sock, skb, portid, group, flags);\n\tif (!err)\n\t\tdelivered = true;\n\telse if (err != -ESRCH)\n\t\treturn err;\n\treturn delivered ? 0 : -ESRCH;\n error:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nint genlmsg_multicast_allns(const struct genl_family *family,\n\t\t\t    struct sk_buff *skb, u32 portid,\n\t\t\t    unsigned int group, gfp_t flags)\n{\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn -EINVAL;\n\tgroup = family->mcgrp_offset + group;\n\treturn genlmsg_mcast(skb, portid, group, flags);\n}\nEXPORT_SYMBOL(genlmsg_multicast_allns);\n\nvoid genl_notify(const struct genl_family *family, struct sk_buff *skb,\n\t\t struct genl_info *info, u32 group, gfp_t flags)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct sock *sk = net->genl_sock;\n\tint report = 0;\n\n\tif (info->nlhdr)\n\t\treport = nlmsg_report(info->nlhdr);\n\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn;\n\tgroup = family->mcgrp_offset + group;\n\tnlmsg_notify(sk, skb, info->snd_portid, group, report, flags);\n}\nEXPORT_SYMBOL(genl_notify);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * NETLINK      Generic Netlink Family\n *\n * \t\tAuthors:\tJamal Hadi Salim\n * \t\t\t\tThomas Graf <tgraf@suug.ch>\n *\t\t\t\tJohannes Berg <johannes@sipsolutions.net>\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/mutex.h>\n#include <linux/bitmap.h>\n#include <linux/rwsem.h>\n#include <linux/idr.h>\n#include <net/sock.h>\n#include <net/genetlink.h>\n\nstatic DEFINE_MUTEX(genl_mutex); /* serialization of message processing */\nstatic DECLARE_RWSEM(cb_lock);\n\natomic_t genl_sk_destructing_cnt = ATOMIC_INIT(0);\nDECLARE_WAIT_QUEUE_HEAD(genl_sk_destructing_waitq);\n\nvoid genl_lock(void)\n{\n\tmutex_lock(&genl_mutex);\n}\nEXPORT_SYMBOL(genl_lock);\n\nvoid genl_unlock(void)\n{\n\tmutex_unlock(&genl_mutex);\n}\nEXPORT_SYMBOL(genl_unlock);\n\n#ifdef CONFIG_LOCKDEP\nbool lockdep_genl_is_held(void)\n{\n\treturn lockdep_is_held(&genl_mutex);\n}\nEXPORT_SYMBOL(lockdep_genl_is_held);\n#endif\n\nstatic void genl_lock_all(void)\n{\n\tdown_write(&cb_lock);\n\tgenl_lock();\n}\n\nstatic void genl_unlock_all(void)\n{\n\tgenl_unlock();\n\tup_write(&cb_lock);\n}\n\nstatic DEFINE_IDR(genl_fam_idr);\n\n/*\n * Bitmap of multicast groups that are currently in use.\n *\n * To avoid an allocation at boot of just one unsigned long,\n * declare it global instead.\n * Bit 0 is marked as already used since group 0 is invalid.\n * Bit 1 is marked as already used since the drop-monitor code\n * abuses the API and thinks it can statically use group 1.\n * That group will typically conflict with other groups that\n * any proper users use.\n * Bit 16 is marked as used since it's used for generic netlink\n * and the code no longer marks pre-reserved IDs as used.\n * Bit 17 is marked as already used since the VFS quota code\n * also abused this API and relied on family == group ID, we\n * cater to that by giving it a static family and group ID.\n * Bit 18 is marked as already used since the PMCRAID driver\n * did the same thing as the VFS quota code (maybe copied?)\n */\nstatic unsigned long mc_group_start = 0x3 | BIT(GENL_ID_CTRL) |\n\t\t\t\t      BIT(GENL_ID_VFS_DQUOT) |\n\t\t\t\t      BIT(GENL_ID_PMCRAID);\nstatic unsigned long *mc_groups = &mc_group_start;\nstatic unsigned long mc_groups_longs = 1;\n\nstatic int genl_ctrl_event(int event, const struct genl_family *family,\n\t\t\t   const struct genl_multicast_group *grp,\n\t\t\t   int grp_id);\n\nstatic const struct genl_family *genl_family_find_byid(unsigned int id)\n{\n\treturn idr_find(&genl_fam_idr, id);\n}\n\nstatic const struct genl_family *genl_family_find_byname(char *name)\n{\n\tconst struct genl_family *family;\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, family, id)\n\t\tif (strcmp(family->name, name) == 0)\n\t\t\treturn family;\n\n\treturn NULL;\n}\n\nstatic const struct genl_ops *genl_get_cmd(u8 cmd,\n\t\t\t\t\t   const struct genl_family *family)\n{\n\tint i;\n\n\tfor (i = 0; i < family->n_ops; i++)\n\t\tif (family->ops[i].cmd == cmd)\n\t\t\treturn &family->ops[i];\n\n\treturn NULL;\n}\n\nstatic int genl_allocate_reserve_groups(int n_groups, int *first_id)\n{\n\tunsigned long *new_groups;\n\tint start = 0;\n\tint i;\n\tint id;\n\tbool fits;\n\n\tdo {\n\t\tif (start == 0)\n\t\t\tid = find_first_zero_bit(mc_groups,\n\t\t\t\t\t\t mc_groups_longs *\n\t\t\t\t\t\t BITS_PER_LONG);\n\t\telse\n\t\t\tid = find_next_zero_bit(mc_groups,\n\t\t\t\t\t\tmc_groups_longs * BITS_PER_LONG,\n\t\t\t\t\t\tstart);\n\n\t\tfits = true;\n\t\tfor (i = id;\n\t\t     i < min_t(int, id + n_groups,\n\t\t\t       mc_groups_longs * BITS_PER_LONG);\n\t\t     i++) {\n\t\t\tif (test_bit(i, mc_groups)) {\n\t\t\t\tstart = i;\n\t\t\t\tfits = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (id + n_groups > mc_groups_longs * BITS_PER_LONG) {\n\t\t\tunsigned long new_longs = mc_groups_longs +\n\t\t\t\t\t\t  BITS_TO_LONGS(n_groups);\n\t\t\tsize_t nlen = new_longs * sizeof(unsigned long);\n\n\t\t\tif (mc_groups == &mc_group_start) {\n\t\t\t\tnew_groups = kzalloc(nlen, GFP_KERNEL);\n\t\t\t\tif (!new_groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmc_groups = new_groups;\n\t\t\t\t*mc_groups = mc_group_start;\n\t\t\t} else {\n\t\t\t\tnew_groups = krealloc(mc_groups, nlen,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\t\tif (!new_groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tmc_groups = new_groups;\n\t\t\t\tfor (i = 0; i < BITS_TO_LONGS(n_groups); i++)\n\t\t\t\t\tmc_groups[mc_groups_longs + i] = 0;\n\t\t\t}\n\t\t\tmc_groups_longs = new_longs;\n\t\t}\n\t} while (!fits);\n\n\tfor (i = id; i < id + n_groups; i++)\n\t\tset_bit(i, mc_groups);\n\t*first_id = id;\n\treturn 0;\n}\n\nstatic struct genl_family genl_ctrl;\n\nstatic int genl_validate_assign_mc_groups(struct genl_family *family)\n{\n\tint first_id;\n\tint n_groups = family->n_mcgrps;\n\tint err = 0, i;\n\tbool groups_allocated = false;\n\n\tif (!n_groups)\n\t\treturn 0;\n\n\tfor (i = 0; i < n_groups; i++) {\n\t\tconst struct genl_multicast_group *grp = &family->mcgrps[i];\n\n\t\tif (WARN_ON(grp->name[0] == '\\0'))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(memchr(grp->name, '\\0', GENL_NAMSIZ) == NULL))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* special-case our own group and hacks */\n\tif (family == &genl_ctrl) {\n\t\tfirst_id = GENL_ID_CTRL;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (strcmp(family->name, \"NET_DM\") == 0) {\n\t\tfirst_id = 1;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (family->id == GENL_ID_VFS_DQUOT) {\n\t\tfirst_id = GENL_ID_VFS_DQUOT;\n\t\tBUG_ON(n_groups != 1);\n\t} else if (family->id == GENL_ID_PMCRAID) {\n\t\tfirst_id = GENL_ID_PMCRAID;\n\t\tBUG_ON(n_groups != 1);\n\t} else {\n\t\tgroups_allocated = true;\n\t\terr = genl_allocate_reserve_groups(n_groups, &first_id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfamily->mcgrp_offset = first_id;\n\n\t/* if still initializing, can't and don't need to to realloc bitmaps */\n\tif (!init_net.genl_sock)\n\t\treturn 0;\n\n\tif (family->netnsok) {\n\t\tstruct net *net;\n\n\t\tnetlink_table_grab();\n\t\trcu_read_lock();\n\t\tfor_each_net_rcu(net) {\n\t\t\terr = __netlink_change_ngroups(net->genl_sock,\n\t\t\t\t\tmc_groups_longs * BITS_PER_LONG);\n\t\t\tif (err) {\n\t\t\t\t/*\n\t\t\t\t * No need to roll back, can only fail if\n\t\t\t\t * memory allocation fails and then the\n\t\t\t\t * number of _possible_ groups has been\n\t\t\t\t * increased on some sockets which is ok.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tnetlink_table_ungrab();\n\t} else {\n\t\terr = netlink_change_ngroups(init_net.genl_sock,\n\t\t\t\t\t     mc_groups_longs * BITS_PER_LONG);\n\t}\n\n\tif (groups_allocated && err) {\n\t\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\t\tclear_bit(family->mcgrp_offset + i, mc_groups);\n\t}\n\n\treturn err;\n}\n\nstatic void genl_unregister_mc_groups(const struct genl_family *family)\n{\n\tstruct net *net;\n\tint i;\n\n\tnetlink_table_grab();\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\t\t__netlink_clear_multicast_users(\n\t\t\t\tnet->genl_sock, family->mcgrp_offset + i);\n\t}\n\trcu_read_unlock();\n\tnetlink_table_ungrab();\n\n\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\tint grp_id = family->mcgrp_offset + i;\n\n\t\tif (grp_id != 1)\n\t\t\tclear_bit(grp_id, mc_groups);\n\t\tgenl_ctrl_event(CTRL_CMD_DELMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], grp_id);\n\t}\n}\n\nstatic int genl_validate_ops(const struct genl_family *family)\n{\n\tconst struct genl_ops *ops = family->ops;\n\tunsigned int n_ops = family->n_ops;\n\tint i, j;\n\n\tif (WARN_ON(n_ops && !ops))\n\t\treturn -EINVAL;\n\n\tif (!n_ops)\n\t\treturn 0;\n\n\tfor (i = 0; i < n_ops; i++) {\n\t\tif (ops[i].dumpit == NULL && ops[i].doit == NULL)\n\t\t\treturn -EINVAL;\n\t\tfor (j = i + 1; j < n_ops; j++)\n\t\t\tif (ops[i].cmd == ops[j].cmd)\n\t\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * genl_register_family - register a generic netlink family\n * @family: generic netlink family\n *\n * Registers the specified family after validating it first. Only one\n * family may be registered with the same family name or identifier.\n *\n * The family's ops, multicast groups and module pointer must already\n * be assigned.\n *\n * Return 0 on success or a negative error code.\n */\nint genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\n\tgenl_lock_all();\n\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\n\t/*\n\t * Sadly, a few cases need to be special-cased\n\t * due to them having previously abused the API\n\t * and having used their family ID also as their\n\t * multicast group ID, so we use reserved IDs\n\t * for both to be sure we can do that mapping.\n\t */\n\tif (family == &genl_ctrl) {\n\t\t/* and this needs to be special for initial family lookups */\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_free;\n\t}\n\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\n\tgenl_unlock_all();\n\n\t/* send all events */\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\n\treturn 0;\n\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\nerrout_free:\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}\nEXPORT_SYMBOL(genl_register_family);\n\n/**\n * genl_unregister_family - unregister generic netlink family\n * @family: generic netlink family\n *\n * Unregisters the specified family.\n *\n * Returns 0 on success or a negative error code.\n */\nint genl_unregister_family(const struct genl_family *family)\n{\n\tgenl_lock_all();\n\n\tif (!genl_family_find_byid(family->id)) {\n\t\tgenl_unlock_all();\n\t\treturn -ENOENT;\n\t}\n\n\tgenl_unregister_mc_groups(family);\n\n\tidr_remove(&genl_fam_idr, family->id);\n\n\tup_write(&cb_lock);\n\twait_event(genl_sk_destructing_waitq,\n\t\t   atomic_read(&genl_sk_destructing_cnt) == 0);\n\tgenl_unlock();\n\n\tkfree(family->attrbuf);\n\n\tgenl_ctrl_event(CTRL_CMD_DELFAMILY, family, NULL, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genl_unregister_family);\n\n/**\n * genlmsg_put - Add generic netlink header to netlink message\n * @skb: socket buffer holding the message\n * @portid: netlink portid the message is addressed to\n * @seq: sequence number (usually the one of the sender)\n * @family: generic netlink family\n * @flags: netlink message flags\n * @cmd: generic netlink command\n *\n * Returns pointer to user specific header\n */\nvoid *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t  const struct genl_family *family, int flags, u8 cmd)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct genlmsghdr *hdr;\n\n\tnlh = nlmsg_put(skb, portid, seq, family->id, GENL_HDRLEN +\n\t\t\tfamily->hdrsize, flags);\n\tif (nlh == NULL)\n\t\treturn NULL;\n\n\thdr = nlmsg_data(nlh);\n\thdr->cmd = cmd;\n\thdr->version = family->version;\n\thdr->reserved = 0;\n\n\treturn (char *) hdr + GENL_HDRLEN;\n}\nEXPORT_SYMBOL(genlmsg_put);\n\nstatic int genl_lock_start(struct netlink_callback *cb)\n{\n\t/* our ops are always const - netlink API doesn't propagate that */\n\tconst struct genl_ops *ops = cb->data;\n\tint rc = 0;\n\n\tif (ops->start) {\n\t\tgenl_lock();\n\t\trc = ops->start(cb);\n\t\tgenl_unlock();\n\t}\n\treturn rc;\n}\n\nstatic int genl_lock_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\t/* our ops are always const - netlink API doesn't propagate that */\n\tconst struct genl_ops *ops = cb->data;\n\tint rc;\n\n\tgenl_lock();\n\trc = ops->dumpit(skb, cb);\n\tgenl_unlock();\n\treturn rc;\n}\n\nstatic int genl_lock_done(struct netlink_callback *cb)\n{\n\t/* our ops are always const - netlink API doesn't propagate that */\n\tconst struct genl_ops *ops = cb->data;\n\tint rc = 0;\n\n\tif (ops->done) {\n\t\tgenl_lock();\n\t\trc = ops->done(cb);\n\t\tgenl_unlock();\n\t}\n\treturn rc;\n}\n\nstatic int genl_family_rcv_msg(const struct genl_family *family,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tconst struct genl_ops *ops;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct genl_info info;\n\tstruct genlmsghdr *hdr = nlmsg_data(nlh);\n\tstruct nlattr **attrbuf;\n\tint hdrlen, err;\n\n\t/* this family doesn't exist in this netns */\n\tif (!family->netnsok && !net_eq(net, &init_net))\n\t\treturn -ENOENT;\n\n\thdrlen = GENL_HDRLEN + family->hdrsize;\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\tops = genl_get_cmd(hdr->cmd, family);\n\tif (ops == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ops->flags & GENL_ADMIN_PERM) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((ops->flags & GENL_UNS_ADMIN_PERM) &&\n\t    !netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {\n\t\tint rc;\n\n\t\tif (ops->dumpit == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (!family->parallel_ops) {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t/* we have const, but the netlink API doesn't */\n\t\t\t\t.data = (void *)ops,\n\t\t\t\t.start = genl_lock_start,\n\t\t\t\t.dump = genl_lock_dumpit,\n\t\t\t\t.done = genl_lock_done,\n\t\t\t};\n\n\t\t\tgenl_unlock();\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t\tgenl_lock();\n\n\t\t} else {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.module = family->module,\n\t\t\t\t.start = ops->start,\n\t\t\t\t.dump = ops->dumpit,\n\t\t\t\t.done = ops->done,\n\t\t\t};\n\n\t\t\trc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tif (ops->doit == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (family->maxattr && family->parallel_ops) {\n\t\tattrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (attrbuf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tattrbuf = family->attrbuf;\n\n\tif (attrbuf) {\n\t\terr = nlmsg_parse(nlh, hdrlen, attrbuf, family->maxattr,\n\t\t\t\t  ops->policy, extack);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tinfo.snd_seq = nlh->nlmsg_seq;\n\tinfo.snd_portid = NETLINK_CB(skb).portid;\n\tinfo.nlhdr = nlh;\n\tinfo.genlhdr = nlmsg_data(nlh);\n\tinfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;\n\tinfo.attrs = attrbuf;\n\tinfo.extack = extack;\n\tgenl_info_net_set(&info, net);\n\tmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\n\n\tif (family->pre_doit) {\n\t\terr = family->pre_doit(ops, skb, &info);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ops->doit(skb, &info);\n\n\tif (family->post_doit)\n\t\tfamily->post_doit(ops, skb, &info);\n\nout:\n\tif (family->parallel_ops)\n\t\tkfree(attrbuf);\n\n\treturn err;\n}\n\nstatic int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct genl_family *family;\n\tint err;\n\n\tfamily = genl_family_find_byid(nlh->nlmsg_type);\n\tif (family == NULL)\n\t\treturn -ENOENT;\n\n\tif (!family->parallel_ops)\n\t\tgenl_lock();\n\n\terr = genl_family_rcv_msg(family, skb, nlh, extack);\n\n\tif (!family->parallel_ops)\n\t\tgenl_unlock();\n\n\treturn err;\n}\n\nstatic void genl_rcv(struct sk_buff *skb)\n{\n\tdown_read(&cb_lock);\n\tnetlink_rcv_skb(skb, &genl_rcv_msg);\n\tup_read(&cb_lock);\n}\n\n/**************************************************************************\n * Controller\n **************************************************************************/\n\nstatic struct genl_family genl_ctrl;\n\nstatic int ctrl_fill_info(const struct genl_family *family, u32 portid, u32 seq,\n\t\t\t  u32 flags, struct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id) ||\n\t    nla_put_u32(skb, CTRL_ATTR_VERSION, family->version) ||\n\t    nla_put_u32(skb, CTRL_ATTR_HDRSIZE, family->hdrsize) ||\n\t    nla_put_u32(skb, CTRL_ATTR_MAXATTR, family->maxattr))\n\t\tgoto nla_put_failure;\n\n\tif (family->n_ops) {\n\t\tstruct nlattr *nla_ops;\n\t\tint i;\n\n\t\tnla_ops = nla_nest_start(skb, CTRL_ATTR_OPS);\n\t\tif (nla_ops == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_ops; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_ops *ops = &family->ops[i];\n\t\t\tu32 op_flags = ops->flags;\n\n\t\t\tif (ops->dumpit)\n\t\t\t\top_flags |= GENL_CMD_CAP_DUMP;\n\t\t\tif (ops->doit)\n\t\t\t\top_flags |= GENL_CMD_CAP_DO;\n\t\t\tif (ops->policy)\n\t\t\t\top_flags |= GENL_CMD_CAP_HASPOL;\n\n\t\t\tnest = nla_nest_start(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_OP_ID, ops->cmd) ||\n\t\t\t    nla_put_u32(skb, CTRL_ATTR_OP_FLAGS, op_flags))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\n\t\tnla_nest_end(skb, nla_ops);\n\t}\n\n\tif (family->n_mcgrps) {\n\t\tstruct nlattr *nla_grps;\n\t\tint i;\n\n\t\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\t\tif (nla_grps == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_multicast_group *grp;\n\n\t\t\tgrp = &family->mcgrps[i];\n\n\t\t\tnest = nla_nest_start(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID,\n\t\t\t\t\tfamily->mcgrp_offset + i) ||\n\t\t\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t\t\t   grp->name))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t\tnla_nest_end(skb, nla_grps);\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ctrl_fill_mcgrp_info(const struct genl_family *family,\n\t\t\t\tconst struct genl_multicast_group *grp,\n\t\t\t\tint grp_id, u32 portid, u32 seq, u32 flags,\n\t\t\t\tstruct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nla_grps;\n\tstruct nlattr *nest;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id))\n\t\tgoto nla_put_failure;\n\n\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\tif (nla_grps == NULL)\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, 1);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID, grp_id) ||\n\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t   grp->name))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\tnla_nest_end(skb, nla_grps);\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint n = 0;\n\tstruct genl_family *rt;\n\tstruct net *net = sock_net(skb->sk);\n\tint fams_to_skip = cb->args[0];\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, rt, id) {\n\t\tif (!rt->netnsok && !net_eq(net, &init_net))\n\t\t\tcontinue;\n\n\t\tif (n++ < fams_to_skip)\n\t\t\tcontinue;\n\n\t\tif (ctrl_fill_info(rt, NETLINK_CB(cb->skb).portid,\n\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t   skb, CTRL_CMD_NEWFAMILY) < 0) {\n\t\t\tn--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[0] = n;\n\treturn skb->len;\n}\n\nstatic struct sk_buff *ctrl_build_family_msg(const struct genl_family *family,\n\t\t\t\t\t     u32 portid, int seq, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\terr = ctrl_fill_info(family, portid, seq, 0, skb, cmd);\n\tif (err < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nctrl_build_mcgrp_msg(const struct genl_family *family,\n\t\t     const struct genl_multicast_group *grp,\n\t\t     int grp_id, u32 portid, int seq, u8 cmd)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\terr = ctrl_fill_mcgrp_info(family, grp, grp_id, portid,\n\t\t\t\t   seq, 0, skb, cmd);\n\tif (err < 0) {\n\t\tnlmsg_free(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic const struct nla_policy ctrl_policy[CTRL_ATTR_MAX+1] = {\n\t[CTRL_ATTR_FAMILY_ID]\t= { .type = NLA_U16 },\n\t[CTRL_ATTR_FAMILY_NAME]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t    .len = GENL_NAMSIZ - 1 },\n};\n\nstatic int ctrl_getfamily(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tconst struct genl_family *res = NULL;\n\tint err = -EINVAL;\n\n\tif (info->attrs[CTRL_ATTR_FAMILY_ID]) {\n\t\tu16 id = nla_get_u16(info->attrs[CTRL_ATTR_FAMILY_ID]);\n\t\tres = genl_family_find_byid(id);\n\t\terr = -ENOENT;\n\t}\n\n\tif (info->attrs[CTRL_ATTR_FAMILY_NAME]) {\n\t\tchar *name;\n\n\t\tname = nla_data(info->attrs[CTRL_ATTR_FAMILY_NAME]);\n\t\tres = genl_family_find_byname(name);\n#ifdef CONFIG_MODULES\n\t\tif (res == NULL) {\n\t\t\tgenl_unlock();\n\t\t\tup_read(&cb_lock);\n\t\t\trequest_module(\"net-pf-%d-proto-%d-family-%s\",\n\t\t\t\t       PF_NETLINK, NETLINK_GENERIC, name);\n\t\t\tdown_read(&cb_lock);\n\t\t\tgenl_lock();\n\t\t\tres = genl_family_find_byname(name);\n\t\t}\n#endif\n\t\terr = -ENOENT;\n\t}\n\n\tif (res == NULL)\n\t\treturn err;\n\n\tif (!res->netnsok && !net_eq(genl_info_net(info), &init_net)) {\n\t\t/* family doesn't exist here */\n\t\treturn -ENOENT;\n\t}\n\n\tmsg = ctrl_build_family_msg(res, info->snd_portid, info->snd_seq,\n\t\t\t\t    CTRL_CMD_NEWFAMILY);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int genl_ctrl_event(int event, const struct genl_family *family,\n\t\t\t   const struct genl_multicast_group *grp,\n\t\t\t   int grp_id)\n{\n\tstruct sk_buff *msg;\n\n\t/* genl is still initialising */\n\tif (!init_net.genl_sock)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase CTRL_CMD_NEWFAMILY:\n\tcase CTRL_CMD_DELFAMILY:\n\t\tWARN_ON(grp);\n\t\tmsg = ctrl_build_family_msg(family, 0, 0, event);\n\t\tbreak;\n\tcase CTRL_CMD_NEWMCAST_GRP:\n\tcase CTRL_CMD_DELMCAST_GRP:\n\t\tBUG_ON(!grp);\n\t\tmsg = ctrl_build_mcgrp_msg(family, grp, grp_id, 0, 0, event);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tif (!family->netnsok) {\n\t\tgenlmsg_multicast_netns(&genl_ctrl, &init_net, msg, 0,\n\t\t\t\t\t0, GFP_KERNEL);\n\t} else {\n\t\trcu_read_lock();\n\t\tgenlmsg_multicast_allns(&genl_ctrl, msg, 0,\n\t\t\t\t\t0, GFP_ATOMIC);\n\t\trcu_read_unlock();\n\t}\n\n\treturn 0;\n}\n\nstatic const struct genl_ops genl_ctrl_ops[] = {\n\t{\n\t\t.cmd\t\t= CTRL_CMD_GETFAMILY,\n\t\t.doit\t\t= ctrl_getfamily,\n\t\t.dumpit\t\t= ctrl_dumpfamily,\n\t\t.policy\t\t= ctrl_policy,\n\t},\n};\n\nstatic const struct genl_multicast_group genl_ctrl_groups[] = {\n\t{ .name = \"notify\", },\n};\n\nstatic struct genl_family genl_ctrl __ro_after_init = {\n\t.module = THIS_MODULE,\n\t.ops = genl_ctrl_ops,\n\t.n_ops = ARRAY_SIZE(genl_ctrl_ops),\n\t.mcgrps = genl_ctrl_groups,\n\t.n_mcgrps = ARRAY_SIZE(genl_ctrl_groups),\n\t.id = GENL_ID_CTRL,\n\t.name = \"nlctrl\",\n\t.version = 0x2,\n\t.maxattr = CTRL_ATTR_MAX,\n\t.netnsok = true,\n};\n\nstatic int genl_bind(struct net *net, int group)\n{\n\tstruct genl_family *f;\n\tint err = -ENOENT;\n\tunsigned int id;\n\n\tdown_read(&cb_lock);\n\n\tidr_for_each_entry(&genl_fam_idr, f, id) {\n\t\tif (group >= f->mcgrp_offset &&\n\t\t    group < f->mcgrp_offset + f->n_mcgrps) {\n\t\t\tint fam_grp = group - f->mcgrp_offset;\n\n\t\t\tif (!f->netnsok && net != &init_net)\n\t\t\t\terr = -ENOENT;\n\t\t\telse if (f->mcast_bind)\n\t\t\t\terr = f->mcast_bind(net, fam_grp);\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cb_lock);\n\n\treturn err;\n}\n\nstatic void genl_unbind(struct net *net, int group)\n{\n\tstruct genl_family *f;\n\tunsigned int id;\n\n\tdown_read(&cb_lock);\n\n\tidr_for_each_entry(&genl_fam_idr, f, id) {\n\t\tif (group >= f->mcgrp_offset &&\n\t\t    group < f->mcgrp_offset + f->n_mcgrps) {\n\t\t\tint fam_grp = group - f->mcgrp_offset;\n\n\t\t\tif (f->mcast_unbind)\n\t\t\t\tf->mcast_unbind(net, fam_grp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cb_lock);\n}\n\nstatic int __net_init genl_pernet_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t\t= genl_rcv,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t\t.bind\t\t= genl_bind,\n\t\t.unbind\t\t= genl_unbind,\n\t};\n\n\t/* we'll bump the group number right afterwards */\n\tnet->genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &cfg);\n\n\tif (!net->genl_sock && net_eq(net, &init_net))\n\t\tpanic(\"GENL: Cannot initialize generic netlink\\n\");\n\n\tif (!net->genl_sock)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit genl_pernet_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->genl_sock);\n\tnet->genl_sock = NULL;\n}\n\nstatic struct pernet_operations genl_pernet_ops = {\n\t.init = genl_pernet_init,\n\t.exit = genl_pernet_exit,\n};\n\nstatic int __init genl_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&genl_ctrl);\n\tif (err < 0)\n\t\tgoto problem;\n\n\terr = register_pernet_subsys(&genl_pernet_ops);\n\tif (err)\n\t\tgoto problem;\n\n\treturn 0;\n\nproblem:\n\tpanic(\"GENL: Cannot register controller: %d\\n\", err);\n}\n\nsubsys_initcall(genl_init);\n\n/**\n * genl_family_attrbuf - return family's attrbuf\n * @family: the family\n *\n * Return the family's attrbuf, while validating that it's\n * actually valid to access it.\n *\n * You cannot use this function with a family that has parallel_ops\n * and you can only use it within (pre/post) doit/dumpit callbacks.\n */\nstruct nlattr **genl_family_attrbuf(const struct genl_family *family)\n{\n\tif (!WARN_ON(family->parallel_ops))\n\t\tlockdep_assert_held(&genl_mutex);\n\n\treturn family->attrbuf;\n}\nEXPORT_SYMBOL(genl_family_attrbuf);\n\nstatic int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,\n\t\t\t gfp_t flags)\n{\n\tstruct sk_buff *tmp;\n\tstruct net *net, *prev = NULL;\n\tbool delivered = false;\n\tint err;\n\n\tfor_each_net_rcu(net) {\n\t\tif (prev) {\n\t\t\ttmp = skb_clone(skb, flags);\n\t\t\tif (!tmp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = nlmsg_multicast(prev->genl_sock, tmp,\n\t\t\t\t\t      portid, group, flags);\n\t\t\tif (!err)\n\t\t\t\tdelivered = true;\n\t\t\telse if (err != -ESRCH)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tprev = net;\n\t}\n\n\terr = nlmsg_multicast(prev->genl_sock, skb, portid, group, flags);\n\tif (!err)\n\t\tdelivered = true;\n\telse if (err != -ESRCH)\n\t\treturn err;\n\treturn delivered ? 0 : -ESRCH;\n error:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nint genlmsg_multicast_allns(const struct genl_family *family,\n\t\t\t    struct sk_buff *skb, u32 portid,\n\t\t\t    unsigned int group, gfp_t flags)\n{\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn -EINVAL;\n\tgroup = family->mcgrp_offset + group;\n\treturn genlmsg_mcast(skb, portid, group, flags);\n}\nEXPORT_SYMBOL(genlmsg_multicast_allns);\n\nvoid genl_notify(const struct genl_family *family, struct sk_buff *skb,\n\t\t struct genl_info *info, u32 group, gfp_t flags)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct sock *sk = net->genl_sock;\n\tint report = 0;\n\n\tif (info->nlhdr)\n\t\treport = nlmsg_report(info->nlhdr);\n\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn;\n\tgroup = family->mcgrp_offset + group;\n\tnlmsg_notify(sk, skb, info->snd_portid, group, report, flags);\n}\nEXPORT_SYMBOL(genl_notify);\n"], "filenames": ["net/netlink/genetlink.c"], "buggy_code_start_loc": [369], "buggy_code_end_loc": [387], "fixing_code_start_loc": [369], "fixing_code_end_loc": [389], "type": "CWE-401", "message": "An issue was discovered in the Linux kernel before 5.0.6. There is a memory leak issue when idr_alloc() fails in genl_register_family() in net/netlink/genetlink.c.", "other": {"cve": {"id": "CVE-2019-15921", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-04T19:15:12.207", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0.6. There is a memory leak issue when idr_alloc() fails in genl_register_family() in net/netlink/genetlink.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.0.6. Se presenta un problema de p\u00e9rdida de memoria cuando la funci\u00f3n idr_alloc() presenta un fallo en la funci\u00f3n genl_register_family() en el archivo net/netlink/genetlink.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.6", "matchCriteriaId": "3A71E3E0-4ACA-4494-A4E5-3F3904F256A9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00064.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.6", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191004-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2"}}