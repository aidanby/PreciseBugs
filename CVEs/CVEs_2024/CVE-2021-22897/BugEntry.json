{"buggy_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2012 - 2016, Marc Hoersken, <info@marc-hoersken.de>\n * Copyright (C) 2012, Mark Salisbury, <mark.salisbury@hp.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all Schannel-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_SCHANNEL\n\n#define EXPOSE_SCHANNEL_INTERNAL_STRUCTS\n\n#ifndef USE_WINDOWS_SSPI\n#  error \"Can't compile SCHANNEL support without SSPI.\"\n#endif\n\n#include \"schannel.h\"\n#include \"vtls.h\"\n#include \"strcase.h\"\n#include \"sendf.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"strerror.h\"\n#include \"select.h\" /* for the socket readiness */\n#include \"inet_pton.h\" /* for IP addr SNI check */\n#include \"curl_multibyte.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n#include \"version_win32.h\"\n\n/* The last #include file should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* ALPN requires version 8.1 of the Windows SDK, which was\n   shipped with Visual Studio 2013, aka _MSC_VER 1800:\n\n   https://technet.microsoft.com/en-us/library/hh831771%28v=ws.11%29.aspx\n*/\n#if defined(_MSC_VER) && (_MSC_VER >= 1800) && !defined(_USING_V110_SDK71_)\n#  define HAS_ALPN 1\n#endif\n\n#ifndef UNISP_NAME_A\n#define UNISP_NAME_A \"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME_W\n#define UNISP_NAME_W L\"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME\n#ifdef UNICODE\n#define UNISP_NAME  UNISP_NAME_W\n#else\n#define UNISP_NAME  UNISP_NAME_A\n#endif\n#endif\n\n#if defined(CryptStringToBinary) && defined(CRYPT_STRING_HEX)\n#define HAS_CLIENT_CERT_PATH\n#endif\n\n#ifdef HAS_CLIENT_CERT_PATH\n#ifdef UNICODE\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_W\n#else\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_A\n#endif\n#endif\n\n#ifndef SP_PROT_SSL2_CLIENT\n#define SP_PROT_SSL2_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_SSL3_CLIENT\n#define SP_PROT_SSL3_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_TLS1_CLIENT\n#define SP_PROT_TLS1_CLIENT             0x00000080\n#endif\n\n#ifndef SP_PROT_TLS1_0_CLIENT\n#define SP_PROT_TLS1_0_CLIENT           SP_PROT_TLS1_CLIENT\n#endif\n\n#ifndef SP_PROT_TLS1_1_CLIENT\n#define SP_PROT_TLS1_1_CLIENT           0x00000200\n#endif\n\n#ifndef SP_PROT_TLS1_2_CLIENT\n#define SP_PROT_TLS1_2_CLIENT           0x00000800\n#endif\n\n#ifndef SCH_USE_STRONG_CRYPTO\n#define SCH_USE_STRONG_CRYPTO           0x00400000\n#endif\n\n#ifndef SECBUFFER_ALERT\n#define SECBUFFER_ALERT                 17\n#endif\n\n/* Both schannel buffer sizes must be > 0 */\n#define CURL_SCHANNEL_BUFFER_INIT_SIZE   4096\n#define CURL_SCHANNEL_BUFFER_FREE_SIZE   1024\n\n#define CERT_THUMBPRINT_STR_LEN 40\n#define CERT_THUMBPRINT_DATA_LEN 20\n\n/* Uncomment to force verbose output\n * #define infof(x, y, ...) printf(y, __VA_ARGS__)\n * #define failf(x, y, ...) printf(y, __VA_ARGS__)\n */\n\n#ifndef CALG_SHA_256\n#  define CALG_SHA_256 0x0000800c\n#endif\n\n#define BACKEND connssl->backend\n\nstatic Curl_recv schannel_recv;\nstatic Curl_send schannel_send;\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey);\n\nstatic void InitSecBuffer(SecBuffer *buffer, unsigned long BufType,\n                          void *BufDataPtr, unsigned long BufByteSize)\n{\n  buffer->cbBuffer = BufByteSize;\n  buffer->BufferType = BufType;\n  buffer->pvBuffer = BufDataPtr;\n}\n\nstatic void InitSecBufferDesc(SecBufferDesc *desc, SecBuffer *BufArr,\n                              unsigned long NumArrElem)\n{\n  desc->ulVersion = SECBUFFER_VERSION;\n  desc->pBuffers = BufArr;\n  desc->cBuffers = NumArrElem;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(SCHANNEL_CRED *schannel_cred, struct Curl_easy *data,\n                        struct connectdata *conn)\n{\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long i = ssl_version;\n\n  switch(ssl_version_max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    break;\n  }\n  for(; i <= (ssl_version_max >> 16); ++i) {\n    switch(i) {\n    case CURL_SSLVERSION_TLSv1_0:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_0_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_1:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_1_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_2:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_2_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_3:\n      failf(data, \"schannel: TLS 1.3 is not yet supported\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  return CURLE_OK;\n}\n\n/*longest is 26, buffer is slightly bigger*/\n#define LONGEST_ALG_ID 32\n#define CIPHEROPTION(X)                         \\\n  if(strcmp(#X, tmp) == 0)                      \\\n    return X\n\nstatic int\nget_alg_id_by_name(char *name)\n{\n  char tmp[LONGEST_ALG_ID] = { 0 };\n  char *nameEnd = strchr(name, ':');\n  size_t n = nameEnd ? min((size_t)(nameEnd - name), LONGEST_ALG_ID - 1) : \\\n    min(strlen(name), LONGEST_ALG_ID - 1);\n  strncpy(tmp, name, n);\n  tmp[n] = 0;\n  CIPHEROPTION(CALG_MD2);\n  CIPHEROPTION(CALG_MD4);\n  CIPHEROPTION(CALG_MD5);\n  CIPHEROPTION(CALG_SHA);\n  CIPHEROPTION(CALG_SHA1);\n  CIPHEROPTION(CALG_MAC);\n  CIPHEROPTION(CALG_RSA_SIGN);\n  CIPHEROPTION(CALG_DSS_SIGN);\n/*ifdefs for the options that are defined conditionally in wincrypt.h*/\n#ifdef CALG_NO_SIGN\n  CIPHEROPTION(CALG_NO_SIGN);\n#endif\n  CIPHEROPTION(CALG_RSA_KEYX);\n  CIPHEROPTION(CALG_DES);\n#ifdef CALG_3DES_112\n  CIPHEROPTION(CALG_3DES_112);\n#endif\n  CIPHEROPTION(CALG_3DES);\n  CIPHEROPTION(CALG_DESX);\n  CIPHEROPTION(CALG_RC2);\n  CIPHEROPTION(CALG_RC4);\n  CIPHEROPTION(CALG_SEAL);\n#ifdef CALG_DH_SF\n  CIPHEROPTION(CALG_DH_SF);\n#endif\n  CIPHEROPTION(CALG_DH_EPHEM);\n#ifdef CALG_AGREEDKEY_ANY\n  CIPHEROPTION(CALG_AGREEDKEY_ANY);\n#endif\n#ifdef CALG_HUGHES_MD5\n  CIPHEROPTION(CALG_HUGHES_MD5);\n#endif\n  CIPHEROPTION(CALG_SKIPJACK);\n#ifdef CALG_TEK\n  CIPHEROPTION(CALG_TEK);\n#endif\n  CIPHEROPTION(CALG_CYLINK_MEK);\n  CIPHEROPTION(CALG_SSL3_SHAMD5);\n#ifdef CALG_SSL3_MASTER\n  CIPHEROPTION(CALG_SSL3_MASTER);\n#endif\n#ifdef CALG_SCHANNEL_MASTER_HASH\n  CIPHEROPTION(CALG_SCHANNEL_MASTER_HASH);\n#endif\n#ifdef CALG_SCHANNEL_MAC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_MAC_KEY);\n#endif\n#ifdef CALG_SCHANNEL_ENC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_ENC_KEY);\n#endif\n#ifdef CALG_PCT1_MASTER\n  CIPHEROPTION(CALG_PCT1_MASTER);\n#endif\n#ifdef CALG_SSL2_MASTER\n  CIPHEROPTION(CALG_SSL2_MASTER);\n#endif\n#ifdef CALG_TLS1_MASTER\n  CIPHEROPTION(CALG_TLS1_MASTER);\n#endif\n#ifdef CALG_RC5\n  CIPHEROPTION(CALG_RC5);\n#endif\n#ifdef CALG_HMAC\n  CIPHEROPTION(CALG_HMAC);\n#endif\n#if !defined(__W32API_MAJOR_VERSION) ||                                 \\\n  !defined(__W32API_MINOR_VERSION) ||                                   \\\n  defined(__MINGW64_VERSION_MAJOR) ||                                   \\\n  (__W32API_MAJOR_VERSION > 5)     ||                                   \\\n  ((__W32API_MAJOR_VERSION == 5) && (__W32API_MINOR_VERSION > 0))\n  /* CALG_TLS1PRF has a syntax error in MinGW's w32api up to version 5.0,\n     see https://osdn.net/projects/mingw/ticket/38391 */\n  CIPHEROPTION(CALG_TLS1PRF);\n#endif\n#ifdef CALG_HASH_REPLACE_OWF\n  CIPHEROPTION(CALG_HASH_REPLACE_OWF);\n#endif\n#ifdef CALG_AES_128\n  CIPHEROPTION(CALG_AES_128);\n#endif\n#ifdef CALG_AES_192\n  CIPHEROPTION(CALG_AES_192);\n#endif\n#ifdef CALG_AES_256\n  CIPHEROPTION(CALG_AES_256);\n#endif\n#ifdef CALG_AES\n  CIPHEROPTION(CALG_AES);\n#endif\n#ifdef CALG_SHA_256\n  CIPHEROPTION(CALG_SHA_256);\n#endif\n#ifdef CALG_SHA_384\n  CIPHEROPTION(CALG_SHA_384);\n#endif\n#ifdef CALG_SHA_512\n  CIPHEROPTION(CALG_SHA_512);\n#endif\n#ifdef CALG_ECDH\n  CIPHEROPTION(CALG_ECDH);\n#endif\n#ifdef CALG_ECMQV\n  CIPHEROPTION(CALG_ECMQV);\n#endif\n#ifdef CALG_ECDSA\n  CIPHEROPTION(CALG_ECDSA);\n#endif\n#ifdef CALG_ECDH_EPHEM\n  CIPHEROPTION(CALG_ECDH_EPHEM);\n#endif\n  return 0;\n}\n\nstatic CURLcode\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  static ALG_ID algIds[45]; /*There are 45 listed in the MS headers*/\n  while(startCur && (0 != *startCur) && (algCount < 45)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}\n\n#ifdef HAS_CLIENT_CERT_PATH\n\n/* Function allocates memory for store_path only if CURLE_OK is returned */\nstatic CURLcode\nget_cert_location(TCHAR *path, DWORD *store_name, TCHAR **store_path,\n                  TCHAR **thumbprint)\n{\n  TCHAR *sep;\n  TCHAR *store_path_start;\n  size_t store_name_len;\n\n  sep = _tcschr(path, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_name_len = sep - path;\n\n  if(_tcsnccmp(path, TEXT(\"CurrentUser\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachine\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE;\n  else if(_tcsnccmp(path, TEXT(\"CurrentService\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_SERVICE;\n  else if(_tcsnccmp(path, TEXT(\"Services\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_SERVICES;\n  else if(_tcsnccmp(path, TEXT(\"Users\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_USERS;\n  else if(_tcsnccmp(path, TEXT(\"CurrentUserGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineEnterprise\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE;\n  else\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_path_start = sep + 1;\n\n  sep = _tcschr(store_path_start, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *thumbprint = sep + 1;\n  if(_tcslen(*thumbprint) != CERT_THUMBPRINT_STR_LEN)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *sep = TEXT('\\0');\n  *store_path = _tcsdup(store_path_start);\n  *sep = TEXT('\\\\');\n  if(!*store_path)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}\n#endif\n\nstatic CURLcode\nschannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ssize_t written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf;\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf;\n  SecBufferDesc inbuf_desc;\n#ifdef HAS_ALPN\n  unsigned char alpn_buffer[128];\n#endif\n  SCHANNEL_CRED schannel_cred;\n  PCCERT_CONTEXT client_certs[1] = { NULL };\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  struct Curl_schannel_cred *old_cred = NULL;\n  struct in_addr addr;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  TCHAR *host_name;\n  CURLcode result;\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 1/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,\n                                  VERSION_LESS_THAN_EQUAL)) {\n    /* Schannel in Windows XP (OS version 5.1) uses legacy handshakes and\n       algorithms that may not be supported by all servers. */\n    infof(data, \"schannel: Windows version is old and may not be able to \"\n          \"connect to some servers due to lack of SNI, algorithms, etc.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.\n     Also it doesn't seem to be supported for Wine, see curl bug #983. */\n  BACKEND->use_alpn = conn->bits.tls_enable_alpn &&\n    !GetProcAddress(GetModuleHandle(TEXT(\"ntdll\")),\n                    \"wine_get_version\") &&\n    curlx_verify_windows_version(6, 3, PLATFORM_WINNT,\n                                 VERSION_GREATER_THAN_EQUAL);\n#else\n  BACKEND->use_alpn = false;\n#endif\n\n#ifdef _WIN32_WCE\n#ifdef HAS_MANUAL_VERIFY_API\n  /* certificate validation on CE doesn't seem to work right; we'll\n   * do it following a more manual process. */\n  BACKEND->use_manual_cred_validation = true;\n#else\n#error \"compiler too old to support requisite manual cert verify for Win CE\"\n#endif\n#else\n#ifdef HAS_MANUAL_VERIFY_API\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    if(curlx_verify_windows_version(6, 1, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL)) {\n      BACKEND->use_manual_cred_validation = true;\n    }\n    else {\n      failf(data, \"schannel: this version of Windows is too old to support \"\n            \"certificate verification via CA bundle file.\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    BACKEND->use_manual_cred_validation = false;\n#else\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    failf(data, \"schannel: CA cert support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n#endif\n\n  BACKEND->cred = NULL;\n\n  /* check for an existing re-usable credential handle */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              (void **)&old_cred, NULL, sockindex)) {\n      BACKEND->cred = old_cred;\n      DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));\n\n      /* increment the reference counter of the credential/session handle */\n      BACKEND->cred->refcount++;\n      DEBUGF(infof(data,\n                   \"schannel: incremented credential handle refcount = %d\\n\",\n                   BACKEND->cred->refcount));\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(!BACKEND->cred) {\n    /* setup Schannel API options */\n    memset(&schannel_cred, 0, sizeof(schannel_cred));\n    schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;\n\n    if(conn->ssl_config.verifypeer) {\n#ifdef HAS_MANUAL_VERIFY_API\n      if(BACKEND->use_manual_cred_validation)\n        schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;\n      else\n#endif\n        schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;\n\n      if(SSL_SET_OPTION(no_revoke)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n\n        DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"\n                     \"checks\\n\"));\n      }\n      else if(SSL_SET_OPTION(revoke_best_effort)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));\n      }\n      else {\n        schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data,\n                     \"schannel: checking server certificate revocation\\n\"));\n      }\n    }\n    else {\n      schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |\n        SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n        SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n      DEBUGF(infof(data,\n                   \"schannel: disabled server cert revocation checks\\n\"));\n    }\n\n    if(!conn->ssl_config.verifyhost) {\n      schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;\n      DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"\n                   \"comparing the supplied target name with the subject \"\n                   \"names in server certificates.\\n\"));\n    }\n\n    if(!SSL_SET_OPTION(auto_client_cert)) {\n      schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;\n      schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;\n      infof(data, \"schannel: disabled automatic use of client certificate\\n\");\n    }\n    else\n      infof(data, \"schannel: enabled automatic use of client certificate\\n\");\n\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n    {\n      result = set_ssl_version_min_max(&schannel_cred, data, conn);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      DWORD cert_store_name = 0;\n      TCHAR *cert_store_path = NULL;\n      TCHAR *cert_thumbprint_str = NULL;\n      CRYPT_HASH_BLOB cert_thumbprint;\n      BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];\n      HCERTSTORE cert_store = NULL;\n      FILE *fInCert = NULL;\n      void *certdata = NULL;\n      size_t certsize = 0;\n      bool blob = data->set.ssl.primary.cert_blob != NULL;\n      TCHAR *cert_path = NULL;\n      if(blob) {\n        certdata = data->set.ssl.primary.cert_blob->data;\n        certsize = data->set.ssl.primary.cert_blob->len;\n      }\n      else {\n        cert_path = curlx_convert_UTF8_to_tchar(\n          data->set.ssl.primary.clientcert);\n        if(!cert_path)\n          return CURLE_OUT_OF_MEMORY;\n\n        result = get_cert_location(cert_path, &cert_store_name,\n          &cert_store_path, &cert_thumbprint_str);\n\n        if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))\n          fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");\n\n        if(result && !fInCert) {\n          failf(data, \"schannel: Failed to get certificate location\"\n                \" or file for %s\",\n                data->set.ssl.primary.clientcert);\n          curlx_unicodefree(cert_path);\n          return result;\n        }\n      }\n\n      if((fInCert || blob) && (data->set.ssl.cert_type) &&\n          (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {\n        failf(data, \"schannel: certificate format compatibility error \"\n                \" for %s\",\n                blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);\n        curlx_unicodefree(cert_path);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n\n      if(fInCert || blob) {\n        /* Reading a .P12 or .pfx file, like the example at bottom of\n             https://social.msdn.microsoft.com/Forums/windowsdesktop/\n                            en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5\n        */\n        CRYPT_DATA_BLOB datablob;\n        WCHAR* pszPassword;\n        size_t pwd_len = 0;\n        int str_w_len = 0;\n        const char *cert_showfilename_error = blob ?\n          \"(memory blob)\" : data->set.ssl.primary.clientcert;\n        curlx_unicodefree(cert_path);\n        if(fInCert) {\n          long cert_tell = 0;\n          bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n          if(continue_reading)\n            cert_tell = ftell(fInCert);\n          if(cert_tell < 0)\n            continue_reading = FALSE;\n          else\n            certsize = (size_t)cert_tell;\n          if(continue_reading)\n            continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n          if(continue_reading)\n            certdata = malloc(certsize + 1);\n          if((!certdata) ||\n             ((int) fread(certdata, certsize, 1, fInCert) != 1))\n            continue_reading = FALSE;\n          fclose(fInCert);\n          if(!continue_reading) {\n            failf(data, \"schannel: Failed to read cert file %s\",\n                data->set.ssl.primary.clientcert);\n            free(certdata);\n            return CURLE_SSL_CERTPROBLEM;\n          }\n        }\n\n        /* Convert key-pair data to the in-memory certificate store */\n        datablob.pbData = (BYTE*)certdata;\n        datablob.cbData = (DWORD)certsize;\n\n        if(data->set.ssl.key_passwd != NULL)\n          pwd_len = strlen(data->set.ssl.key_passwd);\n        pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));\n        if(pszPassword) {\n          if(pwd_len > 0)\n            str_w_len = MultiByteToWideChar(CP_UTF8,\n               MB_ERR_INVALID_CHARS,\n               data->set.ssl.key_passwd, (int)pwd_len,\n               pszPassword, (int)(pwd_len + 1));\n\n          if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))\n            pszPassword[str_w_len] = 0;\n          else\n            pszPassword[0] = 0;\n\n          cert_store = PFXImportCertStore(&datablob, pszPassword, 0);\n          free(pszPassword);\n        }\n        if(!blob)\n          free(certdata);\n        if(!cert_store) {\n          DWORD errorcode = GetLastError();\n          if(errorcode == ERROR_INVALID_PASSWORD)\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"password is bad\",\n                  cert_showfilename_error);\n          else\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"last error is 0x%x\",\n                  cert_showfilename_error, errorcode);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_ANY, NULL, NULL);\n\n        if(!client_certs[0]) {\n          failf(data, \"schannel: Failed to get certificate from file %s\"\n                \", last error is 0x%x\",\n                cert_showfilename_error, GetLastError());\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        schannel_cred.cCreds = 1;\n        schannel_cred.paCred = client_certs;\n      }\n      else {\n        cert_store =\n          CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,\n                        (HCRYPTPROV)NULL,\n                        CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,\n                        cert_store_path);\n        if(!cert_store) {\n          failf(data, \"schannel: Failed to open cert store %x %s, \"\n                \"last error is 0x%x\",\n                cert_store_name, cert_store_path, GetLastError());\n          free(cert_store_path);\n          curlx_unicodefree(cert_path);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n        free(cert_store_path);\n\n        cert_thumbprint.pbData = cert_thumbprint_data;\n        cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;\n\n        if(!CryptStringToBinary(cert_thumbprint_str,\n                                CERT_THUMBPRINT_STR_LEN,\n                                CRYPT_STRING_HEX,\n                                cert_thumbprint_data,\n                                &cert_thumbprint.cbData,\n                                NULL, NULL)) {\n          curlx_unicodefree(cert_path);\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_HASH, &cert_thumbprint, NULL);\n\n        curlx_unicodefree(cert_path);\n\n        if(client_certs[0]) {\n          schannel_cred.cCreds = 1;\n          schannel_cred.paCred = client_certs;\n        }\n        else {\n          /* CRYPT_E_NOT_FOUND / E_INVALIDARG */\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n      }\n      CertCloseStore(cert_store, 0);\n    }\n#else\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      failf(data, \"schannel: client cert support not built in\");\n      return CURLE_NOT_BUILT_IN;\n    }\n#endif\n\n    /* allocate memory for the re-usable credential handle */\n    BACKEND->cred = (struct Curl_schannel_cred *)\n      calloc(1, sizeof(struct Curl_schannel_cred));\n    if(!BACKEND->cred) {\n      failf(data, \"schannel: unable to allocate memory\");\n\n      if(client_certs[0])\n        CertFreeCertificateContext(client_certs[0]);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n    BACKEND->cred->refcount = 1;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374716.aspx\n     */\n    sspi_status =\n      s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,\n                                         SECPKG_CRED_OUTBOUND, NULL,\n                                         &schannel_cred, NULL, NULL,\n                                         &BACKEND->cred->cred_handle,\n                                         &BACKEND->cred->time_stamp);\n\n    if(client_certs[0])\n      CertFreeCertificateContext(client_certs[0]);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      Curl_safefree(BACKEND->cred);\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_NO_CREDENTIALS:\n      case SEC_E_SECPKG_NOT_FOUND:\n      case SEC_E_NOT_OWNER:\n      case SEC_E_UNKNOWN_CREDENTIALS:\n      case SEC_E_INTERNAL_ERROR:\n      default:\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n  /* Warn if SNI is disabled due to use of an IP address */\n  if(Curl_inet_pton(AF_INET, hostname, &addr)\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &addr6)\n#endif\n    ) {\n    infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    int cur = 0;\n    int list_start_index = 0;\n    unsigned int *extension_len = NULL;\n    unsigned short* list_len = NULL;\n\n    /* The first four bytes will be an unsigned int indicating number\n       of bytes of data in the rest of the buffer. */\n    extension_len = (unsigned int *)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned int);\n\n    /* The next four bytes are an indicator that this buffer will contain\n       ALPN data, as opposed to NPN, for example. */\n    *(unsigned int *)&alpn_buffer[cur] =\n      SecApplicationProtocolNegotiationExt_ALPN;\n    cur += sizeof(unsigned int);\n\n    /* The next two bytes will be an unsigned short indicating the number\n       of bytes used to list the preferred protocols. */\n    list_len = (unsigned short*)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned short);\n\n    list_start_index = cur;\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      memcpy(&alpn_buffer[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    alpn_buffer[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&alpn_buffer[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    *list_len = curlx_uitous(cur - list_start_index);\n    *extension_len = *list_len + sizeof(unsigned int) + sizeof(unsigned short);\n\n    InitSecBuffer(&inbuf, SECBUFFER_APPLICATION_PROTOCOLS, alpn_buffer, cur);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n  else {\n    InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n#else /* HAS_ALPN */\n  InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n#endif\n\n  /* setup output buffer */\n  InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n  /* security request flags */\n  BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n    ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY |\n    ISC_REQ_STREAM;\n\n  if(!SSL_SET_OPTION(auto_client_cert)) {\n    BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n  }\n\n  /* allocate memory for the security context handle */\n  BACKEND->ctxt = (struct Curl_schannel_ctxt *)\n    calloc(1, sizeof(struct Curl_schannel_ctxt));\n  if(!BACKEND->ctxt) {\n    failf(data, \"schannel: unable to allocate memory\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  host_name = curlx_convert_UTF8_to_tchar(hostname);\n  if(!host_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Schannel InitializeSecurityContext:\n     https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n\n     At the moment we don't pass inbuf unless we're using ALPN since we only\n     use it for that, and Wine (for which we currently disable ALPN) is giving\n     us problems with inbuf regardless. https://github.com/curl/curl/issues/983\n  */\n  sspi_status = s_pSecFn->InitializeSecurityContext(\n    &BACKEND->cred->cred_handle, NULL, host_name, BACKEND->req_flags, 0, 0,\n    (BACKEND->use_alpn ? &inbuf_desc : NULL),\n    0, &BACKEND->ctxt->ctxt_handle,\n    &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n  curlx_unicodefree(host_name);\n\n  if(sspi_status != SEC_I_CONTINUE_NEEDED) {\n    char buffer[STRERROR_LEN];\n    Curl_safefree(BACKEND->ctxt);\n    switch(sspi_status) {\n    case SEC_E_INSUFFICIENT_MEMORY:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_OUT_OF_MEMORY;\n    case SEC_E_WRONG_PRINCIPAL:\n      failf(data, \"schannel: SNI or certificate check failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_PEER_FAILED_VERIFICATION;\n      /*\n        case SEC_E_INVALID_HANDLE:\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_LOGON_DENIED:\n        case SEC_E_TARGET_UNKNOWN:\n        case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n        case SEC_E_INTERNAL_ERROR:\n        case SEC_E_NO_CREDENTIALS:\n        case SEC_E_UNSUPPORTED_FUNCTION:\n        case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n      */\n    default:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  DEBUGF(infof(data, \"schannel: sending initial handshake data: \"\n               \"sending %lu bytes...\\n\", outbuf.cbBuffer));\n\n  /* send initial handshake data which is now stored in output buffer */\n  result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                            outbuf.cbBuffer, &written);\n  s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n  if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n    failf(data, \"schannel: failed to send initial handshake data: \"\n          \"sent %zd of %lu bytes\", written, outbuf.cbBuffer);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  DEBUGF(infof(data, \"schannel: sent initial handshake data: \"\n               \"sent %zd bytes\\n\", written));\n\n  BACKEND->recv_unrecoverable_err = CURLE_OK;\n  BACKEND->recv_sspi_close_notify = false;\n  BACKEND->recv_connection_closed = false;\n  BACKEND->encdata_is_incomplete = false;\n\n  /* continue to second handshake step */\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  int i;\n  ssize_t nread = -1, written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  SecBuffer outbuf[3];\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf[2];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n  bool doread;\n  char * const hostname = SSL_HOST_NAME();\n  const char *pubkey_ptr;\n\n  doread = (connssl->connecting_state != ssl_connect_2_writing) ? TRUE : FALSE;\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 2/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred || !BACKEND->ctxt)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* buffer to store previously received and decrypted data */\n  if(!BACKEND->decdata_buffer) {\n    BACKEND->decdata_offset = 0;\n    BACKEND->decdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->decdata_buffer = malloc(BACKEND->decdata_length);\n    if(!BACKEND->decdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* buffer to store previously received and encrypted data */\n  if(!BACKEND->encdata_buffer) {\n    BACKEND->encdata_is_incomplete = false;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->encdata_buffer = malloc(BACKEND->encdata_length);\n    if(!BACKEND->encdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* if we need a bigger buffer to read a full message, increase buffer now */\n  if(BACKEND->encdata_length - BACKEND->encdata_offset <\n     CURL_SCHANNEL_BUFFER_FREE_SIZE) {\n    /* increase internal encrypted data buffer */\n    size_t reallocated_length = BACKEND->encdata_offset +\n      CURL_SCHANNEL_BUFFER_FREE_SIZE;\n    reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                 reallocated_length);\n\n    if(!reallocated_buffer) {\n      failf(data, \"schannel: unable to re-allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n    }\n  }\n\n  for(;;) {\n    TCHAR *host_name;\n    if(doread) {\n      /* read encrypted handshake data from socket */\n      result = Curl_read_plain(conn->sock[sockindex],\n                               (char *) (BACKEND->encdata_buffer +\n                                         BACKEND->encdata_offset),\n                               BACKEND->encdata_length -\n                               BACKEND->encdata_offset,\n                               &nread);\n      if(result == CURLE_AGAIN) {\n        if(connssl->connecting_state != ssl_connect_2_writing)\n          connssl->connecting_state = ssl_connect_2_reading;\n        DEBUGF(infof(data, \"schannel: failed to receive handshake, \"\n                     \"need more data\\n\"));\n        return CURLE_OK;\n      }\n      else if((result != CURLE_OK) || (nread == 0)) {\n        failf(data, \"schannel: failed to receive handshake, \"\n              \"SSL/TLS connection failed\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n\n      /* increase encrypted data buffer offset */\n      BACKEND->encdata_offset += nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* setup input buffers */\n    InitSecBuffer(&inbuf[0], SECBUFFER_TOKEN, malloc(BACKEND->encdata_offset),\n                  curlx_uztoul(BACKEND->encdata_offset));\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 2);\n\n    /* setup output buffers */\n    InitSecBuffer(&outbuf[0], SECBUFFER_TOKEN, NULL, 0);\n    InitSecBuffer(&outbuf[1], SECBUFFER_ALERT, NULL, 0);\n    InitSecBuffer(&outbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, outbuf, 3);\n\n    if(!inbuf[0].pvBuffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    /* copy received handshake data into input buffer */\n    memcpy(inbuf[0].pvBuffer, BACKEND->encdata_buffer,\n           BACKEND->encdata_offset);\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n     */\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle, &BACKEND->ctxt->ctxt_handle,\n      host_name, BACKEND->req_flags, 0, 0, &inbuf_desc, 0, NULL,\n      &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    /* free buffer for received handshake data */\n    Curl_safefree(inbuf[0].pvBuffer);\n\n    /* check if the handshake was incomplete */\n    if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      connssl->connecting_state = ssl_connect_2_reading;\n      DEBUGF(infof(data,\n                   \"schannel: received incomplete message, need more data\\n\"));\n      return CURLE_OK;\n    }\n\n    /* If the server has requested a client certificate, attempt to continue\n       the handshake without one. This will allow connections to servers which\n       request a client certificate but do not require it. */\n    if(sspi_status == SEC_I_INCOMPLETE_CREDENTIALS &&\n       !(BACKEND->req_flags & ISC_REQ_USE_SUPPLIED_CREDS)) {\n      BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n      connssl->connecting_state = ssl_connect_2_writing;\n      DEBUGF(infof(data,\n                   \"schannel: a client certificate has been requested\\n\"));\n      return CURLE_OK;\n    }\n\n    /* check if the handshake needs to be continued */\n    if(sspi_status == SEC_I_CONTINUE_NEEDED || sspi_status == SEC_E_OK) {\n      for(i = 0; i < 3; i++) {\n        /* search for handshake tokens that need to be send */\n        if(outbuf[i].BufferType == SECBUFFER_TOKEN && outbuf[i].cbBuffer > 0) {\n          DEBUGF(infof(data, \"schannel: sending next handshake data: \"\n                       \"sending %lu bytes...\\n\", outbuf[i].cbBuffer));\n\n          /* send handshake token to server */\n          result = Curl_write_plain(data, conn->sock[sockindex],\n                                    outbuf[i].pvBuffer, outbuf[i].cbBuffer,\n                                    &written);\n          if((result != CURLE_OK) ||\n             (outbuf[i].cbBuffer != (size_t) written)) {\n            failf(data, \"schannel: failed to send next handshake data: \"\n                  \"sent %zd of %lu bytes\", written, outbuf[i].cbBuffer);\n            return CURLE_SSL_CONNECT_ERROR;\n          }\n        }\n\n        /* free obsolete buffer */\n        if(outbuf[i].pvBuffer != NULL) {\n          s_pSecFn->FreeContextBuffer(outbuf[i].pvBuffer);\n        }\n      }\n    }\n    else {\n      char buffer[STRERROR_LEN];\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_WRONG_PRINCIPAL:\n        failf(data, \"schannel: SNI or certificate check failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case SEC_E_UNTRUSTED_ROOT:\n        failf(data, \"schannel: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n        /*\n          case SEC_E_INVALID_HANDLE:\n          case SEC_E_INVALID_TOKEN:\n          case SEC_E_LOGON_DENIED:\n          case SEC_E_TARGET_UNKNOWN:\n          case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n          case SEC_E_INTERNAL_ERROR:\n          case SEC_E_NO_CREDENTIALS:\n          case SEC_E_UNSUPPORTED_FUNCTION:\n          case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n        */\n      default:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n\n    /* check if there was additional remaining encrypted data */\n    if(inbuf[1].BufferType == SECBUFFER_EXTRA && inbuf[1].cbBuffer > 0) {\n      DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                   inbuf[1].cbBuffer));\n      /*\n        There are two cases where we could be getting extra data here:\n        1) If we're renegotiating a connection and the handshake is already\n        complete (from the server perspective), it can encrypted app data\n        (not handshake data) in an extra buffer at this point.\n        2) (sspi_status == SEC_I_CONTINUE_NEEDED) We are negotiating a\n        connection and this extra data is part of the handshake.\n        We should process the data immediately; waiting for the socket to\n        be ready may fail since the server is done sending handshake data.\n      */\n      /* check if the remaining data is less than the total amount\n         and therefore begins after the already processed data */\n      if(BACKEND->encdata_offset > inbuf[1].cbBuffer) {\n        memmove(BACKEND->encdata_buffer,\n                (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                inbuf[1].cbBuffer, inbuf[1].cbBuffer);\n        BACKEND->encdata_offset = inbuf[1].cbBuffer;\n        if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n          doread = FALSE;\n          continue;\n        }\n      }\n    }\n    else {\n      BACKEND->encdata_offset = 0;\n    }\n    break;\n  }\n\n  /* check if the handshake needs to be continued */\n  if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n\n  /* check if the handshake is complete */\n  if(sspi_status == SEC_E_OK) {\n    connssl->connecting_state = ssl_connect_3;\n    DEBUGF(infof(data, \"schannel: SSL/TLS handshake complete\\n\"));\n  }\n\n  pubkey_ptr = SSL_PINNED_PUB_KEY();\n  if(pubkey_ptr) {\n    result = pkp_pin_peer_pubkey(data, conn, sockindex, pubkey_ptr);\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n  }\n\n#ifdef HAS_MANUAL_VERIFY_API\n  if(conn->ssl_config.verifypeer && BACKEND->use_manual_cred_validation) {\n    return Curl_verify_certificate(data, conn, sockindex);\n  }\n#endif\n\n  return CURLE_OK;\n}\n\nstatic bool\nvalid_cert_encoding(const CERT_CONTEXT *cert_context)\n{\n  return (cert_context != NULL) &&\n    ((cert_context->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n    (cert_context->pbCertEncoded != NULL) &&\n    (cert_context->cbCertEncoded > 0);\n}\n\ntypedef bool(*Read_crt_func)(const CERT_CONTEXT *ccert_context, void *arg);\n\nstatic void\ntraverse_cert_store(const CERT_CONTEXT *context, Read_crt_func func,\n                    void *arg)\n{\n  const CERT_CONTEXT *current_context = NULL;\n  bool should_continue = true;\n  while(should_continue &&\n        (current_context = CertEnumCertificatesInStore(\n          context->hCertStore,\n          current_context)) != NULL)\n    should_continue = func(current_context, arg);\n\n  if(current_context)\n    CertFreeCertificateContext(current_context);\n}\n\nstatic bool\ncert_counter_callback(const CERT_CONTEXT *ccert_context, void *certs_count)\n{\n  if(valid_cert_encoding(ccert_context))\n    (*(int *)certs_count)++;\n  return true;\n}\n\nstruct Adder_args\n{\n  struct Curl_easy *data;\n  CURLcode result;\n  int idx;\n  int certs_count;\n};\n\nstatic bool\nadd_cert_to_certinfo(const CERT_CONTEXT *ccert_context, void *raw_arg)\n{\n  struct Adder_args *args = (struct Adder_args*)raw_arg;\n  args->result = CURLE_OK;\n  if(valid_cert_encoding(ccert_context)) {\n    const char *beg = (const char *) ccert_context->pbCertEncoded;\n    const char *end = beg + ccert_context->cbCertEncoded;\n    int insert_index = (args->certs_count - 1) - args->idx;\n    args->result = Curl_extract_certinfo(args->data, insert_index,\n                                         beg, end);\n    args->idx++;\n  }\n  return args->result == CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CERT_CONTEXT *ccert_context = NULL;\n  bool isproxy = SSL_IS_PROXY();\n#ifdef DEBUGBUILD\n  const char * const hostname = SSL_HOST_NAME();\n#endif\n#ifdef HAS_ALPN\n  SecPkgContext_ApplicationProtocol alpn_result;\n#endif\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 3/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* check if the required context attributes are met */\n  if(BACKEND->ret_flags != BACKEND->req_flags) {\n    if(!(BACKEND->ret_flags & ISC_RET_SEQUENCE_DETECT))\n      failf(data, \"schannel: failed to setup sequence detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_REPLAY_DETECT))\n      failf(data, \"schannel: failed to setup replay detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_CONFIDENTIALITY))\n      failf(data, \"schannel: failed to setup confidentiality\");\n    if(!(BACKEND->ret_flags & ISC_RET_ALLOCATED_MEMORY))\n      failf(data, \"schannel: failed to setup memory allocation\");\n    if(!(BACKEND->ret_flags & ISC_RET_STREAM))\n      failf(data, \"schannel: failed to setup stream orientation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_APPLICATION_PROTOCOL,\n                                       &alpn_result);\n\n    if(sspi_status != SEC_E_OK) {\n      failf(data, \"schannel: failed to retrieve ALPN result\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(alpn_result.ProtoNegoStatus ==\n       SecApplicationProtocolNegotiationStatus_Success) {\n\n      infof(data, \"schannel: ALPN, server accepted to use %.*s\\n\",\n            alpn_result.ProtocolIdSize, alpn_result.ProtocolId);\n\n#ifdef USE_HTTP2\n      if(alpn_result.ProtocolIdSize == ALPN_H2_LENGTH &&\n         !memcmp(ALPN_H2, alpn_result.ProtocolId, ALPN_H2_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n        if(alpn_result.ProtocolIdSize == ALPN_HTTP_1_1_LENGTH &&\n           !memcmp(ALPN_HTTP_1_1, alpn_result.ProtocolId,\n                   ALPN_HTTP_1_1_LENGTH)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n    }\n    else\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n#endif\n\n  /* save the current session data for possible re-use */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    struct Curl_schannel_cred *old_cred = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy, (void **)&old_cred,\n                                      NULL, sockindex));\n    if(incache) {\n      if(old_cred != BACKEND->cred) {\n        DEBUGF(infof(data,\n                     \"schannel: old credential handle is stale, removing\\n\"));\n        /* we're not taking old_cred ownership here, no refcount++ is needed */\n        Curl_ssl_delsessionid(data, (void *)old_cred);\n        incache = FALSE;\n      }\n    }\n    if(!incache) {\n      result = Curl_ssl_addsessionid(data, conn, isproxy, BACKEND->cred,\n                                     sizeof(struct Curl_schannel_cred),\n                                     sockindex);\n      if(result) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"schannel: failed to store credential handle\");\n        return result;\n      }\n      else {\n        /* this cred session is now also referenced by sessionid cache */\n        BACKEND->cred->refcount++;\n        DEBUGF(infof(data,\n                     \"schannel: stored credential handle in session cache\\n\"));\n      }\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(data->set.ssl.certinfo) {\n    int certs_count = 0;\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &ccert_context);\n\n    if((sspi_status != SEC_E_OK) || !ccert_context) {\n      failf(data, \"schannel: failed to retrieve remote cert context\");\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n\n    traverse_cert_store(ccert_context, cert_counter_callback, &certs_count);\n\n    result = Curl_ssl_init_certinfo(data, certs_count);\n    if(!result) {\n      struct Adder_args args;\n      args.data = data;\n      args.idx = 0;\n      args.certs_count = certs_count;\n      traverse_cert_store(ccert_context, add_cert_to_certinfo, &args);\n      result = args.result;\n    }\n    CertFreeCertificateContext(ccert_context);\n    if(result)\n      return result;\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_common(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex, bool nonblocking, bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = schannel_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL/TLS socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL/TLS connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = schannel_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = schannel_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = schannel_recv;\n    conn->send[sockindex] = schannel_send;\n\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n    /* When SSPI is used in combination with Schannel\n     * we need the Schannel context to create the Schannel\n     * binding to pass the IIS extended protection checks.\n     * Available on Windows 7 or later.\n     */\n    conn->sslContext = &BACKEND->ctxt->ctxt_handle;\n#endif\n\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* reset our connection state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t\nschannel_send(struct Curl_easy *data, int sockindex,\n              const void *buf, size_t len, CURLcode *err)\n{\n  ssize_t written = -1;\n  size_t data_len = 0;\n  unsigned char *ptr = NULL;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf[4];\n  SecBufferDesc outbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n\n  /* check if the maximum stream sizes were queried */\n  if(BACKEND->stream_sizes.cbMaximumMessage == 0) {\n    sspi_status = s_pSecFn->QueryContextAttributes(\n      &BACKEND->ctxt->ctxt_handle,\n      SECPKG_ATTR_STREAM_SIZES,\n      &BACKEND->stream_sizes);\n    if(sspi_status != SEC_E_OK) {\n      *err = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n\n  /* check if the buffer is longer than the maximum message length */\n  if(len > BACKEND->stream_sizes.cbMaximumMessage) {\n    len = BACKEND->stream_sizes.cbMaximumMessage;\n  }\n\n  /* calculate the complete message length and allocate a buffer for it */\n  data_len = BACKEND->stream_sizes.cbHeader + len +\n    BACKEND->stream_sizes.cbTrailer;\n  ptr = (unsigned char *) malloc(data_len);\n  if(!ptr) {\n    *err = CURLE_OUT_OF_MEMORY;\n    return -1;\n  }\n\n  /* setup output buffers (header, data, trailer, empty) */\n  InitSecBuffer(&outbuf[0], SECBUFFER_STREAM_HEADER,\n                ptr, BACKEND->stream_sizes.cbHeader);\n  InitSecBuffer(&outbuf[1], SECBUFFER_DATA,\n                ptr + BACKEND->stream_sizes.cbHeader, curlx_uztoul(len));\n  InitSecBuffer(&outbuf[2], SECBUFFER_STREAM_TRAILER,\n                ptr + BACKEND->stream_sizes.cbHeader + len,\n                BACKEND->stream_sizes.cbTrailer);\n  InitSecBuffer(&outbuf[3], SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, outbuf, 4);\n\n  /* copy data into output buffer */\n  memcpy(outbuf[1].pvBuffer, buf, len);\n\n  /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375390.aspx */\n  sspi_status = s_pSecFn->EncryptMessage(&BACKEND->ctxt->ctxt_handle, 0,\n                                         &outbuf_desc, 0);\n\n  /* check if the message was encrypted */\n  if(sspi_status == SEC_E_OK) {\n    written = 0;\n\n    /* send the encrypted message including header, data and trailer */\n    len = outbuf[0].cbBuffer + outbuf[1].cbBuffer + outbuf[2].cbBuffer;\n\n    /*\n      It's important to send the full message which includes the header,\n      encrypted payload, and trailer.  Until the client receives all the\n      data a coherent message has not been delivered and the client\n      can't read any of it.\n\n      If we wanted to buffer the unwritten encrypted bytes, we would\n      tell the client that all data it has requested to be sent has been\n      sent. The unwritten encrypted bytes would be the first bytes to\n      send on the next invocation.\n      Here's the catch with this - if we tell the client that all the\n      bytes have been sent, will the client call this method again to\n      send the buffered data?  Looking at who calls this function, it\n      seems the answer is NO.\n    */\n\n    /* send entire message or fail */\n    while(len > (size_t)written) {\n      ssize_t this_write = 0;\n      int what;\n      timediff_t timeout_ms = Curl_timeleft(data, NULL, FALSE);\n      if(timeout_ms < 0) {\n        /* we already got the timeout */\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      else if(!timeout_ms)\n        timeout_ms = TIMEDIFF_T_MAX;\n      what = SOCKET_WRITABLE(conn->sock[sockindex], timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        *err = CURLE_SEND_ERROR;\n        written = -1;\n        break;\n      }\n      else if(0 == what) {\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      /* socket is writable */\n\n      result = Curl_write_plain(data, conn->sock[sockindex], ptr + written,\n                                len - written, &this_write);\n      if(result == CURLE_AGAIN)\n        continue;\n      else if(result != CURLE_OK) {\n        *err = result;\n        written = -1;\n        break;\n      }\n\n      written += this_write;\n    }\n  }\n  else if(sspi_status == SEC_E_INSUFFICIENT_MEMORY) {\n    *err = CURLE_OUT_OF_MEMORY;\n  }\n  else{\n    *err = CURLE_SEND_ERROR;\n  }\n\n  Curl_safefree(ptr);\n\n  if(len == (size_t)written)\n    /* Encrypted message including header, data and trailer entirely sent.\n       The return value is the number of unencrypted bytes that were sent. */\n    written = outbuf[1].cbBuffer;\n\n  return written;\n}\n\nstatic ssize_t\nschannel_recv(struct Curl_easy *data, int sockindex,\n              char *buf, size_t len, CURLcode *err)\n{\n  size_t size = 0;\n  ssize_t nread = -1;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  size_t reallocated_length;\n  bool done = FALSE;\n  SecBuffer inbuf[4];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  /* we want the length of the encrypted buffer to be at least large enough\n     that it can hold all the bytes requested and some TLS record overhead. */\n  size_t min_encdata_length = len + CURL_SCHANNEL_BUFFER_FREE_SIZE;\n\n  /****************************************************************************\n   * Don't return or set BACKEND->recv_unrecoverable_err unless in the cleanup.\n   * The pattern for return error is set *err, optional infof, goto cleanup.\n   *\n   * Our priority is to always return as much decrypted data to the caller as\n   * possible, even if an error occurs. The state of the decrypted buffer must\n   * always be valid. Transfer of decrypted data to the caller's buffer is\n   * handled in the cleanup.\n   */\n\n  DEBUGF(infof(data, \"schannel: client wants to read %zu bytes\\n\", len));\n  *err = CURLE_OK;\n\n  if(len && len <= BACKEND->decdata_offset) {\n    infof(data, \"schannel: enough decrypted data is already available\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_unrecoverable_err) {\n    *err = BACKEND->recv_unrecoverable_err;\n    infof(data, \"schannel: an unrecoverable error occurred in a prior call\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_sspi_close_notify) {\n    /* once a server has indicated shutdown there is no more encrypted data */\n    infof(data, \"schannel: server indicated shutdown in a prior call\\n\");\n    goto cleanup;\n  }\n\n  /* It's debatable what to return when !len. Regardless we can't return\n     immediately because there may be data to decrypt (in the case we want to\n     decrypt all encrypted cached data) so handle !len later in cleanup.\n  */\n  else if(len && !BACKEND->recv_connection_closed) {\n    /* increase enc buffer in order to fit the requested amount of data */\n    size = BACKEND->encdata_length - BACKEND->encdata_offset;\n    if(size < CURL_SCHANNEL_BUFFER_FREE_SIZE ||\n       BACKEND->encdata_length < min_encdata_length) {\n      reallocated_length = BACKEND->encdata_offset +\n        CURL_SCHANNEL_BUFFER_FREE_SIZE;\n      if(reallocated_length < min_encdata_length) {\n        reallocated_length = min_encdata_length;\n      }\n      reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                   reallocated_length);\n      if(!reallocated_buffer) {\n        *err = CURLE_OUT_OF_MEMORY;\n        failf(data, \"schannel: unable to re-allocate memory\");\n        goto cleanup;\n      }\n\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n      size = BACKEND->encdata_length - BACKEND->encdata_offset;\n      DEBUGF(infof(data, \"schannel: encdata_buffer resized %zu\\n\",\n                   BACKEND->encdata_length));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* read encrypted data from socket */\n    *err = Curl_read_plain(conn->sock[sockindex],\n                           (char *)(BACKEND->encdata_buffer +\n                                    BACKEND->encdata_offset),\n                           size, &nread);\n    if(*err) {\n      nread = -1;\n      if(*err == CURLE_AGAIN)\n        DEBUGF(infof(data,\n                     \"schannel: Curl_read_plain returned CURLE_AGAIN\\n\"));\n      else if(*err == CURLE_RECV_ERROR)\n        infof(data, \"schannel: Curl_read_plain returned CURLE_RECV_ERROR\\n\");\n      else\n        infof(data, \"schannel: Curl_read_plain returned error %d\\n\", *err);\n    }\n    else if(nread == 0) {\n      BACKEND->recv_connection_closed = true;\n      DEBUGF(infof(data, \"schannel: server closed the connection\\n\"));\n    }\n    else if(nread > 0) {\n      BACKEND->encdata_offset += (size_t)nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  /* decrypt loop */\n  while(BACKEND->encdata_offset > 0 && sspi_status == SEC_E_OK &&\n        (!len || BACKEND->decdata_offset < len ||\n         BACKEND->recv_connection_closed)) {\n    /* prepare data buffer for DecryptMessage call */\n    InitSecBuffer(&inbuf[0], SECBUFFER_DATA, BACKEND->encdata_buffer,\n                  curlx_uztoul(BACKEND->encdata_offset));\n\n    /* we need 3 more empty input buffers for possible output */\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[3], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 4);\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375348.aspx\n     */\n    sspi_status = s_pSecFn->DecryptMessage(&BACKEND->ctxt->ctxt_handle,\n                                           &inbuf_desc, 0, NULL);\n\n    /* check if everything went fine (server may want to renegotiate\n       or shutdown the connection context) */\n    if(sspi_status == SEC_E_OK || sspi_status == SEC_I_RENEGOTIATE ||\n       sspi_status == SEC_I_CONTEXT_EXPIRED) {\n      /* check for successfully decrypted data, even before actual\n         renegotiation or shutdown of the connection context */\n      if(inbuf[1].BufferType == SECBUFFER_DATA) {\n        DEBUGF(infof(data, \"schannel: decrypted data length: %lu\\n\",\n                     inbuf[1].cbBuffer));\n\n        /* increase buffer in order to fit the received amount of data */\n        size = inbuf[1].cbBuffer > CURL_SCHANNEL_BUFFER_FREE_SIZE ?\n          inbuf[1].cbBuffer : CURL_SCHANNEL_BUFFER_FREE_SIZE;\n        if(BACKEND->decdata_length - BACKEND->decdata_offset < size ||\n           BACKEND->decdata_length < len) {\n          /* increase internal decrypted data buffer */\n          reallocated_length = BACKEND->decdata_offset + size;\n          /* make sure that the requested amount of data fits */\n          if(reallocated_length < len) {\n            reallocated_length = len;\n          }\n          reallocated_buffer = realloc(BACKEND->decdata_buffer,\n                                       reallocated_length);\n          if(!reallocated_buffer) {\n            *err = CURLE_OUT_OF_MEMORY;\n            failf(data, \"schannel: unable to re-allocate memory\");\n            goto cleanup;\n          }\n          BACKEND->decdata_buffer = reallocated_buffer;\n          BACKEND->decdata_length = reallocated_length;\n        }\n\n        /* copy decrypted data to internal buffer */\n        size = inbuf[1].cbBuffer;\n        if(size) {\n          memcpy(BACKEND->decdata_buffer + BACKEND->decdata_offset,\n                 inbuf[1].pvBuffer, size);\n          BACKEND->decdata_offset += size;\n        }\n\n        DEBUGF(infof(data, \"schannel: decrypted data added: %zu\\n\", size));\n        DEBUGF(infof(data,\n                     \"schannel: decrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->decdata_offset, BACKEND->decdata_length));\n      }\n\n      /* check for remaining encrypted data */\n      if(inbuf[3].BufferType == SECBUFFER_EXTRA && inbuf[3].cbBuffer > 0) {\n        DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                     inbuf[3].cbBuffer));\n\n        /* check if the remaining data is less than the total amount\n         * and therefore begins after the already processed data\n         */\n        if(BACKEND->encdata_offset > inbuf[3].cbBuffer) {\n          /* move remaining encrypted data forward to the beginning of\n             buffer */\n          memmove(BACKEND->encdata_buffer,\n                  (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                  inbuf[3].cbBuffer, inbuf[3].cbBuffer);\n          BACKEND->encdata_offset = inbuf[3].cbBuffer;\n        }\n\n        DEBUGF(infof(data,\n                     \"schannel: encrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->encdata_offset, BACKEND->encdata_length));\n      }\n      else {\n        /* reset encrypted buffer offset, because there is no data remaining */\n        BACKEND->encdata_offset = 0;\n      }\n\n      /* check if server wants to renegotiate the connection context */\n      if(sspi_status == SEC_I_RENEGOTIATE) {\n        infof(data, \"schannel: remote party requests renegotiation\\n\");\n        if(*err && *err != CURLE_AGAIN) {\n          infof(data, \"schannel: can't renogotiate, an error is pending\\n\");\n          goto cleanup;\n        }\n        if(BACKEND->encdata_offset) {\n          *err = CURLE_RECV_ERROR;\n          infof(data, \"schannel: can't renogotiate, \"\n                \"encrypted data available\\n\");\n          goto cleanup;\n        }\n        /* begin renegotiation */\n        infof(data, \"schannel: renegotiating SSL/TLS connection\\n\");\n        connssl->state = ssl_connection_negotiating;\n        connssl->connecting_state = ssl_connect_2_writing;\n        *err = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n        if(*err) {\n          infof(data, \"schannel: renegotiation failed\\n\");\n          goto cleanup;\n        }\n        /* now retry receiving data */\n        sspi_status = SEC_E_OK;\n        infof(data, \"schannel: SSL/TLS connection renegotiated\\n\");\n        continue;\n      }\n      /* check if the server closed the connection */\n      else if(sspi_status == SEC_I_CONTEXT_EXPIRED) {\n        /* In Windows 2000 SEC_I_CONTEXT_EXPIRED (close_notify) is not\n           returned so we have to work around that in cleanup. */\n        BACKEND->recv_sspi_close_notify = true;\n        if(!BACKEND->recv_connection_closed) {\n          BACKEND->recv_connection_closed = true;\n          infof(data, \"schannel: server closed the connection\\n\");\n        }\n        goto cleanup;\n      }\n    }\n    else if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      if(!*err)\n        *err = CURLE_AGAIN;\n      infof(data, \"schannel: failed to decrypt data, need more data\\n\");\n      goto cleanup;\n    }\n    else {\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n      char buffer[STRERROR_LEN];\n#endif\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: failed to read data from server: %s\\n\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      goto cleanup;\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  DEBUGF(infof(data,\n               \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->decdata_offset, BACKEND->decdata_length));\n\n  cleanup:\n  /* Warning- there is no guarantee the encdata state is valid at this point */\n  DEBUGF(infof(data, \"schannel: schannel_recv cleanup\\n\"));\n\n  /* Error if the connection has closed without a close_notify.\n\n     The behavior here is a matter of debate. We don't want to be vulnerable\n     to a truncation attack however there's some browser precedent for\n     ignoring the close_notify for compatibility reasons.\n\n     Additionally, Windows 2000 (v5.0) is a special case since it seems it\n     doesn't return close_notify. In that case if the connection was closed we\n     assume it was graceful (close_notify) since there doesn't seem to be a\n     way to tell.\n  */\n  if(len && !BACKEND->decdata_offset && BACKEND->recv_connection_closed &&\n     !BACKEND->recv_sspi_close_notify) {\n    bool isWin2k = curlx_verify_windows_version(5, 0, PLATFORM_WINNT,\n                                                VERSION_EQUAL);\n\n    if(isWin2k && sspi_status == SEC_E_OK)\n      BACKEND->recv_sspi_close_notify = true;\n    else {\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: server closed abruptly (missing close_notify)\\n\");\n    }\n  }\n\n  /* Any error other than CURLE_AGAIN is an unrecoverable error. */\n  if(*err && *err != CURLE_AGAIN)\n    BACKEND->recv_unrecoverable_err = *err;\n\n  size = len < BACKEND->decdata_offset ? len : BACKEND->decdata_offset;\n  if(size) {\n    memcpy(buf, BACKEND->decdata_buffer, size);\n    memmove(BACKEND->decdata_buffer, BACKEND->decdata_buffer + size,\n            BACKEND->decdata_offset - size);\n    BACKEND->decdata_offset -= size;\n    DEBUGF(infof(data, \"schannel: decrypted data returned %zu\\n\", size));\n    DEBUGF(infof(data,\n                 \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->decdata_offset, BACKEND->decdata_length));\n    *err = CURLE_OK;\n    return (ssize_t)size;\n  }\n\n  if(!*err && !BACKEND->recv_connection_closed)\n    *err = CURLE_AGAIN;\n\n  /* It's debatable what to return when !len. We could return whatever error\n     we got from decryption but instead we override here so the return is\n     consistent.\n  */\n  if(!len)\n    *err = CURLE_OK;\n\n  return *err ? -1 : 0;\n}\n\nstatic CURLcode schannel_connect_nonblocking(struct Curl_easy *data,\n                                             struct connectdata *conn,\n                                             int sockindex, bool *done)\n{\n  return schannel_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode schannel_connect(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool schannel_data_pending(const struct connectdata *conn,\n                                  int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  if(connssl->use) /* SSL/TLS is in use */\n    return (BACKEND->decdata_offset > 0 ||\n            (BACKEND->encdata_offset > 0 && !BACKEND->encdata_is_incomplete));\n  else\n    return FALSE;\n}\n\nstatic void schannel_close(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(conn->ssl[sockindex].use)\n    /* if the SSL/TLS channel hasn't been shut down yet, do that now. */\n    Curl_ssl_shutdown(data, conn, sockindex);\n}\n\nstatic void schannel_session_free(void *ptr)\n{\n  /* this is expected to be called under sessionid lock */\n  struct Curl_schannel_cred *cred = ptr;\n\n  cred->refcount--;\n  if(cred->refcount == 0) {\n    s_pSecFn->FreeCredentialsHandle(&cred->cred_handle);\n    Curl_safefree(cred);\n  }\n}\n\nstatic int schannel_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  /* See https://msdn.microsoft.com/en-us/library/windows/desktop/aa380138.aspx\n   * Shutting Down an Schannel Connection\n   */\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGASSERT(data);\n\n  infof(data, \"schannel: shutting down SSL/TLS connection with %s port %hu\\n\",\n        hostname, conn->remote_port);\n\n  if(BACKEND->cred && BACKEND->ctxt) {\n    SecBufferDesc BuffDesc;\n    SecBuffer Buffer;\n    SECURITY_STATUS sspi_status;\n    SecBuffer outbuf;\n    SecBufferDesc outbuf_desc;\n    CURLcode result;\n    TCHAR *host_name;\n    DWORD dwshut = SCHANNEL_SHUTDOWN;\n\n    InitSecBuffer(&Buffer, SECBUFFER_TOKEN, &dwshut, sizeof(dwshut));\n    InitSecBufferDesc(&BuffDesc, &Buffer, 1);\n\n    sspi_status = s_pSecFn->ApplyControlToken(&BACKEND->ctxt->ctxt_handle,\n                                              &BuffDesc);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: ApplyControlToken failure: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n    }\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* setup output buffer */\n    InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle,\n      &BACKEND->ctxt->ctxt_handle,\n      host_name,\n      BACKEND->req_flags,\n      0,\n      0,\n      NULL,\n      0,\n      &BACKEND->ctxt->ctxt_handle,\n      &outbuf_desc,\n      &BACKEND->ret_flags,\n      &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    if((sspi_status == SEC_E_OK) || (sspi_status == SEC_I_CONTEXT_EXPIRED)) {\n      /* send close message which is in output buffer */\n      ssize_t written;\n      result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                                outbuf.cbBuffer, &written);\n\n      s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n      if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n        infof(data, \"schannel: failed to send close msg: %s\"\n              \" (bytes written: %zd)\\n\", curl_easy_strerror(result), written);\n      }\n    }\n  }\n\n  /* free SSPI Schannel API security context handle */\n  if(BACKEND->ctxt) {\n    DEBUGF(infof(data, \"schannel: clear security context handle\\n\"));\n    s_pSecFn->DeleteSecurityContext(&BACKEND->ctxt->ctxt_handle);\n    Curl_safefree(BACKEND->ctxt);\n  }\n\n  /* free SSPI Schannel API credential handle */\n  if(BACKEND->cred) {\n    Curl_ssl_sessionid_lock(data);\n    schannel_session_free(BACKEND->cred);\n    Curl_ssl_sessionid_unlock(data);\n    BACKEND->cred = NULL;\n  }\n\n  /* free internal buffer for received encrypted data */\n  if(BACKEND->encdata_buffer != NULL) {\n    Curl_safefree(BACKEND->encdata_buffer);\n    BACKEND->encdata_length = 0;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_is_incomplete = false;\n  }\n\n  /* free internal buffer for received decrypted data */\n  if(BACKEND->decdata_buffer != NULL) {\n    Curl_safefree(BACKEND->decdata_buffer);\n    BACKEND->decdata_length = 0;\n    BACKEND->decdata_offset = 0;\n  }\n\n  return CURLE_OK;\n}\n\nstatic int schannel_init(void)\n{\n  return (Curl_sspi_global_init() == CURLE_OK ? 1 : 0);\n}\n\nstatic void schannel_cleanup(void)\n{\n  Curl_sspi_global_cleanup();\n}\n\nstatic size_t schannel_version(char *buffer, size_t size)\n{\n  size = msnprintf(buffer, size, \"Schannel\");\n\n  return size;\n}\n\nstatic CURLcode schannel_random(struct Curl_easy *data UNUSED_PARAM,\n                                unsigned char *entropy, size_t length)\n{\n  HCRYPTPROV hCryptProv = 0;\n\n  (void)data;\n\n  if(!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return CURLE_FAILED_INIT;\n\n  if(!CryptGenRandom(hCryptProv, (DWORD)length, entropy)) {\n    CryptReleaseContext(hCryptProv, 0UL);\n    return CURLE_FAILED_INIT;\n  }\n\n  CryptReleaseContext(hCryptProv, 0UL);\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  CERT_CONTEXT *pCertContextServer = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  do {\n    SECURITY_STATUS sspi_status;\n    const char *x509_der;\n    DWORD x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &pCertContextServer);\n\n    if((sspi_status != SEC_E_OK) || !pCertContextServer) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: Failed to read remote certificate context: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      break; /* failed */\n    }\n\n\n    if(!(((pCertContextServer->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n         (pCertContextServer->cbCertEncoded > 0)))\n      break;\n\n    x509_der = (const char *)pCertContextServer->pbCertEncoded;\n    x509_der_len = pCertContextServer->cbCertEncoded;\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      break;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      break;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n    }\n  } while(0);\n\n  if(pCertContextServer)\n    CertFreeCertificateContext(pCertContextServer);\n\n  return result;\n}\n\nstatic void schannel_checksum(const unsigned char *input,\n                              size_t inputlen,\n                              unsigned char *checksum,\n                              size_t checksumlen,\n                              DWORD provType,\n                              const unsigned int algId)\n{\n  HCRYPTPROV hProv = 0;\n  HCRYPTHASH hHash = 0;\n  DWORD cbHashSize = 0;\n  DWORD dwHashSizeLen = (DWORD)sizeof(cbHashSize);\n  DWORD dwChecksumLen = (DWORD)checksumlen;\n\n  /* since this can fail in multiple ways, zero memory first so we never\n   * return old data\n   */\n  memset(checksum, 0, checksumlen);\n\n  if(!CryptAcquireContext(&hProv, NULL, NULL, provType,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return; /* failed */\n\n  do {\n    if(!CryptCreateHash(hProv, algId, 0, 0, &hHash))\n      break; /* failed */\n\n    /* workaround for original MinGW, should be (const BYTE*) */\n    if(!CryptHashData(hHash, (BYTE*)input, (DWORD)inputlen, 0))\n      break; /* failed */\n\n    /* get hash size */\n    if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&cbHashSize,\n                          &dwHashSizeLen, 0))\n      break; /* failed */\n\n    /* check hash size */\n    if(checksumlen < cbHashSize)\n      break; /* failed */\n\n    if(CryptGetHashParam(hHash, HP_HASHVAL, checksum, &dwChecksumLen, 0))\n      break; /* failed */\n  } while(0);\n\n  if(hHash)\n    CryptDestroyHash(hHash);\n\n  if(hProv)\n    CryptReleaseContext(hProv, 0);\n}\n\nstatic CURLcode schannel_sha256sum(const unsigned char *input,\n                                   size_t inputlen,\n                                   unsigned char *sha256sum,\n                                   size_t sha256len)\n{\n  schannel_checksum(input, inputlen, sha256sum, sha256len,\n                    PROV_RSA_AES, CALG_SHA_256);\n  return CURLE_OK;\n}\n\nstatic void *schannel_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return &BACKEND->ctxt->ctxt_handle;\n}\n\nconst struct Curl_ssl Curl_ssl_schannel = {\n  { CURLSSLBACKEND_SCHANNEL, \"schannel\" }, /* info */\n\n  SSLSUPP_CERTINFO |\n#ifdef HAS_MANUAL_VERIFY_API\n  SSLSUPP_CAINFO_BLOB |\n#endif\n  SSLSUPP_PINNEDPUBKEY,\n\n  sizeof(struct ssl_backend_data),\n\n  schannel_init,                     /* init */\n  schannel_cleanup,                  /* cleanup */\n  schannel_version,                  /* version */\n  Curl_none_check_cxn,               /* check_cxn */\n  schannel_shutdown,                 /* shutdown */\n  schannel_data_pending,             /* data_pending */\n  schannel_random,                   /* random */\n  Curl_none_cert_status_request,     /* cert_status_request */\n  schannel_connect,                  /* connect */\n  schannel_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                  /* getsock */\n  schannel_get_internals,            /* get_internals */\n  schannel_close,                    /* close_one */\n  Curl_none_close_all,               /* close_all */\n  schannel_session_free,             /* session_free */\n  Curl_none_set_engine,              /* set_engine */\n  Curl_none_set_engine_default,      /* set_engine_default */\n  Curl_none_engines_list,            /* engines_list */\n  Curl_none_false_start,             /* false_start */\n  schannel_sha256sum                 /* sha256sum */\n};\n\n#endif /* USE_SCHANNEL */\n", "#ifndef HEADER_CURL_SCHANNEL_H\n#define HEADER_CURL_SCHANNEL_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012, Marc Hoersken, <info@marc-hoersken.de>, et al.\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#ifdef USE_SCHANNEL\n\n#include <schnlsp.h>\n#include <schannel.h>\n#include \"curl_sspi.h\"\n\n#include \"urldata.h\"\n\n/* <wincrypt.h> has been included via the above <schnlsp.h>.\n * Or in case of ldap.c, it was included via <winldap.h>.\n * And since <wincrypt.h> has this:\n *   #define X509_NAME  ((LPCSTR) 7)\n *\n * And in BoringSSL's <openssl/base.h> there is:\n *  typedef struct X509_name_st X509_NAME;\n *  etc.\n *\n * this will cause all kinds of C-preprocessing paste errors in\n * BoringSSL's <openssl/x509.h>: So just undefine those defines here\n * (and only here).\n */\n#if defined(HAVE_BORINGSSL) || defined(OPENSSL_IS_BORINGSSL)\n# undef X509_NAME\n# undef X509_CERT_PAIR\n# undef X509_EXTENSIONS\n#endif\n\nextern const struct Curl_ssl Curl_ssl_schannel;\n\nCURLcode Curl_verify_certificate(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex);\n\n/* structs to expose only in schannel.c and schannel_verify.c */\n#ifdef EXPOSE_SCHANNEL_INTERNAL_STRUCTS\n\n#ifdef __MINGW32__\n#include <_mingw.h>\n#ifdef __MINGW64_VERSION_MAJOR\n#define HAS_MANUAL_VERIFY_API\n#endif\n#else\n#include <wincrypt.h>\n#ifdef CERT_CHAIN_REVOCATION_CHECK_CHAIN\n#define HAS_MANUAL_VERIFY_API\n#endif\n#endif\n\nstruct Curl_schannel_cred {\n  CredHandle cred_handle;\n  TimeStamp time_stamp;\n  int refcount;\n};\n\nstruct Curl_schannel_ctxt {\n  CtxtHandle ctxt_handle;\n  TimeStamp time_stamp;\n};\n\nstruct ssl_backend_data {\n  struct Curl_schannel_cred *cred;\n  struct Curl_schannel_ctxt *ctxt;\n  SecPkgContext_StreamSizes stream_sizes;\n  size_t encdata_length, decdata_length;\n  size_t encdata_offset, decdata_offset;\n  unsigned char *encdata_buffer, *decdata_buffer;\n  /* encdata_is_incomplete: if encdata contains only a partial record that\n     can't be decrypted without another Curl_read_plain (that is, status is\n     SEC_E_INCOMPLETE_MESSAGE) then set this true. after Curl_read_plain writes\n     more bytes into encdata then set this back to false. */\n  bool encdata_is_incomplete;\n  unsigned long req_flags, ret_flags;\n  CURLcode recv_unrecoverable_err; /* schannel_recv had an unrecoverable err */\n  bool recv_sspi_close_notify; /* true if connection closed by close_notify */\n  bool recv_connection_closed; /* true if connection closed, regardless how */\n  bool use_alpn; /* true if ALPN is used for this connection */\n#ifdef HAS_MANUAL_VERIFY_API\n  bool use_manual_cred_validation; /* true if manual cred validation is used */\n#endif\n};\n#endif /* EXPOSE_SCHANNEL_INTERNAL_STRUCTS */\n\n#endif /* USE_SCHANNEL */\n#endif /* HEADER_CURL_SCHANNEL_H */\n"], "fixing_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2012 - 2016, Marc Hoersken, <info@marc-hoersken.de>\n * Copyright (C) 2012, Mark Salisbury, <mark.salisbury@hp.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all Schannel-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_SCHANNEL\n\n#define EXPOSE_SCHANNEL_INTERNAL_STRUCTS\n\n#ifndef USE_WINDOWS_SSPI\n#  error \"Can't compile SCHANNEL support without SSPI.\"\n#endif\n\n#include \"schannel.h\"\n#include \"vtls.h\"\n#include \"strcase.h\"\n#include \"sendf.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"strerror.h\"\n#include \"select.h\" /* for the socket readiness */\n#include \"inet_pton.h\" /* for IP addr SNI check */\n#include \"curl_multibyte.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n#include \"version_win32.h\"\n\n/* The last #include file should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* ALPN requires version 8.1 of the Windows SDK, which was\n   shipped with Visual Studio 2013, aka _MSC_VER 1800:\n\n   https://technet.microsoft.com/en-us/library/hh831771%28v=ws.11%29.aspx\n*/\n#if defined(_MSC_VER) && (_MSC_VER >= 1800) && !defined(_USING_V110_SDK71_)\n#  define HAS_ALPN 1\n#endif\n\n#ifndef UNISP_NAME_A\n#define UNISP_NAME_A \"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME_W\n#define UNISP_NAME_W L\"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME\n#ifdef UNICODE\n#define UNISP_NAME  UNISP_NAME_W\n#else\n#define UNISP_NAME  UNISP_NAME_A\n#endif\n#endif\n\n#if defined(CryptStringToBinary) && defined(CRYPT_STRING_HEX)\n#define HAS_CLIENT_CERT_PATH\n#endif\n\n#ifdef HAS_CLIENT_CERT_PATH\n#ifdef UNICODE\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_W\n#else\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_A\n#endif\n#endif\n\n#ifndef SP_PROT_SSL2_CLIENT\n#define SP_PROT_SSL2_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_SSL3_CLIENT\n#define SP_PROT_SSL3_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_TLS1_CLIENT\n#define SP_PROT_TLS1_CLIENT             0x00000080\n#endif\n\n#ifndef SP_PROT_TLS1_0_CLIENT\n#define SP_PROT_TLS1_0_CLIENT           SP_PROT_TLS1_CLIENT\n#endif\n\n#ifndef SP_PROT_TLS1_1_CLIENT\n#define SP_PROT_TLS1_1_CLIENT           0x00000200\n#endif\n\n#ifndef SP_PROT_TLS1_2_CLIENT\n#define SP_PROT_TLS1_2_CLIENT           0x00000800\n#endif\n\n#ifndef SCH_USE_STRONG_CRYPTO\n#define SCH_USE_STRONG_CRYPTO           0x00400000\n#endif\n\n#ifndef SECBUFFER_ALERT\n#define SECBUFFER_ALERT                 17\n#endif\n\n/* Both schannel buffer sizes must be > 0 */\n#define CURL_SCHANNEL_BUFFER_INIT_SIZE   4096\n#define CURL_SCHANNEL_BUFFER_FREE_SIZE   1024\n\n#define CERT_THUMBPRINT_STR_LEN 40\n#define CERT_THUMBPRINT_DATA_LEN 20\n\n/* Uncomment to force verbose output\n * #define infof(x, y, ...) printf(y, __VA_ARGS__)\n * #define failf(x, y, ...) printf(y, __VA_ARGS__)\n */\n\n#ifndef CALG_SHA_256\n#  define CALG_SHA_256 0x0000800c\n#endif\n\n#define BACKEND connssl->backend\n\nstatic Curl_recv schannel_recv;\nstatic Curl_send schannel_send;\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey);\n\nstatic void InitSecBuffer(SecBuffer *buffer, unsigned long BufType,\n                          void *BufDataPtr, unsigned long BufByteSize)\n{\n  buffer->cbBuffer = BufByteSize;\n  buffer->BufferType = BufType;\n  buffer->pvBuffer = BufDataPtr;\n}\n\nstatic void InitSecBufferDesc(SecBufferDesc *desc, SecBuffer *BufArr,\n                              unsigned long NumArrElem)\n{\n  desc->ulVersion = SECBUFFER_VERSION;\n  desc->pBuffers = BufArr;\n  desc->cBuffers = NumArrElem;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(SCHANNEL_CRED *schannel_cred, struct Curl_easy *data,\n                        struct connectdata *conn)\n{\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long i = ssl_version;\n\n  switch(ssl_version_max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    break;\n  }\n  for(; i <= (ssl_version_max >> 16); ++i) {\n    switch(i) {\n    case CURL_SSLVERSION_TLSv1_0:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_0_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_1:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_1_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_2:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_2_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_3:\n      failf(data, \"schannel: TLS 1.3 is not yet supported\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  return CURLE_OK;\n}\n\n/*longest is 26, buffer is slightly bigger*/\n#define LONGEST_ALG_ID 32\n#define CIPHEROPTION(X)                         \\\n  if(strcmp(#X, tmp) == 0)                      \\\n    return X\n\nstatic int\nget_alg_id_by_name(char *name)\n{\n  char tmp[LONGEST_ALG_ID] = { 0 };\n  char *nameEnd = strchr(name, ':');\n  size_t n = nameEnd ? min((size_t)(nameEnd - name), LONGEST_ALG_ID - 1) : \\\n    min(strlen(name), LONGEST_ALG_ID - 1);\n  strncpy(tmp, name, n);\n  tmp[n] = 0;\n  CIPHEROPTION(CALG_MD2);\n  CIPHEROPTION(CALG_MD4);\n  CIPHEROPTION(CALG_MD5);\n  CIPHEROPTION(CALG_SHA);\n  CIPHEROPTION(CALG_SHA1);\n  CIPHEROPTION(CALG_MAC);\n  CIPHEROPTION(CALG_RSA_SIGN);\n  CIPHEROPTION(CALG_DSS_SIGN);\n/*ifdefs for the options that are defined conditionally in wincrypt.h*/\n#ifdef CALG_NO_SIGN\n  CIPHEROPTION(CALG_NO_SIGN);\n#endif\n  CIPHEROPTION(CALG_RSA_KEYX);\n  CIPHEROPTION(CALG_DES);\n#ifdef CALG_3DES_112\n  CIPHEROPTION(CALG_3DES_112);\n#endif\n  CIPHEROPTION(CALG_3DES);\n  CIPHEROPTION(CALG_DESX);\n  CIPHEROPTION(CALG_RC2);\n  CIPHEROPTION(CALG_RC4);\n  CIPHEROPTION(CALG_SEAL);\n#ifdef CALG_DH_SF\n  CIPHEROPTION(CALG_DH_SF);\n#endif\n  CIPHEROPTION(CALG_DH_EPHEM);\n#ifdef CALG_AGREEDKEY_ANY\n  CIPHEROPTION(CALG_AGREEDKEY_ANY);\n#endif\n#ifdef CALG_HUGHES_MD5\n  CIPHEROPTION(CALG_HUGHES_MD5);\n#endif\n  CIPHEROPTION(CALG_SKIPJACK);\n#ifdef CALG_TEK\n  CIPHEROPTION(CALG_TEK);\n#endif\n  CIPHEROPTION(CALG_CYLINK_MEK);\n  CIPHEROPTION(CALG_SSL3_SHAMD5);\n#ifdef CALG_SSL3_MASTER\n  CIPHEROPTION(CALG_SSL3_MASTER);\n#endif\n#ifdef CALG_SCHANNEL_MASTER_HASH\n  CIPHEROPTION(CALG_SCHANNEL_MASTER_HASH);\n#endif\n#ifdef CALG_SCHANNEL_MAC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_MAC_KEY);\n#endif\n#ifdef CALG_SCHANNEL_ENC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_ENC_KEY);\n#endif\n#ifdef CALG_PCT1_MASTER\n  CIPHEROPTION(CALG_PCT1_MASTER);\n#endif\n#ifdef CALG_SSL2_MASTER\n  CIPHEROPTION(CALG_SSL2_MASTER);\n#endif\n#ifdef CALG_TLS1_MASTER\n  CIPHEROPTION(CALG_TLS1_MASTER);\n#endif\n#ifdef CALG_RC5\n  CIPHEROPTION(CALG_RC5);\n#endif\n#ifdef CALG_HMAC\n  CIPHEROPTION(CALG_HMAC);\n#endif\n#if !defined(__W32API_MAJOR_VERSION) ||                                 \\\n  !defined(__W32API_MINOR_VERSION) ||                                   \\\n  defined(__MINGW64_VERSION_MAJOR) ||                                   \\\n  (__W32API_MAJOR_VERSION > 5)     ||                                   \\\n  ((__W32API_MAJOR_VERSION == 5) && (__W32API_MINOR_VERSION > 0))\n  /* CALG_TLS1PRF has a syntax error in MinGW's w32api up to version 5.0,\n     see https://osdn.net/projects/mingw/ticket/38391 */\n  CIPHEROPTION(CALG_TLS1PRF);\n#endif\n#ifdef CALG_HASH_REPLACE_OWF\n  CIPHEROPTION(CALG_HASH_REPLACE_OWF);\n#endif\n#ifdef CALG_AES_128\n  CIPHEROPTION(CALG_AES_128);\n#endif\n#ifdef CALG_AES_192\n  CIPHEROPTION(CALG_AES_192);\n#endif\n#ifdef CALG_AES_256\n  CIPHEROPTION(CALG_AES_256);\n#endif\n#ifdef CALG_AES\n  CIPHEROPTION(CALG_AES);\n#endif\n#ifdef CALG_SHA_256\n  CIPHEROPTION(CALG_SHA_256);\n#endif\n#ifdef CALG_SHA_384\n  CIPHEROPTION(CALG_SHA_384);\n#endif\n#ifdef CALG_SHA_512\n  CIPHEROPTION(CALG_SHA_512);\n#endif\n#ifdef CALG_ECDH\n  CIPHEROPTION(CALG_ECDH);\n#endif\n#ifdef CALG_ECMQV\n  CIPHEROPTION(CALG_ECMQV);\n#endif\n#ifdef CALG_ECDSA\n  CIPHEROPTION(CALG_ECDSA);\n#endif\n#ifdef CALG_ECDH_EPHEM\n  CIPHEROPTION(CALG_ECDH_EPHEM);\n#endif\n  return 0;\n}\n\nstatic CURLcode\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                int *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}\n\n#ifdef HAS_CLIENT_CERT_PATH\n\n/* Function allocates memory for store_path only if CURLE_OK is returned */\nstatic CURLcode\nget_cert_location(TCHAR *path, DWORD *store_name, TCHAR **store_path,\n                  TCHAR **thumbprint)\n{\n  TCHAR *sep;\n  TCHAR *store_path_start;\n  size_t store_name_len;\n\n  sep = _tcschr(path, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_name_len = sep - path;\n\n  if(_tcsnccmp(path, TEXT(\"CurrentUser\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachine\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE;\n  else if(_tcsnccmp(path, TEXT(\"CurrentService\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_SERVICE;\n  else if(_tcsnccmp(path, TEXT(\"Services\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_SERVICES;\n  else if(_tcsnccmp(path, TEXT(\"Users\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_USERS;\n  else if(_tcsnccmp(path, TEXT(\"CurrentUserGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineEnterprise\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE;\n  else\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_path_start = sep + 1;\n\n  sep = _tcschr(store_path_start, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *thumbprint = sep + 1;\n  if(_tcslen(*thumbprint) != CERT_THUMBPRINT_STR_LEN)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *sep = TEXT('\\0');\n  *store_path = _tcsdup(store_path_start);\n  *sep = TEXT('\\\\');\n  if(!*store_path)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}\n#endif\n\nstatic CURLcode\nschannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ssize_t written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf;\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf;\n  SecBufferDesc inbuf_desc;\n#ifdef HAS_ALPN\n  unsigned char alpn_buffer[128];\n#endif\n  SCHANNEL_CRED schannel_cred;\n  PCCERT_CONTEXT client_certs[1] = { NULL };\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  struct Curl_schannel_cred *old_cred = NULL;\n  struct in_addr addr;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  TCHAR *host_name;\n  CURLcode result;\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 1/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,\n                                  VERSION_LESS_THAN_EQUAL)) {\n    /* Schannel in Windows XP (OS version 5.1) uses legacy handshakes and\n       algorithms that may not be supported by all servers. */\n    infof(data, \"schannel: Windows version is old and may not be able to \"\n          \"connect to some servers due to lack of SNI, algorithms, etc.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.\n     Also it doesn't seem to be supported for Wine, see curl bug #983. */\n  BACKEND->use_alpn = conn->bits.tls_enable_alpn &&\n    !GetProcAddress(GetModuleHandle(TEXT(\"ntdll\")),\n                    \"wine_get_version\") &&\n    curlx_verify_windows_version(6, 3, PLATFORM_WINNT,\n                                 VERSION_GREATER_THAN_EQUAL);\n#else\n  BACKEND->use_alpn = false;\n#endif\n\n#ifdef _WIN32_WCE\n#ifdef HAS_MANUAL_VERIFY_API\n  /* certificate validation on CE doesn't seem to work right; we'll\n   * do it following a more manual process. */\n  BACKEND->use_manual_cred_validation = true;\n#else\n#error \"compiler too old to support requisite manual cert verify for Win CE\"\n#endif\n#else\n#ifdef HAS_MANUAL_VERIFY_API\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    if(curlx_verify_windows_version(6, 1, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL)) {\n      BACKEND->use_manual_cred_validation = true;\n    }\n    else {\n      failf(data, \"schannel: this version of Windows is too old to support \"\n            \"certificate verification via CA bundle file.\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    BACKEND->use_manual_cred_validation = false;\n#else\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    failf(data, \"schannel: CA cert support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n#endif\n\n  BACKEND->cred = NULL;\n\n  /* check for an existing re-usable credential handle */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              (void **)&old_cred, NULL, sockindex)) {\n      BACKEND->cred = old_cred;\n      DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));\n\n      /* increment the reference counter of the credential/session handle */\n      BACKEND->cred->refcount++;\n      DEBUGF(infof(data,\n                   \"schannel: incremented credential handle refcount = %d\\n\",\n                   BACKEND->cred->refcount));\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(!BACKEND->cred) {\n    /* setup Schannel API options */\n    memset(&schannel_cred, 0, sizeof(schannel_cred));\n    schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;\n\n    if(conn->ssl_config.verifypeer) {\n#ifdef HAS_MANUAL_VERIFY_API\n      if(BACKEND->use_manual_cred_validation)\n        schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;\n      else\n#endif\n        schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;\n\n      if(SSL_SET_OPTION(no_revoke)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n\n        DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"\n                     \"checks\\n\"));\n      }\n      else if(SSL_SET_OPTION(revoke_best_effort)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));\n      }\n      else {\n        schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data,\n                     \"schannel: checking server certificate revocation\\n\"));\n      }\n    }\n    else {\n      schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |\n        SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n        SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n      DEBUGF(infof(data,\n                   \"schannel: disabled server cert revocation checks\\n\"));\n    }\n\n    if(!conn->ssl_config.verifyhost) {\n      schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;\n      DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"\n                   \"comparing the supplied target name with the subject \"\n                   \"names in server certificates.\\n\"));\n    }\n\n    if(!SSL_SET_OPTION(auto_client_cert)) {\n      schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;\n      schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;\n      infof(data, \"schannel: disabled automatic use of client certificate\\n\");\n    }\n    else\n      infof(data, \"schannel: enabled automatic use of client certificate\\n\");\n\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n    {\n      result = set_ssl_version_min_max(&schannel_cred, data, conn);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      DWORD cert_store_name = 0;\n      TCHAR *cert_store_path = NULL;\n      TCHAR *cert_thumbprint_str = NULL;\n      CRYPT_HASH_BLOB cert_thumbprint;\n      BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];\n      HCERTSTORE cert_store = NULL;\n      FILE *fInCert = NULL;\n      void *certdata = NULL;\n      size_t certsize = 0;\n      bool blob = data->set.ssl.primary.cert_blob != NULL;\n      TCHAR *cert_path = NULL;\n      if(blob) {\n        certdata = data->set.ssl.primary.cert_blob->data;\n        certsize = data->set.ssl.primary.cert_blob->len;\n      }\n      else {\n        cert_path = curlx_convert_UTF8_to_tchar(\n          data->set.ssl.primary.clientcert);\n        if(!cert_path)\n          return CURLE_OUT_OF_MEMORY;\n\n        result = get_cert_location(cert_path, &cert_store_name,\n          &cert_store_path, &cert_thumbprint_str);\n\n        if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))\n          fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");\n\n        if(result && !fInCert) {\n          failf(data, \"schannel: Failed to get certificate location\"\n                \" or file for %s\",\n                data->set.ssl.primary.clientcert);\n          curlx_unicodefree(cert_path);\n          return result;\n        }\n      }\n\n      if((fInCert || blob) && (data->set.ssl.cert_type) &&\n          (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {\n        failf(data, \"schannel: certificate format compatibility error \"\n                \" for %s\",\n                blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);\n        curlx_unicodefree(cert_path);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n\n      if(fInCert || blob) {\n        /* Reading a .P12 or .pfx file, like the example at bottom of\n             https://social.msdn.microsoft.com/Forums/windowsdesktop/\n                            en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5\n        */\n        CRYPT_DATA_BLOB datablob;\n        WCHAR* pszPassword;\n        size_t pwd_len = 0;\n        int str_w_len = 0;\n        const char *cert_showfilename_error = blob ?\n          \"(memory blob)\" : data->set.ssl.primary.clientcert;\n        curlx_unicodefree(cert_path);\n        if(fInCert) {\n          long cert_tell = 0;\n          bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n          if(continue_reading)\n            cert_tell = ftell(fInCert);\n          if(cert_tell < 0)\n            continue_reading = FALSE;\n          else\n            certsize = (size_t)cert_tell;\n          if(continue_reading)\n            continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n          if(continue_reading)\n            certdata = malloc(certsize + 1);\n          if((!certdata) ||\n             ((int) fread(certdata, certsize, 1, fInCert) != 1))\n            continue_reading = FALSE;\n          fclose(fInCert);\n          if(!continue_reading) {\n            failf(data, \"schannel: Failed to read cert file %s\",\n                data->set.ssl.primary.clientcert);\n            free(certdata);\n            return CURLE_SSL_CERTPROBLEM;\n          }\n        }\n\n        /* Convert key-pair data to the in-memory certificate store */\n        datablob.pbData = (BYTE*)certdata;\n        datablob.cbData = (DWORD)certsize;\n\n        if(data->set.ssl.key_passwd != NULL)\n          pwd_len = strlen(data->set.ssl.key_passwd);\n        pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));\n        if(pszPassword) {\n          if(pwd_len > 0)\n            str_w_len = MultiByteToWideChar(CP_UTF8,\n               MB_ERR_INVALID_CHARS,\n               data->set.ssl.key_passwd, (int)pwd_len,\n               pszPassword, (int)(pwd_len + 1));\n\n          if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))\n            pszPassword[str_w_len] = 0;\n          else\n            pszPassword[0] = 0;\n\n          cert_store = PFXImportCertStore(&datablob, pszPassword, 0);\n          free(pszPassword);\n        }\n        if(!blob)\n          free(certdata);\n        if(!cert_store) {\n          DWORD errorcode = GetLastError();\n          if(errorcode == ERROR_INVALID_PASSWORD)\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"password is bad\",\n                  cert_showfilename_error);\n          else\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"last error is 0x%x\",\n                  cert_showfilename_error, errorcode);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_ANY, NULL, NULL);\n\n        if(!client_certs[0]) {\n          failf(data, \"schannel: Failed to get certificate from file %s\"\n                \", last error is 0x%x\",\n                cert_showfilename_error, GetLastError());\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        schannel_cred.cCreds = 1;\n        schannel_cred.paCred = client_certs;\n      }\n      else {\n        cert_store =\n          CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,\n                        (HCRYPTPROV)NULL,\n                        CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,\n                        cert_store_path);\n        if(!cert_store) {\n          failf(data, \"schannel: Failed to open cert store %x %s, \"\n                \"last error is 0x%x\",\n                cert_store_name, cert_store_path, GetLastError());\n          free(cert_store_path);\n          curlx_unicodefree(cert_path);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n        free(cert_store_path);\n\n        cert_thumbprint.pbData = cert_thumbprint_data;\n        cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;\n\n        if(!CryptStringToBinary(cert_thumbprint_str,\n                                CERT_THUMBPRINT_STR_LEN,\n                                CRYPT_STRING_HEX,\n                                cert_thumbprint_data,\n                                &cert_thumbprint.cbData,\n                                NULL, NULL)) {\n          curlx_unicodefree(cert_path);\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_HASH, &cert_thumbprint, NULL);\n\n        curlx_unicodefree(cert_path);\n\n        if(client_certs[0]) {\n          schannel_cred.cCreds = 1;\n          schannel_cred.paCred = client_certs;\n        }\n        else {\n          /* CRYPT_E_NOT_FOUND / E_INVALIDARG */\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n      }\n      CertCloseStore(cert_store, 0);\n    }\n#else\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      failf(data, \"schannel: client cert support not built in\");\n      return CURLE_NOT_BUILT_IN;\n    }\n#endif\n\n    /* allocate memory for the re-usable credential handle */\n    BACKEND->cred = (struct Curl_schannel_cred *)\n      calloc(1, sizeof(struct Curl_schannel_cred));\n    if(!BACKEND->cred) {\n      failf(data, \"schannel: unable to allocate memory\");\n\n      if(client_certs[0])\n        CertFreeCertificateContext(client_certs[0]);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n    BACKEND->cred->refcount = 1;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374716.aspx\n     */\n    sspi_status =\n      s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,\n                                         SECPKG_CRED_OUTBOUND, NULL,\n                                         &schannel_cred, NULL, NULL,\n                                         &BACKEND->cred->cred_handle,\n                                         &BACKEND->cred->time_stamp);\n\n    if(client_certs[0])\n      CertFreeCertificateContext(client_certs[0]);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      Curl_safefree(BACKEND->cred);\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_NO_CREDENTIALS:\n      case SEC_E_SECPKG_NOT_FOUND:\n      case SEC_E_NOT_OWNER:\n      case SEC_E_UNKNOWN_CREDENTIALS:\n      case SEC_E_INTERNAL_ERROR:\n      default:\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n  /* Warn if SNI is disabled due to use of an IP address */\n  if(Curl_inet_pton(AF_INET, hostname, &addr)\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &addr6)\n#endif\n    ) {\n    infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    int cur = 0;\n    int list_start_index = 0;\n    unsigned int *extension_len = NULL;\n    unsigned short* list_len = NULL;\n\n    /* The first four bytes will be an unsigned int indicating number\n       of bytes of data in the rest of the buffer. */\n    extension_len = (unsigned int *)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned int);\n\n    /* The next four bytes are an indicator that this buffer will contain\n       ALPN data, as opposed to NPN, for example. */\n    *(unsigned int *)&alpn_buffer[cur] =\n      SecApplicationProtocolNegotiationExt_ALPN;\n    cur += sizeof(unsigned int);\n\n    /* The next two bytes will be an unsigned short indicating the number\n       of bytes used to list the preferred protocols. */\n    list_len = (unsigned short*)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned short);\n\n    list_start_index = cur;\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      memcpy(&alpn_buffer[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    alpn_buffer[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&alpn_buffer[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    *list_len = curlx_uitous(cur - list_start_index);\n    *extension_len = *list_len + sizeof(unsigned int) + sizeof(unsigned short);\n\n    InitSecBuffer(&inbuf, SECBUFFER_APPLICATION_PROTOCOLS, alpn_buffer, cur);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n  else {\n    InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n#else /* HAS_ALPN */\n  InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n#endif\n\n  /* setup output buffer */\n  InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n  /* security request flags */\n  BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n    ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY |\n    ISC_REQ_STREAM;\n\n  if(!SSL_SET_OPTION(auto_client_cert)) {\n    BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n  }\n\n  /* allocate memory for the security context handle */\n  BACKEND->ctxt = (struct Curl_schannel_ctxt *)\n    calloc(1, sizeof(struct Curl_schannel_ctxt));\n  if(!BACKEND->ctxt) {\n    failf(data, \"schannel: unable to allocate memory\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  host_name = curlx_convert_UTF8_to_tchar(hostname);\n  if(!host_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Schannel InitializeSecurityContext:\n     https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n\n     At the moment we don't pass inbuf unless we're using ALPN since we only\n     use it for that, and Wine (for which we currently disable ALPN) is giving\n     us problems with inbuf regardless. https://github.com/curl/curl/issues/983\n  */\n  sspi_status = s_pSecFn->InitializeSecurityContext(\n    &BACKEND->cred->cred_handle, NULL, host_name, BACKEND->req_flags, 0, 0,\n    (BACKEND->use_alpn ? &inbuf_desc : NULL),\n    0, &BACKEND->ctxt->ctxt_handle,\n    &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n  curlx_unicodefree(host_name);\n\n  if(sspi_status != SEC_I_CONTINUE_NEEDED) {\n    char buffer[STRERROR_LEN];\n    Curl_safefree(BACKEND->ctxt);\n    switch(sspi_status) {\n    case SEC_E_INSUFFICIENT_MEMORY:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_OUT_OF_MEMORY;\n    case SEC_E_WRONG_PRINCIPAL:\n      failf(data, \"schannel: SNI or certificate check failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_PEER_FAILED_VERIFICATION;\n      /*\n        case SEC_E_INVALID_HANDLE:\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_LOGON_DENIED:\n        case SEC_E_TARGET_UNKNOWN:\n        case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n        case SEC_E_INTERNAL_ERROR:\n        case SEC_E_NO_CREDENTIALS:\n        case SEC_E_UNSUPPORTED_FUNCTION:\n        case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n      */\n    default:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  DEBUGF(infof(data, \"schannel: sending initial handshake data: \"\n               \"sending %lu bytes...\\n\", outbuf.cbBuffer));\n\n  /* send initial handshake data which is now stored in output buffer */\n  result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                            outbuf.cbBuffer, &written);\n  s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n  if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n    failf(data, \"schannel: failed to send initial handshake data: \"\n          \"sent %zd of %lu bytes\", written, outbuf.cbBuffer);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  DEBUGF(infof(data, \"schannel: sent initial handshake data: \"\n               \"sent %zd bytes\\n\", written));\n\n  BACKEND->recv_unrecoverable_err = CURLE_OK;\n  BACKEND->recv_sspi_close_notify = false;\n  BACKEND->recv_connection_closed = false;\n  BACKEND->encdata_is_incomplete = false;\n\n  /* continue to second handshake step */\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  int i;\n  ssize_t nread = -1, written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  SecBuffer outbuf[3];\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf[2];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n  bool doread;\n  char * const hostname = SSL_HOST_NAME();\n  const char *pubkey_ptr;\n\n  doread = (connssl->connecting_state != ssl_connect_2_writing) ? TRUE : FALSE;\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 2/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred || !BACKEND->ctxt)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* buffer to store previously received and decrypted data */\n  if(!BACKEND->decdata_buffer) {\n    BACKEND->decdata_offset = 0;\n    BACKEND->decdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->decdata_buffer = malloc(BACKEND->decdata_length);\n    if(!BACKEND->decdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* buffer to store previously received and encrypted data */\n  if(!BACKEND->encdata_buffer) {\n    BACKEND->encdata_is_incomplete = false;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->encdata_buffer = malloc(BACKEND->encdata_length);\n    if(!BACKEND->encdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* if we need a bigger buffer to read a full message, increase buffer now */\n  if(BACKEND->encdata_length - BACKEND->encdata_offset <\n     CURL_SCHANNEL_BUFFER_FREE_SIZE) {\n    /* increase internal encrypted data buffer */\n    size_t reallocated_length = BACKEND->encdata_offset +\n      CURL_SCHANNEL_BUFFER_FREE_SIZE;\n    reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                 reallocated_length);\n\n    if(!reallocated_buffer) {\n      failf(data, \"schannel: unable to re-allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n    }\n  }\n\n  for(;;) {\n    TCHAR *host_name;\n    if(doread) {\n      /* read encrypted handshake data from socket */\n      result = Curl_read_plain(conn->sock[sockindex],\n                               (char *) (BACKEND->encdata_buffer +\n                                         BACKEND->encdata_offset),\n                               BACKEND->encdata_length -\n                               BACKEND->encdata_offset,\n                               &nread);\n      if(result == CURLE_AGAIN) {\n        if(connssl->connecting_state != ssl_connect_2_writing)\n          connssl->connecting_state = ssl_connect_2_reading;\n        DEBUGF(infof(data, \"schannel: failed to receive handshake, \"\n                     \"need more data\\n\"));\n        return CURLE_OK;\n      }\n      else if((result != CURLE_OK) || (nread == 0)) {\n        failf(data, \"schannel: failed to receive handshake, \"\n              \"SSL/TLS connection failed\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n\n      /* increase encrypted data buffer offset */\n      BACKEND->encdata_offset += nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* setup input buffers */\n    InitSecBuffer(&inbuf[0], SECBUFFER_TOKEN, malloc(BACKEND->encdata_offset),\n                  curlx_uztoul(BACKEND->encdata_offset));\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 2);\n\n    /* setup output buffers */\n    InitSecBuffer(&outbuf[0], SECBUFFER_TOKEN, NULL, 0);\n    InitSecBuffer(&outbuf[1], SECBUFFER_ALERT, NULL, 0);\n    InitSecBuffer(&outbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, outbuf, 3);\n\n    if(!inbuf[0].pvBuffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    /* copy received handshake data into input buffer */\n    memcpy(inbuf[0].pvBuffer, BACKEND->encdata_buffer,\n           BACKEND->encdata_offset);\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n     */\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle, &BACKEND->ctxt->ctxt_handle,\n      host_name, BACKEND->req_flags, 0, 0, &inbuf_desc, 0, NULL,\n      &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    /* free buffer for received handshake data */\n    Curl_safefree(inbuf[0].pvBuffer);\n\n    /* check if the handshake was incomplete */\n    if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      connssl->connecting_state = ssl_connect_2_reading;\n      DEBUGF(infof(data,\n                   \"schannel: received incomplete message, need more data\\n\"));\n      return CURLE_OK;\n    }\n\n    /* If the server has requested a client certificate, attempt to continue\n       the handshake without one. This will allow connections to servers which\n       request a client certificate but do not require it. */\n    if(sspi_status == SEC_I_INCOMPLETE_CREDENTIALS &&\n       !(BACKEND->req_flags & ISC_REQ_USE_SUPPLIED_CREDS)) {\n      BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n      connssl->connecting_state = ssl_connect_2_writing;\n      DEBUGF(infof(data,\n                   \"schannel: a client certificate has been requested\\n\"));\n      return CURLE_OK;\n    }\n\n    /* check if the handshake needs to be continued */\n    if(sspi_status == SEC_I_CONTINUE_NEEDED || sspi_status == SEC_E_OK) {\n      for(i = 0; i < 3; i++) {\n        /* search for handshake tokens that need to be send */\n        if(outbuf[i].BufferType == SECBUFFER_TOKEN && outbuf[i].cbBuffer > 0) {\n          DEBUGF(infof(data, \"schannel: sending next handshake data: \"\n                       \"sending %lu bytes...\\n\", outbuf[i].cbBuffer));\n\n          /* send handshake token to server */\n          result = Curl_write_plain(data, conn->sock[sockindex],\n                                    outbuf[i].pvBuffer, outbuf[i].cbBuffer,\n                                    &written);\n          if((result != CURLE_OK) ||\n             (outbuf[i].cbBuffer != (size_t) written)) {\n            failf(data, \"schannel: failed to send next handshake data: \"\n                  \"sent %zd of %lu bytes\", written, outbuf[i].cbBuffer);\n            return CURLE_SSL_CONNECT_ERROR;\n          }\n        }\n\n        /* free obsolete buffer */\n        if(outbuf[i].pvBuffer != NULL) {\n          s_pSecFn->FreeContextBuffer(outbuf[i].pvBuffer);\n        }\n      }\n    }\n    else {\n      char buffer[STRERROR_LEN];\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_WRONG_PRINCIPAL:\n        failf(data, \"schannel: SNI or certificate check failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case SEC_E_UNTRUSTED_ROOT:\n        failf(data, \"schannel: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n        /*\n          case SEC_E_INVALID_HANDLE:\n          case SEC_E_INVALID_TOKEN:\n          case SEC_E_LOGON_DENIED:\n          case SEC_E_TARGET_UNKNOWN:\n          case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n          case SEC_E_INTERNAL_ERROR:\n          case SEC_E_NO_CREDENTIALS:\n          case SEC_E_UNSUPPORTED_FUNCTION:\n          case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n        */\n      default:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n\n    /* check if there was additional remaining encrypted data */\n    if(inbuf[1].BufferType == SECBUFFER_EXTRA && inbuf[1].cbBuffer > 0) {\n      DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                   inbuf[1].cbBuffer));\n      /*\n        There are two cases where we could be getting extra data here:\n        1) If we're renegotiating a connection and the handshake is already\n        complete (from the server perspective), it can encrypted app data\n        (not handshake data) in an extra buffer at this point.\n        2) (sspi_status == SEC_I_CONTINUE_NEEDED) We are negotiating a\n        connection and this extra data is part of the handshake.\n        We should process the data immediately; waiting for the socket to\n        be ready may fail since the server is done sending handshake data.\n      */\n      /* check if the remaining data is less than the total amount\n         and therefore begins after the already processed data */\n      if(BACKEND->encdata_offset > inbuf[1].cbBuffer) {\n        memmove(BACKEND->encdata_buffer,\n                (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                inbuf[1].cbBuffer, inbuf[1].cbBuffer);\n        BACKEND->encdata_offset = inbuf[1].cbBuffer;\n        if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n          doread = FALSE;\n          continue;\n        }\n      }\n    }\n    else {\n      BACKEND->encdata_offset = 0;\n    }\n    break;\n  }\n\n  /* check if the handshake needs to be continued */\n  if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n\n  /* check if the handshake is complete */\n  if(sspi_status == SEC_E_OK) {\n    connssl->connecting_state = ssl_connect_3;\n    DEBUGF(infof(data, \"schannel: SSL/TLS handshake complete\\n\"));\n  }\n\n  pubkey_ptr = SSL_PINNED_PUB_KEY();\n  if(pubkey_ptr) {\n    result = pkp_pin_peer_pubkey(data, conn, sockindex, pubkey_ptr);\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n  }\n\n#ifdef HAS_MANUAL_VERIFY_API\n  if(conn->ssl_config.verifypeer && BACKEND->use_manual_cred_validation) {\n    return Curl_verify_certificate(data, conn, sockindex);\n  }\n#endif\n\n  return CURLE_OK;\n}\n\nstatic bool\nvalid_cert_encoding(const CERT_CONTEXT *cert_context)\n{\n  return (cert_context != NULL) &&\n    ((cert_context->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n    (cert_context->pbCertEncoded != NULL) &&\n    (cert_context->cbCertEncoded > 0);\n}\n\ntypedef bool(*Read_crt_func)(const CERT_CONTEXT *ccert_context, void *arg);\n\nstatic void\ntraverse_cert_store(const CERT_CONTEXT *context, Read_crt_func func,\n                    void *arg)\n{\n  const CERT_CONTEXT *current_context = NULL;\n  bool should_continue = true;\n  while(should_continue &&\n        (current_context = CertEnumCertificatesInStore(\n          context->hCertStore,\n          current_context)) != NULL)\n    should_continue = func(current_context, arg);\n\n  if(current_context)\n    CertFreeCertificateContext(current_context);\n}\n\nstatic bool\ncert_counter_callback(const CERT_CONTEXT *ccert_context, void *certs_count)\n{\n  if(valid_cert_encoding(ccert_context))\n    (*(int *)certs_count)++;\n  return true;\n}\n\nstruct Adder_args\n{\n  struct Curl_easy *data;\n  CURLcode result;\n  int idx;\n  int certs_count;\n};\n\nstatic bool\nadd_cert_to_certinfo(const CERT_CONTEXT *ccert_context, void *raw_arg)\n{\n  struct Adder_args *args = (struct Adder_args*)raw_arg;\n  args->result = CURLE_OK;\n  if(valid_cert_encoding(ccert_context)) {\n    const char *beg = (const char *) ccert_context->pbCertEncoded;\n    const char *end = beg + ccert_context->cbCertEncoded;\n    int insert_index = (args->certs_count - 1) - args->idx;\n    args->result = Curl_extract_certinfo(args->data, insert_index,\n                                         beg, end);\n    args->idx++;\n  }\n  return args->result == CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CERT_CONTEXT *ccert_context = NULL;\n  bool isproxy = SSL_IS_PROXY();\n#ifdef DEBUGBUILD\n  const char * const hostname = SSL_HOST_NAME();\n#endif\n#ifdef HAS_ALPN\n  SecPkgContext_ApplicationProtocol alpn_result;\n#endif\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 3/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* check if the required context attributes are met */\n  if(BACKEND->ret_flags != BACKEND->req_flags) {\n    if(!(BACKEND->ret_flags & ISC_RET_SEQUENCE_DETECT))\n      failf(data, \"schannel: failed to setup sequence detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_REPLAY_DETECT))\n      failf(data, \"schannel: failed to setup replay detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_CONFIDENTIALITY))\n      failf(data, \"schannel: failed to setup confidentiality\");\n    if(!(BACKEND->ret_flags & ISC_RET_ALLOCATED_MEMORY))\n      failf(data, \"schannel: failed to setup memory allocation\");\n    if(!(BACKEND->ret_flags & ISC_RET_STREAM))\n      failf(data, \"schannel: failed to setup stream orientation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_APPLICATION_PROTOCOL,\n                                       &alpn_result);\n\n    if(sspi_status != SEC_E_OK) {\n      failf(data, \"schannel: failed to retrieve ALPN result\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(alpn_result.ProtoNegoStatus ==\n       SecApplicationProtocolNegotiationStatus_Success) {\n\n      infof(data, \"schannel: ALPN, server accepted to use %.*s\\n\",\n            alpn_result.ProtocolIdSize, alpn_result.ProtocolId);\n\n#ifdef USE_HTTP2\n      if(alpn_result.ProtocolIdSize == ALPN_H2_LENGTH &&\n         !memcmp(ALPN_H2, alpn_result.ProtocolId, ALPN_H2_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n        if(alpn_result.ProtocolIdSize == ALPN_HTTP_1_1_LENGTH &&\n           !memcmp(ALPN_HTTP_1_1, alpn_result.ProtocolId,\n                   ALPN_HTTP_1_1_LENGTH)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n    }\n    else\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n#endif\n\n  /* save the current session data for possible re-use */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    struct Curl_schannel_cred *old_cred = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy, (void **)&old_cred,\n                                      NULL, sockindex));\n    if(incache) {\n      if(old_cred != BACKEND->cred) {\n        DEBUGF(infof(data,\n                     \"schannel: old credential handle is stale, removing\\n\"));\n        /* we're not taking old_cred ownership here, no refcount++ is needed */\n        Curl_ssl_delsessionid(data, (void *)old_cred);\n        incache = FALSE;\n      }\n    }\n    if(!incache) {\n      result = Curl_ssl_addsessionid(data, conn, isproxy, BACKEND->cred,\n                                     sizeof(struct Curl_schannel_cred),\n                                     sockindex);\n      if(result) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"schannel: failed to store credential handle\");\n        return result;\n      }\n      else {\n        /* this cred session is now also referenced by sessionid cache */\n        BACKEND->cred->refcount++;\n        DEBUGF(infof(data,\n                     \"schannel: stored credential handle in session cache\\n\"));\n      }\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(data->set.ssl.certinfo) {\n    int certs_count = 0;\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &ccert_context);\n\n    if((sspi_status != SEC_E_OK) || !ccert_context) {\n      failf(data, \"schannel: failed to retrieve remote cert context\");\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n\n    traverse_cert_store(ccert_context, cert_counter_callback, &certs_count);\n\n    result = Curl_ssl_init_certinfo(data, certs_count);\n    if(!result) {\n      struct Adder_args args;\n      args.data = data;\n      args.idx = 0;\n      args.certs_count = certs_count;\n      traverse_cert_store(ccert_context, add_cert_to_certinfo, &args);\n      result = args.result;\n    }\n    CertFreeCertificateContext(ccert_context);\n    if(result)\n      return result;\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_common(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex, bool nonblocking, bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = schannel_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL/TLS socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL/TLS connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = schannel_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = schannel_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = schannel_recv;\n    conn->send[sockindex] = schannel_send;\n\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n    /* When SSPI is used in combination with Schannel\n     * we need the Schannel context to create the Schannel\n     * binding to pass the IIS extended protection checks.\n     * Available on Windows 7 or later.\n     */\n    conn->sslContext = &BACKEND->ctxt->ctxt_handle;\n#endif\n\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* reset our connection state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t\nschannel_send(struct Curl_easy *data, int sockindex,\n              const void *buf, size_t len, CURLcode *err)\n{\n  ssize_t written = -1;\n  size_t data_len = 0;\n  unsigned char *ptr = NULL;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf[4];\n  SecBufferDesc outbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n\n  /* check if the maximum stream sizes were queried */\n  if(BACKEND->stream_sizes.cbMaximumMessage == 0) {\n    sspi_status = s_pSecFn->QueryContextAttributes(\n      &BACKEND->ctxt->ctxt_handle,\n      SECPKG_ATTR_STREAM_SIZES,\n      &BACKEND->stream_sizes);\n    if(sspi_status != SEC_E_OK) {\n      *err = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n\n  /* check if the buffer is longer than the maximum message length */\n  if(len > BACKEND->stream_sizes.cbMaximumMessage) {\n    len = BACKEND->stream_sizes.cbMaximumMessage;\n  }\n\n  /* calculate the complete message length and allocate a buffer for it */\n  data_len = BACKEND->stream_sizes.cbHeader + len +\n    BACKEND->stream_sizes.cbTrailer;\n  ptr = (unsigned char *) malloc(data_len);\n  if(!ptr) {\n    *err = CURLE_OUT_OF_MEMORY;\n    return -1;\n  }\n\n  /* setup output buffers (header, data, trailer, empty) */\n  InitSecBuffer(&outbuf[0], SECBUFFER_STREAM_HEADER,\n                ptr, BACKEND->stream_sizes.cbHeader);\n  InitSecBuffer(&outbuf[1], SECBUFFER_DATA,\n                ptr + BACKEND->stream_sizes.cbHeader, curlx_uztoul(len));\n  InitSecBuffer(&outbuf[2], SECBUFFER_STREAM_TRAILER,\n                ptr + BACKEND->stream_sizes.cbHeader + len,\n                BACKEND->stream_sizes.cbTrailer);\n  InitSecBuffer(&outbuf[3], SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, outbuf, 4);\n\n  /* copy data into output buffer */\n  memcpy(outbuf[1].pvBuffer, buf, len);\n\n  /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375390.aspx */\n  sspi_status = s_pSecFn->EncryptMessage(&BACKEND->ctxt->ctxt_handle, 0,\n                                         &outbuf_desc, 0);\n\n  /* check if the message was encrypted */\n  if(sspi_status == SEC_E_OK) {\n    written = 0;\n\n    /* send the encrypted message including header, data and trailer */\n    len = outbuf[0].cbBuffer + outbuf[1].cbBuffer + outbuf[2].cbBuffer;\n\n    /*\n      It's important to send the full message which includes the header,\n      encrypted payload, and trailer.  Until the client receives all the\n      data a coherent message has not been delivered and the client\n      can't read any of it.\n\n      If we wanted to buffer the unwritten encrypted bytes, we would\n      tell the client that all data it has requested to be sent has been\n      sent. The unwritten encrypted bytes would be the first bytes to\n      send on the next invocation.\n      Here's the catch with this - if we tell the client that all the\n      bytes have been sent, will the client call this method again to\n      send the buffered data?  Looking at who calls this function, it\n      seems the answer is NO.\n    */\n\n    /* send entire message or fail */\n    while(len > (size_t)written) {\n      ssize_t this_write = 0;\n      int what;\n      timediff_t timeout_ms = Curl_timeleft(data, NULL, FALSE);\n      if(timeout_ms < 0) {\n        /* we already got the timeout */\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      else if(!timeout_ms)\n        timeout_ms = TIMEDIFF_T_MAX;\n      what = SOCKET_WRITABLE(conn->sock[sockindex], timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        *err = CURLE_SEND_ERROR;\n        written = -1;\n        break;\n      }\n      else if(0 == what) {\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      /* socket is writable */\n\n      result = Curl_write_plain(data, conn->sock[sockindex], ptr + written,\n                                len - written, &this_write);\n      if(result == CURLE_AGAIN)\n        continue;\n      else if(result != CURLE_OK) {\n        *err = result;\n        written = -1;\n        break;\n      }\n\n      written += this_write;\n    }\n  }\n  else if(sspi_status == SEC_E_INSUFFICIENT_MEMORY) {\n    *err = CURLE_OUT_OF_MEMORY;\n  }\n  else{\n    *err = CURLE_SEND_ERROR;\n  }\n\n  Curl_safefree(ptr);\n\n  if(len == (size_t)written)\n    /* Encrypted message including header, data and trailer entirely sent.\n       The return value is the number of unencrypted bytes that were sent. */\n    written = outbuf[1].cbBuffer;\n\n  return written;\n}\n\nstatic ssize_t\nschannel_recv(struct Curl_easy *data, int sockindex,\n              char *buf, size_t len, CURLcode *err)\n{\n  size_t size = 0;\n  ssize_t nread = -1;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  size_t reallocated_length;\n  bool done = FALSE;\n  SecBuffer inbuf[4];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  /* we want the length of the encrypted buffer to be at least large enough\n     that it can hold all the bytes requested and some TLS record overhead. */\n  size_t min_encdata_length = len + CURL_SCHANNEL_BUFFER_FREE_SIZE;\n\n  /****************************************************************************\n   * Don't return or set BACKEND->recv_unrecoverable_err unless in the cleanup.\n   * The pattern for return error is set *err, optional infof, goto cleanup.\n   *\n   * Our priority is to always return as much decrypted data to the caller as\n   * possible, even if an error occurs. The state of the decrypted buffer must\n   * always be valid. Transfer of decrypted data to the caller's buffer is\n   * handled in the cleanup.\n   */\n\n  DEBUGF(infof(data, \"schannel: client wants to read %zu bytes\\n\", len));\n  *err = CURLE_OK;\n\n  if(len && len <= BACKEND->decdata_offset) {\n    infof(data, \"schannel: enough decrypted data is already available\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_unrecoverable_err) {\n    *err = BACKEND->recv_unrecoverable_err;\n    infof(data, \"schannel: an unrecoverable error occurred in a prior call\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_sspi_close_notify) {\n    /* once a server has indicated shutdown there is no more encrypted data */\n    infof(data, \"schannel: server indicated shutdown in a prior call\\n\");\n    goto cleanup;\n  }\n\n  /* It's debatable what to return when !len. Regardless we can't return\n     immediately because there may be data to decrypt (in the case we want to\n     decrypt all encrypted cached data) so handle !len later in cleanup.\n  */\n  else if(len && !BACKEND->recv_connection_closed) {\n    /* increase enc buffer in order to fit the requested amount of data */\n    size = BACKEND->encdata_length - BACKEND->encdata_offset;\n    if(size < CURL_SCHANNEL_BUFFER_FREE_SIZE ||\n       BACKEND->encdata_length < min_encdata_length) {\n      reallocated_length = BACKEND->encdata_offset +\n        CURL_SCHANNEL_BUFFER_FREE_SIZE;\n      if(reallocated_length < min_encdata_length) {\n        reallocated_length = min_encdata_length;\n      }\n      reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                   reallocated_length);\n      if(!reallocated_buffer) {\n        *err = CURLE_OUT_OF_MEMORY;\n        failf(data, \"schannel: unable to re-allocate memory\");\n        goto cleanup;\n      }\n\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n      size = BACKEND->encdata_length - BACKEND->encdata_offset;\n      DEBUGF(infof(data, \"schannel: encdata_buffer resized %zu\\n\",\n                   BACKEND->encdata_length));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* read encrypted data from socket */\n    *err = Curl_read_plain(conn->sock[sockindex],\n                           (char *)(BACKEND->encdata_buffer +\n                                    BACKEND->encdata_offset),\n                           size, &nread);\n    if(*err) {\n      nread = -1;\n      if(*err == CURLE_AGAIN)\n        DEBUGF(infof(data,\n                     \"schannel: Curl_read_plain returned CURLE_AGAIN\\n\"));\n      else if(*err == CURLE_RECV_ERROR)\n        infof(data, \"schannel: Curl_read_plain returned CURLE_RECV_ERROR\\n\");\n      else\n        infof(data, \"schannel: Curl_read_plain returned error %d\\n\", *err);\n    }\n    else if(nread == 0) {\n      BACKEND->recv_connection_closed = true;\n      DEBUGF(infof(data, \"schannel: server closed the connection\\n\"));\n    }\n    else if(nread > 0) {\n      BACKEND->encdata_offset += (size_t)nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  /* decrypt loop */\n  while(BACKEND->encdata_offset > 0 && sspi_status == SEC_E_OK &&\n        (!len || BACKEND->decdata_offset < len ||\n         BACKEND->recv_connection_closed)) {\n    /* prepare data buffer for DecryptMessage call */\n    InitSecBuffer(&inbuf[0], SECBUFFER_DATA, BACKEND->encdata_buffer,\n                  curlx_uztoul(BACKEND->encdata_offset));\n\n    /* we need 3 more empty input buffers for possible output */\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[3], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 4);\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375348.aspx\n     */\n    sspi_status = s_pSecFn->DecryptMessage(&BACKEND->ctxt->ctxt_handle,\n                                           &inbuf_desc, 0, NULL);\n\n    /* check if everything went fine (server may want to renegotiate\n       or shutdown the connection context) */\n    if(sspi_status == SEC_E_OK || sspi_status == SEC_I_RENEGOTIATE ||\n       sspi_status == SEC_I_CONTEXT_EXPIRED) {\n      /* check for successfully decrypted data, even before actual\n         renegotiation or shutdown of the connection context */\n      if(inbuf[1].BufferType == SECBUFFER_DATA) {\n        DEBUGF(infof(data, \"schannel: decrypted data length: %lu\\n\",\n                     inbuf[1].cbBuffer));\n\n        /* increase buffer in order to fit the received amount of data */\n        size = inbuf[1].cbBuffer > CURL_SCHANNEL_BUFFER_FREE_SIZE ?\n          inbuf[1].cbBuffer : CURL_SCHANNEL_BUFFER_FREE_SIZE;\n        if(BACKEND->decdata_length - BACKEND->decdata_offset < size ||\n           BACKEND->decdata_length < len) {\n          /* increase internal decrypted data buffer */\n          reallocated_length = BACKEND->decdata_offset + size;\n          /* make sure that the requested amount of data fits */\n          if(reallocated_length < len) {\n            reallocated_length = len;\n          }\n          reallocated_buffer = realloc(BACKEND->decdata_buffer,\n                                       reallocated_length);\n          if(!reallocated_buffer) {\n            *err = CURLE_OUT_OF_MEMORY;\n            failf(data, \"schannel: unable to re-allocate memory\");\n            goto cleanup;\n          }\n          BACKEND->decdata_buffer = reallocated_buffer;\n          BACKEND->decdata_length = reallocated_length;\n        }\n\n        /* copy decrypted data to internal buffer */\n        size = inbuf[1].cbBuffer;\n        if(size) {\n          memcpy(BACKEND->decdata_buffer + BACKEND->decdata_offset,\n                 inbuf[1].pvBuffer, size);\n          BACKEND->decdata_offset += size;\n        }\n\n        DEBUGF(infof(data, \"schannel: decrypted data added: %zu\\n\", size));\n        DEBUGF(infof(data,\n                     \"schannel: decrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->decdata_offset, BACKEND->decdata_length));\n      }\n\n      /* check for remaining encrypted data */\n      if(inbuf[3].BufferType == SECBUFFER_EXTRA && inbuf[3].cbBuffer > 0) {\n        DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                     inbuf[3].cbBuffer));\n\n        /* check if the remaining data is less than the total amount\n         * and therefore begins after the already processed data\n         */\n        if(BACKEND->encdata_offset > inbuf[3].cbBuffer) {\n          /* move remaining encrypted data forward to the beginning of\n             buffer */\n          memmove(BACKEND->encdata_buffer,\n                  (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                  inbuf[3].cbBuffer, inbuf[3].cbBuffer);\n          BACKEND->encdata_offset = inbuf[3].cbBuffer;\n        }\n\n        DEBUGF(infof(data,\n                     \"schannel: encrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->encdata_offset, BACKEND->encdata_length));\n      }\n      else {\n        /* reset encrypted buffer offset, because there is no data remaining */\n        BACKEND->encdata_offset = 0;\n      }\n\n      /* check if server wants to renegotiate the connection context */\n      if(sspi_status == SEC_I_RENEGOTIATE) {\n        infof(data, \"schannel: remote party requests renegotiation\\n\");\n        if(*err && *err != CURLE_AGAIN) {\n          infof(data, \"schannel: can't renogotiate, an error is pending\\n\");\n          goto cleanup;\n        }\n        if(BACKEND->encdata_offset) {\n          *err = CURLE_RECV_ERROR;\n          infof(data, \"schannel: can't renogotiate, \"\n                \"encrypted data available\\n\");\n          goto cleanup;\n        }\n        /* begin renegotiation */\n        infof(data, \"schannel: renegotiating SSL/TLS connection\\n\");\n        connssl->state = ssl_connection_negotiating;\n        connssl->connecting_state = ssl_connect_2_writing;\n        *err = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n        if(*err) {\n          infof(data, \"schannel: renegotiation failed\\n\");\n          goto cleanup;\n        }\n        /* now retry receiving data */\n        sspi_status = SEC_E_OK;\n        infof(data, \"schannel: SSL/TLS connection renegotiated\\n\");\n        continue;\n      }\n      /* check if the server closed the connection */\n      else if(sspi_status == SEC_I_CONTEXT_EXPIRED) {\n        /* In Windows 2000 SEC_I_CONTEXT_EXPIRED (close_notify) is not\n           returned so we have to work around that in cleanup. */\n        BACKEND->recv_sspi_close_notify = true;\n        if(!BACKEND->recv_connection_closed) {\n          BACKEND->recv_connection_closed = true;\n          infof(data, \"schannel: server closed the connection\\n\");\n        }\n        goto cleanup;\n      }\n    }\n    else if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      if(!*err)\n        *err = CURLE_AGAIN;\n      infof(data, \"schannel: failed to decrypt data, need more data\\n\");\n      goto cleanup;\n    }\n    else {\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n      char buffer[STRERROR_LEN];\n#endif\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: failed to read data from server: %s\\n\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      goto cleanup;\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  DEBUGF(infof(data,\n               \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->decdata_offset, BACKEND->decdata_length));\n\n  cleanup:\n  /* Warning- there is no guarantee the encdata state is valid at this point */\n  DEBUGF(infof(data, \"schannel: schannel_recv cleanup\\n\"));\n\n  /* Error if the connection has closed without a close_notify.\n\n     The behavior here is a matter of debate. We don't want to be vulnerable\n     to a truncation attack however there's some browser precedent for\n     ignoring the close_notify for compatibility reasons.\n\n     Additionally, Windows 2000 (v5.0) is a special case since it seems it\n     doesn't return close_notify. In that case if the connection was closed we\n     assume it was graceful (close_notify) since there doesn't seem to be a\n     way to tell.\n  */\n  if(len && !BACKEND->decdata_offset && BACKEND->recv_connection_closed &&\n     !BACKEND->recv_sspi_close_notify) {\n    bool isWin2k = curlx_verify_windows_version(5, 0, PLATFORM_WINNT,\n                                                VERSION_EQUAL);\n\n    if(isWin2k && sspi_status == SEC_E_OK)\n      BACKEND->recv_sspi_close_notify = true;\n    else {\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: server closed abruptly (missing close_notify)\\n\");\n    }\n  }\n\n  /* Any error other than CURLE_AGAIN is an unrecoverable error. */\n  if(*err && *err != CURLE_AGAIN)\n    BACKEND->recv_unrecoverable_err = *err;\n\n  size = len < BACKEND->decdata_offset ? len : BACKEND->decdata_offset;\n  if(size) {\n    memcpy(buf, BACKEND->decdata_buffer, size);\n    memmove(BACKEND->decdata_buffer, BACKEND->decdata_buffer + size,\n            BACKEND->decdata_offset - size);\n    BACKEND->decdata_offset -= size;\n    DEBUGF(infof(data, \"schannel: decrypted data returned %zu\\n\", size));\n    DEBUGF(infof(data,\n                 \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->decdata_offset, BACKEND->decdata_length));\n    *err = CURLE_OK;\n    return (ssize_t)size;\n  }\n\n  if(!*err && !BACKEND->recv_connection_closed)\n    *err = CURLE_AGAIN;\n\n  /* It's debatable what to return when !len. We could return whatever error\n     we got from decryption but instead we override here so the return is\n     consistent.\n  */\n  if(!len)\n    *err = CURLE_OK;\n\n  return *err ? -1 : 0;\n}\n\nstatic CURLcode schannel_connect_nonblocking(struct Curl_easy *data,\n                                             struct connectdata *conn,\n                                             int sockindex, bool *done)\n{\n  return schannel_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode schannel_connect(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool schannel_data_pending(const struct connectdata *conn,\n                                  int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  if(connssl->use) /* SSL/TLS is in use */\n    return (BACKEND->decdata_offset > 0 ||\n            (BACKEND->encdata_offset > 0 && !BACKEND->encdata_is_incomplete));\n  else\n    return FALSE;\n}\n\nstatic void schannel_close(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(conn->ssl[sockindex].use)\n    /* if the SSL/TLS channel hasn't been shut down yet, do that now. */\n    Curl_ssl_shutdown(data, conn, sockindex);\n}\n\nstatic void schannel_session_free(void *ptr)\n{\n  /* this is expected to be called under sessionid lock */\n  struct Curl_schannel_cred *cred = ptr;\n\n  cred->refcount--;\n  if(cred->refcount == 0) {\n    s_pSecFn->FreeCredentialsHandle(&cred->cred_handle);\n    Curl_safefree(cred);\n  }\n}\n\nstatic int schannel_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  /* See https://msdn.microsoft.com/en-us/library/windows/desktop/aa380138.aspx\n   * Shutting Down an Schannel Connection\n   */\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGASSERT(data);\n\n  infof(data, \"schannel: shutting down SSL/TLS connection with %s port %hu\\n\",\n        hostname, conn->remote_port);\n\n  if(BACKEND->cred && BACKEND->ctxt) {\n    SecBufferDesc BuffDesc;\n    SecBuffer Buffer;\n    SECURITY_STATUS sspi_status;\n    SecBuffer outbuf;\n    SecBufferDesc outbuf_desc;\n    CURLcode result;\n    TCHAR *host_name;\n    DWORD dwshut = SCHANNEL_SHUTDOWN;\n\n    InitSecBuffer(&Buffer, SECBUFFER_TOKEN, &dwshut, sizeof(dwshut));\n    InitSecBufferDesc(&BuffDesc, &Buffer, 1);\n\n    sspi_status = s_pSecFn->ApplyControlToken(&BACKEND->ctxt->ctxt_handle,\n                                              &BuffDesc);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: ApplyControlToken failure: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n    }\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* setup output buffer */\n    InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle,\n      &BACKEND->ctxt->ctxt_handle,\n      host_name,\n      BACKEND->req_flags,\n      0,\n      0,\n      NULL,\n      0,\n      &BACKEND->ctxt->ctxt_handle,\n      &outbuf_desc,\n      &BACKEND->ret_flags,\n      &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    if((sspi_status == SEC_E_OK) || (sspi_status == SEC_I_CONTEXT_EXPIRED)) {\n      /* send close message which is in output buffer */\n      ssize_t written;\n      result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                                outbuf.cbBuffer, &written);\n\n      s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n      if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n        infof(data, \"schannel: failed to send close msg: %s\"\n              \" (bytes written: %zd)\\n\", curl_easy_strerror(result), written);\n      }\n    }\n  }\n\n  /* free SSPI Schannel API security context handle */\n  if(BACKEND->ctxt) {\n    DEBUGF(infof(data, \"schannel: clear security context handle\\n\"));\n    s_pSecFn->DeleteSecurityContext(&BACKEND->ctxt->ctxt_handle);\n    Curl_safefree(BACKEND->ctxt);\n  }\n\n  /* free SSPI Schannel API credential handle */\n  if(BACKEND->cred) {\n    Curl_ssl_sessionid_lock(data);\n    schannel_session_free(BACKEND->cred);\n    Curl_ssl_sessionid_unlock(data);\n    BACKEND->cred = NULL;\n  }\n\n  /* free internal buffer for received encrypted data */\n  if(BACKEND->encdata_buffer != NULL) {\n    Curl_safefree(BACKEND->encdata_buffer);\n    BACKEND->encdata_length = 0;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_is_incomplete = false;\n  }\n\n  /* free internal buffer for received decrypted data */\n  if(BACKEND->decdata_buffer != NULL) {\n    Curl_safefree(BACKEND->decdata_buffer);\n    BACKEND->decdata_length = 0;\n    BACKEND->decdata_offset = 0;\n  }\n\n  return CURLE_OK;\n}\n\nstatic int schannel_init(void)\n{\n  return (Curl_sspi_global_init() == CURLE_OK ? 1 : 0);\n}\n\nstatic void schannel_cleanup(void)\n{\n  Curl_sspi_global_cleanup();\n}\n\nstatic size_t schannel_version(char *buffer, size_t size)\n{\n  size = msnprintf(buffer, size, \"Schannel\");\n\n  return size;\n}\n\nstatic CURLcode schannel_random(struct Curl_easy *data UNUSED_PARAM,\n                                unsigned char *entropy, size_t length)\n{\n  HCRYPTPROV hCryptProv = 0;\n\n  (void)data;\n\n  if(!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return CURLE_FAILED_INIT;\n\n  if(!CryptGenRandom(hCryptProv, (DWORD)length, entropy)) {\n    CryptReleaseContext(hCryptProv, 0UL);\n    return CURLE_FAILED_INIT;\n  }\n\n  CryptReleaseContext(hCryptProv, 0UL);\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  CERT_CONTEXT *pCertContextServer = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  do {\n    SECURITY_STATUS sspi_status;\n    const char *x509_der;\n    DWORD x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &pCertContextServer);\n\n    if((sspi_status != SEC_E_OK) || !pCertContextServer) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: Failed to read remote certificate context: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      break; /* failed */\n    }\n\n\n    if(!(((pCertContextServer->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n         (pCertContextServer->cbCertEncoded > 0)))\n      break;\n\n    x509_der = (const char *)pCertContextServer->pbCertEncoded;\n    x509_der_len = pCertContextServer->cbCertEncoded;\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      break;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      break;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n    }\n  } while(0);\n\n  if(pCertContextServer)\n    CertFreeCertificateContext(pCertContextServer);\n\n  return result;\n}\n\nstatic void schannel_checksum(const unsigned char *input,\n                              size_t inputlen,\n                              unsigned char *checksum,\n                              size_t checksumlen,\n                              DWORD provType,\n                              const unsigned int algId)\n{\n  HCRYPTPROV hProv = 0;\n  HCRYPTHASH hHash = 0;\n  DWORD cbHashSize = 0;\n  DWORD dwHashSizeLen = (DWORD)sizeof(cbHashSize);\n  DWORD dwChecksumLen = (DWORD)checksumlen;\n\n  /* since this can fail in multiple ways, zero memory first so we never\n   * return old data\n   */\n  memset(checksum, 0, checksumlen);\n\n  if(!CryptAcquireContext(&hProv, NULL, NULL, provType,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return; /* failed */\n\n  do {\n    if(!CryptCreateHash(hProv, algId, 0, 0, &hHash))\n      break; /* failed */\n\n    /* workaround for original MinGW, should be (const BYTE*) */\n    if(!CryptHashData(hHash, (BYTE*)input, (DWORD)inputlen, 0))\n      break; /* failed */\n\n    /* get hash size */\n    if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&cbHashSize,\n                          &dwHashSizeLen, 0))\n      break; /* failed */\n\n    /* check hash size */\n    if(checksumlen < cbHashSize)\n      break; /* failed */\n\n    if(CryptGetHashParam(hHash, HP_HASHVAL, checksum, &dwChecksumLen, 0))\n      break; /* failed */\n  } while(0);\n\n  if(hHash)\n    CryptDestroyHash(hHash);\n\n  if(hProv)\n    CryptReleaseContext(hProv, 0);\n}\n\nstatic CURLcode schannel_sha256sum(const unsigned char *input,\n                                   size_t inputlen,\n                                   unsigned char *sha256sum,\n                                   size_t sha256len)\n{\n  schannel_checksum(input, inputlen, sha256sum, sha256len,\n                    PROV_RSA_AES, CALG_SHA_256);\n  return CURLE_OK;\n}\n\nstatic void *schannel_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return &BACKEND->ctxt->ctxt_handle;\n}\n\nconst struct Curl_ssl Curl_ssl_schannel = {\n  { CURLSSLBACKEND_SCHANNEL, \"schannel\" }, /* info */\n\n  SSLSUPP_CERTINFO |\n#ifdef HAS_MANUAL_VERIFY_API\n  SSLSUPP_CAINFO_BLOB |\n#endif\n  SSLSUPP_PINNEDPUBKEY,\n\n  sizeof(struct ssl_backend_data),\n\n  schannel_init,                     /* init */\n  schannel_cleanup,                  /* cleanup */\n  schannel_version,                  /* version */\n  Curl_none_check_cxn,               /* check_cxn */\n  schannel_shutdown,                 /* shutdown */\n  schannel_data_pending,             /* data_pending */\n  schannel_random,                   /* random */\n  Curl_none_cert_status_request,     /* cert_status_request */\n  schannel_connect,                  /* connect */\n  schannel_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                  /* getsock */\n  schannel_get_internals,            /* get_internals */\n  schannel_close,                    /* close_one */\n  Curl_none_close_all,               /* close_all */\n  schannel_session_free,             /* session_free */\n  Curl_none_set_engine,              /* set_engine */\n  Curl_none_set_engine_default,      /* set_engine_default */\n  Curl_none_engines_list,            /* engines_list */\n  Curl_none_false_start,             /* false_start */\n  schannel_sha256sum                 /* sha256sum */\n};\n\n#endif /* USE_SCHANNEL */\n", "#ifndef HEADER_CURL_SCHANNEL_H\n#define HEADER_CURL_SCHANNEL_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012, Marc Hoersken, <info@marc-hoersken.de>, et al.\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#ifdef USE_SCHANNEL\n\n#include <schnlsp.h>\n#include <schannel.h>\n#include \"curl_sspi.h\"\n\n#include \"urldata.h\"\n\n/* <wincrypt.h> has been included via the above <schnlsp.h>.\n * Or in case of ldap.c, it was included via <winldap.h>.\n * And since <wincrypt.h> has this:\n *   #define X509_NAME  ((LPCSTR) 7)\n *\n * And in BoringSSL's <openssl/base.h> there is:\n *  typedef struct X509_name_st X509_NAME;\n *  etc.\n *\n * this will cause all kinds of C-preprocessing paste errors in\n * BoringSSL's <openssl/x509.h>: So just undefine those defines here\n * (and only here).\n */\n#if defined(HAVE_BORINGSSL) || defined(OPENSSL_IS_BORINGSSL)\n# undef X509_NAME\n# undef X509_CERT_PAIR\n# undef X509_EXTENSIONS\n#endif\n\nextern const struct Curl_ssl Curl_ssl_schannel;\n\nCURLcode Curl_verify_certificate(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex);\n\n/* structs to expose only in schannel.c and schannel_verify.c */\n#ifdef EXPOSE_SCHANNEL_INTERNAL_STRUCTS\n\n#ifdef __MINGW32__\n#include <_mingw.h>\n#ifdef __MINGW64_VERSION_MAJOR\n#define HAS_MANUAL_VERIFY_API\n#endif\n#else\n#include <wincrypt.h>\n#ifdef CERT_CHAIN_REVOCATION_CHECK_CHAIN\n#define HAS_MANUAL_VERIFY_API\n#endif\n#endif\n\n#define NUMOF_CIPHERS 45 /* There are 45 listed in the MS headers */\n\nstruct Curl_schannel_cred {\n  CredHandle cred_handle;\n  TimeStamp time_stamp;\n  int refcount;\n};\n\nstruct Curl_schannel_ctxt {\n  CtxtHandle ctxt_handle;\n  TimeStamp time_stamp;\n};\n\nstruct ssl_backend_data {\n  struct Curl_schannel_cred *cred;\n  struct Curl_schannel_ctxt *ctxt;\n  SecPkgContext_StreamSizes stream_sizes;\n  size_t encdata_length, decdata_length;\n  size_t encdata_offset, decdata_offset;\n  unsigned char *encdata_buffer, *decdata_buffer;\n  /* encdata_is_incomplete: if encdata contains only a partial record that\n     can't be decrypted without another Curl_read_plain (that is, status is\n     SEC_E_INCOMPLETE_MESSAGE) then set this true. after Curl_read_plain writes\n     more bytes into encdata then set this back to false. */\n  bool encdata_is_incomplete;\n  unsigned long req_flags, ret_flags;\n  CURLcode recv_unrecoverable_err; /* schannel_recv had an unrecoverable err */\n  bool recv_sspi_close_notify; /* true if connection closed by close_notify */\n  bool recv_connection_closed; /* true if connection closed, regardless how */\n  bool use_alpn; /* true if ALPN is used for this connection */\n#ifdef HAS_MANUAL_VERIFY_API\n  bool use_manual_cred_validation; /* true if manual cred validation is used */\n#endif\n  ALG_ID algIds[NUMOF_CIPHERS];\n};\n#endif /* EXPOSE_SCHANNEL_INTERNAL_STRUCTS */\n\n#endif /* USE_SCHANNEL */\n#endif /* HEADER_CURL_SCHANNEL_H */\n"], "filenames": ["lib/vtls/schannel.c", "lib/vtls/schannel.h"], "buggy_code_start_loc": [331, 73], "buggy_code_end_loc": [597, 104], "fixing_code_start_loc": [331, 74], "fixing_code_end_loc": [598, 108], "type": "CWE-668", "message": "curl 7.61.0 through 7.76.1 suffers from exposure of data element to wrong session due to a mistake in the code for CURLOPT_SSL_CIPHER_LIST when libcurl is built to use the Schannel TLS library. The selected cipher set was stored in a single \"static\" variable in the library, which has the surprising side-effect that if an application sets up multiple concurrent transfers, the last one that sets the ciphers will accidentally control the set used by all transfers. In a worst-case scenario, this weakens transport security significantly.", "other": {"cve": {"id": "CVE-2021-22897", "sourceIdentifier": "support@hackerone.com", "published": "2021-06-11T16:15:10.963", "lastModified": "2022-08-30T21:21:31.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "curl 7.61.0 through 7.76.1 suffers from exposure of data element to wrong session due to a mistake in the code for CURLOPT_SSL_CIPHER_LIST when libcurl is built to use the Schannel TLS library. The selected cipher set was stored in a single \"static\" variable in the library, which has the surprising side-effect that if an application sets up multiple concurrent transfers, the last one that sets the ciphers will accidentally control the set used by all transfers. In a worst-case scenario, this weakens transport security significantly."}, {"lang": "es", "value": "curl versiones 7.61.0 hasta 7.76.1, sufre de exposici\u00f3n de un elemento de datos a una sesi\u00f3n equivocada debido a un error en el c\u00f3digo para la funci\u00f3n CURLOPT_SSL_CIPHER_LIST cuando libcurl es constru\u00eddo para usar la biblioteca TLS de Schannel. El ajuste de cifrado seleccionado se almacenaba en una \u00fanica variable \"static\" en la biblioteca, lo que tiene el sorprendente efecto secundario de que si una aplicaci\u00f3n establece m\u00faltiples transferencias concurrentes, la \u00faltima que ajusta los cifrados controlar\u00e1 accidentalmente el ajuste usado por todas las transferencias. En el peor de los casos, esto debilita significativamente la seguridad del transporte"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-840"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haxx:curl:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.61.0", "versionEndIncluding": "7.76.1", "matchCriteriaId": "5681F65E-9839-4E10-8245-C878D384C944"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:1.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "10323322-F6C0-4EA7-9344-736F7A80AA5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_function_cloud_native_environment:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2A5B24D-BDF2-423C-98EA-A40778C01A05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "6F60E32F-0CA0-4C2D-9848-CB92765A9ACB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "DF616620-88CE-4A77-B904-C1728A2E6F9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:1.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "3AA09838-BF13-46AC-BB97-A69F48B73A8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_service_communication_proxy:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "175B97A7-0B00-4378-AD9F-C01B6D9FD570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:essbase:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.1.2.4.047", "matchCriteriaId": "6A0BD5BD-E2F8-4B4E-B5CF-9787E6F2E4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:essbase:*:*:*:*:*:*:*:*", "versionStartIncluding": "21.0", "versionEndExcluding": "21.3", "matchCriteriaId": "3197F464-F0A5-4BD4-9068-65CD448D8F4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.7.34", "matchCriteriaId": "10630209-CF90-455D-B70F-DB50BAFC5499"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndIncluding": "8.0.25", "matchCriteriaId": "181677F8-59EE-49BC-91A7-845819742869"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_infrastructure_network_services:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1.1", "matchCriteriaId": "B0F46497-4AB0-49A7-9453-CC26837BF253"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://curl.se/docs/CVE-2021-22897.html", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/curl/curl/commit/bbb71507b7bab52002f9b1e0880bed6a32834511", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1172857", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210727-0007/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/curl/curl/commit/bbb71507b7bab52002f9b1e0880bed6a32834511"}}