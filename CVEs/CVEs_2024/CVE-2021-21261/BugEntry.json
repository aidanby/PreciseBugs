{"buggy_code": ["/*\n * Copyright \u00a9 2014-2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#ifndef __FLATPAK_BWRAP_H__\n#define __FLATPAK_BWRAP_H__\n\ntypedef struct\n{\n  GPtrArray *argv;\n  GArray    *noinherit_fds; /* Just keep these open while the bwrap lives */\n  GArray    *fds;\n  GStrv      envp;\n} FlatpakBwrap;\n\nextern char *flatpak_bwrap_empty_env[1];\n\nFlatpakBwrap *flatpak_bwrap_new (char **env);\nvoid          flatpak_bwrap_free (FlatpakBwrap *bwrap);\nvoid          flatpak_bwrap_set_env (FlatpakBwrap *bwrap,\n                                     const char   *variable,\n                                     const char   *value,\n                                     gboolean      overwrite);\ngboolean      flatpak_bwrap_is_empty (FlatpakBwrap *bwrap);\nvoid          flatpak_bwrap_finish (FlatpakBwrap *bwrap);\nvoid          flatpak_bwrap_unset_env (FlatpakBwrap *bwrap,\n                                       const char   *variable);\nvoid          flatpak_bwrap_add_arg (FlatpakBwrap *bwrap,\n                                     const char   *arg);\nvoid          flatpak_bwrap_add_noinherit_fd (FlatpakBwrap *bwrap,\n                                              int           fd);\nvoid          flatpak_bwrap_add_fd (FlatpakBwrap *bwrap,\n                                    int           fd);\nvoid          flatpak_bwrap_add_args (FlatpakBwrap *bwrap,\n                                      ...) G_GNUC_NULL_TERMINATED;\nvoid          flatpak_bwrap_add_arg_printf (FlatpakBwrap *bwrap,\n                                            const char   *format,\n                                            ...) G_GNUC_PRINTF (2, 3);\nvoid          flatpak_bwrap_append_argsv (FlatpakBwrap *bwrap,\n                                          char        **args,\n                                          int           len);\nvoid          flatpak_bwrap_append_bwrap (FlatpakBwrap *bwrap,\n                                          FlatpakBwrap *other);       /* Steals the fds */\nvoid          flatpak_bwrap_append_args (FlatpakBwrap *bwrap,\n                                         GPtrArray    *other_array);\nvoid          flatpak_bwrap_add_args_data_fd (FlatpakBwrap *bwrap,\n                                              const char   *op,\n                                              int           fd,\n                                              const char   *path_optional);\ngboolean      flatpak_bwrap_add_args_data (FlatpakBwrap *bwrap,\n                                           const char   *name,\n                                           const char   *content,\n                                           gssize        content_size,\n                                           const char   *path,\n                                           GError      **error);\nvoid          flatpak_bwrap_add_bind_arg (FlatpakBwrap *bwrap,\n                                          const char   *type,\n                                          const char   *src,\n                                          const char   *dest);\ngboolean      flatpak_bwrap_bundle_args (FlatpakBwrap *bwrap,\n                                         int           start,\n                                         int           end,\n                                         gboolean      one_arg,\n                                         GError      **error);\n\nvoid          flatpak_bwrap_child_setup_cb (gpointer user_data);\nvoid          flatpak_bwrap_child_setup (GArray *fd_array,\n                                         gboolean close_fd_workaround);\n\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (FlatpakBwrap, flatpak_bwrap_free)\n\n\n#endif /* __FLATPAK_BWRAP_H__ */\n", "/*\n * Copyright \u00a9 2014-2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-bwrap-private.h\"\n#include \"flatpak-utils-private.h\"\n#include \"flatpak-utils-base-private.h\"\n\nstatic void\nclear_fd (gpointer data)\n{\n  int *fd_p = data;\n\n  if (fd_p != NULL && *fd_p != -1)\n    close (*fd_p);\n}\n\nchar *flatpak_bwrap_empty_env[] = { NULL };\n\nFlatpakBwrap *\nflatpak_bwrap_new (char **env)\n{\n  FlatpakBwrap *bwrap = g_new0 (FlatpakBwrap, 1);\n\n  bwrap->argv = g_ptr_array_new_with_free_func (g_free);\n  bwrap->noinherit_fds = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_set_clear_func (bwrap->noinherit_fds, clear_fd);\n  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_set_clear_func (bwrap->fds, clear_fd);\n\n  if (env)\n    bwrap->envp = g_strdupv (env);\n  else\n    bwrap->envp = g_get_environ ();\n\n  return bwrap;\n}\n\nvoid\nflatpak_bwrap_free (FlatpakBwrap *bwrap)\n{\n  g_ptr_array_unref (bwrap->argv);\n  g_array_unref (bwrap->noinherit_fds);\n  g_array_unref (bwrap->fds);\n  g_strfreev (bwrap->envp);\n  g_free (bwrap);\n}\n\ngboolean\nflatpak_bwrap_is_empty (FlatpakBwrap *bwrap)\n{\n  return bwrap->argv->len == 0;\n}\n\nvoid\nflatpak_bwrap_set_env (FlatpakBwrap *bwrap,\n                       const char   *variable,\n                       const char   *value,\n                       gboolean      overwrite)\n{\n  bwrap->envp = g_environ_setenv (bwrap->envp, variable, value, overwrite);\n}\n\nvoid\nflatpak_bwrap_unset_env (FlatpakBwrap *bwrap,\n                         const char   *variable)\n{\n  bwrap->envp = g_environ_unsetenv (bwrap->envp, variable);\n}\n\nvoid\nflatpak_bwrap_add_arg (FlatpakBwrap *bwrap, const char *arg)\n{\n  g_ptr_array_add (bwrap->argv, g_strdup (arg));\n}\n\nvoid\nflatpak_bwrap_finish (FlatpakBwrap *bwrap)\n{\n  g_ptr_array_add (bwrap->argv, NULL);\n}\n\nvoid\nflatpak_bwrap_add_noinherit_fd (FlatpakBwrap *bwrap,\n                                int           fd)\n{\n  g_array_append_val (bwrap->noinherit_fds, fd);\n}\n\nvoid\nflatpak_bwrap_add_fd (FlatpakBwrap *bwrap,\n                      int           fd)\n{\n  g_array_append_val (bwrap->fds, fd);\n}\n\nvoid\nflatpak_bwrap_add_arg_printf (FlatpakBwrap *bwrap, const char *format, ...)\n{\n  va_list args;\n\n  va_start (args, format);\n  g_ptr_array_add (bwrap->argv, g_strdup_vprintf (format, args));\n  va_end (args);\n}\nvoid\nflatpak_bwrap_add_args (FlatpakBwrap *bwrap, ...)\n{\n  va_list args;\n  const gchar *arg;\n\n  va_start (args, bwrap);\n  while ((arg = va_arg (args, const gchar *)))\n    flatpak_bwrap_add_arg (bwrap, arg);\n  va_end (args);\n}\n\nvoid\nflatpak_bwrap_append_argsv (FlatpakBwrap *bwrap,\n                            char        **args,\n                            int           len)\n{\n  int i;\n\n  if (len < 0)\n    len = g_strv_length (args);\n\n  for (i = 0; i < len; i++)\n    g_ptr_array_add (bwrap->argv, g_strdup (args[i]));\n}\n\nvoid\nflatpak_bwrap_append_args (FlatpakBwrap *bwrap,\n                           GPtrArray    *other_array)\n{\n  flatpak_bwrap_append_argsv (bwrap,\n                              (char **) other_array->pdata,\n                              other_array->len);\n}\n\nstatic int *\nflatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,\n                         gsize        *len_out)\n{\n  gsize len = bwrap->fds->len;\n  int *res = (int *) g_array_free (bwrap->fds, FALSE);\n\n  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));\n  *len_out = len;\n  return res;\n}\n\nvoid\nflatpak_bwrap_append_bwrap (FlatpakBwrap *bwrap,\n                            FlatpakBwrap *other)\n{\n  g_autofree int *fds = NULL;\n  gsize n_fds, i;\n\n  fds = flatpak_bwrap_steal_fds (other, &n_fds);\n  for (i = 0; i < n_fds; i++)\n    flatpak_bwrap_add_fd (bwrap, fds[i]);\n\n  flatpak_bwrap_append_argsv (bwrap,\n                              (char **) other->argv->pdata,\n                              other->argv->len);\n\n  for (i = 0; other->envp[i] != NULL; i++)\n    {\n      char *key_val = other->envp[i];\n      char *eq = strchr (key_val, '=');\n      if (eq)\n        {\n          g_autofree char *key = g_strndup (key_val, eq - key_val);\n          flatpak_bwrap_set_env (bwrap,\n                                 key, eq + 1, TRUE);\n        }\n    }\n}\n\nvoid\nflatpak_bwrap_add_args_data_fd (FlatpakBwrap *bwrap,\n                                const char   *op,\n                                int           fd,\n                                const char   *path_optional)\n{\n  g_autofree char *fd_str = g_strdup_printf (\"%d\", fd);\n\n  flatpak_bwrap_add_fd (bwrap, fd);\n  flatpak_bwrap_add_args (bwrap,\n                          op, fd_str, path_optional,\n                          NULL);\n}\n\n\n/* Given a buffer @content of size @content_size, generate a fd (memfd if available)\n * of the data.  The @name parameter is used by memfd_create() as a debugging aid;\n * it has no semantic meaning.  The bwrap command line will inject it into the target\n * container as @path.\n */\ngboolean\nflatpak_bwrap_add_args_data (FlatpakBwrap *bwrap,\n                             const char   *name,\n                             const char   *content,\n                             gssize        content_size,\n                             const char   *path,\n                             GError      **error)\n{\n  g_auto(GLnxTmpfile) args_tmpf  = { 0, };\n\n  if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&args_tmpf, name, content, content_size, error))\n    return FALSE;\n\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--ro-bind-data\", glnx_steal_fd (&args_tmpf.fd), path);\n  return TRUE;\n}\n\n/* This resolves the target here rather than in bwrap, because it may\n * not resolve in bwrap setup due to absolute symlinks conflicting\n * with /newroot root. For example, dest could be inside\n * ~/.var/app/XXX where XXX is an absolute symlink.  However, in the\n * usecases here the destination file often doesn't exist, so we\n * only resolve the directory part.\n */\nvoid\nflatpak_bwrap_add_bind_arg (FlatpakBwrap *bwrap,\n                            const char   *type,\n                            const char   *src,\n                            const char   *dest)\n{\n  g_autofree char *dest_dirname = g_path_get_dirname (dest);\n  g_autofree char *dest_dirname_real = realpath (dest_dirname, NULL);\n\n  if (dest_dirname_real)\n    {\n      g_autofree char *dest_basename = g_path_get_basename (dest);\n      g_autofree char *dest_real = g_build_filename (dest_dirname_real, dest_basename, NULL);\n      flatpak_bwrap_add_args (bwrap, type, src, dest_real, NULL);\n    }\n}\n\ngboolean\nflatpak_bwrap_bundle_args (FlatpakBwrap *bwrap,\n                           int           start,\n                           int           end,\n                           gboolean      one_arg,\n                           GError      **error)\n{\n  g_autofree gchar *data = NULL;\n  gchar *ptr;\n  gint i;\n  gsize data_len = 0;\n  int fd;\n  g_auto(GLnxTmpfile) args_tmpf  = { 0, };\n\n  if (end == -1)\n    end = bwrap->argv->len;\n\n  for (i = start; i < end; i++)\n    data_len +=  strlen (bwrap->argv->pdata[i]) + 1;\n\n  data = g_new (gchar, data_len);\n  ptr = data;\n  for (i = start; i < end; i++)\n    ptr = g_stpcpy (ptr, bwrap->argv->pdata[i]) + 1;\n\n  if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&args_tmpf, \"bwrap-args\", data, data_len, error))\n    return FALSE;\n\n  fd = glnx_steal_fd (&args_tmpf.fd);\n\n  {\n    g_autofree char *commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata + start, end - start);\n    flatpak_debug2 (\"bwrap --args %d = %s\", fd, commandline);\n  }\n\n  flatpak_bwrap_add_fd (bwrap, fd);\n  g_ptr_array_remove_range (bwrap->argv, start, end - start);\n  if (one_arg)\n    {\n      g_ptr_array_insert (bwrap->argv, start, g_strdup_printf (\"--args=%d\", fd));\n    }\n  else\n    {\n      g_ptr_array_insert (bwrap->argv, start, g_strdup (\"--args\"));\n      g_ptr_array_insert (bwrap->argv, start + 1, g_strdup_printf (\"%d\", fd));\n    }\n\n  return TRUE;\n}\n\nvoid\nflatpak_bwrap_child_setup (GArray *fd_array,\n                           gboolean close_fd_workaround)\n{\n  int i;\n\n  if (close_fd_workaround)\n    flatpak_close_fds_workaround (3);\n\n  /* If no fd_array was specified, don't care. */\n  if (fd_array == NULL)\n    return;\n\n  /* Otherwise, mark not - close-on-exec all the fds in the array */\n  for (i = 0; i < fd_array->len; i++)\n    {\n      int fd = g_array_index (fd_array, int, i);\n\n      /* We also seek all fds to the start, because this lets\n         us use the same fd_array multiple times */\n      if (lseek (fd, 0, SEEK_SET) < 0)\n        {\n          /* Ignore the error, this happens on e.g. pipe fds */\n        }\n\n      fcntl (fd, F_SETFD, 0);\n    }\n}\n\n/* Unset FD_CLOEXEC on the array of fds passed in @user_data */\nvoid\nflatpak_bwrap_child_setup_cb (gpointer user_data)\n{\n  GArray *fd_array = user_data;\n\n  flatpak_bwrap_child_setup (fd_array, TRUE);\n}\n", "/*\n * Copyright \u00a9 2014-2019 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <gio/gdesktopappinfo.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/vfs.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n#ifdef HAVE_DCONF\n#include <dconf/dconf.h>\n#endif\n#ifdef HAVE_LIBMALCONTENT\n#include <libmalcontent/malcontent.h>\n#endif\n\n#ifdef ENABLE_SECCOMP\n#include <seccomp.h>\n#endif\n\n#ifdef ENABLE_XAUTH\n#include <X11/Xauth.h>\n#endif\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-run-private.h\"\n#include \"flatpak-proxy.h\"\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-instance-private.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include \"flatpak-document-dbus-generated.h\"\n#include \"flatpak-error.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n\nconst char * const abs_usrmerged_dirs[] =\n{\n  \"/bin\",\n  \"/lib\",\n  \"/lib32\",\n  \"/lib64\",\n  \"/sbin\",\n  NULL\n};\nconst char * const *flatpak_abs_usrmerged_dirs = abs_usrmerged_dirs;\n\nstatic char *\nextract_unix_path_from_dbus_address (const char *address)\n{\n  const char *path, *path_end;\n\n  if (address == NULL)\n    return NULL;\n\n  if (!g_str_has_prefix (address, \"unix:\"))\n    return NULL;\n\n  path = strstr (address, \"path=\");\n  if (path == NULL)\n    return NULL;\n  path += strlen (\"path=\");\n  path_end = path;\n  while (*path_end != 0 && *path_end != ',')\n    path_end++;\n\n  return g_strndup (path, path_end - path);\n}\n\n#ifdef ENABLE_XAUTH\nstatic gboolean\nauth_streq (char *str,\n            char *au_str,\n            int   au_len)\n{\n  return au_len == strlen (str) && memcmp (str, au_str, au_len) == 0;\n}\n\nstatic gboolean\nxauth_entry_should_propagate (Xauth *xa,\n                              char  *hostname,\n                              char  *number)\n{\n  /* ensure entry isn't for remote access */\n  if (xa->family != FamilyLocal && xa->family != FamilyWild)\n    return FALSE;\n\n  /* ensure entry is for this machine */\n  if (xa->family == FamilyLocal && !auth_streq (hostname, xa->address, xa->address_length))\n    return FALSE;\n\n  /* ensure entry is for this session */\n  if (xa->number != NULL && !auth_streq (number, xa->number, xa->number_length))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic void\nwrite_xauth (char *number, FILE *output)\n{\n  Xauth *xa, local_xa;\n  char *filename;\n  FILE *f;\n  struct utsname unames;\n\n  if (uname (&unames))\n    {\n      g_warning (\"uname failed\");\n      return;\n    }\n\n  filename = XauFileName ();\n  f = fopen (filename, \"rb\");\n  if (f == NULL)\n    return;\n\n  while (TRUE)\n    {\n      xa = XauReadAuth (f);\n      if (xa == NULL)\n        break;\n      if (xauth_entry_should_propagate (xa, unames.nodename, number))\n        {\n          local_xa = *xa;\n          if (local_xa.number)\n            {\n              local_xa.number = \"99\";\n              local_xa.number_length = 2;\n            }\n\n          if (!XauWriteAuth (output, &local_xa))\n            g_warning (\"xauth write error\");\n        }\n\n      XauDisposeAuth (xa);\n    }\n\n  fclose (f);\n}\n#endif /* ENABLE_XAUTH */\n\nstatic void\nflatpak_run_add_x11_args (FlatpakBwrap *bwrap,\n                          gboolean      allowed)\n{\n  g_autofree char *x11_socket = NULL;\n  const char *display;\n\n  /* Always cover /tmp/.X11-unix, that way we never see the host one in case\n   * we have access to the host /tmp. If you request X access we'll put the right\n   * thing in this anyway.\n   */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--tmpfs\", \"/tmp/.X11-unix\",\n                          NULL);\n\n  if (!allowed)\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n      return;\n    }\n\n  g_debug (\"Allowing x11 access\");\n\n  display = g_getenv (\"DISPLAY\");\n  if (display && display[0] == ':' && g_ascii_isdigit (display[1]))\n    {\n      const char *display_nr = &display[1];\n      const char *display_nr_end = display_nr;\n      g_autofree char *d = NULL;\n\n      while (g_ascii_isdigit (*display_nr_end))\n        display_nr_end++;\n\n      d = g_strndup (display_nr, display_nr_end - display_nr);\n      x11_socket = g_strdup_printf (\"/tmp/.X11-unix/X%s\", d);\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", x11_socket, \"/tmp/.X11-unix/X99\",\n                              NULL);\n      flatpak_bwrap_set_env (bwrap, \"DISPLAY\", \":99.0\", TRUE);\n\n#ifdef ENABLE_XAUTH\n      g_auto(GLnxTmpfile) xauth_tmpf  = { 0, };\n\n      if (glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &xauth_tmpf, NULL))\n        {\n          FILE *output = fdopen (xauth_tmpf.fd, \"wb\");\n          if (output != NULL)\n            {\n              /* fd is now owned by output, steal it from the tmpfile */\n              int tmp_fd = dup (glnx_steal_fd (&xauth_tmpf.fd));\n              if (tmp_fd != -1)\n                {\n                  g_autofree char *dest = g_strdup_printf (\"/run/user/%d/Xauthority\", getuid ());\n\n                  write_xauth (d, output);\n                  flatpak_bwrap_add_args_data_fd (bwrap, \"--ro-bind-data\", tmp_fd, dest);\n\n                  flatpak_bwrap_set_env (bwrap, \"XAUTHORITY\", dest, TRUE);\n                }\n\n              fclose (output);\n\n              if (tmp_fd != -1)\n                lseek (tmp_fd, 0, SEEK_SET);\n            }\n        }\n#endif\n    }\n  else\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n    }\n}\n\nstatic gboolean\nflatpak_run_add_wayland_args (FlatpakBwrap *bwrap)\n{\n  const char *wayland_display;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *wayland_socket = NULL;\n  g_autofree char *sandbox_wayland_socket = NULL;\n  gboolean res = FALSE;\n  struct stat statbuf;\n\n  wayland_display = g_getenv (\"WAYLAND_DISPLAY\");\n  if (!wayland_display)\n    wayland_display = \"wayland-0\";\n\n  wayland_socket = g_build_filename (user_runtime_dir, wayland_display, NULL);\n  sandbox_wayland_socket = g_strdup_printf (\"/run/user/%d/%s\", getuid (), wayland_display);\n\n  if (stat (wayland_socket, &statbuf) == 0 &&\n      (statbuf.st_mode & S_IFMT) == S_IFSOCK)\n    {\n      res = TRUE;\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", wayland_socket, sandbox_wayland_socket,\n                              NULL);\n    }\n  return res;\n}\n\nstatic void\nflatpak_run_add_ssh_args (FlatpakBwrap *bwrap)\n{\n  const char * auth_socket;\n  g_autofree char * sandbox_auth_socket = NULL;\n\n  auth_socket = g_getenv (\"SSH_AUTH_SOCK\");\n\n  if (!auth_socket)\n    return; /* ssh agent not present */\n\n  if (!g_file_test (auth_socket, G_FILE_TEST_EXISTS))\n    {\n      /* Let's clean it up, so that the application will not try to connect */\n      flatpak_bwrap_unset_env (bwrap, \"SSH_AUTH_SOCK\");\n      return;\n    }\n\n  sandbox_auth_socket = g_strdup_printf (\"/run/user/%d/ssh-auth\", getuid ());\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", auth_socket, sandbox_auth_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"SSH_AUTH_SOCK\", sandbox_auth_socket, TRUE);\n}\n\nstatic void\nflatpak_run_add_pcsc_args (FlatpakBwrap *bwrap)\n{\n  const char * pcsc_socket;\n  const char * sandbox_pcsc_socket = \"/run/pcscd/pcscd.comm\";\n\n  pcsc_socket = g_getenv (\"PCSCLITE_CSOCK_NAME\");\n  if (pcsc_socket)\n    {\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_unset_env (bwrap, \"PCSCLITE_CSOCK_NAME\");\n          return;\n        }\n    }\n  else\n    {\n      pcsc_socket = \"/run/pcscd/pcscd.comm\";\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", pcsc_socket, sandbox_pcsc_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"PCSCLITE_CSOCK_NAME\", sandbox_pcsc_socket, TRUE);\n}\n\nstatic gboolean\nflatpak_run_cups_check_server_is_socket (const char *server)\n{\n  if (g_str_has_prefix (server, \"/\") && strstr (server, \":\") == NULL)\n    return TRUE;\n\n  return FALSE;\n}\n\n/* Try to find a default server from a cups confguration file */\nstatic char *\nflatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic char *\nflatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n\n  /* TODO\n   * we don't currently support cups servers located on the network, if such\n   * server is detected, we simply ignore it and in the worst case we fallback\n   * to the default socket\n   */\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n\n  // Fallback to default socket\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}\n\nstatic void\nflatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}\n\n/* Try to find a default server from a pulseaudio confguration file */\nstatic char *\nflatpak_run_get_pulseaudio_server_user_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"Pulseaudio user configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == ';') || (*line == '#'))\n        continue;\n\n      if (g_str_has_prefix (line, \".include \"))\n        {\n          g_autofree char *rec_path = g_strdup (line + 9);\n          g_strstrip (rec_path);\n          char *found = flatpak_run_get_pulseaudio_server_user_config (rec_path);\n          if (found)\n            return found;\n        }\n      else if (g_str_has_prefix (line, \"[\"))\n        {\n          return NULL;\n        }\n      else\n        {\n          g_auto(GStrv) tokens = g_strsplit (line, \"=\", 2);\n\n          if ((tokens[0] != NULL) && (tokens[1] != NULL))\n            {\n              g_strchomp (tokens[0]);\n              if (strcmp (\"default-server\", tokens[0]) == 0)\n                {\n                  g_strstrip (tokens[1]);\n                  g_debug (\"Found pulseaudio socket from configuration file '%s': %s\", path, tokens[1]);\n                  return g_strdup (tokens[1]);\n                }\n            }\n        }\n    }\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_get_pulseaudio_server (void)\n{\n  const char * pulse_clientconfig;\n  char *pulse_server;\n  g_autofree char *pulse_user_config = NULL;\n\n  pulse_server = g_strdup (g_getenv (\"PULSE_SERVER\"));\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_clientconfig = g_getenv (\"PULSE_CLIENTCONFIG\");\n  if (pulse_clientconfig)\n    return flatpak_run_get_pulseaudio_server_user_config (pulse_clientconfig);\n\n  pulse_user_config = g_build_filename (g_get_user_config_dir (), \"pulse/client.conf\", NULL);\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (pulse_user_config);\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (\"/etc/pulse/client.conf\");\n  if (pulse_server)\n    return pulse_server;\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_parse_pulse_server (const char *value)\n{\n  g_auto(GStrv) servers = g_strsplit (value, \" \", 0);\n  gsize i;\n\n  for (i = 0; servers[i] != NULL; i++)\n    {\n      const char *server = servers[i];\n      if (g_str_has_prefix (server, \"{\"))\n        {\n          const char * closing = strstr (server, \"}\");\n          if (closing == NULL)\n            continue;\n          server = closing + 1;\n        }\n      if (g_str_has_prefix (server, \"unix:\"))\n        return g_strdup (server + 5);\n    }\n\n  return NULL;\n}\n\n/*\n * Get the machine ID as used by PulseAudio. This is the systemd/D-Bus\n * machine ID, or failing that, the hostname.\n */\nstatic char *\nflatpak_run_get_pulse_machine_id (void)\n{\n  static const char * const machine_ids[] =\n  {\n    \"/etc/machine-id\",\n    \"/var/lib/dbus/machine-id\",\n  };\n  gsize i;\n\n  for (i = 0; i < G_N_ELEMENTS (machine_ids); i++)\n    {\n      g_autofree char *ret = NULL;\n\n      if (g_file_get_contents (machine_ids[i], &ret, NULL, NULL))\n        {\n          gsize j;\n\n          g_strstrip (ret);\n\n          for (j = 0; ret[j] != '\\0'; j++)\n            {\n              if (!g_ascii_isxdigit (ret[j]))\n                break;\n            }\n\n          if (ret[0] != '\\0' && ret[j] == '\\0')\n            return g_steal_pointer (&ret);\n        }\n    }\n\n  return g_strdup (g_get_host_name ());\n}\n\n/*\n * Get the directory used by PulseAudio for its configuration.\n */\nstatic char *\nflatpak_run_get_pulse_home (void)\n{\n  /* Legacy path ~/.pulse is tried first, for compatibility */\n  {\n    const char *parent = g_get_home_dir ();\n    g_autofree char *ret = g_build_filename (parent, \".pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  /* The more modern path, usually ~/.config/pulse */\n  {\n    const char *parent = g_get_user_config_dir ();\n    /* Usually ~/.config/pulse */\n    g_autofree char *ret = g_build_filename (parent, \"pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  return NULL;\n}\n\n/*\n * Get the runtime directory used by PulseAudio for its socket.\n */\nstatic char *\nflatpak_run_get_pulse_runtime_dir (void)\n{\n  const char *val = NULL;\n\n  val = g_getenv (\"PULSE_RUNTIME_PATH\");\n\n  if (val != NULL)\n    return realpath (val, NULL);\n\n  {\n    const char *user_runtime_dir = g_get_user_runtime_dir ();\n\n    if (user_runtime_dir != NULL)\n      {\n        g_autofree char *dir = g_build_filename (user_runtime_dir, \"pulse\", NULL);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  {\n    g_autofree char *pulse_home = flatpak_run_get_pulse_home ();\n    g_autofree char *machine_id = flatpak_run_get_pulse_machine_id ();\n\n    if (pulse_home != NULL && machine_id != NULL)\n      {\n        /* This is usually a symlink, but we take its realpath() anyway */\n        g_autofree char *dir = g_strdup_printf (\"%s/%s-runtime\", pulse_home, machine_id);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  return NULL;\n}\n\nstatic void\nflatpak_run_add_pulseaudio_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *pulseaudio_server = flatpak_run_get_pulseaudio_server ();\n  g_autofree char *pulseaudio_socket = NULL;\n  g_autofree char *pulse_runtime_dir = flatpak_run_get_pulse_runtime_dir ();\n\n  if (pulseaudio_server)\n    pulseaudio_socket = flatpak_run_parse_pulse_server (pulseaudio_server);\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = g_build_filename (pulse_runtime_dir, \"native\", NULL);\n\n      if (!g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = realpath (\"/var/run/pulse/native\", NULL);\n\n      if (pulseaudio_socket && !g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  flatpak_bwrap_unset_env (bwrap, \"PULSE_SERVER\");\n\n  if (pulseaudio_socket && g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n    {\n      gboolean share_shm = FALSE; /* TODO: When do we add this? */\n      g_autofree char *client_config = g_strdup_printf (\"enable-shm=%s\\n\", share_shm ? \"yes\" : \"no\");\n      g_autofree char *sandbox_socket_path = g_strdup_printf (\"/run/user/%d/pulse/native\", getuid ());\n      g_autofree char *pulse_server = g_strdup_printf (\"unix:/run/user/%d/pulse/native\", getuid ());\n      g_autofree char *config_path = g_strdup_printf (\"/run/user/%d/pulse/config\", getuid ());\n\n      /* FIXME - error handling */\n      if (!flatpak_bwrap_add_args_data (bwrap, \"pulseaudio\", client_config, -1, config_path, NULL))\n        return;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", pulseaudio_socket, sandbox_socket_path,\n                              NULL);\n\n      flatpak_bwrap_set_env (bwrap, \"PULSE_SERVER\", pulse_server, TRUE);\n      flatpak_bwrap_set_env (bwrap, \"PULSE_CLIENTCONFIG\", config_path, TRUE);\n    }\n  else\n    g_debug (\"Could not find pulseaudio socket\");\n\n  /* Also allow ALSA access. This was added in 1.8, and is not ideally named. However,\n   * since the practical permission of ALSA and PulseAudio are essentially the same, and\n   * since we don't want to add more permissions for something we plan to replace with\n   * portals/pipewire going forward we reinterpret pulseaudio to also mean ALSA.\n   */\n  if (g_file_test (\"/dev/snd\", G_FILE_TEST_IS_DIR))\n    flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/snd\", \"/dev/snd\", NULL);\n}\n\nstatic void\nflatpak_run_add_resolved_args (FlatpakBwrap *bwrap)\n{\n  const char *resolved_socket = \"/run/systemd/resolve/io.systemd.Resolve\";\n\n  if (g_file_test (resolved_socket, G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--bind\", resolved_socket, resolved_socket, NULL);\n}\n\nstatic void\nflatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}\n\nstatic char *\ncreate_proxy_socket (char *template)\n{\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy\", NULL);\n  g_autofree char *proxy_socket = g_build_filename (proxy_socket_dir, template, NULL);\n  int fd;\n\n  if (!glnx_shutil_mkdir_p_at (AT_FDCWD, proxy_socket_dir, 0755, NULL, NULL))\n    return NULL;\n\n  fd = g_mkstemp (proxy_socket);\n  if (fd == -1)\n    return NULL;\n\n  close (fd);\n\n  return g_steal_pointer (&proxy_socket);\n}\n\nstatic gboolean\nflatpak_run_add_system_dbus_args (FlatpakBwrap   *app_bwrap,\n                                  FlatpakBwrap   *proxy_arg_bwrap,\n                                  FlatpakContext *context,\n                                  FlatpakRunFlags flags)\n{\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SYSTEM_BUS_ADDRESS\");\n  g_autofree char *real_dbus_address = NULL;\n  g_autofree char *dbus_system_socket = NULL;\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) != 0;\n  if (unrestricted)\n    g_debug (\"Allowing system-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY) != 0;\n\n  if (dbus_address != NULL)\n    dbus_system_socket = extract_unix_path_from_dbus_address (dbus_address);\n  else if (g_file_test (\"/var/run/dbus/system_bus_socket\", G_FILE_TEST_EXISTS))\n    dbus_system_socket = g_strdup (\"/var/run/dbus/system_bus_socket\");\n\n  if (dbus_system_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_system_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  else if (!no_proxy && flatpak_context_get_needs_system_bus_proxy (context))\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"system-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      if (dbus_address)\n        real_dbus_address = g_strdup (dbus_address);\n      else\n        real_dbus_address = g_strdup_printf (\"unix:path=%s\", dbus_system_socket);\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, real_dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        flatpak_context_add_bus_filters (context, NULL, FALSE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SYSTEM_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_session_dbus_args (FlatpakBwrap   *app_bwrap,\n                                   FlatpakBwrap   *proxy_arg_bwrap,\n                                   FlatpakContext *context,\n                                   FlatpakRunFlags flags,\n                                   const char     *app_id)\n{\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SESSION_BUS_ADDRESS\");\n  g_autofree char *dbus_session_socket = NULL;\n  g_autofree char *sandbox_socket_path = g_strdup_printf (\"/run/user/%d/bus\", getuid ());\n  g_autofree char *sandbox_dbus_address = g_strdup_printf (\"unix:path=/run/user/%d/bus\", getuid ());\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) != 0;\n\n  if (dbus_address != NULL)\n    {\n      dbus_session_socket = extract_unix_path_from_dbus_address (dbus_address);\n    }\n  else\n    {\n      g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n      struct stat statbuf;\n\n      dbus_session_socket = g_build_filename (user_runtime_dir, \"bus\", NULL);\n\n      if (stat (dbus_session_socket, &statbuf) < 0\n          || (statbuf.st_mode & S_IFMT) != S_IFSOCK\n          || statbuf.st_uid != getuid ())\n        return FALSE;\n    }\n\n  if (unrestricted)\n    g_debug (\"Allowing session-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY) != 0;\n\n  if (dbus_session_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_session_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n      return TRUE;\n    }\n  else if (!no_proxy && dbus_address != NULL)\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"session-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        {\n          flatpak_context_add_bus_filters (context, app_id, TRUE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n          /* Allow calling any interface+method on all portals, but only receive broadcasts under /org/desktop/portal */\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--call=org.freedesktop.portal.*=*\");\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--broadcast=org.freedesktop.portal.*=@/org/freedesktop/portal/*\");\n        }\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SESSION_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_a11y_dbus_args (FlatpakBwrap   *app_bwrap,\n                                FlatpakBwrap   *proxy_arg_bwrap,\n                                FlatpakContext *context,\n                                FlatpakRunFlags flags)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *a11y_address = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDBusMessage) reply = NULL;\n  g_autoptr(GDBusMessage) msg = NULL;\n  g_autofree char *proxy_socket = NULL;\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY) != 0)\n    return FALSE;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus == NULL)\n    return FALSE;\n\n  msg = g_dbus_message_new_method_call (\"org.a11y.Bus\", \"/org/a11y/bus\", \"org.a11y.Bus\", \"GetAddress\");\n  g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n  reply =\n    g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                    G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                    30000,\n                                                    NULL,\n                                                    NULL,\n                                                    NULL);\n  if (reply)\n    {\n      if (g_dbus_message_to_gerror (reply, &local_error))\n        {\n          if (!g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n            g_message (\"Can't find a11y bus: %s\", local_error->message);\n        }\n      else\n        {\n          g_variant_get (g_dbus_message_get_body (reply),\n                         \"(s)\", &a11y_address);\n        }\n    }\n\n  if (!a11y_address)\n    return FALSE;\n\n  proxy_socket = create_proxy_socket (\"a11y-bus-proxy-XXXXXX\");\n  if (proxy_socket == NULL)\n    return FALSE;\n\n  g_autofree char *sandbox_socket_path = g_strdup_printf (\"/run/user/%d/at-spi-bus\", getuid ());\n  g_autofree char *sandbox_dbus_address = g_strdup_printf (\"unix:path=/run/user/%d/at-spi-bus\", getuid ());\n\n  flatpak_bwrap_add_args (proxy_arg_bwrap,\n                          a11y_address,\n                          proxy_socket, \"--filter\", \"--sloppy-names\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Embed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Unembed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Registry.GetRegisteredEvents@/org/a11y/atspi/registry\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetKeystrokeListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetDeviceEventListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersSync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersAsync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          NULL);\n\n  if ((flags & FLATPAK_RUN_FLAG_LOG_A11Y_BUS) != 0)\n    flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n  flatpak_bwrap_add_args (app_bwrap,\n                          \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                          NULL);\n  flatpak_bwrap_set_env (app_bwrap, \"AT_SPI_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n  return TRUE;\n}\n\n/* This wraps the argv in a bwrap call, primary to allow the\n   command to be run with a proper /.flatpak-info with data\n   taken from app_info_path */\nstatic gboolean\nadd_bwrap_wrapper (FlatpakBwrap *bwrap,\n                   const char   *app_info_path,\n                   GError      **error)\n{\n  glnx_autofd int app_info_fd = -1;\n  g_auto(GLnxDirFdIterator) dir_iter = { 0 };\n  struct dirent *dent;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy/\", NULL);\n\n  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);\n  if (app_info_fd == -1)\n    return glnx_throw_errno_prefix (error, _(\"Failed to open app info file\"));\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, \"/\", FALSE, &dir_iter, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  while (TRUE)\n    {\n      glnx_autofd int o_path_fd = -1;\n      struct statfs stfs;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      if (strcmp (dent->d_name, \".flatpak-info\") == 0)\n        continue;\n\n      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */\n      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);\n      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)\n        continue; /* AUTOFS mounts are risky and can cause us to block (see issue #1633), so ignore it. Its unlikely the proxy needs such a directory. */\n\n      if (dent->d_type == DT_DIR)\n        {\n          if (strcmp (dent->d_name, \"tmp\") == 0 ||\n              strcmp (dent->d_name, \"var\") == 0 ||\n              strcmp (dent->d_name, \"run\") == 0)\n            flatpak_bwrap_add_arg (bwrap, \"--bind\");\n          else\n            flatpak_bwrap_add_arg (bwrap, \"--ro-bind\");\n\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n      else if (dent->d_type == DT_LNK)\n        {\n          g_autofree gchar *target = NULL;\n\n          target = glnx_readlinkat_malloc (dir_iter.fd, dent->d_name,\n                                           NULL, error);\n          if (target == NULL)\n            return FALSE;\n          flatpak_bwrap_add_args (bwrap, \"--symlink\", target, NULL);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n    }\n\n  flatpak_bwrap_add_args (bwrap, \"--bind\", proxy_socket_dir, proxy_socket_dir, NULL);\n\n  /* This is a file rather than a bind mount, because it will then\n     not be unmounted from the namespace when the namespace dies. */\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--file\", glnx_steal_fd (&app_info_fd), \"/.flatpak-info\");\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nstart_dbus_proxy (FlatpakBwrap *app_bwrap,\n                  FlatpakBwrap *proxy_arg_bwrap,\n                  const char   *app_info_path,\n                  GError      **error)\n{\n  char x = 'x';\n  const char *proxy;\n  g_autofree char *commandline = NULL;\n  g_autoptr(FlatpakBwrap) proxy_bwrap = NULL;\n  int sync_fds[2] = {-1, -1};\n  int proxy_start_index;\n  g_auto(GStrv) minimal_envp = NULL;\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  proxy_bwrap = flatpak_bwrap_new (NULL);\n\n  if (!add_bwrap_wrapper (proxy_bwrap, app_info_path, error))\n    return FALSE;\n\n  proxy = g_getenv (\"FLATPAK_DBUSPROXY\");\n  if (proxy == NULL)\n    proxy = DBUSPROXY;\n\n  flatpak_bwrap_add_arg (proxy_bwrap, proxy);\n\n  proxy_start_index = proxy_bwrap->argv->len;\n\n  if (pipe2 (sync_fds, O_CLOEXEC) < 0)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Unable to create sync pipe\"));\n      return FALSE;\n    }\n\n  /* read end goes to app */\n  flatpak_bwrap_add_args_data_fd (app_bwrap, \"--sync-fd\", sync_fds[0], NULL);\n\n  /* write end goes to proxy */\n  flatpak_bwrap_add_fd (proxy_bwrap, sync_fds[1]);\n  flatpak_bwrap_add_arg_printf (proxy_bwrap, \"--fd=%d\", sync_fds[1]);\n\n  /* Note: This steals the fds from proxy_arg_bwrap */\n  flatpak_bwrap_append_bwrap (proxy_bwrap, proxy_arg_bwrap);\n\n  if (!flatpak_bwrap_bundle_args (proxy_bwrap, proxy_start_index, -1, TRUE, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (proxy_bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) proxy_bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async (NULL,\n                      (char **) proxy_bwrap->argv->pdata,\n                      NULL,\n                      G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                      flatpak_bwrap_child_setup_cb, proxy_bwrap->fds,\n                      NULL, error))\n    return FALSE;\n\n  /* The write end can be closed now, otherwise the read below will hang of xdg-dbus-proxy\n     fails to start. */\n  g_clear_pointer (&proxy_bwrap, flatpak_bwrap_free);\n\n  /* Sync with proxy, i.e. wait until its listening on the sockets */\n  if (read (sync_fds[0], &x, 1) != 1)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Failed to sync with dbus proxy\"));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic int\nflatpak_extension_compare_by_path (gconstpointer _a,\n                                   gconstpointer _b)\n{\n  const FlatpakExtension *a = _a;\n  const FlatpakExtension *b = _b;\n\n  return g_strcmp0 (a->directory, b->directory);\n}\n\ngboolean\nflatpak_run_add_extension_args (FlatpakBwrap      *bwrap,\n                                GKeyFile          *metakey,\n                                FlatpakDecomposed *ref,\n                                gboolean           use_ld_so_cache,\n                                char             **extensions_out,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autoptr(GString) used_extensions = g_string_new (\"\");\n  GList *extensions, *path_sorted_extensions, *l;\n  g_autoptr(GString) ld_library_path = g_string_new (\"\");\n  int count = 0;\n  g_autoptr(GHashTable) mounted_tmpfs =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autoptr(GHashTable) created_symlink =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *arch = flatpak_decomposed_dup_arch (ref);\n  const char *branch = flatpak_decomposed_get_branch (ref);\n  gboolean is_app = flatpak_decomposed_is_app (ref);\n\n  extensions = flatpak_list_extensions (metakey, arch, branch);\n\n  /* First we apply all the bindings, they are sorted alphabetically in order for parent directory\n     to be mounted before child directories */\n  path_sorted_extensions = g_list_copy (extensions);\n  path_sorted_extensions = g_list_sort (path_sorted_extensions, flatpak_extension_compare_by_path);\n\n  for (l = path_sorted_extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (is_app ? \"/app\" : \"/usr\", ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      g_autofree char *ref_file = g_build_filename (full_directory, \".ref\", NULL);\n      g_autofree char *real_ref = g_build_filename (ext->files_path, ext->directory, \".ref\", NULL);\n\n      if (ext->needs_tmpfs)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n\n          if (g_hash_table_lookup (mounted_tmpfs, parent) == NULL)\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--tmpfs\", parent,\n                                      NULL);\n              g_hash_table_insert (mounted_tmpfs, g_steal_pointer (&parent), \"mounted\");\n            }\n        }\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", ext->files_path, full_directory,\n                              NULL);\n\n      if (g_file_test (real_ref, G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", ref_file,\n                                NULL);\n    }\n\n  g_list_free (path_sorted_extensions);\n\n  /* Then apply library directories and file merging, in extension prio order */\n\n  for (l = extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (is_app ? \"/app\" : \"/usr\", ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      int i;\n\n      if (used_extensions->len > 0)\n        g_string_append (used_extensions, \";\");\n      g_string_append (used_extensions, ext->installed_id);\n      g_string_append (used_extensions, \"=\");\n      if (ext->commit != NULL)\n        g_string_append (used_extensions, ext->commit);\n      else\n        g_string_append (used_extensions, \"local\");\n\n      if (ext->add_ld_path)\n        {\n          g_autofree char *ld_path = g_build_filename (full_directory, ext->add_ld_path, NULL);\n\n          if (use_ld_so_cache)\n            {\n              g_autofree char *contents = g_strconcat (ld_path, \"\\n\", NULL);\n              /* We prepend app or runtime and a counter in order to get the include order correct for the conf files */\n              g_autofree char *ld_so_conf_file = g_strdup_printf (\"%s-%03d-%s.conf\", flatpak_decomposed_get_kind_str (ref), ++count, ext->installed_id);\n              g_autofree char *ld_so_conf_file_path = g_build_filename (\"/run/flatpak/ld.so.conf.d\", ld_so_conf_file, NULL);\n\n              if (!flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                                contents, -1, ld_so_conf_file_path, error))\n                return FALSE;\n            }\n          else\n            {\n              if (ld_library_path->len != 0)\n                g_string_append (ld_library_path, \":\");\n              g_string_append (ld_library_path, ld_path);\n            }\n        }\n\n      for (i = 0; ext->merge_dirs != NULL && ext->merge_dirs[i] != NULL; i++)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n          g_autofree char *merge_dir = g_build_filename (parent, ext->merge_dirs[i], NULL);\n          g_autofree char *source_dir = g_build_filename (ext->files_path, ext->merge_dirs[i], NULL);\n          g_auto(GLnxDirFdIterator) source_iter = { 0 };\n          struct dirent *dent;\n\n          if (glnx_dirfd_iterator_init_at (AT_FDCWD, source_dir, TRUE, &source_iter, NULL))\n            {\n              while (glnx_dirfd_iterator_next_dent (&source_iter, &dent, NULL, NULL) && dent != NULL)\n                {\n                  g_autofree char *symlink_path = g_build_filename (merge_dir, dent->d_name, NULL);\n                  /* Only create the first, because extensions are listed in prio order */\n                  if (g_hash_table_lookup (created_symlink, symlink_path) == NULL)\n                    {\n                      g_autofree char *symlink = g_build_filename (directory, ext->merge_dirs[i], dent->d_name, NULL);\n                      flatpak_bwrap_add_args (bwrap,\n                                              \"--symlink\", symlink, symlink_path,\n                                              NULL);\n                      g_hash_table_insert (created_symlink, g_steal_pointer (&symlink_path), \"created\");\n                    }\n                }\n            }\n        }\n    }\n\n  g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n\n  if (ld_library_path->len != 0)\n    {\n      const gchar *old_ld_path = g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\");\n\n      if (old_ld_path != NULL && *old_ld_path != 0)\n        {\n          if (is_app)\n            {\n              g_string_append (ld_library_path, \":\");\n              g_string_append (ld_library_path, old_ld_path);\n            }\n          else\n            {\n              g_string_prepend (ld_library_path, \":\");\n              g_string_prepend (ld_library_path, old_ld_path);\n            }\n        }\n\n      flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n    }\n\n  if (extensions_out)\n    *extensions_out = g_string_free (g_steal_pointer (&used_extensions), FALSE);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  if (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\") != NULL)\n    {\n      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"LD_LIBRARY_PATH\", g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"LD_LIBRARY_PATH\");\n    }\n\n  if (g_environ_getenv (bwrap->envp, \"TMPDIR\") != NULL)\n    {\n      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"TMPDIR\", g_environ_getenv (bwrap->envp, \"TMPDIR\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"TMPDIR\");\n    }\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}\n\ntypedef struct\n{\n  const char *env;\n  const char *val;\n} ExportData;\n\nstatic const ExportData default_exports[] = {\n  {\"PATH\", \"/app/bin:/usr/bin\"},\n  /* We always want to unset LD_LIBRARY_PATH to avoid inheriting weird\n   * dependencies from the host. But if not using ld.so.cache this is\n   * later set. */\n  {\"LD_LIBRARY_PATH\", NULL},\n  {\"XDG_CONFIG_DIRS\", \"/app/etc/xdg:/etc/xdg\"},\n  {\"XDG_DATA_DIRS\", \"/app/share:/usr/share\"},\n  {\"SHELL\", \"/bin/sh\"},\n  {\"TMPDIR\", NULL}, /* Unset TMPDIR as it may not exist in the sandbox */\n\n  /* Some env vars are common enough and will affect the sandbox badly\n     if set on the host. We clear these always. */\n  {\"PYTHONPATH\", NULL},\n  {\"PERLLIB\", NULL},\n  {\"PERL5LIB\", NULL},\n  {\"XCURSOR_PATH\", NULL},\n};\n\nstatic const ExportData no_ld_so_cache_exports[] = {\n  {\"LD_LIBRARY_PATH\", \"/app/lib\"},\n};\n\nstatic const ExportData devel_exports[] = {\n  {\"ACLOCAL_PATH\", \"/app/share/aclocal\"},\n  {\"C_INCLUDE_PATH\", \"/app/include\"},\n  {\"CPLUS_INCLUDE_PATH\", \"/app/include\"},\n  {\"LDFLAGS\", \"-L/app/lib \"},\n  {\"PKG_CONFIG_PATH\", \"/app/lib/pkgconfig:/app/share/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig\"},\n  {\"LC_ALL\", \"en_US.utf8\"},\n};\n\nstatic void\nadd_exports (GPtrArray        *env_array,\n             const ExportData *exports,\n             gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      if (exports[i].val)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", exports[i].env, exports[i].val));\n    }\n}\n\nchar **\nflatpak_run_get_minimal_env (gboolean devel, gboolean use_ld_so_cache)\n{\n  GPtrArray *env_array;\n  static const char * const copy[] = {\n    \"PWD\",\n    \"GDMSESSION\",\n    \"XDG_CURRENT_DESKTOP\",\n    \"XDG_SESSION_DESKTOP\",\n    \"DESKTOP_SESSION\",\n    \"EMAIL_ADDRESS\",\n    \"HOME\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"REAL_NAME\",\n    \"TERM\",\n    \"USER\",\n    \"USERNAME\",\n  };\n  static const char * const copy_nodevel[] = {\n    \"LANG\",\n    \"LANGUAGE\",\n    \"LC_ALL\",\n    \"LC_ADDRESS\",\n    \"LC_COLLATE\",\n    \"LC_CTYPE\",\n    \"LC_IDENTIFICATION\",\n    \"LC_MEASUREMENT\",\n    \"LC_MESSAGES\",\n    \"LC_MONETARY\",\n    \"LC_NAME\",\n    \"LC_NUMERIC\",\n    \"LC_PAPER\",\n    \"LC_TELEPHONE\",\n    \"LC_TIME\",\n  };\n  int i;\n\n  env_array = g_ptr_array_new_with_free_func (g_free);\n\n  add_exports (env_array, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    add_exports (env_array, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n\n  if (devel)\n    add_exports (env_array, devel_exports, G_N_ELEMENTS (devel_exports));\n\n  for (i = 0; i < G_N_ELEMENTS (copy); i++)\n    {\n      const char *current = g_getenv (copy[i]);\n      if (current)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy[i], current));\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (copy_nodevel); i++)\n        {\n          const char *current = g_getenv (copy_nodevel[i]);\n          if (current)\n            g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy_nodevel[i], current));\n        }\n    }\n\n  g_ptr_array_add (env_array, NULL);\n  return (char **) g_ptr_array_free (env_array, FALSE);\n}\n\nstatic char **\napply_exports (char            **envp,\n               const ExportData *exports,\n               gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      const char *value = exports[i].val;\n\n      if (value)\n        envp = g_environ_setenv (envp, exports[i].env, value, TRUE);\n      else\n        envp = g_environ_unsetenv (envp, exports[i].env);\n    }\n\n  return envp;\n}\n\nvoid\nflatpak_run_apply_env_default (FlatpakBwrap *bwrap, gboolean use_ld_so_cache)\n{\n  bwrap->envp = apply_exports (bwrap->envp, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    bwrap->envp = apply_exports (bwrap->envp, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n}\n\nstatic void\nflatpak_run_apply_env_prompt (FlatpakBwrap *bwrap, const char *app_id)\n{\n  /* A custom shell prompt. FLATPAK_ID is always set.\n   * PS1 can be overwritten by runtime metadata or by --env overrides\n   */\n  flatpak_bwrap_set_env (bwrap, \"FLATPAK_ID\", app_id, TRUE);\n  flatpak_bwrap_set_env (bwrap, \"PS1\", \"[\ud83d\udce6 $FLATPAK_ID \\\\W]\\\\$ \", FALSE);\n}\n\nvoid\nflatpak_run_apply_env_appid (FlatpakBwrap *bwrap,\n                             GFile        *app_dir)\n{\n  g_autoptr(GFile) app_dir_data = NULL;\n  g_autoptr(GFile) app_dir_config = NULL;\n  g_autoptr(GFile) app_dir_cache = NULL;\n\n  app_dir_data = g_file_get_child (app_dir, \"data\");\n  app_dir_config = g_file_get_child (app_dir, \"config\");\n  app_dir_cache = g_file_get_child (app_dir, \"cache\");\n  flatpak_bwrap_set_env (bwrap, \"XDG_DATA_HOME\", flatpak_file_get_path_cached (app_dir_data), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CONFIG_HOME\", flatpak_file_get_path_cached (app_dir_config), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CACHE_HOME\", flatpak_file_get_path_cached (app_dir_cache), TRUE);\n\n  if (g_getenv (\"XDG_DATA_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_DATA_HOME\", g_getenv (\"XDG_DATA_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CONFIG_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CONFIG_HOME\", g_getenv (\"XDG_CONFIG_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CACHE_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CACHE_HOME\", g_getenv (\"XDG_CACHE_HOME\"), TRUE);\n}\n\nvoid\nflatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n\n      if (val && val[0] != 0)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}\n\nGFile *\nflatpak_get_data_dir (const char *app_id)\n{\n  g_autoptr(GFile) home = g_file_new_for_path (g_get_home_dir ());\n  g_autoptr(GFile) var_app = g_file_resolve_relative_path (home, \".var/app\");\n\n  return g_file_get_child (var_app, app_id);\n}\n\ngboolean\nflatpak_ensure_data_dir (GFile        *app_id_dir,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  g_autoptr(GFile) data_dir = g_file_get_child (app_id_dir, \"data\");\n  g_autoptr(GFile) cache_dir = g_file_get_child (app_id_dir, \"cache\");\n  g_autoptr(GFile) fontconfig_cache_dir = g_file_get_child (cache_dir, \"fontconfig\");\n  g_autoptr(GFile) tmp_dir = g_file_get_child (cache_dir, \"tmp\");\n  g_autoptr(GFile) config_dir = g_file_get_child (app_id_dir, \"config\");\n\n  if (!flatpak_mkdir_p (data_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (fontconfig_cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (tmp_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (config_dir, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstruct JobData\n{\n  char      *job;\n  GMainLoop *main_loop;\n};\n\nstatic void\njob_removed_cb (SystemdManager *manager,\n                guint32         id,\n                char           *job,\n                char           *unit,\n                char           *result,\n                struct JobData *data)\n{\n  if (strcmp (job, data->job) == 0)\n    g_main_loop_quit (data->main_loop);\n}\n\nstatic gchar *\nsystemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}\n\ngboolean\nflatpak_run_in_transient_unit (const char *appid, GError **error)\n{\n  g_autoptr(GDBusConnection) conn = NULL;\n  g_autofree char *path = NULL;\n  g_autofree char *address = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *appid_escaped = NULL;\n  g_autofree char *job = NULL;\n  SystemdManager *manager = NULL;\n  GVariantBuilder builder;\n  GVariant *properties = NULL;\n  GVariant *aux = NULL;\n  guint32 pid;\n  GMainLoop *main_loop = NULL;\n  struct JobData data;\n  gboolean res = FALSE;\n  g_autoptr(GMainContextPopDefault) main_context = NULL;\n\n  path = g_strdup_printf (\"/run/user/%d/systemd/private\", getuid ());\n\n  if (!g_file_test (path, G_FILE_TEST_EXISTS))\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                               _(\"No systemd user session available, cgroups not available\"));\n\n  main_context = flatpak_main_context_new_default ();\n  main_loop = g_main_loop_new (main_context, FALSE);\n\n  address = g_strconcat (\"unix:path=\", path, NULL);\n\n  conn = g_dbus_connection_new_for_address_sync (address,\n                                                 G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,\n                                                 NULL,\n                                                 NULL, error);\n  if (!conn)\n    goto out;\n\n  manager = systemd_manager_proxy_new_sync (conn,\n                                            G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,\n                                            NULL,\n                                            \"/org/freedesktop/systemd1\",\n                                            NULL, error);\n  if (!manager)\n    goto out;\n\n  appid_escaped = systemd_unit_name_escape (appid);\n  name = g_strdup_printf (\"app-flatpak-%s-%d.scope\", appid_escaped, getpid ());\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a(sv)\"));\n\n  pid = getpid ();\n  g_variant_builder_add (&builder, \"(sv)\",\n                         \"PIDs\",\n                         g_variant_new_fixed_array (G_VARIANT_TYPE (\"u\"),\n                                                    &pid, 1, sizeof (guint32))\n                        );\n\n  properties = g_variant_builder_end (&builder);\n\n  aux = g_variant_new_array (G_VARIANT_TYPE (\"(sa(sv))\"), NULL, 0);\n\n  if (!systemd_manager_call_start_transient_unit_sync (manager,\n                                                       name,\n                                                       \"fail\",\n                                                       properties,\n                                                       aux,\n                                                       &job,\n                                                       NULL,\n                                                       error))\n    goto out;\n\n  data.job = job;\n  data.main_loop = main_loop;\n  g_signal_connect (manager, \"job-removed\", G_CALLBACK (job_removed_cb), &data);\n\n  g_main_loop_run (main_loop);\n\n  res = TRUE;\n\nout:\n  if (main_loop)\n    g_main_loop_unref (main_loop);\n  if (manager)\n    g_object_unref (manager);\n\n  return res;\n}\n\nstatic void\nadd_font_path_args (FlatpakBwrap *bwrap)\n{\n  g_autoptr(GString) xml_snippet = g_string_new (\"\");\n  gchar *path_build_tmp = NULL;\n  g_autoptr(GFile) user_font1 = NULL;\n  g_autoptr(GFile) user_font2 = NULL;\n  g_autoptr(GFile) user_font_cache = NULL;\n  g_auto(GStrv) system_cache_dirs = NULL;\n  gboolean found_cache = FALSE;\n  int i;\n\n\n  g_string_append (xml_snippet,\n                   \"<?xml version=\\\"1.0\\\"?>\\n\"\n                   \"<!DOCTYPE fontconfig SYSTEM \\\"fonts.dtd\\\">\\n\"\n                   \"<fontconfig>\\n\");\n\n  if (g_file_test (SYSTEM_FONTS_DIR, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", SYSTEM_FONTS_DIR, \"/run/host/fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/fonts</remap-dir>\\n\",\n                              SYSTEM_FONTS_DIR);\n    }\n\n  if (g_file_test (\"/usr/local/share/fonts\", G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/local/share/fonts\", \"/run/host/local-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/local-fonts</remap-dir>\\n\",\n                              \"/usr/local/share/fonts\");\n    }\n\n  system_cache_dirs = g_strsplit (SYSTEM_FONT_CACHE_DIRS, \":\", 0);\n  for (i = 0; system_cache_dirs[i] != NULL; i++)\n    {\n      if (g_file_test (system_cache_dirs[i], G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", system_cache_dirs[i], \"/run/host/fonts-cache\",\n                                  NULL);\n          found_cache = TRUE;\n          break;\n        }\n    }\n\n  if (!found_cache)\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/fonts-cache\",\n                              \"--remount-ro\", \"/run/host/fonts-cache\",\n                              NULL);\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_data_dir (), \"fonts\", NULL);\n  user_font1 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  path_build_tmp = g_build_filename (g_get_home_dir (), \".fonts\", NULL);\n  user_font2 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font1, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font1), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font1));\n    }\n  else if (g_file_query_exists (user_font2, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font2), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font2));\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_cache_dir (), \"fontconfig\", NULL);\n  user_font_cache = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font_cache, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font_cache), \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n  else\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/user-fonts-cache\",\n                              \"--remount-ro\", \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n\n  g_string_append (xml_snippet,\n                   \"</fontconfig>\\n\");\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"font-dirs.xml\", xml_snippet->str, xml_snippet->len, \"/run/host/font-dirs.xml\", NULL))\n    g_warning (\"Unable to add fontconfig data snippet\");\n}\n\nstatic void\nadd_icon_path_args (FlatpakBwrap *bwrap)\n{\n  g_autofree gchar *user_icons_path = NULL;\n  g_autoptr(GFile) user_icons = NULL;\n\n  if (g_file_test (\"/usr/share/icons\", G_FILE_TEST_IS_DIR))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/share/icons\", \"/run/host/share/icons\",\n                              NULL);\n    }\n\n  user_icons_path = g_build_filename (g_get_user_data_dir (), \"icons\", NULL);\n  user_icons = g_file_new_for_path (user_icons_path);\n  if (g_file_query_exists (user_icons, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_icons), \"/run/host/user-share/icons\",\n                              NULL);\n    }\n}\n\nFlatpakContext *\nflatpak_app_compute_permissions (GKeyFile *app_metadata,\n                                 GKeyFile *runtime_metadata,\n                                 GError  **error)\n{\n  g_autoptr(FlatpakContext) app_context = NULL;\n\n  app_context = flatpak_context_new ();\n\n  if (runtime_metadata != NULL)\n    {\n      if (!flatpak_context_load_metadata (app_context, runtime_metadata, error))\n        return NULL;\n\n      /* Don't inherit any permissions from the runtime, only things like env vars. */\n      flatpak_context_reset_permissions (app_context);\n    }\n\n  if (app_metadata != NULL &&\n      !flatpak_context_load_metadata (app_context, app_metadata, error))\n    return NULL;\n\n  return g_steal_pointer (&app_context);\n}\n\nstatic void\nflatpak_run_gc_ids (void)\n{\n  flatpak_instance_iterate_all_and_gc (NULL);\n}\n\nstatic char *\nflatpak_run_allocate_id (int *lock_fd_out)\n{\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *base_dir = g_build_filename (user_runtime_dir, \".flatpak\", NULL);\n  int count;\n\n  g_mkdir_with_parents (base_dir, 0755);\n\n  flatpak_run_gc_ids ();\n\n  for (count = 0; count < 1000; count++)\n    {\n      g_autofree char *instance_id = NULL;\n      g_autofree char *instance_dir = NULL;\n\n      instance_id = g_strdup_printf (\"%u\", g_random_int ());\n\n      instance_dir = g_build_filename (base_dir, instance_id, NULL);\n\n      /* We use an atomic mkdir to ensure the instance id is unique */\n      if (mkdir (instance_dir, 0755) == 0)\n        {\n          g_autofree char *lock_file = g_build_filename (instance_dir, \".ref\", NULL);\n          glnx_autofd int lock_fd = -1;\n          struct flock l = {\n            .l_type = F_RDLCK,\n            .l_whence = SEEK_SET,\n            .l_start = 0,\n            .l_len = 0\n          };\n\n          /* Then we take a file lock inside the dir, hold that during\n           * setup and in bwrap. Anyone trying to clean up unused\n           * directories need to first verify that there is a .ref\n           * file and take a write lock on .ref to ensure its not in\n           * use. */\n          lock_fd = open (lock_file, O_RDWR | O_CREAT | O_CLOEXEC, 0644);\n          /* There is a tiny race here between the open creating the file and the lock succeeding.\n             We work around that by only gc:ing \"old\" .ref files */\n          if (lock_fd != -1 && fcntl (lock_fd, F_SETLK, &l) == 0)\n            {\n              *lock_fd_out = glnx_steal_fd (&lock_fd);\n              g_debug (\"Allocated instance id %s\", instance_id);\n              return g_steal_pointer (&instance_id);\n            }\n        }\n    }\n\n  return NULL;\n}\n\n#ifdef HAVE_DCONF\n\nstatic void\nadd_dconf_key_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *key,\n                          DConfReadFlags flags)\n{\n  g_autofree char *group = g_path_get_dirname (key);\n  g_autofree char *k = g_path_get_basename (key);\n  GVariant *value = dconf_client_read_full (client, key, flags, NULL);\n\n  if (value)\n    {\n      g_autofree char *val = g_variant_print (value, TRUE);\n      g_key_file_set_value (keyfile, group + 1, k, val);\n    }\n}\n\nstatic void\nadd_dconf_dir_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *dir,\n                          DConfReadFlags flags)\n{\n  g_auto(GStrv) keys = NULL;\n  int i;\n\n  keys = dconf_client_list (client, dir, NULL);\n  for (i = 0; keys[i]; i++)\n    {\n      g_autofree char *k = g_strconcat (dir, keys[i], NULL);\n      if (dconf_is_dir (k, NULL))\n        add_dconf_dir_to_keyfile (keyfile, client, k, flags);\n      else if (dconf_is_key (k, NULL))\n        add_dconf_key_to_keyfile (keyfile, client, k, flags);\n    }\n}\n\nstatic void\nadd_dconf_locks_to_list (GString     *s,\n                         DConfClient *client,\n                         const char  *dir)\n{\n  g_auto(GStrv) locks = NULL;\n  int i;\n\n  locks = dconf_client_list_locks (client, dir, NULL);\n  for (i = 0; locks[i]; i++)\n    {\n      g_string_append (s, locks[i]);\n      g_string_append_c (s, '\\n');\n    }\n}\n\n#endif /* HAVE_DCONF */\n\nstatic void\nget_dconf_data (const char  *app_id,\n                const char **paths,\n                const char  *migrate_path,\n                char       **defaults,\n                gsize       *defaults_size,\n                char       **values,\n                gsize       *values_size,\n                char       **locks,\n                gsize       *locks_size)\n{\n#ifdef HAVE_DCONF\n  DConfClient *client = NULL;\n  g_autofree char *prefix = NULL;\n#endif\n  g_autoptr(GKeyFile) defaults_data = NULL;\n  g_autoptr(GKeyFile) values_data = NULL;\n  g_autoptr(GString) locks_data = NULL;\n\n  defaults_data = g_key_file_new ();\n  values_data = g_key_file_new ();\n  locks_data = g_string_new (\"\");\n\n#ifdef HAVE_DCONF\n\n  client = dconf_client_new ();\n\n  prefix = flatpak_dconf_path_for_app_id (app_id);\n\n  if (migrate_path)\n    {\n      g_debug (\"Add values in dir '%s', prefix is '%s'\", migrate_path, prefix);\n      if (flatpak_dconf_path_is_similar (migrate_path, prefix))\n        add_dconf_dir_to_keyfile (values_data, client, migrate_path, DCONF_READ_USER_VALUE);\n      else\n        g_warning (\"Ignoring D-Conf migrate-path setting %s\", migrate_path);\n    }\n\n  g_debug (\"Add defaults in dir %s\", prefix);\n  add_dconf_dir_to_keyfile (defaults_data, client, prefix, DCONF_READ_DEFAULT_VALUE);\n\n  g_debug (\"Add locks in dir %s\", prefix);\n  add_dconf_locks_to_list (locks_data, client, prefix);\n\n  /* We allow extra paths for defaults and locks, but not for user values */\n  if (paths)\n    {\n      int i;\n      for (i = 0; paths[i]; i++)\n        {\n          if (dconf_is_dir (paths[i], NULL))\n            {\n              g_debug (\"Add defaults in dir %s\", paths[i]);\n              add_dconf_dir_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n\n              g_debug (\"Add locks in dir %s\", paths[i]);\n              add_dconf_locks_to_list (locks_data, client, paths[i]);\n            }\n          else if (dconf_is_key (paths[i], NULL))\n            {\n              g_debug (\"Add individual key %s\", paths[i]);\n              add_dconf_key_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n              add_dconf_key_to_keyfile (values_data, client, paths[i], DCONF_READ_USER_VALUE);\n            }\n          else\n            {\n              g_warning (\"Ignoring settings path '%s': neither dir nor key\", paths[i]);\n            }\n        }\n    }\n#endif\n\n  *defaults = g_key_file_to_data (defaults_data, defaults_size, NULL);\n  *values = g_key_file_to_data (values_data, values_size, NULL);\n  *locks_size = locks_data->len;\n  *locks = g_string_free (g_steal_pointer (&locks_data), FALSE);\n\n#ifdef HAVE_DCONF\n  g_object_unref (client);\n#endif\n}\n\nstatic gboolean\nflatpak_run_add_dconf_args (FlatpakBwrap *bwrap,\n                            const char   *app_id,\n                            GKeyFile     *metakey,\n                            GError      **error)\n{\n  g_auto(GStrv) paths = NULL;\n  g_autofree char *migrate_path = NULL;\n  g_autofree char *defaults = NULL;\n  g_autofree char *values = NULL;\n  g_autofree char *locks = NULL;\n  gsize defaults_size;\n  gsize values_size;\n  gsize locks_size;\n\n  if (metakey)\n    {\n      paths = g_key_file_get_string_list (metakey,\n                                          FLATPAK_METADATA_GROUP_DCONF,\n                                          FLATPAK_METADATA_KEY_DCONF_PATHS,\n                                          NULL, NULL);\n      migrate_path = g_key_file_get_string (metakey,\n                                            FLATPAK_METADATA_GROUP_DCONF,\n                                            FLATPAK_METADATA_KEY_DCONF_MIGRATE_PATH,\n                                            NULL);\n    }\n\n  get_dconf_data (app_id,\n                  (const char **) paths,\n                  migrate_path,\n                  &defaults, &defaults_size,\n                  &values, &values_size,\n                  &locks, &locks_size);\n\n  if (defaults_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-defaults\",\n                                    defaults, defaults_size,\n                                    \"/etc/glib-2.0/settings/defaults\",\n                                    error))\n    return FALSE;\n\n  if (locks_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-locks\",\n                                    locks, locks_size,\n                                    \"/etc/glib-2.0/settings/locks\",\n                                    error))\n    return FALSE;\n\n  /* We do a one-time conversion of existing dconf settings to a keyfile.\n   * Only do that once the app stops requesting dconf access.\n   */\n  if (migrate_path)\n    {\n      g_autofree char *filename = NULL;\n\n      filename = g_build_filename (g_get_home_dir (),\n                                   \".var/app\", app_id,\n                                   \"config/glib-2.0/settings/keyfile\",\n                                   NULL);\n\n      g_debug (\"writing D-Conf values to %s\", filename);\n\n      if (values_size != 0 && !g_file_test (filename, G_FILE_TEST_EXISTS))\n        {\n          g_autofree char *dir = g_path_get_dirname (filename);\n\n          if (g_mkdir_with_parents (dir, 0700) == -1)\n            {\n              g_warning (\"failed creating dirs for %s\", filename);\n              return FALSE;\n            }\n\n          if (!g_file_set_contents (filename, values, values_size, error))\n            {\n              g_warning (\"failed writing %s\", filename);\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_add_app_info_args (FlatpakBwrap       *bwrap,\n                               GFile              *app_files,\n                               GBytes             *app_deploy_data,\n                               const char         *app_extensions,\n                               GFile              *runtime_files,\n                               GBytes             *runtime_deploy_data,\n                               const char         *runtime_extensions,\n                               const char         *app_id,\n                               const char         *app_branch,\n                               FlatpakDecomposed  *runtime_ref,\n                               GFile              *app_id_dir,\n                               FlatpakContext     *final_app_context,\n                               FlatpakContext     *cmdline_context,\n                               gboolean            sandbox,\n                               gboolean            build,\n                               gboolean            devel,\n                               char              **app_info_path_out,\n                               int                 instance_id_fd,\n                               char              **instance_id_host_dir_out,\n                               GError             **error)\n{\n  g_autofree char *info_path = NULL;\n  g_autofree char *bwrapinfo_path = NULL;\n  int fd, fd2, fd3;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree char *runtime_path = NULL;\n  g_autofree char *old_dest = g_strdup_printf (\"/run/user/%d/flatpak-info\", getuid ());\n  const char *group;\n  g_autofree char *instance_id = NULL;\n  glnx_autofd int lock_fd = -1;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autofree char *instance_id_sandbox_dir = NULL;\n  g_autofree char *instance_id_lock_file = NULL;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  instance_id = flatpak_run_allocate_id (&lock_fd);\n  if (instance_id == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Unable to allocate instance id\"));\n\n  instance_id_host_dir = g_build_filename (user_runtime_dir, \".flatpak\", instance_id, NULL);\n  instance_id_sandbox_dir = g_strdup_printf (\"/run/user/%d/.flatpak/%s\", getuid (), instance_id);\n  instance_id_lock_file = g_build_filename (instance_id_sandbox_dir, \".ref\", NULL);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\",\n                          instance_id_host_dir,\n                          instance_id_sandbox_dir,\n                          \"--lock-file\",\n                          instance_id_lock_file,\n                          NULL);\n  /* Keep the .ref lock held until we've started bwrap to avoid races */\n  flatpak_bwrap_add_noinherit_fd (bwrap, glnx_steal_fd (&lock_fd));\n\n  info_path = g_build_filename (instance_id_host_dir, \"info\", NULL);\n\n  keyfile = g_key_file_new ();\n\n  if (app_files)\n    group = FLATPAK_METADATA_GROUP_APPLICATION;\n  else\n    group = FLATPAK_METADATA_GROUP_RUNTIME;\n\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_NAME, app_id);\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_RUNTIME,\n                         flatpak_decomposed_get_ref (runtime_ref));\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_INSTANCE_ID, instance_id);\n  if (app_id_dir)\n    {\n      g_autofree char *instance_path = g_file_get_path (app_id_dir);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_INSTANCE_PATH, instance_path);\n    }\n\n  if (app_files)\n    {\n      g_autofree char *app_path = g_file_get_path (app_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_APP_PATH, app_path);\n    }\n  if (app_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_COMMIT, flatpak_deploy_data_get_commit (app_deploy_data));\n  if (app_extensions && *app_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_EXTENSIONS, app_extensions);\n  runtime_path = g_file_get_path (runtime_files);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_RUNTIME_PATH, runtime_path);\n  if (runtime_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_COMMIT, flatpak_deploy_data_get_commit (runtime_deploy_data));\n  if (runtime_extensions && *runtime_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_EXTENSIONS, runtime_extensions);\n  if (app_branch != NULL)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_BRANCH, app_branch);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_ARCH, arch);\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_FLATPAK_VERSION, PACKAGE_VERSION);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SESSION_BUS_PROXY, TRUE);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SYSTEM_BUS_PROXY, TRUE);\n\n  if (sandbox)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SANDBOX, TRUE);\n  if (build)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_BUILD, TRUE);\n  if (devel)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_DEVEL, TRUE);\n\n  if (cmdline_context)\n    {\n      g_autoptr(GPtrArray) cmdline_args = g_ptr_array_new_with_free_func (g_free);\n      flatpak_context_to_args (cmdline_context, cmdline_args);\n      if (cmdline_args->len > 0)\n        {\n          g_key_file_set_string_list (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_EXTRA_ARGS,\n                                      (const char * const *) cmdline_args->pdata,\n                                      cmdline_args->len);\n        }\n    }\n\n  flatpak_context_save_metadata (final_app_context, TRUE, keyfile);\n\n  if (!g_key_file_save_to_file (keyfile, info_path, error))\n    return FALSE;\n\n  /* We want to create a file on /.flatpak-info that the app cannot modify, which\n     we do by creating a read-only bind mount. This way one can openat()\n     /proc/$pid/root, and if that succeeds use openat via that to find the\n     unfakable .flatpak-info file. However, there is a tiny race in that if\n     you manage to open /proc/$pid/root, but then the pid dies, then\n     every mount but the root is unmounted in the namespace, so the\n     .flatpak-info will be empty. We fix this by first creating a real file\n     with the real info in, then bind-mounting on top of that, the same info.\n     This way even if the bind-mount is unmounted we can find the real data.\n   */\n\n  fd = open (info_path, O_RDONLY);\n  if (fd == -1)\n    {\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  fd2 = open (info_path, O_RDONLY);\n  if (fd2 == -1)\n    {\n      close (fd);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--file\", fd, \"/.flatpak-info\");\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--ro-bind-data\", fd2, \"/.flatpak-info\");\n  flatpak_bwrap_add_args (bwrap,\n                          \"--symlink\", \"../../../.flatpak-info\", old_dest,\n                          NULL);\n\n  /* Tell the application that it's running under Flatpak in a generic way. */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--setenv\", \"container\", \"flatpak\",\n                          NULL);\n  if (!flatpak_bwrap_add_args_data (bwrap,\n                                    \"container-manager\",\n                                    \"flatpak\\n\", -1,\n                                    \"/run/host/container-manager\",\n                                    error))\n    return FALSE;\n\n  bwrapinfo_path = g_build_filename (instance_id_host_dir, \"bwrapinfo.json\", NULL);\n  fd3 = open (bwrapinfo_path, O_RDWR | O_CREAT, 0644);\n  if (fd3 == -1)\n    {\n      close (fd);\n      close (fd2);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open bwrapinfo.json file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  /* NOTE: It is important that this takes place after bwrapinfo.json is created,\n     otherwise start notifications in the portal may not work. */\n  if (instance_id_fd != -1)\n    {\n      gsize instance_id_position = 0;\n      gsize instance_id_size = strlen (instance_id);\n\n      while (instance_id_size > 0)\n        {\n          gssize bytes_written = write (instance_id_fd, instance_id + instance_id_position, instance_id_size);\n          if (G_UNLIKELY (bytes_written <= 0))\n            {\n              int errsv = bytes_written == -1 ? errno : ENOSPC;\n              if (errsv == EINTR)\n                continue;\n\n              close (fd);\n              close (fd2);\n              close (fd3);\n\n              g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                           _(\"Failed to write to instance id fd: %s\"), g_strerror (errsv));\n              return FALSE;\n            }\n\n          instance_id_position += bytes_written;\n          instance_id_size -= bytes_written;\n        }\n\n      close (instance_id_fd);\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--info-fd\", fd3, NULL);\n\n  if (app_info_path_out != NULL)\n    *app_info_path_out = g_strdup_printf (\"/proc/self/fd/%d\", fd);\n\n  if (instance_id_host_dir_out != NULL)\n    *instance_id_host_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n\nstatic void\nadd_tzdata_args (FlatpakBwrap *bwrap,\n                 GFile *runtime_files)\n{\n  g_autofree char *raw_timezone = flatpak_get_timezone ();\n  g_autofree char *timezone_content = g_strdup_printf (\"%s\\n\", raw_timezone);\n  g_autofree char *localtime_content = g_strconcat (\"../usr/share/zoneinfo/\", raw_timezone, NULL);\n  g_autoptr(GFile) runtime_zoneinfo = NULL;\n\n  if (runtime_files)\n    runtime_zoneinfo = g_file_resolve_relative_path (runtime_files, \"share/zoneinfo\");\n\n  /* Check for runtime /usr/share/zoneinfo */\n  if (runtime_zoneinfo != NULL && g_file_query_exists (runtime_zoneinfo, NULL))\n    {\n      /* Check for host /usr/share/zoneinfo */\n      if (g_file_test (\"/usr/share/zoneinfo\", G_FILE_TEST_IS_DIR))\n        {\n          /* Here we assume the host timezone file exist in the host data */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", \"/usr/share/zoneinfo\", \"/usr/share/zoneinfo\",\n                                  \"--symlink\", localtime_content, \"/etc/localtime\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) runtime_tzfile = g_file_resolve_relative_path (runtime_zoneinfo, raw_timezone);\n\n          /* Check if host timezone file exist in the runtime tzdata */\n          if (g_file_query_exists (runtime_tzfile, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--symlink\", localtime_content, \"/etc/localtime\",\n                                    NULL);\n        }\n    }\n\n  flatpak_bwrap_add_args_data (bwrap, \"timezone\",\n                               timezone_content, -1, \"/etc/timezone\",\n                               NULL);\n}\n\nstatic void\nadd_monitor_path_args (gboolean      use_session_helper,\n                       FlatpakBwrap *bwrap)\n{\n  g_autoptr(AutoFlatpakSessionHelper) session_helper = NULL;\n  g_autofree char *monitor_path = NULL;\n  g_autofree char *pkcs11_socket_path = NULL;\n  g_autoptr(GVariant) session_data = NULL;\n\n  if (use_session_helper)\n    {\n      session_helper =\n        flatpak_session_helper_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION,\n                                                       G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES | G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,\n                                                       \"org.freedesktop.Flatpak\",\n                                                       \"/org/freedesktop/Flatpak/SessionHelper\",\n                                                       NULL, NULL);\n    }\n\n  if (session_helper &&\n      flatpak_session_helper_call_request_session_sync (session_helper,\n                                                        &session_data,\n                                                        NULL, NULL))\n    {\n      if (g_variant_lookup (session_data, \"path\", \"s\", &monitor_path))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", monitor_path, \"/run/host/monitor\",\n                                \"--symlink\", \"/run/host/monitor/resolv.conf\", \"/etc/resolv.conf\",\n                                \"--symlink\", \"/run/host/monitor/host.conf\", \"/etc/host.conf\",\n                                \"--symlink\", \"/run/host/monitor/hosts\", \"/etc/hosts\",\n                                NULL);\n\n      if (g_variant_lookup (session_data, \"pkcs11-socket\", \"s\", &pkcs11_socket_path))\n        {\n          g_autofree char *sandbox_pkcs11_socket_path = g_strdup_printf (\"/run/user/%d/p11-kit/pkcs11\", getuid ());\n          const char *trusted_module_contents =\n            \"# This overrides the runtime p11-kit-trusted module with a client one talking to the trust module on the host\\n\"\n            \"module: p11-kit-client.so\\n\";\n\n          if (flatpak_bwrap_add_args_data (bwrap, \"p11-kit-trust.module\",\n                                           trusted_module_contents, -1,\n                                           \"/etc/pkcs11/modules/p11-kit-trust.module\", NULL))\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--ro-bind\", pkcs11_socket_path, sandbox_pkcs11_socket_path,\n                                      NULL);\n              flatpak_bwrap_unset_env (bwrap, \"P11_KIT_SERVER_ADDRESS\");\n            }\n        }\n    }\n  else\n    {\n      if (g_file_test (\"/etc/resolv.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/resolv.conf\", \"/etc/resolv.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/host.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/host.conf\", \"/etc/host.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/hosts\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/hosts\", \"/etc/hosts\",\n                                NULL);\n    }\n}\n\nstatic void\nadd_document_portal_args (FlatpakBwrap *bwrap,\n                          const char   *app_id,\n                          char        **out_mount_path)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *doc_mount_path = NULL;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GDBusMessage) reply = NULL;\n      g_autoptr(GDBusMessage) msg =\n        g_dbus_message_new_method_call (\"org.freedesktop.portal.Documents\",\n                                        \"/org/freedesktop/portal/documents\",\n                                        \"org.freedesktop.portal.Documents\",\n                                        \"GetMountPoint\");\n      g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n      reply =\n        g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                        G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                        30000,\n                                                        NULL,\n                                                        NULL,\n                                                        NULL);\n      if (reply)\n        {\n          if (g_dbus_message_to_gerror (reply, &local_error))\n            {\n              if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n                g_debug (\"Document portal not available, not mounting /run/user/%d/doc\", getuid ());\n              else\n                g_message (\"Can't get document portal: %s\", local_error->message);\n            }\n          else\n            {\n              g_autofree char *src_path = NULL;\n              g_autofree char *dst_path = NULL;\n              g_variant_get (g_dbus_message_get_body (reply),\n                             \"(^ay)\", &doc_mount_path);\n\n              src_path = g_strdup_printf (\"%s/by-app/%s\",\n                                          doc_mount_path, app_id);\n              dst_path = g_strdup_printf (\"/run/user/%d/doc\", getuid ());\n              flatpak_bwrap_add_args (bwrap, \"--bind\", src_path, dst_path, NULL);\n            }\n        }\n    }\n\n  *out_mount_path = g_steal_pointer (&doc_mount_path);\n}\n\n#ifdef ENABLE_SECCOMP\nstatic const uint32_t seccomp_x86_64_extra_arches[] = { SCMP_ARCH_X86, 0, };\n\n#ifdef SCMP_ARCH_AARCH64\nstatic const uint32_t seccomp_aarch64_extra_arches[] = { SCMP_ARCH_ARM, 0 };\n#endif\n\nstatic inline void\ncleanup_seccomp (void *p)\n{\n  scmp_filter_ctx *pp = (scmp_filter_ctx *) p;\n\n  if (*pp)\n    seccomp_release (*pp);\n}\n\nstatic gboolean\nsetup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}\n#endif\n\nstatic void\nflatpak_run_setup_usr_links (FlatpakBwrap *bwrap,\n                             GFile        *runtime_files)\n{\n  int i;\n\n  if (runtime_files == NULL)\n    return;\n\n  for (i = 0; flatpak_abs_usrmerged_dirs[i] != NULL; i++)\n    {\n      const char *subdir = flatpak_abs_usrmerged_dirs[i];\n      g_autoptr(GFile) runtime_subdir = NULL;\n\n      g_assert (subdir[0] == '/');\n      /* Skip the '/' when using as a subdirectory of the runtime */\n      runtime_subdir = g_file_get_child (runtime_files, subdir + 1);\n\n      if (g_file_query_exists (runtime_subdir, NULL))\n        {\n          g_autofree char *link = g_strconcat (\"usr\", subdir, NULL);\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--symlink\", link, subdir,\n                                  NULL);\n        }\n    }\n}\n\ngboolean\nflatpak_run_setup_base_argv (FlatpakBwrap   *bwrap,\n                             GFile          *runtime_files,\n                             GFile          *app_id_dir,\n                             const char     *arch,\n                             FlatpakRunFlags flags,\n                             GError        **error)\n{\n  g_autofree char *run_dir = NULL;\n  g_autofree char *passwd_contents = NULL;\n  g_autoptr(GString) group_contents = NULL;\n  const char *pkcs11_conf_contents = NULL;\n  struct group *g;\n  gulong pers;\n  gid_t gid = getgid ();\n  g_autoptr(GFile) etc = NULL;\n\n  run_dir = g_strdup_printf (\"/run/user/%d\", getuid ());\n\n  passwd_contents = g_strdup_printf (\"%s:x:%d:%d:%s:%s:%s\\n\"\n                                     \"nfsnobody:x:65534:65534:Unmapped user:/:/sbin/nologin\\n\",\n                                     g_get_user_name (),\n                                     getuid (), gid,\n                                     g_get_real_name (),\n                                     g_get_home_dir (),\n                                     DEFAULT_SHELL);\n\n  group_contents = g_string_new (\"\");\n  g = getgrgid (gid);\n  /* if NULL, the primary group is not known outside the container, so\n   * it might as well stay unknown inside the container... */\n  if (g != NULL)\n    g_string_append_printf (group_contents, \"%s:x:%d:%s\\n\",\n                            g->gr_name, gid, g_get_user_name ());\n  g_string_append (group_contents, \"nfsnobody:x:65534:\\n\");\n\n  pkcs11_conf_contents =\n    \"# Disable user pkcs11 config, because the host modules don't work in the runtime\\n\"\n    \"user-config: none\\n\";\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_PROC) == 0)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--proc\", \"/proc\",\n                            NULL);\n\n  if (!(flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS))\n    flatpak_bwrap_add_arg (bwrap, \"--unshare-pid\");\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--dir\", \"/tmp\",\n                          \"--dir\", \"/var/tmp\",\n                          \"--dir\", \"/run/host\",\n                          \"--dir\", run_dir,\n                          \"--setenv\", \"XDG_RUNTIME_DIR\", run_dir,\n                          \"--symlink\", \"../run\", \"/var/run\",\n                          \"--ro-bind\", \"/sys/block\", \"/sys/block\",\n                          \"--ro-bind\", \"/sys/bus\", \"/sys/bus\",\n                          \"--ro-bind\", \"/sys/class\", \"/sys/class\",\n                          \"--ro-bind\", \"/sys/dev\", \"/sys/dev\",\n                          \"--ro-bind\", \"/sys/devices\", \"/sys/devices\",\n                          \"--ro-bind-try\", \"/proc/self/ns/user\", \"/run/.userns\",\n                          /* glib uses this like /etc/timezone */\n                          \"--symlink\", \"/etc/timezone\", \"/var/db/zoneinfo\",\n                          NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_DIE_WITH_PARENT)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--die-with-parent\",\n                            NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/usr/etc\",\n                            \"--symlink\", \"usr/etc\", \"/etc\",\n                            NULL);\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"passwd\", passwd_contents, -1, \"/etc/passwd\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"group\", group_contents->str, -1, \"/etc/group\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"pkcs11.conf\", pkcs11_conf_contents, -1, \"/etc/pkcs11/pkcs11.conf\", error))\n    return FALSE;\n\n  if (g_file_test (\"/etc/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/etc/machine-id\", \"/etc/machine-id\", NULL);\n  else if (g_file_test (\"/var/lib/dbus/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/var/lib/dbus/machine-id\", \"/etc/machine-id\", NULL);\n\n  if (runtime_files)\n    etc = g_file_get_child (runtime_files, \"etc\");\n  if (etc != NULL &&\n      (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0 &&\n      g_file_query_exists (etc, NULL))\n    {\n      g_auto(GLnxDirFdIterator) dfd_iter = { 0, };\n      struct dirent *dent;\n      gboolean inited;\n\n      inited = glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (etc), FALSE, &dfd_iter, NULL);\n\n      while (inited)\n        {\n          g_autofree char *src = NULL;\n          g_autofree char *dest = NULL;\n\n          if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dfd_iter, &dent, NULL, NULL) || dent == NULL)\n            break;\n\n          if (strcmp (dent->d_name, \"passwd\") == 0 ||\n              strcmp (dent->d_name, \"group\") == 0 ||\n              strcmp (dent->d_name, \"machine-id\") == 0 ||\n              strcmp (dent->d_name, \"resolv.conf\") == 0 ||\n              strcmp (dent->d_name, \"host.conf\") == 0 ||\n              strcmp (dent->d_name, \"hosts\") == 0 ||\n              strcmp (dent->d_name, \"localtime\") == 0 ||\n              strcmp (dent->d_name, \"timezone\") == 0 ||\n              strcmp (dent->d_name, \"pkcs11\") == 0)\n            continue;\n\n          src = g_build_filename (flatpak_file_get_path_cached (etc), dent->d_name, NULL);\n          dest = g_build_filename (\"/etc\", dent->d_name, NULL);\n          if (dent->d_type == DT_LNK)\n            {\n              g_autofree char *target = NULL;\n\n              target = glnx_readlinkat_malloc (dfd_iter.fd, dent->d_name,\n                                               NULL, error);\n              if (target == NULL)\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap, \"--symlink\", target, dest, NULL);\n            }\n          else\n            {\n              flatpak_bwrap_add_args (bwrap, \"--ro-bind\", src, dest, NULL);\n            }\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autoptr(GFile) app_cache_dir = g_file_get_child (app_id_dir, \"cache\");\n      g_autoptr(GFile) app_tmp_dir = g_file_get_child (app_cache_dir, \"tmp\");\n      g_autoptr(GFile) app_data_dir = g_file_get_child (app_id_dir, \"data\");\n      g_autoptr(GFile) app_config_dir = g_file_get_child (app_id_dir, \"config\");\n\n      flatpak_bwrap_add_args (bwrap,\n                              /* These are nice to have as a fixed path */\n                              \"--bind\", flatpak_file_get_path_cached (app_cache_dir), \"/var/cache\",\n                              \"--bind\", flatpak_file_get_path_cached (app_data_dir), \"/var/data\",\n                              \"--bind\", flatpak_file_get_path_cached (app_config_dir), \"/var/config\",\n                              \"--bind\", flatpak_file_get_path_cached (app_tmp_dir), \"/var/tmp\",\n                              NULL);\n    }\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files);\n\n  add_tzdata_args (bwrap, runtime_files);\n\n  pers = PER_LINUX;\n\n  if ((flags & FLATPAK_RUN_FLAG_SET_PERSONALITY) &&\n      flatpak_is_linux32_arch (arch))\n    {\n      g_debug (\"Setting personality linux32\");\n      pers = PER_LINUX32;\n    }\n\n  /* Always set the personallity, and clear all weird flags */\n  personality (pers);\n\n#ifdef ENABLE_SECCOMP\n  if (!setup_seccomp (bwrap, arch, pers, flags, error))\n    return FALSE;\n#endif\n\n  if ((flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0)\n    add_monitor_path_args ((flags & FLATPAK_RUN_FLAG_NO_SESSION_HELPER) == 0, bwrap);\n\n  return TRUE;\n}\n\nstatic gboolean\nforward_file (XdpDbusDocuments *documents,\n              const char       *app_id,\n              const char       *file,\n              char            **out_doc_id,\n              GError          **error)\n{\n  int fd, fd_id;\n  g_autofree char *doc_id = NULL;\n  g_autoptr(GUnixFDList) fd_list = NULL;\n  const char *perms[] = { \"read\", \"write\", NULL };\n\n  fd = open (file, O_PATH | O_CLOEXEC);\n  if (fd == -1)\n    return flatpak_fail (error, _(\"Failed to open \u2018%s\u2019\"), file);\n\n  fd_list = g_unix_fd_list_new ();\n  fd_id = g_unix_fd_list_append (fd_list, fd, error);\n  close (fd);\n\n  if (!xdp_dbus_documents_call_add_sync (documents,\n                                         g_variant_new (\"h\", fd_id),\n                                         TRUE, /* reuse */\n                                         FALSE, /* not persistent */\n                                         fd_list,\n                                         &doc_id,\n                                         NULL,\n                                         NULL,\n                                         error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  if (!xdp_dbus_documents_call_grant_permissions_sync (documents,\n                                                       doc_id,\n                                                       app_id,\n                                                       perms,\n                                                       NULL,\n                                                       error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  *out_doc_id = g_steal_pointer (&doc_id);\n\n  return TRUE;\n}\n\nstatic gboolean\nadd_rest_args (FlatpakBwrap   *bwrap,\n               const char     *app_id,\n               FlatpakExports *exports,\n               gboolean        file_forwarding,\n               const char     *doc_mount_path,\n               char           *args[],\n               int             n_args,\n               GError        **error)\n{\n  g_autoptr(XdpDbusDocuments) documents = NULL;\n  gboolean forwarding = FALSE;\n  gboolean forwarding_uri = FALSE;\n  gboolean can_forward = TRUE;\n  int i;\n\n  if (file_forwarding && doc_mount_path == NULL)\n    {\n      g_message (\"Can't get document portal mount path\");\n      can_forward = FALSE;\n    }\n  else if (file_forwarding)\n    {\n      g_autoptr(GError) local_error = NULL;\n\n      documents = xdp_dbus_documents_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION, 0,\n                                                             \"org.freedesktop.portal.Documents\",\n                                                             \"/org/freedesktop/portal/documents\",\n                                                             NULL,\n                                                             &local_error);\n      if (documents == NULL)\n        {\n          g_message (\"Can't get document portal: %s\", local_error->message);\n          can_forward = FALSE;\n        }\n    }\n\n  for (i = 0; i < n_args; i++)\n    {\n      g_autoptr(GFile) file = NULL;\n\n      if (file_forwarding &&\n          (strcmp (args[i], \"@@\") == 0 ||\n           strcmp (args[i], \"@@u\") == 0))\n        {\n          forwarding_uri = strcmp (args[i], \"@@u\") == 0;\n          forwarding = !forwarding;\n          continue;\n        }\n\n      if (can_forward && forwarding)\n        {\n          if (forwarding_uri)\n            {\n              if (g_str_has_prefix (args[i], \"file:\"))\n                file = g_file_new_for_uri (args[i]);\n              else if (G_IS_DIR_SEPARATOR (args[i][0]))\n                file = g_file_new_for_path (args[i]);\n            }\n          else\n            file = g_file_new_for_path (args[i]);\n        }\n\n      if (file && !flatpak_exports_path_is_visible (exports,\n                                                    flatpak_file_get_path_cached (file)))\n        {\n          g_autofree char *doc_id = NULL;\n          g_autofree char *basename = NULL;\n          g_autofree char *doc_path = NULL;\n          if (!forward_file (documents, app_id, flatpak_file_get_path_cached (file),\n                             &doc_id, error))\n            return FALSE;\n\n          basename = g_file_get_basename (file);\n          doc_path = g_build_filename (doc_mount_path, doc_id, basename, NULL);\n\n          if (forwarding_uri)\n            {\n              g_autofree char *path = doc_path;\n              doc_path = g_filename_to_uri (path, NULL, NULL);\n              /* This should never fail */\n              g_assert (doc_path != NULL);\n            }\n\n          g_debug (\"Forwarding file '%s' as '%s' to %s\", args[i], doc_path, app_id);\n          flatpak_bwrap_add_arg (bwrap, doc_path);\n        }\n      else\n        flatpak_bwrap_add_arg (bwrap, args[i]);\n    }\n\n  return TRUE;\n}\n\nFlatpakContext *\nflatpak_context_load_for_deploy (FlatpakDeploy *deploy,\n                                 GError       **error)\n{\n  g_autoptr(FlatpakContext) context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n  context = flatpak_app_compute_permissions (metakey, NULL, error);\n  if (context == NULL)\n    return NULL;\n\n  overrides = flatpak_deploy_get_overrides (deploy);\n  flatpak_context_merge (context, overrides);\n\n  return g_steal_pointer (&context);\n}\n\nstatic char *\ncalculate_ld_cache_checksum (GBytes   *app_deploy_data,\n                             GBytes   *runtime_deploy_data,\n                             const char *app_extensions,\n                             const char *runtime_extensions)\n{\n  g_autoptr(GChecksum) ld_so_checksum = g_checksum_new (G_CHECKSUM_SHA256);\n  if (app_deploy_data)\n    g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (app_deploy_data), -1);\n  g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (runtime_deploy_data), -1);\n  if (app_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) app_extensions, -1);\n  if (runtime_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) runtime_extensions, -1);\n\n  return g_strdup (g_checksum_get_string (ld_so_checksum));\n}\n\nstatic gboolean\nadd_ld_so_conf (FlatpakBwrap *bwrap,\n                GError      **error)\n{\n  const char *contents =\n    \"include /run/flatpak/ld.so.conf.d/app-*.conf\\n\"\n    \"include /app/etc/ld.so.conf\\n\"\n    \"/app/lib\\n\"\n    \"include /run/flatpak/ld.so.conf.d/runtime-*.conf\\n\";\n\n  return flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                      contents, -1, \"/etc/ld.so.conf\", error);\n}\n\nstatic int\nregenerate_ld_cache (GPtrArray    *base_argv_array,\n                     GArray       *base_fd_array,\n                     GFile        *app_id_dir,\n                     const char   *checksum,\n                     GFile        *runtime_files,\n                     gboolean      generate_ld_so_conf,\n                     GCancellable *cancellable,\n                     GError      **error)\n{\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_autoptr(GArray) combined_fd_array = NULL;\n  g_autoptr(GFile) ld_so_cache = NULL;\n  g_autoptr(GFile) ld_so_cache_tmp = NULL;\n  g_autofree char *sandbox_cache_path = NULL;\n  g_autofree char *tmp_basename = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  g_autofree char *commandline = NULL;\n  int exit_status;\n  glnx_autofd int ld_so_fd = -1;\n  g_autoptr(GFile) ld_so_dir = NULL;\n\n  if (app_id_dir)\n    ld_so_dir = g_file_get_child (app_id_dir, \".ld.so\");\n  else\n    {\n      g_autoptr(GFile) base_dir = g_file_new_for_path (g_get_user_cache_dir ());\n      ld_so_dir = g_file_resolve_relative_path (base_dir, \"flatpak/ld.so\");\n    }\n\n  ld_so_cache = g_file_get_child (ld_so_dir, checksum);\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache), O_RDONLY);\n  if (ld_so_fd >= 0)\n    return glnx_steal_fd (&ld_so_fd);\n\n  g_debug (\"Regenerating ld.so.cache %s\", flatpak_file_get_path_cached (ld_so_cache));\n\n  if (!flatpak_mkdir_p (ld_so_dir, cancellable, error))\n    return FALSE;\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n\n  flatpak_bwrap_append_args (bwrap, base_argv_array);\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files);\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return -1;\n    }\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--symlink\", \"../usr/etc/ld.so.conf\", \"/etc/ld.so.conf\",\n                            NULL);\n\n  tmp_basename = g_strconcat (checksum, \".XXXXXX\", NULL);\n  glnx_gen_temp_name (tmp_basename);\n\n  sandbox_cache_path = g_build_filename (\"/run/ld-so-cache-dir\", tmp_basename, NULL);\n  ld_so_cache_tmp = g_file_get_child (ld_so_dir, tmp_basename);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--unshare-pid\",\n                          \"--unshare-ipc\",\n                          \"--unshare-net\",\n                          \"--proc\", \"/proc\",\n                          \"--dev\", \"/dev\",\n                          \"--bind\", flatpak_file_get_path_cached (ld_so_dir), \"/run/ld-so-cache-dir\",\n                          NULL);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return -1;\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"ldconfig\", \"-X\", \"-C\", sandbox_cache_path, NULL);\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running: '%s'\", commandline);\n\n  combined_fd_array = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_append_vals (combined_fd_array, base_fd_array->data, base_fd_array->len);\n  g_array_append_vals (combined_fd_array, bwrap->fds->data, bwrap->fds->len);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_sync (NULL,\n                     (char **) bwrap->argv->pdata,\n                     bwrap->envp,\n                     G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                     flatpak_bwrap_child_setup_cb, combined_fd_array,\n                     NULL, NULL,\n                     &exit_status,\n                     error))\n    return -1;\n\n  if (!WIFEXITED (exit_status) || WEXITSTATUS (exit_status) != 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                          _(\"ldconfig failed, exit status %d\"), exit_status);\n      return -1;\n    }\n\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache_tmp), O_RDONLY);\n  if (ld_so_fd < 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Can't open generated ld.so.cache\"));\n      return -1;\n    }\n\n  if (app_id_dir == NULL)\n    {\n      /* For runs without an app id dir we always regenerate the ld.so.cache */\n      unlink (flatpak_file_get_path_cached (ld_so_cache_tmp));\n    }\n  else\n    {\n      g_autoptr(GFile) active = g_file_get_child (ld_so_dir, \"active\");\n\n      /* For app-dirs we keep one checksum alive, by pointing the active symlink to it */\n\n      /* Rename to known name, possibly overwriting existing ref if race */\n      if (rename (flatpak_file_get_path_cached (ld_so_cache_tmp), flatpak_file_get_path_cached (ld_so_cache)) == -1)\n        {\n          glnx_set_error_from_errno (error);\n          return -1;\n        }\n\n      if (!flatpak_switch_symlink_and_remove (flatpak_file_get_path_cached (active),\n                                              checksum, error))\n        return -1;\n    }\n\n  return glnx_steal_fd (&ld_so_fd);\n}\n\n/* Check that this user is actually allowed to run this app. When running\n * from the gnome-initial-setup session, an app filter might not be available. */\nstatic gboolean\ncheck_parental_controls (FlatpakDecomposed *app_ref,\n                         FlatpakDeploy     *deploy,\n                         GCancellable      *cancellable,\n                         GError           **error)\n{\n#ifdef HAVE_LIBMALCONTENT\n  g_autoptr(MctManager) manager = NULL;\n  g_autoptr(MctAppFilter) app_filter = NULL;\n  g_autoptr(GAsyncResult) app_filter_result = NULL;\n  g_autoptr(GDBusConnection) system_bus = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDesktopAppInfo) app_info = NULL;\n  gboolean allowed = FALSE;\n\n  system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, error);\n  if (system_bus == NULL)\n    return FALSE;\n\n  manager = mct_manager_new (system_bus);\n  app_filter = mct_manager_get_app_filter (manager, getuid (),\n                                           MCT_GET_APP_FILTER_FLAGS_INTERACTIVE,\n                                           cancellable, &local_error);\n  if (g_error_matches (local_error, MCT_APP_FILTER_ERROR, MCT_APP_FILTER_ERROR_DISABLED))\n    {\n      g_debug (\"Skipping parental controls check for %s since parental \"\n               \"controls are disabled globally\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN) ||\n           g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NAME_HAS_NO_OWNER))\n    {\n      g_debug (\"Skipping parental controls check for %s since a required \"\n               \"service was not found\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  /* Always filter by app ID. Additionally, filter by app info (which runs\n   * multiple checks, including whether the app ID, executable path and\n   * content types are allowed) if available. If the flatpak contains\n   * multiple .desktop files, we use the main one. The app ID check is\n   * always done, as the binary executed by `flatpak run` isn\u2019t necessarily\n   * extracted from a .desktop file. */\n  allowed = mct_app_filter_is_flatpak_ref_allowed (app_filter, flatpak_decomposed_get_ref (app_ref));\n\n  /* Look up the app\u2019s main .desktop file. */\n  if (deploy != NULL && allowed)\n    {\n      g_autoptr(GFile) deploy_dir = NULL;\n      const char *deploy_path;\n      g_autofree char *desktop_file_name = NULL;\n      g_autofree char *desktop_file_path = NULL;\n      g_autofree char *app_id = flatpak_decomposed_dup_id (app_ref);\n\n      deploy_dir = flatpak_deploy_get_dir (deploy);\n      deploy_path = flatpak_file_get_path_cached (deploy_dir);\n\n      desktop_file_name = g_strconcat (app_id, \".desktop\", NULL);\n      desktop_file_path = g_build_path (G_DIR_SEPARATOR_S,\n                                        deploy_path,\n                                        \"export\",\n                                        \"share\",\n                                        \"applications\",\n                                        desktop_file_name,\n                                        NULL);\n      app_info = g_desktop_app_info_new_from_filename (desktop_file_path);\n    }\n\n  if (app_info != NULL)\n    allowed = allowed && mct_app_filter_is_appinfo_allowed (app_filter,\n                                                            G_APP_INFO (app_info));\n\n  if (!allowed)\n    return flatpak_fail_error (error, FLATPAK_ERROR_PERMISSION_DENIED,\n                               /* Translators: The placeholder is for an app ref. */\n                               _(\"Running %s is not allowed by the policy set by your administrator\"),\n                               flatpak_decomposed_get_ref (app_ref));\n#endif  /* HAVE_LIBMALCONTENT */\n\n  return TRUE;\n}\n\nstatic int\nopen_namespace_fd_if_needed (const char *path,\n                             const char *other_path) {\n  struct stat s, other_s;\n\n  if (stat (path, &s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  if (stat (other_path, &other_s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  /* setns calls fail if the process is already in the desired namespace, hence the\n     check here to ensure the namespaces are different. */\n  if (s.st_ino != other_s.st_ino)\n    return open (path, O_RDONLY|O_CLOEXEC);\n\n  return -1;\n}\n\nstatic gboolean\ncheck_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n\n  /* This check exists to stop accidental usage of `sudo flatpak run`\n     and is not to prevent running as root.\n   */\n\n  if (!sudo_command_env)\n    return TRUE;\n\n  /* SUDO_COMMAND could be a value like `/usr/bin/flatpak run foo` */\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be ran with sudo\"));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          \"--lock-file\", \"/usr/.ref\",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                            \"--lock-file\", \"/app/.ref\",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/app\",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2014-2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#ifndef __FLATPAK_BWRAP_H__\n#define __FLATPAK_BWRAP_H__\n\ntypedef struct\n{\n  GPtrArray *argv;\n  GArray    *noinherit_fds; /* Just keep these open while the bwrap lives */\n  GArray    *fds;\n  GStrv      envp;\n} FlatpakBwrap;\n\nextern char *flatpak_bwrap_empty_env[1];\n\nFlatpakBwrap *flatpak_bwrap_new (char **env);\nvoid          flatpak_bwrap_free (FlatpakBwrap *bwrap);\nvoid          flatpak_bwrap_set_env (FlatpakBwrap *bwrap,\n                                     const char   *variable,\n                                     const char   *value,\n                                     gboolean      overwrite);\ngboolean      flatpak_bwrap_is_empty (FlatpakBwrap *bwrap);\nvoid          flatpak_bwrap_finish (FlatpakBwrap *bwrap);\nvoid          flatpak_bwrap_unset_env (FlatpakBwrap *bwrap,\n                                       const char   *variable);\nvoid          flatpak_bwrap_add_arg (FlatpakBwrap *bwrap,\n                                     const char   *arg);\nvoid          flatpak_bwrap_take_arg (FlatpakBwrap *bwrap,\n                                      char         *arg);\nvoid          flatpak_bwrap_add_noinherit_fd (FlatpakBwrap *bwrap,\n                                              int           fd);\nvoid          flatpak_bwrap_add_fd (FlatpakBwrap *bwrap,\n                                    int           fd);\nvoid          flatpak_bwrap_add_args (FlatpakBwrap *bwrap,\n                                      ...) G_GNUC_NULL_TERMINATED;\nvoid          flatpak_bwrap_add_arg_printf (FlatpakBwrap *bwrap,\n                                            const char   *format,\n                                            ...) G_GNUC_PRINTF (2, 3);\nvoid          flatpak_bwrap_append_argsv (FlatpakBwrap *bwrap,\n                                          char        **args,\n                                          int           len);\nvoid          flatpak_bwrap_append_bwrap (FlatpakBwrap *bwrap,\n                                          FlatpakBwrap *other);       /* Steals the fds */\nvoid          flatpak_bwrap_append_args (FlatpakBwrap *bwrap,\n                                         GPtrArray    *other_array);\nvoid          flatpak_bwrap_add_args_data_fd (FlatpakBwrap *bwrap,\n                                              const char   *op,\n                                              int           fd,\n                                              const char   *path_optional);\ngboolean      flatpak_bwrap_add_args_data (FlatpakBwrap *bwrap,\n                                           const char   *name,\n                                           const char   *content,\n                                           gssize        content_size,\n                                           const char   *path,\n                                           GError      **error);\nvoid          flatpak_bwrap_add_bind_arg (FlatpakBwrap *bwrap,\n                                          const char   *type,\n                                          const char   *src,\n                                          const char   *dest);\nvoid          flatpak_bwrap_envp_to_args (FlatpakBwrap *bwrap);\ngboolean      flatpak_bwrap_bundle_args (FlatpakBwrap *bwrap,\n                                         int           start,\n                                         int           end,\n                                         gboolean      one_arg,\n                                         GError      **error);\n\nvoid          flatpak_bwrap_child_setup_cb (gpointer user_data);\nvoid          flatpak_bwrap_child_setup (GArray *fd_array,\n                                         gboolean close_fd_workaround);\n\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (FlatpakBwrap, flatpak_bwrap_free)\n\n\n#endif /* __FLATPAK_BWRAP_H__ */\n", "/*\n * Copyright \u00a9 2014-2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-bwrap-private.h\"\n#include \"flatpak-utils-private.h\"\n#include \"flatpak-utils-base-private.h\"\n\nstatic void\nclear_fd (gpointer data)\n{\n  int *fd_p = data;\n\n  if (fd_p != NULL && *fd_p != -1)\n    close (*fd_p);\n}\n\nchar *flatpak_bwrap_empty_env[] = { NULL };\n\nFlatpakBwrap *\nflatpak_bwrap_new (char **env)\n{\n  FlatpakBwrap *bwrap = g_new0 (FlatpakBwrap, 1);\n\n  bwrap->argv = g_ptr_array_new_with_free_func (g_free);\n  bwrap->noinherit_fds = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_set_clear_func (bwrap->noinherit_fds, clear_fd);\n  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_set_clear_func (bwrap->fds, clear_fd);\n\n  if (env)\n    bwrap->envp = g_strdupv (env);\n  else\n    bwrap->envp = g_get_environ ();\n\n  return bwrap;\n}\n\nvoid\nflatpak_bwrap_free (FlatpakBwrap *bwrap)\n{\n  g_ptr_array_unref (bwrap->argv);\n  g_array_unref (bwrap->noinherit_fds);\n  g_array_unref (bwrap->fds);\n  g_strfreev (bwrap->envp);\n  g_free (bwrap);\n}\n\ngboolean\nflatpak_bwrap_is_empty (FlatpakBwrap *bwrap)\n{\n  return bwrap->argv->len == 0;\n}\n\nvoid\nflatpak_bwrap_set_env (FlatpakBwrap *bwrap,\n                       const char   *variable,\n                       const char   *value,\n                       gboolean      overwrite)\n{\n  bwrap->envp = g_environ_setenv (bwrap->envp, variable, value, overwrite);\n}\n\nvoid\nflatpak_bwrap_unset_env (FlatpakBwrap *bwrap,\n                         const char   *variable)\n{\n  bwrap->envp = g_environ_unsetenv (bwrap->envp, variable);\n}\n\nvoid\nflatpak_bwrap_add_arg (FlatpakBwrap *bwrap, const char *arg)\n{\n  g_ptr_array_add (bwrap->argv, g_strdup (arg));\n}\n\n/*\n * flatpak_bwrap_take_arg:\n * @arg: (transfer full): Take ownership of this argument\n *\n * Add @arg to @bwrap's argv, taking ownership of the pointer.\n */\nvoid\nflatpak_bwrap_take_arg (FlatpakBwrap *bwrap, char *arg)\n{\n  g_ptr_array_add (bwrap->argv, arg);\n}\n\nvoid\nflatpak_bwrap_finish (FlatpakBwrap *bwrap)\n{\n  g_ptr_array_add (bwrap->argv, NULL);\n}\n\nvoid\nflatpak_bwrap_add_noinherit_fd (FlatpakBwrap *bwrap,\n                                int           fd)\n{\n  g_array_append_val (bwrap->noinherit_fds, fd);\n}\n\nvoid\nflatpak_bwrap_add_fd (FlatpakBwrap *bwrap,\n                      int           fd)\n{\n  g_array_append_val (bwrap->fds, fd);\n}\n\nvoid\nflatpak_bwrap_add_arg_printf (FlatpakBwrap *bwrap, const char *format, ...)\n{\n  va_list args;\n\n  va_start (args, format);\n  g_ptr_array_add (bwrap->argv, g_strdup_vprintf (format, args));\n  va_end (args);\n}\nvoid\nflatpak_bwrap_add_args (FlatpakBwrap *bwrap, ...)\n{\n  va_list args;\n  const gchar *arg;\n\n  va_start (args, bwrap);\n  while ((arg = va_arg (args, const gchar *)))\n    flatpak_bwrap_add_arg (bwrap, arg);\n  va_end (args);\n}\n\nvoid\nflatpak_bwrap_append_argsv (FlatpakBwrap *bwrap,\n                            char        **args,\n                            int           len)\n{\n  int i;\n\n  if (len < 0)\n    len = g_strv_length (args);\n\n  for (i = 0; i < len; i++)\n    g_ptr_array_add (bwrap->argv, g_strdup (args[i]));\n}\n\nvoid\nflatpak_bwrap_append_args (FlatpakBwrap *bwrap,\n                           GPtrArray    *other_array)\n{\n  flatpak_bwrap_append_argsv (bwrap,\n                              (char **) other_array->pdata,\n                              other_array->len);\n}\n\nstatic int *\nflatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,\n                         gsize        *len_out)\n{\n  gsize len = bwrap->fds->len;\n  int *res = (int *) g_array_free (bwrap->fds, FALSE);\n\n  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));\n  *len_out = len;\n  return res;\n}\n\nvoid\nflatpak_bwrap_append_bwrap (FlatpakBwrap *bwrap,\n                            FlatpakBwrap *other)\n{\n  g_autofree int *fds = NULL;\n  gsize n_fds, i;\n\n  fds = flatpak_bwrap_steal_fds (other, &n_fds);\n  for (i = 0; i < n_fds; i++)\n    flatpak_bwrap_add_fd (bwrap, fds[i]);\n\n  flatpak_bwrap_append_argsv (bwrap,\n                              (char **) other->argv->pdata,\n                              other->argv->len);\n\n  for (i = 0; other->envp[i] != NULL; i++)\n    {\n      char *key_val = other->envp[i];\n      char *eq = strchr (key_val, '=');\n      if (eq)\n        {\n          g_autofree char *key = g_strndup (key_val, eq - key_val);\n          flatpak_bwrap_set_env (bwrap,\n                                 key, eq + 1, TRUE);\n        }\n    }\n}\n\nvoid\nflatpak_bwrap_add_args_data_fd (FlatpakBwrap *bwrap,\n                                const char   *op,\n                                int           fd,\n                                const char   *path_optional)\n{\n  g_autofree char *fd_str = g_strdup_printf (\"%d\", fd);\n\n  flatpak_bwrap_add_fd (bwrap, fd);\n  flatpak_bwrap_add_args (bwrap,\n                          op, fd_str, path_optional,\n                          NULL);\n}\n\n\n/* Given a buffer @content of size @content_size, generate a fd (memfd if available)\n * of the data.  The @name parameter is used by memfd_create() as a debugging aid;\n * it has no semantic meaning.  The bwrap command line will inject it into the target\n * container as @path.\n */\ngboolean\nflatpak_bwrap_add_args_data (FlatpakBwrap *bwrap,\n                             const char   *name,\n                             const char   *content,\n                             gssize        content_size,\n                             const char   *path,\n                             GError      **error)\n{\n  g_auto(GLnxTmpfile) args_tmpf  = { 0, };\n\n  if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&args_tmpf, name, content, content_size, error))\n    return FALSE;\n\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--ro-bind-data\", glnx_steal_fd (&args_tmpf.fd), path);\n  return TRUE;\n}\n\n/* This resolves the target here rather than in bwrap, because it may\n * not resolve in bwrap setup due to absolute symlinks conflicting\n * with /newroot root. For example, dest could be inside\n * ~/.var/app/XXX where XXX is an absolute symlink.  However, in the\n * usecases here the destination file often doesn't exist, so we\n * only resolve the directory part.\n */\nvoid\nflatpak_bwrap_add_bind_arg (FlatpakBwrap *bwrap,\n                            const char   *type,\n                            const char   *src,\n                            const char   *dest)\n{\n  g_autofree char *dest_dirname = g_path_get_dirname (dest);\n  g_autofree char *dest_dirname_real = realpath (dest_dirname, NULL);\n\n  if (dest_dirname_real)\n    {\n      g_autofree char *dest_basename = g_path_get_basename (dest);\n      g_autofree char *dest_real = g_build_filename (dest_dirname_real, dest_basename, NULL);\n      flatpak_bwrap_add_args (bwrap, type, src, dest_real, NULL);\n    }\n}\n\n/*\n * Convert bwrap->envp into a series of --setenv arguments for bwrap(1),\n * assumed to be applied to an empty environment. Reset envp to be an\n * empty environment.\n */\nvoid\nflatpak_bwrap_envp_to_args (FlatpakBwrap *bwrap)\n{\n  gsize i;\n\n  for (i = 0; bwrap->envp[i] != NULL; i++)\n    {\n      char *key_val = bwrap->envp[i];\n      char *eq = strchr (key_val, '=');\n\n      if (eq)\n        {\n          flatpak_bwrap_add_arg (bwrap, \"--setenv\");\n          flatpak_bwrap_take_arg (bwrap, g_strndup (key_val, eq - key_val));\n          flatpak_bwrap_add_arg (bwrap, eq + 1);\n        }\n      else\n        {\n          g_warn_if_reached ();\n        }\n    }\n\n  g_strfreev (g_steal_pointer (&bwrap->envp));\n  bwrap->envp = g_strdupv (flatpak_bwrap_empty_env);\n}\n\ngboolean\nflatpak_bwrap_bundle_args (FlatpakBwrap *bwrap,\n                           int           start,\n                           int           end,\n                           gboolean      one_arg,\n                           GError      **error)\n{\n  g_autofree gchar *data = NULL;\n  gchar *ptr;\n  gint i;\n  gsize data_len = 0;\n  int fd;\n  g_auto(GLnxTmpfile) args_tmpf  = { 0, };\n\n  if (end == -1)\n    end = bwrap->argv->len;\n\n  for (i = start; i < end; i++)\n    data_len +=  strlen (bwrap->argv->pdata[i]) + 1;\n\n  data = g_new (gchar, data_len);\n  ptr = data;\n  for (i = start; i < end; i++)\n    ptr = g_stpcpy (ptr, bwrap->argv->pdata[i]) + 1;\n\n  if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&args_tmpf, \"bwrap-args\", data, data_len, error))\n    return FALSE;\n\n  fd = glnx_steal_fd (&args_tmpf.fd);\n\n  {\n    g_autofree char *commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata + start, end - start);\n    flatpak_debug2 (\"bwrap --args %d = %s\", fd, commandline);\n  }\n\n  flatpak_bwrap_add_fd (bwrap, fd);\n  g_ptr_array_remove_range (bwrap->argv, start, end - start);\n  if (one_arg)\n    {\n      g_ptr_array_insert (bwrap->argv, start, g_strdup_printf (\"--args=%d\", fd));\n    }\n  else\n    {\n      g_ptr_array_insert (bwrap->argv, start, g_strdup (\"--args\"));\n      g_ptr_array_insert (bwrap->argv, start + 1, g_strdup_printf (\"%d\", fd));\n    }\n\n  return TRUE;\n}\n\nvoid\nflatpak_bwrap_child_setup (GArray *fd_array,\n                           gboolean close_fd_workaround)\n{\n  int i;\n\n  if (close_fd_workaround)\n    flatpak_close_fds_workaround (3);\n\n  /* If no fd_array was specified, don't care. */\n  if (fd_array == NULL)\n    return;\n\n  /* Otherwise, mark not - close-on-exec all the fds in the array */\n  for (i = 0; i < fd_array->len; i++)\n    {\n      int fd = g_array_index (fd_array, int, i);\n\n      /* We also seek all fds to the start, because this lets\n         us use the same fd_array multiple times */\n      if (lseek (fd, 0, SEEK_SET) < 0)\n        {\n          /* Ignore the error, this happens on e.g. pipe fds */\n        }\n\n      fcntl (fd, F_SETFD, 0);\n    }\n}\n\n/* Unset FD_CLOEXEC on the array of fds passed in @user_data */\nvoid\nflatpak_bwrap_child_setup_cb (gpointer user_data)\n{\n  GArray *fd_array = user_data;\n\n  flatpak_bwrap_child_setup (fd_array, TRUE);\n}\n", "/*\n * Copyright \u00a9 2014-2019 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <gio/gdesktopappinfo.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/vfs.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n#ifdef HAVE_DCONF\n#include <dconf/dconf.h>\n#endif\n#ifdef HAVE_LIBMALCONTENT\n#include <libmalcontent/malcontent.h>\n#endif\n\n#ifdef ENABLE_SECCOMP\n#include <seccomp.h>\n#endif\n\n#ifdef ENABLE_XAUTH\n#include <X11/Xauth.h>\n#endif\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-run-private.h\"\n#include \"flatpak-proxy.h\"\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-instance-private.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include \"flatpak-document-dbus-generated.h\"\n#include \"flatpak-error.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n\nconst char * const abs_usrmerged_dirs[] =\n{\n  \"/bin\",\n  \"/lib\",\n  \"/lib32\",\n  \"/lib64\",\n  \"/sbin\",\n  NULL\n};\nconst char * const *flatpak_abs_usrmerged_dirs = abs_usrmerged_dirs;\n\nstatic char *\nextract_unix_path_from_dbus_address (const char *address)\n{\n  const char *path, *path_end;\n\n  if (address == NULL)\n    return NULL;\n\n  if (!g_str_has_prefix (address, \"unix:\"))\n    return NULL;\n\n  path = strstr (address, \"path=\");\n  if (path == NULL)\n    return NULL;\n  path += strlen (\"path=\");\n  path_end = path;\n  while (*path_end != 0 && *path_end != ',')\n    path_end++;\n\n  return g_strndup (path, path_end - path);\n}\n\n#ifdef ENABLE_XAUTH\nstatic gboolean\nauth_streq (char *str,\n            char *au_str,\n            int   au_len)\n{\n  return au_len == strlen (str) && memcmp (str, au_str, au_len) == 0;\n}\n\nstatic gboolean\nxauth_entry_should_propagate (Xauth *xa,\n                              char  *hostname,\n                              char  *number)\n{\n  /* ensure entry isn't for remote access */\n  if (xa->family != FamilyLocal && xa->family != FamilyWild)\n    return FALSE;\n\n  /* ensure entry is for this machine */\n  if (xa->family == FamilyLocal && !auth_streq (hostname, xa->address, xa->address_length))\n    return FALSE;\n\n  /* ensure entry is for this session */\n  if (xa->number != NULL && !auth_streq (number, xa->number, xa->number_length))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic void\nwrite_xauth (char *number, FILE *output)\n{\n  Xauth *xa, local_xa;\n  char *filename;\n  FILE *f;\n  struct utsname unames;\n\n  if (uname (&unames))\n    {\n      g_warning (\"uname failed\");\n      return;\n    }\n\n  filename = XauFileName ();\n  f = fopen (filename, \"rb\");\n  if (f == NULL)\n    return;\n\n  while (TRUE)\n    {\n      xa = XauReadAuth (f);\n      if (xa == NULL)\n        break;\n      if (xauth_entry_should_propagate (xa, unames.nodename, number))\n        {\n          local_xa = *xa;\n          if (local_xa.number)\n            {\n              local_xa.number = \"99\";\n              local_xa.number_length = 2;\n            }\n\n          if (!XauWriteAuth (output, &local_xa))\n            g_warning (\"xauth write error\");\n        }\n\n      XauDisposeAuth (xa);\n    }\n\n  fclose (f);\n}\n#endif /* ENABLE_XAUTH */\n\nstatic void\nflatpak_run_add_x11_args (FlatpakBwrap *bwrap,\n                          gboolean      allowed)\n{\n  g_autofree char *x11_socket = NULL;\n  const char *display;\n\n  /* Always cover /tmp/.X11-unix, that way we never see the host one in case\n   * we have access to the host /tmp. If you request X access we'll put the right\n   * thing in this anyway.\n   */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--tmpfs\", \"/tmp/.X11-unix\",\n                          NULL);\n\n  if (!allowed)\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n      return;\n    }\n\n  g_debug (\"Allowing x11 access\");\n\n  display = g_getenv (\"DISPLAY\");\n  if (display && display[0] == ':' && g_ascii_isdigit (display[1]))\n    {\n      const char *display_nr = &display[1];\n      const char *display_nr_end = display_nr;\n      g_autofree char *d = NULL;\n\n      while (g_ascii_isdigit (*display_nr_end))\n        display_nr_end++;\n\n      d = g_strndup (display_nr, display_nr_end - display_nr);\n      x11_socket = g_strdup_printf (\"/tmp/.X11-unix/X%s\", d);\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", x11_socket, \"/tmp/.X11-unix/X99\",\n                              NULL);\n      flatpak_bwrap_set_env (bwrap, \"DISPLAY\", \":99.0\", TRUE);\n\n#ifdef ENABLE_XAUTH\n      g_auto(GLnxTmpfile) xauth_tmpf  = { 0, };\n\n      if (glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &xauth_tmpf, NULL))\n        {\n          FILE *output = fdopen (xauth_tmpf.fd, \"wb\");\n          if (output != NULL)\n            {\n              /* fd is now owned by output, steal it from the tmpfile */\n              int tmp_fd = dup (glnx_steal_fd (&xauth_tmpf.fd));\n              if (tmp_fd != -1)\n                {\n                  g_autofree char *dest = g_strdup_printf (\"/run/user/%d/Xauthority\", getuid ());\n\n                  write_xauth (d, output);\n                  flatpak_bwrap_add_args_data_fd (bwrap, \"--ro-bind-data\", tmp_fd, dest);\n\n                  flatpak_bwrap_set_env (bwrap, \"XAUTHORITY\", dest, TRUE);\n                }\n\n              fclose (output);\n\n              if (tmp_fd != -1)\n                lseek (tmp_fd, 0, SEEK_SET);\n            }\n        }\n#endif\n    }\n  else\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n    }\n}\n\nstatic gboolean\nflatpak_run_add_wayland_args (FlatpakBwrap *bwrap)\n{\n  const char *wayland_display;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *wayland_socket = NULL;\n  g_autofree char *sandbox_wayland_socket = NULL;\n  gboolean res = FALSE;\n  struct stat statbuf;\n\n  wayland_display = g_getenv (\"WAYLAND_DISPLAY\");\n  if (!wayland_display)\n    wayland_display = \"wayland-0\";\n\n  wayland_socket = g_build_filename (user_runtime_dir, wayland_display, NULL);\n  sandbox_wayland_socket = g_strdup_printf (\"/run/user/%d/%s\", getuid (), wayland_display);\n\n  if (stat (wayland_socket, &statbuf) == 0 &&\n      (statbuf.st_mode & S_IFMT) == S_IFSOCK)\n    {\n      res = TRUE;\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", wayland_socket, sandbox_wayland_socket,\n                              NULL);\n    }\n  return res;\n}\n\nstatic void\nflatpak_run_add_ssh_args (FlatpakBwrap *bwrap)\n{\n  const char * auth_socket;\n  g_autofree char * sandbox_auth_socket = NULL;\n\n  auth_socket = g_getenv (\"SSH_AUTH_SOCK\");\n\n  if (!auth_socket)\n    return; /* ssh agent not present */\n\n  if (!g_file_test (auth_socket, G_FILE_TEST_EXISTS))\n    {\n      /* Let's clean it up, so that the application will not try to connect */\n      flatpak_bwrap_unset_env (bwrap, \"SSH_AUTH_SOCK\");\n      return;\n    }\n\n  sandbox_auth_socket = g_strdup_printf (\"/run/user/%d/ssh-auth\", getuid ());\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", auth_socket, sandbox_auth_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"SSH_AUTH_SOCK\", sandbox_auth_socket, TRUE);\n}\n\nstatic void\nflatpak_run_add_pcsc_args (FlatpakBwrap *bwrap)\n{\n  const char * pcsc_socket;\n  const char * sandbox_pcsc_socket = \"/run/pcscd/pcscd.comm\";\n\n  pcsc_socket = g_getenv (\"PCSCLITE_CSOCK_NAME\");\n  if (pcsc_socket)\n    {\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_unset_env (bwrap, \"PCSCLITE_CSOCK_NAME\");\n          return;\n        }\n    }\n  else\n    {\n      pcsc_socket = \"/run/pcscd/pcscd.comm\";\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", pcsc_socket, sandbox_pcsc_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"PCSCLITE_CSOCK_NAME\", sandbox_pcsc_socket, TRUE);\n}\n\nstatic gboolean\nflatpak_run_cups_check_server_is_socket (const char *server)\n{\n  if (g_str_has_prefix (server, \"/\") && strstr (server, \":\") == NULL)\n    return TRUE;\n\n  return FALSE;\n}\n\n/* Try to find a default server from a cups confguration file */\nstatic char *\nflatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic char *\nflatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n\n  /* TODO\n   * we don't currently support cups servers located on the network, if such\n   * server is detected, we simply ignore it and in the worst case we fallback\n   * to the default socket\n   */\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n\n  // Fallback to default socket\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}\n\nstatic void\nflatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}\n\n/* Try to find a default server from a pulseaudio confguration file */\nstatic char *\nflatpak_run_get_pulseaudio_server_user_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"Pulseaudio user configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == ';') || (*line == '#'))\n        continue;\n\n      if (g_str_has_prefix (line, \".include \"))\n        {\n          g_autofree char *rec_path = g_strdup (line + 9);\n          g_strstrip (rec_path);\n          char *found = flatpak_run_get_pulseaudio_server_user_config (rec_path);\n          if (found)\n            return found;\n        }\n      else if (g_str_has_prefix (line, \"[\"))\n        {\n          return NULL;\n        }\n      else\n        {\n          g_auto(GStrv) tokens = g_strsplit (line, \"=\", 2);\n\n          if ((tokens[0] != NULL) && (tokens[1] != NULL))\n            {\n              g_strchomp (tokens[0]);\n              if (strcmp (\"default-server\", tokens[0]) == 0)\n                {\n                  g_strstrip (tokens[1]);\n                  g_debug (\"Found pulseaudio socket from configuration file '%s': %s\", path, tokens[1]);\n                  return g_strdup (tokens[1]);\n                }\n            }\n        }\n    }\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_get_pulseaudio_server (void)\n{\n  const char * pulse_clientconfig;\n  char *pulse_server;\n  g_autofree char *pulse_user_config = NULL;\n\n  pulse_server = g_strdup (g_getenv (\"PULSE_SERVER\"));\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_clientconfig = g_getenv (\"PULSE_CLIENTCONFIG\");\n  if (pulse_clientconfig)\n    return flatpak_run_get_pulseaudio_server_user_config (pulse_clientconfig);\n\n  pulse_user_config = g_build_filename (g_get_user_config_dir (), \"pulse/client.conf\", NULL);\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (pulse_user_config);\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (\"/etc/pulse/client.conf\");\n  if (pulse_server)\n    return pulse_server;\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_parse_pulse_server (const char *value)\n{\n  g_auto(GStrv) servers = g_strsplit (value, \" \", 0);\n  gsize i;\n\n  for (i = 0; servers[i] != NULL; i++)\n    {\n      const char *server = servers[i];\n      if (g_str_has_prefix (server, \"{\"))\n        {\n          const char * closing = strstr (server, \"}\");\n          if (closing == NULL)\n            continue;\n          server = closing + 1;\n        }\n      if (g_str_has_prefix (server, \"unix:\"))\n        return g_strdup (server + 5);\n    }\n\n  return NULL;\n}\n\n/*\n * Get the machine ID as used by PulseAudio. This is the systemd/D-Bus\n * machine ID, or failing that, the hostname.\n */\nstatic char *\nflatpak_run_get_pulse_machine_id (void)\n{\n  static const char * const machine_ids[] =\n  {\n    \"/etc/machine-id\",\n    \"/var/lib/dbus/machine-id\",\n  };\n  gsize i;\n\n  for (i = 0; i < G_N_ELEMENTS (machine_ids); i++)\n    {\n      g_autofree char *ret = NULL;\n\n      if (g_file_get_contents (machine_ids[i], &ret, NULL, NULL))\n        {\n          gsize j;\n\n          g_strstrip (ret);\n\n          for (j = 0; ret[j] != '\\0'; j++)\n            {\n              if (!g_ascii_isxdigit (ret[j]))\n                break;\n            }\n\n          if (ret[0] != '\\0' && ret[j] == '\\0')\n            return g_steal_pointer (&ret);\n        }\n    }\n\n  return g_strdup (g_get_host_name ());\n}\n\n/*\n * Get the directory used by PulseAudio for its configuration.\n */\nstatic char *\nflatpak_run_get_pulse_home (void)\n{\n  /* Legacy path ~/.pulse is tried first, for compatibility */\n  {\n    const char *parent = g_get_home_dir ();\n    g_autofree char *ret = g_build_filename (parent, \".pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  /* The more modern path, usually ~/.config/pulse */\n  {\n    const char *parent = g_get_user_config_dir ();\n    /* Usually ~/.config/pulse */\n    g_autofree char *ret = g_build_filename (parent, \"pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  return NULL;\n}\n\n/*\n * Get the runtime directory used by PulseAudio for its socket.\n */\nstatic char *\nflatpak_run_get_pulse_runtime_dir (void)\n{\n  const char *val = NULL;\n\n  val = g_getenv (\"PULSE_RUNTIME_PATH\");\n\n  if (val != NULL)\n    return realpath (val, NULL);\n\n  {\n    const char *user_runtime_dir = g_get_user_runtime_dir ();\n\n    if (user_runtime_dir != NULL)\n      {\n        g_autofree char *dir = g_build_filename (user_runtime_dir, \"pulse\", NULL);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  {\n    g_autofree char *pulse_home = flatpak_run_get_pulse_home ();\n    g_autofree char *machine_id = flatpak_run_get_pulse_machine_id ();\n\n    if (pulse_home != NULL && machine_id != NULL)\n      {\n        /* This is usually a symlink, but we take its realpath() anyway */\n        g_autofree char *dir = g_strdup_printf (\"%s/%s-runtime\", pulse_home, machine_id);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  return NULL;\n}\n\nstatic void\nflatpak_run_add_pulseaudio_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *pulseaudio_server = flatpak_run_get_pulseaudio_server ();\n  g_autofree char *pulseaudio_socket = NULL;\n  g_autofree char *pulse_runtime_dir = flatpak_run_get_pulse_runtime_dir ();\n\n  if (pulseaudio_server)\n    pulseaudio_socket = flatpak_run_parse_pulse_server (pulseaudio_server);\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = g_build_filename (pulse_runtime_dir, \"native\", NULL);\n\n      if (!g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = realpath (\"/var/run/pulse/native\", NULL);\n\n      if (pulseaudio_socket && !g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  flatpak_bwrap_unset_env (bwrap, \"PULSE_SERVER\");\n\n  if (pulseaudio_socket && g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n    {\n      gboolean share_shm = FALSE; /* TODO: When do we add this? */\n      g_autofree char *client_config = g_strdup_printf (\"enable-shm=%s\\n\", share_shm ? \"yes\" : \"no\");\n      g_autofree char *sandbox_socket_path = g_strdup_printf (\"/run/user/%d/pulse/native\", getuid ());\n      g_autofree char *pulse_server = g_strdup_printf (\"unix:/run/user/%d/pulse/native\", getuid ());\n      g_autofree char *config_path = g_strdup_printf (\"/run/user/%d/pulse/config\", getuid ());\n\n      /* FIXME - error handling */\n      if (!flatpak_bwrap_add_args_data (bwrap, \"pulseaudio\", client_config, -1, config_path, NULL))\n        return;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", pulseaudio_socket, sandbox_socket_path,\n                              NULL);\n\n      flatpak_bwrap_set_env (bwrap, \"PULSE_SERVER\", pulse_server, TRUE);\n      flatpak_bwrap_set_env (bwrap, \"PULSE_CLIENTCONFIG\", config_path, TRUE);\n    }\n  else\n    g_debug (\"Could not find pulseaudio socket\");\n\n  /* Also allow ALSA access. This was added in 1.8, and is not ideally named. However,\n   * since the practical permission of ALSA and PulseAudio are essentially the same, and\n   * since we don't want to add more permissions for something we plan to replace with\n   * portals/pipewire going forward we reinterpret pulseaudio to also mean ALSA.\n   */\n  if (g_file_test (\"/dev/snd\", G_FILE_TEST_IS_DIR))\n    flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/snd\", \"/dev/snd\", NULL);\n}\n\nstatic void\nflatpak_run_add_resolved_args (FlatpakBwrap *bwrap)\n{\n  const char *resolved_socket = \"/run/systemd/resolve/io.systemd.Resolve\";\n\n  if (g_file_test (resolved_socket, G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--bind\", resolved_socket, resolved_socket, NULL);\n}\n\nstatic void\nflatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}\n\nstatic char *\ncreate_proxy_socket (char *template)\n{\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy\", NULL);\n  g_autofree char *proxy_socket = g_build_filename (proxy_socket_dir, template, NULL);\n  int fd;\n\n  if (!glnx_shutil_mkdir_p_at (AT_FDCWD, proxy_socket_dir, 0755, NULL, NULL))\n    return NULL;\n\n  fd = g_mkstemp (proxy_socket);\n  if (fd == -1)\n    return NULL;\n\n  close (fd);\n\n  return g_steal_pointer (&proxy_socket);\n}\n\nstatic gboolean\nflatpak_run_add_system_dbus_args (FlatpakBwrap   *app_bwrap,\n                                  FlatpakBwrap   *proxy_arg_bwrap,\n                                  FlatpakContext *context,\n                                  FlatpakRunFlags flags)\n{\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SYSTEM_BUS_ADDRESS\");\n  g_autofree char *real_dbus_address = NULL;\n  g_autofree char *dbus_system_socket = NULL;\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) != 0;\n  if (unrestricted)\n    g_debug (\"Allowing system-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY) != 0;\n\n  if (dbus_address != NULL)\n    dbus_system_socket = extract_unix_path_from_dbus_address (dbus_address);\n  else if (g_file_test (\"/var/run/dbus/system_bus_socket\", G_FILE_TEST_EXISTS))\n    dbus_system_socket = g_strdup (\"/var/run/dbus/system_bus_socket\");\n\n  if (dbus_system_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_system_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  else if (!no_proxy && flatpak_context_get_needs_system_bus_proxy (context))\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"system-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      if (dbus_address)\n        real_dbus_address = g_strdup (dbus_address);\n      else\n        real_dbus_address = g_strdup_printf (\"unix:path=%s\", dbus_system_socket);\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, real_dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        flatpak_context_add_bus_filters (context, NULL, FALSE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SYSTEM_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_session_dbus_args (FlatpakBwrap   *app_bwrap,\n                                   FlatpakBwrap   *proxy_arg_bwrap,\n                                   FlatpakContext *context,\n                                   FlatpakRunFlags flags,\n                                   const char     *app_id)\n{\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SESSION_BUS_ADDRESS\");\n  g_autofree char *dbus_session_socket = NULL;\n  g_autofree char *sandbox_socket_path = g_strdup_printf (\"/run/user/%d/bus\", getuid ());\n  g_autofree char *sandbox_dbus_address = g_strdup_printf (\"unix:path=/run/user/%d/bus\", getuid ());\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) != 0;\n\n  if (dbus_address != NULL)\n    {\n      dbus_session_socket = extract_unix_path_from_dbus_address (dbus_address);\n    }\n  else\n    {\n      g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n      struct stat statbuf;\n\n      dbus_session_socket = g_build_filename (user_runtime_dir, \"bus\", NULL);\n\n      if (stat (dbus_session_socket, &statbuf) < 0\n          || (statbuf.st_mode & S_IFMT) != S_IFSOCK\n          || statbuf.st_uid != getuid ())\n        return FALSE;\n    }\n\n  if (unrestricted)\n    g_debug (\"Allowing session-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY) != 0;\n\n  if (dbus_session_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_session_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n      return TRUE;\n    }\n  else if (!no_proxy && dbus_address != NULL)\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"session-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        {\n          flatpak_context_add_bus_filters (context, app_id, TRUE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n          /* Allow calling any interface+method on all portals, but only receive broadcasts under /org/desktop/portal */\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--call=org.freedesktop.portal.*=*\");\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--broadcast=org.freedesktop.portal.*=@/org/freedesktop/portal/*\");\n        }\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SESSION_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_a11y_dbus_args (FlatpakBwrap   *app_bwrap,\n                                FlatpakBwrap   *proxy_arg_bwrap,\n                                FlatpakContext *context,\n                                FlatpakRunFlags flags)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *a11y_address = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDBusMessage) reply = NULL;\n  g_autoptr(GDBusMessage) msg = NULL;\n  g_autofree char *proxy_socket = NULL;\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY) != 0)\n    return FALSE;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus == NULL)\n    return FALSE;\n\n  msg = g_dbus_message_new_method_call (\"org.a11y.Bus\", \"/org/a11y/bus\", \"org.a11y.Bus\", \"GetAddress\");\n  g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n  reply =\n    g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                    G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                    30000,\n                                                    NULL,\n                                                    NULL,\n                                                    NULL);\n  if (reply)\n    {\n      if (g_dbus_message_to_gerror (reply, &local_error))\n        {\n          if (!g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n            g_message (\"Can't find a11y bus: %s\", local_error->message);\n        }\n      else\n        {\n          g_variant_get (g_dbus_message_get_body (reply),\n                         \"(s)\", &a11y_address);\n        }\n    }\n\n  if (!a11y_address)\n    return FALSE;\n\n  proxy_socket = create_proxy_socket (\"a11y-bus-proxy-XXXXXX\");\n  if (proxy_socket == NULL)\n    return FALSE;\n\n  g_autofree char *sandbox_socket_path = g_strdup_printf (\"/run/user/%d/at-spi-bus\", getuid ());\n  g_autofree char *sandbox_dbus_address = g_strdup_printf (\"unix:path=/run/user/%d/at-spi-bus\", getuid ());\n\n  flatpak_bwrap_add_args (proxy_arg_bwrap,\n                          a11y_address,\n                          proxy_socket, \"--filter\", \"--sloppy-names\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Embed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Unembed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Registry.GetRegisteredEvents@/org/a11y/atspi/registry\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetKeystrokeListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetDeviceEventListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersSync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersAsync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          NULL);\n\n  if ((flags & FLATPAK_RUN_FLAG_LOG_A11Y_BUS) != 0)\n    flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n  flatpak_bwrap_add_args (app_bwrap,\n                          \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                          NULL);\n  flatpak_bwrap_set_env (app_bwrap, \"AT_SPI_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n  return TRUE;\n}\n\n/* This wraps the argv in a bwrap call, primary to allow the\n   command to be run with a proper /.flatpak-info with data\n   taken from app_info_path */\nstatic gboolean\nadd_bwrap_wrapper (FlatpakBwrap *bwrap,\n                   const char   *app_info_path,\n                   GError      **error)\n{\n  glnx_autofd int app_info_fd = -1;\n  g_auto(GLnxDirFdIterator) dir_iter = { 0 };\n  struct dirent *dent;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy/\", NULL);\n\n  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);\n  if (app_info_fd == -1)\n    return glnx_throw_errno_prefix (error, _(\"Failed to open app info file\"));\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, \"/\", FALSE, &dir_iter, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  while (TRUE)\n    {\n      glnx_autofd int o_path_fd = -1;\n      struct statfs stfs;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      if (strcmp (dent->d_name, \".flatpak-info\") == 0)\n        continue;\n\n      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */\n      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);\n      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)\n        continue; /* AUTOFS mounts are risky and can cause us to block (see issue #1633), so ignore it. Its unlikely the proxy needs such a directory. */\n\n      if (dent->d_type == DT_DIR)\n        {\n          if (strcmp (dent->d_name, \"tmp\") == 0 ||\n              strcmp (dent->d_name, \"var\") == 0 ||\n              strcmp (dent->d_name, \"run\") == 0)\n            flatpak_bwrap_add_arg (bwrap, \"--bind\");\n          else\n            flatpak_bwrap_add_arg (bwrap, \"--ro-bind\");\n\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n      else if (dent->d_type == DT_LNK)\n        {\n          g_autofree gchar *target = NULL;\n\n          target = glnx_readlinkat_malloc (dir_iter.fd, dent->d_name,\n                                           NULL, error);\n          if (target == NULL)\n            return FALSE;\n          flatpak_bwrap_add_args (bwrap, \"--symlink\", target, NULL);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n    }\n\n  flatpak_bwrap_add_args (bwrap, \"--bind\", proxy_socket_dir, proxy_socket_dir, NULL);\n\n  /* This is a file rather than a bind mount, because it will then\n     not be unmounted from the namespace when the namespace dies. */\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--file\", glnx_steal_fd (&app_info_fd), \"/.flatpak-info\");\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nstart_dbus_proxy (FlatpakBwrap *app_bwrap,\n                  FlatpakBwrap *proxy_arg_bwrap,\n                  const char   *app_info_path,\n                  GError      **error)\n{\n  char x = 'x';\n  const char *proxy;\n  g_autofree char *commandline = NULL;\n  g_autoptr(FlatpakBwrap) proxy_bwrap = NULL;\n  int sync_fds[2] = {-1, -1};\n  int proxy_start_index;\n  g_auto(GStrv) minimal_envp = NULL;\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  proxy_bwrap = flatpak_bwrap_new (NULL);\n\n  if (!add_bwrap_wrapper (proxy_bwrap, app_info_path, error))\n    return FALSE;\n\n  proxy = g_getenv (\"FLATPAK_DBUSPROXY\");\n  if (proxy == NULL)\n    proxy = DBUSPROXY;\n\n  flatpak_bwrap_add_arg (proxy_bwrap, proxy);\n\n  proxy_start_index = proxy_bwrap->argv->len;\n\n  if (pipe2 (sync_fds, O_CLOEXEC) < 0)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Unable to create sync pipe\"));\n      return FALSE;\n    }\n\n  /* read end goes to app */\n  flatpak_bwrap_add_args_data_fd (app_bwrap, \"--sync-fd\", sync_fds[0], NULL);\n\n  /* write end goes to proxy */\n  flatpak_bwrap_add_fd (proxy_bwrap, sync_fds[1]);\n  flatpak_bwrap_add_arg_printf (proxy_bwrap, \"--fd=%d\", sync_fds[1]);\n\n  /* Note: This steals the fds from proxy_arg_bwrap */\n  flatpak_bwrap_append_bwrap (proxy_bwrap, proxy_arg_bwrap);\n\n  if (!flatpak_bwrap_bundle_args (proxy_bwrap, proxy_start_index, -1, TRUE, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (proxy_bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) proxy_bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async (NULL,\n                      (char **) proxy_bwrap->argv->pdata,\n                      NULL,\n                      G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                      flatpak_bwrap_child_setup_cb, proxy_bwrap->fds,\n                      NULL, error))\n    return FALSE;\n\n  /* The write end can be closed now, otherwise the read below will hang of xdg-dbus-proxy\n     fails to start. */\n  g_clear_pointer (&proxy_bwrap, flatpak_bwrap_free);\n\n  /* Sync with proxy, i.e. wait until its listening on the sockets */\n  if (read (sync_fds[0], &x, 1) != 1)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Failed to sync with dbus proxy\"));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic int\nflatpak_extension_compare_by_path (gconstpointer _a,\n                                   gconstpointer _b)\n{\n  const FlatpakExtension *a = _a;\n  const FlatpakExtension *b = _b;\n\n  return g_strcmp0 (a->directory, b->directory);\n}\n\ngboolean\nflatpak_run_add_extension_args (FlatpakBwrap      *bwrap,\n                                GKeyFile          *metakey,\n                                FlatpakDecomposed *ref,\n                                gboolean           use_ld_so_cache,\n                                char             **extensions_out,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autoptr(GString) used_extensions = g_string_new (\"\");\n  GList *extensions, *path_sorted_extensions, *l;\n  g_autoptr(GString) ld_library_path = g_string_new (\"\");\n  int count = 0;\n  g_autoptr(GHashTable) mounted_tmpfs =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autoptr(GHashTable) created_symlink =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *arch = flatpak_decomposed_dup_arch (ref);\n  const char *branch = flatpak_decomposed_get_branch (ref);\n  gboolean is_app = flatpak_decomposed_is_app (ref);\n\n  extensions = flatpak_list_extensions (metakey, arch, branch);\n\n  /* First we apply all the bindings, they are sorted alphabetically in order for parent directory\n     to be mounted before child directories */\n  path_sorted_extensions = g_list_copy (extensions);\n  path_sorted_extensions = g_list_sort (path_sorted_extensions, flatpak_extension_compare_by_path);\n\n  for (l = path_sorted_extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (is_app ? \"/app\" : \"/usr\", ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      g_autofree char *ref_file = g_build_filename (full_directory, \".ref\", NULL);\n      g_autofree char *real_ref = g_build_filename (ext->files_path, ext->directory, \".ref\", NULL);\n\n      if (ext->needs_tmpfs)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n\n          if (g_hash_table_lookup (mounted_tmpfs, parent) == NULL)\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--tmpfs\", parent,\n                                      NULL);\n              g_hash_table_insert (mounted_tmpfs, g_steal_pointer (&parent), \"mounted\");\n            }\n        }\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", ext->files_path, full_directory,\n                              NULL);\n\n      if (g_file_test (real_ref, G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", ref_file,\n                                NULL);\n    }\n\n  g_list_free (path_sorted_extensions);\n\n  /* Then apply library directories and file merging, in extension prio order */\n\n  for (l = extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (is_app ? \"/app\" : \"/usr\", ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      int i;\n\n      if (used_extensions->len > 0)\n        g_string_append (used_extensions, \";\");\n      g_string_append (used_extensions, ext->installed_id);\n      g_string_append (used_extensions, \"=\");\n      if (ext->commit != NULL)\n        g_string_append (used_extensions, ext->commit);\n      else\n        g_string_append (used_extensions, \"local\");\n\n      if (ext->add_ld_path)\n        {\n          g_autofree char *ld_path = g_build_filename (full_directory, ext->add_ld_path, NULL);\n\n          if (use_ld_so_cache)\n            {\n              g_autofree char *contents = g_strconcat (ld_path, \"\\n\", NULL);\n              /* We prepend app or runtime and a counter in order to get the include order correct for the conf files */\n              g_autofree char *ld_so_conf_file = g_strdup_printf (\"%s-%03d-%s.conf\", flatpak_decomposed_get_kind_str (ref), ++count, ext->installed_id);\n              g_autofree char *ld_so_conf_file_path = g_build_filename (\"/run/flatpak/ld.so.conf.d\", ld_so_conf_file, NULL);\n\n              if (!flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                                contents, -1, ld_so_conf_file_path, error))\n                return FALSE;\n            }\n          else\n            {\n              if (ld_library_path->len != 0)\n                g_string_append (ld_library_path, \":\");\n              g_string_append (ld_library_path, ld_path);\n            }\n        }\n\n      for (i = 0; ext->merge_dirs != NULL && ext->merge_dirs[i] != NULL; i++)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n          g_autofree char *merge_dir = g_build_filename (parent, ext->merge_dirs[i], NULL);\n          g_autofree char *source_dir = g_build_filename (ext->files_path, ext->merge_dirs[i], NULL);\n          g_auto(GLnxDirFdIterator) source_iter = { 0 };\n          struct dirent *dent;\n\n          if (glnx_dirfd_iterator_init_at (AT_FDCWD, source_dir, TRUE, &source_iter, NULL))\n            {\n              while (glnx_dirfd_iterator_next_dent (&source_iter, &dent, NULL, NULL) && dent != NULL)\n                {\n                  g_autofree char *symlink_path = g_build_filename (merge_dir, dent->d_name, NULL);\n                  /* Only create the first, because extensions are listed in prio order */\n                  if (g_hash_table_lookup (created_symlink, symlink_path) == NULL)\n                    {\n                      g_autofree char *symlink = g_build_filename (directory, ext->merge_dirs[i], dent->d_name, NULL);\n                      flatpak_bwrap_add_args (bwrap,\n                                              \"--symlink\", symlink, symlink_path,\n                                              NULL);\n                      g_hash_table_insert (created_symlink, g_steal_pointer (&symlink_path), \"created\");\n                    }\n                }\n            }\n        }\n    }\n\n  g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n\n  if (ld_library_path->len != 0)\n    {\n      const gchar *old_ld_path = g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\");\n\n      if (old_ld_path != NULL && *old_ld_path != 0)\n        {\n          if (is_app)\n            {\n              g_string_append (ld_library_path, \":\");\n              g_string_append (ld_library_path, old_ld_path);\n            }\n          else\n            {\n              g_string_prepend (ld_library_path, \":\");\n              g_string_prepend (ld_library_path, old_ld_path);\n            }\n        }\n\n      flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n    }\n\n  if (extensions_out)\n    *extensions_out = g_string_free (g_steal_pointer (&used_extensions), FALSE);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}\n\ntypedef struct\n{\n  const char *env;\n  const char *val;\n} ExportData;\n\nstatic const ExportData default_exports[] = {\n  {\"PATH\", \"/app/bin:/usr/bin\"},\n  /* We always want to unset LD_LIBRARY_PATH to avoid inheriting weird\n   * dependencies from the host. But if not using ld.so.cache this is\n   * later set. */\n  {\"LD_LIBRARY_PATH\", NULL},\n  {\"XDG_CONFIG_DIRS\", \"/app/etc/xdg:/etc/xdg\"},\n  {\"XDG_DATA_DIRS\", \"/app/share:/usr/share\"},\n  {\"SHELL\", \"/bin/sh\"},\n  {\"TMPDIR\", NULL}, /* Unset TMPDIR as it may not exist in the sandbox */\n\n  /* Some env vars are common enough and will affect the sandbox badly\n     if set on the host. We clear these always. */\n  {\"PYTHONPATH\", NULL},\n  {\"PERLLIB\", NULL},\n  {\"PERL5LIB\", NULL},\n  {\"XCURSOR_PATH\", NULL},\n};\n\nstatic const ExportData no_ld_so_cache_exports[] = {\n  {\"LD_LIBRARY_PATH\", \"/app/lib\"},\n};\n\nstatic const ExportData devel_exports[] = {\n  {\"ACLOCAL_PATH\", \"/app/share/aclocal\"},\n  {\"C_INCLUDE_PATH\", \"/app/include\"},\n  {\"CPLUS_INCLUDE_PATH\", \"/app/include\"},\n  {\"LDFLAGS\", \"-L/app/lib \"},\n  {\"PKG_CONFIG_PATH\", \"/app/lib/pkgconfig:/app/share/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig\"},\n  {\"LC_ALL\", \"en_US.utf8\"},\n};\n\nstatic void\nadd_exports (GPtrArray        *env_array,\n             const ExportData *exports,\n             gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      if (exports[i].val)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", exports[i].env, exports[i].val));\n    }\n}\n\nchar **\nflatpak_run_get_minimal_env (gboolean devel, gboolean use_ld_so_cache)\n{\n  GPtrArray *env_array;\n  static const char * const copy[] = {\n    \"PWD\",\n    \"GDMSESSION\",\n    \"XDG_CURRENT_DESKTOP\",\n    \"XDG_SESSION_DESKTOP\",\n    \"DESKTOP_SESSION\",\n    \"EMAIL_ADDRESS\",\n    \"HOME\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"REAL_NAME\",\n    \"TERM\",\n    \"USER\",\n    \"USERNAME\",\n  };\n  static const char * const copy_nodevel[] = {\n    \"LANG\",\n    \"LANGUAGE\",\n    \"LC_ALL\",\n    \"LC_ADDRESS\",\n    \"LC_COLLATE\",\n    \"LC_CTYPE\",\n    \"LC_IDENTIFICATION\",\n    \"LC_MEASUREMENT\",\n    \"LC_MESSAGES\",\n    \"LC_MONETARY\",\n    \"LC_NAME\",\n    \"LC_NUMERIC\",\n    \"LC_PAPER\",\n    \"LC_TELEPHONE\",\n    \"LC_TIME\",\n  };\n  int i;\n\n  env_array = g_ptr_array_new_with_free_func (g_free);\n\n  add_exports (env_array, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    add_exports (env_array, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n\n  if (devel)\n    add_exports (env_array, devel_exports, G_N_ELEMENTS (devel_exports));\n\n  for (i = 0; i < G_N_ELEMENTS (copy); i++)\n    {\n      const char *current = g_getenv (copy[i]);\n      if (current)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy[i], current));\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (copy_nodevel); i++)\n        {\n          const char *current = g_getenv (copy_nodevel[i]);\n          if (current)\n            g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy_nodevel[i], current));\n        }\n    }\n\n  g_ptr_array_add (env_array, NULL);\n  return (char **) g_ptr_array_free (env_array, FALSE);\n}\n\nstatic char **\napply_exports (char            **envp,\n               const ExportData *exports,\n               gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      const char *value = exports[i].val;\n\n      if (value)\n        envp = g_environ_setenv (envp, exports[i].env, value, TRUE);\n      else\n        envp = g_environ_unsetenv (envp, exports[i].env);\n    }\n\n  return envp;\n}\n\nvoid\nflatpak_run_apply_env_default (FlatpakBwrap *bwrap, gboolean use_ld_so_cache)\n{\n  bwrap->envp = apply_exports (bwrap->envp, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    bwrap->envp = apply_exports (bwrap->envp, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n}\n\nstatic void\nflatpak_run_apply_env_prompt (FlatpakBwrap *bwrap, const char *app_id)\n{\n  /* A custom shell prompt. FLATPAK_ID is always set.\n   * PS1 can be overwritten by runtime metadata or by --env overrides\n   */\n  flatpak_bwrap_set_env (bwrap, \"FLATPAK_ID\", app_id, TRUE);\n  flatpak_bwrap_set_env (bwrap, \"PS1\", \"[\ud83d\udce6 $FLATPAK_ID \\\\W]\\\\$ \", FALSE);\n}\n\nvoid\nflatpak_run_apply_env_appid (FlatpakBwrap *bwrap,\n                             GFile        *app_dir)\n{\n  g_autoptr(GFile) app_dir_data = NULL;\n  g_autoptr(GFile) app_dir_config = NULL;\n  g_autoptr(GFile) app_dir_cache = NULL;\n\n  app_dir_data = g_file_get_child (app_dir, \"data\");\n  app_dir_config = g_file_get_child (app_dir, \"config\");\n  app_dir_cache = g_file_get_child (app_dir, \"cache\");\n  flatpak_bwrap_set_env (bwrap, \"XDG_DATA_HOME\", flatpak_file_get_path_cached (app_dir_data), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CONFIG_HOME\", flatpak_file_get_path_cached (app_dir_config), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CACHE_HOME\", flatpak_file_get_path_cached (app_dir_cache), TRUE);\n\n  if (g_getenv (\"XDG_DATA_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_DATA_HOME\", g_getenv (\"XDG_DATA_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CONFIG_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CONFIG_HOME\", g_getenv (\"XDG_CONFIG_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CACHE_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CACHE_HOME\", g_getenv (\"XDG_CACHE_HOME\"), TRUE);\n}\n\nvoid\nflatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n\n      if (val && val[0] != 0)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}\n\nGFile *\nflatpak_get_data_dir (const char *app_id)\n{\n  g_autoptr(GFile) home = g_file_new_for_path (g_get_home_dir ());\n  g_autoptr(GFile) var_app = g_file_resolve_relative_path (home, \".var/app\");\n\n  return g_file_get_child (var_app, app_id);\n}\n\ngboolean\nflatpak_ensure_data_dir (GFile        *app_id_dir,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  g_autoptr(GFile) data_dir = g_file_get_child (app_id_dir, \"data\");\n  g_autoptr(GFile) cache_dir = g_file_get_child (app_id_dir, \"cache\");\n  g_autoptr(GFile) fontconfig_cache_dir = g_file_get_child (cache_dir, \"fontconfig\");\n  g_autoptr(GFile) tmp_dir = g_file_get_child (cache_dir, \"tmp\");\n  g_autoptr(GFile) config_dir = g_file_get_child (app_id_dir, \"config\");\n\n  if (!flatpak_mkdir_p (data_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (fontconfig_cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (tmp_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (config_dir, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstruct JobData\n{\n  char      *job;\n  GMainLoop *main_loop;\n};\n\nstatic void\njob_removed_cb (SystemdManager *manager,\n                guint32         id,\n                char           *job,\n                char           *unit,\n                char           *result,\n                struct JobData *data)\n{\n  if (strcmp (job, data->job) == 0)\n    g_main_loop_quit (data->main_loop);\n}\n\nstatic gchar *\nsystemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}\n\ngboolean\nflatpak_run_in_transient_unit (const char *appid, GError **error)\n{\n  g_autoptr(GDBusConnection) conn = NULL;\n  g_autofree char *path = NULL;\n  g_autofree char *address = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *appid_escaped = NULL;\n  g_autofree char *job = NULL;\n  SystemdManager *manager = NULL;\n  GVariantBuilder builder;\n  GVariant *properties = NULL;\n  GVariant *aux = NULL;\n  guint32 pid;\n  GMainLoop *main_loop = NULL;\n  struct JobData data;\n  gboolean res = FALSE;\n  g_autoptr(GMainContextPopDefault) main_context = NULL;\n\n  path = g_strdup_printf (\"/run/user/%d/systemd/private\", getuid ());\n\n  if (!g_file_test (path, G_FILE_TEST_EXISTS))\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                               _(\"No systemd user session available, cgroups not available\"));\n\n  main_context = flatpak_main_context_new_default ();\n  main_loop = g_main_loop_new (main_context, FALSE);\n\n  address = g_strconcat (\"unix:path=\", path, NULL);\n\n  conn = g_dbus_connection_new_for_address_sync (address,\n                                                 G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,\n                                                 NULL,\n                                                 NULL, error);\n  if (!conn)\n    goto out;\n\n  manager = systemd_manager_proxy_new_sync (conn,\n                                            G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,\n                                            NULL,\n                                            \"/org/freedesktop/systemd1\",\n                                            NULL, error);\n  if (!manager)\n    goto out;\n\n  appid_escaped = systemd_unit_name_escape (appid);\n  name = g_strdup_printf (\"app-flatpak-%s-%d.scope\", appid_escaped, getpid ());\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a(sv)\"));\n\n  pid = getpid ();\n  g_variant_builder_add (&builder, \"(sv)\",\n                         \"PIDs\",\n                         g_variant_new_fixed_array (G_VARIANT_TYPE (\"u\"),\n                                                    &pid, 1, sizeof (guint32))\n                        );\n\n  properties = g_variant_builder_end (&builder);\n\n  aux = g_variant_new_array (G_VARIANT_TYPE (\"(sa(sv))\"), NULL, 0);\n\n  if (!systemd_manager_call_start_transient_unit_sync (manager,\n                                                       name,\n                                                       \"fail\",\n                                                       properties,\n                                                       aux,\n                                                       &job,\n                                                       NULL,\n                                                       error))\n    goto out;\n\n  data.job = job;\n  data.main_loop = main_loop;\n  g_signal_connect (manager, \"job-removed\", G_CALLBACK (job_removed_cb), &data);\n\n  g_main_loop_run (main_loop);\n\n  res = TRUE;\n\nout:\n  if (main_loop)\n    g_main_loop_unref (main_loop);\n  if (manager)\n    g_object_unref (manager);\n\n  return res;\n}\n\nstatic void\nadd_font_path_args (FlatpakBwrap *bwrap)\n{\n  g_autoptr(GString) xml_snippet = g_string_new (\"\");\n  gchar *path_build_tmp = NULL;\n  g_autoptr(GFile) user_font1 = NULL;\n  g_autoptr(GFile) user_font2 = NULL;\n  g_autoptr(GFile) user_font_cache = NULL;\n  g_auto(GStrv) system_cache_dirs = NULL;\n  gboolean found_cache = FALSE;\n  int i;\n\n\n  g_string_append (xml_snippet,\n                   \"<?xml version=\\\"1.0\\\"?>\\n\"\n                   \"<!DOCTYPE fontconfig SYSTEM \\\"fonts.dtd\\\">\\n\"\n                   \"<fontconfig>\\n\");\n\n  if (g_file_test (SYSTEM_FONTS_DIR, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", SYSTEM_FONTS_DIR, \"/run/host/fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/fonts</remap-dir>\\n\",\n                              SYSTEM_FONTS_DIR);\n    }\n\n  if (g_file_test (\"/usr/local/share/fonts\", G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/local/share/fonts\", \"/run/host/local-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/local-fonts</remap-dir>\\n\",\n                              \"/usr/local/share/fonts\");\n    }\n\n  system_cache_dirs = g_strsplit (SYSTEM_FONT_CACHE_DIRS, \":\", 0);\n  for (i = 0; system_cache_dirs[i] != NULL; i++)\n    {\n      if (g_file_test (system_cache_dirs[i], G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", system_cache_dirs[i], \"/run/host/fonts-cache\",\n                                  NULL);\n          found_cache = TRUE;\n          break;\n        }\n    }\n\n  if (!found_cache)\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/fonts-cache\",\n                              \"--remount-ro\", \"/run/host/fonts-cache\",\n                              NULL);\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_data_dir (), \"fonts\", NULL);\n  user_font1 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  path_build_tmp = g_build_filename (g_get_home_dir (), \".fonts\", NULL);\n  user_font2 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font1, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font1), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font1));\n    }\n  else if (g_file_query_exists (user_font2, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font2), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font2));\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_cache_dir (), \"fontconfig\", NULL);\n  user_font_cache = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font_cache, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font_cache), \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n  else\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/user-fonts-cache\",\n                              \"--remount-ro\", \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n\n  g_string_append (xml_snippet,\n                   \"</fontconfig>\\n\");\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"font-dirs.xml\", xml_snippet->str, xml_snippet->len, \"/run/host/font-dirs.xml\", NULL))\n    g_warning (\"Unable to add fontconfig data snippet\");\n}\n\nstatic void\nadd_icon_path_args (FlatpakBwrap *bwrap)\n{\n  g_autofree gchar *user_icons_path = NULL;\n  g_autoptr(GFile) user_icons = NULL;\n\n  if (g_file_test (\"/usr/share/icons\", G_FILE_TEST_IS_DIR))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/share/icons\", \"/run/host/share/icons\",\n                              NULL);\n    }\n\n  user_icons_path = g_build_filename (g_get_user_data_dir (), \"icons\", NULL);\n  user_icons = g_file_new_for_path (user_icons_path);\n  if (g_file_query_exists (user_icons, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_icons), \"/run/host/user-share/icons\",\n                              NULL);\n    }\n}\n\nFlatpakContext *\nflatpak_app_compute_permissions (GKeyFile *app_metadata,\n                                 GKeyFile *runtime_metadata,\n                                 GError  **error)\n{\n  g_autoptr(FlatpakContext) app_context = NULL;\n\n  app_context = flatpak_context_new ();\n\n  if (runtime_metadata != NULL)\n    {\n      if (!flatpak_context_load_metadata (app_context, runtime_metadata, error))\n        return NULL;\n\n      /* Don't inherit any permissions from the runtime, only things like env vars. */\n      flatpak_context_reset_permissions (app_context);\n    }\n\n  if (app_metadata != NULL &&\n      !flatpak_context_load_metadata (app_context, app_metadata, error))\n    return NULL;\n\n  return g_steal_pointer (&app_context);\n}\n\nstatic void\nflatpak_run_gc_ids (void)\n{\n  flatpak_instance_iterate_all_and_gc (NULL);\n}\n\nstatic char *\nflatpak_run_allocate_id (int *lock_fd_out)\n{\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *base_dir = g_build_filename (user_runtime_dir, \".flatpak\", NULL);\n  int count;\n\n  g_mkdir_with_parents (base_dir, 0755);\n\n  flatpak_run_gc_ids ();\n\n  for (count = 0; count < 1000; count++)\n    {\n      g_autofree char *instance_id = NULL;\n      g_autofree char *instance_dir = NULL;\n\n      instance_id = g_strdup_printf (\"%u\", g_random_int ());\n\n      instance_dir = g_build_filename (base_dir, instance_id, NULL);\n\n      /* We use an atomic mkdir to ensure the instance id is unique */\n      if (mkdir (instance_dir, 0755) == 0)\n        {\n          g_autofree char *lock_file = g_build_filename (instance_dir, \".ref\", NULL);\n          glnx_autofd int lock_fd = -1;\n          struct flock l = {\n            .l_type = F_RDLCK,\n            .l_whence = SEEK_SET,\n            .l_start = 0,\n            .l_len = 0\n          };\n\n          /* Then we take a file lock inside the dir, hold that during\n           * setup and in bwrap. Anyone trying to clean up unused\n           * directories need to first verify that there is a .ref\n           * file and take a write lock on .ref to ensure its not in\n           * use. */\n          lock_fd = open (lock_file, O_RDWR | O_CREAT | O_CLOEXEC, 0644);\n          /* There is a tiny race here between the open creating the file and the lock succeeding.\n             We work around that by only gc:ing \"old\" .ref files */\n          if (lock_fd != -1 && fcntl (lock_fd, F_SETLK, &l) == 0)\n            {\n              *lock_fd_out = glnx_steal_fd (&lock_fd);\n              g_debug (\"Allocated instance id %s\", instance_id);\n              return g_steal_pointer (&instance_id);\n            }\n        }\n    }\n\n  return NULL;\n}\n\n#ifdef HAVE_DCONF\n\nstatic void\nadd_dconf_key_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *key,\n                          DConfReadFlags flags)\n{\n  g_autofree char *group = g_path_get_dirname (key);\n  g_autofree char *k = g_path_get_basename (key);\n  GVariant *value = dconf_client_read_full (client, key, flags, NULL);\n\n  if (value)\n    {\n      g_autofree char *val = g_variant_print (value, TRUE);\n      g_key_file_set_value (keyfile, group + 1, k, val);\n    }\n}\n\nstatic void\nadd_dconf_dir_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *dir,\n                          DConfReadFlags flags)\n{\n  g_auto(GStrv) keys = NULL;\n  int i;\n\n  keys = dconf_client_list (client, dir, NULL);\n  for (i = 0; keys[i]; i++)\n    {\n      g_autofree char *k = g_strconcat (dir, keys[i], NULL);\n      if (dconf_is_dir (k, NULL))\n        add_dconf_dir_to_keyfile (keyfile, client, k, flags);\n      else if (dconf_is_key (k, NULL))\n        add_dconf_key_to_keyfile (keyfile, client, k, flags);\n    }\n}\n\nstatic void\nadd_dconf_locks_to_list (GString     *s,\n                         DConfClient *client,\n                         const char  *dir)\n{\n  g_auto(GStrv) locks = NULL;\n  int i;\n\n  locks = dconf_client_list_locks (client, dir, NULL);\n  for (i = 0; locks[i]; i++)\n    {\n      g_string_append (s, locks[i]);\n      g_string_append_c (s, '\\n');\n    }\n}\n\n#endif /* HAVE_DCONF */\n\nstatic void\nget_dconf_data (const char  *app_id,\n                const char **paths,\n                const char  *migrate_path,\n                char       **defaults,\n                gsize       *defaults_size,\n                char       **values,\n                gsize       *values_size,\n                char       **locks,\n                gsize       *locks_size)\n{\n#ifdef HAVE_DCONF\n  DConfClient *client = NULL;\n  g_autofree char *prefix = NULL;\n#endif\n  g_autoptr(GKeyFile) defaults_data = NULL;\n  g_autoptr(GKeyFile) values_data = NULL;\n  g_autoptr(GString) locks_data = NULL;\n\n  defaults_data = g_key_file_new ();\n  values_data = g_key_file_new ();\n  locks_data = g_string_new (\"\");\n\n#ifdef HAVE_DCONF\n\n  client = dconf_client_new ();\n\n  prefix = flatpak_dconf_path_for_app_id (app_id);\n\n  if (migrate_path)\n    {\n      g_debug (\"Add values in dir '%s', prefix is '%s'\", migrate_path, prefix);\n      if (flatpak_dconf_path_is_similar (migrate_path, prefix))\n        add_dconf_dir_to_keyfile (values_data, client, migrate_path, DCONF_READ_USER_VALUE);\n      else\n        g_warning (\"Ignoring D-Conf migrate-path setting %s\", migrate_path);\n    }\n\n  g_debug (\"Add defaults in dir %s\", prefix);\n  add_dconf_dir_to_keyfile (defaults_data, client, prefix, DCONF_READ_DEFAULT_VALUE);\n\n  g_debug (\"Add locks in dir %s\", prefix);\n  add_dconf_locks_to_list (locks_data, client, prefix);\n\n  /* We allow extra paths for defaults and locks, but not for user values */\n  if (paths)\n    {\n      int i;\n      for (i = 0; paths[i]; i++)\n        {\n          if (dconf_is_dir (paths[i], NULL))\n            {\n              g_debug (\"Add defaults in dir %s\", paths[i]);\n              add_dconf_dir_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n\n              g_debug (\"Add locks in dir %s\", paths[i]);\n              add_dconf_locks_to_list (locks_data, client, paths[i]);\n            }\n          else if (dconf_is_key (paths[i], NULL))\n            {\n              g_debug (\"Add individual key %s\", paths[i]);\n              add_dconf_key_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n              add_dconf_key_to_keyfile (values_data, client, paths[i], DCONF_READ_USER_VALUE);\n            }\n          else\n            {\n              g_warning (\"Ignoring settings path '%s': neither dir nor key\", paths[i]);\n            }\n        }\n    }\n#endif\n\n  *defaults = g_key_file_to_data (defaults_data, defaults_size, NULL);\n  *values = g_key_file_to_data (values_data, values_size, NULL);\n  *locks_size = locks_data->len;\n  *locks = g_string_free (g_steal_pointer (&locks_data), FALSE);\n\n#ifdef HAVE_DCONF\n  g_object_unref (client);\n#endif\n}\n\nstatic gboolean\nflatpak_run_add_dconf_args (FlatpakBwrap *bwrap,\n                            const char   *app_id,\n                            GKeyFile     *metakey,\n                            GError      **error)\n{\n  g_auto(GStrv) paths = NULL;\n  g_autofree char *migrate_path = NULL;\n  g_autofree char *defaults = NULL;\n  g_autofree char *values = NULL;\n  g_autofree char *locks = NULL;\n  gsize defaults_size;\n  gsize values_size;\n  gsize locks_size;\n\n  if (metakey)\n    {\n      paths = g_key_file_get_string_list (metakey,\n                                          FLATPAK_METADATA_GROUP_DCONF,\n                                          FLATPAK_METADATA_KEY_DCONF_PATHS,\n                                          NULL, NULL);\n      migrate_path = g_key_file_get_string (metakey,\n                                            FLATPAK_METADATA_GROUP_DCONF,\n                                            FLATPAK_METADATA_KEY_DCONF_MIGRATE_PATH,\n                                            NULL);\n    }\n\n  get_dconf_data (app_id,\n                  (const char **) paths,\n                  migrate_path,\n                  &defaults, &defaults_size,\n                  &values, &values_size,\n                  &locks, &locks_size);\n\n  if (defaults_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-defaults\",\n                                    defaults, defaults_size,\n                                    \"/etc/glib-2.0/settings/defaults\",\n                                    error))\n    return FALSE;\n\n  if (locks_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-locks\",\n                                    locks, locks_size,\n                                    \"/etc/glib-2.0/settings/locks\",\n                                    error))\n    return FALSE;\n\n  /* We do a one-time conversion of existing dconf settings to a keyfile.\n   * Only do that once the app stops requesting dconf access.\n   */\n  if (migrate_path)\n    {\n      g_autofree char *filename = NULL;\n\n      filename = g_build_filename (g_get_home_dir (),\n                                   \".var/app\", app_id,\n                                   \"config/glib-2.0/settings/keyfile\",\n                                   NULL);\n\n      g_debug (\"writing D-Conf values to %s\", filename);\n\n      if (values_size != 0 && !g_file_test (filename, G_FILE_TEST_EXISTS))\n        {\n          g_autofree char *dir = g_path_get_dirname (filename);\n\n          if (g_mkdir_with_parents (dir, 0700) == -1)\n            {\n              g_warning (\"failed creating dirs for %s\", filename);\n              return FALSE;\n            }\n\n          if (!g_file_set_contents (filename, values, values_size, error))\n            {\n              g_warning (\"failed writing %s\", filename);\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_add_app_info_args (FlatpakBwrap       *bwrap,\n                               GFile              *app_files,\n                               GBytes             *app_deploy_data,\n                               const char         *app_extensions,\n                               GFile              *runtime_files,\n                               GBytes             *runtime_deploy_data,\n                               const char         *runtime_extensions,\n                               const char         *app_id,\n                               const char         *app_branch,\n                               FlatpakDecomposed  *runtime_ref,\n                               GFile              *app_id_dir,\n                               FlatpakContext     *final_app_context,\n                               FlatpakContext     *cmdline_context,\n                               gboolean            sandbox,\n                               gboolean            build,\n                               gboolean            devel,\n                               char              **app_info_path_out,\n                               int                 instance_id_fd,\n                               char              **instance_id_host_dir_out,\n                               GError             **error)\n{\n  g_autofree char *info_path = NULL;\n  g_autofree char *bwrapinfo_path = NULL;\n  int fd, fd2, fd3;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree char *runtime_path = NULL;\n  g_autofree char *old_dest = g_strdup_printf (\"/run/user/%d/flatpak-info\", getuid ());\n  const char *group;\n  g_autofree char *instance_id = NULL;\n  glnx_autofd int lock_fd = -1;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autofree char *instance_id_sandbox_dir = NULL;\n  g_autofree char *instance_id_lock_file = NULL;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  instance_id = flatpak_run_allocate_id (&lock_fd);\n  if (instance_id == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Unable to allocate instance id\"));\n\n  instance_id_host_dir = g_build_filename (user_runtime_dir, \".flatpak\", instance_id, NULL);\n  instance_id_sandbox_dir = g_strdup_printf (\"/run/user/%d/.flatpak/%s\", getuid (), instance_id);\n  instance_id_lock_file = g_build_filename (instance_id_sandbox_dir, \".ref\", NULL);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\",\n                          instance_id_host_dir,\n                          instance_id_sandbox_dir,\n                          \"--lock-file\",\n                          instance_id_lock_file,\n                          NULL);\n  /* Keep the .ref lock held until we've started bwrap to avoid races */\n  flatpak_bwrap_add_noinherit_fd (bwrap, glnx_steal_fd (&lock_fd));\n\n  info_path = g_build_filename (instance_id_host_dir, \"info\", NULL);\n\n  keyfile = g_key_file_new ();\n\n  if (app_files)\n    group = FLATPAK_METADATA_GROUP_APPLICATION;\n  else\n    group = FLATPAK_METADATA_GROUP_RUNTIME;\n\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_NAME, app_id);\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_RUNTIME,\n                         flatpak_decomposed_get_ref (runtime_ref));\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_INSTANCE_ID, instance_id);\n  if (app_id_dir)\n    {\n      g_autofree char *instance_path = g_file_get_path (app_id_dir);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_INSTANCE_PATH, instance_path);\n    }\n\n  if (app_files)\n    {\n      g_autofree char *app_path = g_file_get_path (app_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_APP_PATH, app_path);\n    }\n  if (app_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_COMMIT, flatpak_deploy_data_get_commit (app_deploy_data));\n  if (app_extensions && *app_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_EXTENSIONS, app_extensions);\n  runtime_path = g_file_get_path (runtime_files);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_RUNTIME_PATH, runtime_path);\n  if (runtime_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_COMMIT, flatpak_deploy_data_get_commit (runtime_deploy_data));\n  if (runtime_extensions && *runtime_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_EXTENSIONS, runtime_extensions);\n  if (app_branch != NULL)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_BRANCH, app_branch);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_ARCH, arch);\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_FLATPAK_VERSION, PACKAGE_VERSION);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SESSION_BUS_PROXY, TRUE);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SYSTEM_BUS_PROXY, TRUE);\n\n  if (sandbox)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SANDBOX, TRUE);\n  if (build)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_BUILD, TRUE);\n  if (devel)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_DEVEL, TRUE);\n\n  if (cmdline_context)\n    {\n      g_autoptr(GPtrArray) cmdline_args = g_ptr_array_new_with_free_func (g_free);\n      flatpak_context_to_args (cmdline_context, cmdline_args);\n      if (cmdline_args->len > 0)\n        {\n          g_key_file_set_string_list (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_EXTRA_ARGS,\n                                      (const char * const *) cmdline_args->pdata,\n                                      cmdline_args->len);\n        }\n    }\n\n  flatpak_context_save_metadata (final_app_context, TRUE, keyfile);\n\n  if (!g_key_file_save_to_file (keyfile, info_path, error))\n    return FALSE;\n\n  /* We want to create a file on /.flatpak-info that the app cannot modify, which\n     we do by creating a read-only bind mount. This way one can openat()\n     /proc/$pid/root, and if that succeeds use openat via that to find the\n     unfakable .flatpak-info file. However, there is a tiny race in that if\n     you manage to open /proc/$pid/root, but then the pid dies, then\n     every mount but the root is unmounted in the namespace, so the\n     .flatpak-info will be empty. We fix this by first creating a real file\n     with the real info in, then bind-mounting on top of that, the same info.\n     This way even if the bind-mount is unmounted we can find the real data.\n   */\n\n  fd = open (info_path, O_RDONLY);\n  if (fd == -1)\n    {\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  fd2 = open (info_path, O_RDONLY);\n  if (fd2 == -1)\n    {\n      close (fd);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--file\", fd, \"/.flatpak-info\");\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--ro-bind-data\", fd2, \"/.flatpak-info\");\n  flatpak_bwrap_add_args (bwrap,\n                          \"--symlink\", \"../../../.flatpak-info\", old_dest,\n                          NULL);\n\n  /* Tell the application that it's running under Flatpak in a generic way. */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--setenv\", \"container\", \"flatpak\",\n                          NULL);\n  if (!flatpak_bwrap_add_args_data (bwrap,\n                                    \"container-manager\",\n                                    \"flatpak\\n\", -1,\n                                    \"/run/host/container-manager\",\n                                    error))\n    return FALSE;\n\n  bwrapinfo_path = g_build_filename (instance_id_host_dir, \"bwrapinfo.json\", NULL);\n  fd3 = open (bwrapinfo_path, O_RDWR | O_CREAT, 0644);\n  if (fd3 == -1)\n    {\n      close (fd);\n      close (fd2);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open bwrapinfo.json file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  /* NOTE: It is important that this takes place after bwrapinfo.json is created,\n     otherwise start notifications in the portal may not work. */\n  if (instance_id_fd != -1)\n    {\n      gsize instance_id_position = 0;\n      gsize instance_id_size = strlen (instance_id);\n\n      while (instance_id_size > 0)\n        {\n          gssize bytes_written = write (instance_id_fd, instance_id + instance_id_position, instance_id_size);\n          if (G_UNLIKELY (bytes_written <= 0))\n            {\n              int errsv = bytes_written == -1 ? errno : ENOSPC;\n              if (errsv == EINTR)\n                continue;\n\n              close (fd);\n              close (fd2);\n              close (fd3);\n\n              g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                           _(\"Failed to write to instance id fd: %s\"), g_strerror (errsv));\n              return FALSE;\n            }\n\n          instance_id_position += bytes_written;\n          instance_id_size -= bytes_written;\n        }\n\n      close (instance_id_fd);\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--info-fd\", fd3, NULL);\n\n  if (app_info_path_out != NULL)\n    *app_info_path_out = g_strdup_printf (\"/proc/self/fd/%d\", fd);\n\n  if (instance_id_host_dir_out != NULL)\n    *instance_id_host_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n\nstatic void\nadd_tzdata_args (FlatpakBwrap *bwrap,\n                 GFile *runtime_files)\n{\n  g_autofree char *raw_timezone = flatpak_get_timezone ();\n  g_autofree char *timezone_content = g_strdup_printf (\"%s\\n\", raw_timezone);\n  g_autofree char *localtime_content = g_strconcat (\"../usr/share/zoneinfo/\", raw_timezone, NULL);\n  g_autoptr(GFile) runtime_zoneinfo = NULL;\n\n  if (runtime_files)\n    runtime_zoneinfo = g_file_resolve_relative_path (runtime_files, \"share/zoneinfo\");\n\n  /* Check for runtime /usr/share/zoneinfo */\n  if (runtime_zoneinfo != NULL && g_file_query_exists (runtime_zoneinfo, NULL))\n    {\n      /* Check for host /usr/share/zoneinfo */\n      if (g_file_test (\"/usr/share/zoneinfo\", G_FILE_TEST_IS_DIR))\n        {\n          /* Here we assume the host timezone file exist in the host data */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", \"/usr/share/zoneinfo\", \"/usr/share/zoneinfo\",\n                                  \"--symlink\", localtime_content, \"/etc/localtime\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) runtime_tzfile = g_file_resolve_relative_path (runtime_zoneinfo, raw_timezone);\n\n          /* Check if host timezone file exist in the runtime tzdata */\n          if (g_file_query_exists (runtime_tzfile, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--symlink\", localtime_content, \"/etc/localtime\",\n                                    NULL);\n        }\n    }\n\n  flatpak_bwrap_add_args_data (bwrap, \"timezone\",\n                               timezone_content, -1, \"/etc/timezone\",\n                               NULL);\n}\n\nstatic void\nadd_monitor_path_args (gboolean      use_session_helper,\n                       FlatpakBwrap *bwrap)\n{\n  g_autoptr(AutoFlatpakSessionHelper) session_helper = NULL;\n  g_autofree char *monitor_path = NULL;\n  g_autofree char *pkcs11_socket_path = NULL;\n  g_autoptr(GVariant) session_data = NULL;\n\n  if (use_session_helper)\n    {\n      session_helper =\n        flatpak_session_helper_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION,\n                                                       G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES | G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,\n                                                       \"org.freedesktop.Flatpak\",\n                                                       \"/org/freedesktop/Flatpak/SessionHelper\",\n                                                       NULL, NULL);\n    }\n\n  if (session_helper &&\n      flatpak_session_helper_call_request_session_sync (session_helper,\n                                                        &session_data,\n                                                        NULL, NULL))\n    {\n      if (g_variant_lookup (session_data, \"path\", \"s\", &monitor_path))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", monitor_path, \"/run/host/monitor\",\n                                \"--symlink\", \"/run/host/monitor/resolv.conf\", \"/etc/resolv.conf\",\n                                \"--symlink\", \"/run/host/monitor/host.conf\", \"/etc/host.conf\",\n                                \"--symlink\", \"/run/host/monitor/hosts\", \"/etc/hosts\",\n                                NULL);\n\n      if (g_variant_lookup (session_data, \"pkcs11-socket\", \"s\", &pkcs11_socket_path))\n        {\n          g_autofree char *sandbox_pkcs11_socket_path = g_strdup_printf (\"/run/user/%d/p11-kit/pkcs11\", getuid ());\n          const char *trusted_module_contents =\n            \"# This overrides the runtime p11-kit-trusted module with a client one talking to the trust module on the host\\n\"\n            \"module: p11-kit-client.so\\n\";\n\n          if (flatpak_bwrap_add_args_data (bwrap, \"p11-kit-trust.module\",\n                                           trusted_module_contents, -1,\n                                           \"/etc/pkcs11/modules/p11-kit-trust.module\", NULL))\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--ro-bind\", pkcs11_socket_path, sandbox_pkcs11_socket_path,\n                                      NULL);\n              flatpak_bwrap_unset_env (bwrap, \"P11_KIT_SERVER_ADDRESS\");\n            }\n        }\n    }\n  else\n    {\n      if (g_file_test (\"/etc/resolv.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/resolv.conf\", \"/etc/resolv.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/host.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/host.conf\", \"/etc/host.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/hosts\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/hosts\", \"/etc/hosts\",\n                                NULL);\n    }\n}\n\nstatic void\nadd_document_portal_args (FlatpakBwrap *bwrap,\n                          const char   *app_id,\n                          char        **out_mount_path)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *doc_mount_path = NULL;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GDBusMessage) reply = NULL;\n      g_autoptr(GDBusMessage) msg =\n        g_dbus_message_new_method_call (\"org.freedesktop.portal.Documents\",\n                                        \"/org/freedesktop/portal/documents\",\n                                        \"org.freedesktop.portal.Documents\",\n                                        \"GetMountPoint\");\n      g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n      reply =\n        g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                        G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                        30000,\n                                                        NULL,\n                                                        NULL,\n                                                        NULL);\n      if (reply)\n        {\n          if (g_dbus_message_to_gerror (reply, &local_error))\n            {\n              if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n                g_debug (\"Document portal not available, not mounting /run/user/%d/doc\", getuid ());\n              else\n                g_message (\"Can't get document portal: %s\", local_error->message);\n            }\n          else\n            {\n              g_autofree char *src_path = NULL;\n              g_autofree char *dst_path = NULL;\n              g_variant_get (g_dbus_message_get_body (reply),\n                             \"(^ay)\", &doc_mount_path);\n\n              src_path = g_strdup_printf (\"%s/by-app/%s\",\n                                          doc_mount_path, app_id);\n              dst_path = g_strdup_printf (\"/run/user/%d/doc\", getuid ());\n              flatpak_bwrap_add_args (bwrap, \"--bind\", src_path, dst_path, NULL);\n            }\n        }\n    }\n\n  *out_mount_path = g_steal_pointer (&doc_mount_path);\n}\n\n#ifdef ENABLE_SECCOMP\nstatic const uint32_t seccomp_x86_64_extra_arches[] = { SCMP_ARCH_X86, 0, };\n\n#ifdef SCMP_ARCH_AARCH64\nstatic const uint32_t seccomp_aarch64_extra_arches[] = { SCMP_ARCH_ARM, 0 };\n#endif\n\nstatic inline void\ncleanup_seccomp (void *p)\n{\n  scmp_filter_ctx *pp = (scmp_filter_ctx *) p;\n\n  if (*pp)\n    seccomp_release (*pp);\n}\n\nstatic gboolean\nsetup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}\n#endif\n\nstatic void\nflatpak_run_setup_usr_links (FlatpakBwrap *bwrap,\n                             GFile        *runtime_files)\n{\n  int i;\n\n  if (runtime_files == NULL)\n    return;\n\n  for (i = 0; flatpak_abs_usrmerged_dirs[i] != NULL; i++)\n    {\n      const char *subdir = flatpak_abs_usrmerged_dirs[i];\n      g_autoptr(GFile) runtime_subdir = NULL;\n\n      g_assert (subdir[0] == '/');\n      /* Skip the '/' when using as a subdirectory of the runtime */\n      runtime_subdir = g_file_get_child (runtime_files, subdir + 1);\n\n      if (g_file_query_exists (runtime_subdir, NULL))\n        {\n          g_autofree char *link = g_strconcat (\"usr\", subdir, NULL);\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--symlink\", link, subdir,\n                                  NULL);\n        }\n    }\n}\n\ngboolean\nflatpak_run_setup_base_argv (FlatpakBwrap   *bwrap,\n                             GFile          *runtime_files,\n                             GFile          *app_id_dir,\n                             const char     *arch,\n                             FlatpakRunFlags flags,\n                             GError        **error)\n{\n  g_autofree char *run_dir = NULL;\n  g_autofree char *passwd_contents = NULL;\n  g_autoptr(GString) group_contents = NULL;\n  const char *pkcs11_conf_contents = NULL;\n  struct group *g;\n  gulong pers;\n  gid_t gid = getgid ();\n  g_autoptr(GFile) etc = NULL;\n\n  run_dir = g_strdup_printf (\"/run/user/%d\", getuid ());\n\n  passwd_contents = g_strdup_printf (\"%s:x:%d:%d:%s:%s:%s\\n\"\n                                     \"nfsnobody:x:65534:65534:Unmapped user:/:/sbin/nologin\\n\",\n                                     g_get_user_name (),\n                                     getuid (), gid,\n                                     g_get_real_name (),\n                                     g_get_home_dir (),\n                                     DEFAULT_SHELL);\n\n  group_contents = g_string_new (\"\");\n  g = getgrgid (gid);\n  /* if NULL, the primary group is not known outside the container, so\n   * it might as well stay unknown inside the container... */\n  if (g != NULL)\n    g_string_append_printf (group_contents, \"%s:x:%d:%s\\n\",\n                            g->gr_name, gid, g_get_user_name ());\n  g_string_append (group_contents, \"nfsnobody:x:65534:\\n\");\n\n  pkcs11_conf_contents =\n    \"# Disable user pkcs11 config, because the host modules don't work in the runtime\\n\"\n    \"user-config: none\\n\";\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_PROC) == 0)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--proc\", \"/proc\",\n                            NULL);\n\n  if (!(flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS))\n    flatpak_bwrap_add_arg (bwrap, \"--unshare-pid\");\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--dir\", \"/tmp\",\n                          \"--dir\", \"/var/tmp\",\n                          \"--dir\", \"/run/host\",\n                          \"--dir\", run_dir,\n                          \"--setenv\", \"XDG_RUNTIME_DIR\", run_dir,\n                          \"--symlink\", \"../run\", \"/var/run\",\n                          \"--ro-bind\", \"/sys/block\", \"/sys/block\",\n                          \"--ro-bind\", \"/sys/bus\", \"/sys/bus\",\n                          \"--ro-bind\", \"/sys/class\", \"/sys/class\",\n                          \"--ro-bind\", \"/sys/dev\", \"/sys/dev\",\n                          \"--ro-bind\", \"/sys/devices\", \"/sys/devices\",\n                          \"--ro-bind-try\", \"/proc/self/ns/user\", \"/run/.userns\",\n                          /* glib uses this like /etc/timezone */\n                          \"--symlink\", \"/etc/timezone\", \"/var/db/zoneinfo\",\n                          NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_DIE_WITH_PARENT)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--die-with-parent\",\n                            NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/usr/etc\",\n                            \"--symlink\", \"usr/etc\", \"/etc\",\n                            NULL);\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"passwd\", passwd_contents, -1, \"/etc/passwd\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"group\", group_contents->str, -1, \"/etc/group\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"pkcs11.conf\", pkcs11_conf_contents, -1, \"/etc/pkcs11/pkcs11.conf\", error))\n    return FALSE;\n\n  if (g_file_test (\"/etc/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/etc/machine-id\", \"/etc/machine-id\", NULL);\n  else if (g_file_test (\"/var/lib/dbus/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/var/lib/dbus/machine-id\", \"/etc/machine-id\", NULL);\n\n  if (runtime_files)\n    etc = g_file_get_child (runtime_files, \"etc\");\n  if (etc != NULL &&\n      (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0 &&\n      g_file_query_exists (etc, NULL))\n    {\n      g_auto(GLnxDirFdIterator) dfd_iter = { 0, };\n      struct dirent *dent;\n      gboolean inited;\n\n      inited = glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (etc), FALSE, &dfd_iter, NULL);\n\n      while (inited)\n        {\n          g_autofree char *src = NULL;\n          g_autofree char *dest = NULL;\n\n          if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dfd_iter, &dent, NULL, NULL) || dent == NULL)\n            break;\n\n          if (strcmp (dent->d_name, \"passwd\") == 0 ||\n              strcmp (dent->d_name, \"group\") == 0 ||\n              strcmp (dent->d_name, \"machine-id\") == 0 ||\n              strcmp (dent->d_name, \"resolv.conf\") == 0 ||\n              strcmp (dent->d_name, \"host.conf\") == 0 ||\n              strcmp (dent->d_name, \"hosts\") == 0 ||\n              strcmp (dent->d_name, \"localtime\") == 0 ||\n              strcmp (dent->d_name, \"timezone\") == 0 ||\n              strcmp (dent->d_name, \"pkcs11\") == 0)\n            continue;\n\n          src = g_build_filename (flatpak_file_get_path_cached (etc), dent->d_name, NULL);\n          dest = g_build_filename (\"/etc\", dent->d_name, NULL);\n          if (dent->d_type == DT_LNK)\n            {\n              g_autofree char *target = NULL;\n\n              target = glnx_readlinkat_malloc (dfd_iter.fd, dent->d_name,\n                                               NULL, error);\n              if (target == NULL)\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap, \"--symlink\", target, dest, NULL);\n            }\n          else\n            {\n              flatpak_bwrap_add_args (bwrap, \"--ro-bind\", src, dest, NULL);\n            }\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autoptr(GFile) app_cache_dir = g_file_get_child (app_id_dir, \"cache\");\n      g_autoptr(GFile) app_tmp_dir = g_file_get_child (app_cache_dir, \"tmp\");\n      g_autoptr(GFile) app_data_dir = g_file_get_child (app_id_dir, \"data\");\n      g_autoptr(GFile) app_config_dir = g_file_get_child (app_id_dir, \"config\");\n\n      flatpak_bwrap_add_args (bwrap,\n                              /* These are nice to have as a fixed path */\n                              \"--bind\", flatpak_file_get_path_cached (app_cache_dir), \"/var/cache\",\n                              \"--bind\", flatpak_file_get_path_cached (app_data_dir), \"/var/data\",\n                              \"--bind\", flatpak_file_get_path_cached (app_config_dir), \"/var/config\",\n                              \"--bind\", flatpak_file_get_path_cached (app_tmp_dir), \"/var/tmp\",\n                              NULL);\n    }\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files);\n\n  add_tzdata_args (bwrap, runtime_files);\n\n  pers = PER_LINUX;\n\n  if ((flags & FLATPAK_RUN_FLAG_SET_PERSONALITY) &&\n      flatpak_is_linux32_arch (arch))\n    {\n      g_debug (\"Setting personality linux32\");\n      pers = PER_LINUX32;\n    }\n\n  /* Always set the personallity, and clear all weird flags */\n  personality (pers);\n\n#ifdef ENABLE_SECCOMP\n  if (!setup_seccomp (bwrap, arch, pers, flags, error))\n    return FALSE;\n#endif\n\n  if ((flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0)\n    add_monitor_path_args ((flags & FLATPAK_RUN_FLAG_NO_SESSION_HELPER) == 0, bwrap);\n\n  return TRUE;\n}\n\nstatic gboolean\nforward_file (XdpDbusDocuments *documents,\n              const char       *app_id,\n              const char       *file,\n              char            **out_doc_id,\n              GError          **error)\n{\n  int fd, fd_id;\n  g_autofree char *doc_id = NULL;\n  g_autoptr(GUnixFDList) fd_list = NULL;\n  const char *perms[] = { \"read\", \"write\", NULL };\n\n  fd = open (file, O_PATH | O_CLOEXEC);\n  if (fd == -1)\n    return flatpak_fail (error, _(\"Failed to open \u2018%s\u2019\"), file);\n\n  fd_list = g_unix_fd_list_new ();\n  fd_id = g_unix_fd_list_append (fd_list, fd, error);\n  close (fd);\n\n  if (!xdp_dbus_documents_call_add_sync (documents,\n                                         g_variant_new (\"h\", fd_id),\n                                         TRUE, /* reuse */\n                                         FALSE, /* not persistent */\n                                         fd_list,\n                                         &doc_id,\n                                         NULL,\n                                         NULL,\n                                         error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  if (!xdp_dbus_documents_call_grant_permissions_sync (documents,\n                                                       doc_id,\n                                                       app_id,\n                                                       perms,\n                                                       NULL,\n                                                       error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  *out_doc_id = g_steal_pointer (&doc_id);\n\n  return TRUE;\n}\n\nstatic gboolean\nadd_rest_args (FlatpakBwrap   *bwrap,\n               const char     *app_id,\n               FlatpakExports *exports,\n               gboolean        file_forwarding,\n               const char     *doc_mount_path,\n               char           *args[],\n               int             n_args,\n               GError        **error)\n{\n  g_autoptr(XdpDbusDocuments) documents = NULL;\n  gboolean forwarding = FALSE;\n  gboolean forwarding_uri = FALSE;\n  gboolean can_forward = TRUE;\n  int i;\n\n  if (file_forwarding && doc_mount_path == NULL)\n    {\n      g_message (\"Can't get document portal mount path\");\n      can_forward = FALSE;\n    }\n  else if (file_forwarding)\n    {\n      g_autoptr(GError) local_error = NULL;\n\n      documents = xdp_dbus_documents_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION, 0,\n                                                             \"org.freedesktop.portal.Documents\",\n                                                             \"/org/freedesktop/portal/documents\",\n                                                             NULL,\n                                                             &local_error);\n      if (documents == NULL)\n        {\n          g_message (\"Can't get document portal: %s\", local_error->message);\n          can_forward = FALSE;\n        }\n    }\n\n  for (i = 0; i < n_args; i++)\n    {\n      g_autoptr(GFile) file = NULL;\n\n      if (file_forwarding &&\n          (strcmp (args[i], \"@@\") == 0 ||\n           strcmp (args[i], \"@@u\") == 0))\n        {\n          forwarding_uri = strcmp (args[i], \"@@u\") == 0;\n          forwarding = !forwarding;\n          continue;\n        }\n\n      if (can_forward && forwarding)\n        {\n          if (forwarding_uri)\n            {\n              if (g_str_has_prefix (args[i], \"file:\"))\n                file = g_file_new_for_uri (args[i]);\n              else if (G_IS_DIR_SEPARATOR (args[i][0]))\n                file = g_file_new_for_path (args[i]);\n            }\n          else\n            file = g_file_new_for_path (args[i]);\n        }\n\n      if (file && !flatpak_exports_path_is_visible (exports,\n                                                    flatpak_file_get_path_cached (file)))\n        {\n          g_autofree char *doc_id = NULL;\n          g_autofree char *basename = NULL;\n          g_autofree char *doc_path = NULL;\n          if (!forward_file (documents, app_id, flatpak_file_get_path_cached (file),\n                             &doc_id, error))\n            return FALSE;\n\n          basename = g_file_get_basename (file);\n          doc_path = g_build_filename (doc_mount_path, doc_id, basename, NULL);\n\n          if (forwarding_uri)\n            {\n              g_autofree char *path = doc_path;\n              doc_path = g_filename_to_uri (path, NULL, NULL);\n              /* This should never fail */\n              g_assert (doc_path != NULL);\n            }\n\n          g_debug (\"Forwarding file '%s' as '%s' to %s\", args[i], doc_path, app_id);\n          flatpak_bwrap_add_arg (bwrap, doc_path);\n        }\n      else\n        flatpak_bwrap_add_arg (bwrap, args[i]);\n    }\n\n  return TRUE;\n}\n\nFlatpakContext *\nflatpak_context_load_for_deploy (FlatpakDeploy *deploy,\n                                 GError       **error)\n{\n  g_autoptr(FlatpakContext) context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n  context = flatpak_app_compute_permissions (metakey, NULL, error);\n  if (context == NULL)\n    return NULL;\n\n  overrides = flatpak_deploy_get_overrides (deploy);\n  flatpak_context_merge (context, overrides);\n\n  return g_steal_pointer (&context);\n}\n\nstatic char *\ncalculate_ld_cache_checksum (GBytes   *app_deploy_data,\n                             GBytes   *runtime_deploy_data,\n                             const char *app_extensions,\n                             const char *runtime_extensions)\n{\n  g_autoptr(GChecksum) ld_so_checksum = g_checksum_new (G_CHECKSUM_SHA256);\n  if (app_deploy_data)\n    g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (app_deploy_data), -1);\n  g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (runtime_deploy_data), -1);\n  if (app_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) app_extensions, -1);\n  if (runtime_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) runtime_extensions, -1);\n\n  return g_strdup (g_checksum_get_string (ld_so_checksum));\n}\n\nstatic gboolean\nadd_ld_so_conf (FlatpakBwrap *bwrap,\n                GError      **error)\n{\n  const char *contents =\n    \"include /run/flatpak/ld.so.conf.d/app-*.conf\\n\"\n    \"include /app/etc/ld.so.conf\\n\"\n    \"/app/lib\\n\"\n    \"include /run/flatpak/ld.so.conf.d/runtime-*.conf\\n\";\n\n  return flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                      contents, -1, \"/etc/ld.so.conf\", error);\n}\n\nstatic int\nregenerate_ld_cache (GPtrArray    *base_argv_array,\n                     GArray       *base_fd_array,\n                     GFile        *app_id_dir,\n                     const char   *checksum,\n                     GFile        *runtime_files,\n                     gboolean      generate_ld_so_conf,\n                     GCancellable *cancellable,\n                     GError      **error)\n{\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_autoptr(GArray) combined_fd_array = NULL;\n  g_autoptr(GFile) ld_so_cache = NULL;\n  g_autoptr(GFile) ld_so_cache_tmp = NULL;\n  g_autofree char *sandbox_cache_path = NULL;\n  g_autofree char *tmp_basename = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  g_autofree char *commandline = NULL;\n  int exit_status;\n  glnx_autofd int ld_so_fd = -1;\n  g_autoptr(GFile) ld_so_dir = NULL;\n\n  if (app_id_dir)\n    ld_so_dir = g_file_get_child (app_id_dir, \".ld.so\");\n  else\n    {\n      g_autoptr(GFile) base_dir = g_file_new_for_path (g_get_user_cache_dir ());\n      ld_so_dir = g_file_resolve_relative_path (base_dir, \"flatpak/ld.so\");\n    }\n\n  ld_so_cache = g_file_get_child (ld_so_dir, checksum);\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache), O_RDONLY);\n  if (ld_so_fd >= 0)\n    return glnx_steal_fd (&ld_so_fd);\n\n  g_debug (\"Regenerating ld.so.cache %s\", flatpak_file_get_path_cached (ld_so_cache));\n\n  if (!flatpak_mkdir_p (ld_so_dir, cancellable, error))\n    return FALSE;\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n\n  flatpak_bwrap_append_args (bwrap, base_argv_array);\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files);\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return -1;\n    }\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--symlink\", \"../usr/etc/ld.so.conf\", \"/etc/ld.so.conf\",\n                            NULL);\n\n  tmp_basename = g_strconcat (checksum, \".XXXXXX\", NULL);\n  glnx_gen_temp_name (tmp_basename);\n\n  sandbox_cache_path = g_build_filename (\"/run/ld-so-cache-dir\", tmp_basename, NULL);\n  ld_so_cache_tmp = g_file_get_child (ld_so_dir, tmp_basename);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--unshare-pid\",\n                          \"--unshare-ipc\",\n                          \"--unshare-net\",\n                          \"--proc\", \"/proc\",\n                          \"--dev\", \"/dev\",\n                          \"--bind\", flatpak_file_get_path_cached (ld_so_dir), \"/run/ld-so-cache-dir\",\n                          NULL);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return -1;\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"ldconfig\", \"-X\", \"-C\", sandbox_cache_path, NULL);\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running: '%s'\", commandline);\n\n  combined_fd_array = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_append_vals (combined_fd_array, base_fd_array->data, base_fd_array->len);\n  g_array_append_vals (combined_fd_array, bwrap->fds->data, bwrap->fds->len);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_sync (NULL,\n                     (char **) bwrap->argv->pdata,\n                     bwrap->envp,\n                     G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                     flatpak_bwrap_child_setup_cb, combined_fd_array,\n                     NULL, NULL,\n                     &exit_status,\n                     error))\n    return -1;\n\n  if (!WIFEXITED (exit_status) || WEXITSTATUS (exit_status) != 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                          _(\"ldconfig failed, exit status %d\"), exit_status);\n      return -1;\n    }\n\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache_tmp), O_RDONLY);\n  if (ld_so_fd < 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Can't open generated ld.so.cache\"));\n      return -1;\n    }\n\n  if (app_id_dir == NULL)\n    {\n      /* For runs without an app id dir we always regenerate the ld.so.cache */\n      unlink (flatpak_file_get_path_cached (ld_so_cache_tmp));\n    }\n  else\n    {\n      g_autoptr(GFile) active = g_file_get_child (ld_so_dir, \"active\");\n\n      /* For app-dirs we keep one checksum alive, by pointing the active symlink to it */\n\n      /* Rename to known name, possibly overwriting existing ref if race */\n      if (rename (flatpak_file_get_path_cached (ld_so_cache_tmp), flatpak_file_get_path_cached (ld_so_cache)) == -1)\n        {\n          glnx_set_error_from_errno (error);\n          return -1;\n        }\n\n      if (!flatpak_switch_symlink_and_remove (flatpak_file_get_path_cached (active),\n                                              checksum, error))\n        return -1;\n    }\n\n  return glnx_steal_fd (&ld_so_fd);\n}\n\n/* Check that this user is actually allowed to run this app. When running\n * from the gnome-initial-setup session, an app filter might not be available. */\nstatic gboolean\ncheck_parental_controls (FlatpakDecomposed *app_ref,\n                         FlatpakDeploy     *deploy,\n                         GCancellable      *cancellable,\n                         GError           **error)\n{\n#ifdef HAVE_LIBMALCONTENT\n  g_autoptr(MctManager) manager = NULL;\n  g_autoptr(MctAppFilter) app_filter = NULL;\n  g_autoptr(GAsyncResult) app_filter_result = NULL;\n  g_autoptr(GDBusConnection) system_bus = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDesktopAppInfo) app_info = NULL;\n  gboolean allowed = FALSE;\n\n  system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, error);\n  if (system_bus == NULL)\n    return FALSE;\n\n  manager = mct_manager_new (system_bus);\n  app_filter = mct_manager_get_app_filter (manager, getuid (),\n                                           MCT_GET_APP_FILTER_FLAGS_INTERACTIVE,\n                                           cancellable, &local_error);\n  if (g_error_matches (local_error, MCT_APP_FILTER_ERROR, MCT_APP_FILTER_ERROR_DISABLED))\n    {\n      g_debug (\"Skipping parental controls check for %s since parental \"\n               \"controls are disabled globally\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN) ||\n           g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NAME_HAS_NO_OWNER))\n    {\n      g_debug (\"Skipping parental controls check for %s since a required \"\n               \"service was not found\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  /* Always filter by app ID. Additionally, filter by app info (which runs\n   * multiple checks, including whether the app ID, executable path and\n   * content types are allowed) if available. If the flatpak contains\n   * multiple .desktop files, we use the main one. The app ID check is\n   * always done, as the binary executed by `flatpak run` isn\u2019t necessarily\n   * extracted from a .desktop file. */\n  allowed = mct_app_filter_is_flatpak_ref_allowed (app_filter, flatpak_decomposed_get_ref (app_ref));\n\n  /* Look up the app\u2019s main .desktop file. */\n  if (deploy != NULL && allowed)\n    {\n      g_autoptr(GFile) deploy_dir = NULL;\n      const char *deploy_path;\n      g_autofree char *desktop_file_name = NULL;\n      g_autofree char *desktop_file_path = NULL;\n      g_autofree char *app_id = flatpak_decomposed_dup_id (app_ref);\n\n      deploy_dir = flatpak_deploy_get_dir (deploy);\n      deploy_path = flatpak_file_get_path_cached (deploy_dir);\n\n      desktop_file_name = g_strconcat (app_id, \".desktop\", NULL);\n      desktop_file_path = g_build_path (G_DIR_SEPARATOR_S,\n                                        deploy_path,\n                                        \"export\",\n                                        \"share\",\n                                        \"applications\",\n                                        desktop_file_name,\n                                        NULL);\n      app_info = g_desktop_app_info_new_from_filename (desktop_file_path);\n    }\n\n  if (app_info != NULL)\n    allowed = allowed && mct_app_filter_is_appinfo_allowed (app_filter,\n                                                            G_APP_INFO (app_info));\n\n  if (!allowed)\n    return flatpak_fail_error (error, FLATPAK_ERROR_PERMISSION_DENIED,\n                               /* Translators: The placeholder is for an app ref. */\n                               _(\"Running %s is not allowed by the policy set by your administrator\"),\n                               flatpak_decomposed_get_ref (app_ref));\n#endif  /* HAVE_LIBMALCONTENT */\n\n  return TRUE;\n}\n\nstatic int\nopen_namespace_fd_if_needed (const char *path,\n                             const char *other_path) {\n  struct stat s, other_s;\n\n  if (stat (path, &s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  if (stat (other_path, &other_s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  /* setns calls fail if the process is already in the desired namespace, hence the\n     check here to ensure the namespaces are different. */\n  if (s.st_ino != other_s.st_ino)\n    return open (path, O_RDONLY|O_CLOEXEC);\n\n  return -1;\n}\n\nstatic gboolean\ncheck_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n\n  /* This check exists to stop accidental usage of `sudo flatpak run`\n     and is not to prevent running as root.\n   */\n\n  if (!sudo_command_env)\n    return TRUE;\n\n  /* SUDO_COMMAND could be a value like `/usr/bin/flatpak run foo` */\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be ran with sudo\"));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          \"--lock-file\", \"/usr/.ref\",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                            \"--lock-file\", \"/app/.ref\",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/app\",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n"], "filenames": ["common/flatpak-bwrap-private.h", "common/flatpak-bwrap.c", "common/flatpak-run.c"], "buggy_code_start_loc": [45, 111, 1465], "buggy_code_end_loc": [75, 276, 4127], "fixing_code_start_loc": [46, 112, 1464], "fixing_code_end_loc": [79, 320, 4124], "type": "CWE-74", "message": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.", "other": {"cve": {"id": "CVE-2021-21261", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-14T20:15:12.360", "lastModified": "2021-01-27T19:34:12.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0."}, {"lang": "es", "value": "Flatpak es un sistema para crear, distribuir y ejecutar aplicaciones de escritorio en sandbox en Linux. Se detect\u00f3 un fallo en el servicio \"flatpak-portal\" que puede permitir que las aplicaciones en sandbox ejecuten c\u00f3digo arbitrario en el sistema host (un escape del sandbox). Este fallo de escape del sandbox est\u00e1 presente en las versiones 0.11.4 y anteriores a las versiones reparadas 1.8.5 y 1.10.0. El servicio D-Bus del portal Flatpak (\"flatpak-portal\", tambi\u00e9n conocido por su nombre de servicio D-Bus \"org.freedesktop.portal.Flatpak\") permite que las aplicaciones en un sandbox de Flatpak inicien sus propios subprocesos en una nueva instancia del sandbox, ya sea con la misma configuraci\u00f3n de seguridad que la persona que llama o con una configuraci\u00f3n de seguridad m\u00e1s restrictiva. Por ejemplo, esto se usa en navegadores web empaquetados con Flatpak, como Chromium, para iniciar subprocesos que procesar\u00e1n contenido web no confiable. y dar a esos subprocesos un sandbox m\u00e1s restrictivo que el propio navegador. En versiones vulnerables, el servicio del portal Flatpak pasa las variables de entorno especificadas por la persona que llama hacia procesos que no est\u00e1n en el sandbox en el sistema host y, en particular, al comando \"flatpak run\" que se usa para iniciar la nueva instancia del sandbox. Una aplicaci\u00f3n Flatpak maliciosa o comprometida podr\u00eda establecer variables de entorno en las que conf\u00ede el comando \"flatpak run\" y usarlas para ejecutar c\u00f3digo arbitrario que no se encuentra en un sandbox. Como soluci\u00f3n alternativa, esta vulnerabilidad puede ser mitigada evitando que se inicie el servicio \"flatpak-portal\", pero esa mitigaci\u00f3n impedir\u00e1 que muchas aplicaciones de Flatpak funcionen correctamente. Esto se corrige en las versiones 1.8.5 y 1.10.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.11.4", "versionEndExcluding": "1.8.5", "matchCriteriaId": "041D999E-622C-4771-9819-57C6F1BE7056"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.9.1", "versionEndExcluding": "1.10.0", "matchCriteriaId": "FD8B7A39-7AB9-43AA-9B31-B2112B6D90CF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/6e5ae7a109cdfa9735ea7ccbd8cb79f9e8d3ae8b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/cc1401043c075268ecc652eac557ef8076b5eaba", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/releases/tag/1.8.5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202101-21", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4830", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486"}}