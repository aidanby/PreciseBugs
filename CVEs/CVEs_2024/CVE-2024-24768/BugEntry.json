{"buggy_code": ["package service\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/encrypt\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/jwt\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/mfa\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"github.com/pkg/errors\"\n)\n\ntype AuthService struct{}\n\ntype IAuthService interface {\n\tCheckIsSafety(code string) (string, error)\n\tVerifyCode(code string) (bool, error)\n\tLogin(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error)\n\tLogOut(c *gin.Context) error\n\tMFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error)\n}\n\nfunc NewIAuthService() IAuthService {\n\treturn &AuthService{}\n}\n\nfunc (u *AuthService) Login(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error) {\n\tnameSetting, err := settingRepo.Get(settingRepo.WithByKey(\"UserName\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpasswordSetting, err := settingRepo.Get(settingRepo.WithByKey(\"Password\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpass, err := encrypt.StringDecrypt(passwordSetting.Value)\n\tif err != nil {\n\t\treturn nil, constant.ErrAuth\n\t}\n\tif info.Password != pass || nameSetting.Value != info.Name {\n\t\treturn nil, constant.ErrAuth\n\t}\n\tentranceSetting, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {\n\t\treturn nil, buserr.New(constant.ErrEntrance)\n\t}\n\tmfa, err := settingRepo.Get(settingRepo.WithByKey(\"MFAStatus\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = settingRepo.Update(\"Language\", info.Language); err != nil {\n\t\treturn nil, err\n\t}\n\tif mfa.Value == \"enable\" {\n\t\treturn &dto.UserLoginInfo{Name: nameSetting.Value, MfaStatus: mfa.Value}, nil\n\t}\n\treturn u.generateSession(c, info.Name, info.AuthMethod)\n}\n\nfunc (u *AuthService) MFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error) {\n\tnameSetting, err := settingRepo.Get(settingRepo.WithByKey(\"UserName\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpasswordSetting, err := settingRepo.Get(settingRepo.WithByKey(\"Password\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpass, err := encrypt.StringDecrypt(passwordSetting.Value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif info.Password != pass || nameSetting.Value != info.Name {\n\t\treturn nil, constant.ErrAuth\n\t}\n\tentranceSetting, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {\n\t\treturn nil, buserr.New(constant.ErrEntrance)\n\t}\n\tmfaSecret, err := settingRepo.Get(settingRepo.WithByKey(\"MFASecret\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmfaInterval, err := settingRepo.Get(settingRepo.WithByKey(\"MFAInterval\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsuccess := mfa.ValidCode(info.Code, mfaInterval.Value, mfaSecret.Value)\n\tif !success {\n\t\treturn nil, constant.ErrAuth\n\t}\n\n\treturn u.generateSession(c, info.Name, info.AuthMethod)\n}\n\nfunc (u *AuthService) generateSession(c *gin.Context, name, authMethod string) (*dto.UserLoginInfo, error) {\n\tsetting, err := settingRepo.Get(settingRepo.WithByKey(\"SessionTimeout\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlifeTime, err := strconv.Atoi(setting.Value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif authMethod == constant.AuthMethodJWT {\n\t\tj := jwt.NewJWT()\n\t\tclaims := j.CreateClaims(jwt.BaseClaims{\n\t\t\tName: name,\n\t\t})\n\t\ttoken, err := j.CreateToken(claims)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &dto.UserLoginInfo{Name: name, Token: token}, nil\n\t}\n\tsID, _ := c.Cookie(constant.SessionName)\n\tsessionUser, err := global.SESSION.Get(sID)\n\tif err != nil {\n\t\tsID = uuid.New().String()\n\t\tc.SetCookie(constant.SessionName, sID, 0, \"\", \"\", false, false)\n\t\terr := global.SESSION.Set(sID, sessionUser, lifeTime)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &dto.UserLoginInfo{Name: name}, nil\n\t}\n\tif err := global.SESSION.Set(sID, sessionUser, lifeTime); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &dto.UserLoginInfo{Name: name}, nil\n}\n\nfunc (u *AuthService) LogOut(c *gin.Context) error {\n\tsID, _ := c.Cookie(constant.SessionName)\n\tif sID != \"\" {\n\t\tc.SetCookie(constant.SessionName, sID, -1, \"\", \"\", false, false)\n\t\terr := global.SESSION.Delete(sID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *AuthService) VerifyCode(code string) (bool, error) {\n\tsetting, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn setting.Value == code, nil\n}\n\nfunc (u *AuthService) CheckIsSafety(code string) (string, error) {\n\tstatus, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(status.Value) == 0 {\n\t\treturn \"disable\", nil\n\t}\n\tif status.Value == code {\n\t\treturn \"pass\", nil\n\t}\n\treturn \"unpass\", nil\n}\n", "package service\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto/request\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/encrypt\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/files\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/robfig/cron/v3\"\n)\n\ntype SettingService struct{}\n\ntype ISettingService interface {\n\tGetSettingInfo() (*dto.SettingInfo, error)\n\tLoadInterfaceAddr() ([]string, error)\n\tUpdate(key, value string) error\n\tUpdatePassword(c *gin.Context, old, new string) error\n\tUpdatePort(port uint) error\n\tUpdateBindInfo(req dto.BindInfo) error\n\tUpdateSSL(c *gin.Context, req dto.SSLUpdate) error\n\tLoadFromCert() (*dto.SSLInfo, error)\n\tHandlePasswordExpired(c *gin.Context, old, new string) error\n}\n\nfunc NewISettingService() ISettingService {\n\treturn &SettingService{}\n}\n\nfunc (u *SettingService) GetSettingInfo() (*dto.SettingInfo, error) {\n\tsetting, err := settingRepo.GetList()\n\tif err != nil {\n\t\treturn nil, constant.ErrRecordNotFound\n\t}\n\tsettingMap := make(map[string]string)\n\tfor _, set := range setting {\n\t\tsettingMap[set.Key] = set.Value\n\t}\n\tvar info dto.SettingInfo\n\tarr, err := json.Marshal(settingMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := json.Unmarshal(arr, &info); err != nil {\n\t\treturn nil, err\n\t}\n\tinfo.LocalTime = time.Now().Format(\"2006-01-02 15:04:05 MST -0700\")\n\treturn &info, err\n}\n\nfunc (u *SettingService) Update(key, value string) error {\n\tswitch key {\n\tcase \"MonitorStatus\":\n\t\tif value == \"enable\" && global.MonitorCronID == 0 {\n\t\t\tinterval, err := settingRepo.Get(settingRepo.WithByKey(\"MonitorInterval\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := StartMonitor(false, interval.Value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif value == \"disable\" && global.MonitorCronID != 0 {\n\t\t\tmonitorCancel()\n\t\t\tglobal.Cron.Remove(cron.EntryID(global.MonitorCronID))\n\t\t\tglobal.MonitorCronID = 0\n\t\t}\n\tcase \"MonitorInterval\":\n\t\tstatus, err := settingRepo.Get(settingRepo.WithByKey(\"MonitorStatus\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif status.Value == \"enable\" && global.MonitorCronID != 0 {\n\t\t\tif err := StartMonitor(true, value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"AppStoreLastModified\":\n\t\texist, _ := settingRepo.Get(settingRepo.WithByKey(\"AppStoreLastModified\"))\n\t\tif exist.ID == 0 {\n\t\t\t_ = settingRepo.Create(\"AppStoreLastModified\", value)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := settingRepo.Update(key, value); err != nil {\n\t\treturn err\n\t}\n\n\tswitch key {\n\tcase \"ExpirationDays\":\n\t\ttimeout, err := strconv.Atoi(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := settingRepo.Update(\"ExpirationTime\", time.Now().AddDate(0, 0, timeout).Format(\"2006-01-02 15:04:05\")); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"BindDomain\":\n\t\tif len(value) != 0 {\n\t\t\t_ = global.SESSION.Clean()\n\t\t}\n\tcase \"UserName\", \"Password\":\n\t\t_ = global.SESSION.Clean()\n\n\t}\n\n\treturn nil\n}\n\nfunc (u *SettingService) LoadInterfaceAddr() ([]string, error) {\n\taddrMap := make(map[string]struct{})\n\taddrs, err := net.InterfaceAddrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, addr := range addrs {\n\t\tipNet, ok := addr.(*net.IPNet)\n\t\tif ok && ipNet.IP.To16() != nil {\n\t\t\taddrMap[ipNet.IP.String()] = struct{}{}\n\t\t}\n\t}\n\tvar data []string\n\tfor key := range addrMap {\n\t\tdata = append(data, key)\n\t}\n\treturn data, nil\n}\n\nfunc (u *SettingService) UpdateBindInfo(req dto.BindInfo) error {\n\tif err := settingRepo.Update(\"Ipv6\", req.Ipv6); err != nil {\n\t\treturn err\n\t}\n\tif err := settingRepo.Update(\"BindAddress\", req.BindAddress); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\tif err != nil {\n\t\t\tglobal.LOG.Errorf(\"restart system with new bind info failed, err: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (u *SettingService) UpdatePort(port uint) error {\n\tif common.ScanPort(int(port)) {\n\t\treturn buserr.WithDetail(constant.ErrPortInUsed, port, nil)\n\t}\n\tserverPort, err := settingRepo.Get(settingRepo.WithByKey(\"ServerPort\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tportValue, _ := strconv.Atoi(serverPort.Value)\n\tif err := OperateFirewallPort([]int{portValue}, []int{int(port)}); err != nil {\n\t\tglobal.LOG.Errorf(\"set system firewall ports failed, err: %v\", err)\n\t}\n\tif err := settingRepo.Update(\"ServerPort\", strconv.Itoa(int(port))); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\tif err != nil {\n\t\t\tglobal.LOG.Errorf(\"restart system port failed, err: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (u *SettingService) UpdateSSL(c *gin.Context, req dto.SSLUpdate) error {\n\tsecretDir := path.Join(global.CONF.System.BaseDir, \"1panel/secret\")\n\tif req.SSL == \"disable\" {\n\t\tif err := settingRepo.Update(\"SSL\", \"disable\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := settingRepo.Update(\"SSLType\", \"self\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = os.Remove(path.Join(secretDir, \"server.crt\"))\n\t\t_ = os.Remove(path.Join(secretDir, \"server.key\"))\n\t\tgo func() {\n\t\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\t\tif err != nil {\n\t\t\t\tglobal.LOG.Errorf(\"restart system failed, err: %v\", err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}\n\tif _, err := os.Stat(secretDir); err != nil && os.IsNotExist(err) {\n\t\tif err = os.MkdirAll(secretDir, os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := settingRepo.Update(\"SSLType\", req.SSLType); err != nil {\n\t\treturn err\n\t}\n\tvar (\n\t\tsecret string\n\t\tkey    string\n\t)\n\n\tswitch req.SSLType {\n\tcase \"self\":\n\t\tif len(req.Domain) == 0 {\n\t\t\treturn fmt.Errorf(\"load domain failed\")\n\t\t}\n\t\tdefaultCA, err := websiteCARepo.GetFirst(commonRepo.WithByName(\"1Panel\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twebsiteSSL, err := NewIWebsiteCAService().ObtainSSL(request.WebsiteCAObtain{\n\t\t\tID:        defaultCA.ID,\n\t\t\tKeyType:   \"P256\",\n\t\t\tDomains:   req.Domain,\n\t\t\tTime:      1,\n\t\t\tUnit:      \"year\",\n\t\t\tAutoRenew: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecret = websiteSSL.Pem\n\t\tkey = websiteSSL.PrivateKey\n\t\tif err := settingRepo.Update(\"SSLID\", strconv.Itoa(int(websiteSSL.ID))); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"select\":\n\t\twebsiteSSL, err := websiteSSLRepo.GetFirst(commonRepo.WithByID(req.SSLID))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecret = websiteSSL.Pem\n\t\tkey = websiteSSL.PrivateKey\n\t\tif err := settingRepo.Update(\"SSLID\", strconv.Itoa(int(req.SSLID))); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"import-paste\":\n\t\tsecret = req.Cert\n\t\tkey = req.Key\n\tcase \"import-local\":\n\t\tkeyFile, err := os.ReadFile(req.Key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkey = string(keyFile)\n\t\tcertFile, err := os.ReadFile(req.Cert)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecret = string(certFile)\n\t}\n\n\tfileOp := files.NewFileOp()\n\tif err := fileOp.WriteFile(path.Join(secretDir, \"server.crt.tmp\"), strings.NewReader(secret), 0600); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.WriteFile(path.Join(secretDir, \"server.key.tmp\"), strings.NewReader(key), 0600); err != nil {\n\t\treturn err\n\t}\n\tif err := checkCertValid(req.Domain); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.Rename(path.Join(secretDir, \"server.crt.tmp\"), path.Join(secretDir, \"server.crt\")); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.Rename(path.Join(secretDir, \"server.key.tmp\"), path.Join(secretDir, \"server.key\")); err != nil {\n\t\treturn err\n\t}\n\tif err := settingRepo.Update(\"SSL\", req.SSL); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\tif err != nil {\n\t\t\tglobal.LOG.Errorf(\"restart system failed, err: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (u *SettingService) LoadFromCert() (*dto.SSLInfo, error) {\n\tssl, err := settingRepo.Get(settingRepo.WithByKey(\"SSL\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif ssl.Value == \"disable\" {\n\t\treturn &dto.SSLInfo{}, nil\n\t}\n\tsslType, err := settingRepo.Get(settingRepo.WithByKey(\"SSLType\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := loadInfoFromCert()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch sslType.Value {\n\tcase \"import\":\n\t\tif _, err := os.Stat(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\")); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"load server.crt file failed, err: %v\", err)\n\t\t}\n\t\tcertFile, _ := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\"))\n\t\tdata.Cert = string(certFile)\n\n\t\tif _, err := os.Stat(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.key\")); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"load server.key file failed, err: %v\", err)\n\t\t}\n\t\tkeyFile, _ := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.key\"))\n\t\tdata.Key = string(keyFile)\n\tcase \"select\":\n\t\tsslID, err := settingRepo.Get(settingRepo.WithByKey(\"SSLID\"))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tid, _ := strconv.Atoi(sslID.Value)\n\t\tdata.SSLID = uint(id)\n\t}\n\treturn data, nil\n}\n\nfunc (u *SettingService) HandlePasswordExpired(c *gin.Context, old, new string) error {\n\tsetting, err := settingRepo.Get(settingRepo.WithByKey(\"Password\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tpasswordFromDB, err := encrypt.StringDecrypt(setting.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif passwordFromDB == old {\n\t\tnewPassword, err := encrypt.StringEncrypt(new)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := settingRepo.Update(\"Password\", newPassword); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\texpiredSetting, err := settingRepo.Get(settingRepo.WithByKey(\"ExpirationDays\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttimeout, _ := strconv.Atoi(expiredSetting.Value)\n\t\tif err := settingRepo.Update(\"ExpirationTime\", time.Now().AddDate(0, 0, timeout).Format(\"2006-01-02 15:04:05\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\treturn constant.ErrInitialPassword\n}\n\nfunc (u *SettingService) UpdatePassword(c *gin.Context, old, new string) error {\n\tif err := u.HandlePasswordExpired(c, old, new); err != nil {\n\t\treturn err\n\t}\n\t_ = global.SESSION.Clean()\n\treturn nil\n}\n\nfunc loadInfoFromCert() (*dto.SSLInfo, error) {\n\tvar info dto.SSLInfo\n\tcertFile := path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\")\n\tif _, err := os.Stat(certFile); err != nil {\n\t\treturn &info, err\n\t}\n\tcertData, err := os.ReadFile(certFile)\n\tif err != nil {\n\t\treturn &info, err\n\t}\n\tcertBlock, _ := pem.Decode(certData)\n\tif certBlock == nil {\n\t\treturn &info, err\n\t}\n\tcertObj, err := x509.ParseCertificate(certBlock.Bytes)\n\tif err != nil {\n\t\treturn &info, err\n\t}\n\tvar domains []string\n\tif len(certObj.IPAddresses) != 0 {\n\t\tfor _, ip := range certObj.IPAddresses {\n\t\t\tdomains = append(domains, ip.String())\n\t\t}\n\t}\n\tif len(certObj.DNSNames) != 0 {\n\t\tdomains = append(domains, certObj.DNSNames...)\n\t}\n\treturn &dto.SSLInfo{\n\t\tDomain:   strings.Join(domains, \",\"),\n\t\tTimeout:  certObj.NotAfter.Format(\"2006-01-02 15:04:05\"),\n\t\tRootPath: path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\"),\n\t}, nil\n}\n\nfunc checkCertValid(domain string) error {\n\tcertificate, err := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt.tmp\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tkey, err := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.key.tmp\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, err = tls.X509KeyPair(certificate, key); err != nil {\n\t\treturn err\n\t}\n\tcertBlock, _ := pem.Decode(certificate)\n\tif certBlock == nil {\n\t\treturn err\n\t}\n\tif _, err := x509.ParseCertificate(certBlock.Bytes); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["package service\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/encrypt\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/jwt\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/mfa\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"github.com/pkg/errors\"\n)\n\ntype AuthService struct{}\n\ntype IAuthService interface {\n\tCheckIsSafety(code string) (string, error)\n\tVerifyCode(code string) (bool, error)\n\tLogin(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error)\n\tLogOut(c *gin.Context) error\n\tMFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error)\n}\n\nfunc NewIAuthService() IAuthService {\n\treturn &AuthService{}\n}\n\nfunc (u *AuthService) Login(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error) {\n\tnameSetting, err := settingRepo.Get(settingRepo.WithByKey(\"UserName\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpasswordSetting, err := settingRepo.Get(settingRepo.WithByKey(\"Password\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpass, err := encrypt.StringDecrypt(passwordSetting.Value)\n\tif err != nil {\n\t\treturn nil, constant.ErrAuth\n\t}\n\tif info.Password != pass || nameSetting.Value != info.Name {\n\t\treturn nil, constant.ErrAuth\n\t}\n\tentranceSetting, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {\n\t\treturn nil, buserr.New(constant.ErrEntrance)\n\t}\n\tmfa, err := settingRepo.Get(settingRepo.WithByKey(\"MFAStatus\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err = settingRepo.Update(\"Language\", info.Language); err != nil {\n\t\treturn nil, err\n\t}\n\tif mfa.Value == \"enable\" {\n\t\treturn &dto.UserLoginInfo{Name: nameSetting.Value, MfaStatus: mfa.Value}, nil\n\t}\n\treturn u.generateSession(c, info.Name, info.AuthMethod)\n}\n\nfunc (u *AuthService) MFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error) {\n\tnameSetting, err := settingRepo.Get(settingRepo.WithByKey(\"UserName\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpasswordSetting, err := settingRepo.Get(settingRepo.WithByKey(\"Password\"))\n\tif err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())\n\t}\n\tpass, err := encrypt.StringDecrypt(passwordSetting.Value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif info.Password != pass || nameSetting.Value != info.Name {\n\t\treturn nil, constant.ErrAuth\n\t}\n\tentranceSetting, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {\n\t\treturn nil, buserr.New(constant.ErrEntrance)\n\t}\n\tmfaSecret, err := settingRepo.Get(settingRepo.WithByKey(\"MFASecret\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmfaInterval, err := settingRepo.Get(settingRepo.WithByKey(\"MFAInterval\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsuccess := mfa.ValidCode(info.Code, mfaInterval.Value, mfaSecret.Value)\n\tif !success {\n\t\treturn nil, constant.ErrAuth\n\t}\n\n\treturn u.generateSession(c, info.Name, info.AuthMethod)\n}\n\nfunc (u *AuthService) generateSession(c *gin.Context, name, authMethod string) (*dto.UserLoginInfo, error) {\n\tsetting, err := settingRepo.Get(settingRepo.WithByKey(\"SessionTimeout\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thttpsSetting, err := settingRepo.Get(settingRepo.WithByKey(\"SSL\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlifeTime, err := strconv.Atoi(setting.Value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif authMethod == constant.AuthMethodJWT {\n\t\tj := jwt.NewJWT()\n\t\tclaims := j.CreateClaims(jwt.BaseClaims{\n\t\t\tName: name,\n\t\t})\n\t\ttoken, err := j.CreateToken(claims)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &dto.UserLoginInfo{Name: name, Token: token}, nil\n\t}\n\tsID, _ := c.Cookie(constant.SessionName)\n\tsessionUser, err := global.SESSION.Get(sID)\n\tif err != nil {\n\t\tsID = uuid.New().String()\n\t\tc.SetCookie(constant.SessionName, sID, 0, \"\", \"\", httpsSetting.Value == \"enable\", false)\n\t\terr := global.SESSION.Set(sID, sessionUser, lifeTime)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &dto.UserLoginInfo{Name: name}, nil\n\t}\n\tif err := global.SESSION.Set(sID, sessionUser, lifeTime); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &dto.UserLoginInfo{Name: name}, nil\n}\n\nfunc (u *AuthService) LogOut(c *gin.Context) error {\n\thttpsSetting, err := settingRepo.Get(settingRepo.WithByKey(\"SSL\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tsID, _ := c.Cookie(constant.SessionName)\n\tif sID != \"\" {\n\t\tc.SetCookie(constant.SessionName, sID, -1, \"\", \"\", httpsSetting.Value == \"enable\", false)\n\t\terr := global.SESSION.Delete(sID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *AuthService) VerifyCode(code string) (bool, error) {\n\tsetting, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn setting.Value == code, nil\n}\n\nfunc (u *AuthService) CheckIsSafety(code string) (string, error) {\n\tstatus, err := settingRepo.Get(settingRepo.WithByKey(\"SecurityEntrance\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(status.Value) == 0 {\n\t\treturn \"disable\", nil\n\t}\n\tif status.Value == code {\n\t\treturn \"pass\", nil\n\t}\n\treturn \"unpass\", nil\n}\n", "package service\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto/request\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/encrypt\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/files\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/robfig/cron/v3\"\n)\n\ntype SettingService struct{}\n\ntype ISettingService interface {\n\tGetSettingInfo() (*dto.SettingInfo, error)\n\tLoadInterfaceAddr() ([]string, error)\n\tUpdate(key, value string) error\n\tUpdatePassword(c *gin.Context, old, new string) error\n\tUpdatePort(port uint) error\n\tUpdateBindInfo(req dto.BindInfo) error\n\tUpdateSSL(c *gin.Context, req dto.SSLUpdate) error\n\tLoadFromCert() (*dto.SSLInfo, error)\n\tHandlePasswordExpired(c *gin.Context, old, new string) error\n}\n\nfunc NewISettingService() ISettingService {\n\treturn &SettingService{}\n}\n\nfunc (u *SettingService) GetSettingInfo() (*dto.SettingInfo, error) {\n\tsetting, err := settingRepo.GetList()\n\tif err != nil {\n\t\treturn nil, constant.ErrRecordNotFound\n\t}\n\tsettingMap := make(map[string]string)\n\tfor _, set := range setting {\n\t\tsettingMap[set.Key] = set.Value\n\t}\n\tvar info dto.SettingInfo\n\tarr, err := json.Marshal(settingMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := json.Unmarshal(arr, &info); err != nil {\n\t\treturn nil, err\n\t}\n\tinfo.LocalTime = time.Now().Format(\"2006-01-02 15:04:05 MST -0700\")\n\treturn &info, err\n}\n\nfunc (u *SettingService) Update(key, value string) error {\n\tswitch key {\n\tcase \"MonitorStatus\":\n\t\tif value == \"enable\" && global.MonitorCronID == 0 {\n\t\t\tinterval, err := settingRepo.Get(settingRepo.WithByKey(\"MonitorInterval\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := StartMonitor(false, interval.Value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif value == \"disable\" && global.MonitorCronID != 0 {\n\t\t\tmonitorCancel()\n\t\t\tglobal.Cron.Remove(cron.EntryID(global.MonitorCronID))\n\t\t\tglobal.MonitorCronID = 0\n\t\t}\n\tcase \"MonitorInterval\":\n\t\tstatus, err := settingRepo.Get(settingRepo.WithByKey(\"MonitorStatus\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif status.Value == \"enable\" && global.MonitorCronID != 0 {\n\t\t\tif err := StartMonitor(true, value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"AppStoreLastModified\":\n\t\texist, _ := settingRepo.Get(settingRepo.WithByKey(\"AppStoreLastModified\"))\n\t\tif exist.ID == 0 {\n\t\t\t_ = settingRepo.Create(\"AppStoreLastModified\", value)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := settingRepo.Update(key, value); err != nil {\n\t\treturn err\n\t}\n\n\tswitch key {\n\tcase \"ExpirationDays\":\n\t\ttimeout, err := strconv.Atoi(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := settingRepo.Update(\"ExpirationTime\", time.Now().AddDate(0, 0, timeout).Format(\"2006-01-02 15:04:05\")); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"BindDomain\":\n\t\tif len(value) != 0 {\n\t\t\t_ = global.SESSION.Clean()\n\t\t}\n\tcase \"UserName\", \"Password\":\n\t\t_ = global.SESSION.Clean()\n\n\t}\n\n\treturn nil\n}\n\nfunc (u *SettingService) LoadInterfaceAddr() ([]string, error) {\n\taddrMap := make(map[string]struct{})\n\taddrs, err := net.InterfaceAddrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, addr := range addrs {\n\t\tipNet, ok := addr.(*net.IPNet)\n\t\tif ok && ipNet.IP.To16() != nil {\n\t\t\taddrMap[ipNet.IP.String()] = struct{}{}\n\t\t}\n\t}\n\tvar data []string\n\tfor key := range addrMap {\n\t\tdata = append(data, key)\n\t}\n\treturn data, nil\n}\n\nfunc (u *SettingService) UpdateBindInfo(req dto.BindInfo) error {\n\tif err := settingRepo.Update(\"Ipv6\", req.Ipv6); err != nil {\n\t\treturn err\n\t}\n\tif err := settingRepo.Update(\"BindAddress\", req.BindAddress); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\tif err != nil {\n\t\t\tglobal.LOG.Errorf(\"restart system with new bind info failed, err: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (u *SettingService) UpdatePort(port uint) error {\n\tif common.ScanPort(int(port)) {\n\t\treturn buserr.WithDetail(constant.ErrPortInUsed, port, nil)\n\t}\n\tserverPort, err := settingRepo.Get(settingRepo.WithByKey(\"ServerPort\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tportValue, _ := strconv.Atoi(serverPort.Value)\n\tif err := OperateFirewallPort([]int{portValue}, []int{int(port)}); err != nil {\n\t\tglobal.LOG.Errorf(\"set system firewall ports failed, err: %v\", err)\n\t}\n\tif err := settingRepo.Update(\"ServerPort\", strconv.Itoa(int(port))); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\tif err != nil {\n\t\t\tglobal.LOG.Errorf(\"restart system port failed, err: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (u *SettingService) UpdateSSL(c *gin.Context, req dto.SSLUpdate) error {\n\tsecretDir := path.Join(global.CONF.System.BaseDir, \"1panel/secret\")\n\tif req.SSL == \"disable\" {\n\t\tif err := settingRepo.Update(\"SSL\", \"disable\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := settingRepo.Update(\"SSLType\", \"self\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = os.Remove(path.Join(secretDir, \"server.crt\"))\n\t\t_ = os.Remove(path.Join(secretDir, \"server.key\"))\n\t\tsID, _ := c.Cookie(constant.SessionName)\n\t\tc.SetCookie(constant.SessionName, sID, 0, \"\", \"\", false, false)\n\n\t\tgo func() {\n\t\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\t\tif err != nil {\n\t\t\t\tglobal.LOG.Errorf(\"restart system failed, err: %v\", err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}\n\tif _, err := os.Stat(secretDir); err != nil && os.IsNotExist(err) {\n\t\tif err = os.MkdirAll(secretDir, os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := settingRepo.Update(\"SSLType\", req.SSLType); err != nil {\n\t\treturn err\n\t}\n\tvar (\n\t\tsecret string\n\t\tkey    string\n\t)\n\n\tswitch req.SSLType {\n\tcase \"self\":\n\t\tif len(req.Domain) == 0 {\n\t\t\treturn fmt.Errorf(\"load domain failed\")\n\t\t}\n\t\tdefaultCA, err := websiteCARepo.GetFirst(commonRepo.WithByName(\"1Panel\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twebsiteSSL, err := NewIWebsiteCAService().ObtainSSL(request.WebsiteCAObtain{\n\t\t\tID:        defaultCA.ID,\n\t\t\tKeyType:   \"P256\",\n\t\t\tDomains:   req.Domain,\n\t\t\tTime:      1,\n\t\t\tUnit:      \"year\",\n\t\t\tAutoRenew: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecret = websiteSSL.Pem\n\t\tkey = websiteSSL.PrivateKey\n\t\tif err := settingRepo.Update(\"SSLID\", strconv.Itoa(int(websiteSSL.ID))); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"select\":\n\t\twebsiteSSL, err := websiteSSLRepo.GetFirst(commonRepo.WithByID(req.SSLID))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecret = websiteSSL.Pem\n\t\tkey = websiteSSL.PrivateKey\n\t\tif err := settingRepo.Update(\"SSLID\", strconv.Itoa(int(req.SSLID))); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"import-paste\":\n\t\tsecret = req.Cert\n\t\tkey = req.Key\n\tcase \"import-local\":\n\t\tkeyFile, err := os.ReadFile(req.Key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkey = string(keyFile)\n\t\tcertFile, err := os.ReadFile(req.Cert)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecret = string(certFile)\n\t}\n\n\tfileOp := files.NewFileOp()\n\tif err := fileOp.WriteFile(path.Join(secretDir, \"server.crt.tmp\"), strings.NewReader(secret), 0600); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.WriteFile(path.Join(secretDir, \"server.key.tmp\"), strings.NewReader(key), 0600); err != nil {\n\t\treturn err\n\t}\n\tif err := checkCertValid(req.Domain); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.Rename(path.Join(secretDir, \"server.crt.tmp\"), path.Join(secretDir, \"server.crt\")); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.Rename(path.Join(secretDir, \"server.key.tmp\"), path.Join(secretDir, \"server.key\")); err != nil {\n\t\treturn err\n\t}\n\tif err := settingRepo.Update(\"SSL\", req.SSL); err != nil {\n\t\treturn err\n\t}\n\n\tsID, _ := c.Cookie(constant.SessionName)\n\tc.SetCookie(constant.SessionName, sID, 0, \"\", \"\", true, false)\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\t_, err := cmd.Exec(\"systemctl restart 1panel.service\")\n\t\tif err != nil {\n\t\t\tglobal.LOG.Errorf(\"restart system failed, err: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (u *SettingService) LoadFromCert() (*dto.SSLInfo, error) {\n\tssl, err := settingRepo.Get(settingRepo.WithByKey(\"SSL\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif ssl.Value == \"disable\" {\n\t\treturn &dto.SSLInfo{}, nil\n\t}\n\tsslType, err := settingRepo.Get(settingRepo.WithByKey(\"SSLType\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := loadInfoFromCert()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch sslType.Value {\n\tcase \"import\":\n\t\tif _, err := os.Stat(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\")); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"load server.crt file failed, err: %v\", err)\n\t\t}\n\t\tcertFile, _ := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\"))\n\t\tdata.Cert = string(certFile)\n\n\t\tif _, err := os.Stat(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.key\")); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"load server.key file failed, err: %v\", err)\n\t\t}\n\t\tkeyFile, _ := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.key\"))\n\t\tdata.Key = string(keyFile)\n\tcase \"select\":\n\t\tsslID, err := settingRepo.Get(settingRepo.WithByKey(\"SSLID\"))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tid, _ := strconv.Atoi(sslID.Value)\n\t\tdata.SSLID = uint(id)\n\t}\n\treturn data, nil\n}\n\nfunc (u *SettingService) HandlePasswordExpired(c *gin.Context, old, new string) error {\n\tsetting, err := settingRepo.Get(settingRepo.WithByKey(\"Password\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tpasswordFromDB, err := encrypt.StringDecrypt(setting.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif passwordFromDB == old {\n\t\tnewPassword, err := encrypt.StringEncrypt(new)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := settingRepo.Update(\"Password\", newPassword); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\texpiredSetting, err := settingRepo.Get(settingRepo.WithByKey(\"ExpirationDays\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttimeout, _ := strconv.Atoi(expiredSetting.Value)\n\t\tif err := settingRepo.Update(\"ExpirationTime\", time.Now().AddDate(0, 0, timeout).Format(\"2006-01-02 15:04:05\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\treturn constant.ErrInitialPassword\n}\n\nfunc (u *SettingService) UpdatePassword(c *gin.Context, old, new string) error {\n\tif err := u.HandlePasswordExpired(c, old, new); err != nil {\n\t\treturn err\n\t}\n\t_ = global.SESSION.Clean()\n\treturn nil\n}\n\nfunc loadInfoFromCert() (*dto.SSLInfo, error) {\n\tvar info dto.SSLInfo\n\tcertFile := path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\")\n\tif _, err := os.Stat(certFile); err != nil {\n\t\treturn &info, err\n\t}\n\tcertData, err := os.ReadFile(certFile)\n\tif err != nil {\n\t\treturn &info, err\n\t}\n\tcertBlock, _ := pem.Decode(certData)\n\tif certBlock == nil {\n\t\treturn &info, err\n\t}\n\tcertObj, err := x509.ParseCertificate(certBlock.Bytes)\n\tif err != nil {\n\t\treturn &info, err\n\t}\n\tvar domains []string\n\tif len(certObj.IPAddresses) != 0 {\n\t\tfor _, ip := range certObj.IPAddresses {\n\t\t\tdomains = append(domains, ip.String())\n\t\t}\n\t}\n\tif len(certObj.DNSNames) != 0 {\n\t\tdomains = append(domains, certObj.DNSNames...)\n\t}\n\treturn &dto.SSLInfo{\n\t\tDomain:   strings.Join(domains, \",\"),\n\t\tTimeout:  certObj.NotAfter.Format(\"2006-01-02 15:04:05\"),\n\t\tRootPath: path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt\"),\n\t}, nil\n}\n\nfunc checkCertValid(domain string) error {\n\tcertificate, err := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.crt.tmp\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tkey, err := os.ReadFile(path.Join(global.CONF.System.BaseDir, \"1panel/secret/server.key.tmp\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, err = tls.X509KeyPair(certificate, key); err != nil {\n\t\treturn err\n\t}\n\tcertBlock, _ := pem.Decode(certificate)\n\tif certBlock == nil {\n\t\treturn err\n\t}\n\tif _, err := x509.ParseCertificate(certBlock.Bytes); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"], "filenames": ["backend/app/service/auth.go", "backend/app/service/setting.go"], "buggy_code_start_loc": [111, 200], "buggy_code_end_loc": [150, 291], "fixing_code_start_loc": [112, 201], "fixing_code_end_loc": [158, 298], "type": "CWE-311", "message": "1Panel is an open source Linux server operation and maintenance management panel. The HTTPS cookie that comes with the panel does not have the Secure keyword, which may cause the cookie to be sent in plain text if accessed using HTTP. This issue has been patched in version 1.9.6.\n\n", "other": {"cve": {"id": "CVE-2024-24768", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-05T15:15:09.607", "lastModified": "2024-02-13T00:36:30.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "1Panel is an open source Linux server operation and maintenance management panel. The HTTPS cookie that comes with the panel does not have the Secure keyword, which may cause the cookie to be sent in plain text if accessed using HTTP. This issue has been patched in version 1.9.6.\n\n"}, {"lang": "es", "value": "1Panel es un panel de gesti\u00f3n de operaci\u00f3n y mantenimiento de servidores Linux de c\u00f3digo abierto. La cookie HTTPS que viene con el panel no tiene la palabra clave Secure, lo que puede hacer que la cookie se env\u00ede en texto plano si se accede mediante HTTP. Este problema se solucion\u00f3 en la versi\u00f3n 1.9.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 3.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-311"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-315"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:1panel:1.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "B112F28A-9D5B-45B8-8201-1FA859875E7F"}]}]}], "references": [{"url": "https://github.com/1Panel-dev/1Panel/commit/1169648162c4b9b48e0b4aa508f9dea4d6bc50d5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/1Panel-dev/1Panel/pull/3817", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/1Panel-dev/1Panel/security/advisories/GHSA-9xfw-jjq2-7v8h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/1Panel-dev/1Panel/commit/1169648162c4b9b48e0b4aa508f9dea4d6bc50d5"}}