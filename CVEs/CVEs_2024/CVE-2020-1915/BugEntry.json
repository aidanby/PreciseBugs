{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/VM/JSObject.h\"\n\n#include \"hermes/VM/BuildMetadata.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/HostModel.h\"\n#include \"hermes/VM/InternalProperty.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSDate.h\"\n#include \"hermes/VM/JSProxy.h\"\n#include \"hermes/VM/Operations.h\"\n\n#include \"llvh/ADT/SmallSet.h\"\n\nnamespace hermes {\nnamespace vm {\n\nObjectVTable JSObject::vt{\n    VTable(\n        CellKind::ObjectKind,\n        cellSize<JSObject>(),\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr, // externalMemorySize\n        VTable::HeapSnapshotMetadata{HeapSnapshot::NodeType::Object,\n                                     JSObject::_snapshotNameImpl,\n                                     JSObject::_snapshotAddEdgesImpl,\n                                     nullptr,\n                                     JSObject::_snapshotAddLocationsImpl}),\n    JSObject::_getOwnIndexedRangeImpl,\n    JSObject::_haveOwnIndexedImpl,\n    JSObject::_getOwnIndexedPropertyFlagsImpl,\n    JSObject::_getOwnIndexedImpl,\n    JSObject::_setOwnIndexedImpl,\n    JSObject::_deleteOwnIndexedImpl,\n    JSObject::_checkAllOwnIndexedImpl,\n};\n\nvoid ObjectBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  // This call is just for debugging and consistency purposes.\n  mb.addJSObjectOverlapSlots(JSObject::numOverlapSlots<JSObject>());\n\n  const auto *self = static_cast<const JSObject *>(cell);\n  mb.addField(\"parent\", &self->parent_);\n  mb.addField(\"class\", &self->clazz_);\n  mb.addField(\"propStorage\", &self->propStorage_);\n\n  // Declare the direct properties.\n  static const char *directPropName[JSObject::DIRECT_PROPERTY_SLOTS] = {\n      \"directProp0\", \"directProp1\", \"directProp2\", \"directProp3\"};\n  for (unsigned i = mb.getJSObjectOverlapSlots();\n       i < JSObject::DIRECT_PROPERTY_SLOTS;\n       ++i) {\n    mb.addField(directPropName[i], self->directProps() + i);\n  }\n}\n\n#ifdef HERMESVM_SERIALIZE\nvoid JSObject::serializeObjectImpl(\n    Serializer &s,\n    const GCCell *cell,\n    unsigned overlapSlots) {\n  auto *self = vmcast<const JSObject>(cell);\n  s.writeData(&self->flags_, sizeof(ObjectFlags));\n  s.writeRelocation(self->parent_.get(s.getRuntime()));\n  s.writeRelocation(self->clazz_.get(s.getRuntime()));\n  // propStorage_ : GCPointer<PropStorage> is also ArrayStorage. Serialize\n  // *propStorage_ with this JSObject.\n  bool hasArray = (bool)self->propStorage_;\n  s.writeInt<uint8_t>(hasArray);\n  if (hasArray) {\n    ArrayStorage::serializeArrayStorage(\n        s, self->propStorage_.get(s.getRuntime()));\n  }\n\n  // Record the number of overlap slots, so that the deserialization code\n  // doesn't need to keep track of it.\n  s.writeInt<uint8_t>(overlapSlots);\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    s.writeHermesValue(self->directProps()[i]);\n  }\n}\n\nvoid ObjectSerialize(Serializer &s, const GCCell *cell) {\n  JSObject::serializeObjectImpl(s, cell, JSObject::numOverlapSlots<JSObject>());\n  s.endObject(cell);\n}\n\nvoid ObjectDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::ObjectKind && \"Expected JSObject\");\n  void *mem = d.getRuntime()->alloc</*fixedSize*/ true>(cellSize<JSObject>());\n  auto *obj = new (mem) JSObject(d, &JSObject::vt.base);\n\n  d.endObject(obj);\n}\n\nJSObject::JSObject(Deserializer &d, const VTable *vtp)\n    : GCCell(&d.getRuntime()->getHeap(), vtp) {\n  d.readData(&flags_, sizeof(ObjectFlags));\n  d.readRelocation(&parent_, RelocationKind::GCPointer);\n  d.readRelocation(&clazz_, RelocationKind::GCPointer);\n  if (d.readInt<uint8_t>()) {\n    propStorage_.set(\n        d.getRuntime(),\n        ArrayStorage::deserializeArrayStorage(d),\n        &d.getRuntime()->getHeap());\n  }\n\n  auto overlapSlots = d.readInt<uint8_t>();\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    d.readHermesValue(&directProps()[i]);\n  }\n}\n#endif\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<JSObject> parentHandle) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      *parentHandle,\n      runtime->getHiddenClassForPrototypeRaw(\n          *parentHandle,\n          numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(Runtime *runtime) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    unsigned propertyCount) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  auto self = mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n\n  return runtime->ignoreAllocationFailure(\n      JSObject::allocatePropStorage(std::move(self), runtime, propertyCount));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<HiddenClass> clazz) {\n  auto obj = JSObject::create(runtime, clazz->getNumProperties());\n  obj->clazz_.set(runtime, *clazz, &runtime->getHeap());\n  // If the hidden class has index like property, we need to clear the fast path\n  // flag.\n  if (LLVM_UNLIKELY(obj->clazz_.get(runtime)->getHasIndexLikeProperties()))\n    obj->flags_.fastIndexProperties = false;\n  return obj;\n}\n\nvoid JSObject::initializeLazyObject(\n    Runtime *runtime,\n    Handle<JSObject> lazyObject) {\n  assert(lazyObject->flags_.lazyObject && \"object must be lazy\");\n  // object is now assumed to be a regular object.\n  lazyObject->flags_.lazyObject = 0;\n\n  // only functions can be lazy.\n  assert(vmisa<Callable>(lazyObject.get()) && \"unexpected lazy object\");\n  Callable::defineLazyProperties(Handle<Callable>::vmcast(lazyObject), runtime);\n}\n\nObjectID JSObject::getObjectID(JSObject *self, Runtime *runtime) {\n  if (LLVM_LIKELY(self->flags_.objectID))\n    return self->flags_.objectID;\n\n  // Object ID does not yet exist, get next unique global ID..\n  self->flags_.objectID = runtime->generateNextObjectID();\n  // Make sure it is not zero.\n  if (LLVM_UNLIKELY(!self->flags_.objectID))\n    --self->flags_.objectID;\n  return self->flags_.objectID;\n}\n\nCallResult<PseudoHandle<JSObject>> JSObject::getPrototypeOf(\n    PseudoHandle<JSObject> selfHandle,\n    Runtime *runtime) {\n  if (LLVM_LIKELY(!selfHandle->isProxyObject())) {\n    return createPseudoHandle(selfHandle->getParent(runtime));\n  }\n\n  return JSProxy::getPrototypeOf(\n      runtime->makeHandle(std::move(selfHandle)), runtime);\n}\n\nnamespace {\n\nCallResult<bool> proxyOpFlags(\n    Runtime *runtime,\n    PropOpFlags opFlags,\n    const char *msg,\n    CallResult<bool> res) {\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*res && opFlags.getThrowOnError()) {\n    return runtime->raiseTypeError(msg);\n  }\n  return res;\n}\n\n} // namespace\n\nCallResult<bool> JSObject::setParent(\n    JSObject *self,\n    Runtime *runtime,\n    JSObject *parent,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Object is not extensible.\",\n        JSProxy::setPrototypeOf(\n            runtime->makeHandle(self), runtime, runtime->makeHandle(parent)));\n  }\n  // ES9 9.1.2\n  // 4.\n  if (self->parent_.get(runtime) == parent)\n    return true;\n  // 5.\n  if (!self->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\"Object is not extensible.\");\n    } else {\n      return false;\n    }\n  }\n  // 6-8. Check for a prototype cycle.\n  for (JSObject *cur = parent; cur; cur = cur->parent_.get(runtime)) {\n    if (cur == self) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\"Prototype cycle detected\");\n      } else {\n        return false;\n      }\n    } else if (LLVM_UNLIKELY(cur->isProxyObject())) {\n      // TODO this branch should also be used for module namespace and\n      // immutable prototype exotic objects.\n      break;\n    }\n  }\n  // 9.\n  self->parent_.set(runtime, parent, &runtime->getHeap());\n  // 10.\n  return true;\n}\n\nvoid JSObject::allocateNewSlotStorage(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SlotIndex newSlotIndex,\n    Handle<> valueHandle) {\n  // If it is a direct property, just store the value and we are done.\n  if (LLVM_LIKELY(newSlotIndex < DIRECT_PROPERTY_SLOTS)) {\n    selfHandle->directProps()[newSlotIndex].set(\n        *valueHandle, &runtime->getHeap());\n    return;\n  }\n\n  // Make the slot index relative to the indirect storage.\n  newSlotIndex -= DIRECT_PROPERTY_SLOTS;\n\n  // Allocate a new property storage if not already allocated.\n  if (LLVM_UNLIKELY(!selfHandle->propStorage_)) {\n    // Allocate new storage.\n    assert(newSlotIndex == 0 && \"allocated slot must be at end\");\n    auto arrRes = runtime->ignoreAllocationFailure(\n        PropStorage::create(runtime, DEFAULT_PROPERTY_CAPACITY));\n    selfHandle->propStorage_.set(\n        runtime, vmcast<PropStorage>(arrRes), &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(\n                 newSlotIndex >=\n                 selfHandle->propStorage_.get(runtime)->capacity())) {\n    // Reallocate the existing one.\n    assert(\n        newSlotIndex == selfHandle->propStorage_.get(runtime)->size() &&\n        \"allocated slot must be at end\");\n    auto hnd = runtime->makeMutableHandle(selfHandle->propStorage_);\n    PropStorage::resize(hnd, runtime, newSlotIndex + 1);\n    selfHandle->propStorage_.set(runtime, *hnd, &runtime->getHeap());\n  }\n\n  {\n    NoAllocScope scope{runtime};\n    auto *const propStorage = selfHandle->propStorage_.getNonNull(runtime);\n    if (newSlotIndex >= propStorage->size()) {\n      assert(\n          newSlotIndex == propStorage->size() &&\n          \"allocated slot must be at end\");\n      PropStorage::resizeWithinCapacity(propStorage, runtime, newSlotIndex + 1);\n    }\n    // If we don't need to resize, just store it directly.\n    propStorage->at(newSlotIndex).set(*valueHandle, &runtime->getHeap());\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    NamedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getNamedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(getNamedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor =\n      vmcast<PropertyAccessor>(getNamedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getComputedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor = vmcast<PropertyAccessor>(\n      getComputedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc,\n    Handle<> nameValHandle) {\n  if (!propObj) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n\n  if (LLVM_LIKELY(!desc.flags.proxyObject)) {\n    return JSObject::getComputedPropertyValue_RJS(\n        selfHandle, runtime, propObj, desc);\n  }\n\n  CallResult<Handle<>> keyRes = toPropertyKey(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(keyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  CallResult<bool> hasRes = JSProxy::hasComputed(propObj, runtime, *keyRes);\n  if (LLVM_UNLIKELY(hasRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*hasRes) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n  return JSProxy::getComputed(propObj, runtime, *keyRes, selfHandle);\n}\n\nCallResult<Handle<JSArray>> JSObject::getOwnPropertyKeys(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    OwnKeysFlags okFlags) {\n  assert(\n      (okFlags.getIncludeNonSymbols() || okFlags.getIncludeSymbols()) &&\n      \"Can't exclude symbols and strings\");\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      CallResult<PseudoHandle<JSArray>> proxyRes =\n          JSProxy::ownPropertyKeys(selfHandle, runtime, okFlags);\n      if (LLVM_UNLIKELY(proxyRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return runtime->makeHandle(std::move(*proxyRes));\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    initializeLazyObject(runtime, selfHandle);\n  }\n\n  auto range = getOwnIndexedRange(selfHandle.get(), runtime);\n\n  // Estimate the capacity of the output array.  This estimate is only\n  // reasonable for the non-symbol case.\n  uint32_t capacity = okFlags.getIncludeNonSymbols()\n      ? (selfHandle->clazz_.get(runtime)->getNumProperties() + range.second -\n         range.first)\n      : 0;\n\n  auto arrayRes = JSArray::create(runtime, capacity, 0);\n  if (LLVM_UNLIKELY(arrayRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto array = runtime->makeHandle(std::move(*arrayRes));\n\n  // Optional array of SymbolIDs reported via host object API\n  llvh::Optional<Handle<JSArray>> hostObjectSymbols;\n  size_t hostObjectSymbolCount = 0;\n\n  // If current object is a host object we need to deduplicate its properties\n  llvh::SmallSet<SymbolID::RawType, 16> dedupSet;\n\n  // Output index.\n  uint32_t index = 0;\n\n  // Avoid allocating a new handle per element.\n  MutableHandle<> tmpHandle{runtime};\n\n  // Number of indexed properties.\n  uint32_t numIndexed = 0;\n\n  // Regular properties with names that are array indexes are stashed here, if\n  // encountered.\n  llvh::SmallVector<uint32_t, 8> indexNames{};\n\n  // Iterate the named properties excluding those which use Symbols.\n  if (okFlags.getIncludeNonSymbols()) {\n    // Get host object property names\n    if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n      assert(\n          range.first == range.second &&\n          \"Host objects cannot own indexed range\");\n      auto hostSymbolsRes =\n          vmcast<HostObject>(selfHandle.get())->getHostPropertyNames();\n      if (hostSymbolsRes == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if ((hostObjectSymbolCount = (**hostSymbolsRes)->getEndIndex()) != 0) {\n        Handle<JSArray> hostSymbols = *hostSymbolsRes;\n        hostObjectSymbols = std::move(hostSymbols);\n        capacity += hostObjectSymbolCount;\n      }\n    }\n\n    // Iterate the indexed properties.\n    GCScopeMarkerRAII marker{runtime};\n    for (auto i = range.first; i != range.second; ++i) {\n      auto res = getOwnIndexedPropertyFlags(selfHandle.get(), runtime, i);\n      if (!res)\n        continue;\n\n      // If specified, check whether it is enumerable.\n      if (!okFlags.getIncludeNonEnumerable() && !res->enumerable)\n        continue;\n\n      tmpHandle = HermesValue::encodeDoubleValue(i);\n      JSArray::setElementAt(array, runtime, index++, tmpHandle);\n      marker.flush();\n    }\n\n    numIndexed = index;\n\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime,\n         okFlags,\n         array,\n         hostObjectSymbolCount,\n         &index,\n         &indexNames,\n         &tmpHandle,\n         &dedupSet](SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isPropertyNamePrimitive(id)) {\n            return;\n          }\n\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n\n          // Host properties might overlap with the ones recognized by the\n          // hidden class. If we're dealing with a host object then keep track\n          // of hidden class properties for the deduplication purposes.\n          if (LLVM_UNLIKELY(hostObjectSymbolCount > 0)) {\n            dedupSet.insert(id.unsafeGetRaw());\n          }\n\n          // Check if this property is an integer index. If it is, we stash it\n          // away to deal with it later. This check should be fast since most\n          // property names don't start with a digit.\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            return;\n          }\n\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        });\n\n    // Iterate over HostObject properties and append them to the array. Do not\n    // append duplicates.\n    if (LLVM_UNLIKELY(hostObjectSymbols)) {\n      for (size_t i = 0; i < hostObjectSymbolCount; ++i) {\n        assert(\n            (*hostObjectSymbols)->at(runtime, i).isSymbol() &&\n            \"Host object needs to return array of SymbolIDs\");\n        marker.flush();\n        SymbolID id = (*hostObjectSymbols)->at(runtime, i).getSymbol();\n        if (dedupSet.count(id.unsafeGetRaw()) == 0) {\n          dedupSet.insert(id.unsafeGetRaw());\n\n          assert(\n              !InternalProperty::isInternal(id) &&\n              \"host object returned reserved symbol\");\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            continue;\n          }\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        }\n      }\n    }\n  }\n\n  // Now iterate the named properties again, including only Symbols.\n  // We could iterate only once, if we chose to ignore (and disallow)\n  // own properties on HostObjects, as we do with Proxies.\n  if (okFlags.getIncludeSymbols()) {\n    MutableHandle<SymbolID> idHandle{runtime};\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime, okFlags, array, &index, &idHandle](\n            SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isSymbolPrimitive(id)) {\n            return;\n          }\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n          idHandle = id;\n          JSArray::setElementAt(array, runtime, index++, idHandle);\n        });\n  }\n\n  // The end (exclusive) of the named properties.\n  uint32_t endNamed = index;\n\n  // Properly set the length of the array.\n  auto cr = JSArray::setLength(\n      array, runtime, endNamed + indexNames.size(), PropOpFlags{});\n  (void)cr;\n  assert(\n      cr != ExecutionStatus::EXCEPTION && *cr && \"JSArray::setLength() failed\");\n\n  // If we have no index-like names, we are done.\n  if (LLVM_LIKELY(indexNames.empty()))\n    return array;\n\n  // In the unlikely event that we encountered index-like names, we need to sort\n  // them and merge them with the real indexed properties. Note that it is\n  // guaranteed that there are no clashes.\n  std::sort(indexNames.begin(), indexNames.end());\n\n  // Also make space for the new elements by shifting all the named properties\n  // to the right. First, resize the array.\n  JSArray::setStorageEndIndex(array, runtime, endNamed + indexNames.size());\n\n  // Shift the non-index property names. The region [numIndexed..endNamed) is\n  // moved to [numIndexed+indexNames.size()..array->size()).\n  // TODO: optimize this by implementing memcpy-like functionality in ArrayImpl.\n  for (uint32_t last = endNamed, toLast = array->getEndIndex();\n       last != numIndexed;) {\n    --last;\n    --toLast;\n    tmpHandle = array->at(runtime, last);\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  // Now we need to merge the indexes in indexNames and the array\n  // [0..numIndexed). We start from the end and copy the larger element from\n  // either array.\n  // 1+ the destination position to copy into.\n  for (uint32_t toLast = numIndexed + indexNames.size(),\n                indexNamesLast = indexNames.size();\n       toLast != 0;) {\n    if (numIndexed) {\n      uint32_t a = (uint32_t)array->at(runtime, numIndexed - 1).getNumber();\n      uint32_t b;\n\n      if (indexNamesLast && (b = indexNames[indexNamesLast - 1]) > a) {\n        tmpHandle = HermesValue::encodeDoubleValue(b);\n        --indexNamesLast;\n      } else {\n        tmpHandle = HermesValue::encodeDoubleValue(a);\n        --numIndexed;\n      }\n    } else {\n      assert(indexNamesLast && \"prematurely ran out of source values\");\n      tmpHandle =\n          HermesValue::encodeDoubleValue(indexNames[indexNamesLast - 1]);\n      --indexNamesLast;\n    }\n\n    --toLast;\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  return array;\n}\n\n/// Convert a value to string unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n#define LAZY_TO_STRING(runtime, nameValHandle, str)       \\\n  do {                                                    \\\n    if (!str) {                                           \\\n      auto status = toString_RJS(runtime, nameValHandle); \\\n      assert(                                             \\\n          status != ExecutionStatus::EXCEPTION &&         \\\n          \"toString() of primitive cannot fail\");         \\\n      str = status->get();                                \\\n    }                                                     \\\n  } while (0)\n\n/// Convert a value to an identifier unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param id [SymbolID] the identifier is stored there. Must be initialized\n///   to INVALID_IDENTIFIER_ID initially.\n#define LAZY_TO_IDENTIFIER(runtime, nameValHandle, id)          \\\n  do {                                                          \\\n    if (id.isInvalid()) {                                       \\\n      CallResult<Handle<SymbolID>> idRes =                      \\\n          valueToSymbolID(runtime, nameValHandle);              \\\n      if (LLVM_UNLIKELY(idRes == ExecutionStatus::EXCEPTION)) { \\\n        return ExecutionStatus::EXCEPTION;                      \\\n      }                                                         \\\n      id = **idRes;                                             \\\n    }                                                           \\\n  } while (0)\n\n/// Convert a value to array index, if possible.\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n/// \\param arrayIndex [OptValue<uint32_t>] the array index is stored\n///   there.\n#define TO_ARRAY_INDEX(runtime, nameValHandle, str, arrayIndex) \\\n  do {                                                          \\\n    arrayIndex = toArrayIndexFastPath(*nameValHandle);          \\\n    if (!arrayIndex && !nameValHandle->isSymbol()) {            \\\n      LAZY_TO_STRING(runtime, nameValHandle, str);              \\\n      arrayIndex = toArrayIndex(runtime, str);                  \\\n    }                                                           \\\n  } while (0)\n\n/// \\return true if the flags of a new property make it suitable for indexed\n///   storage. All new indexed properties are enumerable, writable and\n///   configurable and have no accessors.\nstatic bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {\n  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&\n      dpf.writable && dpf.setConfigurable && dpf.configurable &&\n      !dpf.setSetter && !dpf.setGetter;\n}\n\nstruct JSObject::Helper {\n public:\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static ObjectFlags &flags(JSObject *self) {\n    return self->flags_;\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static OptValue<PropertyFlags>\n  getOwnIndexedPropertyFlags(JSObject *self, Runtime *runtime, uint32_t index) {\n    return JSObject::getOwnIndexedPropertyFlags(self, runtime, index);\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static NamedPropertyDescriptor &castToNamedPropertyDescriptorRef(\n      ComputedPropertyDescriptor &desc) {\n    return desc.castToNamedPropertyDescriptorRef();\n  }\n};\n\nnamespace {\n\n/// ES5.1 8.12.1.\n\n/// A helper which takes a SymbolID which caches the conversion of\n/// nameValHandle if it's needed.  It should be default constructed,\n/// and may or may not be set.  This has been measured to be a useful\n/// perf win.  Note that always_inline seems to be ignored on static\n/// methods, so this function has to be local to the cpp file in order\n/// to be inlined for the perf win.\nLLVM_ATTRIBUTE_ALWAYS_INLINE\nCallResult<bool> getOwnComputedPrimitiveDescriptorImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    SymbolID &id,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getOwnComputedPrimitiveDescriptor \"\n      \"cannot be an object\");\n\n  // Try the fast paths first if we have \"fast\" index properties and the\n  // property name is an obvious index.\n  if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n    if (JSObject::Helper::flags(*selfHandle).fastIndexProperties) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        // This a valid array index, residing in our indexed storage.\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n\n      // This a valid array index, but we don't have it in our indexed storage,\n      // and we don't have index-like named properties.\n      return false;\n    }\n\n    if (!selfHandle->getClass(runtime)->getHasIndexLikeProperties() &&\n        !selfHandle->isHostObject() && !selfHandle->isLazy() &&\n        !selfHandle->isProxyObject()) {\n      // Early return to handle the case where an object definitely has no\n      // index-like properties. This avoids allocating a new StringPrimitive and\n      // uniquing it below.\n      return false;\n    }\n  }\n\n  // Convert the string to a SymbolID\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n  // Look for a named property with this name.\n  if (JSObject::getOwnNamedDescriptor(\n          selfHandle,\n          runtime,\n          id,\n          JSObject::Helper::castToNamedPropertyDescriptorRef(desc))) {\n    return true;\n  }\n\n  if (LLVM_LIKELY(\n          !JSObject::Helper::flags(*selfHandle).indexedStorage &&\n          !selfHandle->isLazy() && !selfHandle->isProxyObject())) {\n    return false;\n  }\n  MutableHandle<StringPrimitive> strPrim{runtime};\n\n  // If we have indexed storage, perform potentially expensive conversions\n  // to array index and check it.\n  if (JSObject::Helper::flags(*selfHandle).indexedStorage) {\n    // If the name is a valid integer array index, store it here.\n    OptValue<uint32_t> arrayIndex;\n\n    // Try to convert the property name to an array index.\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n\n    if (arrayIndex) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (selfHandle->isLazy()) {\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return JSObject::getOwnComputedPrimitiveDescriptor(\n        selfHandle, runtime, nameValHandle, ignoreProxy, desc);\n  }\n\n  assert(selfHandle->isProxyObject() && \"descriptor flags are impossible\");\n  if (ignoreProxy == JSObject::IgnoreProxy::Yes) {\n    return false;\n  }\n  return JSProxy::getOwnProperty(\n      selfHandle, runtime, nameValHandle, desc, nullptr);\n}\n\n} // namespace\n\nCallResult<bool> JSObject::getOwnComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    ComputedPropertyDescriptor &desc) {\n  SymbolID id{};\n\n  return getOwnComputedPrimitiveDescriptorImpl(\n      selfHandle, runtime, nameValHandle, ignoreProxy, id, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::No, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc,\n    MutableHandle<> &valueOrAccessor) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // The proxy is ignored here so we can avoid calling\n  // JSProxy::getOwnProperty twice on proxies, since\n  // getOwnComputedPrimitiveDescriptor doesn't pass back the\n  // valueOrAccessor.\n  CallResult<bool> res = JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::Yes, desc);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (*res) {\n    valueOrAccessor = getComputedSlotValue(selfHandle.get(), runtime, desc);\n    return true;\n  }\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::getOwnProperty(\n        selfHandle, runtime, nameValHandle, desc, &valueOrAccessor);\n  }\n  return false;\n}\n\nJSObject *JSObject::getNamedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags expectedFlags,\n    NamedPropertyDescriptor &desc) {\n  if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n    return *selfHandle;\n\n  // Check here for host object flag.  This means that \"normal\" own\n  // properties above win over host-defined properties, but there's no\n  // cost imposed on own property lookups.  This should do what we\n  // need in practice, and we can define host vs js property\n  // disambiguation however we want.  This is here in order to avoid\n  // impacting perf for the common case where an own property exists\n  // in normal storage.\n  if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n    desc.flags.hostObject = true;\n    desc.flags.writable = true;\n    return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    assert(\n        !selfHandle->flags_.proxyObject &&\n        \"Proxy objects should never be lazy\");\n    // Initialize the object and perform the lookup again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n\n    if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n      return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    desc.flags.proxyObject = true;\n    return *selfHandle;\n  }\n\n  if (selfHandle->parent_) {\n    MutableHandle<JSObject> mutableSelfHandle{\n        runtime, selfHandle->parent_.getNonNull(runtime)};\n\n    do {\n      // Check the most common case first, at the cost of some code duplication.\n      if (LLVM_LIKELY(\n              !mutableSelfHandle->flags_.lazyObject &&\n              !mutableSelfHandle->flags_.hostObject &&\n              !mutableSelfHandle->flags_.proxyObject)) {\n      findProp:\n        if (findProperty(\n                mutableSelfHandle,\n                runtime,\n                name,\n                PropertyFlags::invalid(),\n                desc)) {\n          assert(\n              !selfHandle->flags_.proxyObject &&\n              \"Proxy object parents should never have own properties\");\n          return *mutableSelfHandle;\n        }\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.lazyObject)) {\n        JSObject::initializeLazyObject(runtime, mutableSelfHandle);\n        goto findProp;\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.hostObject)) {\n        desc.flags.hostObject = true;\n        desc.flags.writable = true;\n        return *mutableSelfHandle;\n      } else {\n        assert(\n            mutableSelfHandle->flags_.proxyObject &&\n            \"descriptor flags are impossible\");\n        desc.flags.proxyObject = true;\n        return *mutableSelfHandle;\n      }\n    } while ((mutableSelfHandle = mutableSelfHandle->parent_.get(runtime)));\n  }\n\n  return nullptr;\n}\n\nExecutionStatus JSObject::getComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getComputedPrimitiveDescriptor cannot \"\n      \"be an object\");\n\n  propObj = selfHandle.get();\n\n  SymbolID id{};\n\n  GCScopeMarkerRAII marker{runtime};\n  do {\n    // A proxy is ignored here so we can check the bit later and\n    // return it back to the caller for additional processing.\n\n    Handle<JSObject> loopHandle = propObj;\n\n    CallResult<bool> res = getOwnComputedPrimitiveDescriptorImpl(\n        loopHandle, runtime, nameValHandle, IgnoreProxy::Yes, id, desc);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*res) {\n      return ExecutionStatus::RETURNED;\n    }\n\n    if (LLVM_UNLIKELY(propObj->flags_.hostObject)) {\n      desc.flags.hostObject = true;\n      desc.flags.writable = true;\n      return ExecutionStatus::RETURNED;\n    }\n    if (LLVM_UNLIKELY(propObj->flags_.proxyObject)) {\n      desc.flags.proxyObject = true;\n      return ExecutionStatus::RETURNED;\n    }\n    // This isn't a proxy, so use the faster getParent() instead of\n    // getPrototypeOf.\n    propObj = propObj->getParent(runtime);\n    // Flush at the end of the loop to allow first iteration to be as fast as\n    // possible.\n    marker.flush();\n  } while (propObj);\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::getComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return getComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, propObj, desc);\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> receiver,\n    PropOpFlags opFlags,\n    PropertyCacheEntry *cacheEntry) {\n  NamedPropertyDescriptor desc;\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (!propObj) {\n    if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n      return runtime->raiseReferenceError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' doesn't exist\");\n    }\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  }\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject)) {\n    // Populate the cache if requested.\n    if (cacheEntry && !propObj->getClass(runtime)->isDictionaryNoCache()) {\n      cacheEntry->clazz = propObj->getClassGCPtr().getStorageType();\n      cacheEntry->slot = desc.slot;\n    }\n    return createPseudoHandle(getNamedSlotValue(propObj, runtime, desc));\n  }\n\n  if (desc.flags.accessor) {\n    auto *accessor =\n        vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return Callable::executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    auto res = vmcast<HostObject>(propObj)->get(name);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return createPseudoHandle(*res);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    return JSProxy::getNamed(\n        runtime->makeHandle(propObj), runtime, name, receiver);\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return getComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)));\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to getNamed().\n  }\n  return getNamed_RJS(selfHandle, runtime, name, opFlags);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return it.\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}\n\nCallResult<bool> JSObject::hasNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  NamedPropertyDescriptor desc;\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (propObj == nullptr) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    return JSProxy::hasNamed(runtime->makeHandle(propObj), runtime, name);\n  }\n  return true;\n}\n\nCallResult<bool> JSObject::hasNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      if (haveOwnIndexed(selfHandle.get(), runtime, *nameAsIndex)) {\n        return true;\n      }\n      if (selfHandle->flags_.fastIndexProperties) {\n        return false;\n      }\n    }\n    // Here we have indexed properties but the symbol was not stored in the\n    // indexedStorage.\n    // Fall through to getNamed().\n  }\n  return hasNamed(selfHandle, runtime, name);\n}\n\nCallResult<bool> JSObject::hasComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return true.\n      if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n        return true;\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (getComputedPrimitiveDescriptor(\n          selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n      ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::hasComputed(propObj, runtime, *key);\n  }\n  // For compatibility with polyfills we want to pretend that all HostObject\n  // properties are \"own\" properties in 'in'. Since there is no way to check for\n  // a HostObject property, we must always assume success. In practice the\n  // property name would have been obtained from enumerating the properties in\n  // JS code that looks something like this:\n  //    for(key in hostObj) {\n  //      if (key in hostObj)\n  //        ...\n  //    }\n  return true;\n}\n\nstatic ExecutionStatus raiseErrorForOverridingStaticBuiltin(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<SymbolID> name) {\n  Handle<StringPrimitive> methodNameHnd =\n      runtime->makeHandle(runtime->getStringPrimFromSymbolID(name.get()));\n  // If the 'name' property does not exist or is an accessor, we don't display\n  // the name.\n  NamedPropertyDescriptor desc;\n  auto *obj = JSObject::getNamedDescriptor(\n      selfHandle, runtime, Predefined::getSymbolID(Predefined::name), desc);\n  assert(\n      !selfHandle->isProxyObject() &&\n      \"raiseErrorForOverridingStaticBuiltin cannot be used with proxy objects\");\n\n  if (!obj || desc.flags.accessor) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  // Display the name property of the builtin object if it is a string.\n  StringPrimitive *objName = dyn_vmcast<StringPrimitive>(\n      JSObject::getNamedSlotValue(selfHandle.get(), runtime, desc));\n  if (!objName) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  return runtime->raiseTypeError(\n      TwineChar16(\"Attempting to override read-only builtin method '\") +\n      TwineChar16(objName) + \".\" + TwineChar16(methodNameHnd.get()) + \"'\");\n}\n\nCallResult<bool> JSObject::putNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  NamedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(\n      selfHandle,\n      runtime,\n      name,\n      PropertyFlags::defaultNewNamedPropertyFlags(),\n      desc);\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            *selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      setNamedSlotValue(\n          *selfHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor =\n          vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              TwineChar16(\"Cannot assign to property '\") +\n              runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n              \"' which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              *valueHandle) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<bool> setRes = JSProxy::setNamed(\n          runtime->makeHandle(propObj), runtime, name, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy set returned false for property '\") +\n            runtime->getIdentifierTable().getStringView(runtime, name) + \"'\");\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(name));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Cannot assign to read-only property '\") +\n            runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n            \"'\");\n      }\n      return false;\n    }\n\n    if (*selfHandle == propObj && desc.flags.internalSetter) {\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueHandle, opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n\n    if (getOwnNamedDescriptor(receiverHandle, runtime, name, desc)) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      assert(\n          !receiverHandle->isHostObject() && !receiverHandle->isProxyObject() &&\n          \"getOwnNamedDescriptor never sets hostObject or proxyObject flags\");\n\n      setNamedSlotValue(\n          *receiverHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    // Now deal with host and proxy object cases.  We need to call\n    // getOwnComputedPrimitiveDescriptor because it knows how to call\n    // the [[getOwnProperty]] Proxy impl if needed.\n    if (LLVM_UNLIKELY(\n            receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())\n            ->set(name, *valueHandle);\n      }\n      ComputedPropertyDescriptor desc;\n      Handle<> nameValHandle = runtime->makeHandle(name);\n      CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n          receiverHandle, runtime, nameValHandle, IgnoreProxy::No, desc);\n      if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      DefinePropertyFlags dpf;\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle, runtime, nameValHandle, dpf, valueHandle, opFlags);\n    }\n  }\n\n  // Does the caller require it to exist?\n  if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n    return runtime->raiseReferenceError(\n        TwineChar16(\"Property '\") +\n        runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n        \"' doesn't exist\");\n  }\n\n  // Add a new property.\n\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      name,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::putNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return putComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)),\n          valueHandle,\n          opFlags);\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to putNamed().\n  }\n  return putNamed_RJS(selfHandle, runtime, name, valueHandle, opFlags);\n}\n\nCallResult<bool> JSObject::putComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() &&\n      \"mustExist flag cannot be used with computed properties\");\n\n  // Try the fast-path first: has \"index-like\" properties, the \"name\"\n  // already is a valid integer index, selfHandle and receiver are the\n  // same, and it is present in storage.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {\n        if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n          auto result =\n              setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);\n          if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_LIKELY(*result))\n            return true;\n          if (opFlags.getThrowOnError()) {\n            // TODO: better message.\n            return runtime->raiseTypeError(\n                \"Cannot assign to read-only property\");\n          }\n          return false;\n        }\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      if (LLVM_UNLIKELY(\n              setComputedSlotValue(selfHandle, runtime, desc, valueHandle) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    // Is it an accessor?\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor = vmcast<PropertyAccessor>(\n          getComputedSlotValue(propObj.get(), runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeErrorForValue(\n              \"Cannot assign to property \",\n              nameValPrimitiveHandle,\n              \" which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              valueHandle.get()) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n      if (key == ExecutionStatus::EXCEPTION)\n        return ExecutionStatus::EXCEPTION;\n      CallResult<bool> setRes =\n          JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy trap returned false for property\"));\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        SymbolID id{};\n        LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(id));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeErrorForValue(\n            \"Cannot assign to read-only property \", nameValPrimitiveHandle, \"\");\n      }\n      return false;\n    }\n\n    if (selfHandle == propObj && desc.flags.internalSetter) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      return internalSetter(\n          selfHandle,\n          runtime,\n          id,\n          desc.castToNamedPropertyDescriptorRef(),\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n    CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n        receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);\n    if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    DefinePropertyFlags dpf;\n    if (*descDefinedRes) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      if (LLVM_LIKELY(\n              !desc.flags.internalSetter && !receiverHandle->isHostObject() &&\n              !receiverHandle->isProxyObject())) {\n        if (LLVM_UNLIKELY(\n                setComputedSlotValue(\n                    receiverHandle, runtime, desc, valueHandle) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        return true;\n      }\n    }\n\n    if (LLVM_UNLIKELY(\n            desc.flags.internalSetter || receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      if (desc.flags.internalSetter) {\n        return internalSetter(\n            receiverHandle,\n            runtime,\n            id,\n            desc.castToNamedPropertyDescriptorRef(),\n            valueHandle,\n            opFlags);\n      } else if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n      }\n      assert(\n          receiverHandle->isProxyObject() && \"descriptor flags are impossible\");\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle,\n          runtime,\n          nameValPrimitiveHandle,\n          dpf,\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  /// Can we add more properties?\n  if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // If we have indexed storage we must check whether the property is an index,\n  // and if it is, store it in indexed storage.\n  if (receiverHandle->flags_.indexedStorage) {\n    OptValue<uint32_t> arrayIndex;\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n    if (arrayIndex) {\n      // Check whether we need to update array's \".length\" property.\n      if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {\n        if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {\n          auto cr = putNamed_RJS(\n              receiverHandle,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime->makeHandle(\n                  HermesValue::encodeNumberValue(*arrayIndex + 1)),\n              opFlags);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_UNLIKELY(!*cr))\n            return false;\n        }\n      }\n\n      auto result =\n          setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (LLVM_LIKELY(*result))\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\"Cannot assign to read-only property\");\n      }\n      return false;\n    }\n  }\n\n  SymbolID id{};\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Add a new named property.\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      id,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::deleteNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n\n  // If the property doesn't exist in this object, return success.\n  if (!pos) {\n    if (LLVM_LIKELY(\n            !selfHandle->flags_.lazyObject &&\n            !selfHandle->flags_.proxyObject)) {\n      return true;\n    } else if (selfHandle->flags_.lazyObject) {\n      // object is lazy, initialize and read again.\n      initializeLazyObject(runtime, selfHandle);\n      pos = findProperty(selfHandle, runtime, name, desc);\n      if (!pos) // still not there, return true.\n        return true;\n    } else {\n      assert(selfHandle->flags_.proxyObject && \"object flags are impossible\");\n      return proxyOpFlags(\n          runtime,\n          opFlags,\n          \"Proxy delete returned false\",\n          JSProxy::deleteNamed(selfHandle, runtime, name));\n    }\n  }\n  // If the property isn't configurable, fail.\n  if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' is not configurable\");\n    }\n    return false;\n  }\n\n  // Clear the deleted property value to prevent memory leaks.\n  setNamedSlotValue(\n      *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n  // Perform the actual deletion.\n  auto newClazz = HiddenClass::deleteProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  return true;\n}\n\nCallResult<bool> JSObject::deleteComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  auto nameValPrimitiveHandle = *converted;\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n  }\n\n  // Try the fast-path first: the \"name\" is a valid array index and we don't\n  // have \"index-like\" named properties.\n  if (arrayIndex && selfHandle->flags_.fastIndexProperties) {\n    // Delete the indexed property.\n    if (deleteOwnIndexed(selfHandle, runtime, *arrayIndex))\n      return true;\n\n    // Cannot delete property (for example this may be a typed array).\n    if (opFlags.getThrowOnError()) {\n      // TODO: better error message.\n      return runtime->raiseTypeError(\"Cannot delete property\");\n    }\n    return false;\n  }\n\n  // slow path, check if object is lazy before continuing.\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    // initialize and try again.\n    initializeLazyObject(runtime, selfHandle);\n    return deleteComputed(selfHandle, runtime, nameValHandle, opFlags);\n  }\n\n  // Convert the string to an SymbolID;\n  SymbolID id;\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, id, desc);\n\n  // If the property exists, make sure it is configurable.\n  if (pos) {\n    // If the property isn't configurable, fail.\n    if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: a better message.\n        return runtime->raiseTypeError(\"Property is not configurable\");\n      }\n      return false;\n    }\n  }\n\n  // At this point we know that the named property either doesn't exist, or\n  // is configurable and so can be deleted, or the object is a Proxy.\n\n  // If it is an \"index-like\" property, we must also delete the \"shadow\" indexed\n  // property in order to keep Array.length correct.\n  if (arrayIndex) {\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      // Cannot delete property (for example this may be a typed array).\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot delete property\");\n      }\n      return false;\n    }\n  }\n\n  if (pos) {\n    // delete the named property (if it exists).\n    // Clear the deleted property value to prevent memory leaks.\n    setNamedSlotValue(\n        *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n    // Remove the property descriptor.\n    auto newClazz = HiddenClass::deleteProperty(\n        runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Proxy delete returned false\",\n        JSProxy::deleteComputed(selfHandle, runtime, *key));\n  }\n\n  return true;\n}\n\nCallResult<bool> JSObject::defineOwnPropertyInternal(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // Is it an existing property.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n  if (pos) {\n    return updateOwnProperty(\n        selfHandle,\n        runtime,\n        name,\n        *pos,\n        desc,\n        dpFlags,\n        valueOrAccessor,\n        opFlags);\n  }\n\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      return JSProxy::defineOwnProperty(\n          selfHandle,\n          runtime,\n          name.isUniqued() ? runtime->makeHandle(HermesValue::encodeStringValue(\n                                 runtime->getStringPrimFromSymbolID(name)))\n                           : runtime->makeHandle(name),\n          dpFlags,\n          valueOrAccessor,\n          opFlags);\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    // if the property was not found and the object is lazy we need to\n    // initialize it and try again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return defineOwnPropertyInternal(\n        selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  return addOwnProperty(\n      selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n}\n\nExecutionStatus JSObject::defineNewOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"definedNewOwnProperty cannot be used with proxy objects\");\n  assert(\n      !(propertyFlags.accessor && !valueOrAccessor.get().isPointer()) &&\n      \"accessor must be non-empty\");\n  assert(\n      !(propertyFlags.accessor && propertyFlags.writable) &&\n      \"writable must not be set with accessors\");\n  assert(\n      !HiddenClass::debugIsPropertyDefined(\n          selfHandle->clazz_.get(runtime), runtime, name) &&\n      \"new property is already defined\");\n\n  return addOwnPropertyImpl(\n      selfHandle, runtime, name, propertyFlags, valueOrAccessor);\n}\n\nCallResult<bool> JSObject::defineOwnComputedPrimitive(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"defineOwnComputedPrimitive() cannot be \"\n      \"an object\");\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"Cannot set internalSetter on a computed property\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n  }\n\n  SymbolID id{};\n\n  // If not storing a property with an array index name, or if we don't have\n  // indexed storage, just pass to the named routine.\n  if (!arrayIndex) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return defineOwnPropertyInternal(\n        selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  // At this point we know that we have indexed storage and that the property\n  // has an index-like name.\n\n  // First check if a named property with the same name exists.\n  if (selfHandle->clazz_.get(runtime)->getHasIndexLikeProperties()) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n    NamedPropertyDescriptor desc;\n    auto pos = findProperty(selfHandle, runtime, id, desc);\n    // If we found a named property, update it.\n    if (pos) {\n      return updateOwnProperty(\n          selfHandle,\n          runtime,\n          id,\n          *pos,\n          desc,\n          dpFlags,\n          valueOrAccessor,\n          opFlags);\n    }\n  }\n\n  // Does an indexed property with that index exist?\n  auto indexedPropPresent =\n      getOwnIndexedPropertyFlags(selfHandle.get(), runtime, *arrayIndex);\n  if (indexedPropPresent) {\n    // The current value of the property.\n    HermesValue curValueOrAccessor =\n        getOwnIndexed(selfHandle.get(), runtime, *arrayIndex);\n\n    auto updateStatus = checkPropertyUpdate(\n        runtime,\n        *indexedPropPresent,\n        dpFlags,\n        curValueOrAccessor,\n        valueOrAccessor,\n        opFlags);\n    if (updateStatus == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    if (updateStatus->first == PropertyUpdateStatus::failed)\n      return false;\n\n    // The property update is valid, but can the property remain an \"indexed\"\n    // property, or do we need to convert it to a named property?\n    // If the property flags didn't change, the property remains indexed.\n    if (updateStatus->second == *indexedPropPresent) {\n      // If the value doesn't change, we are done.\n      if (updateStatus->first == PropertyUpdateStatus::done)\n        return true;\n\n      // If we successfully updated the value, we are done.\n      auto result =\n          setOwnIndexed(selfHandle, runtime, *arrayIndex, valueOrAccessor);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*result)\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\n            \"cannot change read-only property value\");\n      }\n\n      return false;\n    }\n\n    // OK, we need to convert an indexed property to a named one.\n\n    // Check whether to use the supplied value, or to reuse the old one, as we\n    // are simply reconfiguring it.\n    MutableHandle<> value{runtime};\n    if (dpFlags.setValue || dpFlags.isAccessor()) {\n      value = valueOrAccessor.get();\n    } else {\n      value = curValueOrAccessor;\n    }\n\n    // Update dpFlags to match the existing property flags.\n    dpFlags.setEnumerable = 1;\n    dpFlags.setWritable = 1;\n    dpFlags.setConfigurable = 1;\n    dpFlags.enumerable = updateStatus->second.enumerable;\n    dpFlags.writable = updateStatus->second.writable;\n    dpFlags.configurable = updateStatus->second.configurable;\n\n    // Delete the existing indexed property.\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n\n    // Add the new named property.\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return addOwnProperty(selfHandle, runtime, id, dpFlags, value, opFlags);\n  }\n\n  /// Can we add new properties?\n  if (!selfHandle->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // This is a new property with an index-like name.\n  // Check whether we need to update array's \".length\" property.\n  bool updateLength = false;\n  if (auto arrayHandle = Handle<JSArray>::dyn_vmcast(selfHandle)) {\n    if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(*arrayHandle))) {\n      NamedPropertyDescriptor lengthDesc;\n      bool lengthPresent = getOwnNamedDescriptor(\n          arrayHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::length),\n          lengthDesc);\n      (void)lengthPresent;\n      assert(lengthPresent && \".length must be present in JSArray\");\n\n      if (!lengthDesc.flags.writable) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"Cannot assign to read-only 'length' property of array\");\n        }\n        return false;\n      }\n\n      updateLength = true;\n    }\n  }\n\n  bool newIsIndexed = canNewPropertyBeIndexed(dpFlags);\n  if (newIsIndexed) {\n    auto result = setOwnIndexed(\n        selfHandle,\n        runtime,\n        *arrayIndex,\n        dpFlags.setValue ? valueOrAccessor : Runtime::getUndefinedValue());\n    if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    if (!*result) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n  }\n\n  // If this is an array and we need to update \".length\", do so.\n  if (updateLength) {\n    // This should always succeed since we are simply enlarging the length.\n    auto res = JSArray::setLength(\n        Handle<JSArray>::vmcast(selfHandle), runtime, *arrayIndex + 1, opFlags);\n    (void)res;\n    assert(\n        res != ExecutionStatus::EXCEPTION && *res &&\n        \"JSArray::setLength() failed unexpectedly\");\n  }\n\n  if (newIsIndexed)\n    return true;\n\n  // We are adding a new property with an index-like name.\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n  return addOwnProperty(\n      selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n}\n\nCallResult<bool> JSObject::defineOwnComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return defineOwnComputedPrimitive(\n      selfHandle, runtime, *converted, dpFlags, valueOrAccessor, opFlags);\n}\n\nstd::string JSObject::getHeuristicTypeName(GC *gc) {\n  PointerBase *const base = gc->getPointerBase();\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (auto *constructor = dyn_vmcast<JSObject>(*constructorVal)) {\n      auto name = constructor->getNameIfExists(base);\n      // If the constructor's name doesn't exist, or it is just the object\n      // constructor, attempt to find a different name.\n      if (!name.empty() && name != \"Object\")\n        return name;\n    }\n  }\n\n  std::string name = getVT()->base.snapshotMetaData.defaultNameForNode(this);\n  // A constructor's name was not found, check if the object is in dictionary\n  // mode.\n  if (getClass(base)->isDictionary()) {\n    return name + \"(Dictionary)\";\n  }\n\n  // If it's not an Object, the CellKind is most likely good enough on its own\n  if (getKind() != CellKind::ObjectKind) {\n    return name;\n  }\n\n  // If the object isn't a dictionary, and it has only a few property names,\n  // make the name based on those property names.\n  std::vector<std::string> propertyNames;\n  HiddenClass::forEachPropertyNoAlloc(\n      getClass(base),\n      base,\n      [gc, &propertyNames](SymbolID id, NamedPropertyDescriptor) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        propertyNames.emplace_back(gc->convertSymbolToUTF8(id));\n      });\n  // NOTE: One option is to sort the property names before truncation, to\n  // reduce the number of groups; however, by not sorting them it makes it\n  // easier to spot sets of objects with the same properties but in different\n  // orders, and thus find HiddenClass optimizations to make.\n\n  // For objects with a lot of properties but aren't in dictionary mode yet,\n  // keep the number displayed small.\n  constexpr int kMaxPropertiesForTypeName = 5;\n  bool truncated = false;\n  if (propertyNames.size() > kMaxPropertiesForTypeName) {\n    propertyNames.erase(\n        propertyNames.begin() + kMaxPropertiesForTypeName, propertyNames.end());\n    truncated = true;\n  }\n  // The final name should look like Object(a, b, c).\n  if (propertyNames.empty()) {\n    // Don't add parentheses for objects with no properties.\n    return name;\n  }\n  name += \"(\";\n  bool first = true;\n  for (const auto &prop : propertyNames) {\n    if (!first) {\n      name += \", \";\n    }\n    first = false;\n    name += prop;\n  }\n  if (truncated) {\n    // No need to check for comma edge case because this only happens for\n    // greater than one property.\n    static_assert(\n        kMaxPropertiesForTypeName >= 1,\n        \"Property truncation should not happen for 0 properties\");\n    name += \", ...\";\n  }\n  name += \")\";\n  return name;\n}\n\nstd::string JSObject::getNameIfExists(PointerBase *base) {\n  // Try \"displayName\" first, if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::displayName))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // Next, use \"name\" if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::name))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // There is no other way to access the \"name\" property on an object.\n  return \"\";\n}\n\nstd::string JSObject::_snapshotNameImpl(GCCell *cell, GC *gc) {\n  auto *const self = vmcast<JSObject>(cell);\n  return self->getHeuristicTypeName(gc);\n}\n\nvoid JSObject::_snapshotAddEdgesImpl(GCCell *cell, GC *gc, HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n\n  // Add the prototype as a property edge, so it's easy for JS developers to\n  // walk the prototype chain on their own.\n  if (self->parent_) {\n    snap.addNamedEdge(\n        HeapSnapshot::EdgeType::Property,\n        // __proto__ chosen for similarity to V8.\n        \"__proto__\",\n        gc->getObjectID(self->parent_));\n  }\n\n  HiddenClass::forEachPropertyNoAlloc(\n      self->clazz_.get(gc->getPointerBase()),\n      gc->getPointerBase(),\n      [self, gc, &snap](SymbolID id, NamedPropertyDescriptor desc) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        // Else, it's a user-visible property.\n        GCHermesValue &prop =\n            namedSlotRef(self, gc->getPointerBase(), desc.slot);\n        const llvh::Optional<HeapSnapshot::NodeID> idForProp =\n            gc->getSnapshotID(prop);\n        if (!idForProp) {\n          return;\n        }\n        std::string propName = gc->convertSymbolToUTF8(id);\n        // If the property name is a valid array index, display it as an\n        // \"element\" instead of a \"property\". This will put square brackets\n        // around the number and sort it numerically rather than\n        // alphabetically.\n        if (auto index = ::hermes::toArrayIndex(propName)) {\n          snap.addIndexedEdge(\n              HeapSnapshot::EdgeType::Element,\n              index.getValue(),\n              idForProp.getValue());\n        } else {\n          snap.addNamedEdge(\n              HeapSnapshot::EdgeType::Property, propName, idForProp.getValue());\n        }\n      });\n}\n\nvoid JSObject::_snapshotAddLocationsImpl(\n    GCCell *cell,\n    GC *gc,\n    HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n  PointerBase *const base = gc->getPointerBase();\n  // Add the location of the constructor function for this object, if that\n  // constructor is a user-defined JS function.\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          self, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (constructorVal->isObject()) {\n      if (auto *constructor = dyn_vmcast<JSFunction>(*constructorVal)) {\n        constructor->addLocationToSnapshot(snap, gc->getObjectID(self));\n      }\n    }\n  }\n}\n\nstd::pair<uint32_t, uint32_t> JSObject::_getOwnIndexedRangeImpl(\n    JSObject *self,\n    Runtime *runtime) {\n  return {0, 0};\n}\n\nbool JSObject::_haveOwnIndexedImpl(JSObject *self, Runtime *, uint32_t) {\n  return false;\n}\n\nOptValue<PropertyFlags> JSObject::_getOwnIndexedPropertyFlagsImpl(\n    JSObject *self,\n    Runtime *runtime,\n    uint32_t) {\n  return llvh::None;\n}\n\nHermesValue JSObject::_getOwnIndexedImpl(JSObject *, Runtime *, uint32_t) {\n  return HermesValue::encodeEmptyValue();\n}\n\nCallResult<bool>\nJSObject::_setOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t, Handle<>) {\n  return false;\n}\n\nbool JSObject::_deleteOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t) {\n  return false;\n}\n\nbool JSObject::_checkAllOwnIndexedImpl(\n    JSObject * /*self*/,\n    Runtime * /*runtime*/,\n    ObjectVTable::CheckAllOwnIndexedMode /*mode*/) {\n  return true;\n}\n\nvoid JSObject::preventExtensions(JSObject *self) {\n  assert(\n      !self->flags_.proxyObject &&\n      \"[[Extensible]] slot cannot be set directly on Proxy objects\");\n  self->flags_.noExtend = true;\n}\n\nCallResult<bool> JSObject::preventExtensions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::preventExtensions(selfHandle, runtime, opFlags);\n  }\n  JSObject::preventExtensions(*selfHandle);\n  return true;\n}\n\nExecutionStatus JSObject::seal(Handle<JSObject> selfHandle, Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes && \"seal preventExtensions with ThrowOnError returned false\");\n\n  // Already sealed?\n  if (selfHandle->flags_.sealed)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllNonConfigurable(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::freeze(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes &&\n      \"freeze preventExtensions with ThrowOnError returned false\");\n\n  // Already frozen?\n  if (selfHandle->flags_.frozen)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllReadOnly(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nvoid JSObject::updatePropertyFlagsWithoutTransitions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropertyFlags flagsToClear,\n    PropertyFlags flagsToSet,\n    OptValue<llvh::ArrayRef<SymbolID>> props) {\n  auto newClazz = HiddenClass::updatePropertyFlagsWithoutTransitions(\n      runtime->makeHandle(selfHandle->clazz_),\n      runtime,\n      flagsToClear,\n      flagsToSet,\n      props);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n}\n\nCallResult<bool> JSObject::isExtensible(\n    PseudoHandle<JSObject> self,\n    Runtime *runtime) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return JSProxy::isExtensible(runtime->makeHandle(std::move(self)), runtime);\n  }\n  return self->isExtensible();\n}\n\nbool JSObject::isSealed(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.sealed)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllNonConfigurable(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::NonConfigurable)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nbool JSObject::isFrozen(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.frozen)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllReadOnly(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::ReadOnly)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nCallResult<bool> JSObject::addOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  /// Can we add more properties?\n  if (!selfHandle->isExtensible() && !opFlags.getInternalForce()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Cannot add new property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"'\");\n    }\n    return false;\n  }\n\n  PropertyFlags flags{};\n\n  // Accessors don't set writeable.\n  if (dpFlags.isAccessor()) {\n    dpFlags.setWritable = 0;\n    flags.accessor = 1;\n  }\n\n  // Override the default flags if specified.\n  if (dpFlags.setEnumerable)\n    flags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    flags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    flags.configurable = dpFlags.configurable;\n  flags.internalSetter = dpFlags.enableInternalSetter;\n\n  if (LLVM_UNLIKELY(\n          addOwnPropertyImpl(\n              selfHandle, runtime, name, flags, valueOrAccessor) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  return true;\n}\n\nExecutionStatus JSObject::addOwnPropertyImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"Internal properties cannot be added to Proxy objects\");\n  // Add a new property to the class.\n  // TODO: if we check for OOM here in the future, we must undo the slot\n  // allocation.\n  auto addResult = HiddenClass::addProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, name, propertyFlags);\n  if (LLVM_UNLIKELY(addResult == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  selfHandle->clazz_.set(runtime, *addResult->first, &runtime->getHeap());\n\n  allocateNewSlotStorage(\n      selfHandle, runtime, addResult->second, valueOrAccessor);\n\n  // If this is an index-like property, we need to clear the fast path flags.\n  if (LLVM_UNLIKELY(\n          selfHandle->clazz_.getNonNull(runtime)->getHasIndexLikeProperties()))\n    selfHandle->flags_.fastIndexProperties = false;\n\n  return ExecutionStatus::RETURNED;\n}\n\nCallResult<bool> JSObject::updateOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    HiddenClass::PropertyPos propertyPos,\n    NamedPropertyDescriptor desc,\n    const DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto updateStatus = checkPropertyUpdate(\n      runtime,\n      desc.flags,\n      dpFlags,\n      getNamedSlotValue(selfHandle.get(), runtime, desc),\n      valueOrAccessor,\n      opFlags);\n  if (updateStatus == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n  if (updateStatus->first == PropertyUpdateStatus::failed)\n    return false;\n\n  // If the property flags changed, update them.\n  if (updateStatus->second != desc.flags) {\n    desc.flags = updateStatus->second;\n    auto newClazz = HiddenClass::updateProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        propertyPos,\n        desc.flags);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  }\n\n  if (updateStatus->first == PropertyUpdateStatus::done)\n    return true;\n  assert(\n      updateStatus->first == PropertyUpdateStatus::needSet &&\n      \"unexpected PropertyUpdateStatus\");\n\n  if (dpFlags.setValue) {\n    if (LLVM_LIKELY(!desc.flags.internalSetter))\n      setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n    else\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueOrAccessor, opFlags);\n  } else if (dpFlags.isAccessor()) {\n    setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n  } else {\n    // If checkPropertyUpdate() returned needSet, but there is no value or\n    // accessor, clear the value.\n    setNamedSlotValue(\n        selfHandle.get(), runtime, desc, HermesValue::encodeUndefinedValue());\n  }\n\n  return true;\n}\n\nCallResult<std::pair<JSObject::PropertyUpdateStatus, PropertyFlags>>\nJSObject::checkPropertyUpdate(\n    Runtime *runtime,\n    const PropertyFlags currentFlags,\n    DefinePropertyFlags dpFlags,\n    const HermesValue curValueOrAccessor,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  // 8.12.9 [5] Return true, if every field in Desc is absent.\n  if (dpFlags.isEmpty())\n    return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n\n  assert(\n      (!dpFlags.isAccessor() || (!dpFlags.setWritable && !dpFlags.writable)) &&\n      \"can't set both accessor and writable\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"cannot change the value of internalSetter\");\n\n  // 8.12.9 [6] Return true, if every field in Desc also occurs in current and\n  // the value of every field in Desc is the same value as the corresponding\n  // field in current when compared using the SameValue algorithm (9.12).\n  // TODO: this would probably be much more efficient with bitmasks.\n  if ((!dpFlags.setEnumerable ||\n       dpFlags.enumerable == currentFlags.enumerable) &&\n      (!dpFlags.setConfigurable ||\n       dpFlags.configurable == currentFlags.configurable)) {\n    if (dpFlags.isAccessor()) {\n      if (currentFlags.accessor) {\n        auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n        auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n        if ((!dpFlags.setGetter ||\n             curAccessor->getter == newAccessor->getter) &&\n            (!dpFlags.setSetter ||\n             curAccessor->setter == newAccessor->setter)) {\n          return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n        }\n      }\n    } else {\n      if (!currentFlags.accessor &&\n          (!dpFlags.setValue ||\n           isSameValue(curValueOrAccessor, valueOrAccessor.get())) &&\n          (!dpFlags.setWritable || dpFlags.writable == currentFlags.writable)) {\n        return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n      }\n    }\n  }\n\n  // 8.12.9 [7]\n  // If the property is not configurable, some aspects are not changeable.\n  if (!currentFlags.configurable) {\n    // Trying to change non-configurable to configurable?\n    if (dpFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // Trying to change the enumerability of non-configurable property?\n    if (dpFlags.setEnumerable &&\n        dpFlags.enumerable != currentFlags.enumerable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n  }\n\n  PropertyFlags newFlags = currentFlags;\n\n  // 8.12.9 [8] If IsGenericDescriptor(Desc) is true, then no further validation\n  // is required.\n  if (!(dpFlags.setValue || dpFlags.setWritable || dpFlags.setGetter ||\n        dpFlags.setSetter)) {\n    // Do nothing\n  }\n  // 8.12.9 [9]\n  // Changing between accessor and data descriptor?\n  else if (currentFlags.accessor != dpFlags.isAccessor()) {\n    if (!currentFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // If we change from accessor to data descriptor, Preserve the existing\n    // values of the converted property\u2019s [[Configurable]] and [[Enumerable]]\n    // attributes and set the rest of the property\u2019s attributes to their default\n    // values.\n    // If it's the other way around, since the accessor doesn't have the\n    // [[Writable]] attribute, do nothing.\n    newFlags.writable = 0;\n\n    // If we are changing from accessor to non-accessor, we must set a new\n    // value.\n    if (!dpFlags.isAccessor())\n      dpFlags.setValue = 1;\n  }\n  // 8.12.9 [10] if both are data descriptors.\n  else if (!currentFlags.accessor) {\n    if (!currentFlags.configurable) {\n      if (!currentFlags.writable) {\n        // If the current property is not writable, but the new one is.\n        if (dpFlags.writable) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not configurable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n\n        // If we are setting a different value.\n        if (dpFlags.setValue &&\n            !isSameValue(curValueOrAccessor, valueOrAccessor.get())) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not writable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n      }\n    }\n  }\n  // 8.12.9 [11] Both are accessors.\n  else {\n    auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n    auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n    // If not configurable, make sure that nothing is changing.\n    if (!currentFlags.configurable) {\n      if ((dpFlags.setGetter && newAccessor->getter != curAccessor->getter) ||\n          (dpFlags.setSetter && newAccessor->setter != curAccessor->setter)) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"property is not configurable\"); // TODO: better message.\n        }\n        return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n      }\n    }\n\n    // If not setting the getter or the setter, re-use the current one.\n    if (!dpFlags.setGetter)\n      newAccessor->getter.set(\n          runtime, curAccessor->getter, &runtime->getHeap());\n    if (!dpFlags.setSetter)\n      newAccessor->setter.set(\n          runtime, curAccessor->setter, &runtime->getHeap());\n  }\n\n  // 8.12.9 [12] For each attribute field of Desc that is present, set the\n  // correspondingly named attribute of the property named P of object O to the\n  // value of the field.\n  if (dpFlags.setEnumerable)\n    newFlags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    newFlags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    newFlags.configurable = dpFlags.configurable;\n\n  if (dpFlags.setValue)\n    newFlags.accessor = false;\n  else if (dpFlags.isAccessor())\n    newFlags.accessor = true;\n  else\n    return std::make_pair(PropertyUpdateStatus::done, newFlags);\n\n  return std::make_pair(PropertyUpdateStatus::needSet, newFlags);\n}\n\nCallResult<bool> JSObject::internalSetter(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    NamedPropertyDescriptor /*desc*/,\n    Handle<> value,\n    PropOpFlags opFlags) {\n  if (vmisa<JSArray>(selfHandle.get())) {\n    if (name == Predefined::getSymbolID(Predefined::length)) {\n      return JSArray::setLength(\n          Handle<JSArray>::vmcast(selfHandle), runtime, value, opFlags);\n    }\n  }\n\n  llvm_unreachable(\"unhandled property in Object::internalSetter()\");\n}\n\nnamespace {\n\n/// Helper function to add all the property names of an object to an\n/// array, starting at the given index. Only enumerable properties are\n/// incluced. Returns the index after the last property added, but...\nCallResult<uint32_t> appendAllPropertyNames(\n    Handle<JSObject> obj,\n    Runtime *runtime,\n    MutableHandle<BigStorage> &arr,\n    uint32_t beginIndex) {\n  uint32_t size = beginIndex;\n  // We know that duplicate property names can only exist between objects in\n  // the prototype chain. Hence there should not be duplicated properties\n  // before we start to look at any prototype.\n  bool needDedup = false;\n  MutableHandle<> prop(runtime);\n  MutableHandle<JSObject> head(runtime, obj.get());\n  MutableHandle<StringPrimitive> tmpVal{runtime};\n  while (head.get()) {\n    GCScope gcScope(runtime);\n\n    // enumerableProps will contain all enumerable own properties from obj.\n    // Impl note: this is the only place where getOwnPropertyKeys will be\n    // called without IncludeNonEnumerable on a Proxy.  Everywhere else,\n    // trap ordering is specified but ES9 13.7.5.15 says \"The mechanics and\n    // order of enumerating the properties is not specified\", which is\n    // unusual.\n    auto cr =\n        JSObject::getOwnPropertyNames(head, runtime, true /* onlyEnumerable */);\n    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto enumerableProps = *cr;\n    auto marker = gcScope.createMarker();\n    for (unsigned i = 0, e = enumerableProps->getEndIndex(); i < e; ++i) {\n      gcScope.flushToMarker(marker);\n      prop = enumerableProps->at(runtime, i);\n      if (!needDedup) {\n        // If no dedup is needed, add it directly.\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n        continue;\n      }\n      // Otherwise loop through all existing properties and check if we\n      // have seen it before.\n      bool dupFound = false;\n      if (prop->isNumber()) {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            dupFound = val.getNumber() == prop->getNumber();\n          } else {\n            // val is string, prop is number.\n            tmpVal = val.getString();\n            auto valNum = toArrayIndex(\n                StringPrimitive::createStringView(runtime, tmpVal));\n            dupFound = valNum && valNum.getValue() == prop->getNumber();\n          }\n        }\n      } else {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            // val is number, prop is string.\n            auto propNum = toArrayIndex(StringPrimitive::createStringView(\n                runtime, Handle<StringPrimitive>::vmcast(prop)));\n            dupFound = propNum && (propNum.getValue() == val.getNumber());\n          } else {\n            dupFound = val.getString()->equals(prop->getString());\n          }\n        }\n      }\n      if (LLVM_LIKELY(!dupFound)) {\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n      }\n    }\n    // Continue to follow the prototype chain.\n    CallResult<PseudoHandle<JSObject>> parentRes =\n        JSObject::getPrototypeOf(head, runtime);\n    if (LLVM_UNLIKELY(parentRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = parentRes->get();\n    needDedup = true;\n  }\n  return size;\n}\n\n/// Adds the hidden classes of the prototype chain of obj to arr,\n/// starting with the prototype of obj at index 0, etc., and\n/// terminates with null.\n///\n/// \\param obj The object whose prototype chain should be output\n/// \\param[out] arr The array where the classes will be appended. This\n/// array is cleared if any object is unsuitable for caching.\nExecutionStatus setProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    MutableHandle<BigStorage> &arr) {\n  // Layout of a JSArray stored in the for-in cache:\n  // [class(proto(obj)), class(proto(proto(obj))), ..., null, prop0, prop1, ...]\n\n  if (!obj->shouldCacheForIn(runtime)) {\n    arr->clear(runtime);\n    return ExecutionStatus::RETURNED;\n  }\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  MutableHandle<> clazz(runtime);\n  GCScopeMarkerRAII marker{runtime};\n  while (head.get()) {\n    if (!head->shouldCacheForIn(runtime)) {\n      arr->clear(runtime);\n      return ExecutionStatus::RETURNED;\n    }\n    if (JSObject::Helper::flags(*head).lazyObject) {\n      // Ensure all properties have been initialized before caching the hidden\n      // class. Not doing this will result in changes to the hidden class\n      // when getOwnPropertyKeys is called later.\n      JSObject::initializeLazyObject(runtime, head);\n    }\n    clazz = HermesValue::encodeObjectValue(head->getClass(runtime));\n    if (LLVM_UNLIKELY(\n            BigStorage::push_back(arr, runtime, clazz) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = head->getParent(runtime);\n    marker.flush();\n  }\n  clazz = HermesValue::encodeNullValue();\n  return BigStorage::push_back(arr, runtime, clazz);\n}\n\n/// Verifies that the classes of obj's prototype chain still matches those\n/// previously prefixed to arr by setProtoClasses.\n///\n/// \\param obj The object whose prototype chain should be verified\n/// \\param arr Array previously populated by setProtoClasses\n/// \\return The index after the terminating null if everything matches,\n/// otherwise 0.\nuint32_t matchesProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    Handle<BigStorage> arr) {\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  uint32_t i = 0;\n  while (head.get()) {\n    HermesValue protoCls = arr->at(i++);\n    if (protoCls.isNull() || protoCls.getObject() != head->getClass(runtime) ||\n        head->isProxyObject()) {\n      return 0;\n    }\n    head = head->getParent(runtime);\n  }\n  // The chains must both end at the same point.\n  if (head || !arr->at(i++).isNull()) {\n    return 0;\n  }\n  assert(i > 0 && \"success should be positive\");\n  return i;\n}\n\n} // namespace\n\nCallResult<Handle<BigStorage>> getForInPropertyNames(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    uint32_t &beginIndex,\n    uint32_t &endIndex) {\n  Handle<HiddenClass> clazz(runtime, obj->getClass(runtime));\n\n  // Fast case: Check the cache.\n  MutableHandle<BigStorage> arr(runtime, clazz->getForInCache(runtime));\n  if (arr) {\n    beginIndex = matchesProtoClasses(runtime, obj, arr);\n    if (beginIndex) {\n      // Cache is valid for this object, so use it.\n      endIndex = arr->size();\n      return arr;\n    }\n    // Invalid for this object. We choose to clear the cache since the\n    // changes to the prototype chain probably affect other objects too.\n    clazz->clearForInCache(runtime);\n    // Clear arr to slightly reduce risk of OOM from allocation below.\n    arr = nullptr;\n  }\n\n  // Slow case: Build the array of properties.\n  auto ownPropEstimate = clazz->getNumProperties();\n  auto arrRes = obj->shouldCacheForIn(runtime)\n      ? BigStorage::createLongLived(runtime, ownPropEstimate)\n      : BigStorage::create(runtime, ownPropEstimate);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  arr = std::move(*arrRes);\n  if (setProtoClasses(runtime, obj, arr) == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  beginIndex = arr->size();\n  // If obj or any of its prototypes are unsuitable for caching, then\n  // beginIndex is 0 and we return an array with only the property names.\n  bool canCache = beginIndex;\n  auto end = appendAllPropertyNames(obj, runtime, arr, beginIndex);\n  if (end == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  endIndex = *end;\n  // Avoid degenerate memory explosion: if > 75% of the array is properties\n  // or classes from prototypes, then don't cache it.\n  const bool tooMuchProto = *end / 4 > ownPropEstimate;\n  if (canCache && !tooMuchProto) {\n    assert(beginIndex > 0 && \"cached array must start with proto classes\");\n#ifdef HERMES_SLOW_DEBUG\n    assert(beginIndex == matchesProtoClasses(runtime, obj, arr) && \"matches\");\n#endif\n    clazz->setForInCache(*arr, runtime);\n  }\n  return arr;\n}\n\n//===----------------------------------------------------------------------===//\n// class PropertyAccessor\n\nVTable PropertyAccessor::vt{CellKind::PropertyAccessorKind,\n                            cellSize<PropertyAccessor>()};\n\nvoid PropertyAccessorBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  const auto *self = static_cast<const PropertyAccessor *>(cell);\n  mb.addField(\"getter\", &self->getter);\n  mb.addField(\"setter\", &self->setter);\n}\n\n#ifdef HERMESVM_SERIALIZE\nPropertyAccessor::PropertyAccessor(Deserializer &d)\n    : GCCell(&d.getRuntime()->getHeap(), &vt) {\n  d.readRelocation(&getter, RelocationKind::GCPointer);\n  d.readRelocation(&setter, RelocationKind::GCPointer);\n}\n\nvoid PropertyAccessorSerialize(Serializer &s, const GCCell *cell) {\n  auto *self = vmcast<const PropertyAccessor>(cell);\n  s.writeRelocation(self->getter.get(s.getRuntime()));\n  s.writeRelocation(self->setter.get(s.getRuntime()));\n  s.endObject(cell);\n}\n\nvoid PropertyAccessorDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::PropertyAccessorKind && \"Expected PropertyAccessor\");\n  void *mem = d.getRuntime()->alloc(cellSize<PropertyAccessor>());\n  auto *cell = new (mem) PropertyAccessor(d);\n  d.endObject(cell);\n}\n#endif\n\nCallResult<HermesValue> PropertyAccessor::create(\n    Runtime *runtime,\n    Handle<Callable> getter,\n    Handle<Callable> setter) {\n  void *mem = runtime->alloc(cellSize<PropertyAccessor>());\n  return HermesValue::encodeObjectValue(\n      new (mem) PropertyAccessor(runtime, *getter, *setter));\n}\n\n} // namespace vm\n} // namespace hermes\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes -Xhermes-internal-test-methods -Xes6-proxy -non-strict -O -target=HBC %s | %FileCheck --match-full-lines %s\n\nlet isStrictMode = (function() { return this === undefined; })();\n\nfunction betterToString(value) {\n  if (Array.isArray(value)) {\n    return('[' +\n           ((typeof HermesInternal === 'object' && HermesInternal.isProxy(value))\n            ? \"Proxy:\" : \"\") +\n           value.map(betterToString).join(',') +\n           ']');\n  } else if (typeof HermesInternal === 'object' && HermesInternal.isProxy(value)) {\n    return '[Proxy]';\n  } else {\n    // This works reasonably if value is a symbol.\n    return String(value);\n  }\n}\n\n// This has a similar API to the Node.js assert object.\nlet assert = {\n  _isEqual: function(a, b) {\n    // Remember to check for NaN which does not compare as equal with itself.\n    return a === b || (Number.isNaN(a) && Number.isNaN(b));\n  },\n  equal: function(actual, expected, msg) {\n    if (!assert._isEqual(actual, expected)) {\n      assert.fail(\n        (msg ? msg + ' -- ' : '') +\n          'Not equal: actual <' +\n          betterToString(actual) +\n          '>, and expected <' +\n          betterToString(expected) +\n          '>',\n      );\n    }\n  },\n  _isArrayEqual: function(a, b) {\n    if (a.length !== b.length)\n      return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!assert._isEqual(a[i], b[i]))\n        return false;\n    }\n    return true;\n  },\n  arrayEqual: function(actual, expected, msg) {\n    if (!assert._isArrayEqual(actual, expected)) {\n      assert.fail(\n        (msg ? msg + ' -- ' : '') +\n          'Array not equal: actual <' +\n          betterToString(actual) +\n          '>, and expected <' +\n          betterToString(expected) +\n          '>',\n      );\n    }\n  },\n  deepEqual: function(actual, expected, msg) {\n    if (Array.isArray(actual)) {\n      msg = (msg ? msg + ' -- ' : '');\n      assert.equal(Array.isArray(expected), true, msg + \"length\");\n      assert.equal(actual.length, expected.length, msg + \"length\");\n      for (let i = 0; i < actual.length; i++) {\n        assert.deepEqual(actual[i], expected[i], \"values\");\n      }\n      assert.deepEqual(Object.getPrototypeOf(actual),\n                       Object.getPrototypeOf(expected),\n                       msg + \"prototype\");\n      return;\n    }\n    if (typeof actual === 'object') {\n      assert.equal(typeof expected, 'object', msg);\n      if (actual === null) {\n        assert.equal(expected, null, msg);\n        return;\n      }\n      assert.notEqual(expected, null, msg);\n      msg = (msg ? msg + ' -- ' : '');\n      assert.arrayEqual(Object.getOwnPropertyNames(actual).sort(),\n                        Object.getOwnPropertyNames(expected).sort(),\n                        msg + \"names\");\n      assert.arrayEqual(Object.getOwnPropertySymbols(actual),\n                        Object.getOwnPropertySymbols(expected),\n                        msg + \"symbols\");\n\n      for (p of Object.getOwnPropertyNames(expected)) {\n        assert.deepEqual(actual[p], expected[p],\n                         msg + \"property \" + betterToString(p));\n      }\n      for (p of Object.getOwnPropertySymbols(expected)) {\n        assert.deepEqual(actual[p], expected[p],\n                         msg + \"property \" + betterToString(p));\n      }\n      assert.deepEqual(Object.getPrototypeOf(actual),\n                       Object.getPrototypeOf(expected),\n                       msg);\n      return;\n    }\n    assert.equal(actual, expected, msg);\n  },\n  notEqual: function(actual, expected, msg) {\n    if (assert._isEqual(actual, expected)) {\n      assert.fail(\n        (msg ? msg + ' -- ' : '') +\n          'Equal: actual <' +\n          betterToString(actual) +\n          '>, and expected <' +\n          betterToString(expected) +\n          '>',\n      );\n    }\n  },\n  ok: function(value, msg) {\n    assert.equal(!!value, true, msg);\n  },\n  throws: function(block, error, msg) {\n    try {\n      block();\n    } catch (e) {\n      assert.equal(e.constructor, error, e.message + ' ' + msg);\n      return;\n    }\n    // Can't put fail inside the try because it will catch the AssertionError.\n    assert.fail((msg ? msg + ' -- ' : '') + 'Failed to throw');\n  },\n  fail: function(msg) {\n    throw new Error('AssertionError: ' + (msg ? msg : 'Failed'));\n  },\n};\n\nvar traps = [];\nvar currentProxy = undefined;\n\nfunction trapReturns(trapName, checkArgs, ret, target) {\n  let handler = {};\n  let proxy = new Proxy(target || {}, handler);\n  handler[trapName] = function trap(...trapArgs) {\n    print(trapName + ' trap (returns)');\n    traps.push(trapName);\n    assert.equal(this, handler);\n    assert.equal(trapArgs[0], target);\n    checkArgs(_ => trapArgs.slice(1));\n    return ret;\n  };\n  return proxy;\n}\n\nfunction TrapError(message) {\n  this.message = message || '';\n}\n\nTrapError.prototype.toString = function () {\n  return 'TrapError: ' + this.message;\n};\n\nfunction trapThrows(trap) {\n  function throwTarget() {}\n  return new Proxy(throwTarget, {\n    [trap]: function() {\n      print(trap + ' trap (throws)');\n      traps.push(trap);\n      throw new TrapError(trap);\n    }\n  });\n}\n\nfunction checkValue(value) {\n  return function checkValue(func, msg) {\n    assert.equal(func(), value, msg);\n  };\n}\n\nfunction checkArray(arr, alter = _ => _) {\n  return function checkArray(func, msg) {\n    assert.arrayEqual(alter(func()), arr, msg);\n  };\n}\n\nfunction checkDeep(expected) {\n  return function checkDeep(func, msg) {\n    assert.deepEqual(func(), expected, msg);\n  }\n}\n\nfunction checkElements(...checkers) {\n  return function checkElements(func, msg) {\n    let actual = func();\n    assert.equal(actual.length, checkers.length);\n    for (let i = 0; i < actual.length; ++i) {\n      checkers[i](_ => actual[i], msg);\n    }\n  };\n}\n\nfunction checkDesc(expected) {\n  return function checkDesc(func, msg) {\n    let actual = func();\n    if (expected === undefined && actual == undefined) {\n      return;\n    }\n    assert.notEqual(expected, undefined);\n    assert.notEqual(actual, undefined);\n    for (let p of ['configurable', 'enumerable', 'value', 'writable', 'get', 'set']) {\n      assert.equal(expected[p], actual[p], msg ? (msg + ' ' + p) : 'for ' + p);\n    }\n  };\n}\n\nfunction checkThrows(ex) {\n  return function checkThrows(func, msg) {\n    assert.throws(func, ex, msg);\n  };\n}\n\nfunction checkIf(pred) {\n  return function checkIf(func, msg) {\n    assert.equal(pred(func()), true, msg);\n  };\n}\n\nfunction checkStrictValue(value) {\n  if (isStrictMode) {\n    return checkThrows(TypeError);\n  } else {\n    return checkValue(value);\n  }\n}\n\nfunction checkUnimplemented(ex) {\n  return ((typeof HermesInternal === 'object')\n          ? checkThrows(TypeError)\n          : checkDeep(ex));\n}\n\nfunction checkTraps(arr) {\n  return function checkTraps(func, msg) {\n    assert.arrayEqual(traps, arr, msg);\n  };\n}\n\nfunction checkUnimplementedTraps(ex) {\n  return ((typeof HermesInternal === 'object')\n          ? checkArray([])\n          : checkArray(ex));\n}\n\nfunction checkProxy() {\n  return function checkProxy(func, msg) {\n    assert.equal(func(), currentProxy, msg);\n  };\n}\n\nfunction checkBoxed(value) {\n  return function checkBoxed(func, msg) {\n    let actual = func();\n    if (actual.constructor === Number) {\n      assert.equal(Number(actual), value);\n    } else if (actual.constructor === Boolean) {\n      assert.equal(Boolean(actual), value);\n    } else {\n      assert.equal(actual, value);\n    }\n  }\n}\n\nfunction checkAll(...funcs) {\n  return function checkAll(func, msg) {\n    let actual = func();\n    for (let f of funcs) {\n      f(_ => actual, msg);\n    }\n  };\n}\n\n// This function is used to describe a battery of tests for a\n// particular trap.  For each test:\n// * a target is created by calling targetFactory\n// * a Proxy is created using that target\n// * func is called on the proxy and target\n// * the result of calling the function is checked.\n//\n// a checker is a function which takes a function to call, calls it,\n// and asserts if it did something unexpected.  The checker can check\n// the return value, if an exception is thrown, etc.  The Function to\n// call calls func on an appropriately constructed proxy as below.\n//\n// This happens several times.\n// A. the noTrapChecker is called on a Proxy with no traps.\n// B. for each of a list of [value, checker], the checker is called\n//   on a Proxy with a trap which returns value.  The first argument to the trap\n//   is checked against target, and the rest with checkArgs.\n// C. a trap which throws a TrapError is checked that the exception\n//   makes it out to the caller.\n// D. the noTrapChecker is called on a revocable Proxy with no traps.\n//   The proxy is revoked, and the function is called again, expecting\n//   a TypeError.\n//\n// For each test, there is also a check that the expected trap was\n// called.\nfunction proxyTests(trap, func, targetFactory, noTrapChecker, checkArgs,\n                    trapCalls) {\n  // A.\n  let target = targetFactory();\n  traps = [];\n  currentProxy = new Proxy(target, {});\n  try {\n    noTrapChecker(_ => func(currentProxy, target),\n                  'for noTrap');\n  } catch (e) {\n    e.message += ' for noTrap';\n    throw e;\n  }\n  assert.arrayEqual(traps, [], 'for noTrap');\n  // B.\n  let i = 0;\n  for (let [trapRet, checker, trapChecker] of trapCalls) {\n    traps = [];\n    let target = targetFactory();\n    let msg = 'for trapRet ' + i + ' ' + betterToString(trapRet);\n    try {\n      currentProxy = trapReturns(trap, checkArgs, trapRet, target);\n      checker(_ => func(currentProxy, target), msg);\n    } catch (e) {\n      e.message += ' ' + msg;\n      throw e;\n    }\n    if (trapChecker) {\n      trapChecker(_ => traps, msg);\n    } else {\n      assert.arrayEqual(traps, [trap], msg);\n    }\n    ++i;\n  }\n  // C.\n  target = targetFactory();\n  traps = [];\n  currentProxy = trapThrows(trap);\n  checkThrows(TrapError)(_ => func(currentProxy, target),\n                         'for trapThrows');\n  assert.arrayEqual(traps, [trap], 'for trapThrows');\n  // D.\n  target = targetFactory();\n  traps = [];\n  let pr = Proxy.revocable(target, {});\n  currentProxy = pr.proxy;\n  try {\n    noTrapChecker(_ => func(currentProxy, target),\n                  'for revocable');\n  } catch (e) {\n    e.message += ' for revocable';\n    throw e;\n  }\n  pr.revoke();\n   checkThrows(TypeError)(\n    _ => func(currentProxy, target),\n    ' for revoked');\n  assert.arrayEqual(traps, [], 'for revoked');\n  traps = [];\n  currentProxy = undefined;\n}\n\nfunction restorePrototype(obj, func) {\n  let save = Object.getPrototypeOf(obj);\n  func();\n  Object.setPrototypeOf(obj, save);\n}\n\nlet base = {};\nlet obj = {a:1};\n\n// end helpers and standard values\n\nprint('getPrototypeOf');\n// CHECK-LABEL: getPrototypeOf\n\n// extensible target with non-null parent\nfor (let func of [Object.getPrototypeOf, proxy => proxy.__proto__]) {\n  proxyTests(\n    // This is the trap we are testing.\n    'getPrototypeOf',\n    // This is the function\n    func,\n    _ => Object.create(base),\n    checkValue(base),\n    checkArray([]),\n    [[base, checkValue(base)],\n     [obj, checkValue(obj)],\n     [17, checkThrows(TypeError)],\n     [null, checkValue(null)]]);\n}\n\nproxyTests(\n  'getPrototypeOf',\n  proxy => base.isPrototypeOf(proxy),\n  _ => Object.create(base),\n  checkValue(true),\n  checkArray([]),\n  [[base, checkValue(true)],\n   [obj, checkValue(false)],\n   [17, checkThrows(TypeError)],\n   [null, checkValue(false)]]);\n\n// non-extensible target with non-null parent\nproxyTests(\n  'getPrototypeOf',\n  Object.getPrototypeOf,\n  _ => Object.preventExtensions(Object.create(base)),\n  checkValue(base),\n  checkArray([]),\n  [[base, checkValue(base)],\n   [obj, checkThrows(TypeError)],\n   [17, checkThrows(TypeError)],\n   [null, checkThrows(TypeError)]]);\n\n// extensible target with null parent\nproxyTests(\n  'getPrototypeOf',\n  Object.getPrototypeOf,\n  _ => Object.create(null),\n  checkValue(null),\n  checkArray([]),\n  [[base, checkValue(base)],\n   [obj, checkValue(obj)],\n   [17, checkThrows(TypeError)],\n   [null, checkValue(null)]]);\n\n// non-extensible target with null parent\nproxyTests(\n  'getPrototypeOf',\n  Object.getPrototypeOf,\n  _ => Object.preventExtensions(Object.create(null)),\n  checkValue(null),\n  checkArray([]),\n  [[base, checkThrows(TypeError)],\n   [obj, checkThrows(TypeError)],\n   [17, checkThrows(TypeError)],\n   [null, checkValue(null)]]);\n\nlet ctorProto = {};\nfunction Ctor() { return this; };\nCtor.prototype = ctorProto;\nlet ctorObj = new Ctor();\n\nproxyTests(\n  'getPrototypeOf',\n  proxy => proxy instanceof Ctor,\n  _ => ctorObj,\n  checkValue(true),\n  checkArray([]),\n  [[ctorObj, checkValue(true)],\n   [ctorProto, checkValue(true)],\n   [{}, checkValue(false)],\n   [17, checkThrows(TypeError)]]);\n\nprint('setPrototypeOf');\n// CHECK-LABEL: setPrototypeOf\n\nfor (let func of [proxy => assert.equal(Object.setPrototypeOf(proxy, base), proxy),\n                  proxy => proxy.__proto__ = base]) {\n  proxyTests(\n    'setPrototypeOf',\n    function (proxy, target) {\n      func(proxy);\n      let a = Object.getPrototypeOf(target);\n      let b = Object.getPrototypeOf(proxy);\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({}),\n    checkValue(base),\n    checkArray([base]),\n    [[true, checkValue(Object.prototype)],\n     [false, checkThrows(TypeError)]]);\n}\n\nprint('isExtensible');\n// CHECK-LABEL: isExtensible\n\n// extensible object\nproxyTests(\n  'isExtensible',\n  Object.isExtensible,\n  _ => ({}),\n  checkValue(true),\n  checkArray([]),\n  [[true, checkValue(true)],\n   [false, checkThrows(TypeError)]]);\n\n// non-extensible object\nproxyTests(\n  'isExtensible',\n  Object.isExtensible,\n  _ => Object.preventExtensions({}),\n  checkValue(false),\n  checkArray([]),\n  [[false, checkValue(false)],\n   [true, checkThrows(TypeError)]]);\n\nprint('preventExtensions');\n// CHECK-LABEL: preventExtensions\n\n// extensible object\nproxyTests(\n  'preventExtensions',\n  function (proxy, target) {\n    assert.equal(Object.preventExtensions(proxy), proxy);\n    let a = Object.isExtensible(target);\n    let b = Object.isExtensible(proxy);\n    assert.equal(a, b);\n    return !a;\n  },\n  _ => ({}),\n  checkValue(true),\n  checkArray([]),\n  [[true, checkThrows(TypeError)],\n   [false, checkThrows(TypeError)]]);\n\n// non-extensible object\nproxyTests(\n  'preventExtensions',\n  function (proxy, target) {\n    assert.equal(Object.preventExtensions(proxy), proxy);\n    let a = Object.isExtensible(target);\n    let b = Object.isExtensible(proxy);\n    assert.equal(a, b);\n    return !a;\n  },\n  _ => Object.preventExtensions({}),\n  checkValue(true),\n  checkArray([]),\n  [[true, checkValue(true)],\n   [false, checkThrows(TypeError)]]);\n\nprint('getOwnPropertyDescriptor');\n// CHECK-LABEL: getOwnPropertyDescriptor\n\n// writable value prop\nfunction getter() { return 'foo'; }\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => Object.getOwnPropertyDescriptor(proxy, 'prop'),\n  _ => ({prop: 1}),\n  checkDesc({configurable: true, enumerable: true, writable: true, value: 1}),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: true, value: 3},\n    checkDesc({configurable: true, enumerable: true, writable: true, value: 3})],\n   [{configurable: true, enumerable: true, writable: false, value: 4},\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 4})],\n   [{configurable: false, enumerable: true, writable: false, value: 5},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, get: getter},\n    checkDesc({configurable: true, enumerable: true, get: getter})]]);\n\n// writable accessor prop\nfunction getfoo() { return 'foo'; }\nfunction getbar() { return 'bar'; }\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => Object.getOwnPropertyDescriptor(proxy, 'prop'),\n  _ => Object.create(Object.prototype,\n                     {prop: {configurable: true, enumerable: true, get: getfoo}}),\n  checkDesc({configurable: true, enumerable: true, get: getfoo}),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: true, value: 3},\n    checkDesc({configurable: true, enumerable: true, writable: true, value: 3})],\n   [{configurable: true, enumerable: true, writable: false, value: 4},\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 4})],\n   [{configurable: false, enumerable: true, writable: false, value: 5},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, get: getbar},\n    checkDesc({configurable: true, enumerable: true, get: getbar})]]);\n\n// non-configurable, non-writable value prop\nproxyTests(\n  'getOwnPropertyDescriptor',\n  function (proxy) {\n    return Object.getOwnPropertyDescriptor(proxy, 'prop');\n  },\n  _ => Object.freeze({prop: 1}),\n  checkDesc({configurable: false, enumerable: true, writable: false, value: 1}),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: true, value: 1},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: false, value: 1},\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: false, value: 4},\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, get: getter},\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: false, value: 1},\n    checkDesc({configurable: false, enumerable: true, writable: false, value: 1})]]);\n\n// no prop\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => Object.getOwnPropertyDescriptor(proxy, 'prop'),\n  _ => ({}),\n  checkValue(undefined),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: true, value: 1},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: false, value: 2},\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 2})],\n   [{configurable: true, enumerable: true, writable: true, value: 3},\n    checkDesc({configurable: true, enumerable: true, writable: true, value: 3})],\n   [{configurable: true, enumerable: true, get: getter},\n    checkDesc({configurable: true, enumerable: true, get: getter})]]);\n\n// hasOwnProperty true.  doesn't call 'has' trap\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.hasOwnProperty('prop'),\n  _ => ({prop: 1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(true)],\n   [undefined,\n    checkValue(false)]]);\n\n// hasOwnProperty false.  doesn't call 'has' trap\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.hasOwnProperty('prop'),\n  _ => ({}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(true)],\n   [undefined,\n    checkValue(false)]]);\n\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.propertyIsEnumerable('prop'),\n  _ => ({}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(false)],\n   [undefined,\n    checkValue(false)]]);\n\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.propertyIsEnumerable('prop'),\n  _ => Object.create(Object.prototype,\n                     {prop: {configurable: true, enumerable: false,\n                             writeable: true, value: 1}}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(false)],\n   [undefined,\n    checkValue(false)]]);\n\nfunction setfoo() {}\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.__lookupGetter__('prop'),\n  _ => Object.create(Object.prototype, {prop: {\n    configurable: true,\n    enumerable: true,\n    get: getfoo,\n  }}),\n  checkValue(getfoo),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 3},\n    checkValue(undefined)],\n   [{configurable: true, enumerable: true, get: getbar},\n    checkValue(getbar)]]);\n\n// Function.prototype.bind uses getOwnPropertyDescriptor trap and get\n// to determine length (see ES9 19.2.3.2)\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.bind(obj).length,\n  _ => function(one, two, three) {},\n  checkValue(3),\n  checkArray(['length']),\n  []);\n\n// Try above test with lazy and non-lazy functions\n\nprint('defineProperty');\n// CHECK-LABEL: defineProperty\n\n// add new property\nvar desc = {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 1,\n};\nproxyTests(\n  'defineProperty',\n  function (proxy, target) {\n    let ret = Object.defineProperty(proxy, 'prop', desc);\n    assert.equal(ret, proxy);\n    let a = Object.getOwnPropertyDescriptor(target, 'prop');\n    let b = Object.getOwnPropertyDescriptor(proxy, 'prop');\n    if (a !== undefined || b !== undefined) {\n      checkDesc(a)(_ => b);\n    }\n    return a;\n  },\n  _ => ({}),\n  checkDesc(desc),\n  checkElements(\n    checkValue('prop'),\n    checkDesc(desc)),\n  [[true, checkValue(undefined)],\n   [false, checkThrows(TypeError)]]);\n\n// modify existing property\nproxyTests(\n  'defineProperty',\n  function (proxy, target) {\n    let ret = Object.defineProperty(proxy, 'prop', desc);\n    assert.equal(ret, proxy);\n    let a = Object.getOwnPropertyDescriptor(target, 'prop');\n    let b = Object.getOwnPropertyDescriptor(proxy, 'prop');\n    if (a !== undefined || b !== undefined) {\n      checkDesc(a)(_ => b);\n    }\n    return a;\n  },\n  _ => Object.create(Object.prototype, {prop: {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n    value: 2,\n  }}),\n  checkDesc(desc),\n  checkElements(\n    checkValue('prop'),\n    checkDesc(desc)),\n  [[true,\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 2})],\n   [false,\n    checkThrows(TypeError)]]);\n\n// proxy validation failure\nvar desc = {\n  configurable: false,\n  enumerable: true,\n  writable: true,\n  value: 1,\n};\nproxyTests(\n  'defineProperty',\n  function (proxy, target) {\n    let ret = Object.defineProperty(proxy, 'prop', desc);\n    assert.equal(ret, proxy);\n    let a = Object.getOwnPropertyDescriptor(target, 'prop');\n    let b = Object.getOwnPropertyDescriptor(proxy, 'prop');\n    checkDesc(a)(_ => b);\n    return a;\n  },\n  _ => Object.create(Object.prototype, {prop: {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n    value: 2,\n  }}),\n  checkDesc(desc),\n  checkElements(\n    checkValue('prop'),\n    checkDesc(desc)),\n  [[true,\n    checkThrows(TypeError)],\n   [false,\n    checkThrows(TypeError)]]);\n\nprint('has');\n// CHECK-LABEL: has\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => Object.preventExtensions({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkThrows(TypeError)],\n   [true, checkValue(true)]]);\n\nprint('get');\n// CHECK-LABEL: get\n\n// Using computedProp as a key should guarantee 'getComputed' behavior.\nvar computedProp = 'prop';\nfor (let func of [proxy => proxy.prop,\n                  proxy => proxy[computedProp]]) {\n  // prop does not exist\n  proxyTests(\n    'get',\n    func,\n    _ => ({}),\n    checkValue(undefined),\n    checkElements(\n      checkValue('prop'),\n      checkProxy()),\n    [[false, checkValue(false)],\n     ['hello', checkValue('hello')]]);\n\n  // prop exists\n  proxyTests(\n    'get',\n    func,\n    _ => ({prop:1}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkProxy()),\n    [[false, checkValue(false)],\n     ['hello', checkValue('hello')]]);\n\n  // validation fail\n  proxyTests(\n    'get',\n    func,\n    _ => Object.create(\n      Object.prototype,\n      {prop: {configurable: false, enumerable: true, writable: false, value: 1}}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkProxy()),\n    [[1, checkValue(1)],\n     ['hello', checkThrows(TypeError)]]);\n}\n\n// parent is proxy\nvar child = {};\nproxyTests(\n  'get',\n  function (proxy) {\n    Object.setPrototypeOf(child, proxy);\n    return child.prop;\n  },\n  _ => ({prop:1}),\n  checkValue(1),\n  checkElements(\n    checkValue('prop'),\n    checkValue(child)),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]);\n\n// numeric prop (trap gets a string)\nproxyTests(\n  'get',\n  proxy => proxy[3],\n  _ => [1,2,3,4,5],\n  checkValue(4),\n  checkElements(\n    checkValue(\"3\"),\n    checkProxy()),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]);\n\n// symbol prop\nproxyTests(\n  'get',\n  proxy => proxy[Symbol.for('symprop')],\n  _ => ({[Symbol.for('symprop')]:1}),\n  checkValue(1),\n  checkElements(\n    checkValue(Symbol.for('symprop')),\n    checkProxy()),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]);\n\n// transient get\nrestorePrototype(Number.prototype, _ => proxyTests(\n  'get',\n  function (proxy, target) {\n    Object.setPrototypeOf(Number.prototype, proxy);\n    return (5).prop;\n  },\n  _ => ({}),\n  checkValue(undefined),\n  checkArray(['prop', 5]),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]));\n\n// transient get has prop\nrestorePrototype(Number.prototype, _ => proxyTests(\n  'get',\n  function (proxy, target) {\n    Object.setPrototypeOf(Number.prototype, proxy);\n    return (5).prop;\n  },\n  _ => ({prop:1}),\n  checkValue(1),\n  checkArray(['prop', 5]),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]));\n\nprint('set');\n// CHECK-LABEL: set\n\nfor (let func of [proxy => proxy.prop = 1,\n                  proxy => proxy[computedProp] = 1]) {\n  // set new property\n  proxyTests(\n    'set',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkValue(1),\n      checkProxy()),\n    [[false, checkStrictValue(undefined)],\n     [true, checkValue(undefined)]]);\n\n  // overwrite existing property\n  proxyTests(\n    'set',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({prop:2}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkValue(1),\n      checkProxy()),\n    [[false, checkStrictValue(2)],\n     [true, checkValue(2)]]);\n\n  // validation fail\n  proxyTests(\n    'set',\n    func,\n    _ => Object.create(\n      Object.prototype,\n      {prop: {configurable: false, enumerable: true, writable: false, value: 2}}),\n    checkStrictValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkValue(1),\n      checkProxy()),\n    [[false, checkStrictValue(1)],\n     [true, checkThrows(TypeError)]]);\n}\n\n// parent is proxy\nvar child = {};\nproxyTests(\n  'set',\n  function (proxy) {\n    // child gets reused, so clean it up, if we modified it.\n    delete child.prop;\n    Object.setPrototypeOf(child, proxy);\n    child.prop = 2;\n    return child.prop;\n  },\n  _ => ({prop:1}),\n  checkValue(2),\n  checkElements(\n    checkValue('prop'),\n    checkValue(2),\n    checkValue(child)),\n  [[false, checkStrictValue(1)],\n   [true, checkValue(1)]]);\n\n// symbol prop\nproxyTests(\n  'set',\n  function (proxy, target) {\n    proxy[Symbol.for('symprop')] = 1;\n    let a = target[Symbol.for('symprop')];\n    let b = proxy[Symbol.for('symprop')];\n    assert.equal(a, b);\n    return a;\n  },\n  _ => ({[Symbol.for('symprop')]:2}),\n  checkValue(1),\n  checkElements(\n    checkValue(Symbol.for('symprop')),\n    checkValue(1),\n    checkProxy()),\n  [[false, checkStrictValue(2)],\n   [true, checkValue(2)]]);\n\n// transient set\nrestorePrototype(Number.prototype, _ => proxyTests(\n  'set',\n  function (proxy, target) {\n    Object.setPrototypeOf(Number.prototype, proxy);\n    (5).prop = 10;\n  },\n  _ => ({}),\n  checkStrictValue(undefined),\n  checkArray(['prop', 10, 5]),\n  [[false, checkStrictValue(undefined)],\n   [true, checkValue(undefined)]]));\n\nprint('deleteProperty');\n// CHECK-LABEL: deleteProperty\n\nfor (let func of [proxy => delete proxy.prop,\n                  proxy => delete proxy[computedProp]]) {\n  // delete non-existent property\n  proxyTests(\n    'deleteProperty',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({}),\n    checkValue(undefined),\n    checkArray(['prop']),\n    [[false, checkStrictValue(undefined)],\n     [true, checkValue(undefined)]]);\n\n  // delete existing property\n  proxyTests(\n    'deleteProperty',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({prop:2}),\n    checkValue(undefined),\n    checkArray(['prop']),\n    [[false, checkStrictValue(2)],\n     [true, checkValue(2)]]);\n\n  // validation fail\n  proxyTests(\n    'deleteProperty',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => Object.create(\n      Object.prototype,\n      {prop: {configurable: false, enumerable: true, writable: false, value: 2}}),\n    checkStrictValue(2),\n    checkArray(['prop']),\n    [[false, checkStrictValue(2)],\n     [true, checkThrows(TypeError)]]);\n}\n\nprint('ownKeys');\n// CHECK-LABEL: ownKeys\n\nproxyTests(\n  'ownKeys',\n  Object.getOwnPropertyNames,\n  _ => ({a:1, b:2, [Symbol.for('c')]:3, [Symbol.for('d')]:4}),\n  checkArray(['a', 'b']),\n  checkArray([]),\n  [[['e', Symbol.for('f'), 'g', Symbol.for('h')],\n    checkArray(['e', 'g'])]]);\n\nproxyTests(\n  'ownKeys',\n  Object.getOwnPropertySymbols,\n  _ => ({a:1, b:2, [Symbol.for('c')]:3, [Symbol.for('d')]:4}),\n  checkArray([Symbol.for('c'), Symbol.for('d')]),\n  checkArray([]),\n  [[['e', Symbol.for('f'), 'g', Symbol.for('h')],\n    checkArray([Symbol.for('f'), Symbol.for('h')])]]);\n\n// validation fail\nproxyTests(\n  'ownKeys',\n  Object.getOwnPropertyNames,\n  _ => Object.preventExtensions({a:1, b:2}),\n  checkArray(['a', 'b']),\n  checkArray([]),\n  [[['a', 'b'],\n    checkArray(['a', 'b'])],\n   [['e', 'g'],\n    checkThrows(TypeError)]]);\n\nprint('apply');\n// CHECK-LABEL: apply\n\n// call with no this specified\nproxyTests(\n  'apply',\n  proxy => proxy(1),\n  _ => function (a) { return [this, a + 2]; },\n  checkArray([isStrictMode ? undefined : globalThis, 3]),\n  checkDeep([undefined, [1]]),\n  [[4, checkValue(4)],\n   ['hello', checkValue('hello')]]);\n\n// call throws exception\nproxyTests(\n  'apply',\n  proxy => proxy(1),\n  _ => function (a) { throw new Error(\"fail\"); },\n  checkThrows(Error),\n  checkDeep([undefined, [1]]),\n  [])\n\n// specify undefined, null this\nfor (let testThis of [undefined, null]) {\n  for (let func of [proxy => proxy.bind(testThis)(1),\n                    proxy => proxy.call(testThis, 1)]) {\n    proxyTests(\n      'apply',\n      func,\n      _ => function (a) { return [this, a + 2]; },\n      checkArray([isStrictMode ? testThis : globalThis, 3]),\n      checkElements(\n        checkValue(testThis),\n        checkArray([1])),\n      [[4, checkValue(4)],\n       ['hello', checkValue('hello')]]);\n  }\n}\n\n// specify some this objects\nfor (let testThis of [obj, [1,2,3], _ => 4]) {\n  for (let func of [proxy => proxy.bind(testThis)(1),\n                    proxy => proxy.call(testThis, 1)]) {\n    proxyTests(\n      'apply',\n      func,\n      _ => function (a) { return [this, a + 2]; },\n      checkArray([testThis, 3]),\n      checkElements(\n        checkValue(testThis),\n        checkArray([1])),\n      [[4, checkValue(4)],\n       ['hello', checkValue('hello')]]);\n  }\n}\n\n// Specify some this primitives (they get boxed)\nfor (let testThis of [5, true]) {\n  for (let func of [proxy => proxy.bind(testThis)(1),\n                    proxy => proxy.call(testThis, 1)]) {\n    proxyTests(\n      'apply',\n      func,\n      _ => function (a) { return [this, a + 2]; },\n      checkElements(\n        checkBoxed(testThis),\n        checkValue(3)),\n      checkElements(\n        checkValue(testThis),\n        checkArray([1])),\n      [[4, checkValue(4)],\n       ['hello', checkValue('hello')]]);\n  }\n}\n\nprint('construct');\n// CHECK-LABEL: construct\n\nfunction testTargetCtor (a) { this.a = a; return this; }\nfunction testCtor1 (a) { return this; }\nfunction testCtor2 (a) { this.a = 2; return this; }\nvar x = new Ctor();\nprint(x, x.constructor);\nproxyTests(\n  'construct',\n  function (proxy) {\n    let o = new proxy(1);\n    return [o.constructor, o.a];\n  },\n  _ => testTargetCtor,\n  checkArray([testTargetCtor, 1]),\n  checkElements(\n    checkArray([1]),\n    checkProxy()),\n  [[new testCtor1(),\n    checkArray([testCtor1, undefined])],\n   [new testCtor2(),\n    checkArray([testCtor2, 2])],\n   ['hello',\n    checkThrows(TypeError)]]);\n\n// test target is not a ctor.  Note that the trap isn't called, so\n// proxyTests's assumptions would fail.\nvar p = new Proxy(_ => _, {});\nassert.throws(_ => new p(), TypeError);\nvar p = new Proxy(_ => _, { construct() { assert.fail(\"trap called\"); }});\nassert.throws(_ => new p(), TypeError);\n\nprint('ProxyCreate');\n// CHECK-LABEL: ProxyCreate\n\nfor (let val of [undefined, null, true, 17, \"string\"]) {\n  assert.throws(_ => new Proxy(val, {}), TypeError);\n  assert.throws(_ => new Proxy({}, val), TypeError);\n}\n\n// Check that adding slots to the revoker function works as expected.\n\nvar pr = Proxy.revocable({}, {});\npr.revoke.prop = 1;\nassert.equal(pr.revoke.prop, 1);\npr.revoke();\nassert.equal(pr.revoke.prop, 1);\n\nassert.throws(_=> pr.proxy.foo, TypeError);\nassert.ok(_=> new Proxy(pr.proxy, {}), \"ProxyCreate using revoked proxies should be allowed.\");\nassert.ok(_=> new Proxy({}, pr.proxy), \"ProxyCreate using revoked proxies should be allowed.\");\n\nprint('Array.isArray');\n// CHECK-LABEL: Array.isArray\n\nvar a = [];\nvar ap = new Proxy(a, {});\nvar app = new Proxy(ap, {});\nassert.equal(Array.isArray(app), true);\n\nprint('multitraps');\n// CHECK-LABEL: multitraps\n\nfunction spyTraps(output) {\n  return {\n    has(target, key) {\n      output.push(\"has:\" + betterToString(key));\n      print(output[output.length - 1]);\n      return key in target;\n    },\n    get(target, key) {\n      output.push(\"get:\" + betterToString(key));\n      print(output[output.length - 1]);\n      return target[key];\n    },\n    set(target, key, value) {\n      output.push(\"set:\" + betterToString(key));\n      print(output[output.length - 1]);\n      target[key] = value;\n      return true;\n    },\n    deleteProperty(target, key) {\n      output.push(\"delete:\" + betterToString(key));\n      print(output[output.length - 1]);\n      delete target[key];\n      return true;\n    },\n    ownKeys(target) {\n      output.push(\"ownKeys\");\n      print(output[output.length - 1]);\n      return Object.getOwnPropertyNames(target).concat(\n        Object.getOwnPropertySymbols(target));\n    },\n    getOwnPropertyDescriptor(target, key) {\n      output.push(\"getOwnPropertyDescriptor:\" + betterToString(key));\n      print(output[output.length - 1]);\n      return Object.getOwnPropertyDescriptor(target, key);\n    },\n  };\n};\n\nvar sourceParent = Object.defineProperties({}, {\n  pa:{value:11, writable:true, configurable:true, enumerable: true},\n  pb:{value:12, writable:true, configurable:true, enumerable: false},\n  [Symbol.for('pc')]:{value:13, writable:true, configurable:true, enumerable: true},\n  [Symbol.for('pd')]:{value:14, writable:true, configurable:true, enumerable: false},\n});\n\nvar source = Object.create(sourceParent, {\n  ca:{value:21, writable:true, configurable:true, enumerable: true},\n  cb:{value:22, writable:true, configurable:true, enumerable: false},\n  [Symbol.for('cc')]:{value:23, writable:true, configurable:true, enumerable: true},\n  [Symbol.for('cd')]:{value:24, writable:true, configurable:true, enumerable: false},\n});\n\nvar sourceArray = [10,20,30];\n\nassert.equal(Object.getOwnPropertyNames(sourceParent).length, 2);\nassert.equal(Object.getOwnPropertySymbols(sourceParent).length, 2);\nassert.equal(Object.getOwnPropertyNames(source).length, 2);\nassert.equal(Object.getOwnPropertySymbols(source).length, 2);\n\nfunction multiTests(source, func, checkResult, checkTraps) {\n  checkResult(_ => func(source), \"for source\");\n\n  var output = [];\n  checkResult(_ => func(new Proxy(source, spyTraps(output))), \"for proxy\");\n  checkTraps(_ => output);\n}\n\n// own\n\nmultiTests(\n  source,\n  Object.getOwnPropertyDescriptors,\n  checkDeep({\n    ca:{value:21, writable:true, configurable:true, enumerable: true},\n    cb:{value:22, writable:true, configurable:true, enumerable: false},\n    [Symbol.for('cc')]:{value:23, writable:true, configurable:true, enumerable: true},\n    [Symbol.for('cd')]:{value:24, writable:true, configurable:true, enumerable: false},\n  }),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb',\n    'getOwnPropertyDescriptor:Symbol(cc)',\n    'getOwnPropertyDescriptor:Symbol(cd)']));\n\nmultiTests(\n  sourceArray,\n  Object.getOwnPropertyDescriptors,\n  checkDeep({\n    0:{value:10, writable:true, configurable:true, enumerable: true},\n    1:{value:20, writable:true, configurable:true, enumerable: true},\n    2:{value:30, writable:true, configurable:true, enumerable: true},\n    length:{value:3, writable:true, configurable:false, enumerable: false},\n  }),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'getOwnPropertyDescriptor:1',\n    'getOwnPropertyDescriptor:2',\n    'getOwnPropertyDescriptor:length']));\n\n// enumerable own\nfor (let func of [_ => Object.assign({}, _),\n                  _ => ({..._})]) {\n  multiTests(\n    source,\n    func,\n    checkDeep({ca:21, [Symbol.for('cc')]:23}),\n    checkArray(['ownKeys',\n                'getOwnPropertyDescriptor:ca',\n                'get:ca',\n                'getOwnPropertyDescriptor:cb',\n                'getOwnPropertyDescriptor:Symbol(cc)',\n                'get:Symbol(cc)',\n                'getOwnPropertyDescriptor:Symbol(cd)']));\n\n  multiTests(\n    sourceArray,\n    func,\n    checkDeep({0:10, 1:20, 2:30}),\n    checkArray(['ownKeys',\n                'getOwnPropertyDescriptor:0',\n                'get:0',\n                'getOwnPropertyDescriptor:1',\n                'get:1',\n                'getOwnPropertyDescriptor:2',\n                'get:2',\n                'getOwnPropertyDescriptor:length']));\n}\n\nvar descriptors = Object.defineProperties({}, {\n  pa: {\n    value: Object.getOwnPropertyDescriptor(sourceParent, 'pa'),\n    writable: true,\n    configurable: true,\n    enumerable: true,\n  },\n  pb: {\n    value: Object.getOwnPropertyDescriptor(sourceParent, 'pb'),\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  },\n  ca: {\n    value: Object.getOwnPropertyDescriptor(source, 'ca'),\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  },\n  cb: {\n    value: Object.getOwnPropertyDescriptor(source, 'cb'),\n    writable: true,\n    configurable: true,\n    enumerable: true,\n  },\n  x: {\n    value: \"i-am-not-a-descriptor\",\n    writable: true,\n    configurable: true,\n    enumerable: false, // and non-enumerable props aren't used descriptors\n  },\n});\n\nmultiTests(\n  descriptors,\n  descs => Object.defineProperties({}, descs),\n  checkDeep({pa: 11, cb: 22}),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:pa',\n    'get:pa',\n    'getOwnPropertyDescriptor:pb',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb',\n    'get:cb',\n    'getOwnPropertyDescriptor:x']));\n\n// enumerable strings\nmultiTests(\n  source,\n  function(obj) {\n    let keys = [];\n    for (let key in obj) {\n      keys.push(key);\n    }\n    return keys;\n  },\n  checkArray(['ca', 'pa']),\n  checkArray(['ownKeys',\n              'getOwnPropertyDescriptor:ca',\n              'getOwnPropertyDescriptor:cb'],\n             function(actual) {\n               // d8 does this.  It's weird.  I don't know why.\n               if (typeof HermesInternal !== 'object') {\n                 if (actual[actual.length - 1] === 'getOwnPropertyDescriptor:pa') {\n                   --actual.length;\n                 }\n               }\n               return actual;\n             }));\n\nmultiTests(\n  sourceArray,\n  function(obj) {\n    let keys = [];\n    for (let key in obj) {\n      keys.push(key);\n    }\n    return keys;\n  },\n  checkArray([\"0\", '1', '2']),\n  checkArray(['ownKeys',\n              'getOwnPropertyDescriptor:0',\n              'getOwnPropertyDescriptor:1',\n              'getOwnPropertyDescriptor:2',\n              'getOwnPropertyDescriptor:length']));\n\n// iteration\nmultiTests(\n  sourceArray,\n  function(iterable) {\n    let values = [];\n    for (let value of iterable) {\n      values.push(value);\n    }\n    return values;\n  },\n  checkArray([10,20,30]),\n  checkArray([\n    'get:Symbol(Symbol.iterator)',\n    'get:length',\n    'get:0',\n    'get:length',\n    'get:1',\n    'get:length',\n    'get:2',\n    'get:length']));\n\n// enumerable own strings\nmultiTests(\n  source,\n  Object.keys,\n  checkArray(['ca']),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb']));\n\nmultiTests(\n  source,\n  Object.values,\n  checkArray([21]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'get:ca',\n    'getOwnPropertyDescriptor:cb']));\n\nmultiTests(\n  source,\n  Object.entries,\n  checkDeep([['ca', 21]]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'get:ca',\n    'getOwnPropertyDescriptor:cb']));\n\nmultiTests(\n  source,\n  JSON.stringify,\n  checkValue('{\"ca\":21}'),\n  checkArray([\n    'get:toJSON',\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb',\n    'get:ca']));\n\nmultiTests(\n  sourceArray,\n  Object.keys,\n  checkArray(['0', '1', '2']),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'getOwnPropertyDescriptor:1',\n    'getOwnPropertyDescriptor:2',\n    'getOwnPropertyDescriptor:length']));\n\nmultiTests(\n  sourceArray,\n  Object.values,\n  checkArray([10, 20, 30]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'get:0',\n    'getOwnPropertyDescriptor:1',\n    'get:1',\n    'getOwnPropertyDescriptor:2',\n    'get:2',\n    'getOwnPropertyDescriptor:length']));\n\nmultiTests(\n  sourceArray,\n  Object.entries,\n  checkDeep([\n    ['0', 10],\n    ['1', 20],\n    ['2', 30],\n  ]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'get:0',\n    'getOwnPropertyDescriptor:1',\n    'get:1',\n    'getOwnPropertyDescriptor:2',\n    'get:2',\n    'getOwnPropertyDescriptor:length']));\n\nmultiTests(\n  sourceArray,\n  JSON.stringify,\n  checkValue('[10,20,30]'),\n  checkArray([\n    'get:toJSON',\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2']));\n\nmultiTests(\n  sourceArray,\n  source => [...source],\n  checkArray([10,20,30]),\n  checkArray([\n    \"get:Symbol(Symbol.iterator)\",\n    \"get:length\",\n    \"get:0\",\n    \"get:length\",\n    \"get:1\",\n    \"get:length\",\n    \"get:2\",\n    \"get:length\",\n  ]));\n\n// Spreading when [Symbol.iterator] is a proxy.\nvar spreadSource = [10,20,30];\nmultiTests(\n  {},\n  proto => {\n    spreadSource.__proto__ = proto;\n    try {\n      return [...spreadSource];\n    } catch (e) {\n      return e.name;\n    }\n  },\n  checkValue(\"TypeError\"),\n  checkArray([\"get:Symbol(Symbol.iterator)\"])\n);\n\nprint('Array.prototype');\n// CHECK-LABEL: Array.prototype\n\nvar arrayOne = [11,12];\n// mind the gap\narrayOne[3] = 13;\nvar arrayTwo = [24,25,26,27];\n\nfunction alterArrayTraps(actual) {\n  // Hermes does not yet implement ArraySpeciesCreate, so we ignore\n  // those traps in d8.\n  if (typeof HermesInternal !== 'object') {\n    return actual.filter(_ => _ !== 'get:constructor');\n  }\n  // We want to return a new array, so later calls don't append to the\n  // traps we test.\n  return actual.concat();\n}\n\nfunction arrayTests(func, checkResult, checkTraps) {\n  checkResult(_ => func(arrayOne.concat(), arrayTwo.concat()),\n              \"for arrays\");\n\n  var output = [];\n  var actual;\n  try {\n    actual = func(new Proxy(arrayOne.concat(), new spyTraps(output)),\n                  new Proxy(arrayTwo.concat(), new spyTraps(output)));\n  } catch (e) {\n    checkResult(function() { throw e }, \"for proxy exception\");\n    checkTraps(_ => output);\n    return;\n  }\n\n  // If actual is an Array Iterator, expand it here, before copying output\n  var copyOutput = alterArrayTraps(output);\n  checkResult(_ => actual,\n              \"for proxies\");\n  checkTraps(_ => copyOutput);\n}\n\nfunction hasGetTraps(begin, end /* inclusive */) {\n  var ret = [];\n  for (var i = begin; i <= end; ++i) {\n    ret.push(\"has:\" + i);\n    ret.push(\"get:\" + i);\n  }\n  return ret;\n}\n\nvar oneTraps = [\n  'get:length',\n  ...hasGetTraps(0, 1),\n  'has:2',\n  // get:2 is not called\n  'has:3',\n  'get:3',\n];\n\narrayTests(\n  (one, two) => Array.prototype.concat.call(one, two),\n  checkArray([11,12,,13,24,25,26,27]),\n  checkArray([\n    'get:Symbol(Symbol.isConcatSpreadable)',\n    ...oneTraps,\n    'get:Symbol(Symbol.isConcatSpreadable)',\n    'get:length',\n    ...hasGetTraps(0, 3),\n]));\n\narrayTests(\n  one => Array.prototype.copyWithin.call(one, 2, 1, 3),\n  checkArray([11,12,12,,]),\n  checkArray([\n    'get:length',\n    'has:2',\n    'delete:3',\n    'has:1',\n    'get:1',\n    'set:2']));\n\narrayTests(\n  one => Array.from(Array.prototype.entries.call(one)),\n  checkDeep([[0,11], [1,12], [2, undefined], [3,13]]),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:length',\n    'get:1',\n    'get:length',\n    'get:2',\n    'get:length',\n    'get:3',\n    'get:length']));\n\narrayTests(\n  one => Array.prototype.every.call(one, _ => _ % 2 == 1),\n  checkValue(false),\n  checkArray([\n    'get:length',\n    ...hasGetTraps(0, 1)]));\n\narrayTests(\n  one => Array.prototype.fill.call(one, 99, 2),\n  checkArray([11,12,99,99]),\n  checkArray([\n    'get:length',\n    'set:2',\n    'set:3']));\n\narrayTests(\n  one => Array.prototype.filter.call(one, _ => _ % 2 == 1),\n  checkArray([11,13]),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.find.call(one, _ => _ % 2 == 0),\n  checkValue(12),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.findIndex.call(one, _ => _ % 2 == 0),\n  checkValue(1),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.findIndex.call(one, _ => _ > 99),\n  checkValue(-1),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.prototype.flatMap.call(one, _ => _ * 10),\n  checkArray([110,120,130]),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.forEach.call(one, _ => _ * 10),\n  checkValue(undefined),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.includes.call(one, 12),\n  checkValue(true),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.includes.call(one, 99),\n  checkValue(false),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.prototype.indexOf.call(one, 12),\n  checkValue(1),\n  checkArray([\n    'get:length',\n    'has:0',\n    'get:0',\n    'has:1',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.indexOf.call(one, 99),\n  checkValue(-1),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.join.call(one, \",\"),\n  checkValue(\"11,12,,13\"),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.from(Array.prototype.keys.call(one)),\n  checkArray([0,1,2,3]),\n  checkArray([\n    'get:length',\n    'get:length',\n    'get:length',\n    'get:length',\n    'get:length']));\n\narrayTests(\n  one => Array.prototype.lastIndexOf.call(one, 12),\n  checkValue(1),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'has:2',\n    'has:1',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.lastIndexOf.call(one, 99),\n  checkValue(-1),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'has:2',\n    'has:1',\n    'get:1',\n    'has:0',\n    'get:0']));\n\narrayTests(\n  one => Array.prototype.map.call(one, _ => _ * 10),\n  checkArray([110,120,,130]),\n  checkArray(oneTraps));\n\narrayTests(\n  function(one) {\n    var ret = [];\n    ret.push(Array.prototype.pop.call(one));\n    ret.push(Array.prototype.pop.call(one));\n    ret.push(one.length);\n    return ret;\n  },\n  checkArray([13,undefined,2]),\n  checkArray([\n    'get:length',\n    'get:3',\n    'delete:3',\n    'set:length',\n    'get:length',\n    'get:2',\n    'delete:2',\n    'set:length',\n    'get:length']));\n\narrayTests(\n  function(one) {\n    var length = Array.prototype.push.call(one, 99);\n    return [length, one];\n  },\n  checkDeep([5,[11,12,,13,99]]),\n  checkArray([\n    'get:length',\n    'set:4',\n    'set:length']));\n\narrayTests(\n  one => Array.prototype.reduce.call(one, (a, b) => a + b),\n  checkValue(36),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.reduceRight.call(one, (a, b) => a + b),\n  checkValue(36),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'has:2',\n    'has:1',\n    'get:1',\n    'has:0',\n    'get:0']));\n\narrayTests(\n  one => Array.prototype.reverse.call(one),\n  checkArray([13,,12,11]),\n  checkArray([\n    'get:length',\n    'has:0',\n    'get:0',\n    'has:3',\n    'get:3',\n    'set:0',\n    'set:3',\n    'has:1',\n    'get:1',\n    'has:2',\n    'delete:1',\n    'set:2']));\n\narrayTests(\n  function(one) {\n    var ret = [];\n    ret.push(Array.prototype.shift.call(one));\n    ret.push(Array.prototype.shift.call(one));\n    ret.push(Array.prototype.shift.call(one));\n    ret.push(one.length);\n    return ret;\n  },\n  checkArray([11,12,undefined,1]),\n  checkArray([\n    'get:length',\n    'get:0',\n    'has:1',\n    'get:1',\n    'set:0',\n    'has:2',\n    'delete:1',\n    'has:3',\n    'get:3',\n    'set:2',\n    'delete:3',\n    'set:length',\n\n    'get:length',\n    'get:0',\n    'has:1',\n    'delete:0',\n    'has:2',\n    'get:2',\n    'set:1',\n    'delete:2',\n    'set:length',\n\n    'get:length',\n    'get:0',\n    'has:1',\n    'get:1',\n    'set:0',\n    'delete:1',\n    'set:length',\n\n    'get:length']));\n\narrayTests(\n  one => Array.prototype.slice.call(one, 1, 3),\n  checkArray([12,,]),\n  checkArray([\n    'get:length',\n    'has:1',\n    'get:1',\n    'has:2']));\n\narrayTests(\n  one => Array.prototype.some.call(one, _ => _ % 2 == 1),\n  checkValue(true),\n  checkArray([\n    'get:length',\n    'has:0',\n    'get:0']));\n\narrayTests(\n  one => Array.prototype.sort.call(one.reverse()),\n  checkArray([11,12,13,,]),\n  // sort's behavior is implementation-defined, so we just check\n  // that any traps at all are called.\n  checkIf(_ => _.length > 0));\n\narrayTests(\n  function(one) {\n    var ret = Array.prototype.splice.call(one, 1, 2, 98, 99);\n    return [ret, one];\n  },\n  checkDeep([[12,,],[11,98,99,13]]),\n  checkArray([\n    'get:length',\n    'has:1',\n    'get:1',\n    'has:2',\n    'set:1',\n    'set:2',\n    'set:length']));\n\narrayTests(\n  one => Array.prototype.toLocaleString.call(one),\n  checkValue(\"11,12,,13\"),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.prototype.toString.call(one),\n  checkValue(\"11,12,,13\"),\n  checkArray([\n    'get:join',\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  function(one) {\n    var ret = Array.prototype.unshift.call(one, 98, 99);\n    return [ret, one];\n  },\n  checkDeep([6, [98,99,11,12,,13]]),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'set:5',\n    'has:2',\n    'delete:4',\n    'has:1',\n    'get:1',\n    'set:3',\n    'has:0',\n    'get:0',\n    'set:2',\n    'set:0',\n    'set:1',\n    'set:length']));\n\narrayTests(\n  one => Array.from(Array.prototype.values.call(one)),\n  checkArray([11,12,,13]),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:length',\n    'get:1',\n    'get:length',\n    'get:2',\n    'get:length',\n    'get:3',\n    'get:length']));\n\nprint('misc');\n// CHECK-LABEL: misc\n\n// Do a deep target recursion\nvar p = {a:1};\nfor (var i = 0; i < 64; ++i) {\n  p = new Proxy(p, {});\n}\nassert.equal(p.a, 1);\n\n// Test HermesInternal\nassert.equal(\n  typeof HermesInternal !== 'object' ||\n    HermesInternal.isProxy(new Proxy({}, {})),\n  true);\n\n// spread of a callable\nvar f = function() { return 1; }\nf.a = 1;\nf.b = 2;\ncheckDeep({...f})(_ => ({a:1, b:2}))\n\n// Check that defining a property in a Proxy target which is an array\n// uses fast array access (this will trip an assert otherwise)\nnew Proxy([], {}).unshift(0);\n\nprint('done');\n// CHECK-LABEL: done\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/VM/JSObject.h\"\n\n#include \"hermes/VM/BuildMetadata.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/HostModel.h\"\n#include \"hermes/VM/InternalProperty.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSDate.h\"\n#include \"hermes/VM/JSProxy.h\"\n#include \"hermes/VM/Operations.h\"\n\n#include \"llvh/ADT/SmallSet.h\"\n\nnamespace hermes {\nnamespace vm {\n\nObjectVTable JSObject::vt{\n    VTable(\n        CellKind::ObjectKind,\n        cellSize<JSObject>(),\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr, // externalMemorySize\n        VTable::HeapSnapshotMetadata{HeapSnapshot::NodeType::Object,\n                                     JSObject::_snapshotNameImpl,\n                                     JSObject::_snapshotAddEdgesImpl,\n                                     nullptr,\n                                     JSObject::_snapshotAddLocationsImpl}),\n    JSObject::_getOwnIndexedRangeImpl,\n    JSObject::_haveOwnIndexedImpl,\n    JSObject::_getOwnIndexedPropertyFlagsImpl,\n    JSObject::_getOwnIndexedImpl,\n    JSObject::_setOwnIndexedImpl,\n    JSObject::_deleteOwnIndexedImpl,\n    JSObject::_checkAllOwnIndexedImpl,\n};\n\nvoid ObjectBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  // This call is just for debugging and consistency purposes.\n  mb.addJSObjectOverlapSlots(JSObject::numOverlapSlots<JSObject>());\n\n  const auto *self = static_cast<const JSObject *>(cell);\n  mb.addField(\"parent\", &self->parent_);\n  mb.addField(\"class\", &self->clazz_);\n  mb.addField(\"propStorage\", &self->propStorage_);\n\n  // Declare the direct properties.\n  static const char *directPropName[JSObject::DIRECT_PROPERTY_SLOTS] = {\n      \"directProp0\", \"directProp1\", \"directProp2\", \"directProp3\"};\n  for (unsigned i = mb.getJSObjectOverlapSlots();\n       i < JSObject::DIRECT_PROPERTY_SLOTS;\n       ++i) {\n    mb.addField(directPropName[i], self->directProps() + i);\n  }\n}\n\n#ifdef HERMESVM_SERIALIZE\nvoid JSObject::serializeObjectImpl(\n    Serializer &s,\n    const GCCell *cell,\n    unsigned overlapSlots) {\n  auto *self = vmcast<const JSObject>(cell);\n  s.writeData(&self->flags_, sizeof(ObjectFlags));\n  s.writeRelocation(self->parent_.get(s.getRuntime()));\n  s.writeRelocation(self->clazz_.get(s.getRuntime()));\n  // propStorage_ : GCPointer<PropStorage> is also ArrayStorage. Serialize\n  // *propStorage_ with this JSObject.\n  bool hasArray = (bool)self->propStorage_;\n  s.writeInt<uint8_t>(hasArray);\n  if (hasArray) {\n    ArrayStorage::serializeArrayStorage(\n        s, self->propStorage_.get(s.getRuntime()));\n  }\n\n  // Record the number of overlap slots, so that the deserialization code\n  // doesn't need to keep track of it.\n  s.writeInt<uint8_t>(overlapSlots);\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    s.writeHermesValue(self->directProps()[i]);\n  }\n}\n\nvoid ObjectSerialize(Serializer &s, const GCCell *cell) {\n  JSObject::serializeObjectImpl(s, cell, JSObject::numOverlapSlots<JSObject>());\n  s.endObject(cell);\n}\n\nvoid ObjectDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::ObjectKind && \"Expected JSObject\");\n  void *mem = d.getRuntime()->alloc</*fixedSize*/ true>(cellSize<JSObject>());\n  auto *obj = new (mem) JSObject(d, &JSObject::vt.base);\n\n  d.endObject(obj);\n}\n\nJSObject::JSObject(Deserializer &d, const VTable *vtp)\n    : GCCell(&d.getRuntime()->getHeap(), vtp) {\n  d.readData(&flags_, sizeof(ObjectFlags));\n  d.readRelocation(&parent_, RelocationKind::GCPointer);\n  d.readRelocation(&clazz_, RelocationKind::GCPointer);\n  if (d.readInt<uint8_t>()) {\n    propStorage_.set(\n        d.getRuntime(),\n        ArrayStorage::deserializeArrayStorage(d),\n        &d.getRuntime()->getHeap());\n  }\n\n  auto overlapSlots = d.readInt<uint8_t>();\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    d.readHermesValue(&directProps()[i]);\n  }\n}\n#endif\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<JSObject> parentHandle) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      *parentHandle,\n      runtime->getHiddenClassForPrototypeRaw(\n          *parentHandle,\n          numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(Runtime *runtime) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    unsigned propertyCount) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  auto self = mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n\n  return runtime->ignoreAllocationFailure(\n      JSObject::allocatePropStorage(std::move(self), runtime, propertyCount));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<HiddenClass> clazz) {\n  auto obj = JSObject::create(runtime, clazz->getNumProperties());\n  obj->clazz_.set(runtime, *clazz, &runtime->getHeap());\n  // If the hidden class has index like property, we need to clear the fast path\n  // flag.\n  if (LLVM_UNLIKELY(obj->clazz_.get(runtime)->getHasIndexLikeProperties()))\n    obj->flags_.fastIndexProperties = false;\n  return obj;\n}\n\nvoid JSObject::initializeLazyObject(\n    Runtime *runtime,\n    Handle<JSObject> lazyObject) {\n  assert(lazyObject->flags_.lazyObject && \"object must be lazy\");\n  // object is now assumed to be a regular object.\n  lazyObject->flags_.lazyObject = 0;\n\n  // only functions can be lazy.\n  assert(vmisa<Callable>(lazyObject.get()) && \"unexpected lazy object\");\n  Callable::defineLazyProperties(Handle<Callable>::vmcast(lazyObject), runtime);\n}\n\nObjectID JSObject::getObjectID(JSObject *self, Runtime *runtime) {\n  if (LLVM_LIKELY(self->flags_.objectID))\n    return self->flags_.objectID;\n\n  // Object ID does not yet exist, get next unique global ID..\n  self->flags_.objectID = runtime->generateNextObjectID();\n  // Make sure it is not zero.\n  if (LLVM_UNLIKELY(!self->flags_.objectID))\n    --self->flags_.objectID;\n  return self->flags_.objectID;\n}\n\nCallResult<PseudoHandle<JSObject>> JSObject::getPrototypeOf(\n    PseudoHandle<JSObject> selfHandle,\n    Runtime *runtime) {\n  if (LLVM_LIKELY(!selfHandle->isProxyObject())) {\n    return createPseudoHandle(selfHandle->getParent(runtime));\n  }\n\n  return JSProxy::getPrototypeOf(\n      runtime->makeHandle(std::move(selfHandle)), runtime);\n}\n\nnamespace {\n\nCallResult<bool> proxyOpFlags(\n    Runtime *runtime,\n    PropOpFlags opFlags,\n    const char *msg,\n    CallResult<bool> res) {\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*res && opFlags.getThrowOnError()) {\n    return runtime->raiseTypeError(msg);\n  }\n  return res;\n}\n\n} // namespace\n\nCallResult<bool> JSObject::setParent(\n    JSObject *self,\n    Runtime *runtime,\n    JSObject *parent,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Object is not extensible.\",\n        JSProxy::setPrototypeOf(\n            runtime->makeHandle(self), runtime, runtime->makeHandle(parent)));\n  }\n  // ES9 9.1.2\n  // 4.\n  if (self->parent_.get(runtime) == parent)\n    return true;\n  // 5.\n  if (!self->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\"Object is not extensible.\");\n    } else {\n      return false;\n    }\n  }\n  // 6-8. Check for a prototype cycle.\n  for (JSObject *cur = parent; cur; cur = cur->parent_.get(runtime)) {\n    if (cur == self) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\"Prototype cycle detected\");\n      } else {\n        return false;\n      }\n    } else if (LLVM_UNLIKELY(cur->isProxyObject())) {\n      // TODO this branch should also be used for module namespace and\n      // immutable prototype exotic objects.\n      break;\n    }\n  }\n  // 9.\n  self->parent_.set(runtime, parent, &runtime->getHeap());\n  // 10.\n  return true;\n}\n\nvoid JSObject::allocateNewSlotStorage(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SlotIndex newSlotIndex,\n    Handle<> valueHandle) {\n  // If it is a direct property, just store the value and we are done.\n  if (LLVM_LIKELY(newSlotIndex < DIRECT_PROPERTY_SLOTS)) {\n    selfHandle->directProps()[newSlotIndex].set(\n        *valueHandle, &runtime->getHeap());\n    return;\n  }\n\n  // Make the slot index relative to the indirect storage.\n  newSlotIndex -= DIRECT_PROPERTY_SLOTS;\n\n  // Allocate a new property storage if not already allocated.\n  if (LLVM_UNLIKELY(!selfHandle->propStorage_)) {\n    // Allocate new storage.\n    assert(newSlotIndex == 0 && \"allocated slot must be at end\");\n    auto arrRes = runtime->ignoreAllocationFailure(\n        PropStorage::create(runtime, DEFAULT_PROPERTY_CAPACITY));\n    selfHandle->propStorage_.set(\n        runtime, vmcast<PropStorage>(arrRes), &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(\n                 newSlotIndex >=\n                 selfHandle->propStorage_.get(runtime)->capacity())) {\n    // Reallocate the existing one.\n    assert(\n        newSlotIndex == selfHandle->propStorage_.get(runtime)->size() &&\n        \"allocated slot must be at end\");\n    auto hnd = runtime->makeMutableHandle(selfHandle->propStorage_);\n    PropStorage::resize(hnd, runtime, newSlotIndex + 1);\n    selfHandle->propStorage_.set(runtime, *hnd, &runtime->getHeap());\n  }\n\n  {\n    NoAllocScope scope{runtime};\n    auto *const propStorage = selfHandle->propStorage_.getNonNull(runtime);\n    if (newSlotIndex >= propStorage->size()) {\n      assert(\n          newSlotIndex == propStorage->size() &&\n          \"allocated slot must be at end\");\n      PropStorage::resizeWithinCapacity(propStorage, runtime, newSlotIndex + 1);\n    }\n    // If we don't need to resize, just store it directly.\n    propStorage->at(newSlotIndex).set(*valueHandle, &runtime->getHeap());\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    NamedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getNamedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(getNamedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor =\n      vmcast<PropertyAccessor>(getNamedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getComputedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor = vmcast<PropertyAccessor>(\n      getComputedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc,\n    Handle<> nameValHandle) {\n  if (!propObj) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n\n  if (LLVM_LIKELY(!desc.flags.proxyObject)) {\n    return JSObject::getComputedPropertyValue_RJS(\n        selfHandle, runtime, propObj, desc);\n  }\n\n  CallResult<Handle<>> keyRes = toPropertyKey(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(keyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  CallResult<bool> hasRes = JSProxy::hasComputed(propObj, runtime, *keyRes);\n  if (LLVM_UNLIKELY(hasRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*hasRes) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n  return JSProxy::getComputed(propObj, runtime, *keyRes, selfHandle);\n}\n\nCallResult<Handle<JSArray>> JSObject::getOwnPropertyKeys(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    OwnKeysFlags okFlags) {\n  assert(\n      (okFlags.getIncludeNonSymbols() || okFlags.getIncludeSymbols()) &&\n      \"Can't exclude symbols and strings\");\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      CallResult<PseudoHandle<JSArray>> proxyRes =\n          JSProxy::ownPropertyKeys(selfHandle, runtime, okFlags);\n      if (LLVM_UNLIKELY(proxyRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return runtime->makeHandle(std::move(*proxyRes));\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    initializeLazyObject(runtime, selfHandle);\n  }\n\n  auto range = getOwnIndexedRange(selfHandle.get(), runtime);\n\n  // Estimate the capacity of the output array.  This estimate is only\n  // reasonable for the non-symbol case.\n  uint32_t capacity = okFlags.getIncludeNonSymbols()\n      ? (selfHandle->clazz_.get(runtime)->getNumProperties() + range.second -\n         range.first)\n      : 0;\n\n  auto arrayRes = JSArray::create(runtime, capacity, 0);\n  if (LLVM_UNLIKELY(arrayRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto array = runtime->makeHandle(std::move(*arrayRes));\n\n  // Optional array of SymbolIDs reported via host object API\n  llvh::Optional<Handle<JSArray>> hostObjectSymbols;\n  size_t hostObjectSymbolCount = 0;\n\n  // If current object is a host object we need to deduplicate its properties\n  llvh::SmallSet<SymbolID::RawType, 16> dedupSet;\n\n  // Output index.\n  uint32_t index = 0;\n\n  // Avoid allocating a new handle per element.\n  MutableHandle<> tmpHandle{runtime};\n\n  // Number of indexed properties.\n  uint32_t numIndexed = 0;\n\n  // Regular properties with names that are array indexes are stashed here, if\n  // encountered.\n  llvh::SmallVector<uint32_t, 8> indexNames{};\n\n  // Iterate the named properties excluding those which use Symbols.\n  if (okFlags.getIncludeNonSymbols()) {\n    // Get host object property names\n    if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n      assert(\n          range.first == range.second &&\n          \"Host objects cannot own indexed range\");\n      auto hostSymbolsRes =\n          vmcast<HostObject>(selfHandle.get())->getHostPropertyNames();\n      if (hostSymbolsRes == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if ((hostObjectSymbolCount = (**hostSymbolsRes)->getEndIndex()) != 0) {\n        Handle<JSArray> hostSymbols = *hostSymbolsRes;\n        hostObjectSymbols = std::move(hostSymbols);\n        capacity += hostObjectSymbolCount;\n      }\n    }\n\n    // Iterate the indexed properties.\n    GCScopeMarkerRAII marker{runtime};\n    for (auto i = range.first; i != range.second; ++i) {\n      auto res = getOwnIndexedPropertyFlags(selfHandle.get(), runtime, i);\n      if (!res)\n        continue;\n\n      // If specified, check whether it is enumerable.\n      if (!okFlags.getIncludeNonEnumerable() && !res->enumerable)\n        continue;\n\n      tmpHandle = HermesValue::encodeDoubleValue(i);\n      JSArray::setElementAt(array, runtime, index++, tmpHandle);\n      marker.flush();\n    }\n\n    numIndexed = index;\n\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime,\n         okFlags,\n         array,\n         hostObjectSymbolCount,\n         &index,\n         &indexNames,\n         &tmpHandle,\n         &dedupSet](SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isPropertyNamePrimitive(id)) {\n            return;\n          }\n\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n\n          // Host properties might overlap with the ones recognized by the\n          // hidden class. If we're dealing with a host object then keep track\n          // of hidden class properties for the deduplication purposes.\n          if (LLVM_UNLIKELY(hostObjectSymbolCount > 0)) {\n            dedupSet.insert(id.unsafeGetRaw());\n          }\n\n          // Check if this property is an integer index. If it is, we stash it\n          // away to deal with it later. This check should be fast since most\n          // property names don't start with a digit.\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            return;\n          }\n\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        });\n\n    // Iterate over HostObject properties and append them to the array. Do not\n    // append duplicates.\n    if (LLVM_UNLIKELY(hostObjectSymbols)) {\n      for (size_t i = 0; i < hostObjectSymbolCount; ++i) {\n        assert(\n            (*hostObjectSymbols)->at(runtime, i).isSymbol() &&\n            \"Host object needs to return array of SymbolIDs\");\n        marker.flush();\n        SymbolID id = (*hostObjectSymbols)->at(runtime, i).getSymbol();\n        if (dedupSet.count(id.unsafeGetRaw()) == 0) {\n          dedupSet.insert(id.unsafeGetRaw());\n\n          assert(\n              !InternalProperty::isInternal(id) &&\n              \"host object returned reserved symbol\");\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            continue;\n          }\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        }\n      }\n    }\n  }\n\n  // Now iterate the named properties again, including only Symbols.\n  // We could iterate only once, if we chose to ignore (and disallow)\n  // own properties on HostObjects, as we do with Proxies.\n  if (okFlags.getIncludeSymbols()) {\n    MutableHandle<SymbolID> idHandle{runtime};\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime, okFlags, array, &index, &idHandle](\n            SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isSymbolPrimitive(id)) {\n            return;\n          }\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n          idHandle = id;\n          JSArray::setElementAt(array, runtime, index++, idHandle);\n        });\n  }\n\n  // The end (exclusive) of the named properties.\n  uint32_t endNamed = index;\n\n  // Properly set the length of the array.\n  auto cr = JSArray::setLength(\n      array, runtime, endNamed + indexNames.size(), PropOpFlags{});\n  (void)cr;\n  assert(\n      cr != ExecutionStatus::EXCEPTION && *cr && \"JSArray::setLength() failed\");\n\n  // If we have no index-like names, we are done.\n  if (LLVM_LIKELY(indexNames.empty()))\n    return array;\n\n  // In the unlikely event that we encountered index-like names, we need to sort\n  // them and merge them with the real indexed properties. Note that it is\n  // guaranteed that there are no clashes.\n  std::sort(indexNames.begin(), indexNames.end());\n\n  // Also make space for the new elements by shifting all the named properties\n  // to the right. First, resize the array.\n  JSArray::setStorageEndIndex(array, runtime, endNamed + indexNames.size());\n\n  // Shift the non-index property names. The region [numIndexed..endNamed) is\n  // moved to [numIndexed+indexNames.size()..array->size()).\n  // TODO: optimize this by implementing memcpy-like functionality in ArrayImpl.\n  for (uint32_t last = endNamed, toLast = array->getEndIndex();\n       last != numIndexed;) {\n    --last;\n    --toLast;\n    tmpHandle = array->at(runtime, last);\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  // Now we need to merge the indexes in indexNames and the array\n  // [0..numIndexed). We start from the end and copy the larger element from\n  // either array.\n  // 1+ the destination position to copy into.\n  for (uint32_t toLast = numIndexed + indexNames.size(),\n                indexNamesLast = indexNames.size();\n       toLast != 0;) {\n    if (numIndexed) {\n      uint32_t a = (uint32_t)array->at(runtime, numIndexed - 1).getNumber();\n      uint32_t b;\n\n      if (indexNamesLast && (b = indexNames[indexNamesLast - 1]) > a) {\n        tmpHandle = HermesValue::encodeDoubleValue(b);\n        --indexNamesLast;\n      } else {\n        tmpHandle = HermesValue::encodeDoubleValue(a);\n        --numIndexed;\n      }\n    } else {\n      assert(indexNamesLast && \"prematurely ran out of source values\");\n      tmpHandle =\n          HermesValue::encodeDoubleValue(indexNames[indexNamesLast - 1]);\n      --indexNamesLast;\n    }\n\n    --toLast;\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  return array;\n}\n\n/// Convert a value to string unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n#define LAZY_TO_STRING(runtime, nameValHandle, str)       \\\n  do {                                                    \\\n    if (!str) {                                           \\\n      auto status = toString_RJS(runtime, nameValHandle); \\\n      assert(                                             \\\n          status != ExecutionStatus::EXCEPTION &&         \\\n          \"toString() of primitive cannot fail\");         \\\n      str = status->get();                                \\\n    }                                                     \\\n  } while (0)\n\n/// Convert a value to an identifier unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param id [SymbolID] the identifier is stored there. Must be initialized\n///   to INVALID_IDENTIFIER_ID initially.\n#define LAZY_TO_IDENTIFIER(runtime, nameValHandle, id)          \\\n  do {                                                          \\\n    if (id.isInvalid()) {                                       \\\n      CallResult<Handle<SymbolID>> idRes =                      \\\n          valueToSymbolID(runtime, nameValHandle);              \\\n      if (LLVM_UNLIKELY(idRes == ExecutionStatus::EXCEPTION)) { \\\n        return ExecutionStatus::EXCEPTION;                      \\\n      }                                                         \\\n      id = **idRes;                                             \\\n    }                                                           \\\n  } while (0)\n\n/// Convert a value to array index, if possible.\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n/// \\param arrayIndex [OptValue<uint32_t>] the array index is stored\n///   there.\n#define TO_ARRAY_INDEX(runtime, nameValHandle, str, arrayIndex) \\\n  do {                                                          \\\n    arrayIndex = toArrayIndexFastPath(*nameValHandle);          \\\n    if (!arrayIndex && !nameValHandle->isSymbol()) {            \\\n      LAZY_TO_STRING(runtime, nameValHandle, str);              \\\n      arrayIndex = toArrayIndex(runtime, str);                  \\\n    }                                                           \\\n  } while (0)\n\n/// \\return true if the flags of a new property make it suitable for indexed\n///   storage. All new indexed properties are enumerable, writable and\n///   configurable and have no accessors.\nstatic bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {\n  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&\n      dpf.writable && dpf.setConfigurable && dpf.configurable &&\n      !dpf.setSetter && !dpf.setGetter;\n}\n\nstruct JSObject::Helper {\n public:\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static ObjectFlags &flags(JSObject *self) {\n    return self->flags_;\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static OptValue<PropertyFlags>\n  getOwnIndexedPropertyFlags(JSObject *self, Runtime *runtime, uint32_t index) {\n    return JSObject::getOwnIndexedPropertyFlags(self, runtime, index);\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static NamedPropertyDescriptor &castToNamedPropertyDescriptorRef(\n      ComputedPropertyDescriptor &desc) {\n    return desc.castToNamedPropertyDescriptorRef();\n  }\n};\n\nnamespace {\n\n/// ES5.1 8.12.1.\n\n/// A helper which takes a SymbolID which caches the conversion of\n/// nameValHandle if it's needed.  It should be default constructed,\n/// and may or may not be set.  This has been measured to be a useful\n/// perf win.  Note that always_inline seems to be ignored on static\n/// methods, so this function has to be local to the cpp file in order\n/// to be inlined for the perf win.\nLLVM_ATTRIBUTE_ALWAYS_INLINE\nCallResult<bool> getOwnComputedPrimitiveDescriptorImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    SymbolID &id,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getOwnComputedPrimitiveDescriptor \"\n      \"cannot be an object\");\n\n  // Try the fast paths first if we have \"fast\" index properties and the\n  // property name is an obvious index.\n  if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n    if (JSObject::Helper::flags(*selfHandle).fastIndexProperties) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        // This a valid array index, residing in our indexed storage.\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n\n      // This a valid array index, but we don't have it in our indexed storage,\n      // and we don't have index-like named properties.\n      return false;\n    }\n\n    if (!selfHandle->getClass(runtime)->getHasIndexLikeProperties() &&\n        !selfHandle->isHostObject() && !selfHandle->isLazy() &&\n        !selfHandle->isProxyObject()) {\n      // Early return to handle the case where an object definitely has no\n      // index-like properties. This avoids allocating a new StringPrimitive and\n      // uniquing it below.\n      return false;\n    }\n  }\n\n  // Convert the string to a SymbolID\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n  // Look for a named property with this name.\n  if (JSObject::getOwnNamedDescriptor(\n          selfHandle,\n          runtime,\n          id,\n          JSObject::Helper::castToNamedPropertyDescriptorRef(desc))) {\n    return true;\n  }\n\n  if (LLVM_LIKELY(\n          !JSObject::Helper::flags(*selfHandle).indexedStorage &&\n          !selfHandle->isLazy() && !selfHandle->isProxyObject())) {\n    return false;\n  }\n  MutableHandle<StringPrimitive> strPrim{runtime};\n\n  // If we have indexed storage, perform potentially expensive conversions\n  // to array index and check it.\n  if (JSObject::Helper::flags(*selfHandle).indexedStorage) {\n    // If the name is a valid integer array index, store it here.\n    OptValue<uint32_t> arrayIndex;\n\n    // Try to convert the property name to an array index.\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n\n    if (arrayIndex) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (selfHandle->isLazy()) {\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return JSObject::getOwnComputedPrimitiveDescriptor(\n        selfHandle, runtime, nameValHandle, ignoreProxy, desc);\n  }\n\n  assert(selfHandle->isProxyObject() && \"descriptor flags are impossible\");\n  if (ignoreProxy == JSObject::IgnoreProxy::Yes) {\n    return false;\n  }\n  return JSProxy::getOwnProperty(\n      selfHandle, runtime, nameValHandle, desc, nullptr);\n}\n\n} // namespace\n\nCallResult<bool> JSObject::getOwnComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    ComputedPropertyDescriptor &desc) {\n  SymbolID id{};\n\n  return getOwnComputedPrimitiveDescriptorImpl(\n      selfHandle, runtime, nameValHandle, ignoreProxy, id, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::No, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc,\n    MutableHandle<> &valueOrAccessor) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // The proxy is ignored here so we can avoid calling\n  // JSProxy::getOwnProperty twice on proxies, since\n  // getOwnComputedPrimitiveDescriptor doesn't pass back the\n  // valueOrAccessor.\n  CallResult<bool> res = JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::Yes, desc);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (*res) {\n    valueOrAccessor = getComputedSlotValue(selfHandle.get(), runtime, desc);\n    return true;\n  }\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::getOwnProperty(\n        selfHandle, runtime, nameValHandle, desc, &valueOrAccessor);\n  }\n  return false;\n}\n\nJSObject *JSObject::getNamedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags expectedFlags,\n    NamedPropertyDescriptor &desc) {\n  if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n    return *selfHandle;\n\n  // Check here for host object flag.  This means that \"normal\" own\n  // properties above win over host-defined properties, but there's no\n  // cost imposed on own property lookups.  This should do what we\n  // need in practice, and we can define host vs js property\n  // disambiguation however we want.  This is here in order to avoid\n  // impacting perf for the common case where an own property exists\n  // in normal storage.\n  if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n    desc.flags.hostObject = true;\n    desc.flags.writable = true;\n    return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    assert(\n        !selfHandle->flags_.proxyObject &&\n        \"Proxy objects should never be lazy\");\n    // Initialize the object and perform the lookup again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n\n    if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n      return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    desc.flags.proxyObject = true;\n    return *selfHandle;\n  }\n\n  if (selfHandle->parent_) {\n    MutableHandle<JSObject> mutableSelfHandle{\n        runtime, selfHandle->parent_.getNonNull(runtime)};\n\n    do {\n      // Check the most common case first, at the cost of some code duplication.\n      if (LLVM_LIKELY(\n              !mutableSelfHandle->flags_.lazyObject &&\n              !mutableSelfHandle->flags_.hostObject &&\n              !mutableSelfHandle->flags_.proxyObject)) {\n      findProp:\n        if (findProperty(\n                mutableSelfHandle,\n                runtime,\n                name,\n                PropertyFlags::invalid(),\n                desc)) {\n          assert(\n              !selfHandle->flags_.proxyObject &&\n              \"Proxy object parents should never have own properties\");\n          return *mutableSelfHandle;\n        }\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.lazyObject)) {\n        JSObject::initializeLazyObject(runtime, mutableSelfHandle);\n        goto findProp;\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.hostObject)) {\n        desc.flags.hostObject = true;\n        desc.flags.writable = true;\n        return *mutableSelfHandle;\n      } else {\n        assert(\n            mutableSelfHandle->flags_.proxyObject &&\n            \"descriptor flags are impossible\");\n        desc.flags.proxyObject = true;\n        return *mutableSelfHandle;\n      }\n    } while ((mutableSelfHandle = mutableSelfHandle->parent_.get(runtime)));\n  }\n\n  return nullptr;\n}\n\nExecutionStatus JSObject::getComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getComputedPrimitiveDescriptor cannot \"\n      \"be an object\");\n\n  propObj = selfHandle.get();\n\n  SymbolID id{};\n\n  GCScopeMarkerRAII marker{runtime};\n  do {\n    // A proxy is ignored here so we can check the bit later and\n    // return it back to the caller for additional processing.\n\n    Handle<JSObject> loopHandle = propObj;\n\n    CallResult<bool> res = getOwnComputedPrimitiveDescriptorImpl(\n        loopHandle, runtime, nameValHandle, IgnoreProxy::Yes, id, desc);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*res) {\n      return ExecutionStatus::RETURNED;\n    }\n\n    if (LLVM_UNLIKELY(propObj->flags_.hostObject)) {\n      desc.flags.hostObject = true;\n      desc.flags.writable = true;\n      return ExecutionStatus::RETURNED;\n    }\n    if (LLVM_UNLIKELY(propObj->flags_.proxyObject)) {\n      desc.flags.proxyObject = true;\n      return ExecutionStatus::RETURNED;\n    }\n    // This isn't a proxy, so use the faster getParent() instead of\n    // getPrototypeOf.\n    propObj = propObj->getParent(runtime);\n    // Flush at the end of the loop to allow first iteration to be as fast as\n    // possible.\n    marker.flush();\n  } while (propObj);\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::getComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return getComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, propObj, desc);\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> receiver,\n    PropOpFlags opFlags,\n    PropertyCacheEntry *cacheEntry) {\n  NamedPropertyDescriptor desc;\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (!propObj) {\n    if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n      return runtime->raiseReferenceError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' doesn't exist\");\n    }\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  }\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject)) {\n    // Populate the cache if requested.\n    if (cacheEntry && !propObj->getClass(runtime)->isDictionaryNoCache()) {\n      cacheEntry->clazz = propObj->getClassGCPtr().getStorageType();\n      cacheEntry->slot = desc.slot;\n    }\n    return createPseudoHandle(getNamedSlotValue(propObj, runtime, desc));\n  }\n\n  if (desc.flags.accessor) {\n    auto *accessor =\n        vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return Callable::executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    auto res = vmcast<HostObject>(propObj)->get(name);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return createPseudoHandle(*res);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    return JSProxy::getNamed(\n        runtime->makeHandle(propObj), runtime, name, receiver);\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return getComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)));\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to getNamed().\n  }\n  return getNamed_RJS(selfHandle, runtime, name, opFlags);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return it.\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}\n\nCallResult<bool> JSObject::hasNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  NamedPropertyDescriptor desc;\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (propObj == nullptr) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    return JSProxy::hasNamed(runtime->makeHandle(propObj), runtime, name);\n  }\n  return true;\n}\n\nCallResult<bool> JSObject::hasNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      if (haveOwnIndexed(selfHandle.get(), runtime, *nameAsIndex)) {\n        return true;\n      }\n      if (selfHandle->flags_.fastIndexProperties) {\n        return false;\n      }\n    }\n    // Here we have indexed properties but the symbol was not stored in the\n    // indexedStorage.\n    // Fall through to getNamed().\n  }\n  return hasNamed(selfHandle, runtime, name);\n}\n\nCallResult<bool> JSObject::hasComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return true.\n      if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n        return true;\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (getComputedPrimitiveDescriptor(\n          selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n      ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::hasComputed(propObj, runtime, *key);\n  }\n  // For compatibility with polyfills we want to pretend that all HostObject\n  // properties are \"own\" properties in 'in'. Since there is no way to check for\n  // a HostObject property, we must always assume success. In practice the\n  // property name would have been obtained from enumerating the properties in\n  // JS code that looks something like this:\n  //    for(key in hostObj) {\n  //      if (key in hostObj)\n  //        ...\n  //    }\n  return true;\n}\n\nstatic ExecutionStatus raiseErrorForOverridingStaticBuiltin(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<SymbolID> name) {\n  Handle<StringPrimitive> methodNameHnd =\n      runtime->makeHandle(runtime->getStringPrimFromSymbolID(name.get()));\n  // If the 'name' property does not exist or is an accessor, we don't display\n  // the name.\n  NamedPropertyDescriptor desc;\n  auto *obj = JSObject::getNamedDescriptor(\n      selfHandle, runtime, Predefined::getSymbolID(Predefined::name), desc);\n  assert(\n      !selfHandle->isProxyObject() &&\n      \"raiseErrorForOverridingStaticBuiltin cannot be used with proxy objects\");\n\n  if (!obj || desc.flags.accessor) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  // Display the name property of the builtin object if it is a string.\n  StringPrimitive *objName = dyn_vmcast<StringPrimitive>(\n      JSObject::getNamedSlotValue(selfHandle.get(), runtime, desc));\n  if (!objName) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  return runtime->raiseTypeError(\n      TwineChar16(\"Attempting to override read-only builtin method '\") +\n      TwineChar16(objName) + \".\" + TwineChar16(methodNameHnd.get()) + \"'\");\n}\n\nCallResult<bool> JSObject::putNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  NamedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(\n      selfHandle,\n      runtime,\n      name,\n      PropertyFlags::defaultNewNamedPropertyFlags(),\n      desc);\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            *selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      setNamedSlotValue(\n          *selfHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor =\n          vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              TwineChar16(\"Cannot assign to property '\") +\n              runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n              \"' which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              *valueHandle) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<bool> setRes = JSProxy::setNamed(\n          runtime->makeHandle(propObj), runtime, name, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy set returned false for property '\") +\n            runtime->getIdentifierTable().getStringView(runtime, name) + \"'\");\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(name));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Cannot assign to read-only property '\") +\n            runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n            \"'\");\n      }\n      return false;\n    }\n\n    if (*selfHandle == propObj && desc.flags.internalSetter) {\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueHandle, opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n\n    if (getOwnNamedDescriptor(receiverHandle, runtime, name, desc)) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      assert(\n          !receiverHandle->isHostObject() && !receiverHandle->isProxyObject() &&\n          \"getOwnNamedDescriptor never sets hostObject or proxyObject flags\");\n\n      setNamedSlotValue(\n          *receiverHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    // Now deal with host and proxy object cases.  We need to call\n    // getOwnComputedPrimitiveDescriptor because it knows how to call\n    // the [[getOwnProperty]] Proxy impl if needed.\n    if (LLVM_UNLIKELY(\n            receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())\n            ->set(name, *valueHandle);\n      }\n      ComputedPropertyDescriptor desc;\n      Handle<> nameValHandle = runtime->makeHandle(name);\n      CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n          receiverHandle, runtime, nameValHandle, IgnoreProxy::No, desc);\n      if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      DefinePropertyFlags dpf;\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle, runtime, nameValHandle, dpf, valueHandle, opFlags);\n    }\n  }\n\n  // Does the caller require it to exist?\n  if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n    return runtime->raiseReferenceError(\n        TwineChar16(\"Property '\") +\n        runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n        \"' doesn't exist\");\n  }\n\n  // Add a new property.\n\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      name,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::putNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return putComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)),\n          valueHandle,\n          opFlags);\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to putNamed().\n  }\n  return putNamed_RJS(selfHandle, runtime, name, valueHandle, opFlags);\n}\n\nCallResult<bool> JSObject::putComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() &&\n      \"mustExist flag cannot be used with computed properties\");\n\n  // Try the fast-path first: has \"index-like\" properties, the \"name\"\n  // already is a valid integer index, selfHandle and receiver are the\n  // same, and it is present in storage.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {\n        if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n          auto result =\n              setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);\n          if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_LIKELY(*result))\n            return true;\n          if (opFlags.getThrowOnError()) {\n            // TODO: better message.\n            return runtime->raiseTypeError(\n                \"Cannot assign to read-only property\");\n          }\n          return false;\n        }\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      if (LLVM_UNLIKELY(\n              setComputedSlotValue(selfHandle, runtime, desc, valueHandle) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    // Is it an accessor?\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor = vmcast<PropertyAccessor>(\n          getComputedSlotValue(propObj.get(), runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeErrorForValue(\n              \"Cannot assign to property \",\n              nameValPrimitiveHandle,\n              \" which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              valueHandle.get()) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n      if (key == ExecutionStatus::EXCEPTION)\n        return ExecutionStatus::EXCEPTION;\n      CallResult<bool> setRes =\n          JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy trap returned false for property\"));\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        SymbolID id{};\n        LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(id));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeErrorForValue(\n            \"Cannot assign to read-only property \", nameValPrimitiveHandle, \"\");\n      }\n      return false;\n    }\n\n    if (selfHandle == propObj && desc.flags.internalSetter) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      return internalSetter(\n          selfHandle,\n          runtime,\n          id,\n          desc.castToNamedPropertyDescriptorRef(),\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n    CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n        receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);\n    if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    DefinePropertyFlags dpf;\n    if (*descDefinedRes) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      if (LLVM_LIKELY(\n              !desc.flags.internalSetter && !receiverHandle->isHostObject() &&\n              !receiverHandle->isProxyObject())) {\n        if (LLVM_UNLIKELY(\n                setComputedSlotValue(\n                    receiverHandle, runtime, desc, valueHandle) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        return true;\n      }\n    }\n\n    if (LLVM_UNLIKELY(\n            desc.flags.internalSetter || receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      // If putComputed is called on a proxy whose target's prototype\n      // is an array with a propname of 'length', then internalSetter\n      // will be true, and the receiver will be a proxy.  In that case,\n      // proxy wins.\n      if (receiverHandle->isProxyObject()) {\n        if (*descDefinedRes) {\n          dpf.setValue = 1;\n        } else {\n          dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n        }\n        return JSProxy::defineOwnProperty(\n            receiverHandle,\n            runtime,\n            nameValPrimitiveHandle,\n            dpf,\n            valueHandle,\n            opFlags);\n      }\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      if (desc.flags.internalSetter) {\n        return internalSetter(\n            receiverHandle,\n            runtime,\n            id,\n            desc.castToNamedPropertyDescriptorRef(),\n            valueHandle,\n            opFlags);\n      }\n      assert(\n          receiverHandle->isHostObject() && \"descriptor flags are impossible\");\n      return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n    }\n  }\n\n  /// Can we add more properties?\n  if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // If we have indexed storage we must check whether the property is an index,\n  // and if it is, store it in indexed storage.\n  if (receiverHandle->flags_.indexedStorage) {\n    OptValue<uint32_t> arrayIndex;\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n    if (arrayIndex) {\n      // Check whether we need to update array's \".length\" property.\n      if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {\n        if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {\n          auto cr = putNamed_RJS(\n              receiverHandle,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime->makeHandle(\n                  HermesValue::encodeNumberValue(*arrayIndex + 1)),\n              opFlags);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_UNLIKELY(!*cr))\n            return false;\n        }\n      }\n\n      auto result =\n          setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (LLVM_LIKELY(*result))\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\"Cannot assign to read-only property\");\n      }\n      return false;\n    }\n  }\n\n  SymbolID id{};\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Add a new named property.\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      id,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::deleteNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n\n  // If the property doesn't exist in this object, return success.\n  if (!pos) {\n    if (LLVM_LIKELY(\n            !selfHandle->flags_.lazyObject &&\n            !selfHandle->flags_.proxyObject)) {\n      return true;\n    } else if (selfHandle->flags_.lazyObject) {\n      // object is lazy, initialize and read again.\n      initializeLazyObject(runtime, selfHandle);\n      pos = findProperty(selfHandle, runtime, name, desc);\n      if (!pos) // still not there, return true.\n        return true;\n    } else {\n      assert(selfHandle->flags_.proxyObject && \"object flags are impossible\");\n      return proxyOpFlags(\n          runtime,\n          opFlags,\n          \"Proxy delete returned false\",\n          JSProxy::deleteNamed(selfHandle, runtime, name));\n    }\n  }\n  // If the property isn't configurable, fail.\n  if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' is not configurable\");\n    }\n    return false;\n  }\n\n  // Clear the deleted property value to prevent memory leaks.\n  setNamedSlotValue(\n      *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n  // Perform the actual deletion.\n  auto newClazz = HiddenClass::deleteProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  return true;\n}\n\nCallResult<bool> JSObject::deleteComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  auto nameValPrimitiveHandle = *converted;\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n  }\n\n  // Try the fast-path first: the \"name\" is a valid array index and we don't\n  // have \"index-like\" named properties.\n  if (arrayIndex && selfHandle->flags_.fastIndexProperties) {\n    // Delete the indexed property.\n    if (deleteOwnIndexed(selfHandle, runtime, *arrayIndex))\n      return true;\n\n    // Cannot delete property (for example this may be a typed array).\n    if (opFlags.getThrowOnError()) {\n      // TODO: better error message.\n      return runtime->raiseTypeError(\"Cannot delete property\");\n    }\n    return false;\n  }\n\n  // slow path, check if object is lazy before continuing.\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    // initialize and try again.\n    initializeLazyObject(runtime, selfHandle);\n    return deleteComputed(selfHandle, runtime, nameValHandle, opFlags);\n  }\n\n  // Convert the string to an SymbolID;\n  SymbolID id;\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, id, desc);\n\n  // If the property exists, make sure it is configurable.\n  if (pos) {\n    // If the property isn't configurable, fail.\n    if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: a better message.\n        return runtime->raiseTypeError(\"Property is not configurable\");\n      }\n      return false;\n    }\n  }\n\n  // At this point we know that the named property either doesn't exist, or\n  // is configurable and so can be deleted, or the object is a Proxy.\n\n  // If it is an \"index-like\" property, we must also delete the \"shadow\" indexed\n  // property in order to keep Array.length correct.\n  if (arrayIndex) {\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      // Cannot delete property (for example this may be a typed array).\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot delete property\");\n      }\n      return false;\n    }\n  }\n\n  if (pos) {\n    // delete the named property (if it exists).\n    // Clear the deleted property value to prevent memory leaks.\n    setNamedSlotValue(\n        *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n    // Remove the property descriptor.\n    auto newClazz = HiddenClass::deleteProperty(\n        runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Proxy delete returned false\",\n        JSProxy::deleteComputed(selfHandle, runtime, *key));\n  }\n\n  return true;\n}\n\nCallResult<bool> JSObject::defineOwnPropertyInternal(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // Is it an existing property.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n  if (pos) {\n    return updateOwnProperty(\n        selfHandle,\n        runtime,\n        name,\n        *pos,\n        desc,\n        dpFlags,\n        valueOrAccessor,\n        opFlags);\n  }\n\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      return JSProxy::defineOwnProperty(\n          selfHandle,\n          runtime,\n          name.isUniqued() ? runtime->makeHandle(HermesValue::encodeStringValue(\n                                 runtime->getStringPrimFromSymbolID(name)))\n                           : runtime->makeHandle(name),\n          dpFlags,\n          valueOrAccessor,\n          opFlags);\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    // if the property was not found and the object is lazy we need to\n    // initialize it and try again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return defineOwnPropertyInternal(\n        selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  return addOwnProperty(\n      selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n}\n\nExecutionStatus JSObject::defineNewOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"definedNewOwnProperty cannot be used with proxy objects\");\n  assert(\n      !(propertyFlags.accessor && !valueOrAccessor.get().isPointer()) &&\n      \"accessor must be non-empty\");\n  assert(\n      !(propertyFlags.accessor && propertyFlags.writable) &&\n      \"writable must not be set with accessors\");\n  assert(\n      !HiddenClass::debugIsPropertyDefined(\n          selfHandle->clazz_.get(runtime), runtime, name) &&\n      \"new property is already defined\");\n\n  return addOwnPropertyImpl(\n      selfHandle, runtime, name, propertyFlags, valueOrAccessor);\n}\n\nCallResult<bool> JSObject::defineOwnComputedPrimitive(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"defineOwnComputedPrimitive() cannot be \"\n      \"an object\");\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"Cannot set internalSetter on a computed property\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n  }\n\n  SymbolID id{};\n\n  // If not storing a property with an array index name, or if we don't have\n  // indexed storage, just pass to the named routine.\n  if (!arrayIndex) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return defineOwnPropertyInternal(\n        selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  // At this point we know that we have indexed storage and that the property\n  // has an index-like name.\n\n  // First check if a named property with the same name exists.\n  if (selfHandle->clazz_.get(runtime)->getHasIndexLikeProperties()) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n    NamedPropertyDescriptor desc;\n    auto pos = findProperty(selfHandle, runtime, id, desc);\n    // If we found a named property, update it.\n    if (pos) {\n      return updateOwnProperty(\n          selfHandle,\n          runtime,\n          id,\n          *pos,\n          desc,\n          dpFlags,\n          valueOrAccessor,\n          opFlags);\n    }\n  }\n\n  // Does an indexed property with that index exist?\n  auto indexedPropPresent =\n      getOwnIndexedPropertyFlags(selfHandle.get(), runtime, *arrayIndex);\n  if (indexedPropPresent) {\n    // The current value of the property.\n    HermesValue curValueOrAccessor =\n        getOwnIndexed(selfHandle.get(), runtime, *arrayIndex);\n\n    auto updateStatus = checkPropertyUpdate(\n        runtime,\n        *indexedPropPresent,\n        dpFlags,\n        curValueOrAccessor,\n        valueOrAccessor,\n        opFlags);\n    if (updateStatus == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    if (updateStatus->first == PropertyUpdateStatus::failed)\n      return false;\n\n    // The property update is valid, but can the property remain an \"indexed\"\n    // property, or do we need to convert it to a named property?\n    // If the property flags didn't change, the property remains indexed.\n    if (updateStatus->second == *indexedPropPresent) {\n      // If the value doesn't change, we are done.\n      if (updateStatus->first == PropertyUpdateStatus::done)\n        return true;\n\n      // If we successfully updated the value, we are done.\n      auto result =\n          setOwnIndexed(selfHandle, runtime, *arrayIndex, valueOrAccessor);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*result)\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\n            \"cannot change read-only property value\");\n      }\n\n      return false;\n    }\n\n    // OK, we need to convert an indexed property to a named one.\n\n    // Check whether to use the supplied value, or to reuse the old one, as we\n    // are simply reconfiguring it.\n    MutableHandle<> value{runtime};\n    if (dpFlags.setValue || dpFlags.isAccessor()) {\n      value = valueOrAccessor.get();\n    } else {\n      value = curValueOrAccessor;\n    }\n\n    // Update dpFlags to match the existing property flags.\n    dpFlags.setEnumerable = 1;\n    dpFlags.setWritable = 1;\n    dpFlags.setConfigurable = 1;\n    dpFlags.enumerable = updateStatus->second.enumerable;\n    dpFlags.writable = updateStatus->second.writable;\n    dpFlags.configurable = updateStatus->second.configurable;\n\n    // Delete the existing indexed property.\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n\n    // Add the new named property.\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return addOwnProperty(selfHandle, runtime, id, dpFlags, value, opFlags);\n  }\n\n  /// Can we add new properties?\n  if (!selfHandle->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // This is a new property with an index-like name.\n  // Check whether we need to update array's \".length\" property.\n  bool updateLength = false;\n  if (auto arrayHandle = Handle<JSArray>::dyn_vmcast(selfHandle)) {\n    if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(*arrayHandle))) {\n      NamedPropertyDescriptor lengthDesc;\n      bool lengthPresent = getOwnNamedDescriptor(\n          arrayHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::length),\n          lengthDesc);\n      (void)lengthPresent;\n      assert(lengthPresent && \".length must be present in JSArray\");\n\n      if (!lengthDesc.flags.writable) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"Cannot assign to read-only 'length' property of array\");\n        }\n        return false;\n      }\n\n      updateLength = true;\n    }\n  }\n\n  bool newIsIndexed = canNewPropertyBeIndexed(dpFlags);\n  if (newIsIndexed) {\n    auto result = setOwnIndexed(\n        selfHandle,\n        runtime,\n        *arrayIndex,\n        dpFlags.setValue ? valueOrAccessor : Runtime::getUndefinedValue());\n    if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    if (!*result) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n  }\n\n  // If this is an array and we need to update \".length\", do so.\n  if (updateLength) {\n    // This should always succeed since we are simply enlarging the length.\n    auto res = JSArray::setLength(\n        Handle<JSArray>::vmcast(selfHandle), runtime, *arrayIndex + 1, opFlags);\n    (void)res;\n    assert(\n        res != ExecutionStatus::EXCEPTION && *res &&\n        \"JSArray::setLength() failed unexpectedly\");\n  }\n\n  if (newIsIndexed)\n    return true;\n\n  // We are adding a new property with an index-like name.\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n  return addOwnProperty(\n      selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n}\n\nCallResult<bool> JSObject::defineOwnComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return defineOwnComputedPrimitive(\n      selfHandle, runtime, *converted, dpFlags, valueOrAccessor, opFlags);\n}\n\nstd::string JSObject::getHeuristicTypeName(GC *gc) {\n  PointerBase *const base = gc->getPointerBase();\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (auto *constructor = dyn_vmcast<JSObject>(*constructorVal)) {\n      auto name = constructor->getNameIfExists(base);\n      // If the constructor's name doesn't exist, or it is just the object\n      // constructor, attempt to find a different name.\n      if (!name.empty() && name != \"Object\")\n        return name;\n    }\n  }\n\n  std::string name = getVT()->base.snapshotMetaData.defaultNameForNode(this);\n  // A constructor's name was not found, check if the object is in dictionary\n  // mode.\n  if (getClass(base)->isDictionary()) {\n    return name + \"(Dictionary)\";\n  }\n\n  // If it's not an Object, the CellKind is most likely good enough on its own\n  if (getKind() != CellKind::ObjectKind) {\n    return name;\n  }\n\n  // If the object isn't a dictionary, and it has only a few property names,\n  // make the name based on those property names.\n  std::vector<std::string> propertyNames;\n  HiddenClass::forEachPropertyNoAlloc(\n      getClass(base),\n      base,\n      [gc, &propertyNames](SymbolID id, NamedPropertyDescriptor) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        propertyNames.emplace_back(gc->convertSymbolToUTF8(id));\n      });\n  // NOTE: One option is to sort the property names before truncation, to\n  // reduce the number of groups; however, by not sorting them it makes it\n  // easier to spot sets of objects with the same properties but in different\n  // orders, and thus find HiddenClass optimizations to make.\n\n  // For objects with a lot of properties but aren't in dictionary mode yet,\n  // keep the number displayed small.\n  constexpr int kMaxPropertiesForTypeName = 5;\n  bool truncated = false;\n  if (propertyNames.size() > kMaxPropertiesForTypeName) {\n    propertyNames.erase(\n        propertyNames.begin() + kMaxPropertiesForTypeName, propertyNames.end());\n    truncated = true;\n  }\n  // The final name should look like Object(a, b, c).\n  if (propertyNames.empty()) {\n    // Don't add parentheses for objects with no properties.\n    return name;\n  }\n  name += \"(\";\n  bool first = true;\n  for (const auto &prop : propertyNames) {\n    if (!first) {\n      name += \", \";\n    }\n    first = false;\n    name += prop;\n  }\n  if (truncated) {\n    // No need to check for comma edge case because this only happens for\n    // greater than one property.\n    static_assert(\n        kMaxPropertiesForTypeName >= 1,\n        \"Property truncation should not happen for 0 properties\");\n    name += \", ...\";\n  }\n  name += \")\";\n  return name;\n}\n\nstd::string JSObject::getNameIfExists(PointerBase *base) {\n  // Try \"displayName\" first, if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::displayName))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // Next, use \"name\" if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::name))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // There is no other way to access the \"name\" property on an object.\n  return \"\";\n}\n\nstd::string JSObject::_snapshotNameImpl(GCCell *cell, GC *gc) {\n  auto *const self = vmcast<JSObject>(cell);\n  return self->getHeuristicTypeName(gc);\n}\n\nvoid JSObject::_snapshotAddEdgesImpl(GCCell *cell, GC *gc, HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n\n  // Add the prototype as a property edge, so it's easy for JS developers to\n  // walk the prototype chain on their own.\n  if (self->parent_) {\n    snap.addNamedEdge(\n        HeapSnapshot::EdgeType::Property,\n        // __proto__ chosen for similarity to V8.\n        \"__proto__\",\n        gc->getObjectID(self->parent_));\n  }\n\n  HiddenClass::forEachPropertyNoAlloc(\n      self->clazz_.get(gc->getPointerBase()),\n      gc->getPointerBase(),\n      [self, gc, &snap](SymbolID id, NamedPropertyDescriptor desc) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        // Else, it's a user-visible property.\n        GCHermesValue &prop =\n            namedSlotRef(self, gc->getPointerBase(), desc.slot);\n        const llvh::Optional<HeapSnapshot::NodeID> idForProp =\n            gc->getSnapshotID(prop);\n        if (!idForProp) {\n          return;\n        }\n        std::string propName = gc->convertSymbolToUTF8(id);\n        // If the property name is a valid array index, display it as an\n        // \"element\" instead of a \"property\". This will put square brackets\n        // around the number and sort it numerically rather than\n        // alphabetically.\n        if (auto index = ::hermes::toArrayIndex(propName)) {\n          snap.addIndexedEdge(\n              HeapSnapshot::EdgeType::Element,\n              index.getValue(),\n              idForProp.getValue());\n        } else {\n          snap.addNamedEdge(\n              HeapSnapshot::EdgeType::Property, propName, idForProp.getValue());\n        }\n      });\n}\n\nvoid JSObject::_snapshotAddLocationsImpl(\n    GCCell *cell,\n    GC *gc,\n    HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n  PointerBase *const base = gc->getPointerBase();\n  // Add the location of the constructor function for this object, if that\n  // constructor is a user-defined JS function.\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          self, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (constructorVal->isObject()) {\n      if (auto *constructor = dyn_vmcast<JSFunction>(*constructorVal)) {\n        constructor->addLocationToSnapshot(snap, gc->getObjectID(self));\n      }\n    }\n  }\n}\n\nstd::pair<uint32_t, uint32_t> JSObject::_getOwnIndexedRangeImpl(\n    JSObject *self,\n    Runtime *runtime) {\n  return {0, 0};\n}\n\nbool JSObject::_haveOwnIndexedImpl(JSObject *self, Runtime *, uint32_t) {\n  return false;\n}\n\nOptValue<PropertyFlags> JSObject::_getOwnIndexedPropertyFlagsImpl(\n    JSObject *self,\n    Runtime *runtime,\n    uint32_t) {\n  return llvh::None;\n}\n\nHermesValue JSObject::_getOwnIndexedImpl(JSObject *, Runtime *, uint32_t) {\n  return HermesValue::encodeEmptyValue();\n}\n\nCallResult<bool>\nJSObject::_setOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t, Handle<>) {\n  return false;\n}\n\nbool JSObject::_deleteOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t) {\n  return false;\n}\n\nbool JSObject::_checkAllOwnIndexedImpl(\n    JSObject * /*self*/,\n    Runtime * /*runtime*/,\n    ObjectVTable::CheckAllOwnIndexedMode /*mode*/) {\n  return true;\n}\n\nvoid JSObject::preventExtensions(JSObject *self) {\n  assert(\n      !self->flags_.proxyObject &&\n      \"[[Extensible]] slot cannot be set directly on Proxy objects\");\n  self->flags_.noExtend = true;\n}\n\nCallResult<bool> JSObject::preventExtensions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::preventExtensions(selfHandle, runtime, opFlags);\n  }\n  JSObject::preventExtensions(*selfHandle);\n  return true;\n}\n\nExecutionStatus JSObject::seal(Handle<JSObject> selfHandle, Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes && \"seal preventExtensions with ThrowOnError returned false\");\n\n  // Already sealed?\n  if (selfHandle->flags_.sealed)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllNonConfigurable(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::freeze(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes &&\n      \"freeze preventExtensions with ThrowOnError returned false\");\n\n  // Already frozen?\n  if (selfHandle->flags_.frozen)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllReadOnly(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nvoid JSObject::updatePropertyFlagsWithoutTransitions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropertyFlags flagsToClear,\n    PropertyFlags flagsToSet,\n    OptValue<llvh::ArrayRef<SymbolID>> props) {\n  auto newClazz = HiddenClass::updatePropertyFlagsWithoutTransitions(\n      runtime->makeHandle(selfHandle->clazz_),\n      runtime,\n      flagsToClear,\n      flagsToSet,\n      props);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n}\n\nCallResult<bool> JSObject::isExtensible(\n    PseudoHandle<JSObject> self,\n    Runtime *runtime) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return JSProxy::isExtensible(runtime->makeHandle(std::move(self)), runtime);\n  }\n  return self->isExtensible();\n}\n\nbool JSObject::isSealed(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.sealed)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllNonConfigurable(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::NonConfigurable)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nbool JSObject::isFrozen(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.frozen)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllReadOnly(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::ReadOnly)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nCallResult<bool> JSObject::addOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  /// Can we add more properties?\n  if (!selfHandle->isExtensible() && !opFlags.getInternalForce()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Cannot add new property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"'\");\n    }\n    return false;\n  }\n\n  PropertyFlags flags{};\n\n  // Accessors don't set writeable.\n  if (dpFlags.isAccessor()) {\n    dpFlags.setWritable = 0;\n    flags.accessor = 1;\n  }\n\n  // Override the default flags if specified.\n  if (dpFlags.setEnumerable)\n    flags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    flags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    flags.configurable = dpFlags.configurable;\n  flags.internalSetter = dpFlags.enableInternalSetter;\n\n  if (LLVM_UNLIKELY(\n          addOwnPropertyImpl(\n              selfHandle, runtime, name, flags, valueOrAccessor) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  return true;\n}\n\nExecutionStatus JSObject::addOwnPropertyImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"Internal properties cannot be added to Proxy objects\");\n  // Add a new property to the class.\n  // TODO: if we check for OOM here in the future, we must undo the slot\n  // allocation.\n  auto addResult = HiddenClass::addProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, name, propertyFlags);\n  if (LLVM_UNLIKELY(addResult == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  selfHandle->clazz_.set(runtime, *addResult->first, &runtime->getHeap());\n\n  allocateNewSlotStorage(\n      selfHandle, runtime, addResult->second, valueOrAccessor);\n\n  // If this is an index-like property, we need to clear the fast path flags.\n  if (LLVM_UNLIKELY(\n          selfHandle->clazz_.getNonNull(runtime)->getHasIndexLikeProperties()))\n    selfHandle->flags_.fastIndexProperties = false;\n\n  return ExecutionStatus::RETURNED;\n}\n\nCallResult<bool> JSObject::updateOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    HiddenClass::PropertyPos propertyPos,\n    NamedPropertyDescriptor desc,\n    const DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto updateStatus = checkPropertyUpdate(\n      runtime,\n      desc.flags,\n      dpFlags,\n      getNamedSlotValue(selfHandle.get(), runtime, desc),\n      valueOrAccessor,\n      opFlags);\n  if (updateStatus == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n  if (updateStatus->first == PropertyUpdateStatus::failed)\n    return false;\n\n  // If the property flags changed, update them.\n  if (updateStatus->second != desc.flags) {\n    desc.flags = updateStatus->second;\n    auto newClazz = HiddenClass::updateProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        propertyPos,\n        desc.flags);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  }\n\n  if (updateStatus->first == PropertyUpdateStatus::done)\n    return true;\n  assert(\n      updateStatus->first == PropertyUpdateStatus::needSet &&\n      \"unexpected PropertyUpdateStatus\");\n\n  if (dpFlags.setValue) {\n    if (LLVM_LIKELY(!desc.flags.internalSetter))\n      setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n    else\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueOrAccessor, opFlags);\n  } else if (dpFlags.isAccessor()) {\n    setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n  } else {\n    // If checkPropertyUpdate() returned needSet, but there is no value or\n    // accessor, clear the value.\n    setNamedSlotValue(\n        selfHandle.get(), runtime, desc, HermesValue::encodeUndefinedValue());\n  }\n\n  return true;\n}\n\nCallResult<std::pair<JSObject::PropertyUpdateStatus, PropertyFlags>>\nJSObject::checkPropertyUpdate(\n    Runtime *runtime,\n    const PropertyFlags currentFlags,\n    DefinePropertyFlags dpFlags,\n    const HermesValue curValueOrAccessor,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  // 8.12.9 [5] Return true, if every field in Desc is absent.\n  if (dpFlags.isEmpty())\n    return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n\n  assert(\n      (!dpFlags.isAccessor() || (!dpFlags.setWritable && !dpFlags.writable)) &&\n      \"can't set both accessor and writable\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"cannot change the value of internalSetter\");\n\n  // 8.12.9 [6] Return true, if every field in Desc also occurs in current and\n  // the value of every field in Desc is the same value as the corresponding\n  // field in current when compared using the SameValue algorithm (9.12).\n  // TODO: this would probably be much more efficient with bitmasks.\n  if ((!dpFlags.setEnumerable ||\n       dpFlags.enumerable == currentFlags.enumerable) &&\n      (!dpFlags.setConfigurable ||\n       dpFlags.configurable == currentFlags.configurable)) {\n    if (dpFlags.isAccessor()) {\n      if (currentFlags.accessor) {\n        auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n        auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n        if ((!dpFlags.setGetter ||\n             curAccessor->getter == newAccessor->getter) &&\n            (!dpFlags.setSetter ||\n             curAccessor->setter == newAccessor->setter)) {\n          return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n        }\n      }\n    } else {\n      if (!currentFlags.accessor &&\n          (!dpFlags.setValue ||\n           isSameValue(curValueOrAccessor, valueOrAccessor.get())) &&\n          (!dpFlags.setWritable || dpFlags.writable == currentFlags.writable)) {\n        return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n      }\n    }\n  }\n\n  // 8.12.9 [7]\n  // If the property is not configurable, some aspects are not changeable.\n  if (!currentFlags.configurable) {\n    // Trying to change non-configurable to configurable?\n    if (dpFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // Trying to change the enumerability of non-configurable property?\n    if (dpFlags.setEnumerable &&\n        dpFlags.enumerable != currentFlags.enumerable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n  }\n\n  PropertyFlags newFlags = currentFlags;\n\n  // 8.12.9 [8] If IsGenericDescriptor(Desc) is true, then no further validation\n  // is required.\n  if (!(dpFlags.setValue || dpFlags.setWritable || dpFlags.setGetter ||\n        dpFlags.setSetter)) {\n    // Do nothing\n  }\n  // 8.12.9 [9]\n  // Changing between accessor and data descriptor?\n  else if (currentFlags.accessor != dpFlags.isAccessor()) {\n    if (!currentFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // If we change from accessor to data descriptor, Preserve the existing\n    // values of the converted property\u2019s [[Configurable]] and [[Enumerable]]\n    // attributes and set the rest of the property\u2019s attributes to their default\n    // values.\n    // If it's the other way around, since the accessor doesn't have the\n    // [[Writable]] attribute, do nothing.\n    newFlags.writable = 0;\n\n    // If we are changing from accessor to non-accessor, we must set a new\n    // value.\n    if (!dpFlags.isAccessor())\n      dpFlags.setValue = 1;\n  }\n  // 8.12.9 [10] if both are data descriptors.\n  else if (!currentFlags.accessor) {\n    if (!currentFlags.configurable) {\n      if (!currentFlags.writable) {\n        // If the current property is not writable, but the new one is.\n        if (dpFlags.writable) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not configurable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n\n        // If we are setting a different value.\n        if (dpFlags.setValue &&\n            !isSameValue(curValueOrAccessor, valueOrAccessor.get())) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not writable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n      }\n    }\n  }\n  // 8.12.9 [11] Both are accessors.\n  else {\n    auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n    auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n    // If not configurable, make sure that nothing is changing.\n    if (!currentFlags.configurable) {\n      if ((dpFlags.setGetter && newAccessor->getter != curAccessor->getter) ||\n          (dpFlags.setSetter && newAccessor->setter != curAccessor->setter)) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"property is not configurable\"); // TODO: better message.\n        }\n        return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n      }\n    }\n\n    // If not setting the getter or the setter, re-use the current one.\n    if (!dpFlags.setGetter)\n      newAccessor->getter.set(\n          runtime, curAccessor->getter, &runtime->getHeap());\n    if (!dpFlags.setSetter)\n      newAccessor->setter.set(\n          runtime, curAccessor->setter, &runtime->getHeap());\n  }\n\n  // 8.12.9 [12] For each attribute field of Desc that is present, set the\n  // correspondingly named attribute of the property named P of object O to the\n  // value of the field.\n  if (dpFlags.setEnumerable)\n    newFlags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    newFlags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    newFlags.configurable = dpFlags.configurable;\n\n  if (dpFlags.setValue)\n    newFlags.accessor = false;\n  else if (dpFlags.isAccessor())\n    newFlags.accessor = true;\n  else\n    return std::make_pair(PropertyUpdateStatus::done, newFlags);\n\n  return std::make_pair(PropertyUpdateStatus::needSet, newFlags);\n}\n\nCallResult<bool> JSObject::internalSetter(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    NamedPropertyDescriptor /*desc*/,\n    Handle<> value,\n    PropOpFlags opFlags) {\n  if (vmisa<JSArray>(selfHandle.get())) {\n    if (name == Predefined::getSymbolID(Predefined::length)) {\n      return JSArray::setLength(\n          Handle<JSArray>::vmcast(selfHandle), runtime, value, opFlags);\n    }\n  }\n\n  llvm_unreachable(\"unhandled property in Object::internalSetter()\");\n}\n\nnamespace {\n\n/// Helper function to add all the property names of an object to an\n/// array, starting at the given index. Only enumerable properties are\n/// incluced. Returns the index after the last property added, but...\nCallResult<uint32_t> appendAllPropertyNames(\n    Handle<JSObject> obj,\n    Runtime *runtime,\n    MutableHandle<BigStorage> &arr,\n    uint32_t beginIndex) {\n  uint32_t size = beginIndex;\n  // We know that duplicate property names can only exist between objects in\n  // the prototype chain. Hence there should not be duplicated properties\n  // before we start to look at any prototype.\n  bool needDedup = false;\n  MutableHandle<> prop(runtime);\n  MutableHandle<JSObject> head(runtime, obj.get());\n  MutableHandle<StringPrimitive> tmpVal{runtime};\n  while (head.get()) {\n    GCScope gcScope(runtime);\n\n    // enumerableProps will contain all enumerable own properties from obj.\n    // Impl note: this is the only place where getOwnPropertyKeys will be\n    // called without IncludeNonEnumerable on a Proxy.  Everywhere else,\n    // trap ordering is specified but ES9 13.7.5.15 says \"The mechanics and\n    // order of enumerating the properties is not specified\", which is\n    // unusual.\n    auto cr =\n        JSObject::getOwnPropertyNames(head, runtime, true /* onlyEnumerable */);\n    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto enumerableProps = *cr;\n    auto marker = gcScope.createMarker();\n    for (unsigned i = 0, e = enumerableProps->getEndIndex(); i < e; ++i) {\n      gcScope.flushToMarker(marker);\n      prop = enumerableProps->at(runtime, i);\n      if (!needDedup) {\n        // If no dedup is needed, add it directly.\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n        continue;\n      }\n      // Otherwise loop through all existing properties and check if we\n      // have seen it before.\n      bool dupFound = false;\n      if (prop->isNumber()) {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            dupFound = val.getNumber() == prop->getNumber();\n          } else {\n            // val is string, prop is number.\n            tmpVal = val.getString();\n            auto valNum = toArrayIndex(\n                StringPrimitive::createStringView(runtime, tmpVal));\n            dupFound = valNum && valNum.getValue() == prop->getNumber();\n          }\n        }\n      } else {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            // val is number, prop is string.\n            auto propNum = toArrayIndex(StringPrimitive::createStringView(\n                runtime, Handle<StringPrimitive>::vmcast(prop)));\n            dupFound = propNum && (propNum.getValue() == val.getNumber());\n          } else {\n            dupFound = val.getString()->equals(prop->getString());\n          }\n        }\n      }\n      if (LLVM_LIKELY(!dupFound)) {\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n      }\n    }\n    // Continue to follow the prototype chain.\n    CallResult<PseudoHandle<JSObject>> parentRes =\n        JSObject::getPrototypeOf(head, runtime);\n    if (LLVM_UNLIKELY(parentRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = parentRes->get();\n    needDedup = true;\n  }\n  return size;\n}\n\n/// Adds the hidden classes of the prototype chain of obj to arr,\n/// starting with the prototype of obj at index 0, etc., and\n/// terminates with null.\n///\n/// \\param obj The object whose prototype chain should be output\n/// \\param[out] arr The array where the classes will be appended. This\n/// array is cleared if any object is unsuitable for caching.\nExecutionStatus setProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    MutableHandle<BigStorage> &arr) {\n  // Layout of a JSArray stored in the for-in cache:\n  // [class(proto(obj)), class(proto(proto(obj))), ..., null, prop0, prop1, ...]\n\n  if (!obj->shouldCacheForIn(runtime)) {\n    arr->clear(runtime);\n    return ExecutionStatus::RETURNED;\n  }\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  MutableHandle<> clazz(runtime);\n  GCScopeMarkerRAII marker{runtime};\n  while (head.get()) {\n    if (!head->shouldCacheForIn(runtime)) {\n      arr->clear(runtime);\n      return ExecutionStatus::RETURNED;\n    }\n    if (JSObject::Helper::flags(*head).lazyObject) {\n      // Ensure all properties have been initialized before caching the hidden\n      // class. Not doing this will result in changes to the hidden class\n      // when getOwnPropertyKeys is called later.\n      JSObject::initializeLazyObject(runtime, head);\n    }\n    clazz = HermesValue::encodeObjectValue(head->getClass(runtime));\n    if (LLVM_UNLIKELY(\n            BigStorage::push_back(arr, runtime, clazz) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = head->getParent(runtime);\n    marker.flush();\n  }\n  clazz = HermesValue::encodeNullValue();\n  return BigStorage::push_back(arr, runtime, clazz);\n}\n\n/// Verifies that the classes of obj's prototype chain still matches those\n/// previously prefixed to arr by setProtoClasses.\n///\n/// \\param obj The object whose prototype chain should be verified\n/// \\param arr Array previously populated by setProtoClasses\n/// \\return The index after the terminating null if everything matches,\n/// otherwise 0.\nuint32_t matchesProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    Handle<BigStorage> arr) {\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  uint32_t i = 0;\n  while (head.get()) {\n    HermesValue protoCls = arr->at(i++);\n    if (protoCls.isNull() || protoCls.getObject() != head->getClass(runtime) ||\n        head->isProxyObject()) {\n      return 0;\n    }\n    head = head->getParent(runtime);\n  }\n  // The chains must both end at the same point.\n  if (head || !arr->at(i++).isNull()) {\n    return 0;\n  }\n  assert(i > 0 && \"success should be positive\");\n  return i;\n}\n\n} // namespace\n\nCallResult<Handle<BigStorage>> getForInPropertyNames(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    uint32_t &beginIndex,\n    uint32_t &endIndex) {\n  Handle<HiddenClass> clazz(runtime, obj->getClass(runtime));\n\n  // Fast case: Check the cache.\n  MutableHandle<BigStorage> arr(runtime, clazz->getForInCache(runtime));\n  if (arr) {\n    beginIndex = matchesProtoClasses(runtime, obj, arr);\n    if (beginIndex) {\n      // Cache is valid for this object, so use it.\n      endIndex = arr->size();\n      return arr;\n    }\n    // Invalid for this object. We choose to clear the cache since the\n    // changes to the prototype chain probably affect other objects too.\n    clazz->clearForInCache(runtime);\n    // Clear arr to slightly reduce risk of OOM from allocation below.\n    arr = nullptr;\n  }\n\n  // Slow case: Build the array of properties.\n  auto ownPropEstimate = clazz->getNumProperties();\n  auto arrRes = obj->shouldCacheForIn(runtime)\n      ? BigStorage::createLongLived(runtime, ownPropEstimate)\n      : BigStorage::create(runtime, ownPropEstimate);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  arr = std::move(*arrRes);\n  if (setProtoClasses(runtime, obj, arr) == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  beginIndex = arr->size();\n  // If obj or any of its prototypes are unsuitable for caching, then\n  // beginIndex is 0 and we return an array with only the property names.\n  bool canCache = beginIndex;\n  auto end = appendAllPropertyNames(obj, runtime, arr, beginIndex);\n  if (end == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  endIndex = *end;\n  // Avoid degenerate memory explosion: if > 75% of the array is properties\n  // or classes from prototypes, then don't cache it.\n  const bool tooMuchProto = *end / 4 > ownPropEstimate;\n  if (canCache && !tooMuchProto) {\n    assert(beginIndex > 0 && \"cached array must start with proto classes\");\n#ifdef HERMES_SLOW_DEBUG\n    assert(beginIndex == matchesProtoClasses(runtime, obj, arr) && \"matches\");\n#endif\n    clazz->setForInCache(*arr, runtime);\n  }\n  return arr;\n}\n\n//===----------------------------------------------------------------------===//\n// class PropertyAccessor\n\nVTable PropertyAccessor::vt{CellKind::PropertyAccessorKind,\n                            cellSize<PropertyAccessor>()};\n\nvoid PropertyAccessorBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  const auto *self = static_cast<const PropertyAccessor *>(cell);\n  mb.addField(\"getter\", &self->getter);\n  mb.addField(\"setter\", &self->setter);\n}\n\n#ifdef HERMESVM_SERIALIZE\nPropertyAccessor::PropertyAccessor(Deserializer &d)\n    : GCCell(&d.getRuntime()->getHeap(), &vt) {\n  d.readRelocation(&getter, RelocationKind::GCPointer);\n  d.readRelocation(&setter, RelocationKind::GCPointer);\n}\n\nvoid PropertyAccessorSerialize(Serializer &s, const GCCell *cell) {\n  auto *self = vmcast<const PropertyAccessor>(cell);\n  s.writeRelocation(self->getter.get(s.getRuntime()));\n  s.writeRelocation(self->setter.get(s.getRuntime()));\n  s.endObject(cell);\n}\n\nvoid PropertyAccessorDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::PropertyAccessorKind && \"Expected PropertyAccessor\");\n  void *mem = d.getRuntime()->alloc(cellSize<PropertyAccessor>());\n  auto *cell = new (mem) PropertyAccessor(d);\n  d.endObject(cell);\n}\n#endif\n\nCallResult<HermesValue> PropertyAccessor::create(\n    Runtime *runtime,\n    Handle<Callable> getter,\n    Handle<Callable> setter) {\n  void *mem = runtime->alloc(cellSize<PropertyAccessor>());\n  return HermesValue::encodeObjectValue(\n      new (mem) PropertyAccessor(runtime, *getter, *setter));\n}\n\n} // namespace vm\n} // namespace hermes\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes -Xhermes-internal-test-methods -Xes6-proxy -non-strict -O -target=HBC %s | %FileCheck --match-full-lines %s\n\nlet isStrictMode = (function() { return this === undefined; })();\n\nfunction betterToString(value) {\n  if (Array.isArray(value)) {\n    return('[' +\n           ((typeof HermesInternal === 'object' && HermesInternal.isProxy(value))\n            ? \"Proxy:\" : \"\") +\n           value.map(betterToString).join(',') +\n           ']');\n  } else if (typeof HermesInternal === 'object' && HermesInternal.isProxy(value)) {\n    return '[Proxy]';\n  } else {\n    // This works reasonably if value is a symbol.\n    return String(value);\n  }\n}\n\n// This has a similar API to the Node.js assert object.\nlet assert = {\n  _isEqual: function(a, b) {\n    // Remember to check for NaN which does not compare as equal with itself.\n    return a === b || (Number.isNaN(a) && Number.isNaN(b));\n  },\n  equal: function(actual, expected, msg) {\n    if (!assert._isEqual(actual, expected)) {\n      assert.fail(\n        (msg ? msg + ' -- ' : '') +\n          'Not equal: actual <' +\n          betterToString(actual) +\n          '>, and expected <' +\n          betterToString(expected) +\n          '>',\n      );\n    }\n  },\n  _isArrayEqual: function(a, b) {\n    if (a.length !== b.length)\n      return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!assert._isEqual(a[i], b[i]))\n        return false;\n    }\n    return true;\n  },\n  arrayEqual: function(actual, expected, msg) {\n    if (!assert._isArrayEqual(actual, expected)) {\n      assert.fail(\n        (msg ? msg + ' -- ' : '') +\n          'Array not equal: actual <' +\n          betterToString(actual) +\n          '>, and expected <' +\n          betterToString(expected) +\n          '>',\n      );\n    }\n  },\n  deepEqual: function(actual, expected, msg) {\n    if (Array.isArray(actual)) {\n      msg = (msg ? msg + ' -- ' : '');\n      assert.equal(Array.isArray(expected), true, msg + \"length\");\n      assert.equal(actual.length, expected.length, msg + \"length\");\n      for (let i = 0; i < actual.length; i++) {\n        assert.deepEqual(actual[i], expected[i], \"values\");\n      }\n      assert.deepEqual(Object.getPrototypeOf(actual),\n                       Object.getPrototypeOf(expected),\n                       msg + \"prototype\");\n      return;\n    }\n    if (typeof actual === 'object') {\n      assert.equal(typeof expected, 'object', msg);\n      if (actual === null) {\n        assert.equal(expected, null, msg);\n        return;\n      }\n      assert.notEqual(expected, null, msg);\n      msg = (msg ? msg + ' -- ' : '');\n      assert.arrayEqual(Object.getOwnPropertyNames(actual).sort(),\n                        Object.getOwnPropertyNames(expected).sort(),\n                        msg + \"names\");\n      assert.arrayEqual(Object.getOwnPropertySymbols(actual),\n                        Object.getOwnPropertySymbols(expected),\n                        msg + \"symbols\");\n\n      for (p of Object.getOwnPropertyNames(expected)) {\n        assert.deepEqual(actual[p], expected[p],\n                         msg + \"property \" + betterToString(p));\n      }\n      for (p of Object.getOwnPropertySymbols(expected)) {\n        assert.deepEqual(actual[p], expected[p],\n                         msg + \"property \" + betterToString(p));\n      }\n      assert.deepEqual(Object.getPrototypeOf(actual),\n                       Object.getPrototypeOf(expected),\n                       msg);\n      return;\n    }\n    assert.equal(actual, expected, msg);\n  },\n  notEqual: function(actual, expected, msg) {\n    if (assert._isEqual(actual, expected)) {\n      assert.fail(\n        (msg ? msg + ' -- ' : '') +\n          'Equal: actual <' +\n          betterToString(actual) +\n          '>, and expected <' +\n          betterToString(expected) +\n          '>',\n      );\n    }\n  },\n  ok: function(value, msg) {\n    assert.equal(!!value, true, msg);\n  },\n  throws: function(block, error, msg) {\n    try {\n      block();\n    } catch (e) {\n      assert.equal(e.constructor, error, e.message + ' ' + msg);\n      return;\n    }\n    // Can't put fail inside the try because it will catch the AssertionError.\n    assert.fail((msg ? msg + ' -- ' : '') + 'Failed to throw');\n  },\n  fail: function(msg) {\n    throw new Error('AssertionError: ' + (msg ? msg : 'Failed'));\n  },\n};\n\nvar traps = [];\nvar currentProxy = undefined;\n\nfunction trapReturns(trapName, checkArgs, ret, target) {\n  let handler = {};\n  let proxy = new Proxy(target || {}, handler);\n  handler[trapName] = function trap(...trapArgs) {\n    print(trapName + ' trap (returns)');\n    traps.push(trapName);\n    assert.equal(this, handler);\n    assert.equal(trapArgs[0], target);\n    checkArgs(_ => trapArgs.slice(1));\n    return ret;\n  };\n  return proxy;\n}\n\nfunction TrapError(message) {\n  this.message = message || '';\n}\n\nTrapError.prototype.toString = function () {\n  return 'TrapError: ' + this.message;\n};\n\nfunction trapThrows(trap) {\n  function throwTarget() {}\n  return new Proxy(throwTarget, {\n    [trap]: function() {\n      print(trap + ' trap (throws)');\n      traps.push(trap);\n      throw new TrapError(trap);\n    }\n  });\n}\n\nfunction checkValue(value) {\n  return function checkValue(func, msg) {\n    assert.equal(func(), value, msg);\n  };\n}\n\nfunction checkArray(arr, alter = _ => _) {\n  return function checkArray(func, msg) {\n    assert.arrayEqual(alter(func()), arr, msg);\n  };\n}\n\nfunction checkDeep(expected) {\n  return function checkDeep(func, msg) {\n    assert.deepEqual(func(), expected, msg);\n  }\n}\n\nfunction checkElements(...checkers) {\n  return function checkElements(func, msg) {\n    let actual = func();\n    assert.equal(actual.length, checkers.length);\n    for (let i = 0; i < actual.length; ++i) {\n      checkers[i](_ => actual[i], msg);\n    }\n  };\n}\n\nfunction checkDesc(expected) {\n  return function checkDesc(func, msg) {\n    let actual = func();\n    if (expected === undefined && actual == undefined) {\n      return;\n    }\n    assert.notEqual(expected, undefined);\n    assert.notEqual(actual, undefined);\n    for (let p of ['configurable', 'enumerable', 'value', 'writable', 'get', 'set']) {\n      assert.equal(expected[p], actual[p], msg ? (msg + ' ' + p) : 'for ' + p);\n    }\n  };\n}\n\nfunction checkThrows(ex) {\n  return function checkThrows(func, msg) {\n    assert.throws(func, ex, msg);\n  };\n}\n\nfunction checkIf(pred) {\n  return function checkIf(func, msg) {\n    assert.equal(pred(func()), true, msg);\n  };\n}\n\nfunction checkStrictValue(value) {\n  if (isStrictMode) {\n    return checkThrows(TypeError);\n  } else {\n    return checkValue(value);\n  }\n}\n\nfunction checkUnimplemented(ex) {\n  return ((typeof HermesInternal === 'object')\n          ? checkThrows(TypeError)\n          : checkDeep(ex));\n}\n\nfunction checkTraps(arr) {\n  return function checkTraps(func, msg) {\n    assert.arrayEqual(traps, arr, msg);\n  };\n}\n\nfunction checkUnimplementedTraps(ex) {\n  return ((typeof HermesInternal === 'object')\n          ? checkArray([])\n          : checkArray(ex));\n}\n\nfunction checkProxy() {\n  return function checkProxy(func, msg) {\n    assert.equal(func(), currentProxy, msg);\n  };\n}\n\nfunction checkBoxed(value) {\n  return function checkBoxed(func, msg) {\n    let actual = func();\n    if (actual.constructor === Number) {\n      assert.equal(Number(actual), value);\n    } else if (actual.constructor === Boolean) {\n      assert.equal(Boolean(actual), value);\n    } else {\n      assert.equal(actual, value);\n    }\n  }\n}\n\nfunction checkAll(...funcs) {\n  return function checkAll(func, msg) {\n    let actual = func();\n    for (let f of funcs) {\n      f(_ => actual, msg);\n    }\n  };\n}\n\n// This function is used to describe a battery of tests for a\n// particular trap.  For each test:\n// * a target is created by calling targetFactory\n// * a Proxy is created using that target\n// * func is called on the proxy and target\n// * the result of calling the function is checked.\n//\n// a checker is a function which takes a function to call, calls it,\n// and asserts if it did something unexpected.  The checker can check\n// the return value, if an exception is thrown, etc.  The Function to\n// call calls func on an appropriately constructed proxy as below.\n//\n// This happens several times.\n// A. the noTrapChecker is called on a Proxy with no traps.\n// B. for each of a list of [value, checker], the checker is called\n//   on a Proxy with a trap which returns value.  The first argument to the trap\n//   is checked against target, and the rest with checkArgs.\n// C. a trap which throws a TrapError is checked that the exception\n//   makes it out to the caller.\n// D. the noTrapChecker is called on a revocable Proxy with no traps.\n//   The proxy is revoked, and the function is called again, expecting\n//   a TypeError.\n//\n// For each test, there is also a check that the expected trap was\n// called.\nfunction proxyTests(trap, func, targetFactory, noTrapChecker, checkArgs,\n                    trapCalls) {\n  // A.\n  let target = targetFactory();\n  traps = [];\n  currentProxy = new Proxy(target, {});\n  try {\n    noTrapChecker(_ => func(currentProxy, target),\n                  'for noTrap');\n  } catch (e) {\n    e.message += ' for noTrap';\n    throw e;\n  }\n  assert.arrayEqual(traps, [], 'for noTrap');\n  // B.\n  let i = 0;\n  for (let [trapRet, checker, trapChecker] of trapCalls) {\n    traps = [];\n    let target = targetFactory();\n    let msg = 'for trapRet ' + i + ' ' + betterToString(trapRet);\n    try {\n      currentProxy = trapReturns(trap, checkArgs, trapRet, target);\n      checker(_ => func(currentProxy, target), msg);\n    } catch (e) {\n      e.message += ' ' + msg;\n      throw e;\n    }\n    if (trapChecker) {\n      trapChecker(_ => traps, msg);\n    } else {\n      assert.arrayEqual(traps, [trap], msg);\n    }\n    ++i;\n  }\n  // C.\n  target = targetFactory();\n  traps = [];\n  currentProxy = trapThrows(trap);\n  checkThrows(TrapError)(_ => func(currentProxy, target),\n                         'for trapThrows');\n  assert.arrayEqual(traps, [trap], 'for trapThrows');\n  // D.\n  target = targetFactory();\n  traps = [];\n  let pr = Proxy.revocable(target, {});\n  currentProxy = pr.proxy;\n  try {\n    noTrapChecker(_ => func(currentProxy, target),\n                  'for revocable');\n  } catch (e) {\n    e.message += ' for revocable';\n    throw e;\n  }\n  pr.revoke();\n   checkThrows(TypeError)(\n    _ => func(currentProxy, target),\n    ' for revoked');\n  assert.arrayEqual(traps, [], 'for revoked');\n  traps = [];\n  currentProxy = undefined;\n}\n\nfunction restorePrototype(obj, func) {\n  let save = Object.getPrototypeOf(obj);\n  func();\n  Object.setPrototypeOf(obj, save);\n}\n\nlet base = {};\nlet obj = {a:1};\n\n// end helpers and standard values\n\nprint('getPrototypeOf');\n// CHECK-LABEL: getPrototypeOf\n\n// extensible target with non-null parent\nfor (let func of [Object.getPrototypeOf, proxy => proxy.__proto__]) {\n  proxyTests(\n    // This is the trap we are testing.\n    'getPrototypeOf',\n    // This is the function\n    func,\n    _ => Object.create(base),\n    checkValue(base),\n    checkArray([]),\n    [[base, checkValue(base)],\n     [obj, checkValue(obj)],\n     [17, checkThrows(TypeError)],\n     [null, checkValue(null)]]);\n}\n\nproxyTests(\n  'getPrototypeOf',\n  proxy => base.isPrototypeOf(proxy),\n  _ => Object.create(base),\n  checkValue(true),\n  checkArray([]),\n  [[base, checkValue(true)],\n   [obj, checkValue(false)],\n   [17, checkThrows(TypeError)],\n   [null, checkValue(false)]]);\n\n// non-extensible target with non-null parent\nproxyTests(\n  'getPrototypeOf',\n  Object.getPrototypeOf,\n  _ => Object.preventExtensions(Object.create(base)),\n  checkValue(base),\n  checkArray([]),\n  [[base, checkValue(base)],\n   [obj, checkThrows(TypeError)],\n   [17, checkThrows(TypeError)],\n   [null, checkThrows(TypeError)]]);\n\n// extensible target with null parent\nproxyTests(\n  'getPrototypeOf',\n  Object.getPrototypeOf,\n  _ => Object.create(null),\n  checkValue(null),\n  checkArray([]),\n  [[base, checkValue(base)],\n   [obj, checkValue(obj)],\n   [17, checkThrows(TypeError)],\n   [null, checkValue(null)]]);\n\n// non-extensible target with null parent\nproxyTests(\n  'getPrototypeOf',\n  Object.getPrototypeOf,\n  _ => Object.preventExtensions(Object.create(null)),\n  checkValue(null),\n  checkArray([]),\n  [[base, checkThrows(TypeError)],\n   [obj, checkThrows(TypeError)],\n   [17, checkThrows(TypeError)],\n   [null, checkValue(null)]]);\n\nlet ctorProto = {};\nfunction Ctor() { return this; };\nCtor.prototype = ctorProto;\nlet ctorObj = new Ctor();\n\nproxyTests(\n  'getPrototypeOf',\n  proxy => proxy instanceof Ctor,\n  _ => ctorObj,\n  checkValue(true),\n  checkArray([]),\n  [[ctorObj, checkValue(true)],\n   [ctorProto, checkValue(true)],\n   [{}, checkValue(false)],\n   [17, checkThrows(TypeError)]]);\n\nprint('setPrototypeOf');\n// CHECK-LABEL: setPrototypeOf\n\nfor (let func of [proxy => assert.equal(Object.setPrototypeOf(proxy, base), proxy),\n                  proxy => proxy.__proto__ = base]) {\n  proxyTests(\n    'setPrototypeOf',\n    function (proxy, target) {\n      func(proxy);\n      let a = Object.getPrototypeOf(target);\n      let b = Object.getPrototypeOf(proxy);\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({}),\n    checkValue(base),\n    checkArray([base]),\n    [[true, checkValue(Object.prototype)],\n     [false, checkThrows(TypeError)]]);\n}\n\nprint('isExtensible');\n// CHECK-LABEL: isExtensible\n\n// extensible object\nproxyTests(\n  'isExtensible',\n  Object.isExtensible,\n  _ => ({}),\n  checkValue(true),\n  checkArray([]),\n  [[true, checkValue(true)],\n   [false, checkThrows(TypeError)]]);\n\n// non-extensible object\nproxyTests(\n  'isExtensible',\n  Object.isExtensible,\n  _ => Object.preventExtensions({}),\n  checkValue(false),\n  checkArray([]),\n  [[false, checkValue(false)],\n   [true, checkThrows(TypeError)]]);\n\nprint('preventExtensions');\n// CHECK-LABEL: preventExtensions\n\n// extensible object\nproxyTests(\n  'preventExtensions',\n  function (proxy, target) {\n    assert.equal(Object.preventExtensions(proxy), proxy);\n    let a = Object.isExtensible(target);\n    let b = Object.isExtensible(proxy);\n    assert.equal(a, b);\n    return !a;\n  },\n  _ => ({}),\n  checkValue(true),\n  checkArray([]),\n  [[true, checkThrows(TypeError)],\n   [false, checkThrows(TypeError)]]);\n\n// non-extensible object\nproxyTests(\n  'preventExtensions',\n  function (proxy, target) {\n    assert.equal(Object.preventExtensions(proxy), proxy);\n    let a = Object.isExtensible(target);\n    let b = Object.isExtensible(proxy);\n    assert.equal(a, b);\n    return !a;\n  },\n  _ => Object.preventExtensions({}),\n  checkValue(true),\n  checkArray([]),\n  [[true, checkValue(true)],\n   [false, checkThrows(TypeError)]]);\n\nprint('getOwnPropertyDescriptor');\n// CHECK-LABEL: getOwnPropertyDescriptor\n\n// writable value prop\nfunction getter() { return 'foo'; }\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => Object.getOwnPropertyDescriptor(proxy, 'prop'),\n  _ => ({prop: 1}),\n  checkDesc({configurable: true, enumerable: true, writable: true, value: 1}),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: true, value: 3},\n    checkDesc({configurable: true, enumerable: true, writable: true, value: 3})],\n   [{configurable: true, enumerable: true, writable: false, value: 4},\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 4})],\n   [{configurable: false, enumerable: true, writable: false, value: 5},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, get: getter},\n    checkDesc({configurable: true, enumerable: true, get: getter})]]);\n\n// writable accessor prop\nfunction getfoo() { return 'foo'; }\nfunction getbar() { return 'bar'; }\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => Object.getOwnPropertyDescriptor(proxy, 'prop'),\n  _ => Object.create(Object.prototype,\n                     {prop: {configurable: true, enumerable: true, get: getfoo}}),\n  checkDesc({configurable: true, enumerable: true, get: getfoo}),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: true, value: 3},\n    checkDesc({configurable: true, enumerable: true, writable: true, value: 3})],\n   [{configurable: true, enumerable: true, writable: false, value: 4},\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 4})],\n   [{configurable: false, enumerable: true, writable: false, value: 5},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, get: getbar},\n    checkDesc({configurable: true, enumerable: true, get: getbar})]]);\n\n// non-configurable, non-writable value prop\nproxyTests(\n  'getOwnPropertyDescriptor',\n  function (proxy) {\n    return Object.getOwnPropertyDescriptor(proxy, 'prop');\n  },\n  _ => Object.freeze({prop: 1}),\n  checkDesc({configurable: false, enumerable: true, writable: false, value: 1}),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: true, value: 1},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: false, value: 1},\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: false, value: 4},\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, get: getter},\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: false, value: 1},\n    checkDesc({configurable: false, enumerable: true, writable: false, value: 1})]]);\n\n// no prop\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => Object.getOwnPropertyDescriptor(proxy, 'prop'),\n  _ => ({}),\n  checkValue(undefined),\n  checkArray(['prop']),\n  [[2,\n    checkThrows(TypeError)],\n   [{configurable: false, enumerable: true, writable: true, value: 1},\n    checkThrows(TypeError)],\n   [{configurable: true, enumerable: true, writable: false, value: 2},\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 2})],\n   [{configurable: true, enumerable: true, writable: true, value: 3},\n    checkDesc({configurable: true, enumerable: true, writable: true, value: 3})],\n   [{configurable: true, enumerable: true, get: getter},\n    checkDesc({configurable: true, enumerable: true, get: getter})]]);\n\n// hasOwnProperty true.  doesn't call 'has' trap\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.hasOwnProperty('prop'),\n  _ => ({prop: 1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(true)],\n   [undefined,\n    checkValue(false)]]);\n\n// hasOwnProperty false.  doesn't call 'has' trap\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.hasOwnProperty('prop'),\n  _ => ({}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(true)],\n   [undefined,\n    checkValue(false)]]);\n\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.propertyIsEnumerable('prop'),\n  _ => ({}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(false)],\n   [undefined,\n    checkValue(false)]]);\n\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.propertyIsEnumerable('prop'),\n  _ => Object.create(Object.prototype,\n                     {prop: {configurable: true, enumerable: false,\n                             writeable: true, value: 1}}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 1},\n    checkValue(true)],\n   [{configurable: true, enumerable: false, writable: true, value: 1},\n    checkValue(false)],\n   [undefined,\n    checkValue(false)]]);\n\nfunction setfoo() {}\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.__lookupGetter__('prop'),\n  _ => Object.create(Object.prototype, {prop: {\n    configurable: true,\n    enumerable: true,\n    get: getfoo,\n  }}),\n  checkValue(getfoo),\n  checkArray(['prop']),\n  [[{configurable: true, enumerable: true, writable: true, value: 3},\n    checkValue(undefined)],\n   [{configurable: true, enumerable: true, get: getbar},\n    checkValue(getbar)]]);\n\n// Function.prototype.bind uses getOwnPropertyDescriptor trap and get\n// to determine length (see ES9 19.2.3.2)\nproxyTests(\n  'getOwnPropertyDescriptor',\n  proxy => proxy.bind(obj).length,\n  _ => function(one, two, three) {},\n  checkValue(3),\n  checkArray(['length']),\n  []);\n\n// Try above test with lazy and non-lazy functions\n\nprint('defineProperty');\n// CHECK-LABEL: defineProperty\n\n// add new property\nvar desc = {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 1,\n};\nproxyTests(\n  'defineProperty',\n  function (proxy, target) {\n    let ret = Object.defineProperty(proxy, 'prop', desc);\n    assert.equal(ret, proxy);\n    let a = Object.getOwnPropertyDescriptor(target, 'prop');\n    let b = Object.getOwnPropertyDescriptor(proxy, 'prop');\n    if (a !== undefined || b !== undefined) {\n      checkDesc(a)(_ => b);\n    }\n    return a;\n  },\n  _ => ({}),\n  checkDesc(desc),\n  checkElements(\n    checkValue('prop'),\n    checkDesc(desc)),\n  [[true, checkValue(undefined)],\n   [false, checkThrows(TypeError)]]);\n\n// modify existing property\nproxyTests(\n  'defineProperty',\n  function (proxy, target) {\n    let ret = Object.defineProperty(proxy, 'prop', desc);\n    assert.equal(ret, proxy);\n    let a = Object.getOwnPropertyDescriptor(target, 'prop');\n    let b = Object.getOwnPropertyDescriptor(proxy, 'prop');\n    if (a !== undefined || b !== undefined) {\n      checkDesc(a)(_ => b);\n    }\n    return a;\n  },\n  _ => Object.create(Object.prototype, {prop: {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n    value: 2,\n  }}),\n  checkDesc(desc),\n  checkElements(\n    checkValue('prop'),\n    checkDesc(desc)),\n  [[true,\n    checkDesc({configurable: true, enumerable: true, writable: false, value: 2})],\n   [false,\n    checkThrows(TypeError)]]);\n\n// proxy validation failure\nvar desc = {\n  configurable: false,\n  enumerable: true,\n  writable: true,\n  value: 1,\n};\nproxyTests(\n  'defineProperty',\n  function (proxy, target) {\n    let ret = Object.defineProperty(proxy, 'prop', desc);\n    assert.equal(ret, proxy);\n    let a = Object.getOwnPropertyDescriptor(target, 'prop');\n    let b = Object.getOwnPropertyDescriptor(proxy, 'prop');\n    checkDesc(a)(_ => b);\n    return a;\n  },\n  _ => Object.create(Object.prototype, {prop: {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n    value: 2,\n  }}),\n  checkDesc(desc),\n  checkElements(\n    checkValue('prop'),\n    checkDesc(desc)),\n  [[true,\n    checkThrows(TypeError)],\n   [false,\n    checkThrows(TypeError)]]);\n\nprint('has');\n// CHECK-LABEL: has\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({}),\n  checkValue(false),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => ({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkValue(false)],\n   [true, checkValue(true)]]);\n\nproxyTests(\n  'has',\n  proxy => 'prop' in proxy,\n  _ => Object.preventExtensions({prop:1}),\n  checkValue(true),\n  checkArray(['prop']),\n  [[false, checkThrows(TypeError)],\n   [true, checkValue(true)]]);\n\nprint('get');\n// CHECK-LABEL: get\n\n// Using computedProp as a key should guarantee 'getComputed' behavior.\nvar computedProp = 'prop';\nfor (let func of [proxy => proxy.prop,\n                  proxy => proxy[computedProp]]) {\n  // prop does not exist\n  proxyTests(\n    'get',\n    func,\n    _ => ({}),\n    checkValue(undefined),\n    checkElements(\n      checkValue('prop'),\n      checkProxy()),\n    [[false, checkValue(false)],\n     ['hello', checkValue('hello')]]);\n\n  // prop exists\n  proxyTests(\n    'get',\n    func,\n    _ => ({prop:1}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkProxy()),\n    [[false, checkValue(false)],\n     ['hello', checkValue('hello')]]);\n\n  // validation fail\n  proxyTests(\n    'get',\n    func,\n    _ => Object.create(\n      Object.prototype,\n      {prop: {configurable: false, enumerable: true, writable: false, value: 1}}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkProxy()),\n    [[1, checkValue(1)],\n     ['hello', checkThrows(TypeError)]]);\n}\n\n// parent is proxy\nvar child = {};\nproxyTests(\n  'get',\n  function (proxy) {\n    Object.setPrototypeOf(child, proxy);\n    return child.prop;\n  },\n  _ => ({prop:1}),\n  checkValue(1),\n  checkElements(\n    checkValue('prop'),\n    checkValue(child)),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]);\n\n// numeric prop (trap gets a string)\nproxyTests(\n  'get',\n  proxy => proxy[3],\n  _ => [1,2,3,4,5],\n  checkValue(4),\n  checkElements(\n    checkValue(\"3\"),\n    checkProxy()),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]);\n\n// symbol prop\nproxyTests(\n  'get',\n  proxy => proxy[Symbol.for('symprop')],\n  _ => ({[Symbol.for('symprop')]:1}),\n  checkValue(1),\n  checkElements(\n    checkValue(Symbol.for('symprop')),\n    checkProxy()),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]);\n\n// transient get\nrestorePrototype(Number.prototype, _ => proxyTests(\n  'get',\n  function (proxy, target) {\n    Object.setPrototypeOf(Number.prototype, proxy);\n    return (5).prop;\n  },\n  _ => ({}),\n  checkValue(undefined),\n  checkArray(['prop', 5]),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]));\n\n// transient get has prop\nrestorePrototype(Number.prototype, _ => proxyTests(\n  'get',\n  function (proxy, target) {\n    Object.setPrototypeOf(Number.prototype, proxy);\n    return (5).prop;\n  },\n  _ => ({prop:1}),\n  checkValue(1),\n  checkArray(['prop', 5]),\n  [[false, checkValue(false)],\n   ['hello', checkValue('hello')]]));\n\nprint('set');\n// CHECK-LABEL: set\n\nfor (let func of [proxy => proxy.prop = 1,\n                  proxy => proxy[computedProp] = 1]) {\n  // set new property\n  proxyTests(\n    'set',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkValue(1),\n      checkProxy()),\n    [[false, checkStrictValue(undefined)],\n     [true, checkValue(undefined)]]);\n\n  // overwrite existing property\n  proxyTests(\n    'set',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({prop:2}),\n    checkValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkValue(1),\n      checkProxy()),\n    [[false, checkStrictValue(2)],\n     [true, checkValue(2)]]);\n\n  // validation fail\n  proxyTests(\n    'set',\n    func,\n    _ => Object.create(\n      Object.prototype,\n      {prop: {configurable: false, enumerable: true, writable: false, value: 2}}),\n    checkStrictValue(1),\n    checkElements(\n      checkValue('prop'),\n      checkValue(1),\n      checkProxy()),\n    [[false, checkStrictValue(1)],\n     [true, checkThrows(TypeError)]]);\n}\n\n// parent is proxy\nvar child = {};\nproxyTests(\n  'set',\n  function (proxy) {\n    // child gets reused, so clean it up, if we modified it.\n    delete child.prop;\n    Object.setPrototypeOf(child, proxy);\n    child.prop = 2;\n    return child.prop;\n  },\n  _ => ({prop:1}),\n  checkValue(2),\n  checkElements(\n    checkValue('prop'),\n    checkValue(2),\n    checkValue(child)),\n  [[false, checkStrictValue(1)],\n   [true, checkValue(1)]]);\n\n// symbol prop\nproxyTests(\n  'set',\n  function (proxy, target) {\n    proxy[Symbol.for('symprop')] = 1;\n    let a = target[Symbol.for('symprop')];\n    let b = proxy[Symbol.for('symprop')];\n    assert.equal(a, b);\n    return a;\n  },\n  _ => ({[Symbol.for('symprop')]:2}),\n  checkValue(1),\n  checkElements(\n    checkValue(Symbol.for('symprop')),\n    checkValue(1),\n    checkProxy()),\n  [[false, checkStrictValue(2)],\n   [true, checkValue(2)]]);\n\n// transient set\nrestorePrototype(Number.prototype, _ => proxyTests(\n  'set',\n  function (proxy, target) {\n    Object.setPrototypeOf(Number.prototype, proxy);\n    (5).prop = 10;\n  },\n  _ => ({}),\n  checkStrictValue(undefined),\n  checkArray(['prop', 10, 5]),\n  [[false, checkStrictValue(undefined)],\n   [true, checkValue(undefined)]]));\n\nprint('deleteProperty');\n// CHECK-LABEL: deleteProperty\n\nfor (let func of [proxy => delete proxy.prop,\n                  proxy => delete proxy[computedProp]]) {\n  // delete non-existent property\n  proxyTests(\n    'deleteProperty',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({}),\n    checkValue(undefined),\n    checkArray(['prop']),\n    [[false, checkStrictValue(undefined)],\n     [true, checkValue(undefined)]]);\n\n  // delete existing property\n  proxyTests(\n    'deleteProperty',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => ({prop:2}),\n    checkValue(undefined),\n    checkArray(['prop']),\n    [[false, checkStrictValue(2)],\n     [true, checkValue(2)]]);\n\n  // validation fail\n  proxyTests(\n    'deleteProperty',\n    function (proxy, target) {\n      func(proxy);\n      let a = target.prop;\n      let b = proxy.prop;\n      assert.equal(a, b);\n      return a;\n    },\n    _ => Object.create(\n      Object.prototype,\n      {prop: {configurable: false, enumerable: true, writable: false, value: 2}}),\n    checkStrictValue(2),\n    checkArray(['prop']),\n    [[false, checkStrictValue(2)],\n     [true, checkThrows(TypeError)]]);\n}\n\nprint('ownKeys');\n// CHECK-LABEL: ownKeys\n\nproxyTests(\n  'ownKeys',\n  Object.getOwnPropertyNames,\n  _ => ({a:1, b:2, [Symbol.for('c')]:3, [Symbol.for('d')]:4}),\n  checkArray(['a', 'b']),\n  checkArray([]),\n  [[['e', Symbol.for('f'), 'g', Symbol.for('h')],\n    checkArray(['e', 'g'])]]);\n\nproxyTests(\n  'ownKeys',\n  Object.getOwnPropertySymbols,\n  _ => ({a:1, b:2, [Symbol.for('c')]:3, [Symbol.for('d')]:4}),\n  checkArray([Symbol.for('c'), Symbol.for('d')]),\n  checkArray([]),\n  [[['e', Symbol.for('f'), 'g', Symbol.for('h')],\n    checkArray([Symbol.for('f'), Symbol.for('h')])]]);\n\n// validation fail\nproxyTests(\n  'ownKeys',\n  Object.getOwnPropertyNames,\n  _ => Object.preventExtensions({a:1, b:2}),\n  checkArray(['a', 'b']),\n  checkArray([]),\n  [[['a', 'b'],\n    checkArray(['a', 'b'])],\n   [['e', 'g'],\n    checkThrows(TypeError)]]);\n\nprint('apply');\n// CHECK-LABEL: apply\n\n// call with no this specified\nproxyTests(\n  'apply',\n  proxy => proxy(1),\n  _ => function (a) { return [this, a + 2]; },\n  checkArray([isStrictMode ? undefined : globalThis, 3]),\n  checkDeep([undefined, [1]]),\n  [[4, checkValue(4)],\n   ['hello', checkValue('hello')]]);\n\n// call throws exception\nproxyTests(\n  'apply',\n  proxy => proxy(1),\n  _ => function (a) { throw new Error(\"fail\"); },\n  checkThrows(Error),\n  checkDeep([undefined, [1]]),\n  [])\n\n// specify undefined, null this\nfor (let testThis of [undefined, null]) {\n  for (let func of [proxy => proxy.bind(testThis)(1),\n                    proxy => proxy.call(testThis, 1)]) {\n    proxyTests(\n      'apply',\n      func,\n      _ => function (a) { return [this, a + 2]; },\n      checkArray([isStrictMode ? testThis : globalThis, 3]),\n      checkElements(\n        checkValue(testThis),\n        checkArray([1])),\n      [[4, checkValue(4)],\n       ['hello', checkValue('hello')]]);\n  }\n}\n\n// specify some this objects\nfor (let testThis of [obj, [1,2,3], _ => 4]) {\n  for (let func of [proxy => proxy.bind(testThis)(1),\n                    proxy => proxy.call(testThis, 1)]) {\n    proxyTests(\n      'apply',\n      func,\n      _ => function (a) { return [this, a + 2]; },\n      checkArray([testThis, 3]),\n      checkElements(\n        checkValue(testThis),\n        checkArray([1])),\n      [[4, checkValue(4)],\n       ['hello', checkValue('hello')]]);\n  }\n}\n\n// Specify some this primitives (they get boxed)\nfor (let testThis of [5, true]) {\n  for (let func of [proxy => proxy.bind(testThis)(1),\n                    proxy => proxy.call(testThis, 1)]) {\n    proxyTests(\n      'apply',\n      func,\n      _ => function (a) { return [this, a + 2]; },\n      checkElements(\n        checkBoxed(testThis),\n        checkValue(3)),\n      checkElements(\n        checkValue(testThis),\n        checkArray([1])),\n      [[4, checkValue(4)],\n       ['hello', checkValue('hello')]]);\n  }\n}\n\nprint('construct');\n// CHECK-LABEL: construct\n\nfunction testTargetCtor (a) { this.a = a; return this; }\nfunction testCtor1 (a) { return this; }\nfunction testCtor2 (a) { this.a = 2; return this; }\nvar x = new Ctor();\nprint(x, x.constructor);\nproxyTests(\n  'construct',\n  function (proxy) {\n    let o = new proxy(1);\n    return [o.constructor, o.a];\n  },\n  _ => testTargetCtor,\n  checkArray([testTargetCtor, 1]),\n  checkElements(\n    checkArray([1]),\n    checkProxy()),\n  [[new testCtor1(),\n    checkArray([testCtor1, undefined])],\n   [new testCtor2(),\n    checkArray([testCtor2, 2])],\n   ['hello',\n    checkThrows(TypeError)]]);\n\n// test target is not a ctor.  Note that the trap isn't called, so\n// proxyTests's assumptions would fail.\nvar p = new Proxy(_ => _, {});\nassert.throws(_ => new p(), TypeError);\nvar p = new Proxy(_ => _, { construct() { assert.fail(\"trap called\"); }});\nassert.throws(_ => new p(), TypeError);\n\nprint('ProxyCreate');\n// CHECK-LABEL: ProxyCreate\n\nfor (let val of [undefined, null, true, 17, \"string\"]) {\n  assert.throws(_ => new Proxy(val, {}), TypeError);\n  assert.throws(_ => new Proxy({}, val), TypeError);\n}\n\n// Check that adding slots to the revoker function works as expected.\n\nvar pr = Proxy.revocable({}, {});\npr.revoke.prop = 1;\nassert.equal(pr.revoke.prop, 1);\npr.revoke();\nassert.equal(pr.revoke.prop, 1);\n\nassert.throws(_=> pr.proxy.foo, TypeError);\nassert.ok(_=> new Proxy(pr.proxy, {}), \"ProxyCreate using revoked proxies should be allowed.\");\nassert.ok(_=> new Proxy({}, pr.proxy), \"ProxyCreate using revoked proxies should be allowed.\");\n\nprint('Array.isArray');\n// CHECK-LABEL: Array.isArray\n\nvar a = [];\nvar ap = new Proxy(a, {});\nvar app = new Proxy(ap, {});\nassert.equal(Array.isArray(app), true);\n\nprint('multitraps');\n// CHECK-LABEL: multitraps\n\nfunction spyTraps(output) {\n  return {\n    has(target, key) {\n      output.push(\"has:\" + betterToString(key));\n      print(output[output.length - 1]);\n      return key in target;\n    },\n    get(target, key) {\n      output.push(\"get:\" + betterToString(key));\n      print(output[output.length - 1]);\n      return target[key];\n    },\n    set(target, key, value) {\n      output.push(\"set:\" + betterToString(key));\n      print(output[output.length - 1]);\n      target[key] = value;\n      return true;\n    },\n    deleteProperty(target, key) {\n      output.push(\"delete:\" + betterToString(key));\n      print(output[output.length - 1]);\n      delete target[key];\n      return true;\n    },\n    ownKeys(target) {\n      output.push(\"ownKeys\");\n      print(output[output.length - 1]);\n      return Object.getOwnPropertyNames(target).concat(\n        Object.getOwnPropertySymbols(target));\n    },\n    getOwnPropertyDescriptor(target, key) {\n      output.push(\"getOwnPropertyDescriptor:\" + betterToString(key));\n      print(output[output.length - 1]);\n      return Object.getOwnPropertyDescriptor(target, key);\n    },\n  };\n};\n\nvar sourceParent = Object.defineProperties({}, {\n  pa:{value:11, writable:true, configurable:true, enumerable: true},\n  pb:{value:12, writable:true, configurable:true, enumerable: false},\n  [Symbol.for('pc')]:{value:13, writable:true, configurable:true, enumerable: true},\n  [Symbol.for('pd')]:{value:14, writable:true, configurable:true, enumerable: false},\n});\n\nvar source = Object.create(sourceParent, {\n  ca:{value:21, writable:true, configurable:true, enumerable: true},\n  cb:{value:22, writable:true, configurable:true, enumerable: false},\n  [Symbol.for('cc')]:{value:23, writable:true, configurable:true, enumerable: true},\n  [Symbol.for('cd')]:{value:24, writable:true, configurable:true, enumerable: false},\n});\n\nvar sourceArray = [10,20,30];\n\nassert.equal(Object.getOwnPropertyNames(sourceParent).length, 2);\nassert.equal(Object.getOwnPropertySymbols(sourceParent).length, 2);\nassert.equal(Object.getOwnPropertyNames(source).length, 2);\nassert.equal(Object.getOwnPropertySymbols(source).length, 2);\n\nfunction multiTests(source, func, checkResult, checkTraps) {\n  checkResult(_ => func(source), \"for source\");\n\n  var output = [];\n  checkResult(_ => func(new Proxy(source, spyTraps(output))), \"for proxy\");\n  checkTraps(_ => output);\n}\n\n// own\n\nmultiTests(\n  source,\n  Object.getOwnPropertyDescriptors,\n  checkDeep({\n    ca:{value:21, writable:true, configurable:true, enumerable: true},\n    cb:{value:22, writable:true, configurable:true, enumerable: false},\n    [Symbol.for('cc')]:{value:23, writable:true, configurable:true, enumerable: true},\n    [Symbol.for('cd')]:{value:24, writable:true, configurable:true, enumerable: false},\n  }),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb',\n    'getOwnPropertyDescriptor:Symbol(cc)',\n    'getOwnPropertyDescriptor:Symbol(cd)']));\n\nmultiTests(\n  sourceArray,\n  Object.getOwnPropertyDescriptors,\n  checkDeep({\n    0:{value:10, writable:true, configurable:true, enumerable: true},\n    1:{value:20, writable:true, configurable:true, enumerable: true},\n    2:{value:30, writable:true, configurable:true, enumerable: true},\n    length:{value:3, writable:true, configurable:false, enumerable: false},\n  }),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'getOwnPropertyDescriptor:1',\n    'getOwnPropertyDescriptor:2',\n    'getOwnPropertyDescriptor:length']));\n\n// enumerable own\nfor (let func of [_ => Object.assign({}, _),\n                  _ => ({..._})]) {\n  multiTests(\n    source,\n    func,\n    checkDeep({ca:21, [Symbol.for('cc')]:23}),\n    checkArray(['ownKeys',\n                'getOwnPropertyDescriptor:ca',\n                'get:ca',\n                'getOwnPropertyDescriptor:cb',\n                'getOwnPropertyDescriptor:Symbol(cc)',\n                'get:Symbol(cc)',\n                'getOwnPropertyDescriptor:Symbol(cd)']));\n\n  multiTests(\n    sourceArray,\n    func,\n    checkDeep({0:10, 1:20, 2:30}),\n    checkArray(['ownKeys',\n                'getOwnPropertyDescriptor:0',\n                'get:0',\n                'getOwnPropertyDescriptor:1',\n                'get:1',\n                'getOwnPropertyDescriptor:2',\n                'get:2',\n                'getOwnPropertyDescriptor:length']));\n}\n\nvar descriptors = Object.defineProperties({}, {\n  pa: {\n    value: Object.getOwnPropertyDescriptor(sourceParent, 'pa'),\n    writable: true,\n    configurable: true,\n    enumerable: true,\n  },\n  pb: {\n    value: Object.getOwnPropertyDescriptor(sourceParent, 'pb'),\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  },\n  ca: {\n    value: Object.getOwnPropertyDescriptor(source, 'ca'),\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  },\n  cb: {\n    value: Object.getOwnPropertyDescriptor(source, 'cb'),\n    writable: true,\n    configurable: true,\n    enumerable: true,\n  },\n  x: {\n    value: \"i-am-not-a-descriptor\",\n    writable: true,\n    configurable: true,\n    enumerable: false, // and non-enumerable props aren't used descriptors\n  },\n});\n\nmultiTests(\n  descriptors,\n  descs => Object.defineProperties({}, descs),\n  checkDeep({pa: 11, cb: 22}),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:pa',\n    'get:pa',\n    'getOwnPropertyDescriptor:pb',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb',\n    'get:cb',\n    'getOwnPropertyDescriptor:x']));\n\n// enumerable strings\nmultiTests(\n  source,\n  function(obj) {\n    let keys = [];\n    for (let key in obj) {\n      keys.push(key);\n    }\n    return keys;\n  },\n  checkArray(['ca', 'pa']),\n  checkArray(['ownKeys',\n              'getOwnPropertyDescriptor:ca',\n              'getOwnPropertyDescriptor:cb'],\n             function(actual) {\n               // d8 does this.  It's weird.  I don't know why.\n               if (typeof HermesInternal !== 'object') {\n                 if (actual[actual.length - 1] === 'getOwnPropertyDescriptor:pa') {\n                   --actual.length;\n                 }\n               }\n               return actual;\n             }));\n\nmultiTests(\n  sourceArray,\n  function(obj) {\n    let keys = [];\n    for (let key in obj) {\n      keys.push(key);\n    }\n    return keys;\n  },\n  checkArray([\"0\", '1', '2']),\n  checkArray(['ownKeys',\n              'getOwnPropertyDescriptor:0',\n              'getOwnPropertyDescriptor:1',\n              'getOwnPropertyDescriptor:2',\n              'getOwnPropertyDescriptor:length']));\n\n// iteration\nmultiTests(\n  sourceArray,\n  function(iterable) {\n    let values = [];\n    for (let value of iterable) {\n      values.push(value);\n    }\n    return values;\n  },\n  checkArray([10,20,30]),\n  checkArray([\n    'get:Symbol(Symbol.iterator)',\n    'get:length',\n    'get:0',\n    'get:length',\n    'get:1',\n    'get:length',\n    'get:2',\n    'get:length']));\n\n// enumerable own strings\nmultiTests(\n  source,\n  Object.keys,\n  checkArray(['ca']),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb']));\n\nmultiTests(\n  source,\n  Object.values,\n  checkArray([21]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'get:ca',\n    'getOwnPropertyDescriptor:cb']));\n\nmultiTests(\n  source,\n  Object.entries,\n  checkDeep([['ca', 21]]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'get:ca',\n    'getOwnPropertyDescriptor:cb']));\n\nmultiTests(\n  source,\n  JSON.stringify,\n  checkValue('{\"ca\":21}'),\n  checkArray([\n    'get:toJSON',\n    'ownKeys',\n    'getOwnPropertyDescriptor:ca',\n    'getOwnPropertyDescriptor:cb',\n    'get:ca']));\n\nmultiTests(\n  sourceArray,\n  Object.keys,\n  checkArray(['0', '1', '2']),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'getOwnPropertyDescriptor:1',\n    'getOwnPropertyDescriptor:2',\n    'getOwnPropertyDescriptor:length']));\n\nmultiTests(\n  sourceArray,\n  Object.values,\n  checkArray([10, 20, 30]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'get:0',\n    'getOwnPropertyDescriptor:1',\n    'get:1',\n    'getOwnPropertyDescriptor:2',\n    'get:2',\n    'getOwnPropertyDescriptor:length']));\n\nmultiTests(\n  sourceArray,\n  Object.entries,\n  checkDeep([\n    ['0', 10],\n    ['1', 20],\n    ['2', 30],\n  ]),\n  checkArray([\n    'ownKeys',\n    'getOwnPropertyDescriptor:0',\n    'get:0',\n    'getOwnPropertyDescriptor:1',\n    'get:1',\n    'getOwnPropertyDescriptor:2',\n    'get:2',\n    'getOwnPropertyDescriptor:length']));\n\nmultiTests(\n  sourceArray,\n  JSON.stringify,\n  checkValue('[10,20,30]'),\n  checkArray([\n    'get:toJSON',\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2']));\n\nmultiTests(\n  sourceArray,\n  source => [...source],\n  checkArray([10,20,30]),\n  checkArray([\n    \"get:Symbol(Symbol.iterator)\",\n    \"get:length\",\n    \"get:0\",\n    \"get:length\",\n    \"get:1\",\n    \"get:length\",\n    \"get:2\",\n    \"get:length\",\n  ]));\n\n// Spreading when [Symbol.iterator] is a proxy.\nvar spreadSource = [10,20,30];\nmultiTests(\n  {},\n  proto => {\n    spreadSource.__proto__ = proto;\n    try {\n      return [...spreadSource];\n    } catch (e) {\n      return e.name;\n    }\n  },\n  checkValue(\"TypeError\"),\n  checkArray([\"get:Symbol(Symbol.iterator)\"])\n);\n\nprint('Array.prototype');\n// CHECK-LABEL: Array.prototype\n\nvar arrayOne = [11,12];\n// mind the gap\narrayOne[3] = 13;\nvar arrayTwo = [24,25,26,27];\n\nfunction alterArrayTraps(actual) {\n  // Hermes does not yet implement ArraySpeciesCreate, so we ignore\n  // those traps in d8.\n  if (typeof HermesInternal !== 'object') {\n    return actual.filter(_ => _ !== 'get:constructor');\n  }\n  // We want to return a new array, so later calls don't append to the\n  // traps we test.\n  return actual.concat();\n}\n\nfunction arrayTests(func, checkResult, checkTraps) {\n  checkResult(_ => func(arrayOne.concat(), arrayTwo.concat()),\n              \"for arrays\");\n\n  var output = [];\n  var actual;\n  try {\n    actual = func(new Proxy(arrayOne.concat(), new spyTraps(output)),\n                  new Proxy(arrayTwo.concat(), new spyTraps(output)));\n  } catch (e) {\n    checkResult(function() { throw e }, \"for proxy exception\");\n    checkTraps(_ => output);\n    return;\n  }\n\n  // If actual is an Array Iterator, expand it here, before copying output\n  var copyOutput = alterArrayTraps(output);\n  checkResult(_ => actual,\n              \"for proxies\");\n  checkTraps(_ => copyOutput);\n}\n\nfunction hasGetTraps(begin, end /* inclusive */) {\n  var ret = [];\n  for (var i = begin; i <= end; ++i) {\n    ret.push(\"has:\" + i);\n    ret.push(\"get:\" + i);\n  }\n  return ret;\n}\n\nvar oneTraps = [\n  'get:length',\n  ...hasGetTraps(0, 1),\n  'has:2',\n  // get:2 is not called\n  'has:3',\n  'get:3',\n];\n\narrayTests(\n  (one, two) => Array.prototype.concat.call(one, two),\n  checkArray([11,12,,13,24,25,26,27]),\n  checkArray([\n    'get:Symbol(Symbol.isConcatSpreadable)',\n    ...oneTraps,\n    'get:Symbol(Symbol.isConcatSpreadable)',\n    'get:length',\n    ...hasGetTraps(0, 3),\n]));\n\narrayTests(\n  one => Array.prototype.copyWithin.call(one, 2, 1, 3),\n  checkArray([11,12,12,,]),\n  checkArray([\n    'get:length',\n    'has:2',\n    'delete:3',\n    'has:1',\n    'get:1',\n    'set:2']));\n\narrayTests(\n  one => Array.from(Array.prototype.entries.call(one)),\n  checkDeep([[0,11], [1,12], [2, undefined], [3,13]]),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:length',\n    'get:1',\n    'get:length',\n    'get:2',\n    'get:length',\n    'get:3',\n    'get:length']));\n\narrayTests(\n  one => Array.prototype.every.call(one, _ => _ % 2 == 1),\n  checkValue(false),\n  checkArray([\n    'get:length',\n    ...hasGetTraps(0, 1)]));\n\narrayTests(\n  one => Array.prototype.fill.call(one, 99, 2),\n  checkArray([11,12,99,99]),\n  checkArray([\n    'get:length',\n    'set:2',\n    'set:3']));\n\narrayTests(\n  one => Array.prototype.filter.call(one, _ => _ % 2 == 1),\n  checkArray([11,13]),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.find.call(one, _ => _ % 2 == 0),\n  checkValue(12),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.findIndex.call(one, _ => _ % 2 == 0),\n  checkValue(1),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.findIndex.call(one, _ => _ > 99),\n  checkValue(-1),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.prototype.flatMap.call(one, _ => _ * 10),\n  checkArray([110,120,130]),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.forEach.call(one, _ => _ * 10),\n  checkValue(undefined),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.includes.call(one, 12),\n  checkValue(true),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.includes.call(one, 99),\n  checkValue(false),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.prototype.indexOf.call(one, 12),\n  checkValue(1),\n  checkArray([\n    'get:length',\n    'has:0',\n    'get:0',\n    'has:1',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.indexOf.call(one, 99),\n  checkValue(-1),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.join.call(one, \",\"),\n  checkValue(\"11,12,,13\"),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.from(Array.prototype.keys.call(one)),\n  checkArray([0,1,2,3]),\n  checkArray([\n    'get:length',\n    'get:length',\n    'get:length',\n    'get:length',\n    'get:length']));\n\narrayTests(\n  one => Array.prototype.lastIndexOf.call(one, 12),\n  checkValue(1),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'has:2',\n    'has:1',\n    'get:1']));\n\narrayTests(\n  one => Array.prototype.lastIndexOf.call(one, 99),\n  checkValue(-1),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'has:2',\n    'has:1',\n    'get:1',\n    'has:0',\n    'get:0']));\n\narrayTests(\n  one => Array.prototype.map.call(one, _ => _ * 10),\n  checkArray([110,120,,130]),\n  checkArray(oneTraps));\n\narrayTests(\n  function(one) {\n    var ret = [];\n    ret.push(Array.prototype.pop.call(one));\n    ret.push(Array.prototype.pop.call(one));\n    ret.push(one.length);\n    return ret;\n  },\n  checkArray([13,undefined,2]),\n  checkArray([\n    'get:length',\n    'get:3',\n    'delete:3',\n    'set:length',\n    'get:length',\n    'get:2',\n    'delete:2',\n    'set:length',\n    'get:length']));\n\narrayTests(\n  function(one) {\n    var length = Array.prototype.push.call(one, 99);\n    return [length, one];\n  },\n  checkDeep([5,[11,12,,13,99]]),\n  checkArray([\n    'get:length',\n    'set:4',\n    'set:length']));\n\narrayTests(\n  one => Array.prototype.reduce.call(one, (a, b) => a + b),\n  checkValue(36),\n  checkArray(oneTraps));\n\narrayTests(\n  one => Array.prototype.reduceRight.call(one, (a, b) => a + b),\n  checkValue(36),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'has:2',\n    'has:1',\n    'get:1',\n    'has:0',\n    'get:0']));\n\narrayTests(\n  one => Array.prototype.reverse.call(one),\n  checkArray([13,,12,11]),\n  checkArray([\n    'get:length',\n    'has:0',\n    'get:0',\n    'has:3',\n    'get:3',\n    'set:0',\n    'set:3',\n    'has:1',\n    'get:1',\n    'has:2',\n    'delete:1',\n    'set:2']));\n\narrayTests(\n  function(one) {\n    var ret = [];\n    ret.push(Array.prototype.shift.call(one));\n    ret.push(Array.prototype.shift.call(one));\n    ret.push(Array.prototype.shift.call(one));\n    ret.push(one.length);\n    return ret;\n  },\n  checkArray([11,12,undefined,1]),\n  checkArray([\n    'get:length',\n    'get:0',\n    'has:1',\n    'get:1',\n    'set:0',\n    'has:2',\n    'delete:1',\n    'has:3',\n    'get:3',\n    'set:2',\n    'delete:3',\n    'set:length',\n\n    'get:length',\n    'get:0',\n    'has:1',\n    'delete:0',\n    'has:2',\n    'get:2',\n    'set:1',\n    'delete:2',\n    'set:length',\n\n    'get:length',\n    'get:0',\n    'has:1',\n    'get:1',\n    'set:0',\n    'delete:1',\n    'set:length',\n\n    'get:length']));\n\narrayTests(\n  one => Array.prototype.slice.call(one, 1, 3),\n  checkArray([12,,]),\n  checkArray([\n    'get:length',\n    'has:1',\n    'get:1',\n    'has:2']));\n\narrayTests(\n  one => Array.prototype.some.call(one, _ => _ % 2 == 1),\n  checkValue(true),\n  checkArray([\n    'get:length',\n    'has:0',\n    'get:0']));\n\narrayTests(\n  one => Array.prototype.sort.call(one.reverse()),\n  checkArray([11,12,13,,]),\n  // sort's behavior is implementation-defined, so we just check\n  // that any traps at all are called.\n  checkIf(_ => _.length > 0));\n\narrayTests(\n  function(one) {\n    var ret = Array.prototype.splice.call(one, 1, 2, 98, 99);\n    return [ret, one];\n  },\n  checkDeep([[12,,],[11,98,99,13]]),\n  checkArray([\n    'get:length',\n    'has:1',\n    'get:1',\n    'has:2',\n    'set:1',\n    'set:2',\n    'set:length']));\n\narrayTests(\n  one => Array.prototype.toLocaleString.call(one),\n  checkValue(\"11,12,,13\"),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  one => Array.prototype.toString.call(one),\n  checkValue(\"11,12,,13\"),\n  checkArray([\n    'get:join',\n    'get:length',\n    'get:0',\n    'get:1',\n    'get:2',\n    'get:3']));\n\narrayTests(\n  function(one) {\n    var ret = Array.prototype.unshift.call(one, 98, 99);\n    return [ret, one];\n  },\n  checkDeep([6, [98,99,11,12,,13]]),\n  checkArray([\n    'get:length',\n    'has:3',\n    'get:3',\n    'set:5',\n    'has:2',\n    'delete:4',\n    'has:1',\n    'get:1',\n    'set:3',\n    'has:0',\n    'get:0',\n    'set:2',\n    'set:0',\n    'set:1',\n    'set:length']));\n\narrayTests(\n  one => Array.from(Array.prototype.values.call(one)),\n  checkArray([11,12,,13]),\n  checkArray([\n    'get:length',\n    'get:0',\n    'get:length',\n    'get:1',\n    'get:length',\n    'get:2',\n    'get:length',\n    'get:3',\n    'get:length']));\n\nprint('misc');\n// CHECK-LABEL: misc\n\n// Do a deep target recursion\nvar p = {a:1};\nfor (var i = 0; i < 64; ++i) {\n  p = new Proxy(p, {});\n}\nassert.equal(p.a, 1);\n\n// Test HermesInternal\nassert.equal(\n  typeof HermesInternal !== 'object' ||\n    HermesInternal.isProxy(new Proxy({}, {})),\n  true);\n\n// spread of a callable\nvar f = function() { return 1; }\nf.a = 1;\nf.b = 2;\ncheckDeep({...f})(_ => ({a:1, b:2}))\n\n// Check that defining a property in a Proxy target which is an array\n// uses fast array access (this will trip an assert otherwise)\nnew Proxy([], {}).unshift(0);\n\n// If putComputed is called on a proxy whose target's prototype is an\n// array with a propname of 'length', then internalSetter will be\n// true, and the receiver will be a proxy.  In that case, proxy needs\n// to win; the behavior may assert or be UB otherwise.\nvar p = new Proxy(Object.create([]), {});\n// using String() forces putComputed\np[String('length')] = 0x123;\np[0xABC] = 1111;\n\nprint('done');\n// CHECK-LABEL: done\n"], "filenames": ["lib/VM/JSObject.cpp", "test/hermes/proxy.js"], "buggy_code_start_loc": [1701, 2127], "buggy_code_end_loc": [1729, 2127], "fixing_code_start_loc": [1702, 2128], "fixing_code_end_loc": [1734, 2137], "type": "CWE-125", "message": "An out-of-bounds read in the JavaScript Interpreter in Facebook Hermes prior to commit 8cb935cd3b2321c46aa6b7ed8454d95c75a7fca0 allows attackers to cause a denial of service attack or possible further memory corruption via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "other": {"cve": {"id": "CVE-2020-1915", "sourceIdentifier": "cve-assign@fb.com", "published": "2020-10-26T21:15:12.193", "lastModified": "2020-11-02T16:37:07.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out-of-bounds read in the JavaScript Interpreter in Facebook Hermes prior to commit 8cb935cd3b2321c46aa6b7ed8454d95c75a7fca0 allows attackers to cause a denial of service attack or possible further memory corruption via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."}, {"lang": "es", "value": "Una lectura fuera de l\u00edmites en el int\u00e9rprete de JavaScript en Facebook Hermes anterior al commit 8cb935cd3b2321c46aa6b7ed8454d95c75a7fca0, permite a atacantes causar un ataque de denegaci\u00f3n de servicio o una posible corrupci\u00f3n adicional de la memoria por medio de un JavaScript dise\u00f1ado. Tome en cuenta que esto solo puede ser aprovechado si la aplicaci\u00f3n que usa Hermes permite la evaluaci\u00f3n de un JavaScript que no es confiable. Por consiguiente, la mayor\u00eda de las aplicaciones React Native no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hermes:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-09-25", "matchCriteriaId": "77CAD963-CD06-4E04-89C0-86B1EEB63268"}]}]}], "references": [{"url": "https://github.com/facebook/hermes/commit/8cb935cd3b2321c46aa6b7ed8454d95c75a7fca0", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2020-1915", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hermes/commit/8cb935cd3b2321c46aa6b7ed8454d95c75a7fca0"}}