{"buggy_code": ["package org.expressme.openid;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.StringReader;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.security.InvalidKeyException;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\nimport javax.crypto.Mac;\r\nimport javax.crypto.spec.SecretKeySpec;\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\n/**\r\n * Open ID Manager for all open id operation.\r\n * \r\n * @author Michael Liao (askxuefeng@gmail.com)\r\n * @author Erwin Quinto (erwin.quinto@gmail.com)\r\n */\r\npublic class OpenIdManager {\r\n\r\n    private static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\r\n\r\n    private ShortName shortName = new ShortName();\r\n    private Map<String, Endpoint> endpointCache = new ConcurrentHashMap<String, Endpoint>();\r\n    private Map<Endpoint, Association> associationCache = new ConcurrentHashMap<Endpoint, Association>();\r\n\r\n    private int timeOut = 5000; // 5 seconds\r\n    private String assocQuery = null;\r\n    private String authQuery = null;\r\n    private String returnTo = null;\r\n    private String returnToUrlEncode = null;\r\n    private String realm = null;\r\n\r\n    /**\r\n     * Set returning address after authentication.\r\n     * \r\n     * @param returnTo URL that should redirect to.\r\n     */\r\n    public void setReturnTo(String returnTo) {\r\n        try {\r\n            this.returnToUrlEncode = Utils.urlEncode(returnTo);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        this.returnTo = returnTo;\r\n    }\r\n\r\n    /**\r\n     * Set realm. For example, \"http://*.example.com\".\r\n     * \r\n     * @param realm Realm of RP.\r\n     */\r\n    public void setRealm(String realm) {\r\n        try {\r\n            this.realm = Utils.urlEncode(realm);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set timeout in milliseconds.\r\n     */\r\n    public void setTimeOut(int timeOutInMilliseconds) {\r\n        this.timeOut = timeOutInMilliseconds;\r\n    }\r\n\r\n    /**\r\n     * Get authentication information from HTTP request and key.\r\n     * @deprecated Using getAuthentication(HttpServletRequest request, byte[] key, String alias) instead.\r\n     */\r\n    public Authentication getAuthentication(HttpServletRequest request, byte[] key) {\r\n    \treturn getAuthentication(request, key, Endpoint.DEFAULT_ALIAS);\r\n    }\r\n\r\n    /**\r\n     * Get authentication information from HTTP request, key.and alias\r\n     */\r\n    public Authentication getAuthentication(HttpServletRequest request, byte[] key, String alias) {\r\n        // verify:\r\n        String identity = request.getParameter(\"openid.identity\");\r\n        if (identity==null)\r\n            throw new OpenIdException(\"Missing 'openid.identity'.\");\r\n        if (request.getParameter(\"openid.invalidate_handle\")!=null)\r\n            throw new OpenIdException(\"Invalidate handle.\");\r\n        String sig = request.getParameter(\"openid.sig\");\r\n        if (sig==null)\r\n            throw new OpenIdException(\"Missing 'openid.sig'.\");\r\n        String signed = request.getParameter(\"openid.signed\");\r\n        if (signed==null)\r\n            throw new OpenIdException(\"Missing 'openid.signed'.\");\r\n        if (!returnTo.equals(request.getParameter(\"openid.return_to\")))\r\n            throw new OpenIdException(\"Bad 'openid.return_to'.\");\r\n        // check sig:\r\n        String[] params = signed.split(\"[\\\\,]+\");\r\n        StringBuilder sb = new StringBuilder(1024);\r\n        for (String param : params) {\r\n            sb.append(param)\r\n              .append(':');\r\n            String value = request.getParameter(\"openid.\" + param);\r\n            if (value!=null)\r\n                sb.append(value);\r\n            sb.append('\\n');\r\n        }\r\n        String hmac = getHmacSha1(sb.toString(), key);\r\n        if (!sig.equals(hmac))\r\n            throw new OpenIdException(\"Verify signature failed.\");\r\n        \r\n        // set auth:\r\n        Authentication auth = new Authentication();\r\n        auth.setIdentity(identity);\r\n        auth.setEmail(request.getParameter(\"openid.\" + alias + \".value.email\"));\r\n        auth.setLanguage(request.getParameter(\"openid.\" + alias + \".value.language\"));\r\n        auth.setGender(request.getParameter(\"openid.\" + alias + \".value.gender\"));\r\n        auth.setFullname(getFullname(request, alias));\r\n        auth.setFirstname(getFirstname(request, alias));\r\n        auth.setLastname(getLastname(request, alias));\r\n        return auth;\r\n    }\r\n\r\n    String getLastname (HttpServletRequest request, String axa) {\r\n    \tString name = request.getParameter(\"openid.\" + axa + \".value.lastname\");\r\n    \t// If lastname is not supported try to get it from the fullname\r\n    \tif (name == null) {\r\n    \t\tname = request.getParameter(\"openid.\" + axa + \".value.fullname\");\r\n    \t\tif (name != null) {\r\n    \t\t    int n = name.lastIndexOf(' ');\r\n    \t\t    if (n!=(-1))\r\n    \t\t        name = name.substring(n + 1);\r\n    \t\t}\r\n    \t}\r\n    \treturn name;\r\n    }\r\n\r\n    String getFirstname(HttpServletRequest request, String axa) {\r\n    \tString name = request.getParameter(\"openid.\" + axa + \".value.firstname\");\r\n    \t//If firstname is not supported try to get it from the fullname\r\n    \tif (name == null) {\r\n    \t\tname = request.getParameter(\"openid.\" + axa + \".value.fullname\");\r\n    \t\tif (name != null) {\r\n    \t\t    int n = name.indexOf(' ');\r\n                if (n!=(-1))\r\n                    name = name.substring(0, n);\r\n    \t\t}\r\n    \t}\r\n    \treturn name;\r\n    }\r\n\r\n    String getFullname(HttpServletRequest request, String axa) {\r\n    \t// If fullname is not supported then get combined first and last name\r\n    \tString fname = request.getParameter(\"openid.\"+axa+\".value.fullname\");\r\n    \tif (fname == null) {\r\n    \t\tfname = request.getParameter(\"openid.\"+axa+\".value.firstname\");\r\n    \t\tif (fname != null) {\r\n    \t\t\tfname += \" \";\r\n    \t\t}\r\n    \t\tfname += request.getParameter(\"openid.\"+axa+\".value.lastname\");\r\n    \t}\r\n    \treturn fname;\r\n    }\r\n\r\n    String getHmacSha1(String data, byte[] key) {\r\n        SecretKeySpec signingKey = new SecretKeySpec(key, HMAC_SHA1_ALGORITHM);\r\n        Mac mac = null;\r\n        try {\r\n            mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\r\n            mac.init(signingKey);\r\n        }\r\n        catch(NoSuchAlgorithmException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        catch(InvalidKeyException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        try {\r\n            byte[] rawHmac = mac.doFinal(data.getBytes(\"UTF-8\"));\r\n            return Base64.encodeBytes(rawHmac);\r\n        }\r\n        catch(IllegalStateException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lookup end point by name or full URL.\r\n     */\r\n    public Endpoint lookupEndpoint(String nameOrUrl) {\r\n        String url = null;\r\n        String alias = null;\r\n        if (nameOrUrl.startsWith(\"http://\") || nameOrUrl.startsWith(\"https://\"))\r\n            url = nameOrUrl;\r\n        else {\r\n            url = shortName.lookupUrlByName(nameOrUrl);\r\n            if (url==null)\r\n                throw new OpenIdException(\"Cannot find OP URL by name: \" + nameOrUrl);\r\n            alias = shortName.lookupAliasByName(nameOrUrl);\r\n        }\r\n        Endpoint endpoint = endpointCache.get(url);\r\n        if (endpoint!=null && !endpoint.isExpired())\r\n            return endpoint;\r\n        endpoint = requestEndpoint(url, alias==null ? Endpoint.DEFAULT_ALIAS : alias);\r\n        endpointCache.put(url, endpoint);\r\n        return endpoint;\r\n    }\r\n\r\n    public Association lookupAssociation(Endpoint endpoint) {\r\n        Association assoc = associationCache.get(endpoint);\r\n        if (assoc!=null && !assoc.isExpired())\r\n            return assoc;\r\n        assoc = requestAssociation(endpoint);\r\n        associationCache.put(endpoint, assoc);\r\n        return assoc;\r\n    }\r\n\r\n    public String getAuthenticationUrl(Endpoint endpoint, Association association) {\r\n        StringBuilder sb = new StringBuilder(1024);\r\n        sb.append(endpoint.getUrl())\r\n          .append(endpoint.getUrl().contains(\"?\") ? '&' : '?')\r\n          .append(getAuthQuery(endpoint.getAlias()))\r\n          .append(\"&openid.return_to=\")\r\n          .append(returnToUrlEncode)\r\n          .append(\"&openid.assoc_handle=\")\r\n          .append(association.getAssociationHandle());\r\n        if (realm!=null)\r\n            sb.append(\"&openid.realm=\").append(realm);\r\n        return sb.toString();\r\n    }\r\n\r\n    Endpoint requestEndpoint(String url, String alias) {\r\n        Map<String, Object> map = Utils.httpRequest(\r\n                url,\r\n                \"GET\",\r\n                \"application/xrds+xml\",\r\n                null,\r\n                timeOut\r\n        );\r\n        try {\r\n            String content = Utils.getContent(map);\r\n            return new Endpoint(Utils.mid(content, \"<URI>\", \"</URI>\"), alias, Utils.getMaxAge(map));\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n    }\r\n\r\n    Association requestAssociation(Endpoint endpoint) {\r\n        Map<String, Object> map = Utils.httpRequest(\r\n                endpoint.getUrl(),\r\n                \"POST\",\r\n                \"*/*\",\r\n                getAssocQuery(),\r\n                timeOut\r\n        );\r\n        String content = null;\r\n        try {\r\n            content = Utils.getContent(map);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        Association assoc = new Association();\r\n        try {\r\n            BufferedReader r = new BufferedReader(new StringReader(content));\r\n            for (;;) {\r\n                String line = r.readLine();\r\n                if (line==null)\r\n                    break;\r\n                line = line.trim();\r\n                int pos = line.indexOf(':');\r\n                if (pos!=(-1)) {\r\n                    String key = line.substring(0, pos);\r\n                    String value = line.substring(pos + 1);\r\n                    if (\"session_type\".equals(key))\r\n                        assoc.setSessionType(value);\r\n                    else if (\"assoc_type\".equals(key))\r\n                        assoc.setAssociationType(value);\r\n                    else if (\"assoc_handle\".equals(key))\r\n                        assoc.setAssociationHandle(value);\r\n                    else if (\"mac_key\".equals(key))\r\n                        assoc.setMacKey(value);\r\n                    else if (\"expires_in\".equals(key)) {\r\n                        long maxAge = Long.parseLong(value);\r\n                        assoc.setMaxAge(maxAge * 900L); // 90%\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch(IOException e) {\r\n            throw new RuntimeException(\"IOException is impossible!\", e);\r\n        }\r\n        return assoc;\r\n    }\r\n\r\n    String getAuthQuery(String axa) {\r\n        if (authQuery!=null)\r\n            return authQuery;\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"openid.ns=http://specs.openid.net/auth/2.0\");\r\n        list.add(\"openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select\");\r\n        list.add(\"openid.identity=http://specs.openid.net/auth/2.0/identifier_select\");\r\n        list.add(\"openid.mode=checkid_setup\");\r\n        list.add(\"openid.ns.\" + axa + \"=http://openid.net/srv/ax/1.0\");\r\n        list.add(\"openid.\" + axa + \".mode=fetch_request\");\r\n        list.add(\"openid.\" + axa + \".type.email=http://axschema.org/contact/email\");\r\n        list.add(\"openid.\" + axa + \".type.fullname=http://axschema.org/namePerson\");\r\n        list.add(\"openid.\" + axa + \".type.language=http://axschema.org/pref/language\");\r\n        list.add(\"openid.\" + axa + \".type.firstname=http://axschema.org/namePerson/first\");\r\n        list.add(\"openid.\" + axa + \".type.lastname=http://axschema.org/namePerson/last\");\r\n        list.add(\"openid.\" + axa + \".type.gender=http://axschema.org/person/gender\");\r\n        list.add(\"openid.\" + axa + \".required=email,fullname,language,firstname,lastname,gender\");\r\n        String query = Utils.buildQuery(list);\r\n        authQuery = query;\r\n        return query;\r\n    }\r\n\r\n    String getAssocQuery() {\r\n        if (assocQuery!=null)\r\n            return assocQuery;\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"openid.ns=http://specs.openid.net/auth/2.0\");\r\n        list.add(\"openid.mode=associate\");\r\n        list.add(\"openid.session_type=\" + Association.SESSION_TYPE_NO_ENCRYPTION);\r\n        list.add(\"openid.assoc_type=\" + Association.ASSOC_TYPE_HMAC_SHA1);\r\n        String query = Utils.buildQuery(list);\r\n        assocQuery = query;\r\n        return query;\r\n    }\r\n}\r\n"], "fixing_code": ["package org.expressme.openid;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.StringReader;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.security.InvalidKeyException;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\nimport javax.crypto.Mac;\r\nimport javax.crypto.spec.SecretKeySpec;\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\n/**\r\n * Open ID Manager for all open id operation.\r\n * \r\n * @author Michael Liao (askxuefeng@gmail.com)\r\n * @author Erwin Quinto (erwin.quinto@gmail.com)\r\n */\r\npublic class OpenIdManager {\r\n\r\n    private static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\r\n\r\n    private ShortName shortName = new ShortName();\r\n    private Map<String, Endpoint> endpointCache = new ConcurrentHashMap<String, Endpoint>();\r\n    private Map<Endpoint, Association> associationCache = new ConcurrentHashMap<Endpoint, Association>();\r\n\r\n    private int timeOut = 5000; // 5 seconds\r\n    private String assocQuery = null;\r\n    private String authQuery = null;\r\n    private String returnTo = null;\r\n    private String returnToUrlEncode = null;\r\n    private String realm = null;\r\n\r\n    /**\r\n     * Set returning address after authentication.\r\n     * \r\n     * @param returnTo URL that should redirect to.\r\n     */\r\n    public void setReturnTo(String returnTo) {\r\n        try {\r\n            this.returnToUrlEncode = Utils.urlEncode(returnTo);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        this.returnTo = returnTo;\r\n    }\r\n\r\n    /**\r\n     * Set realm. For example, \"http://*.example.com\".\r\n     * \r\n     * @param realm Realm of RP.\r\n     */\r\n    public void setRealm(String realm) {\r\n        try {\r\n            this.realm = Utils.urlEncode(realm);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set timeout in milliseconds.\r\n     */\r\n    public void setTimeOut(int timeOutInMilliseconds) {\r\n        this.timeOut = timeOutInMilliseconds;\r\n    }\r\n\r\n    /**\r\n     * Get authentication information from HTTP request and key.\r\n     * @deprecated Using getAuthentication(HttpServletRequest request, byte[] key, String alias) instead.\r\n     */\r\n    public Authentication getAuthentication(HttpServletRequest request, byte[] key) {\r\n    \treturn getAuthentication(request, key, Endpoint.DEFAULT_ALIAS);\r\n    }\r\n\r\n    /**\r\n     * Get authentication information from HTTP request, key.and alias\r\n     */\r\n    public Authentication getAuthentication(HttpServletRequest request, byte[] key, String alias) {\r\n        // verify:\r\n        String identity = request.getParameter(\"openid.identity\");\r\n        if (identity==null)\r\n            throw new OpenIdException(\"Missing 'openid.identity'.\");\r\n        if (request.getParameter(\"openid.invalidate_handle\")!=null)\r\n            throw new OpenIdException(\"Invalidate handle.\");\r\n        String sig = request.getParameter(\"openid.sig\");\r\n        if (sig==null)\r\n            throw new OpenIdException(\"Missing 'openid.sig'.\");\r\n        String signed = request.getParameter(\"openid.signed\");\r\n        if (signed==null)\r\n            throw new OpenIdException(\"Missing 'openid.signed'.\");\r\n        if (!returnTo.equals(request.getParameter(\"openid.return_to\")))\r\n            throw new OpenIdException(\"Bad 'openid.return_to'.\");\r\n        // check sig:\r\n        String[] params = signed.split(\"[\\\\,]+\");\r\n        StringBuilder sb = new StringBuilder(1024);\r\n        for (String param : params) {\r\n            sb.append(param)\r\n              .append(':');\r\n            String value = request.getParameter(\"openid.\" + param);\r\n            if (value!=null)\r\n                sb.append(value);\r\n            sb.append('\\n');\r\n        }\r\n        String hmac = getHmacSha1(sb.toString(), key);\r\n        if (!safeEquals(sig, hmac))\r\n            throw new OpenIdException(\"Verify signature failed.\");\r\n\r\n        // set auth:\r\n        Authentication auth = new Authentication();\r\n        auth.setIdentity(identity);\r\n        auth.setEmail(request.getParameter(\"openid.\" + alias + \".value.email\"));\r\n        auth.setLanguage(request.getParameter(\"openid.\" + alias + \".value.language\"));\r\n        auth.setGender(request.getParameter(\"openid.\" + alias + \".value.gender\"));\r\n        auth.setFullname(getFullname(request, alias));\r\n        auth.setFirstname(getFirstname(request, alias));\r\n        auth.setLastname(getLastname(request, alias));\r\n        return auth;\r\n    }\r\n\r\n    boolean safeEquals(String s1, String s2) {\r\n        if (s1.length()!=s2.length())\r\n            return false;\r\n        int result = 0;\r\n        for (int i=0; i<s1.length(); i++) {\r\n            int c1 = s1.charAt(i);\r\n            int c2 = s2.charAt(i);\r\n            result |= (c1 ^c2);\r\n        }\r\n        return result==0;\r\n    }\r\n\r\n    String getLastname (HttpServletRequest request, String axa) {\r\n    \tString name = request.getParameter(\"openid.\" + axa + \".value.lastname\");\r\n    \t// If lastname is not supported try to get it from the fullname\r\n    \tif (name == null) {\r\n    \t\tname = request.getParameter(\"openid.\" + axa + \".value.fullname\");\r\n    \t\tif (name != null) {\r\n    \t\t    int n = name.lastIndexOf(' ');\r\n    \t\t    if (n!=(-1))\r\n    \t\t        name = name.substring(n + 1);\r\n    \t\t}\r\n    \t}\r\n    \treturn name;\r\n    }\r\n\r\n    String getFirstname(HttpServletRequest request, String axa) {\r\n    \tString name = request.getParameter(\"openid.\" + axa + \".value.firstname\");\r\n    \t//If firstname is not supported try to get it from the fullname\r\n    \tif (name == null) {\r\n    \t\tname = request.getParameter(\"openid.\" + axa + \".value.fullname\");\r\n    \t\tif (name != null) {\r\n    \t\t    int n = name.indexOf(' ');\r\n                if (n!=(-1))\r\n                    name = name.substring(0, n);\r\n    \t\t}\r\n    \t}\r\n    \treturn name;\r\n    }\r\n\r\n    String getFullname(HttpServletRequest request, String axa) {\r\n    \t// If fullname is not supported then get combined first and last name\r\n    \tString fname = request.getParameter(\"openid.\"+axa+\".value.fullname\");\r\n    \tif (fname == null) {\r\n    \t\tfname = request.getParameter(\"openid.\"+axa+\".value.firstname\");\r\n    \t\tif (fname != null) {\r\n    \t\t\tfname += \" \";\r\n    \t\t}\r\n    \t\tfname += request.getParameter(\"openid.\"+axa+\".value.lastname\");\r\n    \t}\r\n    \treturn fname;\r\n    }\r\n\r\n    String getHmacSha1(String data, byte[] key) {\r\n        SecretKeySpec signingKey = new SecretKeySpec(key, HMAC_SHA1_ALGORITHM);\r\n        Mac mac = null;\r\n        try {\r\n            mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\r\n            mac.init(signingKey);\r\n        }\r\n        catch(NoSuchAlgorithmException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        catch(InvalidKeyException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        try {\r\n            byte[] rawHmac = mac.doFinal(data.getBytes(\"UTF-8\"));\r\n            return Base64.encodeBytes(rawHmac);\r\n        }\r\n        catch(IllegalStateException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lookup end point by name or full URL.\r\n     */\r\n    public Endpoint lookupEndpoint(String nameOrUrl) {\r\n        String url = null;\r\n        String alias = null;\r\n        if (nameOrUrl.startsWith(\"http://\") || nameOrUrl.startsWith(\"https://\"))\r\n            url = nameOrUrl;\r\n        else {\r\n            url = shortName.lookupUrlByName(nameOrUrl);\r\n            if (url==null)\r\n                throw new OpenIdException(\"Cannot find OP URL by name: \" + nameOrUrl);\r\n            alias = shortName.lookupAliasByName(nameOrUrl);\r\n        }\r\n        Endpoint endpoint = endpointCache.get(url);\r\n        if (endpoint!=null && !endpoint.isExpired())\r\n            return endpoint;\r\n        endpoint = requestEndpoint(url, alias==null ? Endpoint.DEFAULT_ALIAS : alias);\r\n        endpointCache.put(url, endpoint);\r\n        return endpoint;\r\n    }\r\n\r\n    public Association lookupAssociation(Endpoint endpoint) {\r\n        Association assoc = associationCache.get(endpoint);\r\n        if (assoc!=null && !assoc.isExpired())\r\n            return assoc;\r\n        assoc = requestAssociation(endpoint);\r\n        associationCache.put(endpoint, assoc);\r\n        return assoc;\r\n    }\r\n\r\n    public String getAuthenticationUrl(Endpoint endpoint, Association association) {\r\n        StringBuilder sb = new StringBuilder(1024);\r\n        sb.append(endpoint.getUrl())\r\n          .append(endpoint.getUrl().contains(\"?\") ? '&' : '?')\r\n          .append(getAuthQuery(endpoint.getAlias()))\r\n          .append(\"&openid.return_to=\")\r\n          .append(returnToUrlEncode)\r\n          .append(\"&openid.assoc_handle=\")\r\n          .append(association.getAssociationHandle());\r\n        if (realm!=null)\r\n            sb.append(\"&openid.realm=\").append(realm);\r\n        return sb.toString();\r\n    }\r\n\r\n    Endpoint requestEndpoint(String url, String alias) {\r\n        Map<String, Object> map = Utils.httpRequest(\r\n                url,\r\n                \"GET\",\r\n                \"application/xrds+xml\",\r\n                null,\r\n                timeOut\r\n        );\r\n        try {\r\n            String content = Utils.getContent(map);\r\n            return new Endpoint(Utils.mid(content, \"<URI>\", \"</URI>\"), alias, Utils.getMaxAge(map));\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n    }\r\n\r\n    Association requestAssociation(Endpoint endpoint) {\r\n        Map<String, Object> map = Utils.httpRequest(\r\n                endpoint.getUrl(),\r\n                \"POST\",\r\n                \"*/*\",\r\n                getAssocQuery(),\r\n                timeOut\r\n        );\r\n        String content = null;\r\n        try {\r\n            content = Utils.getContent(map);\r\n        }\r\n        catch(UnsupportedEncodingException e) {\r\n            throw new OpenIdException(e);\r\n        }\r\n        Association assoc = new Association();\r\n        try {\r\n            BufferedReader r = new BufferedReader(new StringReader(content));\r\n            for (;;) {\r\n                String line = r.readLine();\r\n                if (line==null)\r\n                    break;\r\n                line = line.trim();\r\n                int pos = line.indexOf(':');\r\n                if (pos!=(-1)) {\r\n                    String key = line.substring(0, pos);\r\n                    String value = line.substring(pos + 1);\r\n                    if (\"session_type\".equals(key))\r\n                        assoc.setSessionType(value);\r\n                    else if (\"assoc_type\".equals(key))\r\n                        assoc.setAssociationType(value);\r\n                    else if (\"assoc_handle\".equals(key))\r\n                        assoc.setAssociationHandle(value);\r\n                    else if (\"mac_key\".equals(key))\r\n                        assoc.setMacKey(value);\r\n                    else if (\"expires_in\".equals(key)) {\r\n                        long maxAge = Long.parseLong(value);\r\n                        assoc.setMaxAge(maxAge * 900L); // 90%\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch(IOException e) {\r\n            throw new RuntimeException(\"IOException is impossible!\", e);\r\n        }\r\n        return assoc;\r\n    }\r\n\r\n    String getAuthQuery(String axa) {\r\n        if (authQuery!=null)\r\n            return authQuery;\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"openid.ns=http://specs.openid.net/auth/2.0\");\r\n        list.add(\"openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select\");\r\n        list.add(\"openid.identity=http://specs.openid.net/auth/2.0/identifier_select\");\r\n        list.add(\"openid.mode=checkid_setup\");\r\n        list.add(\"openid.ns.\" + axa + \"=http://openid.net/srv/ax/1.0\");\r\n        list.add(\"openid.\" + axa + \".mode=fetch_request\");\r\n        list.add(\"openid.\" + axa + \".type.email=http://axschema.org/contact/email\");\r\n        list.add(\"openid.\" + axa + \".type.fullname=http://axschema.org/namePerson\");\r\n        list.add(\"openid.\" + axa + \".type.language=http://axschema.org/pref/language\");\r\n        list.add(\"openid.\" + axa + \".type.firstname=http://axschema.org/namePerson/first\");\r\n        list.add(\"openid.\" + axa + \".type.lastname=http://axschema.org/namePerson/last\");\r\n        list.add(\"openid.\" + axa + \".type.gender=http://axschema.org/person/gender\");\r\n        list.add(\"openid.\" + axa + \".required=email,fullname,language,firstname,lastname,gender\");\r\n        String query = Utils.buildQuery(list);\r\n        authQuery = query;\r\n        return query;\r\n    }\r\n\r\n    String getAssocQuery() {\r\n        if (assocQuery!=null)\r\n            return assocQuery;\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"openid.ns=http://specs.openid.net/auth/2.0\");\r\n        list.add(\"openid.mode=associate\");\r\n        list.add(\"openid.session_type=\" + Association.SESSION_TYPE_NO_ENCRYPTION);\r\n        list.add(\"openid.assoc_type=\" + Association.ASSOC_TYPE_HMAC_SHA1);\r\n        String query = Utils.buildQuery(list);\r\n        assocQuery = query;\r\n        return query;\r\n    }\r\n}\r\n"], "filenames": ["JOpenId/src/org/expressme/openid/OpenIdManager.java"], "buggy_code_start_loc": [113], "buggy_code_end_loc": [125], "fixing_code_start_loc": [113], "fixing_code_end_loc": [138], "type": "CWE-203", "message": "A vulnerability, which was classified as problematic, was found in michaelliao jopenid. Affected is the function getAuthentication of the file JOpenId/src/org/expressme/openid/OpenIdManager.java. The manipulation leads to observable timing discrepancy. Upgrading to version 1.08 is able to address this issue. The name of the patch is c9baaa976b684637f0d5a50268e91846a7a719ab. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218460.", "other": {"cve": {"id": "CVE-2010-10006", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-18T00:15:11.420", "lastModified": "2023-01-24T19:44:25.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in michaelliao jopenid. Affected is the function getAuthentication of the file JOpenId/src/org/expressme/openid/OpenIdManager.java. The manipulation leads to observable timing discrepancy. Upgrading to version 1.08 is able to address this issue. The name of the patch is c9baaa976b684637f0d5a50268e91846a7a719ab. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218460."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:S/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.4}, "baseSeverity": "LOW", "exploitabilityScore": 2.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jopenid_project:jopenid:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.08", "matchCriteriaId": "1654319E-88C2-4CB6-9271-BC03DDA9058E"}]}]}], "references": [{"url": "https://github.com/michaelliao/jopenid/commit/c9baaa976b684637f0d5a50268e91846a7a719ab", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelliao/jopenid/releases/tag/JOpenId-1.08", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218460", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.218460", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/michaelliao/jopenid/commit/c9baaa976b684637f0d5a50268e91846a7a719ab"}}