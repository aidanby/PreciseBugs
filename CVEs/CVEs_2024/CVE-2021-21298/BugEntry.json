{"buggy_code": ["/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n\nvar fs = require('fs-extra');\nvar when = require('when');\nvar fspath = require(\"path\");\nvar os = require('os');\n\nvar gitTools = require(\"./git\");\nvar util = require(\"../util\");\nvar defaultFileSet = require(\"./defaultFileSet\");\nvar sshKeys = require(\"./ssh\");\nvar settings;\nvar runtime;\nvar log = require(\"@node-red/util\").log;\n\nvar projectsDir;\n\nvar authCache = require(\"./git/authCache\");\n\n// TODO: DRY - red/api/editor/sshkeys !\nfunction getSSHKeyUsername(userObj) {\n    var username = '__default';\n    if ( userObj && userObj.username ) {\n        username = userObj.username;\n    }\n    return username;\n}\n\nfunction getUserGitSettings(user) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var userSettings = settings.getUserSettings(username)||{};\n    return userSettings.git;\n}\n\nfunction getGitUser(user) {\n    var gitSettings = getUserGitSettings(user);\n    if (gitSettings) {\n        return gitSettings.user;\n    }\n    return null;\n}\n\nfunction Project(path) {\n    this.path = path;\n    this.name = fspath.basename(path);\n    this.paths = {};\n    this.files = {};\n    this.auth = {origin:{}};\n    this.missingFiles = [];\n    this.credentialSecret = null;\n}\nProject.prototype.load = function () {\n    var project = this;\n    var globalProjectSettings = settings.get(\"projects\");\n// console.log(globalProjectSettings)\n    var projectSettings = {};\n    if (globalProjectSettings) {\n        if (globalProjectSettings.projects.hasOwnProperty(this.name)) {\n            projectSettings = globalProjectSettings.projects[this.name] || {};\n        }\n    }\n    this.paths.root = projectSettings.rootPath || \"\";\n    this.credentialSecret = projectSettings.credentialSecret;\n    this.git = projectSettings.git || { user:{} };\n\n    // this.paths.flowFile = fspath.join(this.path,\"flow.json\");\n    // this.paths.credentialsFile = fspath.join(this.path,\"flow_cred.json\");\n\n    var promises = [];\n    return checkProjectFiles(project).then(function(missingFiles) {\n        project.missingFiles = missingFiles;\n        if (missingFiles.indexOf('package.json') === -1) {\n            // We have a package.json in project.path+project.paths.root+\"package.json\"\n            project.paths['package.json'] = fspath.join(project.paths.root,\"package.json\");\n            promises.push(fs.readFile(fspath.join(project.path,project.paths['package.json']),\"utf8\").then(function(content) {\n                try {\n                    project.package = util.parseJSON(content);\n                    if (project.package.hasOwnProperty('node-red')) {\n                        if (project.package['node-red'].hasOwnProperty('settings')) {\n                            project.paths.flowFile = fspath.join(project.paths.root,project.package['node-red'].settings.flowFile);\n                            project.paths.credentialsFile = fspath.join(project.paths.root,project.package['node-red'].settings.credentialsFile);\n                        }\n                    } else {\n                        // TODO: package.json doesn't have a node-red section\n                        //       is that a bad thing?\n                    }\n                } catch(err) {\n                    // package.json isn't valid JSON... is a merge underway?\n                    project.package = {};\n                }\n            }));\n            if (missingFiles.indexOf('README.md') === -1) {\n                project.paths['README.md'] = fspath.join(project.paths.root,\"README.md\");\n                promises.push(fs.readFile(fspath.join(project.path,project.paths['README.md']),\"utf8\").then(function(content) {\n                    project.description = content;\n                }));\n            } else {\n                project.description = \"\";\n            }\n        } else {\n            project.package = {};\n            project.description = \"\";\n        }\n\n        // if (missingFiles.indexOf('flow.json') !== -1) {\n        //     console.log(\"MISSING FLOW FILE\");\n        // } else {\n        //     project.paths.flowFile = fspath.join(project.path,\"flow.json\");\n        // }\n        // if (missingFiles.indexOf('flow_cred.json') !== -1) {\n        //     console.log(\"MISSING CREDS FILE\");\n        // } else {\n        //     project.paths.credentialsFile = fspath.join(project.path,\"flow_cred.json\");\n        // }\n\n        promises.push(project.loadRemotes());\n\n        return when.settle(promises).then(function(results) {\n            return project;\n        })\n    });\n};\n\nProject.prototype.initialise = function(user,data) {\n    var project = this;\n    // if (!this.empty) {\n    //     throw new Error(\"Cannot initialise non-empty project\");\n    // }\n    var files = Object.keys(defaultFileSet);\n    var promises = [];\n\n    if (data.hasOwnProperty('credentialSecret')) {\n        var projects = settings.get('projects');\n        projects.projects[project.name] = projects.projects[project.name] || {};\n        projects.projects[project.name].credentialSecret = data.credentialSecret;\n        promises.push(settings.set('projects',projects));\n    }\n\n    if (data.hasOwnProperty('files')) {\n        if (data.files.hasOwnProperty('flow') && data.files.hasOwnProperty('credentials')) {\n            project.files.flow = data.files.flow;\n            project.files.credentials = data.files.credentials;\n            var flowFilePath = fspath.join(project.path,project.files.flow);\n            var credsFilePath = getCredentialsFilename(flowFilePath);\n            promises.push(util.writeFile(flowFilePath,\"[]\"));\n            promises.push(util.writeFile(credsFilePath,\"{}\"));\n            files.push(project.files.flow);\n            files.push(project.files.credentials);\n        }\n    }\n    for (var file in defaultFileSet) {\n        if (defaultFileSet.hasOwnProperty(file)) {\n            var path = fspath.join(project.path,file);\n            if (!fs.existsSync(path)) {\n                promises.push(util.writeFile(path,defaultFileSet[file](project)));\n            }\n\n        }\n    }\n\n    return Promise.all(promises).then(function() {\n        return gitTools.stageFile(project.path,files);\n    }).then(function() {\n        return gitTools.commit(project.path,\"Create project files\",getGitUser(user));\n    }).then(function() {\n        return project.load()\n    })\n}\n\nProject.prototype.loadRemotes = function() {\n    var project = this;\n    return gitTools.getRemotes(project.path).then(function(remotes) {\n        project.remotes = remotes;\n    }).then(function() {\n        project.branches = {};\n        return project.status();\n    }).then(function() {\n        if (project.remotes) {\n            var allRemotes = Object.keys(project.remotes);\n            var match = \"\";\n            if (project.branches.remote) {\n                allRemotes.forEach(function(remote) {\n                    if (project.branches.remote.indexOf(remote) === 0 && match.length < remote.length) {\n                        match = remote;\n                    }\n                });\n                project.currentRemote = project.parseRemoteBranch(project.branches.remote).remote;\n            }\n        } else {\n            delete project.currentRemote;\n        }\n    });\n}\n\nProject.prototype.parseRemoteBranch = function (remoteBranch) {\n    if (!remoteBranch) {\n        return {}\n    }\n    var project = this;\n    var allRemotes = Object.keys(project.remotes);\n    var match = \"\";\n    allRemotes.forEach(function(remote) {\n        if (remoteBranch.indexOf(remote) === 0 && match.length < remote.length) {\n            match = remote;\n        }\n    });\n    return {\n        remote: match,\n        branch: remoteBranch.substring(match.length+1)\n    }\n\n};\n\nProject.prototype.isEmpty = function () {\n    return this.empty;\n};\n\nProject.prototype.isMerging = function() {\n    return this.merging;\n}\n\nProject.prototype.update = function (user, data) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n\n    var promises = [];\n    var project = this;\n    var saveSettings = false;\n    var saveREADME = false;\n    var savePackage = false;\n    var flowFilesChanged = false;\n    var credentialSecretChanged = false;\n    var reloadProject = false;\n\n    var globalProjectSettings = settings.get(\"projects\");\n    if (!globalProjectSettings.projects.hasOwnProperty(this.name)) {\n        globalProjectSettings.projects[this.name] = {};\n        saveSettings = true;\n    }\n\n    if (data.credentialSecret && data.credentialSecret !== this.credentialSecret) {\n        var existingSecret = data.currentCredentialSecret;\n        var isReset = data.resetCredentialSecret;\n        var secret = data.credentialSecret;\n\n        // console.log(\"updating credentialSecret\");\n        // console.log(\"request:\");\n        // console.log(JSON.stringify(data,\"\",4));\n        // console.log(\" this.credentialSecret\",this.credentialSecret);\n        // console.log(\" this.info\", this.info);\n\n        if (!isReset && // not a reset\n            this.credentialSecret && // key already set\n            !this.credentialSecretInvalid && // key not invalid\n            this.credentialSecret !== existingSecret) { // key doesn't match provided existing key\n                var e = new Error(\"Cannot change credentialSecret without current key\");\n                e.code = \"missing_current_credential_key\";\n                return when.reject(e);\n        }\n        this.credentialSecret = secret;\n\n        globalProjectSettings.projects[this.name].credentialSecret = project.credentialSecret;\n        delete this.credentialSecretInvalid;\n        saveSettings = true;\n        credentialSecretChanged = true;\n    }\n\n    if (this.missingFiles.indexOf('package.json') !== -1) {\n        if (!data.files || !data.files.package) {\n            // Cannot update a project that doesn't have a known package.json\n            return Promise.reject(\"Cannot update project with missing package.json\");\n        }\n    }\n\n    if (data.hasOwnProperty('files')) {\n        this.package['node-red'] = this.package['node-red'] || { settings: {}};\n        if (data.files.hasOwnProperty('package') && (data.files.package !== fspath.join(this.paths.root,\"package.json\") || !this.paths['package.json'])) {\n            // We have a package file. It could be one that doesn't exist yet,\n            // or it does exist and we need to load it.\n            if (!/package\\.json$/.test(data.files.package)) {\n                return Promise.reject(\"Invalid package file: \"+data.files.package)\n            }\n            var root = data.files.package.substring(0,data.files.package.length-12);\n            this.paths.root = root;\n            this.paths['package.json'] = data.files.package;\n            globalProjectSettings.projects[this.name].rootPath = root;\n            saveSettings = true;\n            // 1. check if it exists\n            if (fs.existsSync(fspath.join(this.path,this.paths['package.json']))) {\n                // Load the existing one....\n            } else {\n                var newPackage = defaultFileSet[\"package.json\"](this);\n                fs.writeFileSync(fspath.join(this.path,this.paths['package.json']),newPackage);\n                this.package = JSON.parse(newPackage);\n            }\n            reloadProject = true;\n            flowFilesChanged = true;\n        }\n\n        if (data.files.hasOwnProperty('flow') && this.package['node-red'].settings.flowFile !== data.files.flow.substring(this.paths.root.length)) {\n            this.paths.flowFile = data.files.flow;\n            this.package['node-red'].settings.flowFile = data.files.flow.substring(this.paths.root.length);\n            savePackage = true;\n            flowFilesChanged = true;\n        }\n        if (data.files.hasOwnProperty('credentials') && this.package['node-red'].settings.credentialsFile !== data.files.credentials.substring(this.paths.root.length)) {\n            this.paths.credentialsFile = data.files.credentials;\n            this.package['node-red'].settings.credentialsFile = data.files.credentials.substring(this.paths.root.length);\n            // Don't know if the credSecret is invalid or not so clear the flag\n            delete this.credentialSecretInvalid;\n            savePackage = true;\n            flowFilesChanged = true;\n        }\n    }\n\n    if (data.hasOwnProperty('description')) {\n        saveREADME = true;\n        this.description = data.description;\n    }\n    if (data.hasOwnProperty('dependencies')) {\n        savePackage = true;\n        this.package.dependencies = data.dependencies;\n    }\n    if (data.hasOwnProperty('summary')) {\n        savePackage = true;\n        this.package.description = data.summary;\n    }\n    if (data.hasOwnProperty('version')) {\n        savePackage = true;\n        this.package.version = data.version;\n    }\n\n    if (data.hasOwnProperty('git')) {\n        if (data.git.hasOwnProperty('user')) {\n            globalProjectSettings.projects[this.name].git = globalProjectSettings.projects[this.name].git || {};\n            globalProjectSettings.projects[this.name].git.user = globalProjectSettings.projects[this.name].git.user || {};\n            globalProjectSettings.projects[this.name].git.user[username] = {\n                name: data.git.user.name,\n                email: data.git.user.email\n            }\n            this.git.user[username] = {\n                name: data.git.user.name,\n                email: data.git.user.email\n            }\n            saveSettings = true;\n        }\n        if (data.git.hasOwnProperty('remotes')) {\n            var remoteNames = Object.keys(data.git.remotes);\n            var remotesChanged = false;\n            var modifyRemotesPromise = Promise.resolve();\n            remoteNames.forEach(function(name) {\n                if (data.git.remotes[name].removed) {\n                    remotesChanged = true;\n                    modifyRemotesPromise = modifyRemotesPromise.then(function() { gitTools.removeRemote(project.path,name) });\n                } else {\n                    if (data.git.remotes[name].url) {\n                        remotesChanged = true;\n                        modifyRemotesPromise = modifyRemotesPromise.then(function() { gitTools.addRemote(project.path,name,data.git.remotes[name])});\n                    }\n                    if (data.git.remotes[name].username && data.git.remotes[name].password) {\n                        var url = data.git.remotes[name].url || project.remotes[name].fetch;\n                        authCache.set(project.name,url,username,data.git.remotes[name]);\n                    }\n                }\n            })\n            if (remotesChanged) {\n                modifyRemotesPromise = modifyRemotesPromise.then(function() {\n                    return project.loadRemotes();\n                });\n                promises.push(modifyRemotesPromise);\n            }\n        }\n    }\n\n\n    if (saveSettings) {\n        promises.push(settings.set(\"projects\",globalProjectSettings));\n    }\n\n    var modifiedFiles = [];\n\n    if (saveREADME) {\n        promises.push(util.writeFile(fspath.join(this.path,this.paths['README.md']), this.description));\n        modifiedFiles.push('README.md');\n    }\n    if (savePackage) {\n        promises.push(fs.readFile(fspath.join(this.path,this.paths['package.json']),\"utf8\").then(content => {\n            var currentPackage = {};\n            try {\n                currentPackage = util.parseJSON(content);\n            } catch(err) {\n            }\n            this.package = Object.assign(currentPackage,this.package);\n            return util.writeFile(fspath.join(project.path,this.paths['package.json']), JSON.stringify(this.package,\"\",4));\n        }));\n        modifiedFiles.push('package.json');\n    }\n    return when.settle(promises).then(function(res) {\n        var gitSettings = getUserGitSettings(user) || {};\n        var workflowMode = (gitSettings.workflow||{}).mode || \"manual\";\n        if (workflowMode === 'auto') {\n            return project.stageFile(modifiedFiles.map(f => project.paths[f])).then(() => {\n                return project.commit(user,{message:\"Update \"+modifiedFiles.join(\", \")})\n            })\n        }\n    }).then(res => {\n        if (reloadProject) {\n            return this.load()\n        }\n    }).then(function() {\n        return {\n            flowFilesChanged: flowFilesChanged,\n            credentialSecretChanged: credentialSecretChanged\n        }})\n};\n\nProject.prototype.getFiles = function () {\n    return gitTools.getFiles(this.path).catch(function(err) {\n        if (/ambiguous argument/.test(err.message)) {\n            return {};\n        }\n        throw err;\n    });\n};\n\nProject.prototype.stageFile = function(file) {\n    return gitTools.stageFile(this.path,file);\n};\n\nProject.prototype.unstageFile = function(file) {\n    return gitTools.unstageFile(this.path,file);\n}\n\nProject.prototype.commit = function(user, options) {\n    var self = this;\n    return gitTools.commit(this.path,options.message,getGitUser(user)).then(function() {\n        if (self.merging) {\n            self.merging = false;\n            return\n        }\n    });\n}\n\nProject.prototype.getFileDiff = function(file,type) {\n    return gitTools.getFileDiff(this.path,file,type);\n}\n\nProject.prototype.getCommits = function(options) {\n    return gitTools.getCommits(this.path,options).catch(function(err) {\n        if (/bad default revision/i.test(err.message) || /ambiguous argument/i.test(err.message) || /does not have any commits yet/i.test(err.message)) {\n            return {\n                count:0,\n                commits:[],\n                total: 0\n            }\n        }\n        throw err;\n    })\n}\n\nProject.prototype.getCommit = function(sha) {\n    return gitTools.getCommit(this.path,sha);\n}\n\nProject.prototype.getFile = function (filePath,treeish) {\n    if (treeish !== \"_\") {\n        return gitTools.getFile(this.path, filePath, treeish);\n    } else {\n        return fs.readFile(fspath.join(this.path,filePath),\"utf8\");\n    }\n};\n\nProject.prototype.revertFile = function (filePath) {\n    var self = this;\n    return gitTools.revertFile(this.path, filePath).then(function() {\n        return self.load();\n    });\n};\n\nProject.prototype.status = function(user, includeRemote) {\n    var self = this;\n\n    var fetchPromise;\n    if (this.remotes && includeRemote) {\n        fetchPromise = gitTools.getRemoteBranch(self.path).then(function(remoteBranch) {\n            if (remoteBranch) {\n                var allRemotes = Object.keys(self.remotes);\n                var match = \"\";\n                allRemotes.forEach(function(remote) {\n                    if (remoteBranch.indexOf(remote) === 0 && match.length < remote.length) {\n                        match = remote;\n                    }\n                })\n                return self.fetch(user, match);\n            }\n        });\n    } else {\n        fetchPromise = Promise.resolve();\n    }\n\n    var completeStatus = function(fetchError) {\n        var promises = [\n            gitTools.getStatus(self.path),\n            fs.exists(fspath.join(self.path,\".git\",\"MERGE_HEAD\"))\n        ];\n        return Promise.all(promises).then(function(results) {\n            var result = results[0];\n            if (results[1]) {\n                result.merging = true;\n                if (!self.merging) {\n                    self.merging = true;\n                    runtime.events.emit(\"runtime-event\",{\n                        id:\"runtime-state\",\n                        payload:{\n                            type:\"warning\",\n                            error:\"git_merge_conflict\",\n                            project:self.name,\n                            text:\"notification.warnings.git_merge_conflict\"\n                        },\n                        retain:true}\n                    );\n                }\n            } else {\n                self.merging = false;\n            }\n            self.branches.local = result.branches.local;\n            self.branches.remote = result.branches.remote;\n            if (fetchError && !/ambiguous argument/.test(fetchError.message)) {\n                result.branches.remoteError = {\n                    remote: fetchError.remote,\n                    code: fetchError.code\n                }\n            }\n            if (result.commits.total === 0 && Object.keys(result.files).length === 0) {\n                if (!self.empty) {\n                    runtime.events.emit(\"runtime-event\",{\n                        id:\"runtime-state\",\n                        payload:{\n                            type:\"warning\",\n                            error:\"project_empty\",\n                            text:\"notification.warnings.project_empty\"},\n                            retain:true\n                        }\n                    );\n                }\n                self.empty = true;\n            } else {\n                if (self.empty) {\n                    if (self.paths.flowFile) {\n                        runtime.events.emit(\"runtime-event\",{id:\"runtime-state\",retain:true});\n                    } else {\n                        runtime.events.emit(\"runtime-event\",{\n                            id:\"runtime-state\",\n                            payload:{\n                                type:\"warning\",\n                                error:\"missing_flow_file\",\n                                text:\"notification.warnings.missing_flow_file\"},\n                                retain:true\n                            }\n                        );\n                    }\n                }\n                delete self.empty;\n            }\n            return result;\n        }).catch(function(err) {\n            if (/ambiguous argument/.test(err.message)) {\n                return {\n                    files:{},\n                    commits:{total:0},\n                    branches:{}\n                };\n            }\n            throw err;\n        });\n    }\n    return fetchPromise.then(completeStatus).catch(function(e) {\n        // if (e.code !== 'git_auth_failed') {\n        //     console.log(\"Fetch failed\");\n        //     console.log(e);\n        // }\n        return completeStatus(e);\n    })\n};\n\nProject.prototype.push = function (user,remoteBranchName,setRemote) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var remote = this.parseRemoteBranch(remoteBranchName||this.branches.remote);\n    return gitTools.push(this.path, remote.remote || this.currentRemote,remote.branch, setRemote, authCache.get(this.name,this.remotes[remote.remote || this.currentRemote].fetch,username));\n};\n\nProject.prototype.pull = function (user,remoteBranchName,setRemote,allowUnrelatedHistories) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var self = this;\n    if (setRemote) {\n        return gitTools.setUpstream(this.path, remoteBranchName).then(function() {\n            self.currentRemote = self.parseRemoteBranch(remoteBranchName).remote;\n            return gitTools.pull(self.path, null, null, allowUnrelatedHistories, authCache.get(self.name,self.remotes[self.currentRemote].fetch,username),getGitUser(user));\n        })\n    } else {\n        var remote = this.parseRemoteBranch(remoteBranchName);\n        return gitTools.pull(this.path, remote.remote, remote.branch, allowUnrelatedHistories, authCache.get(this.name,this.remotes[remote.remote||self.currentRemote].fetch,username),getGitUser(user));\n    }\n};\n\nProject.prototype.resolveMerge = function (file,resolutions) {\n    var filePath = fspath.join(this.path,file);\n    var self = this;\n    if (typeof resolutions === 'string') {\n        return util.writeFile(filePath, resolutions).then(function() {\n            return self.stageFile(file);\n        })\n    }\n    return fs.readFile(filePath,\"utf8\").then(function(content) {\n        var lines = content.split(\"\\n\");\n        var result = [];\n        var ignoreBlock = false;\n        var currentBlock;\n        for (var i=1;i<=lines.length;i++) {\n            if (resolutions.hasOwnProperty(i)) {\n                currentBlock = resolutions[i];\n                if (currentBlock.selection === \"A\") {\n                    ignoreBlock = false;\n                } else {\n                    ignoreBlock = true;\n                }\n                continue;\n            }\n            if (currentBlock) {\n                if (currentBlock.separator === i) {\n                    if (currentBlock.selection === \"A\") {\n                        ignoreBlock = true;\n                    } else {\n                        ignoreBlock = false;\n                    }\n                    continue;\n                } else if (currentBlock.changeEnd === i) {\n                    currentBlock = null;\n                    continue;\n                } else if (ignoreBlock) {\n                    continue;\n                }\n            }\n            result.push(lines[i-1]);\n        }\n        var finalResult = result.join(\"\\n\");\n        return util.writeFile(filePath,finalResult).then(function() {\n            return self.stageFile(file);\n        })\n    });\n};\n\nProject.prototype.abortMerge = function () {\n    var self = this;\n    return gitTools.abortMerge(this.path).then(function() {\n        self.merging = false;\n    })\n};\n\nProject.prototype.getBranches = function (user, isRemote) {\n    var self = this;\n    var fetchPromise;\n    if (isRemote) {\n        fetchPromise = self.fetch(user);\n    } else {\n        fetchPromise = Promise.resolve();\n    }\n    return fetchPromise.then(function() {\n        return gitTools.getBranches(self.path,isRemote);\n    });\n};\n\nProject.prototype.deleteBranch = function (user, branch, isRemote, force) {\n    // TODO: isRemote==true support\n    // TODO: make sure we don't try to delete active branch\n    return gitTools.deleteBranch(this.path,branch,isRemote, force);\n};\n\nProject.prototype.fetch = function(user,remoteName) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var project = this;\n    if (remoteName) {\n        return gitTools.fetch(project.path,remoteName,authCache.get(project.name,project.remotes[remoteName].fetch,username)).catch(function(err) {\n            err.remote = remoteName;\n            throw err;\n        })\n    } else {\n        var remotes = Object.keys(this.remotes);\n        var promise = Promise.resolve();\n        remotes.forEach(function(remote) {\n            promise = promise.then(function() {\n                return gitTools.fetch(project.path,remote,authCache.get(project.name,project.remotes[remote].fetch,username))\n            }).catch(function(err) {\n                if (!err.remote) {\n                    err.remote = remote;\n                }\n                throw err;\n            })\n        });\n        return promise;\n    }\n}\n\nProject.prototype.setBranch = function (branchName, isCreate) {\n    var self = this;\n    return gitTools.checkoutBranch(this.path, branchName, isCreate).then(function() {\n        return self.load();\n    })\n};\n\nProject.prototype.getBranchStatus = function (branchName) {\n    return gitTools.getBranchStatus(this.path,branchName);\n};\n\nProject.prototype.getRemotes = function (user) {\n    return gitTools.getRemotes(this.path).then(function(remotes) {\n        var result = [];\n        for (var name in remotes) {\n            if (remotes.hasOwnProperty(name)) {\n                remotes[name].name = name;\n                result.push(remotes[name]);\n            }\n        }\n        return {remotes:result};\n    })\n};\n\nProject.prototype.addRemote = function(user,remote,options) {\n    var project = this;\n    return gitTools.addRemote(this.path,remote,options).then(function() {\n        return project.loadRemotes()\n    });\n}\n\nProject.prototype.updateRemote = function(user,remote,options) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n\n    if (options.auth) {\n        var url = this.remotes[remote].fetch;\n        if (options.auth.keyFile) {\n            options.auth.key_path = sshKeys.getPrivateKeyPath(getSSHKeyUsername(user), options.auth.keyFile);\n        }\n        authCache.set(this.name,url,username,options.auth);\n    }\n    return Promise.resolve();\n}\n\nProject.prototype.removeRemote = function(user, remote) {\n    // TODO: if this was the last remote using this url, then remove the authCache\n    // details.\n    var project = this;\n    return gitTools.removeRemote(this.path,remote).then(function() {\n        return project.loadRemotes()\n    });\n}\n\nProject.prototype.getFlowFile = function() {\n    // console.log(\"Project.getFlowFile = \",this.paths.flowFile);\n    if (this.paths.flowFile) {\n        return fspath.join(this.path,this.paths.flowFile);\n    } else {\n        return null;\n    }\n}\n\nProject.prototype.getFlowFileBackup = function() {\n    var flowFile = this.getFlowFile();\n    if (flowFile) {\n        return getBackupFilename(flowFile);\n    }\n    return null;\n}\n\nProject.prototype.getCredentialsFile = function() {\n    // console.log(\"Project.getCredentialsFile = \",this.paths.credentialsFile);\n    if (this.paths.credentialsFile) {\n        return fspath.join(this.path,this.paths.credentialsFile);\n    } else {\n        return this.paths.credentialsFile;\n    }\n}\n\nProject.prototype.getCredentialsFileBackup = function() {\n    return getBackupFilename(this.getCredentialsFile());\n}\n\nProject.prototype.export = function () {\n\n    return {\n        name: this.name,\n        summary: this.package.description,\n        version: this.package.version,\n        description: this.description,\n        dependencies: this.package.dependencies||{},\n        empty: this.empty,\n        settings: {\n            credentialsEncrypted: (typeof this.credentialSecret === \"string\") && this.credentialSecret.length > 0,\n            credentialSecretInvalid: this.credentialSecretInvalid\n        },\n        files: {\n            package: this.paths['package.json'],\n            flow: this.paths.flowFile,\n            credentials: this.paths.credentialsFile\n        },\n        git: {\n            remotes: this.remotes,\n            branches: this.branches\n        }\n    }\n};\n\nfunction getCredentialsFilename(filename) {\n    filename = filename || \"undefined\";\n    // TODO: DRY - ./index.js\n    var ffDir = fspath.dirname(filename);\n    var ffExt = fspath.extname(filename);\n    var ffBase = fspath.basename(filename,ffExt);\n    return fspath.join(ffDir,ffBase+\"_cred\"+ffExt);\n}\nfunction getBackupFilename(filename) {\n    // TODO: DRY - ./index.js\n    filename = filename || \"undefined\";\n    var ffName = fspath.basename(filename);\n    var ffDir = fspath.dirname(filename);\n    return fspath.join(ffDir,\".\"+ffName+\".backup\");\n}\nfunction checkProjectExists(projectPath) {\n    return fs.pathExists(projectPath).then(function(exists) {\n        if (!exists) {\n            var e = new Error(\"Project not found\");\n            e.code = \"project_not_found\";\n            var name = fspath.basename(projectPath);\n            e.project = name;\n            throw e;\n        }\n    });\n}\nfunction createDefaultProject(user, project) {\n    var projectPath = fspath.join(projectsDir,project.name);\n    // Create a basic skeleton of a project\n    return gitTools.initRepo(projectPath).then(function() {\n        var promises = [];\n        var files = Object.keys(defaultFileSet);\n        if (project.files) {\n            if (project.files.flow && !/\\.\\./.test(project.files.flow)) {\n                var flowFilePath;\n                var credsFilePath;\n\n                if (project.migrateFiles) {\n                    var baseFlowFileName = project.files.flow || fspath.basename(project.files.oldFlow);\n                    var baseCredentialFileName = project.files.credentials || fspath.basename(project.files.oldCredentials);\n                    files.push(baseFlowFileName);\n                    files.push(baseCredentialFileName);\n                    flowFilePath = fspath.join(projectPath,baseFlowFileName);\n                    credsFilePath = fspath.join(projectPath,baseCredentialFileName);\n                    if (fs.existsSync(project.files.oldFlow)) {\n                        log.trace(\"Migrating \"+project.files.oldFlow+\" to \"+flowFilePath);\n                        promises.push(fs.copy(project.files.oldFlow,flowFilePath));\n                    } else {\n                        log.trace(project.files.oldFlow+\" does not exist - creating blank file\");\n                        promises.push(util.writeFile(flowFilePath,\"[]\"));\n                    }\n                    log.trace(\"Migrating \"+project.files.oldCredentials+\" to \"+credsFilePath);\n                    runtime.nodes.setCredentialSecret(project.credentialSecret);\n                    promises.push(runtime.nodes.exportCredentials().then(function(creds) {\n                        var credentialData;\n                        if (settings.flowFilePretty) {\n                            credentialData = JSON.stringify(creds,null,4);\n                        } else {\n                            credentialData = JSON.stringify(creds);\n                        }\n                        return util.writeFile(credsFilePath,credentialData);\n                    }));\n                    delete project.migrateFiles;\n                    project.files.flow = baseFlowFileName;\n                    project.files.credentials = baseCredentialFileName;\n                } else {\n                    project.files.credentials = project.files.credentials || getCredentialsFilename(project.files.flow);\n                    files.push(project.files.flow);\n                    files.push(project.files.credentials);\n                    flowFilePath = fspath.join(projectPath,project.files.flow);\n                    credsFilePath = getCredentialsFilename(flowFilePath);\n                    promises.push(util.writeFile(flowFilePath,\"[]\"));\n                    promises.push(util.writeFile(credsFilePath,\"{}\"));\n                }\n            }\n        }\n        for (var file in defaultFileSet) {\n            if (defaultFileSet.hasOwnProperty(file)) {\n                promises.push(util.writeFile(fspath.join(projectPath,file),defaultFileSet[file](project)));\n            }\n        }\n\n        return Promise.all(promises).then(function() {\n            return gitTools.stageFile(projectPath,files);\n        }).then(function() {\n            return gitTools.commit(projectPath,\"Create project\",getGitUser(user));\n        })\n    });\n}\nfunction checkProjectFiles(project) {\n    var promises = [];\n    var paths = [];\n    for (var file in defaultFileSet) {\n        if (defaultFileSet.hasOwnProperty(file)) {\n            paths.push(file);\n            promises.push(fs.stat(fspath.join(project.path,project.paths.root,file)));\n        }\n    }\n    return when.settle(promises).then(function(results) {\n        var missing = [];\n        results.forEach(function(result,i) {\n            if (result.state === 'rejected') {\n                missing.push(paths[i]);\n            }\n        });\n        return missing;\n    }).then(function(missing) {\n        // if (createMissing) {\n        //     var promises = [];\n        //     missing.forEach(function(file) {\n        //         promises.push(util.writeFile(fspath.join(projectPath,file),defaultFileSet[file](project)));\n        //     });\n        //     return promises;\n        // } else {\n        return missing;\n        // }\n    });\n}\nfunction createProject(user, metadata) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    if (!metadata.path) {\n        throw new Error(\"Project missing path property\");\n    }\n    if (!metadata.name) {\n        throw new Error(\"Project missing name property\");\n    }\n\n    var project = metadata.name;\n    var projectPath = metadata.path;\n    return new Promise(function(resolve,reject) {\n        fs.stat(projectPath, function(err,stat) {\n            if (!err) {\n                var e = new Error(\"NLS: Project already exists\");\n                e.code = \"project_exists\";\n                return reject(e);\n            }\n            fs.ensureDir(projectPath).then(function() {\n                var projects = settings.get('projects');\n                if (!projects) {\n                    projects = {\n                        projects:{}\n                    }\n                }\n                projects.projects[project] = {};\n                if (metadata.hasOwnProperty('credentialSecret')) {\n                    if (metadata.credentialSecret === \"\") {\n                        metadata.credentialSecret = false;\n                    }\n                    projects.projects[project].credentialSecret = metadata.credentialSecret;\n                }\n                return settings.set('projects',projects);\n            }).then(function() {\n                if (metadata.git && metadata.git.remotes && metadata.git.remotes.origin) {\n                    var originRemote = metadata.git.remotes.origin;\n                    var auth;\n                    if (originRemote.hasOwnProperty(\"username\") && originRemote.hasOwnProperty(\"password\")) {\n                        authCache.set(project,originRemote.url,username,{ // TODO: hardcoded remote name\n                                username: originRemote.username,\n                                password: originRemote.password\n                            }\n                        );\n                        auth = authCache.get(project,originRemote.url,username);\n                    }\n                    else if (originRemote.hasOwnProperty(\"keyFile\") && originRemote.hasOwnProperty(\"passphrase\")) {\n                        authCache.set(project,originRemote.url,username,{ // TODO: hardcoded remote name\n                                key_path: sshKeys.getPrivateKeyPath(getSSHKeyUsername(user), originRemote.keyFile),\n                                passphrase: originRemote.passphrase\n                            }\n                        );\n                        auth = authCache.get(project,originRemote.url,username);\n                    }\n                    return gitTools.clone(originRemote,auth,projectPath);\n                } else {\n                    return createDefaultProject(user, metadata);\n                }\n            }).then(function() {\n                resolve(loadProject(projectPath))\n            }).catch(function(err) {\n                fs.remove(projectPath,function() {\n                    reject(err);\n                });\n            });\n        })\n    })\n}\nfunction deleteProject(user, projectPath) {\n    return checkProjectExists(projectPath).then(function() {\n        return fs.remove(projectPath).then(function() {\n            var name = fspath.basename(projectPath);\n            var projects = settings.get('projects');\n            delete projects.projects[name];\n            return settings.set('projects', projects);\n        });\n    });\n}\nfunction loadProject(projectPath) {\n    return checkProjectExists(projectPath).then(function() {\n        var project = new Project(projectPath);\n        return project.load();\n    });\n}\nfunction init(_settings, _runtime) {\n    settings = _settings;\n    runtime = _runtime;\n    projectsDir = fspath.join(settings.userDir,\"projects\");\n    authCache.init();\n}\n\nmodule.exports = {\n    init: init,\n    load: loadProject,\n    create: createProject,\n    delete: deleteProject\n}\n", "/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar fs = require('fs-extra');\nvar when = require('when');\nvar fspath = require(\"path\");\nvar nodeFn = require('when/node/function');\nvar crypto = require('crypto');\n\nvar storageSettings = require(\"../settings\");\nvar util = require(\"../util\");\nvar gitTools = require(\"./git\");\nvar sshTools = require(\"./ssh\");\n\nvar Projects = require(\"./Project\");\n\nvar settings;\nvar runtime;\nvar log = require(\"@node-red/util\").log;\n\nvar projectsEnabled = false;\nvar projectLogMessages = [];\n\nvar projectsDir;\nvar activeProject\n\nvar globalGitUser = false;\n\nfunction init(_settings, _runtime) {\n    settings = _settings;\n    runtime = _runtime;\n\n    try {\n        if (settings.editorTheme.projects.enabled === true) {\n            projectsEnabled = true;\n        } else if (settings.editorTheme.projects.enabled === false) {\n            projectLogMessages.push(log._(\"storage.localfilesystem.projects.disabled\"))\n        }\n    } catch(err) {\n        projectLogMessages.push(log._(\"storage.localfilesystem.projects.disabledNoFlag\"))\n        projectsEnabled = false;\n    }\n\n    if (settings.flowFile) {\n        flowsFile = settings.flowFile;\n        // handle Unix and Windows \"C:\\\" and Windows \"\\\\\" for UNC.\n        if (fspath.isAbsolute(flowsFile)) {\n        //if (((flowsFile[0] == \"\\\\\") && (flowsFile[1] == \"\\\\\")) || (flowsFile[0] == \"/\") || (flowsFile[1] == \":\")) {\n            // Absolute path\n            flowsFullPath = flowsFile;\n        } else if (flowsFile.substring(0,2) === \"./\") {\n            // Relative to cwd\n            flowsFullPath = fspath.join(process.cwd(),flowsFile);\n        } else {\n            try {\n                fs.statSync(fspath.join(process.cwd(),flowsFile));\n                // Found in cwd\n                flowsFullPath = fspath.join(process.cwd(),flowsFile);\n            } catch(err) {\n                // Use userDir\n                flowsFullPath = fspath.join(settings.userDir,flowsFile);\n            }\n        }\n\n    } else {\n        flowsFile = 'flows_'+require('os').hostname()+'.json';\n        flowsFullPath = fspath.join(settings.userDir,flowsFile);\n    }\n    var ffExt = fspath.extname(flowsFullPath);\n    var ffBase = fspath.basename(flowsFullPath,ffExt);\n\n    flowsFileBackup = getBackupFilename(flowsFullPath);\n    credentialsFile = fspath.join(settings.userDir,ffBase+\"_cred\"+ffExt);\n    credentialsFileBackup = getBackupFilename(credentialsFile)\n\n    var setupProjectsPromise;\n\n    if (projectsEnabled) {\n        return sshTools.init(settings,runtime).then(function() {\n            gitTools.init(_settings).then(function(gitConfig) {\n                if (!gitConfig || /^1\\./.test(gitConfig.version)) {\n                    if (!gitConfig) {\n                        projectLogMessages.push(log._(\"storage.localfilesystem.projects.git-not-found\"))\n                    } else {\n                        projectLogMessages.push(log._(\"storage.localfilesystem.projects.git-version-old\",{version:gitConfig.version}))\n                    }\n                    projectsEnabled = false;\n                    try {\n                        // As projects have to be turned on, we know this property\n                        // must exist at this point, so turn it off.\n                        // TODO: when on-by-default, this will need to do more\n                        // work to disable.\n                        settings.editorTheme.projects.enabled = false;\n                    } catch(err) {\n                    }\n                } else {\n                    globalGitUser = gitConfig.user;\n                    Projects.init(settings,runtime);\n                    sshTools.init(settings);\n                    projectsDir = fspath.join(settings.userDir,\"projects\");\n                    if (!settings.readOnly) {\n                        return fs.ensureDir(projectsDir)\n                        //TODO: this is accessing settings from storage directly as settings\n                        //      has not yet been initialised. That isn't ideal - can this be deferred?\n                        .then(storageSettings.getSettings)\n                        .then(function(globalSettings) {\n                            var saveSettings = false;\n                            if (!globalSettings.projects) {\n                                globalSettings.projects = {\n                                    projects: {}\n                                }\n                                saveSettings = true;\n                            } else {\n                                activeProject = globalSettings.projects.activeProject;\n                            }\n                            if (!globalSettings.projects.projects) {\n                                globalSettings.projects.projects = {};\n                                saveSettings = true;\n                            }\n                            if (settings.flowFile) {\n                                // if flowFile is a known project name - use it\n                                if (globalSettings.projects.projects.hasOwnProperty(settings.flowFile)) {\n                                    activeProject = settings.flowFile;\n                                    globalSettings.projects.activeProject = settings.flowFile;\n                                    saveSettings = true;\n                                } else {\n                                    // if it resolves to a dir - use it\n                                    try {\n                                        var stat = fs.statSync(fspath.join(projectsDir,settings.flowFile));\n                                        if (stat && stat.isDirectory()) {\n                                            activeProject = settings.flowFile;\n                                            globalSettings.projects.activeProject = activeProject;\n                                            // Now check for a credentialSecret\n                                            if (settings.credentialSecret !== undefined) {\n                                                globalSettings.projects.projects[settings.flowFile] = {\n                                                    credentialSecret: settings.credentialSecret\n                                                }\n                                                saveSettings = true;\n                                            }\n                                        }\n                                    } catch(err) {\n                                        // Doesn't exist, handle as a flow file to be created\n                                    }\n                                }\n                            }\n                            if (!activeProject) {\n                                projectLogMessages.push(log._(\"storage.localfilesystem.no-active-project\"))\n                            }\n                            if (saveSettings) {\n                                return storageSettings.saveSettings(globalSettings);\n                            }\n                        });\n                    }\n                }\n            });\n        });\n    }\n    return Promise.resolve();\n}\n\nfunction listProjects() {\n    return fs.readdir(projectsDir).then(function(fns) {\n        var dirs = [];\n        fns.sort(function(A,B) {\n            return A.toLowerCase().localeCompare(B.toLowerCase());\n        }).filter(function(fn) {\n            var fullPath = fspath.join(projectsDir,fn);\n            if (fn[0] != \".\") {\n                var stats = fs.lstatSync(fullPath);\n                if (stats.isDirectory()) {\n                    dirs.push(fn);\n                }\n            }\n        });\n        return dirs;\n    });\n}\n\nfunction getUserGitSettings(user) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var userSettings = settings.getUserSettings(username)||{};\n    return userSettings.git;\n}\n\nfunction getBackupFilename(filename) {\n    var ffName = fspath.basename(filename);\n    var ffDir = fspath.dirname(filename);\n    return fspath.join(ffDir,\".\"+ffName+\".backup\");\n}\n\nfunction loadProject(name) {\n    var projectPath = name;\n    if (projectPath.indexOf(fspath.sep) === -1) {\n        projectPath = fspath.join(projectsDir,name);\n    }\n    return Projects.load(projectPath).then(function(project) {\n        activeProject = project;\n        flowsFullPath = project.getFlowFile();\n        flowsFileBackup = project.getFlowFileBackup();\n        credentialsFile = project.getCredentialsFile();\n        credentialsFileBackup = project.getCredentialsFileBackup();\n        return project;\n    })\n}\n\nfunction getProject(user, name) {\n    checkActiveProject(name);\n    //return when.resolve(activeProject.info);\n    return Promise.resolve(activeProject.export());\n}\n\nfunction deleteProject(user, name) {\n    if (activeProject && activeProject.name === name) {\n        var e = new Error(\"NLS: Can't delete the active project\");\n        e.code = \"cannot_delete_active_project\";\n        throw e;\n    }\n    var projectPath = fspath.join(projectsDir,name);\n    return Projects.delete(user, projectPath);\n}\n\nfunction checkActiveProject(project) {\n    if (!activeProject || activeProject.name !== project) {\n        //TODO: throw better err\n        throw new Error(\"Cannot operate on inactive project wanted:\"+project+\" current:\"+(activeProject&&activeProject.name));\n    }\n}\nfunction getFiles(user, project) {\n    checkActiveProject(project);\n    return activeProject.getFiles();\n}\nfunction stageFile(user, project,file) {\n    checkActiveProject(project);\n    return activeProject.stageFile(file);\n}\nfunction unstageFile(user, project,file) {\n    checkActiveProject(project);\n    return activeProject.unstageFile(file);\n}\nfunction commit(user, project,options) {\n    checkActiveProject(project);\n    var isMerging = activeProject.isMerging();\n    return activeProject.commit(user, options).then(function() {\n        // The project was merging, now it isn't. Lets reload.\n        if (isMerging && !activeProject.isMerging()) {\n            return reloadActiveProject(\"merge-complete\");\n        }\n    })\n}\nfunction getFileDiff(user, project,file,type) {\n    checkActiveProject(project);\n    return activeProject.getFileDiff(file,type);\n}\nfunction getCommits(user, project,options) {\n    checkActiveProject(project);\n    return activeProject.getCommits(options);\n}\nfunction getCommit(user, project,sha) {\n    checkActiveProject(project);\n    return activeProject.getCommit(sha);\n}\n\nfunction getFile(user, project,filePath,sha) {\n    checkActiveProject(project);\n    return activeProject.getFile(filePath,sha);\n}\nfunction revertFile(user, project,filePath) {\n    checkActiveProject(project);\n    return activeProject.revertFile(filePath).then(function() {\n        return reloadActiveProject(\"revert\");\n    })\n}\nfunction push(user, project,remoteBranchName,setRemote) {\n    checkActiveProject(project);\n    return activeProject.push(user,remoteBranchName,setRemote);\n}\nfunction pull(user, project,remoteBranchName,setRemote,allowUnrelatedHistories) {\n    checkActiveProject(project);\n    return activeProject.pull(user,remoteBranchName,setRemote,allowUnrelatedHistories).then(function() {\n        return reloadActiveProject(\"pull\");\n    });\n}\nfunction getStatus(user, project, includeRemote) {\n    checkActiveProject(project);\n    return activeProject.status(user, includeRemote);\n}\nfunction resolveMerge(user, project,file,resolution) {\n    checkActiveProject(project);\n    return activeProject.resolveMerge(file,resolution);\n}\nfunction abortMerge(user, project) {\n    checkActiveProject(project);\n    return activeProject.abortMerge().then(function() {\n        return reloadActiveProject(\"merge-abort\")\n    });\n}\nfunction getBranches(user, project,isRemote) {\n    checkActiveProject(project);\n    return activeProject.getBranches(user, isRemote);\n}\n\nfunction deleteBranch(user, project, branch, isRemote, force) {\n    checkActiveProject(project);\n    return activeProject.deleteBranch(user, branch, isRemote, force);\n}\n\nfunction setBranch(user, project,branchName,isCreate) {\n    checkActiveProject(project);\n    return activeProject.setBranch(branchName,isCreate).then(function() {\n        return reloadActiveProject(\"change-branch\");\n    });\n}\nfunction getBranchStatus(user, project,branchName) {\n    checkActiveProject(project);\n    return activeProject.getBranchStatus(branchName);\n}\n\n\nfunction getRemotes(user, project) {\n    checkActiveProject(project);\n    return activeProject.getRemotes(user);\n}\nfunction addRemote(user, project, options) {\n    checkActiveProject(project);\n    return activeProject.addRemote(user, options.name, options);\n}\nfunction removeRemote(user, project, remote) {\n    checkActiveProject(project);\n    return activeProject.removeRemote(user, remote);\n}\nfunction updateRemote(user, project, remote, body) {\n    checkActiveProject(project);\n    return activeProject.updateRemote(user, remote, body);\n}\n\nfunction getActiveProject(user) {\n    return activeProject;\n}\n\nfunction reloadActiveProject(action) {\n    return runtime.nodes.stopFlows().then(function() {\n        return runtime.nodes.loadFlows(true).then(function() {\n            runtime.events.emit(\"runtime-event\",{id:\"project-update\", payload:{ project: activeProject.name, action:action}});\n        }).catch(function(err) {\n            // We're committed to the project change now, so notify editors\n            // that it has changed.\n            runtime.events.emit(\"runtime-event\",{id:\"project-update\", payload:{ project: activeProject.name, action:action}});\n            throw err;\n        });\n    });\n}\nfunction createProject(user, metadata) {\n    if (metadata.files && metadata.migrateFiles) {\n        // We expect there to be no active project in this scenario\n        if (activeProject) {\n            throw new Error(\"Cannot migrate as there is an active project\");\n        }\n        var currentEncryptionKey = settings.get('credentialSecret');\n        if (currentEncryptionKey === undefined) {\n            currentEncryptionKey = settings.get('_credentialSecret');\n        }\n        if (!metadata.hasOwnProperty('credentialSecret')) {\n            metadata.credentialSecret = currentEncryptionKey;\n        }\n        if (!metadata.files.flow) {\n            metadata.files.flow = fspath.basename(flowsFullPath);\n        }\n        if (!metadata.files.credentials) {\n            metadata.files.credentials = fspath.basename(credentialsFile);\n        }\n\n        metadata.files.oldFlow = flowsFullPath;\n        metadata.files.oldCredentials = credentialsFile;\n        metadata.files.credentialSecret = currentEncryptionKey;\n    }\n    metadata.path = fspath.join(projectsDir,metadata.name);\n    return Projects.create(user, metadata).then(function(p) {\n        return setActiveProject(user, p.name);\n    }).then(function() {\n        return getProject(user, metadata.name);\n    })\n}\nfunction setActiveProject(user, projectName) {\n    return loadProject(projectName).then(function(project) {\n        var globalProjectSettings = settings.get(\"projects\")||{};\n        globalProjectSettings.activeProject = project.name;\n        return settings.set(\"projects\",globalProjectSettings).then(function() {\n            log.info(log._(\"storage.localfilesystem.projects.changing-project\",{project:(activeProject&&activeProject.name)||\"none\"}));\n            log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n            // console.log(\"Updated file targets to\");\n            // console.log(flowsFullPath)\n            // console.log(credentialsFile)\n            return reloadActiveProject(\"loaded\");\n        })\n    });\n}\n\nfunction initialiseProject(user, project, data) {\n    if (!activeProject || activeProject.name !== project) {\n        // TODO standardise\n        throw new Error(\"Cannot initialise inactive project\");\n    }\n    return activeProject.initialise(user,data).then(function(result) {\n        flowsFullPath = activeProject.getFlowFile();\n        flowsFileBackup = activeProject.getFlowFileBackup();\n        credentialsFile = activeProject.getCredentialsFile();\n        credentialsFileBackup = activeProject.getCredentialsFileBackup();\n        runtime.nodes.setCredentialSecret(activeProject.credentialSecret);\n        return reloadActiveProject(\"updated\");\n    });\n}\nfunction updateProject(user, project, data) {\n    if (!activeProject || activeProject.name !== project) {\n        // TODO standardise\n        throw new Error(\"Cannot update inactive project\");\n    }\n    // In case this triggers a credential secret change\n    var isReset = data.resetCredentialSecret;\n    var wasInvalid = activeProject.credentialSecretInvalid;\n\n    return activeProject.update(user,data).then(function(result) {\n\n        if (result.flowFilesChanged) {\n            flowsFullPath = activeProject.getFlowFile();\n            flowsFileBackup = activeProject.getFlowFileBackup();\n            credentialsFile = activeProject.getCredentialsFile();\n            credentialsFileBackup = activeProject.getCredentialsFileBackup();\n            return reloadActiveProject(\"updated\");\n        } else if (result.credentialSecretChanged) {\n            if (isReset || !wasInvalid) {\n                if (isReset) {\n                    runtime.nodes.clearCredentials();\n                }\n                runtime.nodes.setCredentialSecret(activeProject.credentialSecret);\n                return runtime.nodes.exportCredentials()\n                    .then(runtime.storage.saveCredentials)\n                    .then(function() {\n                        if (wasInvalid) {\n                            return reloadActiveProject(\"updated\");\n                        }\n                    });\n            } else if (wasInvalid) {\n                return reloadActiveProject(\"updated\");\n            }\n        }\n    });\n}\nfunction setCredentialSecret(data) { //existingSecret,secret) {\n    var isReset = data.resetCredentialSecret;\n    var wasInvalid = activeProject.credentialSecretInvalid;\n    return activeProject.update(data).then(function() {\n        if (isReset || !wasInvalid) {\n            if (isReset) {\n                runtime.nodes.clearCredentials();\n            }\n            runtime.nodes.setCredentialSecret(activeProject.credentialSecret);\n            return runtime.nodes.exportCredentials()\n                .then(runtime.storage.saveCredentials)\n                .then(function() {\n                    if (wasInvalid) {\n                        return reloadActiveProject(\"updated\");\n                    }\n                });\n        } else if (wasInvalid) {\n            return reloadActiveProject(\"updated\");\n        }\n    })\n}\n\n\nvar initialFlowLoadComplete = false;\n\nvar flowsFile;\nvar flowsFullPath;\nvar flowsFileExists = false;\nvar flowsFileBackup;\nvar credentialsFile;\nvar credentialsFileBackup;\n\nfunction getFlows() {\n    if (!initialFlowLoadComplete) {\n        initialFlowLoadComplete = true;\n        log.info(log._(\"storage.localfilesystem.user-dir\",{path:settings.userDir}));\n        if (activeProject) {\n            // At this point activeProject will be a string, so go load it and\n            // swap in an instance of Project\n            return loadProject(activeProject).then(function() {\n                log.info(log._(\"storage.localfilesystem.projects.active-project\",{project:activeProject.name||\"none\"}));\n                log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n                return getFlows();\n            });\n        } else {\n            if (projectsEnabled) {\n                log.warn(log._(\"storage.localfilesystem.projects.no-active-project\"))\n            } else {\n                projectLogMessages.forEach(log.warn);\n            }\n            log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n        }\n    }\n    if (activeProject) {\n        var error;\n        if (activeProject.isEmpty()) {\n            log.warn(\"Project repository is empty\");\n            error = new Error(\"Project repository is empty\");\n            error.code = \"project_empty\";\n            return when.reject(error);\n        }\n        if (activeProject.missingFiles && activeProject.missingFiles.indexOf('package.json') !== -1) {\n            log.warn(\"Project missing package.json\");\n            error = new Error(\"Project missing package.json\");\n            error.code = \"missing_package_file\";\n            return when.reject(error);\n        }\n        if (!activeProject.getFlowFile()) {\n            log.warn(\"Project has no flow file\");\n            error = new Error(\"Project has no flow file\");\n            error.code = \"missing_flow_file\";\n            return when.reject(error);\n        }\n        if (activeProject.isMerging()) {\n            log.warn(\"Project has unmerged changes\");\n            error = new Error(\"Project has unmerged changes. Cannot load flows\");\n            error.code = \"git_merge_conflict\";\n            return when.reject(error);\n        }\n\n    }\n    return util.readFile(flowsFullPath,flowsFileBackup,null,'flow').then(function(result) {\n        if (result === null) {\n            flowsFileExists = false;\n            return [];\n        }\n        flowsFileExists = true;\n        return result;\n    });\n}\n\nfunction saveFlows(flows, user) {\n    if (settings.readOnly) {\n        return when.resolve();\n    }\n    if (activeProject && activeProject.isMerging()) {\n        var error = new Error(\"Project has unmerged changes. Cannot deploy new flows\");\n        error.code = \"git_merge_conflict\";\n        return when.reject(error);\n    }\n\n    flowsFileExists = true;\n\n    var flowData;\n\n    if (settings.flowFilePretty || (activeProject && settings.flowFilePretty !== false) ) {\n        // Pretty format if option enabled, or using Projects and not explicitly disabled\n        flowData = JSON.stringify(flows,null,4);\n    } else {\n        flowData = JSON.stringify(flows);\n    }\n    return util.writeFile(flowsFullPath, flowData, flowsFileBackup).then(() => {\n        var gitSettings = getUserGitSettings(user) || {};\n        var workflowMode = (gitSettings.workflow||{}).mode || \"manual\";\n        if (activeProject && workflowMode === 'auto') {\n            return activeProject.stageFile([flowsFullPath, credentialsFile]).then(() => {\n                return activeProject.commit(user,{message:\"Update flow files\"})\n            })\n        }\n    });\n}\n\nfunction getCredentials() {\n    return util.readFile(credentialsFile,credentialsFileBackup,{},'credentials');\n}\n\nfunction saveCredentials(credentials) {\n    if (settings.readOnly) {\n        return when.resolve();\n    }\n\n    var credentialData;\n    if (settings.flowFilePretty || (activeProject && settings.flowFilePretty !== false) ) {\n        // Pretty format if option enabled, or using Projects and not explicitly disabled\n        credentialData = JSON.stringify(credentials,null,4);\n    } else {\n        credentialData = JSON.stringify(credentials);\n    }\n    return util.writeFile(credentialsFile, credentialData, credentialsFileBackup);\n}\n\nfunction getFlowFilename() {\n    if (flowsFullPath) {\n        return fspath.basename(flowsFullPath);\n    }\n}\nfunction getCredentialsFilename() {\n    if (flowsFullPath) {\n        return fspath.basename(credentialsFile);\n    }\n}\n\nmodule.exports = {\n    init: init,\n    listProjects: listProjects,\n    getActiveProject: getActiveProject,\n    setActiveProject: setActiveProject,\n    getProject: getProject,\n    deleteProject: deleteProject,\n    createProject: createProject,\n    initialiseProject: initialiseProject,\n    updateProject: updateProject,\n    getFiles: getFiles,\n    getFile: getFile,\n    revertFile: revertFile,\n    stageFile: stageFile,\n    unstageFile: unstageFile,\n    commit: commit,\n    getFileDiff: getFileDiff,\n    getCommits: getCommits,\n    getCommit: getCommit,\n    push: push,\n    pull: pull,\n    getStatus:getStatus,\n    resolveMerge: resolveMerge,\n    abortMerge: abortMerge,\n    getBranches: getBranches,\n    deleteBranch: deleteBranch,\n    setBranch: setBranch,\n    getBranchStatus:getBranchStatus,\n    getRemotes: getRemotes,\n    addRemote: addRemote,\n    removeRemote: removeRemote,\n    updateRemote: updateRemote,\n    getFlowFilename: getFlowFilename,\n    flowFileExists: function() { return flowsFileExists },\n    getCredentialsFilename: getCredentialsFilename,\n    getGlobalGitUser: function() { return globalGitUser },\n    getFlows: getFlows,\n    saveFlows: saveFlows,\n    getCredentials: getCredentials,\n    saveCredentials: saveCredentials,\n\n    ssh: sshTools\n\n};\n"], "fixing_code": ["/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n\nvar fs = require('fs-extra');\nvar when = require('when');\nvar fspath = require(\"path\");\nvar os = require('os');\n\nvar gitTools = require(\"./git\");\nvar util = require(\"../util\");\nvar defaultFileSet = require(\"./defaultFileSet\");\nvar sshKeys = require(\"./ssh\");\nvar settings;\nvar runtime;\nvar log = require(\"@node-red/util\").log;\n\nvar projectsDir;\n\nvar authCache = require(\"./git/authCache\");\n\n// TODO: DRY - red/api/editor/sshkeys !\nfunction getSSHKeyUsername(userObj) {\n    var username = '__default';\n    if ( userObj && userObj.username ) {\n        username = userObj.username;\n    }\n    return username;\n}\n\nfunction getUserGitSettings(user) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var userSettings = settings.getUserSettings(username)||{};\n    return userSettings.git;\n}\n\nfunction getGitUser(user) {\n    var gitSettings = getUserGitSettings(user);\n    if (gitSettings) {\n        return gitSettings.user;\n    }\n    return null;\n}\n\nfunction Project(path) {\n    this.path = path;\n    this.name = fspath.basename(path);\n    this.paths = {};\n    this.files = {};\n    this.auth = {origin:{}};\n    this.missingFiles = [];\n    this.credentialSecret = null;\n}\nProject.prototype.load = function () {\n    var project = this;\n    var globalProjectSettings = settings.get(\"projects\");\n// console.log(globalProjectSettings)\n    var projectSettings = {};\n    if (globalProjectSettings) {\n        if (globalProjectSettings.projects.hasOwnProperty(this.name)) {\n            projectSettings = globalProjectSettings.projects[this.name] || {};\n        }\n    }\n    this.paths.root = projectSettings.rootPath || \"\";\n    this.credentialSecret = projectSettings.credentialSecret;\n    this.git = projectSettings.git || { user:{} };\n\n    // this.paths.flowFile = fspath.join(this.path,\"flow.json\");\n    // this.paths.credentialsFile = fspath.join(this.path,\"flow_cred.json\");\n\n    var promises = [];\n    return checkProjectFiles(project).then(function(missingFiles) {\n        project.missingFiles = missingFiles;\n        if (missingFiles.indexOf('package.json') === -1) {\n            // We have a package.json in project.path+project.paths.root+\"package.json\"\n            project.paths['package.json'] = fspath.join(project.paths.root,\"package.json\");\n            promises.push(fs.readFile(fspath.join(project.path,project.paths['package.json']),\"utf8\").then(function(content) {\n                try {\n                    project.package = util.parseJSON(content);\n                    if (project.package.hasOwnProperty('node-red')) {\n                        if (project.package['node-red'].hasOwnProperty('settings')) {\n                            project.paths.flowFile = fspath.join(project.paths.root,project.package['node-red'].settings.flowFile);\n                            project.paths.credentialsFile = fspath.join(project.paths.root,project.package['node-red'].settings.credentialsFile);\n                        }\n                    } else {\n                        // TODO: package.json doesn't have a node-red section\n                        //       is that a bad thing?\n                    }\n                } catch(err) {\n                    // package.json isn't valid JSON... is a merge underway?\n                    project.package = {};\n                }\n            }));\n            if (missingFiles.indexOf('README.md') === -1) {\n                project.paths['README.md'] = fspath.join(project.paths.root,\"README.md\");\n                promises.push(fs.readFile(fspath.join(project.path,project.paths['README.md']),\"utf8\").then(function(content) {\n                    project.description = content;\n                }));\n            } else {\n                project.description = \"\";\n            }\n        } else {\n            project.package = {};\n            project.description = \"\";\n        }\n\n        // if (missingFiles.indexOf('flow.json') !== -1) {\n        //     console.log(\"MISSING FLOW FILE\");\n        // } else {\n        //     project.paths.flowFile = fspath.join(project.path,\"flow.json\");\n        // }\n        // if (missingFiles.indexOf('flow_cred.json') !== -1) {\n        //     console.log(\"MISSING CREDS FILE\");\n        // } else {\n        //     project.paths.credentialsFile = fspath.join(project.path,\"flow_cred.json\");\n        // }\n\n        promises.push(project.loadRemotes());\n\n        return when.settle(promises).then(function(results) {\n            return project;\n        })\n    });\n};\n\nProject.prototype.initialise = function(user,data) {\n    var project = this;\n    // if (!this.empty) {\n    //     throw new Error(\"Cannot initialise non-empty project\");\n    // }\n    var files = Object.keys(defaultFileSet);\n    var promises = [];\n\n    if (data.hasOwnProperty('credentialSecret')) {\n        var projects = settings.get('projects');\n        projects.projects[project.name] = projects.projects[project.name] || {};\n        projects.projects[project.name].credentialSecret = data.credentialSecret;\n        promises.push(settings.set('projects',projects));\n    }\n\n    if (data.hasOwnProperty('files')) {\n        if (data.files.hasOwnProperty('flow') && data.files.hasOwnProperty('credentials')) {\n            project.files.flow = data.files.flow;\n            project.files.credentials = data.files.credentials;\n            var flowFilePath = fspath.join(project.path,project.files.flow);\n            var credsFilePath = getCredentialsFilename(flowFilePath);\n            promises.push(util.writeFile(flowFilePath,\"[]\"));\n            promises.push(util.writeFile(credsFilePath,\"{}\"));\n            files.push(project.files.flow);\n            files.push(project.files.credentials);\n        }\n    }\n    for (var file in defaultFileSet) {\n        if (defaultFileSet.hasOwnProperty(file)) {\n            var path = fspath.join(project.path,file);\n            if (!fs.existsSync(path)) {\n                promises.push(util.writeFile(path,defaultFileSet[file](project)));\n            }\n\n        }\n    }\n\n    return Promise.all(promises).then(function() {\n        return gitTools.stageFile(project.path,files);\n    }).then(function() {\n        return gitTools.commit(project.path,\"Create project files\",getGitUser(user));\n    }).then(function() {\n        return project.load()\n    })\n}\n\nProject.prototype.loadRemotes = function() {\n    var project = this;\n    return gitTools.getRemotes(project.path).then(function(remotes) {\n        project.remotes = remotes;\n    }).then(function() {\n        project.branches = {};\n        return project.status();\n    }).then(function() {\n        if (project.remotes) {\n            var allRemotes = Object.keys(project.remotes);\n            var match = \"\";\n            if (project.branches.remote) {\n                allRemotes.forEach(function(remote) {\n                    if (project.branches.remote.indexOf(remote) === 0 && match.length < remote.length) {\n                        match = remote;\n                    }\n                });\n                project.currentRemote = project.parseRemoteBranch(project.branches.remote).remote;\n            }\n        } else {\n            delete project.currentRemote;\n        }\n    });\n}\n\nProject.prototype.parseRemoteBranch = function (remoteBranch) {\n    if (!remoteBranch) {\n        return {}\n    }\n    var project = this;\n    var allRemotes = Object.keys(project.remotes);\n    var match = \"\";\n    allRemotes.forEach(function(remote) {\n        if (remoteBranch.indexOf(remote) === 0 && match.length < remote.length) {\n            match = remote;\n        }\n    });\n    return {\n        remote: match,\n        branch: remoteBranch.substring(match.length+1)\n    }\n\n};\n\nProject.prototype.isEmpty = function () {\n    return this.empty;\n};\n\nProject.prototype.isMerging = function() {\n    return this.merging;\n}\n\nProject.prototype.update = function (user, data) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n\n    var promises = [];\n    var project = this;\n    var saveSettings = false;\n    var saveREADME = false;\n    var savePackage = false;\n    var flowFilesChanged = false;\n    var credentialSecretChanged = false;\n    var reloadProject = false;\n\n    var globalProjectSettings = settings.get(\"projects\");\n    if (!globalProjectSettings.projects.hasOwnProperty(this.name)) {\n        globalProjectSettings.projects[this.name] = {};\n        saveSettings = true;\n    }\n\n    if (data.credentialSecret && data.credentialSecret !== this.credentialSecret) {\n        var existingSecret = data.currentCredentialSecret;\n        var isReset = data.resetCredentialSecret;\n        var secret = data.credentialSecret;\n\n        // console.log(\"updating credentialSecret\");\n        // console.log(\"request:\");\n        // console.log(JSON.stringify(data,\"\",4));\n        // console.log(\" this.credentialSecret\",this.credentialSecret);\n        // console.log(\" this.info\", this.info);\n\n        if (!isReset && // not a reset\n            this.credentialSecret && // key already set\n            !this.credentialSecretInvalid && // key not invalid\n            this.credentialSecret !== existingSecret) { // key doesn't match provided existing key\n                var e = new Error(\"Cannot change credentialSecret without current key\");\n                e.code = \"missing_current_credential_key\";\n                return when.reject(e);\n        }\n        this.credentialSecret = secret;\n\n        globalProjectSettings.projects[this.name].credentialSecret = project.credentialSecret;\n        delete this.credentialSecretInvalid;\n        saveSettings = true;\n        credentialSecretChanged = true;\n    }\n\n    if (this.missingFiles.indexOf('package.json') !== -1) {\n        if (!data.files || !data.files.package) {\n            // Cannot update a project that doesn't have a known package.json\n            return Promise.reject(\"Cannot update project with missing package.json\");\n        }\n    }\n\n    if (data.hasOwnProperty('files')) {\n        this.package['node-red'] = this.package['node-red'] || { settings: {}};\n        if (data.files.hasOwnProperty('package') && (data.files.package !== fspath.join(this.paths.root,\"package.json\") || !this.paths['package.json'])) {\n            // We have a package file. It could be one that doesn't exist yet,\n            // or it does exist and we need to load it.\n            if (!/package\\.json$/.test(data.files.package)) {\n                return Promise.reject(\"Invalid package file: \"+data.files.package)\n            }\n            var root = data.files.package.substring(0,data.files.package.length-12);\n            if (/^\\.\\./.test(fspath.relative(this.path,fspath.join(this.path,data.files.package)))) {\n                return Promise.reject(\"Invalid package file: \"+data.files.package)\n            }\n            this.paths.root = root;\n            this.paths['package.json'] = data.files.package;\n            globalProjectSettings.projects[this.name].rootPath = root;\n            saveSettings = true;\n            // 1. check if it exists\n            if (fs.existsSync(fspath.join(this.path,this.paths['package.json']))) {\n                // Load the existing one....\n            } else {\n                var newPackage = defaultFileSet[\"package.json\"](this);\n                fs.writeFileSync(fspath.join(this.path,this.paths['package.json']),newPackage);\n                this.package = JSON.parse(newPackage);\n            }\n            reloadProject = true;\n            flowFilesChanged = true;\n        }\n\n        if (data.files.hasOwnProperty('flow') && this.package['node-red'].settings.flowFile !== data.files.flow.substring(this.paths.root.length)) {\n            if (/^\\.\\./.test(fspath.relative(this.path,fspath.join(this.path,data.files.flow)))) {\n                return Promise.reject(\"Invalid flow file: \"+data.files.flow)\n            }\n            this.paths.flowFile = data.files.flow;\n            this.package['node-red'].settings.flowFile = data.files.flow.substring(this.paths.root.length);\n            savePackage = true;\n            flowFilesChanged = true;\n        }\n        if (data.files.hasOwnProperty('credentials') && this.package['node-red'].settings.credentialsFile !== data.files.credentials.substring(this.paths.root.length)) {\n            if (/^\\.\\./.test(fspath.relative(this.path,fspath.join(this.path,data.files.credentials)))) {\n                return Promise.reject(\"Invalid credentials file: \"+data.files.credentials)\n            }\n            this.paths.credentialsFile = data.files.credentials;\n            this.package['node-red'].settings.credentialsFile = data.files.credentials.substring(this.paths.root.length);\n            // Don't know if the credSecret is invalid or not so clear the flag\n            delete this.credentialSecretInvalid;\n            savePackage = true;\n            flowFilesChanged = true;\n        }\n    }\n\n    if (data.hasOwnProperty('description')) {\n        saveREADME = true;\n        this.description = data.description;\n    }\n    if (data.hasOwnProperty('dependencies')) {\n        savePackage = true;\n        this.package.dependencies = data.dependencies;\n    }\n    if (data.hasOwnProperty('summary')) {\n        savePackage = true;\n        this.package.description = data.summary;\n    }\n    if (data.hasOwnProperty('version')) {\n        savePackage = true;\n        this.package.version = data.version;\n    }\n\n    if (data.hasOwnProperty('git')) {\n        if (data.git.hasOwnProperty('user')) {\n            globalProjectSettings.projects[this.name].git = globalProjectSettings.projects[this.name].git || {};\n            globalProjectSettings.projects[this.name].git.user = globalProjectSettings.projects[this.name].git.user || {};\n            globalProjectSettings.projects[this.name].git.user[username] = {\n                name: data.git.user.name,\n                email: data.git.user.email\n            }\n            this.git.user[username] = {\n                name: data.git.user.name,\n                email: data.git.user.email\n            }\n            saveSettings = true;\n        }\n        if (data.git.hasOwnProperty('remotes')) {\n            var remoteNames = Object.keys(data.git.remotes);\n            var remotesChanged = false;\n            var modifyRemotesPromise = Promise.resolve();\n            remoteNames.forEach(function(name) {\n                if (data.git.remotes[name].removed) {\n                    remotesChanged = true;\n                    modifyRemotesPromise = modifyRemotesPromise.then(function() { gitTools.removeRemote(project.path,name) });\n                } else {\n                    if (data.git.remotes[name].url) {\n                        remotesChanged = true;\n                        modifyRemotesPromise = modifyRemotesPromise.then(function() { gitTools.addRemote(project.path,name,data.git.remotes[name])});\n                    }\n                    if (data.git.remotes[name].username && data.git.remotes[name].password) {\n                        var url = data.git.remotes[name].url || project.remotes[name].fetch;\n                        authCache.set(project.name,url,username,data.git.remotes[name]);\n                    }\n                }\n            })\n            if (remotesChanged) {\n                modifyRemotesPromise = modifyRemotesPromise.then(function() {\n                    return project.loadRemotes();\n                });\n                promises.push(modifyRemotesPromise);\n            }\n        }\n    }\n\n\n    if (saveSettings) {\n        promises.push(settings.set(\"projects\",globalProjectSettings));\n    }\n\n    var modifiedFiles = [];\n\n    if (saveREADME) {\n        promises.push(util.writeFile(fspath.join(this.path,this.paths['README.md']), this.description));\n        modifiedFiles.push('README.md');\n    }\n    if (savePackage) {\n        promises.push(fs.readFile(fspath.join(this.path,this.paths['package.json']),\"utf8\").then(content => {\n            var currentPackage = {};\n            try {\n                currentPackage = util.parseJSON(content);\n            } catch(err) {\n            }\n            this.package = Object.assign(currentPackage,this.package);\n            return util.writeFile(fspath.join(project.path,this.paths['package.json']), JSON.stringify(this.package,\"\",4));\n        }));\n        modifiedFiles.push('package.json');\n    }\n    return when.settle(promises).then(function(res) {\n        var gitSettings = getUserGitSettings(user) || {};\n        var workflowMode = (gitSettings.workflow||{}).mode || \"manual\";\n        if (workflowMode === 'auto') {\n            return project.stageFile(modifiedFiles.map(f => project.paths[f])).then(() => {\n                return project.commit(user,{message:\"Update \"+modifiedFiles.join(\", \")})\n            })\n        }\n    }).then(res => {\n        if (reloadProject) {\n            return this.load()\n        }\n    }).then(function() {\n        return {\n            flowFilesChanged: flowFilesChanged,\n            credentialSecretChanged: credentialSecretChanged\n        }})\n};\n\nProject.prototype.getFiles = function () {\n    return gitTools.getFiles(this.path).catch(function(err) {\n        if (/ambiguous argument/.test(err.message)) {\n            return {};\n        }\n        throw err;\n    });\n};\n\nProject.prototype.stageFile = function(file) {\n    return gitTools.stageFile(this.path,file);\n};\n\nProject.prototype.unstageFile = function(file) {\n    return gitTools.unstageFile(this.path,file);\n}\n\nProject.prototype.commit = function(user, options) {\n    var self = this;\n    return gitTools.commit(this.path,options.message,getGitUser(user)).then(function() {\n        if (self.merging) {\n            self.merging = false;\n            return\n        }\n    });\n}\n\nProject.prototype.getFileDiff = function(file,type) {\n    return gitTools.getFileDiff(this.path,file,type);\n}\n\nProject.prototype.getCommits = function(options) {\n    return gitTools.getCommits(this.path,options).catch(function(err) {\n        if (/bad default revision/i.test(err.message) || /ambiguous argument/i.test(err.message) || /does not have any commits yet/i.test(err.message)) {\n            return {\n                count:0,\n                commits:[],\n                total: 0\n            }\n        }\n        throw err;\n    })\n}\n\nProject.prototype.getCommit = function(sha) {\n    return gitTools.getCommit(this.path,sha);\n}\n\nProject.prototype.getFile = function (filePath,treeish) {\n    if (treeish !== \"_\") {\n        return gitTools.getFile(this.path, filePath, treeish);\n    } else {\n        let fullPath = fspath.join(this.path,filePath);\n        if (/^\\.\\./.test(fspath.relative(this.path,fullPath))) {\n            throw new Error(\"Invalid file name\")\n        }\n        return fs.readFile(fspath.join(this.path,filePath),\"utf8\");\n    }\n};\n\nProject.prototype.revertFile = function (filePath) {\n    var self = this;\n    return gitTools.revertFile(this.path, filePath).then(function() {\n        return self.load();\n    });\n};\n\nProject.prototype.status = function(user, includeRemote) {\n    var self = this;\n\n    var fetchPromise;\n    if (this.remotes && includeRemote) {\n        fetchPromise = gitTools.getRemoteBranch(self.path).then(function(remoteBranch) {\n            if (remoteBranch) {\n                var allRemotes = Object.keys(self.remotes);\n                var match = \"\";\n                allRemotes.forEach(function(remote) {\n                    if (remoteBranch.indexOf(remote) === 0 && match.length < remote.length) {\n                        match = remote;\n                    }\n                })\n                return self.fetch(user, match);\n            }\n        });\n    } else {\n        fetchPromise = Promise.resolve();\n    }\n\n    var completeStatus = function(fetchError) {\n        var promises = [\n            gitTools.getStatus(self.path),\n            fs.exists(fspath.join(self.path,\".git\",\"MERGE_HEAD\"))\n        ];\n        return Promise.all(promises).then(function(results) {\n            var result = results[0];\n            if (results[1]) {\n                result.merging = true;\n                if (!self.merging) {\n                    self.merging = true;\n                    runtime.events.emit(\"runtime-event\",{\n                        id:\"runtime-state\",\n                        payload:{\n                            type:\"warning\",\n                            error:\"git_merge_conflict\",\n                            project:self.name,\n                            text:\"notification.warnings.git_merge_conflict\"\n                        },\n                        retain:true}\n                    );\n                }\n            } else {\n                self.merging = false;\n            }\n            self.branches.local = result.branches.local;\n            self.branches.remote = result.branches.remote;\n            if (fetchError && !/ambiguous argument/.test(fetchError.message)) {\n                result.branches.remoteError = {\n                    remote: fetchError.remote,\n                    code: fetchError.code\n                }\n            }\n            if (result.commits.total === 0 && Object.keys(result.files).length === 0) {\n                if (!self.empty) {\n                    runtime.events.emit(\"runtime-event\",{\n                        id:\"runtime-state\",\n                        payload:{\n                            type:\"warning\",\n                            error:\"project_empty\",\n                            text:\"notification.warnings.project_empty\"},\n                            retain:true\n                        }\n                    );\n                }\n                self.empty = true;\n            } else {\n                if (self.empty) {\n                    if (self.paths.flowFile) {\n                        runtime.events.emit(\"runtime-event\",{id:\"runtime-state\",retain:true});\n                    } else {\n                        runtime.events.emit(\"runtime-event\",{\n                            id:\"runtime-state\",\n                            payload:{\n                                type:\"warning\",\n                                error:\"missing_flow_file\",\n                                text:\"notification.warnings.missing_flow_file\"},\n                                retain:true\n                            }\n                        );\n                    }\n                }\n                delete self.empty;\n            }\n            return result;\n        }).catch(function(err) {\n            if (/ambiguous argument/.test(err.message)) {\n                return {\n                    files:{},\n                    commits:{total:0},\n                    branches:{}\n                };\n            }\n            throw err;\n        });\n    }\n    return fetchPromise.then(completeStatus).catch(function(e) {\n        // if (e.code !== 'git_auth_failed') {\n        //     console.log(\"Fetch failed\");\n        //     console.log(e);\n        // }\n        return completeStatus(e);\n    })\n};\n\nProject.prototype.push = function (user,remoteBranchName,setRemote) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var remote = this.parseRemoteBranch(remoteBranchName||this.branches.remote);\n    return gitTools.push(this.path, remote.remote || this.currentRemote,remote.branch, setRemote, authCache.get(this.name,this.remotes[remote.remote || this.currentRemote].fetch,username));\n};\n\nProject.prototype.pull = function (user,remoteBranchName,setRemote,allowUnrelatedHistories) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var self = this;\n    if (setRemote) {\n        return gitTools.setUpstream(this.path, remoteBranchName).then(function() {\n            self.currentRemote = self.parseRemoteBranch(remoteBranchName).remote;\n            return gitTools.pull(self.path, null, null, allowUnrelatedHistories, authCache.get(self.name,self.remotes[self.currentRemote].fetch,username),getGitUser(user));\n        })\n    } else {\n        var remote = this.parseRemoteBranch(remoteBranchName);\n        return gitTools.pull(this.path, remote.remote, remote.branch, allowUnrelatedHistories, authCache.get(this.name,this.remotes[remote.remote||self.currentRemote].fetch,username),getGitUser(user));\n    }\n};\n\nProject.prototype.resolveMerge = function (file,resolutions) {\n    var filePath = fspath.join(this.path,file);\n\n    if (/^\\.\\./.test(fspath.relative(this.path,filePath))) {\n        throw new Error(\"Invalid file name\")\n    }\n\n    var self = this;\n    if (typeof resolutions === 'string') {\n        return util.writeFile(filePath, resolutions).then(function() {\n            return self.stageFile(file);\n        })\n    }\n    return fs.readFile(filePath,\"utf8\").then(function(content) {\n        var lines = content.split(\"\\n\");\n        var result = [];\n        var ignoreBlock = false;\n        var currentBlock;\n        for (var i=1;i<=lines.length;i++) {\n            if (resolutions.hasOwnProperty(i)) {\n                currentBlock = resolutions[i];\n                if (currentBlock.selection === \"A\") {\n                    ignoreBlock = false;\n                } else {\n                    ignoreBlock = true;\n                }\n                continue;\n            }\n            if (currentBlock) {\n                if (currentBlock.separator === i) {\n                    if (currentBlock.selection === \"A\") {\n                        ignoreBlock = true;\n                    } else {\n                        ignoreBlock = false;\n                    }\n                    continue;\n                } else if (currentBlock.changeEnd === i) {\n                    currentBlock = null;\n                    continue;\n                } else if (ignoreBlock) {\n                    continue;\n                }\n            }\n            result.push(lines[i-1]);\n        }\n        var finalResult = result.join(\"\\n\");\n        return util.writeFile(filePath,finalResult).then(function() {\n            return self.stageFile(file);\n        })\n    });\n};\n\nProject.prototype.abortMerge = function () {\n    var self = this;\n    return gitTools.abortMerge(this.path).then(function() {\n        self.merging = false;\n    })\n};\n\nProject.prototype.getBranches = function (user, isRemote) {\n    var self = this;\n    var fetchPromise;\n    if (isRemote) {\n        fetchPromise = self.fetch(user);\n    } else {\n        fetchPromise = Promise.resolve();\n    }\n    return fetchPromise.then(function() {\n        return gitTools.getBranches(self.path,isRemote);\n    });\n};\n\nProject.prototype.deleteBranch = function (user, branch, isRemote, force) {\n    // TODO: isRemote==true support\n    // TODO: make sure we don't try to delete active branch\n    return gitTools.deleteBranch(this.path,branch,isRemote, force);\n};\n\nProject.prototype.fetch = function(user,remoteName) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var project = this;\n    if (remoteName) {\n        return gitTools.fetch(project.path,remoteName,authCache.get(project.name,project.remotes[remoteName].fetch,username)).catch(function(err) {\n            err.remote = remoteName;\n            throw err;\n        })\n    } else {\n        var remotes = Object.keys(this.remotes);\n        var promise = Promise.resolve();\n        remotes.forEach(function(remote) {\n            promise = promise.then(function() {\n                return gitTools.fetch(project.path,remote,authCache.get(project.name,project.remotes[remote].fetch,username))\n            }).catch(function(err) {\n                if (!err.remote) {\n                    err.remote = remote;\n                }\n                throw err;\n            })\n        });\n        return promise;\n    }\n}\n\nProject.prototype.setBranch = function (branchName, isCreate) {\n    var self = this;\n    return gitTools.checkoutBranch(this.path, branchName, isCreate).then(function() {\n        return self.load();\n    })\n};\n\nProject.prototype.getBranchStatus = function (branchName) {\n    return gitTools.getBranchStatus(this.path,branchName);\n};\n\nProject.prototype.getRemotes = function (user) {\n    return gitTools.getRemotes(this.path).then(function(remotes) {\n        var result = [];\n        for (var name in remotes) {\n            if (remotes.hasOwnProperty(name)) {\n                remotes[name].name = name;\n                result.push(remotes[name]);\n            }\n        }\n        return {remotes:result};\n    })\n};\n\nProject.prototype.addRemote = function(user,remote,options) {\n    var project = this;\n    return gitTools.addRemote(this.path,remote,options).then(function() {\n        return project.loadRemotes()\n    });\n}\n\nProject.prototype.updateRemote = function(user,remote,options) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n\n    if (options.auth) {\n        var url = this.remotes[remote].fetch;\n        if (options.auth.keyFile) {\n            options.auth.key_path = sshKeys.getPrivateKeyPath(getSSHKeyUsername(user), options.auth.keyFile);\n        }\n        authCache.set(this.name,url,username,options.auth);\n    }\n    return Promise.resolve();\n}\n\nProject.prototype.removeRemote = function(user, remote) {\n    // TODO: if this was the last remote using this url, then remove the authCache\n    // details.\n    var project = this;\n    return gitTools.removeRemote(this.path,remote).then(function() {\n        return project.loadRemotes()\n    });\n}\n\nProject.prototype.getFlowFile = function() {\n    // console.log(\"Project.getFlowFile = \",this.paths.flowFile);\n    if (this.paths.flowFile) {\n        return fspath.join(this.path,this.paths.flowFile);\n    } else {\n        return null;\n    }\n}\n\nProject.prototype.getFlowFileBackup = function() {\n    var flowFile = this.getFlowFile();\n    if (flowFile) {\n        return getBackupFilename(flowFile);\n    }\n    return null;\n}\n\nProject.prototype.getCredentialsFile = function() {\n    // console.log(\"Project.getCredentialsFile = \",this.paths.credentialsFile);\n    if (this.paths.credentialsFile) {\n        return fspath.join(this.path,this.paths.credentialsFile);\n    } else {\n        return this.paths.credentialsFile;\n    }\n}\n\nProject.prototype.getCredentialsFileBackup = function() {\n    return getBackupFilename(this.getCredentialsFile());\n}\n\nProject.prototype.export = function () {\n\n    return {\n        name: this.name,\n        summary: this.package.description,\n        version: this.package.version,\n        description: this.description,\n        dependencies: this.package.dependencies||{},\n        empty: this.empty,\n        settings: {\n            credentialsEncrypted: (typeof this.credentialSecret === \"string\") && this.credentialSecret.length > 0,\n            credentialSecretInvalid: this.credentialSecretInvalid\n        },\n        files: {\n            package: this.paths['package.json'],\n            flow: this.paths.flowFile,\n            credentials: this.paths.credentialsFile\n        },\n        git: {\n            remotes: this.remotes,\n            branches: this.branches\n        }\n    }\n};\n\nfunction getCredentialsFilename(filename) {\n    filename = filename || \"undefined\";\n    // TODO: DRY - ./index.js\n    var ffDir = fspath.dirname(filename);\n    var ffExt = fspath.extname(filename);\n    var ffBase = fspath.basename(filename,ffExt);\n    return fspath.join(ffDir,ffBase+\"_cred\"+ffExt);\n}\nfunction getBackupFilename(filename) {\n    // TODO: DRY - ./index.js\n    filename = filename || \"undefined\";\n    var ffName = fspath.basename(filename);\n    var ffDir = fspath.dirname(filename);\n    return fspath.join(ffDir,\".\"+ffName+\".backup\");\n}\nfunction checkProjectExists(projectPath) {\n    return fs.pathExists(projectPath).then(function(exists) {\n        if (!exists) {\n            var e = new Error(\"Project not found\");\n            e.code = \"project_not_found\";\n            var name = fspath.basename(projectPath);\n            e.project = name;\n            throw e;\n        }\n    });\n}\nfunction createDefaultProject(user, project) {\n    var projectPath = fspath.join(projectsDir,project.name);\n    // Create a basic skeleton of a project\n    return gitTools.initRepo(projectPath).then(function() {\n        var promises = [];\n        var files = Object.keys(defaultFileSet);\n        if (project.files) {\n            if (project.files.flow && !/\\.\\./.test(project.files.flow)) {\n                var flowFilePath;\n                var credsFilePath;\n\n                if (project.migrateFiles) {\n                    var baseFlowFileName = project.files.flow || fspath.basename(project.files.oldFlow);\n                    var baseCredentialFileName = project.files.credentials || fspath.basename(project.files.oldCredentials);\n                    files.push(baseFlowFileName);\n                    files.push(baseCredentialFileName);\n                    flowFilePath = fspath.join(projectPath,baseFlowFileName);\n                    credsFilePath = fspath.join(projectPath,baseCredentialFileName);\n                    if (fs.existsSync(project.files.oldFlow)) {\n                        log.trace(\"Migrating \"+project.files.oldFlow+\" to \"+flowFilePath);\n                        promises.push(fs.copy(project.files.oldFlow,flowFilePath));\n                    } else {\n                        log.trace(project.files.oldFlow+\" does not exist - creating blank file\");\n                        promises.push(util.writeFile(flowFilePath,\"[]\"));\n                    }\n                    log.trace(\"Migrating \"+project.files.oldCredentials+\" to \"+credsFilePath);\n                    runtime.nodes.setCredentialSecret(project.credentialSecret);\n                    promises.push(runtime.nodes.exportCredentials().then(function(creds) {\n                        var credentialData;\n                        if (settings.flowFilePretty) {\n                            credentialData = JSON.stringify(creds,null,4);\n                        } else {\n                            credentialData = JSON.stringify(creds);\n                        }\n                        return util.writeFile(credsFilePath,credentialData);\n                    }));\n                    delete project.migrateFiles;\n                    project.files.flow = baseFlowFileName;\n                    project.files.credentials = baseCredentialFileName;\n                } else {\n                    project.files.credentials = project.files.credentials || getCredentialsFilename(project.files.flow);\n                    files.push(project.files.flow);\n                    files.push(project.files.credentials);\n                    flowFilePath = fspath.join(projectPath,project.files.flow);\n                    credsFilePath = getCredentialsFilename(flowFilePath);\n                    promises.push(util.writeFile(flowFilePath,\"[]\"));\n                    promises.push(util.writeFile(credsFilePath,\"{}\"));\n                }\n            }\n        }\n        for (var file in defaultFileSet) {\n            if (defaultFileSet.hasOwnProperty(file)) {\n                promises.push(util.writeFile(fspath.join(projectPath,file),defaultFileSet[file](project)));\n            }\n        }\n\n        return Promise.all(promises).then(function() {\n            return gitTools.stageFile(projectPath,files);\n        }).then(function() {\n            return gitTools.commit(projectPath,\"Create project\",getGitUser(user));\n        })\n    });\n}\nfunction checkProjectFiles(project) {\n    var promises = [];\n    var paths = [];\n    for (var file in defaultFileSet) {\n        if (defaultFileSet.hasOwnProperty(file)) {\n            paths.push(file);\n            promises.push(fs.stat(fspath.join(project.path,project.paths.root,file)));\n        }\n    }\n    return when.settle(promises).then(function(results) {\n        var missing = [];\n        results.forEach(function(result,i) {\n            if (result.state === 'rejected') {\n                missing.push(paths[i]);\n            }\n        });\n        return missing;\n    }).then(function(missing) {\n        // if (createMissing) {\n        //     var promises = [];\n        //     missing.forEach(function(file) {\n        //         promises.push(util.writeFile(fspath.join(projectPath,file),defaultFileSet[file](project)));\n        //     });\n        //     return promises;\n        // } else {\n        return missing;\n        // }\n    });\n}\nfunction createProject(user, metadata) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    if (!metadata.path) {\n        throw new Error(\"Project missing path property\");\n    }\n    if (!metadata.name) {\n        throw new Error(\"Project missing name property\");\n    }\n\n    var project = metadata.name;\n    var projectPath = metadata.path;\n    return new Promise(function(resolve,reject) {\n        fs.stat(projectPath, function(err,stat) {\n            if (!err) {\n                var e = new Error(\"NLS: Project already exists\");\n                e.code = \"project_exists\";\n                return reject(e);\n            }\n            fs.ensureDir(projectPath).then(function() {\n                var projects = settings.get('projects');\n                if (!projects) {\n                    projects = {\n                        projects:{}\n                    }\n                }\n                projects.projects[project] = {};\n                if (metadata.hasOwnProperty('credentialSecret')) {\n                    if (metadata.credentialSecret === \"\") {\n                        metadata.credentialSecret = false;\n                    }\n                    projects.projects[project].credentialSecret = metadata.credentialSecret;\n                }\n                return settings.set('projects',projects);\n            }).then(function() {\n                if (metadata.git && metadata.git.remotes && metadata.git.remotes.origin) {\n                    var originRemote = metadata.git.remotes.origin;\n                    var auth;\n                    if (originRemote.hasOwnProperty(\"username\") && originRemote.hasOwnProperty(\"password\")) {\n                        authCache.set(project,originRemote.url,username,{ // TODO: hardcoded remote name\n                                username: originRemote.username,\n                                password: originRemote.password\n                            }\n                        );\n                        auth = authCache.get(project,originRemote.url,username);\n                    }\n                    else if (originRemote.hasOwnProperty(\"keyFile\") && originRemote.hasOwnProperty(\"passphrase\")) {\n                        authCache.set(project,originRemote.url,username,{ // TODO: hardcoded remote name\n                                key_path: sshKeys.getPrivateKeyPath(getSSHKeyUsername(user), originRemote.keyFile),\n                                passphrase: originRemote.passphrase\n                            }\n                        );\n                        auth = authCache.get(project,originRemote.url,username);\n                    }\n                    return gitTools.clone(originRemote,auth,projectPath);\n                } else {\n                    return createDefaultProject(user, metadata);\n                }\n            }).then(function() {\n                resolve(loadProject(projectPath))\n            }).catch(function(err) {\n                fs.remove(projectPath,function() {\n                    reject(err);\n                });\n            });\n        })\n    })\n}\nfunction deleteProject(user, projectPath) {\n    return checkProjectExists(projectPath).then(function() {\n        return fs.remove(projectPath).then(function() {\n            var name = fspath.basename(projectPath);\n            var projects = settings.get('projects');\n            delete projects.projects[name];\n            return settings.set('projects', projects);\n        });\n    });\n}\nfunction loadProject(projectPath) {\n    return checkProjectExists(projectPath).then(function() {\n        var project = new Project(projectPath);\n        return project.load();\n    });\n}\nfunction init(_settings, _runtime) {\n    settings = _settings;\n    runtime = _runtime;\n    projectsDir = fspath.resolve(fspath.join(settings.userDir,\"projects\"));\n    authCache.init();\n}\n\nmodule.exports = {\n    init: init,\n    load: loadProject,\n    create: createProject,\n    delete: deleteProject\n}\n", "/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar fs = require('fs-extra');\nvar when = require('when');\nvar fspath = require(\"path\");\nvar nodeFn = require('when/node/function');\nvar crypto = require('crypto');\n\nvar storageSettings = require(\"../settings\");\nvar util = require(\"../util\");\nvar gitTools = require(\"./git\");\nvar sshTools = require(\"./ssh\");\n\nvar Projects = require(\"./Project\");\n\nvar settings;\nvar runtime;\nvar log = require(\"@node-red/util\").log;\n\nvar projectsEnabled = false;\nvar projectLogMessages = [];\n\nvar projectsDir;\nvar activeProject\n\nvar globalGitUser = false;\n\nfunction init(_settings, _runtime) {\n    settings = _settings;\n    runtime = _runtime;\n\n    try {\n        if (settings.editorTheme.projects.enabled === true) {\n            projectsEnabled = true;\n        } else if (settings.editorTheme.projects.enabled === false) {\n            projectLogMessages.push(log._(\"storage.localfilesystem.projects.disabled\"))\n        }\n    } catch(err) {\n        projectLogMessages.push(log._(\"storage.localfilesystem.projects.disabledNoFlag\"))\n        projectsEnabled = false;\n    }\n\n    if (settings.flowFile) {\n        flowsFile = settings.flowFile;\n        // handle Unix and Windows \"C:\\\" and Windows \"\\\\\" for UNC.\n        if (fspath.isAbsolute(flowsFile)) {\n        //if (((flowsFile[0] == \"\\\\\") && (flowsFile[1] == \"\\\\\")) || (flowsFile[0] == \"/\") || (flowsFile[1] == \":\")) {\n            // Absolute path\n            flowsFullPath = flowsFile;\n        } else if (flowsFile.substring(0,2) === \"./\") {\n            // Relative to cwd\n            flowsFullPath = fspath.join(process.cwd(),flowsFile);\n        } else {\n            try {\n                fs.statSync(fspath.join(process.cwd(),flowsFile));\n                // Found in cwd\n                flowsFullPath = fspath.join(process.cwd(),flowsFile);\n            } catch(err) {\n                // Use userDir\n                flowsFullPath = fspath.join(settings.userDir,flowsFile);\n            }\n        }\n\n    } else {\n        flowsFile = 'flows_'+require('os').hostname()+'.json';\n        flowsFullPath = fspath.join(settings.userDir,flowsFile);\n    }\n    var ffExt = fspath.extname(flowsFullPath);\n    var ffBase = fspath.basename(flowsFullPath,ffExt);\n\n    flowsFileBackup = getBackupFilename(flowsFullPath);\n    credentialsFile = fspath.join(settings.userDir,ffBase+\"_cred\"+ffExt);\n    credentialsFileBackup = getBackupFilename(credentialsFile)\n\n    var setupProjectsPromise;\n\n    if (projectsEnabled) {\n        return sshTools.init(settings,runtime).then(function() {\n            gitTools.init(_settings).then(function(gitConfig) {\n                if (!gitConfig || /^1\\./.test(gitConfig.version)) {\n                    if (!gitConfig) {\n                        projectLogMessages.push(log._(\"storage.localfilesystem.projects.git-not-found\"))\n                    } else {\n                        projectLogMessages.push(log._(\"storage.localfilesystem.projects.git-version-old\",{version:gitConfig.version}))\n                    }\n                    projectsEnabled = false;\n                    try {\n                        // As projects have to be turned on, we know this property\n                        // must exist at this point, so turn it off.\n                        // TODO: when on-by-default, this will need to do more\n                        // work to disable.\n                        settings.editorTheme.projects.enabled = false;\n                    } catch(err) {\n                    }\n                } else {\n                    globalGitUser = gitConfig.user;\n                    Projects.init(settings,runtime);\n                    sshTools.init(settings);\n                    projectsDir = fspath.resolve(fspath.join(settings.userDir,\"projects\"));\n                    if (!settings.readOnly) {\n                        return fs.ensureDir(projectsDir)\n                        //TODO: this is accessing settings from storage directly as settings\n                        //      has not yet been initialised. That isn't ideal - can this be deferred?\n                        .then(storageSettings.getSettings)\n                        .then(function(globalSettings) {\n                            var saveSettings = false;\n                            if (!globalSettings.projects) {\n                                globalSettings.projects = {\n                                    projects: {}\n                                }\n                                saveSettings = true;\n                            } else {\n                                activeProject = globalSettings.projects.activeProject;\n                            }\n                            if (!globalSettings.projects.projects) {\n                                globalSettings.projects.projects = {};\n                                saveSettings = true;\n                            }\n                            if (settings.flowFile) {\n                                // if flowFile is a known project name - use it\n                                if (globalSettings.projects.projects.hasOwnProperty(settings.flowFile)) {\n                                    activeProject = settings.flowFile;\n                                    globalSettings.projects.activeProject = settings.flowFile;\n                                    saveSettings = true;\n                                } else {\n                                    // if it resolves to a dir - use it\n                                    try {\n                                        var stat = fs.statSync(fspath.join(projectsDir,settings.flowFile));\n                                        if (stat && stat.isDirectory()) {\n                                            activeProject = settings.flowFile;\n                                            globalSettings.projects.activeProject = activeProject;\n                                            // Now check for a credentialSecret\n                                            if (settings.credentialSecret !== undefined) {\n                                                globalSettings.projects.projects[settings.flowFile] = {\n                                                    credentialSecret: settings.credentialSecret\n                                                }\n                                                saveSettings = true;\n                                            }\n                                        }\n                                    } catch(err) {\n                                        // Doesn't exist, handle as a flow file to be created\n                                    }\n                                }\n                            }\n                            if (!activeProject) {\n                                projectLogMessages.push(log._(\"storage.localfilesystem.no-active-project\"))\n                            }\n                            if (saveSettings) {\n                                return storageSettings.saveSettings(globalSettings);\n                            }\n                        });\n                    }\n                }\n            });\n        });\n    }\n    return Promise.resolve();\n}\n\nfunction listProjects() {\n    return fs.readdir(projectsDir).then(function(fns) {\n        var dirs = [];\n        fns.sort(function(A,B) {\n            return A.toLowerCase().localeCompare(B.toLowerCase());\n        }).filter(function(fn) {\n            var fullPath = fspath.join(projectsDir,fn);\n            if (fn[0] != \".\") {\n                var stats = fs.lstatSync(fullPath);\n                if (stats.isDirectory()) {\n                    dirs.push(fn);\n                }\n            }\n        });\n        return dirs;\n    });\n}\n\nfunction getUserGitSettings(user) {\n    var username;\n    if (!user) {\n        username = \"_\";\n    } else {\n        username = user.username;\n    }\n    var userSettings = settings.getUserSettings(username)||{};\n    return userSettings.git;\n}\n\nfunction getBackupFilename(filename) {\n    var ffName = fspath.basename(filename);\n    var ffDir = fspath.dirname(filename);\n    return fspath.join(ffDir,\".\"+ffName+\".backup\");\n}\n\nfunction loadProject(name) {\n    let fullPath = fspath.resolve(fspath.join(projectsDir,name));\n    var projectPath = name;\n    if (projectPath.indexOf(fspath.sep) === -1) {\n        projectPath = fullPath;\n    } else {\n        // Ensure this project dir is under projectsDir;\n        let relativePath = fspath.relative(projectsDir,fullPath);\n        if (/^\\.\\./.test(relativePath)) {\n            throw new Error(\"Invalid project name\")\n        }\n    }\n    return Projects.load(projectPath).then(function(project) {\n        activeProject = project;\n        flowsFullPath = project.getFlowFile();\n        flowsFileBackup = project.getFlowFileBackup();\n        credentialsFile = project.getCredentialsFile();\n        credentialsFileBackup = project.getCredentialsFileBackup();\n        return project;\n    })\n}\n\nfunction getProject(user, name) {\n    checkActiveProject(name);\n    //return when.resolve(activeProject.info);\n    return Promise.resolve(activeProject.export());\n}\n\nfunction deleteProject(user, name) {\n    if (activeProject && activeProject.name === name) {\n        var e = new Error(\"NLS: Can't delete the active project\");\n        e.code = \"cannot_delete_active_project\";\n        throw e;\n    }\n    var projectPath = fspath.join(projectsDir,name);\n    let relativePath = fspath.relative(projectsDir,projectPath);\n    if (/^\\.\\./.test(relativePath)) {\n        throw new Error(\"Invalid project name\")\n    }\n    return Projects.delete(user, projectPath);\n}\n\nfunction checkActiveProject(project) {\n    if (!activeProject || activeProject.name !== project) {\n        //TODO: throw better err\n        throw new Error(\"Cannot operate on inactive project wanted:\"+project+\" current:\"+(activeProject&&activeProject.name));\n    }\n}\nfunction getFiles(user, project) {\n    checkActiveProject(project);\n    return activeProject.getFiles();\n}\nfunction stageFile(user, project,file) {\n    checkActiveProject(project);\n    return activeProject.stageFile(file);\n}\nfunction unstageFile(user, project,file) {\n    checkActiveProject(project);\n    return activeProject.unstageFile(file);\n}\nfunction commit(user, project,options) {\n    checkActiveProject(project);\n    var isMerging = activeProject.isMerging();\n    return activeProject.commit(user, options).then(function() {\n        // The project was merging, now it isn't. Lets reload.\n        if (isMerging && !activeProject.isMerging()) {\n            return reloadActiveProject(\"merge-complete\");\n        }\n    })\n}\nfunction getFileDiff(user, project,file,type) {\n    checkActiveProject(project);\n    return activeProject.getFileDiff(file,type);\n}\nfunction getCommits(user, project,options) {\n    checkActiveProject(project);\n    return activeProject.getCommits(options);\n}\nfunction getCommit(user, project,sha) {\n    checkActiveProject(project);\n    return activeProject.getCommit(sha);\n}\n\nfunction getFile(user, project,filePath,sha) {\n    checkActiveProject(project);\n    return activeProject.getFile(filePath,sha);\n}\nfunction revertFile(user, project,filePath) {\n    checkActiveProject(project);\n    return activeProject.revertFile(filePath).then(function() {\n        return reloadActiveProject(\"revert\");\n    })\n}\nfunction push(user, project,remoteBranchName,setRemote) {\n    checkActiveProject(project);\n    return activeProject.push(user,remoteBranchName,setRemote);\n}\nfunction pull(user, project,remoteBranchName,setRemote,allowUnrelatedHistories) {\n    checkActiveProject(project);\n    return activeProject.pull(user,remoteBranchName,setRemote,allowUnrelatedHistories).then(function() {\n        return reloadActiveProject(\"pull\");\n    });\n}\nfunction getStatus(user, project, includeRemote) {\n    checkActiveProject(project);\n    return activeProject.status(user, includeRemote);\n}\nfunction resolveMerge(user, project,file,resolution) {\n    checkActiveProject(project);\n    return activeProject.resolveMerge(file,resolution);\n}\nfunction abortMerge(user, project) {\n    checkActiveProject(project);\n    return activeProject.abortMerge().then(function() {\n        return reloadActiveProject(\"merge-abort\")\n    });\n}\nfunction getBranches(user, project,isRemote) {\n    checkActiveProject(project);\n    return activeProject.getBranches(user, isRemote);\n}\n\nfunction deleteBranch(user, project, branch, isRemote, force) {\n    checkActiveProject(project);\n    return activeProject.deleteBranch(user, branch, isRemote, force);\n}\n\nfunction setBranch(user, project,branchName,isCreate) {\n    checkActiveProject(project);\n    return activeProject.setBranch(branchName,isCreate).then(function() {\n        return reloadActiveProject(\"change-branch\");\n    });\n}\nfunction getBranchStatus(user, project,branchName) {\n    checkActiveProject(project);\n    return activeProject.getBranchStatus(branchName);\n}\n\n\nfunction getRemotes(user, project) {\n    checkActiveProject(project);\n    return activeProject.getRemotes(user);\n}\nfunction addRemote(user, project, options) {\n    checkActiveProject(project);\n    return activeProject.addRemote(user, options.name, options);\n}\nfunction removeRemote(user, project, remote) {\n    checkActiveProject(project);\n    return activeProject.removeRemote(user, remote);\n}\nfunction updateRemote(user, project, remote, body) {\n    checkActiveProject(project);\n    return activeProject.updateRemote(user, remote, body);\n}\n\nfunction getActiveProject(user) {\n    return activeProject;\n}\n\nfunction reloadActiveProject(action) {\n    return runtime.nodes.stopFlows().then(function() {\n        return runtime.nodes.loadFlows(true).then(function() {\n            runtime.events.emit(\"runtime-event\",{id:\"project-update\", payload:{ project: activeProject.name, action:action}});\n        }).catch(function(err) {\n            // We're committed to the project change now, so notify editors\n            // that it has changed.\n            runtime.events.emit(\"runtime-event\",{id:\"project-update\", payload:{ project: activeProject.name, action:action}});\n            throw err;\n        });\n    });\n}\nfunction createProject(user, metadata) {\n    if (metadata.files && metadata.migrateFiles) {\n        // We expect there to be no active project in this scenario\n        if (activeProject) {\n            throw new Error(\"Cannot migrate as there is an active project\");\n        }\n        var currentEncryptionKey = settings.get('credentialSecret');\n        if (currentEncryptionKey === undefined) {\n            currentEncryptionKey = settings.get('_credentialSecret');\n        }\n        if (!metadata.hasOwnProperty('credentialSecret')) {\n            metadata.credentialSecret = currentEncryptionKey;\n        }\n        if (!metadata.files.flow) {\n            metadata.files.flow = fspath.basename(flowsFullPath);\n        }\n        if (!metadata.files.credentials) {\n            metadata.files.credentials = fspath.basename(credentialsFile);\n        }\n\n        metadata.files.oldFlow = flowsFullPath;\n        metadata.files.oldCredentials = credentialsFile;\n        metadata.files.credentialSecret = currentEncryptionKey;\n    }\n    metadata.path = fspath.join(projectsDir,metadata.name);\n    if (/^\\.\\./.test(fspath.relative(projectsDir,metadata.path))) {\n        throw new Error(\"Invalid project name\")\n    }\n\n    return Projects.create(user, metadata).then(function(p) {\n        return setActiveProject(user, p.name);\n    }).then(function() {\n        return getProject(user, metadata.name);\n    })\n}\nfunction setActiveProject(user, projectName) {\n    return loadProject(projectName).then(function(project) {\n        var globalProjectSettings = settings.get(\"projects\")||{};\n        globalProjectSettings.activeProject = project.name;\n        return settings.set(\"projects\",globalProjectSettings).then(function() {\n            log.info(log._(\"storage.localfilesystem.projects.changing-project\",{project:(activeProject&&activeProject.name)||\"none\"}));\n            log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n            // console.log(\"Updated file targets to\");\n            // console.log(flowsFullPath)\n            // console.log(credentialsFile)\n            return reloadActiveProject(\"loaded\");\n        })\n    });\n}\n\nfunction initialiseProject(user, project, data) {\n    if (!activeProject || activeProject.name !== project) {\n        // TODO standardise\n        throw new Error(\"Cannot initialise inactive project\");\n    }\n    return activeProject.initialise(user,data).then(function(result) {\n        flowsFullPath = activeProject.getFlowFile();\n        flowsFileBackup = activeProject.getFlowFileBackup();\n        credentialsFile = activeProject.getCredentialsFile();\n        credentialsFileBackup = activeProject.getCredentialsFileBackup();\n        runtime.nodes.setCredentialSecret(activeProject.credentialSecret);\n        return reloadActiveProject(\"updated\");\n    });\n}\nfunction updateProject(user, project, data) {\n    if (!activeProject || activeProject.name !== project) {\n        // TODO standardise\n        throw new Error(\"Cannot update inactive project\");\n    }\n    // In case this triggers a credential secret change\n    var isReset = data.resetCredentialSecret;\n    var wasInvalid = activeProject.credentialSecretInvalid;\n\n    return activeProject.update(user,data).then(function(result) {\n\n        if (result.flowFilesChanged) {\n            flowsFullPath = activeProject.getFlowFile();\n            flowsFileBackup = activeProject.getFlowFileBackup();\n            credentialsFile = activeProject.getCredentialsFile();\n            credentialsFileBackup = activeProject.getCredentialsFileBackup();\n            return reloadActiveProject(\"updated\");\n        } else if (result.credentialSecretChanged) {\n            if (isReset || !wasInvalid) {\n                if (isReset) {\n                    runtime.nodes.clearCredentials();\n                }\n                runtime.nodes.setCredentialSecret(activeProject.credentialSecret);\n                return runtime.nodes.exportCredentials()\n                    .then(runtime.storage.saveCredentials)\n                    .then(function() {\n                        if (wasInvalid) {\n                            return reloadActiveProject(\"updated\");\n                        }\n                    });\n            } else if (wasInvalid) {\n                return reloadActiveProject(\"updated\");\n            }\n        }\n    });\n}\nfunction setCredentialSecret(data) { //existingSecret,secret) {\n    var isReset = data.resetCredentialSecret;\n    var wasInvalid = activeProject.credentialSecretInvalid;\n    return activeProject.update(data).then(function() {\n        if (isReset || !wasInvalid) {\n            if (isReset) {\n                runtime.nodes.clearCredentials();\n            }\n            runtime.nodes.setCredentialSecret(activeProject.credentialSecret);\n            return runtime.nodes.exportCredentials()\n                .then(runtime.storage.saveCredentials)\n                .then(function() {\n                    if (wasInvalid) {\n                        return reloadActiveProject(\"updated\");\n                    }\n                });\n        } else if (wasInvalid) {\n            return reloadActiveProject(\"updated\");\n        }\n    })\n}\n\n\nvar initialFlowLoadComplete = false;\n\nvar flowsFile;\nvar flowsFullPath;\nvar flowsFileExists = false;\nvar flowsFileBackup;\nvar credentialsFile;\nvar credentialsFileBackup;\n\nfunction getFlows() {\n    if (!initialFlowLoadComplete) {\n        initialFlowLoadComplete = true;\n        log.info(log._(\"storage.localfilesystem.user-dir\",{path:settings.userDir}));\n        if (activeProject) {\n            // At this point activeProject will be a string, so go load it and\n            // swap in an instance of Project\n            return loadProject(activeProject).then(function() {\n                log.info(log._(\"storage.localfilesystem.projects.active-project\",{project:activeProject.name||\"none\"}));\n                log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n                return getFlows();\n            });\n        } else {\n            if (projectsEnabled) {\n                log.warn(log._(\"storage.localfilesystem.projects.no-active-project\"))\n            } else {\n                projectLogMessages.forEach(log.warn);\n            }\n            log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n        }\n    }\n    if (activeProject) {\n        var error;\n        if (activeProject.isEmpty()) {\n            log.warn(\"Project repository is empty\");\n            error = new Error(\"Project repository is empty\");\n            error.code = \"project_empty\";\n            return when.reject(error);\n        }\n        if (activeProject.missingFiles && activeProject.missingFiles.indexOf('package.json') !== -1) {\n            log.warn(\"Project missing package.json\");\n            error = new Error(\"Project missing package.json\");\n            error.code = \"missing_package_file\";\n            return when.reject(error);\n        }\n        if (!activeProject.getFlowFile()) {\n            log.warn(\"Project has no flow file\");\n            error = new Error(\"Project has no flow file\");\n            error.code = \"missing_flow_file\";\n            return when.reject(error);\n        }\n        if (activeProject.isMerging()) {\n            log.warn(\"Project has unmerged changes\");\n            error = new Error(\"Project has unmerged changes. Cannot load flows\");\n            error.code = \"git_merge_conflict\";\n            return when.reject(error);\n        }\n\n    }\n    return util.readFile(flowsFullPath,flowsFileBackup,null,'flow').then(function(result) {\n        if (result === null) {\n            flowsFileExists = false;\n            return [];\n        }\n        flowsFileExists = true;\n        return result;\n    });\n}\n\nfunction saveFlows(flows, user) {\n    if (settings.readOnly) {\n        return when.resolve();\n    }\n    if (activeProject && activeProject.isMerging()) {\n        var error = new Error(\"Project has unmerged changes. Cannot deploy new flows\");\n        error.code = \"git_merge_conflict\";\n        return when.reject(error);\n    }\n\n    flowsFileExists = true;\n\n    var flowData;\n\n    if (settings.flowFilePretty || (activeProject && settings.flowFilePretty !== false) ) {\n        // Pretty format if option enabled, or using Projects and not explicitly disabled\n        flowData = JSON.stringify(flows,null,4);\n    } else {\n        flowData = JSON.stringify(flows);\n    }\n    return util.writeFile(flowsFullPath, flowData, flowsFileBackup).then(() => {\n        var gitSettings = getUserGitSettings(user) || {};\n        var workflowMode = (gitSettings.workflow||{}).mode || \"manual\";\n        if (activeProject && workflowMode === 'auto') {\n            return activeProject.stageFile([flowsFullPath, credentialsFile]).then(() => {\n                return activeProject.commit(user,{message:\"Update flow files\"})\n            })\n        }\n    });\n}\n\nfunction getCredentials() {\n    return util.readFile(credentialsFile,credentialsFileBackup,{},'credentials');\n}\n\nfunction saveCredentials(credentials) {\n    if (settings.readOnly) {\n        return when.resolve();\n    }\n\n    var credentialData;\n    if (settings.flowFilePretty || (activeProject && settings.flowFilePretty !== false) ) {\n        // Pretty format if option enabled, or using Projects and not explicitly disabled\n        credentialData = JSON.stringify(credentials,null,4);\n    } else {\n        credentialData = JSON.stringify(credentials);\n    }\n    return util.writeFile(credentialsFile, credentialData, credentialsFileBackup);\n}\n\nfunction getFlowFilename() {\n    if (flowsFullPath) {\n        return fspath.basename(flowsFullPath);\n    }\n}\nfunction getCredentialsFilename() {\n    if (flowsFullPath) {\n        return fspath.basename(credentialsFile);\n    }\n}\n\nmodule.exports = {\n    init: init,\n    listProjects: listProjects,\n    getActiveProject: getActiveProject,\n    setActiveProject: setActiveProject,\n    getProject: getProject,\n    deleteProject: deleteProject,\n    createProject: createProject,\n    initialiseProject: initialiseProject,\n    updateProject: updateProject,\n    getFiles: getFiles,\n    getFile: getFile,\n    revertFile: revertFile,\n    stageFile: stageFile,\n    unstageFile: unstageFile,\n    commit: commit,\n    getFileDiff: getFileDiff,\n    getCommits: getCommits,\n    getCommit: getCommit,\n    push: push,\n    pull: pull,\n    getStatus:getStatus,\n    resolveMerge: resolveMerge,\n    abortMerge: abortMerge,\n    getBranches: getBranches,\n    deleteBranch: deleteBranch,\n    setBranch: setBranch,\n    getBranchStatus:getBranchStatus,\n    getRemotes: getRemotes,\n    addRemote: addRemote,\n    removeRemote: removeRemote,\n    updateRemote: updateRemote,\n    getFlowFilename: getFlowFilename,\n    flowFileExists: function() { return flowsFileExists },\n    getCredentialsFilename: getCredentialsFilename,\n    getGlobalGitUser: function() { return globalGitUser },\n    getFlows: getFlows,\n    saveFlows: saveFlows,\n    getCredentials: getCredentials,\n    saveCredentials: saveCredentials,\n\n    ssh: sshTools\n\n};\n"], "filenames": ["packages/node_modules/@node-red/runtime/lib/storage/localfilesystem/projects/Project.js", "packages/node_modules/@node-red/runtime/lib/storage/localfilesystem/projects/index.js"], "buggy_code_start_loc": [307, 113], "buggy_code_end_loc": [1066, 394], "fixing_code_start_loc": [308, 113], "fixing_code_end_loc": [1084, 410], "type": "CWE-22", "message": "Node-Red is a low-code programming for event-driven applications built using nodejs. Node-RED 1.2.7 and earlier has a vulnerability which allows arbitrary path traversal via the Projects API. If the Projects feature is enabled, a user with `projects.read` permission is able to access any file via the Projects API. The issue has been patched in Node-RED 1.2.8. The vulnerability applies only to the Projects feature which is not enabled by default in Node-RED. The primary workaround is not give untrusted users read access to the Node-RED editor.", "other": {"cve": {"id": "CVE-2021-21298", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-26T17:15:12.337", "lastModified": "2021-03-10T13:32:52.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Node-Red is a low-code programming for event-driven applications built using nodejs. Node-RED 1.2.7 and earlier has a vulnerability which allows arbitrary path traversal via the Projects API. If the Projects feature is enabled, a user with `projects.read` permission is able to access any file via the Projects API. The issue has been patched in Node-RED 1.2.8. The vulnerability applies only to the Projects feature which is not enabled by default in Node-RED. The primary workaround is not give untrusted users read access to the Node-RED editor."}, {"lang": "es", "value": "Node-Red es una programaci\u00f3n de low-code para aplicaciones basadas en eventos dise\u00f1adas usando nodejs.&#xa0;Node-RED versiones 1.2.7 y anteriores, presentan una vulnerabilidad que permite un salto de ruta arbitrario por medio de la API Projects.&#xa0;Si la funcionalidad Proyects est\u00e1 habilitada, un usuario con el permiso \"projects.read\" puede acceder a cualquier archivo por medio de la API Proyects.&#xa0;El problema ha sido parcheado en Node-RED versi\u00f3n 1.2.8.&#xa0;La vulnerabilidad se aplica solo a la funcionalidad Proyects que no est\u00e1 habilitada por defecto en Node-RED.&#xa0;La soluci\u00f3n alternativa principal es no dar acceso de lectura al editor de Node-RED para usuarios que no son confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodered:node-red:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.2.8", "matchCriteriaId": "FD380E45-4954-4427-90D5-66896B983B30"}]}]}], "references": [{"url": "https://github.com/node-red/node-red/commit/74db3e17d075f23d9c95d7871586cf461524c456", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/node-red/node-red/releases/tag/1.2.8", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/node-red/node-red/security/advisories/GHSA-m33v-338h-4v9f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/@node-red/runtime", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/node-red/node-red/commit/74db3e17d075f23d9c95d7871586cf461524c456"}}