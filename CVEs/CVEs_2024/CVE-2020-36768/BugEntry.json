{"buggy_code": ["import os\nimport json\nimport pandas as pd\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import scoped_session, sessionmaker\nimport geoalchemy2\nfrom sqlalchemy import Table, MetaData\nfrom sqlalchemy.ext.declarative import declarative_base\nimport random\n\ndef get_env_variable(name):\n    try:\n        return os.environ[name]\n    except KeyError:\n        message = \"Expected environment variable '{}' not set.\".format(name)\n        raise Exception(message)\n\n\nPOSTGRES_URL = get_env_variable(\"POSTGRES_URL\")\nPOSTGRES_USER = get_env_variable(\"POSTGRES_USER\")\nPOSTGRES_PW = get_env_variable(\"POSTGRES_PW\")\nPOSTGRES_DB = get_env_variable(\"POSTGRES_DB\")\n\n\nDB_URL = 'postgresql+psycopg2://{user}:{pw}@{url}/{db}'.format(\n    user=POSTGRES_USER,\n    pw=POSTGRES_PW,\n    url=POSTGRES_URL,\n    db=POSTGRES_DB\n)\n\nengine = create_engine(DB_URL)\ndb_session = scoped_session(sessionmaker(autocommit=False,\n                                         autoflush=False,\n                                         bind=engine))\n\nBase = declarative_base(metadata=MetaData(schema='se4all', bind=engine))\n\n\nclass BoundaryAdmin(Base):\n    __table__ = Table('boundary_adm1', Base.metadata, autoload=True, autoload_with=engine)\n\n\nclass AdmStatus(Base):\n    __table__ = Table('boundary_adm1_status', Base.metadata, autoload=True, autoload_with=engine)\n\n\ndef query_available_og_clusters():\n    \"\"\"Look for state which have true set for both clusters and og_clusters\"\"\"\n    res = db_session.query(\n        AdmStatus.adm1_pcode\n    ).filter(AdmStatus.cluster_all & AdmStatus.cluster_offgrid).all()\n    return [r.adm1_pcode for r in res]\n\ndef get_state_codes():\n    res = db_session.query(\n        BoundaryAdmin.adm1_pcode.label(\"code\"),\n        BoundaryAdmin.adm1_en.label(\"name\")\n    )\n    return {r.name:r.code for r in res}\n\nOG_CLUSTERS_COLUMNS = ('adm1_pcode', 'cluster_offgrid_id', 'area_km2',\n    'building_count', 'percentage_building_area', 'grid_dist_km', 'geom')\n\n\ndef filter_materialized_view(\n        engine,\n        view_name,\n        schema=\"web\",\n        state_code=None,\n        area=None,\n        distance_grid=None,\n        building=None,\n        buildingfp=None,\n        limit=None,\n        keys=None,\n):\n    if schema is not None:\n        view_name = \"{}.{}\".format(schema, view_name)\n    if limit is None:\n        limit = \"\"\n    else:\n        limit = \" LIMIT {}\".format(limit)\n\n    filter_cond = \"\"\n\n    if state_code is not None:\n        key = \"adm1_pcode\"\n        filter_cond = f\" WHERE {view_name}.{key}='{state_code}'\"\n\n    if area is not None:\n        key = \"area_km2\"\n        if \"WHERE\" in filter_cond:\n            filter_cond = filter_cond + f\" AND {view_name}.{key} >= {area[0]} AND\" \\\n                                        f\" {view_name}.{key} <= {area[1]}\"\n        else:\n            filter_cond = f\" WHERE {view_name}.{key} >= {area[0]} AND {view_name}.{key} <= {area[1]}\"\n\n    if distance_grid is not None:\n        key = \"grid_dist_km\"\n        if \"WHERE\" in filter_cond:\n            filter_cond = filter_cond + f\" AND {view_name}.{key} >= {distance_grid[0]} AND\" \\\n                                        f\" {view_name}.{key} <= {distance_grid[1]}\"\n        else:\n            filter_cond = f\" WHERE {view_name}.{key} >= {distance_grid[0]} AND\" \\\n                          f\" {view_name}.{key} <= {distance_grid[1]}\"\n\n    if building is not None:\n        key = \"building_count\"\n        if \"WHERE\" in filter_cond:\n            filter_cond = filter_cond + f\" AND {view_name}.{key} >= {building[0]} AND\" \\\n                                        f\" {view_name}.{key} <= {building[1]}\"\n        else:\n            filter_cond = f\" WHERE {view_name}.{key} >= {building[0]} AND\" \\\n                          f\" {view_name}.{key} <= {building[1]}\"\n\n    if buildingfp is not None:\n        key = \"percentage_building_area\"\n        if \"WHERE\" in filter_cond:\n            filter_cond = filter_cond + f\" AND {view_name}.{key} >= {buildingfp[0]} AND\" \\\n                                        f\" {view_name}.{key} <= {buildingfp[1]}\"\n        else:\n            filter_cond = f\" WHERE {view_name}.{key} >= {buildingfp[0]} AND\" \\\n                          f\" {view_name}.{key} <= {buildingfp[1]}\"\n\n    if keys is None:\n        columns = \"*\"\n    else:\n        if not isinstance(keys, str):\n            columns = \", \".join(keys)\n        else:\n            columns = \"COUNT({})\".format(keys)\n    with engine.connect() as con:\n        query = 'SELECT {} FROM {}{}{};'.format(columns, view_name, filter_cond, limit)\n        rs = con.execute(query)\n        data = rs.fetchall()\n    return data\n\n\ndef convert_web_mat_view_to_light_json(records, cols):\n    \"\"\"\n\n    :param records:\n    :param cols:\n    :return:\n    \"\"\"\n    df = pd.DataFrame()\n\n    for l in records:\n        l = dict(l)\n        geom = json.loads(l.pop(\"geom\"))\n        lnglat = json.loads(l.pop(\"lnglat\"))\n\n        l.update({\n            'lat': lnglat[\"coordinates\"][1],\n            'lng': lnglat[\"coordinates\"][0],\n            'bNorth': geom[\"coordinates\"][0][2][1],\n            'bSouth': geom[\"coordinates\"][0][0][1],\n            'bEast': geom[\"coordinates\"][0][2][0],\n            'bWest': geom[\"coordinates\"][0][0][0]\n        })\n        df = df.append(l, ignore_index=True)\n\n    value_list = []\n    for c in cols:\n        value_list = value_list + df[c].to_list()\n\n    return {'adm1_pcode': df['adm1_pcode'].unique()[0], \"length\": len(df.index), \"columns\": cols,\n            \"values\": value_list}\n\n\ndef query_filtered_clusters(\n        state_name,\n        state_codes_dict,\n        area=None,\n        distance_grid=None,\n        limit=None,\n        keys=None\n):\n    \"\"\"\n\n    :param state_name:\n    :param state_codes_dict:\n    :param area:\n    :param distance_grid:\n    :param limit:\n    :param keys:\n    :return:\n    \"\"\"\n\n    if state_name in state_codes_dict:\n        view_name = \"cluster_all_mv\"\n        answer = filter_materialized_view(\n            engine,\n            view_name,\n            schema=\"web\",\n            state_code=state_codes_dict[state_name],\n            area=area,\n            distance_grid=distance_grid,\n            limit=limit,\n            keys=keys\n        )\n    else:\n        print(\"Non existent state name: {}\".format(state_name))\n        answer = []\n    return answer\n\n\ndef query_filtered_og_clusters(\n        state_name,\n        state_codes_dict,\n        area=None,\n        distance_grid=None,\n        building=None,\n        buildingfp=None,\n        limit=None,\n        keys=None\n):\n    \"\"\"\n\n    :param state_name:\n    :param state_codes_dict:\n    :param area:\n    :param distance_grid:\n    :param building:\n    :param buildingfp:\n    :param limit:\n    :param keys:\n    :return:\n    \"\"\"\n\n    if state_name in state_codes_dict:\n        view_name = \"cluster_offgrid_mv\"\n        answer = filter_materialized_view(\n            engine,\n            view_name,\n            schema=\"web\",\n            state_code=state_codes_dict[state_name],\n            area=area,\n            distance_grid=distance_grid,\n            building=building,\n            buildingfp=buildingfp,\n            limit=limit,\n            keys=keys\n        )\n    else:\n        print(\"Non existent state name: {}\".format(state_name))\n        answer = []\n    return answer\n\n\ndef get_number_of_entries(engine, view_code, schema=\"web\", table_name=\"cluster_offgrid\"):\n    \"\"\"\n\n    :param engine:\n    :param view_code:\n    :param schema:\n    :return:\n    \"\"\"\n\n    if schema is not None:\n        view_name = \"{}.{}_{}_mv\".format(schema, table_name, view_code)\n    with engine.connect() as con:\n        rs = con.execute('SELECT count(*) as n FROM {};'.format(view_name))\n        data = rs.fetchall()\n    return data[0].n\n\n\ndef query_row_count_cluster(state_code):\n    return get_number_of_entries(engine, state_code, schema=\"web\", table_name=\"cluster_all\")\n\n\ndef query_row_count_ogcluster(state_code):\n    return get_number_of_entries(engine, state_code, schema=\"web\", table_name=\"cluster_offgrid\")\n\n\ndef get_random_og_cluster(engine, view_code, schema=\"web\", limit=5):\n    \"\"\"Select a random cluster from a given view\n\n    :param engine: database engine\n    :param view_name: the state code of the view formatted as \"ngXYZ\"\n    :param schema: the name of the database schema\n    :param limit: the number of villages to choose from\n    :return: the information of one cluster : 'adm1_pcode', 'cluster_offgrid_id', 'area_km2',\n    'building_count', 'percentage_building_area', 'grid_dist_km', 'geom'\n    \"\"\"\n\n    if schema is not None:\n        view_name = \"{}.cluster_offgrid_mv\".format(schema, view_code)\n    cols = \", \".join(OG_CLUSTERS_COLUMNS[:-1])\n    cols = cols + \", ST_AsGeoJSON(bounding_box) as geom, ST_AsGeoJSON(centroid) as lnglat\"\n    with engine.connect() as con:\n        rs = con.execute(\"SELECT {} FROM {} WHERE adm1_pcode='{}' ORDER BY area_km2 DESC LIMIT {};\".format(\n                cols,\n                view_name,\n                view_code,\n                limit\n            )\n        )\n        data = rs.fetchall()\n    single_cluster = data[random.randint(0, min([int(limit), len(data)])-1)]\n    return {key: str(single_cluster[key]) for key in OG_CLUSTERS_COLUMNS + (\"geom\", \"lnglat\")}\n\n\ndef query_random_og_cluster(state_name, state_codes_dict):\n    return get_random_og_cluster(engine=engine, view_code=state_codes_dict[state_name])\n"], "fixing_code": ["import os\nimport json\nimport pandas as pd\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import scoped_session, sessionmaker\nfrom sqlalchemy.sql import text\nfrom sqlalchemy import Table, MetaData\nfrom sqlalchemy.ext.declarative import declarative_base\nimport random\n\ndef get_env_variable(name):\n    try:\n        return os.environ[name]\n    except KeyError:\n        message = \"Expected environment variable '{}' not set.\".format(name)\n        raise Exception(message)\n\n\nPOSTGRES_URL = get_env_variable(\"POSTGRES_URL\")\nPOSTGRES_USER = get_env_variable(\"POSTGRES_USER\")\nPOSTGRES_PW = get_env_variable(\"POSTGRES_PW\")\nPOSTGRES_DB = get_env_variable(\"POSTGRES_DB\")\n\n\nDB_URL = 'postgresql+psycopg2://{user}:{pw}@{url}/{db}'.format(\n    user=POSTGRES_USER,\n    pw=POSTGRES_PW,\n    url=POSTGRES_URL,\n    db=POSTGRES_DB\n)\n\nengine = create_engine(DB_URL)\ndb_session = scoped_session(sessionmaker(autocommit=False,\n                                         autoflush=False,\n                                         bind=engine))\n\nBase = declarative_base(metadata=MetaData(schema='se4all', bind=engine))\n\n\nclass BoundaryAdmin(Base):\n    __table__ = Table('boundary_adm1', Base.metadata, autoload=True, autoload_with=engine)\n\n\nclass AdmStatus(Base):\n    __table__ = Table('boundary_adm1_status', Base.metadata, autoload=True, autoload_with=engine)\n\n\ndef query_available_og_clusters():\n    \"\"\"Look for state which have true set for both clusters and og_clusters\"\"\"\n    res = db_session.query(\n        AdmStatus.adm1_pcode\n    ).filter(AdmStatus.cluster_all & AdmStatus.cluster_offgrid).all()\n    return [r.adm1_pcode for r in res]\n\ndef get_state_codes():\n    res = db_session.query(\n        BoundaryAdmin.adm1_pcode.label(\"code\"),\n        BoundaryAdmin.adm1_en.label(\"name\")\n    )\n    return {r.name:r.code for r in res}\n\nOG_CLUSTERS_COLUMNS = ('adm1_pcode', 'cluster_offgrid_id', 'area_km2',\n    'building_count', 'percentage_building_area', 'grid_dist_km', 'geom')\n\n\ndef filter_materialized_view(\n        engine,\n        view_name,\n        schema=\"web\",\n        state_code=None,\n        area=None,\n        distance_grid=None,\n        building=None,\n        buildingfp=None,\n        limit=None,\n        keys=None,\n):\n    \"\"\"\n\n    :param engine:\n    :param view_name: name of the view in the database (NOT A USER INPUT)\n    :param schema: name of the schema in the database (NOT A USER INPUT)\n    :param state_code: admin code of nigerian state (PROOFED USER INPUT)\n    :param area: boundaries for settlement's area filter (USER INPUT)\n    :param distance_grid: boundaries for settlement's distance to grid filter (USER INPUT)\n    :param building: boundaries for settlement's building count filter (USER INPUT)\n    :param buildingfp: boundaries for settlement's building percentage of area filter (USER INPUT)\n    :param limit: boundaries for settlement area filter (NOT A USER INPUT)\n    :param keys: list of columns to query values from (NOT A USER INPUT)\n    :return: returned data from the query\n    \"\"\"\n\n    # to hold query parameters\n    values = {}\n\n    if schema is not None:\n        view_name = \"{}.{}\".format(schema, view_name)\n\n    if limit is None:\n        limit = \"\"\n    else:\n        values[\"limit\"] = int(limit)\n        limit = \" LIMIT :limit\"\n\n    filter_cond = []\n\n    if state_code is not None:\n        key = \"adm1_pcode\"\n        filter_cond += [f\"{view_name}.{key} = :{key}\"]\n        values[key] = state_code\n\n    if area is not None:\n        key = \"area_km2\"\n        val1 = key + \"_1\"\n        val2 = key + \"_2\"\n        filter_cond += [f\"{view_name}.{key} >= :{val1}\", f\"{view_name}.{key} <= :{val2}\"]\n        values[val1] = float(area[0])\n        values[val2] = float(area[1])\n\n    if distance_grid is not None:\n        key = \"grid_dist_km\"\n        val1 = key + \"_1\"\n        val2 = key + \"_2\"\n        filter_cond += [f\"{view_name}.{key} >= :{val1}\", f\"{view_name}.{key} <= :{val2}\"]\n        values[val1] = float(distance_grid[0])\n        values[val2] = float(distance_grid[1])\n\n    if building is not None:\n        key = \"building_count\"\n        val1 = key + \"_1\"\n        val2 = key + \"_2\"\n        filter_cond += [f\"{view_name}.{key}>=:{val1}\", f\"{view_name}.{key}<=:{val2}\"]\n        values[val1] = int(building[0])\n        values[val2] = int(building[1])\n\n    if buildingfp is not None:\n        key = \"percentage_building_area\"\n        val1 = key + \"_1\"\n        val2 = key + \"_2\"\n        filter_cond += [f\"{view_name}.{key}>=:{val1}\", f\"{view_name}.{key}<=:{val2}\"]\n        values[val1] = float(buildingfp[0])\n        values[val2] = float(buildingfp[1])\n\n    if keys is None:\n        columns = \"*\"\n    else:\n        if not isinstance(keys, str):\n            columns = \", \".join(keys)\n        else:\n            columns = \"COUNT({})\".format(keys)\n\n    if len(filter_cond) > 0:\n        filter_cond_str = \" WHERE \" + \" AND \".join(filter_cond)\n    else:\n        filter_cond_str = \"\"\n\n    with engine.connect() as con:\n        query = 'SELECT {} FROM {}{}{};'.format(columns, view_name, filter_cond_str, limit)\n        rs = con.execute(text(query), **values)\n        data = rs.fetchall()\n    return data\n\n\ndef convert_web_mat_view_to_light_json(records, cols):\n    \"\"\"\n\n    :param records:\n    :param cols:\n    :return:\n    \"\"\"\n    df = pd.DataFrame()\n\n    for l in records:\n        l = dict(l)\n        geom = json.loads(l.pop(\"geom\"))\n        lnglat = json.loads(l.pop(\"lnglat\"))\n\n        l.update({\n            'lat': lnglat[\"coordinates\"][1],\n            'lng': lnglat[\"coordinates\"][0],\n            'bNorth': geom[\"coordinates\"][0][2][1],\n            'bSouth': geom[\"coordinates\"][0][0][1],\n            'bEast': geom[\"coordinates\"][0][2][0],\n            'bWest': geom[\"coordinates\"][0][0][0]\n        })\n        df = df.append(l, ignore_index=True)\n\n    value_list = []\n    for c in cols:\n        value_list = value_list + df[c].to_list()\n\n    return {'adm1_pcode': df['adm1_pcode'].unique()[0], \"length\": len(df.index), \"columns\": cols,\n            \"values\": value_list}\n\n\ndef query_filtered_clusters(\n        state_name,\n        state_codes_dict,\n        area=None,\n        distance_grid=None,\n        limit=None,\n        keys=None\n):\n    \"\"\"\n\n    :param state_name:\n    :param state_codes_dict:\n    :param area:\n    :param distance_grid:\n    :param limit:\n    :param keys:\n    :return:\n    \"\"\"\n\n    if state_name in state_codes_dict:\n        view_name = \"cluster_all_mv\"\n        answer = filter_materialized_view(\n            engine,\n            view_name,\n            schema=\"web\",\n            state_code=state_codes_dict[state_name],\n            area=area,\n            distance_grid=distance_grid,\n            limit=limit,\n            keys=keys\n        )\n    else:\n        print(\"Non existent state name: {}\".format(state_name))\n        answer = []\n    return answer\n\n\ndef query_filtered_og_clusters(\n        state_name,\n        state_codes_dict,\n        area=None,\n        distance_grid=None,\n        building=None,\n        buildingfp=None,\n        limit=None,\n        keys=None\n):\n    \"\"\"\n\n    :param state_name:\n    :param state_codes_dict:\n    :param area:\n    :param distance_grid:\n    :param building:\n    :param buildingfp:\n    :param limit:\n    :param keys:\n    :return:\n    \"\"\"\n\n    if state_name in state_codes_dict:\n        view_name = \"cluster_offgrid_mv\"\n        answer = filter_materialized_view(\n            engine,\n            view_name,\n            schema=\"web\",\n            state_code=state_codes_dict[state_name],\n            area=area,\n            distance_grid=distance_grid,\n            building=building,\n            buildingfp=buildingfp,\n            limit=limit,\n            keys=keys\n        )\n    else:\n        print(\"Non existent state name: {}\".format(state_name))\n        answer = []\n    return answer\n\n\ndef get_number_of_entries(engine, view_code, schema=\"web\", table_name=\"cluster_offgrid\"):\n    \"\"\"\n\n    :param engine:\n    :param view_code:\n    :param schema:\n    :return:\n    \"\"\"\n\n    if schema is not None:\n        view_name = \"{}.{}_{}_mv\".format(schema, table_name, view_code)\n    with engine.connect() as con:\n        rs = con.execute('SELECT count(*) as n FROM {};'.format(view_name))\n        data = rs.fetchall()\n    return data[0].n\n\n\ndef query_row_count_cluster(state_code):\n    return get_number_of_entries(engine, state_code, schema=\"web\", table_name=\"cluster_all\")\n\n\ndef query_row_count_ogcluster(state_code):\n    return get_number_of_entries(engine, state_code, schema=\"web\", table_name=\"cluster_offgrid\")\n\n\ndef get_random_og_cluster(engine, view_code, schema=\"web\", limit=5):\n    \"\"\"Select a random cluster from a given view\n\n    :param engine: database engine\n    :param view_name: the state code of the view formatted as \"ngXYZ\"\n    :param schema: the name of the database schema\n    :param limit: the number of villages to choose from\n    :return: the information of one cluster : 'adm1_pcode', 'cluster_offgrid_id', 'area_km2',\n    'building_count', 'percentage_building_area', 'grid_dist_km', 'geom'\n    \"\"\"\n\n    if schema is not None:\n        view_name = \"{}.cluster_offgrid_mv\".format(schema, view_code)\n    cols = \", \".join(OG_CLUSTERS_COLUMNS[:-1])\n    cols = cols + \", ST_AsGeoJSON(bounding_box) as geom, ST_AsGeoJSON(centroid) as lnglat\"\n    with engine.connect() as con:\n        rs = con.execute(\"SELECT {} FROM {} WHERE adm1_pcode='{}' ORDER BY area_km2 DESC LIMIT {};\".format(\n                cols,\n                view_name,\n                view_code,\n                limit\n            )\n        )\n        data = rs.fetchall()\n    single_cluster = data[random.randint(0, min([int(limit), len(data)])-1)]\n    return {key: str(single_cluster[key]) for key in OG_CLUSTERS_COLUMNS + (\"geom\", \"lnglat\")}\n\n\ndef query_random_og_cluster(state_name, state_codes_dict):\n    return get_random_og_cluster(engine=engine, view_code=state_codes_dict[state_name])\n"], "filenames": ["app/database.py"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [136], "fixing_code_start_loc": [6], "fixing_code_end_loc": [160], "type": "CWE-89", "message": "A vulnerability was found in rl-institut NESP2 Initial Release/1.0. It has been classified as critical. Affected is an unknown function of the file app/database.py. The manipulation leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The patch is identified as 07c0cdf36cf6a4345086d07b54423723a496af5e. It is recommended to apply a patch to fix this issue. VDB-246642 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2020-36768", "sourceIdentifier": "cna@vuldb.com", "published": "2023-12-03T11:15:08.443", "lastModified": "2024-02-29T01:28:46.253", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in rl-institut NESP2 Initial Release/1.0. It has been classified as critical. Affected is an unknown function of the file app/database.py. The manipulation leads to sql injection. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The patch is identified as 07c0cdf36cf6a4345086d07b54423723a496af5e. It is recommended to apply a patch to fix this issue. VDB-246642 is the identifier assigned to this vulnerability."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad en rl-institut NESP2 Initial Release/1.0. Ha sido clasificada como cr\u00edtica. Una funci\u00f3n desconocida del archivo app/database.py es afectada por esta vulnerabilidad. La manipulaci\u00f3n conduce a la inyecci\u00f3n de SQL. Es posible lanzar el ataque de forma remota. El exploit ha sido divulgado al p\u00fablico y puede utilizarse. El parche se identifica como 07c0cdf36cf6a4345086d07b54423723a496af5e. Se recomienda aplicar un parche para solucionar este problema. VDB-246642 es el identificador asignado a esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:reiner-lemoine-institut:nesp2:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "FCEB5AF1-39EE-4BAE-9D86-794A3A76FFD9"}]}]}], "references": [{"url": "https://github.com/rl-institut/NESP2/commit/07c0cdf36cf6a4345086d07b54423723a496af5e", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/rl-institut/NESP2/issues/334", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/rl-institut/NESP2/pull/333", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://vuldb.com/?ctiid.246642", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.246642", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rl-institut/NESP2/commit/07c0cdf36cf6a4345086d07b54423723a496af5e"}}