{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Licensing\n *\n * Copyright 2011-2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 Norbert Federa <norbert.federa@thincast.com>\n * Copyright 2018 David Fort <contact@hardening-consulting.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/crypto.h>\n#include <winpr/shell.h>\n#include <winpr/path.h>\n\n#include <freerdp/log.h>\n\n#include \"redirection.h\"\n#include \"certificate.h\"\n\n#include \"license.h\"\n\n#define TAG FREERDP_TAG(\"core.license\")\n\n#if 0\n#define LICENSE_NULL_CLIENT_RANDOM 1\n#define LICENSE_NULL_PREMASTER_SECRET 1\n#endif\n\nstatic wStream* license_send_stream_init(rdpLicense* license);\n\nstatic void license_generate_randoms(rdpLicense* license);\nstatic BOOL license_generate_keys(rdpLicense* license);\nstatic BOOL license_generate_hwid(rdpLicense* license);\nstatic BOOL license_encrypt_premaster_secret(rdpLicense* license);\n\nstatic LICENSE_PRODUCT_INFO* license_new_product_info(void);\nstatic void license_free_product_info(LICENSE_PRODUCT_INFO* productInfo);\nstatic BOOL license_read_product_info(wStream* s, LICENSE_PRODUCT_INFO* productInfo);\n\nstatic LICENSE_BLOB* license_new_binary_blob(UINT16 type);\nstatic void license_free_binary_blob(LICENSE_BLOB* blob);\nstatic BOOL license_read_binary_blob(wStream* s, LICENSE_BLOB* blob);\nstatic BOOL license_write_binary_blob(wStream* s, const LICENSE_BLOB* blob);\n\nstatic SCOPE_LIST* license_new_scope_list(void);\nstatic void license_free_scope_list(SCOPE_LIST* scopeList);\nstatic BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList);\n\nstatic BOOL license_read_license_request_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_read_platform_challenge_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_read_error_alert_packet(rdpLicense* license, wStream* s);\n\nstatic BOOL license_write_new_license_request_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_answer_license_request(rdpLicense* license);\n\nstatic BOOL license_write_platform_challenge_response_packet(rdpLicense* license, wStream* s,\n                                                             const BYTE* mac_data);\nstatic BOOL license_send_platform_challenge_response_packet(rdpLicense* license);\nstatic BOOL license_send_client_info(rdpLicense* license, const LICENSE_BLOB* calBlob,\n                                     BYTE* signature);\n\n#define PLATFORMID (CLIENT_OS_ID_WINNT_POST_52 | CLIENT_IMAGE_ID_MICROSOFT)\n\n#ifdef WITH_DEBUG_LICENSE\n\nstatic const char* const LICENSE_MESSAGE_STRINGS[] = { \"\",\n\t                                                   \"License Request\",\n\t                                                   \"Platform Challenge\",\n\t                                                   \"New License\",\n\t                                                   \"Upgrade License\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"License Info\",\n\t                                                   \"New License Request\",\n\t                                                   \"\",\n\t                                                   \"Platform Challenge Response\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"Error Alert\" };\n\nstatic const char* const error_codes[] = { \"ERR_UNKNOWN\",\n\t                                       \"ERR_INVALID_SERVER_CERTIFICATE\",\n\t                                       \"ERR_NO_LICENSE\",\n\t                                       \"ERR_INVALID_MAC\",\n\t                                       \"ERR_INVALID_SCOPE\",\n\t                                       \"ERR_UNKNOWN\",\n\t                                       \"ERR_NO_LICENSE_SERVER\",\n\t                                       \"STATUS_VALID_CLIENT\",\n\t                                       \"ERR_INVALID_CLIENT\",\n\t                                       \"ERR_UNKNOWN\",\n\t                                       \"ERR_UNKNOWN\",\n\t                                       \"ERR_INVALID_PRODUCT_ID\",\n\t                                       \"ERR_INVALID_MESSAGE_LENGTH\" };\n\nstatic const char* const state_transitions[] = { \"ST_UNKNOWN\", \"ST_TOTAL_ABORT\", \"ST_NO_TRANSITION\",\n\t                                             \"ST_RESET_PHASE_TO_START\",\n\t                                             \"ST_RESEND_LAST_MESSAGE\" };\n\nstatic void license_print_product_info(const LICENSE_PRODUCT_INFO* productInfo)\n{\n\tchar* CompanyName = NULL;\n\tchar* ProductId = NULL;\n\tConvertFromUnicode(CP_UTF8, 0, (WCHAR*)productInfo->pbCompanyName,\n\t                   productInfo->cbCompanyName / 2, &CompanyName, 0, NULL, NULL);\n\tConvertFromUnicode(CP_UTF8, 0, (WCHAR*)productInfo->pbProductId, productInfo->cbProductId / 2,\n\t                   &ProductId, 0, NULL, NULL);\n\tWLog_INFO(TAG, \"ProductInfo:\");\n\tWLog_INFO(TAG, \"\\tdwVersion: 0x%08\" PRIX32 \"\", productInfo->dwVersion);\n\tWLog_INFO(TAG, \"\\tCompanyName: %s\", CompanyName);\n\tWLog_INFO(TAG, \"\\tProductId: %s\", ProductId);\n\tfree(CompanyName);\n\tfree(ProductId);\n}\n\nstatic void license_print_scope_list(const SCOPE_LIST* scopeList)\n{\n\tUINT32 index;\n\tconst LICENSE_BLOB* scope;\n\tWLog_INFO(TAG, \"ScopeList (%\" PRIu32 \"):\", scopeList->count);\n\n\tfor (index = 0; index < scopeList->count; index++)\n\t{\n\t\tscope = &scopeList->array[index];\n\t\tWLog_INFO(TAG, \"\\t%s\", (const char*)scope->data);\n\t}\n}\n#endif\n\nstatic const char licenseStore[] = \"licenses\";\n\nstatic BOOL computeCalHash(const char* hostname, char* hashStr)\n{\n\tWINPR_DIGEST_CTX* sha1 = NULL;\n\tBOOL ret = FALSE;\n\tBYTE hash[20];\n\tsize_t i;\n\n\tif (!(sha1 = winpr_Digest_New()))\n\t\tgoto out;\n\tif (!winpr_Digest_Init(sha1, WINPR_MD_SHA1))\n\t\tgoto out;\n\tif (!winpr_Digest_Update(sha1, (const BYTE*)hostname, strlen(hostname)))\n\t\tgoto out;\n\tif (!winpr_Digest_Final(sha1, hash, sizeof(hash)))\n\t\tgoto out;\n\n\tfor (i = 0; i < sizeof(hash); i++, hashStr += 2)\n\t\tsprintf_s(hashStr, 3, \"%.2x\", hash[i]);\n\n\tret = TRUE;\nout:\n\twinpr_Digest_Free(sha1);\n\treturn ret;\n}\n\nstatic BOOL saveCal(rdpSettings* settings, const BYTE* data, int length, char* hostname)\n{\n\tchar hash[41];\n\tFILE* fp;\n\tchar* licenseStorePath = NULL;\n\tchar filename[MAX_PATH], filenameNew[MAX_PATH];\n\tchar *filepath = NULL, *filepathNew = NULL;\n\tsize_t written;\n\tBOOL ret = FALSE;\n\n\tif (!PathFileExistsA(settings->ConfigPath))\n\t{\n\t\tif (!PathMakePathA(settings->ConfigPath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error creating directory '%s'\", settings->ConfigPath);\n\t\t\tgoto out;\n\t\t}\n\t\tWLog_INFO(TAG, \"creating directory %s\", settings->ConfigPath);\n\t}\n\n\tif (!(licenseStorePath = GetCombinedPath(settings->ConfigPath, licenseStore)))\n\t\tgoto out;\n\n\tif (!PathFileExistsA(licenseStorePath))\n\t{\n\t\tif (!PathMakePathA(licenseStorePath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error creating directory '%s'\", licenseStorePath);\n\t\t\tgoto out;\n\t\t}\n\t\tWLog_INFO(TAG, \"creating directory %s\", licenseStorePath);\n\t}\n\n\tif (!computeCalHash(hostname, hash))\n\t\tgoto out;\n\tsprintf_s(filename, sizeof(filename) - 1, \"%s.cal\", hash);\n\tsprintf_s(filenameNew, sizeof(filenameNew) - 1, \"%s.cal.new\", hash);\n\n\tif (!(filepath = GetCombinedPath(licenseStorePath, filename)))\n\t\tgoto out;\n\n\tif (!(filepathNew = GetCombinedPath(licenseStorePath, filenameNew)))\n\t\tgoto out;\n\n\tfp = fopen(filepathNew, \"wb\");\n\tif (!fp)\n\t\tgoto out;\n\n\twritten = fwrite(data, length, 1, fp);\n\tfclose(fp);\n\n\tif (written != 1)\n\t{\n\t\tDeleteFile(filepathNew);\n\t\tgoto out;\n\t}\n\n\tret = MoveFileEx(filepathNew, filepath, MOVEFILE_REPLACE_EXISTING);\n\nout:\n\tfree(filepathNew);\n\tfree(filepath);\n\tfree(licenseStorePath);\n\treturn ret;\n}\n\nstatic BYTE* loadCalFile(rdpSettings* settings, const char* hostname, int* dataLen)\n{\n\tchar *licenseStorePath = NULL, *calPath = NULL;\n\tchar calFilename[MAX_PATH];\n\tchar hash[41];\n\tint length, status;\n\tFILE* fp;\n\tBYTE* ret = NULL;\n\n\tif (!computeCalHash(hostname, hash))\n\t{\n\t\tWLog_ERR(TAG, \"loadCalFile: unable to compute hostname hash\");\n\t\treturn NULL;\n\t}\n\n\tsprintf_s(calFilename, sizeof(calFilename) - 1, \"%s.cal\", hash);\n\n\tif (!(licenseStorePath = GetCombinedPath(settings->ConfigPath, licenseStore)))\n\t\treturn NULL;\n\n\tif (!(calPath = GetCombinedPath(licenseStorePath, calFilename)))\n\t\tgoto error_path;\n\n\tfp = fopen(calPath, \"rb\");\n\tif (!fp)\n\t\tgoto error_open;\n\n\t_fseeki64(fp, 0, SEEK_END);\n\tlength = _ftelli64(fp);\n\t_fseeki64(fp, 0, SEEK_SET);\n\n\tret = (BYTE*)malloc(length);\n\tif (!ret)\n\t\tgoto error_malloc;\n\n\tstatus = fread(ret, length, 1, fp);\n\tif (status <= 0)\n\t\tgoto error_read;\n\n\t*dataLen = length;\n\n\tfclose(fp);\n\tfree(calPath);\n\tfree(licenseStorePath);\n\treturn ret;\n\nerror_read:\n\tfree(ret);\nerror_malloc:\n\tfclose(fp);\nerror_open:\n\tfree(calPath);\nerror_path:\n\tfree(licenseStorePath);\n\treturn NULL;\n}\n\n/**\n * Read a licensing preamble.\\n\n * @msdn{cc240480}\n * @param s stream\n * @param bMsgType license message type\n * @param flags message flags\n * @param wMsgSize message size\n * @return if the operation completed successfully\n */\n\nstatic BOOL license_read_preamble(wStream* s, BYTE* bMsgType, BYTE* flags, UINT16* wMsgSize)\n{\n\t/* preamble (4 bytes) */\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, *bMsgType);  /* bMsgType (1 byte) */\n\tStream_Read_UINT8(s, *flags);     /* flags (1 byte) */\n\tStream_Read_UINT16(s, *wMsgSize); /* wMsgSize (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write a licensing preamble.\\n\n * @msdn{cc240480}\n * @param s stream\n * @param bMsgType license message type\n * @param flags message flags\n * @param wMsgSize message size\n */\n\nstatic BOOL license_write_preamble(wStream* s, BYTE bMsgType, BYTE flags, UINT16 wMsgSize)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 4))\n\t\treturn FALSE;\n\n\t/* preamble (4 bytes) */\n\tStream_Write_UINT8(s, bMsgType);  /* bMsgType (1 byte) */\n\tStream_Write_UINT8(s, flags);     /* flags (1 byte) */\n\tStream_Write_UINT16(s, wMsgSize); /* wMsgSize (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Initialize a license packet stream.\\n\n * @param license license module\n * @return stream\n */\n\nwStream* license_send_stream_init(rdpLicense* license)\n{\n\twStream* s;\n\tBOOL do_crypt = license->rdp->do_crypt;\n\n\tlicense->rdp->sec_flags = SEC_LICENSE_PKT;\n\n\t/**\n\t * Encryption of licensing packets is optional even if the rdp security\n\t * layer is used. If the peer has not indicated that it is capable of\n\t * processing encrypted licensing packets (rdp->do_crypt_license) we turn\n\t * off encryption (via rdp->do_crypt) before initializing the rdp stream\n\t * and reenable it afterwards.\n\t */\n\n\tif (do_crypt)\n\t{\n\t\tlicense->rdp->sec_flags |= SEC_LICENSE_ENCRYPT_CS;\n\t\tlicense->rdp->do_crypt = license->rdp->do_crypt_license;\n\t}\n\n\ts = rdp_send_stream_init(license->rdp);\n\tif (!s)\n\t\treturn NULL;\n\n\tlicense->rdp->do_crypt = do_crypt;\n\tlicense->PacketHeaderLength = Stream_GetPosition(s);\n\tif (!Stream_SafeSeek(s, LICENSE_PREAMBLE_LENGTH))\n\t\tgoto fail;\n\treturn s;\n\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\n/**\n * Send an RDP licensing packet.\\n\n * @msdn{cc240479}\n * @param license license module\n * @param s stream\n */\n\nstatic BOOL license_send(rdpLicense* license, wStream* s, BYTE type)\n{\n\tsize_t length;\n\tBYTE flags;\n\tUINT16 wMsgSize;\n\trdpRdp* rdp = license->rdp;\n\tBOOL ret;\n\n\tDEBUG_LICENSE(\"Sending %s Packet\", LICENSE_MESSAGE_STRINGS[type & 0x1F]);\n\tlength = Stream_GetPosition(s);\n\twMsgSize = length - license->PacketHeaderLength;\n\tStream_SetPosition(s, license->PacketHeaderLength);\n\tflags = PREAMBLE_VERSION_3_0;\n\n\t/**\n\t * Using EXTENDED_ERROR_MSG_SUPPORTED here would cause mstsc to crash when\n\t * running in server mode! This flag seems to be incorrectly documented.\n\t */\n\n\tif (!rdp->settings->ServerMode)\n\t\tflags |= EXTENDED_ERROR_MSG_SUPPORTED;\n\n\tif (!license_write_preamble(s, type, flags, wMsgSize))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Sending %s Packet, length %\" PRIu16 \"\", LICENSE_MESSAGE_STRINGS[type & 0x1F],\n\t         wMsgSize);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(s) - LICENSE_PREAMBLE_LENGTH, wMsgSize);\n#endif\n\tStream_SetPosition(s, length);\n\tret = rdp_send(rdp, s, MCS_GLOBAL_CHANNEL_ID);\n\trdp->sec_flags = 0;\n\treturn ret;\n}\n\n/**\n * Receive an RDP licensing packet.\\n\n * @msdn{cc240479}\n * @param license license module\n * @param s stream\n * @return if the operation completed successfully\n */\n\nint license_recv(rdpLicense* license, wStream* s)\n{\n\tBYTE flags;\n\tBYTE bMsgType;\n\tUINT16 wMsgSize;\n\tUINT16 length;\n\tUINT16 channelId;\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(license->rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\treturn -1;\n\n\tif (securityFlags & SEC_ENCRYPT)\n\t{\n\t\tif (!rdp_decrypt(license->rdp, s, &length, securityFlags))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(securityFlags & SEC_LICENSE_PKT))\n\t{\n\t\tint status;\n\n\t\tif (!(securityFlags & SEC_ENCRYPT))\n\t\t\tStream_Rewind(s, RDP_SECURITY_HEADER_LENGTH);\n\n\t\tstatus = rdp_recv_out_of_sequence_pdu(license->rdp, s);\n\t\tif (status < 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"unexpected license packet.\");\n\t\t\treturn status;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!license_read_preamble(s, &bMsgType, &flags, &wMsgSize)) /* preamble (4 bytes) */\n\t\treturn -1;\n\n\tDEBUG_LICENSE(\"Receiving %s Packet\", LICENSE_MESSAGE_STRINGS[bMsgType & 0x1F]);\n\n\tswitch (bMsgType)\n\t{\n\t\tcase LICENSE_REQUEST:\n\t\t\tif (!license_read_license_request_packet(license, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (!license_answer_license_request(license))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase PLATFORM_CHALLENGE:\n\t\t\tif (!license_read_platform_challenge_packet(license, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (!license_send_platform_challenge_response_packet(license))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase NEW_LICENSE:\n\t\tcase UPGRADE_LICENSE:\n\t\t\tif (!license_read_new_or_upgrade_license_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase ERROR_ALERT:\n\t\t\tif (!license_read_error_alert_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"invalid bMsgType:%\" PRIu8 \"\", bMsgType);\n\t\t\treturn -1;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid license_generate_randoms(rdpLicense* license)\n{\n#ifdef LICENSE_NULL_CLIENT_RANDOM\n\tZeroMemory(license->ClientRandom, CLIENT_RANDOM_LENGTH); /* ClientRandom */\n#else\n\twinpr_RAND(license->ClientRandom, CLIENT_RANDOM_LENGTH);       /* ClientRandom */\n#endif\n\n#ifdef LICENSE_NULL_PREMASTER_SECRET\n\tZeroMemory(license->PremasterSecret, PREMASTER_SECRET_LENGTH); /* PremasterSecret */\n#else\n\twinpr_RAND(license->PremasterSecret, PREMASTER_SECRET_LENGTH); /* PremasterSecret */\n#endif\n}\n\n/**\n * Generate License Cryptographic Keys.\n * @param license license module\n */\n\nstatic BOOL license_generate_keys(rdpLicense* license)\n{\n\tBOOL ret;\n\n\tif (\n\t    /* MasterSecret */\n\t    !security_master_secret(license->PremasterSecret, license->ClientRandom,\n\t                            license->ServerRandom, license->MasterSecret) ||\n\t    /* SessionKeyBlob */\n\t    !security_session_key_blob(license->MasterSecret, license->ClientRandom,\n\t                               license->ServerRandom, license->SessionKeyBlob))\n\t{\n\t\treturn FALSE;\n\t}\n\tsecurity_mac_salt_key(license->SessionKeyBlob, license->ClientRandom, license->ServerRandom,\n\t                      license->MacSaltKey); /* MacSaltKey */\n\tret = security_licensing_encryption_key(\n\t    license->SessionKeyBlob, license->ClientRandom, license->ServerRandom,\n\t    license->LicensingEncryptionKey); /* LicensingEncryptionKey */\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"ClientRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ClientRandom, CLIENT_RANDOM_LENGTH);\n\tWLog_DBG(TAG, \"ServerRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ServerRandom, SERVER_RANDOM_LENGTH);\n\tWLog_DBG(TAG, \"PremasterSecret:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->PremasterSecret, PREMASTER_SECRET_LENGTH);\n\tWLog_DBG(TAG, \"MasterSecret:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->MasterSecret, MASTER_SECRET_LENGTH);\n\tWLog_DBG(TAG, \"SessionKeyBlob:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->SessionKeyBlob, SESSION_KEY_BLOB_LENGTH);\n\tWLog_DBG(TAG, \"MacSaltKey:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->MacSaltKey, MAC_SALT_KEY_LENGTH);\n\tWLog_DBG(TAG, \"LicensingEncryptionKey:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->LicensingEncryptionKey,\n\t              LICENSING_ENCRYPTION_KEY_LENGTH);\n#endif\n\treturn ret;\n}\n\n/**\n * Generate Unique Hardware Identifier (CLIENT_HARDWARE_ID).\\n\n * @param license license module\n */\n\nBOOL license_generate_hwid(rdpLicense* license)\n{\n\tconst BYTE* hashTarget;\n\tsize_t targetLen;\n\tBYTE macAddress[6];\n\n\tZeroMemory(license->HardwareId, HWID_LENGTH);\n\n\tif (license->rdp->settings->OldLicenseBehaviour)\n\t{\n\t\tZeroMemory(macAddress, sizeof(macAddress));\n\t\thashTarget = macAddress;\n\t\ttargetLen = sizeof(macAddress);\n\t}\n\telse\n\t{\n\t\twStream s;\n\t\tconst char* hostname = license->rdp->settings->ClientHostname;\n\t\tStream_StaticInit(&s, license->HardwareId, 4);\n\t\tStream_Write_UINT32(&s, PLATFORMID);\n\t\tStream_Free(&s, TRUE);\n\n\t\thashTarget = (const BYTE*)hostname;\n\t\ttargetLen = strlen(hostname);\n\t}\n\n\t/* Allow FIPS override for use of MD5 here, really this does not have to be MD5 as we are just\n\t * taking a MD5 hash of the 6 bytes of 0's(macAddress) */\n\t/* and filling in the Data1-Data4 fields of the CLIENT_HARDWARE_ID structure(from MS-RDPELE\n\t * section 2.2.2.3.1). This is for RDP licensing packets */\n\t/* which will already be encrypted under FIPS, so the use of MD5 here is not for sensitive data\n\t * protection. */\n\treturn winpr_Digest_Allow_FIPS(WINPR_MD_MD5, hashTarget, targetLen,\n\t                               &license->HardwareId[HWID_PLATFORM_ID_LENGTH],\n\t                               WINPR_MD5_DIGEST_LENGTH);\n}\n\nstatic BOOL license_get_server_rsa_public_key(rdpLicense* license)\n{\n\tBYTE* Exponent;\n\tBYTE* Modulus;\n\tint ModulusLength;\n\trdpSettings* settings = license->rdp->settings;\n\n\tif (license->ServerCertificate->length < 1)\n\t{\n\t\tif (!certificate_read_server_certificate(license->certificate, settings->ServerCertificate,\n\t\t                                         settings->ServerCertificateLength))\n\t\t\treturn FALSE;\n\t}\n\n\tExponent = license->certificate->cert_info.exponent;\n\tModulus = license->certificate->cert_info.Modulus;\n\tModulusLength = license->certificate->cert_info.ModulusLength;\n\tCopyMemory(license->Exponent, Exponent, 4);\n\tlicense->ModulusLength = ModulusLength;\n\tlicense->Modulus = (BYTE*)malloc(ModulusLength);\n\tif (!license->Modulus)\n\t\treturn FALSE;\n\tCopyMemory(license->Modulus, Modulus, ModulusLength);\n\treturn TRUE;\n}\n\nBOOL license_encrypt_premaster_secret(rdpLicense* license)\n{\n\tBYTE* EncryptedPremasterSecret;\n\n\tif (!license_get_server_rsa_public_key(license))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Modulus (%\" PRIu32 \" bits):\", license->ModulusLength * 8);\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->Modulus, license->ModulusLength);\n\tWLog_DBG(TAG, \"Exponent:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->Exponent, 4);\n#endif\n\n\tEncryptedPremasterSecret = (BYTE*)calloc(1, license->ModulusLength);\n\tif (!EncryptedPremasterSecret)\n\t\treturn FALSE;\n\n\tlicense->EncryptedPremasterSecret->type = BB_RANDOM_BLOB;\n\tlicense->EncryptedPremasterSecret->length = PREMASTER_SECRET_LENGTH;\n#ifndef LICENSE_NULL_PREMASTER_SECRET\n\tlicense->EncryptedPremasterSecret->length = crypto_rsa_public_encrypt(\n\t    license->PremasterSecret, PREMASTER_SECRET_LENGTH, license->ModulusLength, license->Modulus,\n\t    license->Exponent, EncryptedPremasterSecret);\n#endif\n\tlicense->EncryptedPremasterSecret->data = EncryptedPremasterSecret;\n\treturn TRUE;\n}\n\nstatic BOOL license_rc4_with_licenseKey(const rdpLicense* license, const BYTE* input, size_t len,\n                                        LICENSE_BLOB* target)\n{\n\tWINPR_RC4_CTX* rc4;\n\tBYTE* buffer = NULL;\n\n\trc4 =\n\t    winpr_RC4_New_Allow_FIPS(license->LicensingEncryptionKey, LICENSING_ENCRYPTION_KEY_LENGTH);\n\tif (!rc4)\n\t\treturn FALSE;\n\n\tbuffer = (BYTE*)realloc(target->data, len);\n\tif (!buffer)\n\t\tgoto error_buffer;\n\n\ttarget->data = buffer;\n\ttarget->length = len;\n\n\tif (!winpr_RC4_Update(rc4, len, input, buffer))\n\t\tgoto error_buffer;\n\n\twinpr_RC4_Free(rc4);\n\treturn TRUE;\n\nerror_buffer:\n\twinpr_RC4_Free(rc4);\n\treturn FALSE;\n}\n\n/**\n * Encrypt the input using the license key and MAC the input for a signature\n *\n * @param license rdpLicense to get keys and salt from\n * @param input the input data to encrypt and MAC\n * @param len size of input\n * @param target a target LICENSE_BLOB where the encrypted input will be stored\n * @param mac the signature buffer (16 bytes)\n * @return if the operation completed successfully\n */\nstatic BOOL license_encrypt_and_MAC(rdpLicense* license, const BYTE* input, size_t len,\n                                    LICENSE_BLOB* target, BYTE* mac)\n{\n\treturn license_rc4_with_licenseKey(license, input, len, target) &&\n\t       security_mac_data(license->MacSaltKey, input, len, mac);\n}\n\n/**\n * Decrypt the input using the license key and check the MAC\n *\n * @param license rdpLicense to get keys and salt from\n * @param input the input data to decrypt and MAC\n * @param len size of input\n * @param target a target LICENSE_BLOB where the decrypted input will be stored\n * @param mac the signature buffer (16 bytes)\n * @return if the operation completed successfully\n */\nstatic BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,\n                                          LICENSE_BLOB* target, const BYTE* packetMac)\n{\n\tBYTE macData[16];\n\n\treturn license_rc4_with_licenseKey(license, input, len, target) &&\n\t       security_mac_data(license->MacSaltKey, target->data, len, macData) &&\n\t       (memcmp(packetMac, macData, sizeof(macData)) == 0);\n}\n\n/**\n * Read Product Information (PRODUCT_INFO).\\n\n * @msdn{cc241915}\n * @param s stream\n * @param productInfo product information\n */\n\nBOOL license_read_product_info(wStream* s, LICENSE_PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, productInfo->dwVersion);     /* dwVersion (4 bytes) */\n\tStream_Read_UINT32(s, productInfo->cbCompanyName); /* cbCompanyName (4 bytes) */\n\n\t/* Name must be >0, but there is no upper limit defined, use UINT32_MAX */\n\tif ((productInfo->cbCompanyName < 2) || (productInfo->cbCompanyName % 2 != 0))\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName)\n\t\treturn FALSE;\n\n\tproductInfo->pbProductId = NULL;\n\tproductInfo->pbCompanyName = (BYTE*)malloc(productInfo->cbCompanyName);\n\tif (!productInfo->pbCompanyName)\n\t\treturn FALSE;\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto out_fail;\n\n\tStream_Read_UINT32(s, productInfo->cbProductId); /* cbProductId (4 bytes) */\n\n\tif ((productInfo->cbProductId < 2) || (productInfo->cbProductId % 2 != 0))\n\t\tgoto out_fail;\n\n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t\tgoto out_fail;\n\n\tproductInfo->pbProductId = (BYTE*)malloc(productInfo->cbProductId);\n\tif (!productInfo->pbProductId)\n\t\tgoto out_fail;\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n\nout_fail:\n\tfree(productInfo->pbCompanyName);\n\tfree(productInfo->pbProductId);\n\tproductInfo->pbCompanyName = NULL;\n\tproductInfo->pbProductId = NULL;\n\treturn FALSE;\n}\n\n/**\n * Allocate New Product Information (LICENSE_PRODUCT_INFO).\\n\n * @msdn{cc241915}\n * @return new product information\n */\n\nLICENSE_PRODUCT_INFO* license_new_product_info()\n{\n\tLICENSE_PRODUCT_INFO* productInfo;\n\tproductInfo = (LICENSE_PRODUCT_INFO*)malloc(sizeof(LICENSE_PRODUCT_INFO));\n\tif (!productInfo)\n\t\treturn NULL;\n\tproductInfo->dwVersion = 0;\n\tproductInfo->cbCompanyName = 0;\n\tproductInfo->pbCompanyName = NULL;\n\tproductInfo->cbProductId = 0;\n\tproductInfo->pbProductId = NULL;\n\treturn productInfo;\n}\n\n/**\n * Free Product Information (LICENSE_PRODUCT_INFO).\\n\n * @msdn{cc241915}\n * @param productInfo product information\n */\n\nvoid license_free_product_info(LICENSE_PRODUCT_INFO* productInfo)\n{\n\tif (productInfo)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tfree(productInfo->pbProductId);\n\t\tfree(productInfo);\n\t}\n}\n\n/**\n * Read License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @param s stream\n * @param blob license binary blob\n */\n\nBOOL license_read_binary_blob(wStream* s, LICENSE_BLOB* blob)\n{\n\tUINT16 wBlobType;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, wBlobType);    /* wBlobType (2 bytes) */\n\tStream_Read_UINT16(s, blob->length); /* wBlobLen (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < blob->length)\n\t\treturn FALSE;\n\n\t/*\n\t * Server can choose to not send data by setting length to 0.\n\t * If so, it may not bother to set the type, so shortcut the warning\n\t */\n\tif ((blob->type != BB_ANY_BLOB) && (blob->length == 0))\n\t\treturn TRUE;\n\n\tif ((blob->type != wBlobType) && (blob->type != BB_ANY_BLOB))\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"license binary blob type (0x%\" PRIx16 \") does not match expected type (0x%\" PRIx16\n\t\t         \").\",\n\t\t         wBlobType, blob->type);\n\t}\n\n\tblob->type = wBlobType;\n\tblob->data = (BYTE*)malloc(blob->length);\n\tif (!blob->data)\n\t\treturn FALSE;\n\tStream_Read(s, blob->data, blob->length); /* blobData */\n\treturn TRUE;\n}\n\n/**\n * Write License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @param s stream\n * @param blob license binary blob\n */\n\nBOOL license_write_binary_blob(wStream* s, const LICENSE_BLOB* blob)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, blob->length + 4))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, blob->type);   /* wBlobType (2 bytes) */\n\tStream_Write_UINT16(s, blob->length); /* wBlobLen (2 bytes) */\n\n\tif (blob->length > 0)\n\t\tStream_Write(s, blob->data, blob->length); /* blobData */\n\treturn TRUE;\n}\n\nstatic BOOL license_write_encrypted_premaster_secret_blob(wStream* s, const LICENSE_BLOB* blob,\n                                                          UINT32 ModulusLength)\n{\n\tUINT32 length;\n\tlength = ModulusLength + 8;\n\n\tif (blob->length > ModulusLength)\n\t{\n\t\tWLog_ERR(TAG, \"license_write_encrypted_premaster_secret_blob: invalid blob\");\n\t\treturn FALSE;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(s, length + 4))\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, blob->type); /* wBlobType (2 bytes) */\n\tStream_Write_UINT16(s, length);     /* wBlobLen (2 bytes) */\n\n\tif (blob->length > 0)\n\t\tStream_Write(s, blob->data, blob->length); /* blobData */\n\n\tStream_Zero(s, length - blob->length);\n\treturn TRUE;\n}\n\n/**\n * Allocate New License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @return new license binary blob\n */\n\nLICENSE_BLOB* license_new_binary_blob(UINT16 type)\n{\n\tLICENSE_BLOB* blob;\n\tblob = (LICENSE_BLOB*)calloc(1, sizeof(LICENSE_BLOB));\n\tif (blob)\n\t\tblob->type = type;\n\treturn blob;\n}\n\n/**\n * Free License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @param blob license binary blob\n */\n\nvoid license_free_binary_blob(LICENSE_BLOB* blob)\n{\n\tif (blob)\n\t{\n\t\tfree(blob->data);\n\t\tfree(blob);\n\t}\n}\n\n/**\n * Read License Scope List (SCOPE_LIST).\\n\n * @msdn{cc241916}\n * @param s stream\n * @param scopeList scope list\n */\n\nBOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n\n\tif (scopeCount > Stream_GetRemainingLength(s) / 4) /* every blob is at least 4 bytes */\n\t\treturn FALSE;\n\n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*)calloc(scopeCount, sizeof(LICENSE_BLOB));\n\tif (!scopeList->array)\n\t\treturn FALSE;\n\n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Allocate New License Scope List (SCOPE_LIST).\\n\n * @msdn{cc241916}\n * @return new scope list\n */\n\nSCOPE_LIST* license_new_scope_list()\n{\n\treturn (SCOPE_LIST*)calloc(1, sizeof(SCOPE_LIST));\n}\n\n/**\n * Free License Scope List (SCOPE_LIST).\\n\n * @msdn{cc241916}\n * @param scopeList scope list\n */\n\nvoid license_free_scope_list(SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\n\tif (!scopeList)\n\t\treturn;\n\n\t/*\n\t * We must NOT call license_free_binary_blob() on each scopelist->array[i] element,\n\t * because scopelist->array was allocated at once, by a single call to malloc. The elements\n\t * it contains cannot be deallocated separately then.\n\t * To make things clean, we must deallocate each scopelist->array[].data,\n\t * and finish by deallocating scopelist->array with a single call to free().\n\t */\n\tfor (i = 0; i < scopeList->count; i++)\n\t{\n\t\tfree(scopeList->array[i].data);\n\t}\n\n\tfree(scopeList->array);\n\tfree(scopeList);\n}\n\nBOOL license_send_client_info(rdpLicense* license, const LICENSE_BLOB* calBlob, BYTE* signature)\n{\n\twStream* s;\n\n\t/* Client License Information: */\n\tUINT32 PlatformId = PLATFORMID;\n\tUINT32 PreferredKeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;\n\n\ts = license_send_stream_init(license);\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, PreferredKeyExchangeAlg); /* PreferredKeyExchangeAlg (4 bytes) */\n\tStream_Write_UINT32(s, PlatformId);              /* PlatformId (4 bytes) */\n\n\t/* ClientRandom (32 bytes) */\n\tStream_Write(s, license->ClientRandom, CLIENT_RANDOM_LENGTH);\n\n\t/* Licensing Binary Blob with EncryptedPreMasterSecret: */\n\tif (!license_write_encrypted_premaster_secret_blob(s, license->EncryptedPremasterSecret,\n\t                                                   license->ModulusLength))\n\t\tgoto error;\n\n\t/* Licensing Binary Blob with LicenseInfo: */\n\tif (!license_write_binary_blob(s, calBlob))\n\t\tgoto error;\n\n\t/* Licensing Binary Blob with EncryptedHWID */\n\tif (!license_write_binary_blob(s, license->EncryptedHardwareId))\n\t\tgoto error;\n\n\t/* MACData */\n\tStream_Write(s, signature, LICENSING_ENCRYPTION_KEY_LENGTH);\n\n\treturn license_send(license, s, LICENSE_INFO);\n\nerror:\n\tStream_Release(s);\n\treturn FALSE;\n}\n\n/**\n * Read a LICENSE_REQUEST packet.\\n\n * @msdn{cc241914}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_license_request_packet(rdpLicense* license, wStream* s)\n{\n\t/* ServerRandom (32 bytes) */\n\tif (Stream_GetRemainingLength(s) < 32)\n\t\treturn FALSE;\n\n\tStream_Read(s, license->ServerRandom, 32);\n\n\t/* ProductInfo */\n\tif (!license_read_product_info(s, license->ProductInfo))\n\t\treturn FALSE;\n\n\t/* KeyExchangeList */\n\tif (!license_read_binary_blob(s, license->KeyExchangeList))\n\t\treturn FALSE;\n\n\t/* ServerCertificate */\n\tif (!license_read_binary_blob(s, license->ServerCertificate))\n\t\treturn FALSE;\n\n\t/* ScopeList */\n\tif (!license_read_scope_list(s, license->ScopeList))\n\t\treturn FALSE;\n\n\t/* Parse Server Certificate */\n\tif (!certificate_read_server_certificate(license->certificate, license->ServerCertificate->data,\n\t                                         license->ServerCertificate->length))\n\t\treturn FALSE;\n\n\tif (!license_generate_keys(license) || !license_generate_hwid(license) ||\n\t    !license_encrypt_premaster_secret(license))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"ServerRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ServerRandom, 32);\n\tlicense_print_product_info(license->ProductInfo);\n\tlicense_print_scope_list(license->ScopeList);\n#endif\n\treturn TRUE;\n}\n\n/*\n * Read a PLATFORM_CHALLENGE packet.\\n\n * @msdn{cc241921}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_platform_challenge_packet(rdpLicense* license, wStream* s)\n{\n\tBYTE macData[16];\n\tUINT32 ConnectFlags = 0;\n\n\tDEBUG_LICENSE(\"Receiving Platform Challenge Packet\");\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, ConnectFlags); /* ConnectFlags, Reserved (4 bytes) */\n\n\t/* EncryptedPlatformChallenge */\n\tlicense->EncryptedPlatformChallenge->type = BB_ANY_BLOB;\n\tif (!license_read_binary_blob(s, license->EncryptedPlatformChallenge))\n\t\treturn FALSE;\n\tlicense->EncryptedPlatformChallenge->type = BB_ENCRYPTED_DATA_BLOB;\n\n\t/* MACData (16 bytes) */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn FALSE;\n\n\tStream_Read(s, macData, 16);\n\tif (!license_decrypt_and_check_MAC(license, license->EncryptedPlatformChallenge->data,\n\t                                   license->EncryptedPlatformChallenge->length,\n\t                                   license->PlatformChallenge, macData))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"ConnectFlags: 0x%08\" PRIX32 \"\", ConnectFlags);\n\tWLog_DBG(TAG, \"EncryptedPlatformChallenge:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->EncryptedPlatformChallenge->data,\n\t              license->EncryptedPlatformChallenge->length);\n\tWLog_DBG(TAG, \"PlatformChallenge:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->PlatformChallenge->data,\n\t              license->PlatformChallenge->length);\n\tWLog_DBG(TAG, \"MacData:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, macData, 16);\n#endif\n\treturn TRUE;\n}\n\nstatic BOOL license_read_encrypted_blob(const rdpLicense* license, wStream* s, LICENSE_BLOB* target)\n{\n\tUINT16 wBlobType, wBlobLen;\n\tBYTE* encryptedData;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, wBlobType);\n\tif (wBlobType != BB_ENCRYPTED_DATA_BLOB)\n\t{\n\t\tWLog_DBG(\n\t\t    TAG,\n\t\t    \"expecting BB_ENCRYPTED_DATA_BLOB blob, probably a windows 2003 server, continuing...\");\n\t}\n\n\tStream_Read_UINT16(s, wBlobLen);\n\n\tif (Stream_GetRemainingLength(s) < wBlobLen)\n\t\treturn FALSE;\n\n\tencryptedData = Stream_Pointer(s);\n\tStream_Seek(s, wBlobLen);\n\treturn license_rc4_with_licenseKey(license, encryptedData, wBlobLen, target);\n}\n\n/**\n * Read a NEW_LICENSE packet.\\n\n * @msdn{cc241926}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 os_major;\n\tUINT32 os_minor;\n\tUINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;\n\twStream* licenseStream = NULL;\n\tBOOL ret = FALSE;\n\tBYTE computedMac[16];\n\tLICENSE_BLOB* calBlob;\n\n\tDEBUG_LICENSE(\"Receiving Server New/Upgrade License Packet\");\n\n\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\tif (!calBlob)\n\t\treturn FALSE;\n\n\t/* EncryptedLicenseInfo */\n\tif (!license_read_encrypted_blob(license, s, calBlob))\n\t\tgoto out_free_blob;\n\n\t/* compute MAC and check it */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\tgoto out_free_blob;\n\n\tif (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))\n\t\tgoto out_free_blob;\n\n\tif (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"new or upgrade license MAC mismatch\");\n\t\tgoto out_free_blob;\n\t}\n\n\tif (!Stream_SafeSeek(s, 16))\n\t\tgoto out_free_blob;\n\n\tlicenseStream = Stream_New(calBlob->data, calBlob->length);\n\tif (!licenseStream)\n\t\tgoto out_free_blob;\n\n\tStream_Read_UINT16(licenseStream, os_minor);\n\tStream_Read_UINT16(licenseStream, os_major);\n\n\t/* Scope */\n\tStream_Read_UINT32(licenseStream, cbScope);\n\tif (Stream_GetRemainingLength(licenseStream) < cbScope)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Scope:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);\n#endif\n\tStream_Seek(licenseStream, cbScope);\n\n\t/* CompanyName */\n\tStream_Read_UINT32(licenseStream, cbCompanyName);\n\tif (Stream_GetRemainingLength(licenseStream) < cbCompanyName)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Company name:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);\n#endif\n\tStream_Seek(licenseStream, cbCompanyName);\n\n\t/* productId */\n\tStream_Read_UINT32(licenseStream, cbProductId);\n\tif (Stream_GetRemainingLength(licenseStream) < cbProductId)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Product id:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);\n#endif\n\tStream_Seek(licenseStream, cbProductId);\n\n\t/* licenseInfo */\n\tStream_Read_UINT32(licenseStream, cbLicenseInfo);\n\tif (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)\n\t\tgoto out_free_stream;\n\n\tlicense->state = LICENSE_STATE_COMPLETED;\n\n\tret = TRUE;\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,\n\t\t              license->rdp->settings->ClientHostname);\n\nout_free_stream:\n\tStream_Free(licenseStream, FALSE);\nout_free_blob:\n\tlicense_free_binary_blob(calBlob);\n\treturn ret;\n}\n\n/**\n * Read an ERROR_ALERT packet.\\n\n * @msdn{cc240482}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_error_alert_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 dwErrorCode;\n\tUINT32 dwStateTransition;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, dwErrorCode);       /* dwErrorCode (4 bytes) */\n\tStream_Read_UINT32(s, dwStateTransition); /* dwStateTransition (4 bytes) */\n\n\tif (!license_read_binary_blob(s, license->ErrorInfo)) /* bbErrorInfo */\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"dwErrorCode: %s, dwStateTransition: %s\", error_codes[dwErrorCode],\n\t         state_transitions[dwStateTransition]);\n#endif\n\n\tif (dwErrorCode == STATUS_VALID_CLIENT)\n\t{\n\t\tlicense->state = LICENSE_STATE_COMPLETED;\n\t\treturn TRUE;\n\t}\n\n\tswitch (dwStateTransition)\n\t{\n\t\tcase ST_TOTAL_ABORT:\n\t\t\tlicense->state = LICENSE_STATE_ABORTED;\n\t\t\tbreak;\n\t\tcase ST_NO_TRANSITION:\n\t\t\tlicense->state = LICENSE_STATE_COMPLETED;\n\t\t\tbreak;\n\t\tcase ST_RESET_PHASE_TO_START:\n\t\t\tlicense->state = LICENSE_STATE_AWAIT;\n\t\t\tbreak;\n\t\tcase ST_RESEND_LAST_MESSAGE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a NEW_LICENSE_REQUEST packet.\\n\n * @msdn{cc241918}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_write_new_license_request_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 PlatformId = PLATFORMID;\n\tUINT32 PreferredKeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;\n\n\tStream_Write_UINT32(s, PreferredKeyExchangeAlg); /* PreferredKeyExchangeAlg (4 bytes) */\n\tStream_Write_UINT32(s, PlatformId);              /* PlatformId (4 bytes) */\n\tStream_Write(s, license->ClientRandom, 32);      /* ClientRandom (32 bytes) */\n\n\tif (/* EncryptedPremasterSecret */\n\t    !license_write_encrypted_premaster_secret_blob(s, license->EncryptedPremasterSecret,\n\t                                                   license->ModulusLength) ||\n\t    /* ClientUserName */\n\t    !license_write_binary_blob(s, license->ClientUserName) ||\n\t    /* ClientMachineName */\n\t    !license_write_binary_blob(s, license->ClientMachineName))\n\t{\n\t\treturn FALSE;\n\t}\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"PreferredKeyExchangeAlg: 0x%08\" PRIX32 \"\", PreferredKeyExchangeAlg);\n\tWLog_DBG(TAG, \"ClientRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ClientRandom, 32);\n\tWLog_DBG(TAG, \"EncryptedPremasterSecret\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->EncryptedPremasterSecret->data,\n\t              license->EncryptedPremasterSecret->length);\n\tWLog_DBG(TAG, \"ClientUserName (%\" PRIu16 \"): %s\", license->ClientUserName->length,\n\t         (char*)license->ClientUserName->data);\n\tWLog_DBG(TAG, \"ClientMachineName (%\" PRIu16 \"): %s\", license->ClientMachineName->length,\n\t         (char*)license->ClientMachineName->data);\n#endif\n\treturn TRUE;\n}\n\n/**\n * Send a NEW_LICENSE_REQUEST packet.\\n\n * @msdn{cc241918}\n * @param license license module\n */\n\nBOOL license_answer_license_request(rdpLicense* license)\n{\n\twStream* s;\n\tBYTE* license_data = NULL;\n\tint license_size = 0;\n\tBOOL status;\n\tchar* username;\n\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tlicense_data = loadCalFile(license->rdp->settings, license->rdp->settings->ClientHostname,\n\t\t                           &license_size);\n\n\tif (license_data)\n\t{\n\t\tLICENSE_BLOB* calBlob = NULL;\n\t\tBYTE signature[LICENSING_ENCRYPTION_KEY_LENGTH];\n\n\t\tDEBUG_LICENSE(\"Sending Saved License Packet\");\n\n\t\tlicense->EncryptedHardwareId->type = BB_ENCRYPTED_DATA_BLOB;\n\t\tif (!license_encrypt_and_MAC(license, license->HardwareId, HWID_LENGTH,\n\t\t                             license->EncryptedHardwareId, signature))\n\t\t{\n\t\t\tfree(license_data);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\t\tif (!calBlob)\n\t\t{\n\t\t\tfree(license_data);\n\t\t\treturn FALSE;\n\t\t}\n\t\tcalBlob->data = license_data;\n\t\tcalBlob->length = license_size;\n\n\t\tstatus = license_send_client_info(license, calBlob, signature);\n\t\tlicense_free_binary_blob(calBlob);\n\n\t\treturn status;\n\t}\n\n\tDEBUG_LICENSE(\"Sending New License Packet\");\n\n\ts = license_send_stream_init(license);\n\tif (!s)\n\t\treturn FALSE;\n\tif (license->rdp->settings->Username != NULL)\n\t\tusername = license->rdp->settings->Username;\n\telse\n\t\tusername = \"username\";\n\n\tlicense->ClientUserName->data = (BYTE*)username;\n\tlicense->ClientUserName->length = strlen(username) + 1;\n\tlicense->ClientMachineName->data = (BYTE*)license->rdp->settings->ClientHostname;\n\tlicense->ClientMachineName->length = strlen(license->rdp->settings->ClientHostname) + 1;\n\n\tstatus = license_write_new_license_request_packet(license, s);\n\n\tlicense->ClientUserName->data = NULL;\n\tlicense->ClientUserName->length = 0;\n\tlicense->ClientMachineName->data = NULL;\n\tlicense->ClientMachineName->length = 0;\n\n\tif (!status)\n\t{\n\t\tStream_Release(s);\n\t\treturn FALSE;\n\t}\n\n\treturn license_send(license, s, NEW_LICENSE_REQUEST);\n}\n\n/**\n * Write Client Challenge Response Packet.\\n\n * @msdn{cc241922}\n * @param license license module\n * @param s stream\n * @param mac_data signature\n */\n\nBOOL license_write_platform_challenge_response_packet(rdpLicense* license, wStream* s,\n                                                      const BYTE* macData)\n{\n\tif (!license_write_binary_blob(\n\t        s,\n\t        license->EncryptedPlatformChallengeResponse) || /* EncryptedPlatformChallengeResponse */\n\t    !license_write_binary_blob(s, license->EncryptedHardwareId) || /* EncryptedHWID */\n\t    !Stream_EnsureRemainingCapacity(s, 16))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tStream_Write(s, macData, 16); /* MACData */\n\treturn TRUE;\n}\n\n/**\n * Send Client Challenge Response Packet.\\n\n * @msdn{cc241922}\n * @param license license module\n */\n\nBOOL license_send_platform_challenge_response_packet(rdpLicense* license)\n{\n\twStream* s;\n\twStream* challengeRespData;\n\tint length;\n\tBYTE* buffer;\n\tBYTE mac_data[16];\n\tBOOL status;\n\n\tDEBUG_LICENSE(\"Sending Platform Challenge Response Packet\");\n\ts = license_send_stream_init(license);\n\tlicense->EncryptedPlatformChallenge->type = BB_DATA_BLOB;\n\n\t/* prepare the PLATFORM_CHALLENGE_RESPONSE_DATA */\n\tchallengeRespData = Stream_New(NULL, 8 + license->PlatformChallenge->length);\n\tif (!challengeRespData)\n\t\treturn FALSE;\n\tStream_Write_UINT16(challengeRespData, 0x0100);                        /* wVersion */\n\tStream_Write_UINT16(challengeRespData, OTHER_PLATFORM_CHALLENGE_TYPE); /* wClientType */\n\tStream_Write_UINT16(challengeRespData, LICENSE_DETAIL_DETAIL);         /* wLicenseDetailLevel */\n\tStream_Write_UINT16(challengeRespData, license->PlatformChallenge->length); /* cbChallenge */\n\tStream_Write(challengeRespData, license->PlatformChallenge->data,\n\t             license->PlatformChallenge->length); /* pbChallenge */\n\tStream_SealLength(challengeRespData);\n\n\t/* compute MAC of PLATFORM_CHALLENGE_RESPONSE_DATA + HWID */\n\tlength = Stream_Length(challengeRespData) + HWID_LENGTH;\n\tbuffer = (BYTE*)malloc(length);\n\tif (!buffer)\n\t{\n\t\tStream_Free(challengeRespData, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tCopyMemory(buffer, Stream_Buffer(challengeRespData), Stream_Length(challengeRespData));\n\tCopyMemory(&buffer[Stream_Length(challengeRespData)], license->HardwareId, HWID_LENGTH);\n\tstatus = security_mac_data(license->MacSaltKey, buffer, length, mac_data);\n\tfree(buffer);\n\n\tif (!status)\n\t{\n\t\tStream_Free(challengeRespData, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tlicense->EncryptedHardwareId->type = BB_ENCRYPTED_DATA_BLOB;\n\tif (!license_rc4_with_licenseKey(license, license->HardwareId, HWID_LENGTH,\n\t                                 license->EncryptedHardwareId))\n\t{\n\t\tStream_Free(challengeRespData, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tstatus = license_rc4_with_licenseKey(license, Stream_Buffer(challengeRespData),\n\t                                     Stream_Length(challengeRespData),\n\t                                     license->EncryptedPlatformChallengeResponse);\n\tStream_Free(challengeRespData, TRUE);\n\tif (!status)\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"LicensingEncryptionKey:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->LicensingEncryptionKey, 16);\n\tWLog_DBG(TAG, \"HardwareId:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->HardwareId, HWID_LENGTH);\n\tWLog_DBG(TAG, \"EncryptedHardwareId:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->EncryptedHardwareId->data, HWID_LENGTH);\n#endif\n\tif (license_write_platform_challenge_response_packet(license, s, mac_data))\n\t\treturn license_send(license, s, PLATFORM_CHALLENGE_RESPONSE);\n\n\tStream_Release(s);\n\treturn FALSE;\n}\n\n/**\n * Send Server License Error - Valid Client Packet.\\n\n * @msdn{cc241922}\n * @param license license module\n */\n\nBOOL license_send_valid_client_error_packet(rdpRdp* rdp)\n{\n\trdpLicense* license = rdp->license;\n\twStream* s = license_send_stream_init(license);\n\tif (!s)\n\t\treturn FALSE;\n\n\tDEBUG_LICENSE(\"Sending Error Alert Packet\");\n\tStream_Write_UINT32(s, STATUS_VALID_CLIENT); /* dwErrorCode */\n\tStream_Write_UINT32(s, ST_NO_TRANSITION);    /* dwStateTransition */\n\n\tif (license_write_binary_blob(s, license->ErrorInfo))\n\t\treturn license_send(license, s, ERROR_ALERT);\n\n\tStream_Release(s);\n\treturn FALSE;\n}\n\n/**\n * Instantiate new license module.\n * @param rdp RDP module\n * @return new license module\n */\n\nrdpLicense* license_new(rdpRdp* rdp)\n{\n\trdpLicense* license;\n\tlicense = (rdpLicense*)calloc(1, sizeof(rdpLicense));\n\tif (!license)\n\t\treturn NULL;\n\n\tlicense->rdp = rdp;\n\tlicense->state = LICENSE_STATE_AWAIT;\n\tif (!(license->certificate = certificate_new()))\n\t\tgoto out_error;\n\tif (!(license->ProductInfo = license_new_product_info()))\n\t\tgoto out_error;\n\tif (!(license->ErrorInfo = license_new_binary_blob(BB_ERROR_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->KeyExchangeList = license_new_binary_blob(BB_KEY_EXCHG_ALG_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ServerCertificate = license_new_binary_blob(BB_CERTIFICATE_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ClientUserName = license_new_binary_blob(BB_CLIENT_USER_NAME_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ClientMachineName = license_new_binary_blob(BB_CLIENT_MACHINE_NAME_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->PlatformChallenge = license_new_binary_blob(BB_ANY_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedPlatformChallenge = license_new_binary_blob(BB_ANY_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedPlatformChallengeResponse =\n\t          license_new_binary_blob(BB_ENCRYPTED_DATA_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedPremasterSecret = license_new_binary_blob(BB_ANY_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedHardwareId = license_new_binary_blob(BB_ENCRYPTED_DATA_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ScopeList = license_new_scope_list()))\n\t\tgoto out_error;\n\n\tlicense_generate_randoms(license);\n\n\treturn license;\n\nout_error:\n\tlicense_free(license);\n\treturn NULL;\n}\n\n/**\n * Free license module.\n * @param license license module to be freed\n */\n\nvoid license_free(rdpLicense* license)\n{\n\tif (license)\n\t{\n\t\tfree(license->Modulus);\n\t\tcertificate_free(license->certificate);\n\t\tlicense_free_product_info(license->ProductInfo);\n\t\tlicense_free_binary_blob(license->ErrorInfo);\n\t\tlicense_free_binary_blob(license->KeyExchangeList);\n\t\tlicense_free_binary_blob(license->ServerCertificate);\n\t\tlicense_free_binary_blob(license->ClientUserName);\n\t\tlicense_free_binary_blob(license->ClientMachineName);\n\t\tlicense_free_binary_blob(license->PlatformChallenge);\n\t\tlicense_free_binary_blob(license->EncryptedPlatformChallenge);\n\t\tlicense_free_binary_blob(license->EncryptedPlatformChallengeResponse);\n\t\tlicense_free_binary_blob(license->EncryptedPremasterSecret);\n\t\tlicense_free_binary_blob(license->EncryptedHardwareId);\n\t\tlicense_free_scope_list(license->ScopeList);\n\t\tfree(license);\n\t}\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Licensing\n *\n * Copyright 2011-2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 Norbert Federa <norbert.federa@thincast.com>\n * Copyright 2018 David Fort <contact@hardening-consulting.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/crypto.h>\n#include <winpr/shell.h>\n#include <winpr/path.h>\n\n#include <freerdp/log.h>\n\n#include \"redirection.h\"\n#include \"certificate.h\"\n\n#include \"license.h\"\n\n#define TAG FREERDP_TAG(\"core.license\")\n\n#if 0\n#define LICENSE_NULL_CLIENT_RANDOM 1\n#define LICENSE_NULL_PREMASTER_SECRET 1\n#endif\n\nstatic wStream* license_send_stream_init(rdpLicense* license);\n\nstatic void license_generate_randoms(rdpLicense* license);\nstatic BOOL license_generate_keys(rdpLicense* license);\nstatic BOOL license_generate_hwid(rdpLicense* license);\nstatic BOOL license_encrypt_premaster_secret(rdpLicense* license);\n\nstatic LICENSE_PRODUCT_INFO* license_new_product_info(void);\nstatic void license_free_product_info(LICENSE_PRODUCT_INFO* productInfo);\nstatic BOOL license_read_product_info(wStream* s, LICENSE_PRODUCT_INFO* productInfo);\n\nstatic LICENSE_BLOB* license_new_binary_blob(UINT16 type);\nstatic void license_free_binary_blob(LICENSE_BLOB* blob);\nstatic BOOL license_read_binary_blob(wStream* s, LICENSE_BLOB* blob);\nstatic BOOL license_write_binary_blob(wStream* s, const LICENSE_BLOB* blob);\n\nstatic SCOPE_LIST* license_new_scope_list(void);\nstatic void license_free_scope_list(SCOPE_LIST* scopeList);\nstatic BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList);\n\nstatic BOOL license_read_license_request_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_read_platform_challenge_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_read_error_alert_packet(rdpLicense* license, wStream* s);\n\nstatic BOOL license_write_new_license_request_packet(rdpLicense* license, wStream* s);\nstatic BOOL license_answer_license_request(rdpLicense* license);\n\nstatic BOOL license_write_platform_challenge_response_packet(rdpLicense* license, wStream* s,\n                                                             const BYTE* mac_data);\nstatic BOOL license_send_platform_challenge_response_packet(rdpLicense* license);\nstatic BOOL license_send_client_info(rdpLicense* license, const LICENSE_BLOB* calBlob,\n                                     BYTE* signature);\n\n#define PLATFORMID (CLIENT_OS_ID_WINNT_POST_52 | CLIENT_IMAGE_ID_MICROSOFT)\n\n#ifdef WITH_DEBUG_LICENSE\n\nstatic const char* const LICENSE_MESSAGE_STRINGS[] = { \"\",\n\t                                                   \"License Request\",\n\t                                                   \"Platform Challenge\",\n\t                                                   \"New License\",\n\t                                                   \"Upgrade License\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"License Info\",\n\t                                                   \"New License Request\",\n\t                                                   \"\",\n\t                                                   \"Platform Challenge Response\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"\",\n\t                                                   \"Error Alert\" };\n\nstatic const char* const error_codes[] = { \"ERR_UNKNOWN\",\n\t                                       \"ERR_INVALID_SERVER_CERTIFICATE\",\n\t                                       \"ERR_NO_LICENSE\",\n\t                                       \"ERR_INVALID_MAC\",\n\t                                       \"ERR_INVALID_SCOPE\",\n\t                                       \"ERR_UNKNOWN\",\n\t                                       \"ERR_NO_LICENSE_SERVER\",\n\t                                       \"STATUS_VALID_CLIENT\",\n\t                                       \"ERR_INVALID_CLIENT\",\n\t                                       \"ERR_UNKNOWN\",\n\t                                       \"ERR_UNKNOWN\",\n\t                                       \"ERR_INVALID_PRODUCT_ID\",\n\t                                       \"ERR_INVALID_MESSAGE_LENGTH\" };\n\nstatic const char* const state_transitions[] = { \"ST_UNKNOWN\", \"ST_TOTAL_ABORT\", \"ST_NO_TRANSITION\",\n\t                                             \"ST_RESET_PHASE_TO_START\",\n\t                                             \"ST_RESEND_LAST_MESSAGE\" };\n\nstatic void license_print_product_info(const LICENSE_PRODUCT_INFO* productInfo)\n{\n\tchar* CompanyName = NULL;\n\tchar* ProductId = NULL;\n\tConvertFromUnicode(CP_UTF8, 0, (WCHAR*)productInfo->pbCompanyName,\n\t                   productInfo->cbCompanyName / 2, &CompanyName, 0, NULL, NULL);\n\tConvertFromUnicode(CP_UTF8, 0, (WCHAR*)productInfo->pbProductId, productInfo->cbProductId / 2,\n\t                   &ProductId, 0, NULL, NULL);\n\tWLog_INFO(TAG, \"ProductInfo:\");\n\tWLog_INFO(TAG, \"\\tdwVersion: 0x%08\" PRIX32 \"\", productInfo->dwVersion);\n\tWLog_INFO(TAG, \"\\tCompanyName: %s\", CompanyName);\n\tWLog_INFO(TAG, \"\\tProductId: %s\", ProductId);\n\tfree(CompanyName);\n\tfree(ProductId);\n}\n\nstatic void license_print_scope_list(const SCOPE_LIST* scopeList)\n{\n\tUINT32 index;\n\tconst LICENSE_BLOB* scope;\n\tWLog_INFO(TAG, \"ScopeList (%\" PRIu32 \"):\", scopeList->count);\n\n\tfor (index = 0; index < scopeList->count; index++)\n\t{\n\t\tscope = &scopeList->array[index];\n\t\tWLog_INFO(TAG, \"\\t%s\", (const char*)scope->data);\n\t}\n}\n#endif\n\nstatic const char licenseStore[] = \"licenses\";\n\nstatic BOOL computeCalHash(const char* hostname, char* hashStr)\n{\n\tWINPR_DIGEST_CTX* sha1 = NULL;\n\tBOOL ret = FALSE;\n\tBYTE hash[20];\n\tsize_t i;\n\n\tif (!(sha1 = winpr_Digest_New()))\n\t\tgoto out;\n\tif (!winpr_Digest_Init(sha1, WINPR_MD_SHA1))\n\t\tgoto out;\n\tif (!winpr_Digest_Update(sha1, (const BYTE*)hostname, strlen(hostname)))\n\t\tgoto out;\n\tif (!winpr_Digest_Final(sha1, hash, sizeof(hash)))\n\t\tgoto out;\n\n\tfor (i = 0; i < sizeof(hash); i++, hashStr += 2)\n\t\tsprintf_s(hashStr, 3, \"%.2x\", hash[i]);\n\n\tret = TRUE;\nout:\n\twinpr_Digest_Free(sha1);\n\treturn ret;\n}\n\nstatic BOOL saveCal(rdpSettings* settings, const BYTE* data, int length, char* hostname)\n{\n\tchar hash[41];\n\tFILE* fp;\n\tchar* licenseStorePath = NULL;\n\tchar filename[MAX_PATH], filenameNew[MAX_PATH];\n\tchar *filepath = NULL, *filepathNew = NULL;\n\tsize_t written;\n\tBOOL ret = FALSE;\n\n\tif (!PathFileExistsA(settings->ConfigPath))\n\t{\n\t\tif (!PathMakePathA(settings->ConfigPath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error creating directory '%s'\", settings->ConfigPath);\n\t\t\tgoto out;\n\t\t}\n\t\tWLog_INFO(TAG, \"creating directory %s\", settings->ConfigPath);\n\t}\n\n\tif (!(licenseStorePath = GetCombinedPath(settings->ConfigPath, licenseStore)))\n\t\tgoto out;\n\n\tif (!PathFileExistsA(licenseStorePath))\n\t{\n\t\tif (!PathMakePathA(licenseStorePath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error creating directory '%s'\", licenseStorePath);\n\t\t\tgoto out;\n\t\t}\n\t\tWLog_INFO(TAG, \"creating directory %s\", licenseStorePath);\n\t}\n\n\tif (!computeCalHash(hostname, hash))\n\t\tgoto out;\n\tsprintf_s(filename, sizeof(filename) - 1, \"%s.cal\", hash);\n\tsprintf_s(filenameNew, sizeof(filenameNew) - 1, \"%s.cal.new\", hash);\n\n\tif (!(filepath = GetCombinedPath(licenseStorePath, filename)))\n\t\tgoto out;\n\n\tif (!(filepathNew = GetCombinedPath(licenseStorePath, filenameNew)))\n\t\tgoto out;\n\n\tfp = fopen(filepathNew, \"wb\");\n\tif (!fp)\n\t\tgoto out;\n\n\twritten = fwrite(data, length, 1, fp);\n\tfclose(fp);\n\n\tif (written != 1)\n\t{\n\t\tDeleteFile(filepathNew);\n\t\tgoto out;\n\t}\n\n\tret = MoveFileEx(filepathNew, filepath, MOVEFILE_REPLACE_EXISTING);\n\nout:\n\tfree(filepathNew);\n\tfree(filepath);\n\tfree(licenseStorePath);\n\treturn ret;\n}\n\nstatic BYTE* loadCalFile(rdpSettings* settings, const char* hostname, int* dataLen)\n{\n\tchar *licenseStorePath = NULL, *calPath = NULL;\n\tchar calFilename[MAX_PATH];\n\tchar hash[41];\n\tint length, status;\n\tFILE* fp;\n\tBYTE* ret = NULL;\n\n\tif (!computeCalHash(hostname, hash))\n\t{\n\t\tWLog_ERR(TAG, \"loadCalFile: unable to compute hostname hash\");\n\t\treturn NULL;\n\t}\n\n\tsprintf_s(calFilename, sizeof(calFilename) - 1, \"%s.cal\", hash);\n\n\tif (!(licenseStorePath = GetCombinedPath(settings->ConfigPath, licenseStore)))\n\t\treturn NULL;\n\n\tif (!(calPath = GetCombinedPath(licenseStorePath, calFilename)))\n\t\tgoto error_path;\n\n\tfp = fopen(calPath, \"rb\");\n\tif (!fp)\n\t\tgoto error_open;\n\n\t_fseeki64(fp, 0, SEEK_END);\n\tlength = _ftelli64(fp);\n\t_fseeki64(fp, 0, SEEK_SET);\n\n\tret = (BYTE*)malloc(length);\n\tif (!ret)\n\t\tgoto error_malloc;\n\n\tstatus = fread(ret, length, 1, fp);\n\tif (status <= 0)\n\t\tgoto error_read;\n\n\t*dataLen = length;\n\n\tfclose(fp);\n\tfree(calPath);\n\tfree(licenseStorePath);\n\treturn ret;\n\nerror_read:\n\tfree(ret);\nerror_malloc:\n\tfclose(fp);\nerror_open:\n\tfree(calPath);\nerror_path:\n\tfree(licenseStorePath);\n\treturn NULL;\n}\n\n/**\n * Read a licensing preamble.\\n\n * @msdn{cc240480}\n * @param s stream\n * @param bMsgType license message type\n * @param flags message flags\n * @param wMsgSize message size\n * @return if the operation completed successfully\n */\n\nstatic BOOL license_read_preamble(wStream* s, BYTE* bMsgType, BYTE* flags, UINT16* wMsgSize)\n{\n\t/* preamble (4 bytes) */\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, *bMsgType);  /* bMsgType (1 byte) */\n\tStream_Read_UINT8(s, *flags);     /* flags (1 byte) */\n\tStream_Read_UINT16(s, *wMsgSize); /* wMsgSize (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write a licensing preamble.\\n\n * @msdn{cc240480}\n * @param s stream\n * @param bMsgType license message type\n * @param flags message flags\n * @param wMsgSize message size\n */\n\nstatic BOOL license_write_preamble(wStream* s, BYTE bMsgType, BYTE flags, UINT16 wMsgSize)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 4))\n\t\treturn FALSE;\n\n\t/* preamble (4 bytes) */\n\tStream_Write_UINT8(s, bMsgType);  /* bMsgType (1 byte) */\n\tStream_Write_UINT8(s, flags);     /* flags (1 byte) */\n\tStream_Write_UINT16(s, wMsgSize); /* wMsgSize (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Initialize a license packet stream.\\n\n * @param license license module\n * @return stream\n */\n\nwStream* license_send_stream_init(rdpLicense* license)\n{\n\twStream* s;\n\tBOOL do_crypt = license->rdp->do_crypt;\n\n\tlicense->rdp->sec_flags = SEC_LICENSE_PKT;\n\n\t/**\n\t * Encryption of licensing packets is optional even if the rdp security\n\t * layer is used. If the peer has not indicated that it is capable of\n\t * processing encrypted licensing packets (rdp->do_crypt_license) we turn\n\t * off encryption (via rdp->do_crypt) before initializing the rdp stream\n\t * and reenable it afterwards.\n\t */\n\n\tif (do_crypt)\n\t{\n\t\tlicense->rdp->sec_flags |= SEC_LICENSE_ENCRYPT_CS;\n\t\tlicense->rdp->do_crypt = license->rdp->do_crypt_license;\n\t}\n\n\ts = rdp_send_stream_init(license->rdp);\n\tif (!s)\n\t\treturn NULL;\n\n\tlicense->rdp->do_crypt = do_crypt;\n\tlicense->PacketHeaderLength = Stream_GetPosition(s);\n\tif (!Stream_SafeSeek(s, LICENSE_PREAMBLE_LENGTH))\n\t\tgoto fail;\n\treturn s;\n\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\n/**\n * Send an RDP licensing packet.\\n\n * @msdn{cc240479}\n * @param license license module\n * @param s stream\n */\n\nstatic BOOL license_send(rdpLicense* license, wStream* s, BYTE type)\n{\n\tsize_t length;\n\tBYTE flags;\n\tUINT16 wMsgSize;\n\trdpRdp* rdp = license->rdp;\n\tBOOL ret;\n\n\tDEBUG_LICENSE(\"Sending %s Packet\", LICENSE_MESSAGE_STRINGS[type & 0x1F]);\n\tlength = Stream_GetPosition(s);\n\twMsgSize = length - license->PacketHeaderLength;\n\tStream_SetPosition(s, license->PacketHeaderLength);\n\tflags = PREAMBLE_VERSION_3_0;\n\n\t/**\n\t * Using EXTENDED_ERROR_MSG_SUPPORTED here would cause mstsc to crash when\n\t * running in server mode! This flag seems to be incorrectly documented.\n\t */\n\n\tif (!rdp->settings->ServerMode)\n\t\tflags |= EXTENDED_ERROR_MSG_SUPPORTED;\n\n\tif (!license_write_preamble(s, type, flags, wMsgSize))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Sending %s Packet, length %\" PRIu16 \"\", LICENSE_MESSAGE_STRINGS[type & 0x1F],\n\t         wMsgSize);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(s) - LICENSE_PREAMBLE_LENGTH, wMsgSize);\n#endif\n\tStream_SetPosition(s, length);\n\tret = rdp_send(rdp, s, MCS_GLOBAL_CHANNEL_ID);\n\trdp->sec_flags = 0;\n\treturn ret;\n}\n\n/**\n * Receive an RDP licensing packet.\\n\n * @msdn{cc240479}\n * @param license license module\n * @param s stream\n * @return if the operation completed successfully\n */\n\nint license_recv(rdpLicense* license, wStream* s)\n{\n\tBYTE flags;\n\tBYTE bMsgType;\n\tUINT16 wMsgSize;\n\tUINT16 length;\n\tUINT16 channelId;\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(license->rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\treturn -1;\n\n\tif (securityFlags & SEC_ENCRYPT)\n\t{\n\t\tif (!rdp_decrypt(license->rdp, s, &length, securityFlags))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(securityFlags & SEC_LICENSE_PKT))\n\t{\n\t\tint status;\n\n\t\tif (!(securityFlags & SEC_ENCRYPT))\n\t\t\tStream_Rewind(s, RDP_SECURITY_HEADER_LENGTH);\n\n\t\tstatus = rdp_recv_out_of_sequence_pdu(license->rdp, s);\n\t\tif (status < 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"unexpected license packet.\");\n\t\t\treturn status;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!license_read_preamble(s, &bMsgType, &flags, &wMsgSize)) /* preamble (4 bytes) */\n\t\treturn -1;\n\n\tDEBUG_LICENSE(\"Receiving %s Packet\", LICENSE_MESSAGE_STRINGS[bMsgType & 0x1F]);\n\n\tswitch (bMsgType)\n\t{\n\t\tcase LICENSE_REQUEST:\n\t\t\tif (!license_read_license_request_packet(license, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (!license_answer_license_request(license))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase PLATFORM_CHALLENGE:\n\t\t\tif (!license_read_platform_challenge_packet(license, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (!license_send_platform_challenge_response_packet(license))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase NEW_LICENSE:\n\t\tcase UPGRADE_LICENSE:\n\t\t\tif (!license_read_new_or_upgrade_license_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase ERROR_ALERT:\n\t\t\tif (!license_read_error_alert_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"invalid bMsgType:%\" PRIu8 \"\", bMsgType);\n\t\t\treturn -1;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid license_generate_randoms(rdpLicense* license)\n{\n#ifdef LICENSE_NULL_CLIENT_RANDOM\n\tZeroMemory(license->ClientRandom, CLIENT_RANDOM_LENGTH); /* ClientRandom */\n#else\n\twinpr_RAND(license->ClientRandom, CLIENT_RANDOM_LENGTH);       /* ClientRandom */\n#endif\n\n#ifdef LICENSE_NULL_PREMASTER_SECRET\n\tZeroMemory(license->PremasterSecret, PREMASTER_SECRET_LENGTH); /* PremasterSecret */\n#else\n\twinpr_RAND(license->PremasterSecret, PREMASTER_SECRET_LENGTH); /* PremasterSecret */\n#endif\n}\n\n/**\n * Generate License Cryptographic Keys.\n * @param license license module\n */\n\nstatic BOOL license_generate_keys(rdpLicense* license)\n{\n\tBOOL ret;\n\n\tif (\n\t    /* MasterSecret */\n\t    !security_master_secret(license->PremasterSecret, license->ClientRandom,\n\t                            license->ServerRandom, license->MasterSecret) ||\n\t    /* SessionKeyBlob */\n\t    !security_session_key_blob(license->MasterSecret, license->ClientRandom,\n\t                               license->ServerRandom, license->SessionKeyBlob))\n\t{\n\t\treturn FALSE;\n\t}\n\tsecurity_mac_salt_key(license->SessionKeyBlob, license->ClientRandom, license->ServerRandom,\n\t                      license->MacSaltKey); /* MacSaltKey */\n\tret = security_licensing_encryption_key(\n\t    license->SessionKeyBlob, license->ClientRandom, license->ServerRandom,\n\t    license->LicensingEncryptionKey); /* LicensingEncryptionKey */\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"ClientRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ClientRandom, CLIENT_RANDOM_LENGTH);\n\tWLog_DBG(TAG, \"ServerRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ServerRandom, SERVER_RANDOM_LENGTH);\n\tWLog_DBG(TAG, \"PremasterSecret:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->PremasterSecret, PREMASTER_SECRET_LENGTH);\n\tWLog_DBG(TAG, \"MasterSecret:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->MasterSecret, MASTER_SECRET_LENGTH);\n\tWLog_DBG(TAG, \"SessionKeyBlob:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->SessionKeyBlob, SESSION_KEY_BLOB_LENGTH);\n\tWLog_DBG(TAG, \"MacSaltKey:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->MacSaltKey, MAC_SALT_KEY_LENGTH);\n\tWLog_DBG(TAG, \"LicensingEncryptionKey:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->LicensingEncryptionKey,\n\t              LICENSING_ENCRYPTION_KEY_LENGTH);\n#endif\n\treturn ret;\n}\n\n/**\n * Generate Unique Hardware Identifier (CLIENT_HARDWARE_ID).\\n\n * @param license license module\n */\n\nBOOL license_generate_hwid(rdpLicense* license)\n{\n\tconst BYTE* hashTarget;\n\tsize_t targetLen;\n\tBYTE macAddress[6];\n\n\tZeroMemory(license->HardwareId, HWID_LENGTH);\n\n\tif (license->rdp->settings->OldLicenseBehaviour)\n\t{\n\t\tZeroMemory(macAddress, sizeof(macAddress));\n\t\thashTarget = macAddress;\n\t\ttargetLen = sizeof(macAddress);\n\t}\n\telse\n\t{\n\t\twStream s;\n\t\tconst char* hostname = license->rdp->settings->ClientHostname;\n\t\tStream_StaticInit(&s, license->HardwareId, 4);\n\t\tStream_Write_UINT32(&s, PLATFORMID);\n\t\tStream_Free(&s, TRUE);\n\n\t\thashTarget = (const BYTE*)hostname;\n\t\ttargetLen = strlen(hostname);\n\t}\n\n\t/* Allow FIPS override for use of MD5 here, really this does not have to be MD5 as we are just\n\t * taking a MD5 hash of the 6 bytes of 0's(macAddress) */\n\t/* and filling in the Data1-Data4 fields of the CLIENT_HARDWARE_ID structure(from MS-RDPELE\n\t * section 2.2.2.3.1). This is for RDP licensing packets */\n\t/* which will already be encrypted under FIPS, so the use of MD5 here is not for sensitive data\n\t * protection. */\n\treturn winpr_Digest_Allow_FIPS(WINPR_MD_MD5, hashTarget, targetLen,\n\t                               &license->HardwareId[HWID_PLATFORM_ID_LENGTH],\n\t                               WINPR_MD5_DIGEST_LENGTH);\n}\n\nstatic BOOL license_get_server_rsa_public_key(rdpLicense* license)\n{\n\tBYTE* Exponent;\n\tBYTE* Modulus;\n\tint ModulusLength;\n\trdpSettings* settings = license->rdp->settings;\n\n\tif (license->ServerCertificate->length < 1)\n\t{\n\t\tif (!certificate_read_server_certificate(license->certificate, settings->ServerCertificate,\n\t\t                                         settings->ServerCertificateLength))\n\t\t\treturn FALSE;\n\t}\n\n\tExponent = license->certificate->cert_info.exponent;\n\tModulus = license->certificate->cert_info.Modulus;\n\tModulusLength = license->certificate->cert_info.ModulusLength;\n\tCopyMemory(license->Exponent, Exponent, 4);\n\tlicense->ModulusLength = ModulusLength;\n\tlicense->Modulus = (BYTE*)malloc(ModulusLength);\n\tif (!license->Modulus)\n\t\treturn FALSE;\n\tCopyMemory(license->Modulus, Modulus, ModulusLength);\n\treturn TRUE;\n}\n\nBOOL license_encrypt_premaster_secret(rdpLicense* license)\n{\n\tBYTE* EncryptedPremasterSecret;\n\n\tif (!license_get_server_rsa_public_key(license))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Modulus (%\" PRIu32 \" bits):\", license->ModulusLength * 8);\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->Modulus, license->ModulusLength);\n\tWLog_DBG(TAG, \"Exponent:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->Exponent, 4);\n#endif\n\n\tEncryptedPremasterSecret = (BYTE*)calloc(1, license->ModulusLength);\n\tif (!EncryptedPremasterSecret)\n\t\treturn FALSE;\n\n\tlicense->EncryptedPremasterSecret->type = BB_RANDOM_BLOB;\n\tlicense->EncryptedPremasterSecret->length = PREMASTER_SECRET_LENGTH;\n#ifndef LICENSE_NULL_PREMASTER_SECRET\n\tlicense->EncryptedPremasterSecret->length = crypto_rsa_public_encrypt(\n\t    license->PremasterSecret, PREMASTER_SECRET_LENGTH, license->ModulusLength, license->Modulus,\n\t    license->Exponent, EncryptedPremasterSecret);\n#endif\n\tlicense->EncryptedPremasterSecret->data = EncryptedPremasterSecret;\n\treturn TRUE;\n}\n\nstatic BOOL license_rc4_with_licenseKey(const rdpLicense* license, const BYTE* input, size_t len,\n                                        LICENSE_BLOB* target)\n{\n\tWINPR_RC4_CTX* rc4;\n\tBYTE* buffer = NULL;\n\n\trc4 =\n\t    winpr_RC4_New_Allow_FIPS(license->LicensingEncryptionKey, LICENSING_ENCRYPTION_KEY_LENGTH);\n\tif (!rc4)\n\t\treturn FALSE;\n\n\tbuffer = (BYTE*)realloc(target->data, len);\n\tif (!buffer)\n\t\tgoto error_buffer;\n\n\ttarget->data = buffer;\n\ttarget->length = len;\n\n\tif (!winpr_RC4_Update(rc4, len, input, buffer))\n\t\tgoto error_buffer;\n\n\twinpr_RC4_Free(rc4);\n\treturn TRUE;\n\nerror_buffer:\n\twinpr_RC4_Free(rc4);\n\treturn FALSE;\n}\n\n/**\n * Encrypt the input using the license key and MAC the input for a signature\n *\n * @param license rdpLicense to get keys and salt from\n * @param input the input data to encrypt and MAC\n * @param len size of input\n * @param target a target LICENSE_BLOB where the encrypted input will be stored\n * @param mac the signature buffer (16 bytes)\n * @return if the operation completed successfully\n */\nstatic BOOL license_encrypt_and_MAC(rdpLicense* license, const BYTE* input, size_t len,\n                                    LICENSE_BLOB* target, BYTE* mac)\n{\n\treturn license_rc4_with_licenseKey(license, input, len, target) &&\n\t       security_mac_data(license->MacSaltKey, input, len, mac);\n}\n\n/**\n * Decrypt the input using the license key and check the MAC\n *\n * @param license rdpLicense to get keys and salt from\n * @param input the input data to decrypt and MAC\n * @param len size of input\n * @param target a target LICENSE_BLOB where the decrypted input will be stored\n * @param mac the signature buffer (16 bytes)\n * @return if the operation completed successfully\n */\nstatic BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,\n                                          LICENSE_BLOB* target, const BYTE* packetMac)\n{\n\tBYTE macData[16];\n\n\treturn license_rc4_with_licenseKey(license, input, len, target) &&\n\t       security_mac_data(license->MacSaltKey, target->data, len, macData) &&\n\t       (memcmp(packetMac, macData, sizeof(macData)) == 0);\n}\n\n/**\n * Read Product Information (PRODUCT_INFO).\\n\n * @msdn{cc241915}\n * @param s stream\n * @param productInfo product information\n */\n\nBOOL license_read_product_info(wStream* s, LICENSE_PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, productInfo->dwVersion);     /* dwVersion (4 bytes) */\n\tStream_Read_UINT32(s, productInfo->cbCompanyName); /* cbCompanyName (4 bytes) */\n\n\t/* Name must be >0, but there is no upper limit defined, use UINT32_MAX */\n\tif ((productInfo->cbCompanyName < 2) || (productInfo->cbCompanyName % 2 != 0))\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName)\n\t\treturn FALSE;\n\n\tproductInfo->pbProductId = NULL;\n\tproductInfo->pbCompanyName = (BYTE*)malloc(productInfo->cbCompanyName);\n\tif (!productInfo->pbCompanyName)\n\t\treturn FALSE;\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto out_fail;\n\n\tStream_Read_UINT32(s, productInfo->cbProductId); /* cbProductId (4 bytes) */\n\n\tif ((productInfo->cbProductId < 2) || (productInfo->cbProductId % 2 != 0))\n\t\tgoto out_fail;\n\n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t\tgoto out_fail;\n\n\tproductInfo->pbProductId = (BYTE*)malloc(productInfo->cbProductId);\n\tif (!productInfo->pbProductId)\n\t\tgoto out_fail;\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n\nout_fail:\n\tfree(productInfo->pbCompanyName);\n\tfree(productInfo->pbProductId);\n\tproductInfo->pbCompanyName = NULL;\n\tproductInfo->pbProductId = NULL;\n\treturn FALSE;\n}\n\n/**\n * Allocate New Product Information (LICENSE_PRODUCT_INFO).\\n\n * @msdn{cc241915}\n * @return new product information\n */\n\nLICENSE_PRODUCT_INFO* license_new_product_info()\n{\n\tLICENSE_PRODUCT_INFO* productInfo;\n\tproductInfo = (LICENSE_PRODUCT_INFO*)malloc(sizeof(LICENSE_PRODUCT_INFO));\n\tif (!productInfo)\n\t\treturn NULL;\n\tproductInfo->dwVersion = 0;\n\tproductInfo->cbCompanyName = 0;\n\tproductInfo->pbCompanyName = NULL;\n\tproductInfo->cbProductId = 0;\n\tproductInfo->pbProductId = NULL;\n\treturn productInfo;\n}\n\n/**\n * Free Product Information (LICENSE_PRODUCT_INFO).\\n\n * @msdn{cc241915}\n * @param productInfo product information\n */\n\nvoid license_free_product_info(LICENSE_PRODUCT_INFO* productInfo)\n{\n\tif (productInfo)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tfree(productInfo->pbProductId);\n\t\tfree(productInfo);\n\t}\n}\n\n/**\n * Read License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @param s stream\n * @param blob license binary blob\n */\n\nBOOL license_read_binary_blob(wStream* s, LICENSE_BLOB* blob)\n{\n\tUINT16 wBlobType;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, wBlobType);    /* wBlobType (2 bytes) */\n\tStream_Read_UINT16(s, blob->length); /* wBlobLen (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < blob->length)\n\t\treturn FALSE;\n\n\t/*\n\t * Server can choose to not send data by setting length to 0.\n\t * If so, it may not bother to set the type, so shortcut the warning\n\t */\n\tif ((blob->type != BB_ANY_BLOB) && (blob->length == 0))\n\t\treturn TRUE;\n\n\tif ((blob->type != wBlobType) && (blob->type != BB_ANY_BLOB))\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"license binary blob type (0x%\" PRIx16 \") does not match expected type (0x%\" PRIx16\n\t\t         \").\",\n\t\t         wBlobType, blob->type);\n\t}\n\n\tblob->type = wBlobType;\n\tblob->data = (BYTE*)malloc(blob->length);\n\tif (!blob->data)\n\t\treturn FALSE;\n\tStream_Read(s, blob->data, blob->length); /* blobData */\n\treturn TRUE;\n}\n\n/**\n * Write License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @param s stream\n * @param blob license binary blob\n */\n\nBOOL license_write_binary_blob(wStream* s, const LICENSE_BLOB* blob)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, blob->length + 4))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, blob->type);   /* wBlobType (2 bytes) */\n\tStream_Write_UINT16(s, blob->length); /* wBlobLen (2 bytes) */\n\n\tif (blob->length > 0)\n\t\tStream_Write(s, blob->data, blob->length); /* blobData */\n\treturn TRUE;\n}\n\nstatic BOOL license_write_encrypted_premaster_secret_blob(wStream* s, const LICENSE_BLOB* blob,\n                                                          UINT32 ModulusLength)\n{\n\tUINT32 length;\n\tlength = ModulusLength + 8;\n\n\tif (blob->length > ModulusLength)\n\t{\n\t\tWLog_ERR(TAG, \"license_write_encrypted_premaster_secret_blob: invalid blob\");\n\t\treturn FALSE;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(s, length + 4))\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, blob->type); /* wBlobType (2 bytes) */\n\tStream_Write_UINT16(s, length);     /* wBlobLen (2 bytes) */\n\n\tif (blob->length > 0)\n\t\tStream_Write(s, blob->data, blob->length); /* blobData */\n\n\tStream_Zero(s, length - blob->length);\n\treturn TRUE;\n}\n\n/**\n * Allocate New License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @return new license binary blob\n */\n\nLICENSE_BLOB* license_new_binary_blob(UINT16 type)\n{\n\tLICENSE_BLOB* blob;\n\tblob = (LICENSE_BLOB*)calloc(1, sizeof(LICENSE_BLOB));\n\tif (blob)\n\t\tblob->type = type;\n\treturn blob;\n}\n\n/**\n * Free License Binary Blob (LICENSE_BINARY_BLOB).\\n\n * @msdn{cc240481}\n * @param blob license binary blob\n */\n\nvoid license_free_binary_blob(LICENSE_BLOB* blob)\n{\n\tif (blob)\n\t{\n\t\tfree(blob->data);\n\t\tfree(blob);\n\t}\n}\n\n/**\n * Read License Scope List (SCOPE_LIST).\\n\n * @msdn{cc241916}\n * @param s stream\n * @param scopeList scope list\n */\n\nBOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n\n\tif (scopeCount > Stream_GetRemainingLength(s) / 4) /* every blob is at least 4 bytes */\n\t\treturn FALSE;\n\n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*)calloc(scopeCount, sizeof(LICENSE_BLOB));\n\tif (!scopeList->array)\n\t\treturn FALSE;\n\n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Allocate New License Scope List (SCOPE_LIST).\\n\n * @msdn{cc241916}\n * @return new scope list\n */\n\nSCOPE_LIST* license_new_scope_list()\n{\n\treturn (SCOPE_LIST*)calloc(1, sizeof(SCOPE_LIST));\n}\n\n/**\n * Free License Scope List (SCOPE_LIST).\\n\n * @msdn{cc241916}\n * @param scopeList scope list\n */\n\nvoid license_free_scope_list(SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\n\tif (!scopeList)\n\t\treturn;\n\n\t/*\n\t * We must NOT call license_free_binary_blob() on each scopelist->array[i] element,\n\t * because scopelist->array was allocated at once, by a single call to malloc. The elements\n\t * it contains cannot be deallocated separately then.\n\t * To make things clean, we must deallocate each scopelist->array[].data,\n\t * and finish by deallocating scopelist->array with a single call to free().\n\t */\n\tfor (i = 0; i < scopeList->count; i++)\n\t{\n\t\tfree(scopeList->array[i].data);\n\t}\n\n\tfree(scopeList->array);\n\tfree(scopeList);\n}\n\nBOOL license_send_client_info(rdpLicense* license, const LICENSE_BLOB* calBlob, BYTE* signature)\n{\n\twStream* s;\n\n\t/* Client License Information: */\n\tUINT32 PlatformId = PLATFORMID;\n\tUINT32 PreferredKeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;\n\n\ts = license_send_stream_init(license);\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, PreferredKeyExchangeAlg); /* PreferredKeyExchangeAlg (4 bytes) */\n\tStream_Write_UINT32(s, PlatformId);              /* PlatformId (4 bytes) */\n\n\t/* ClientRandom (32 bytes) */\n\tStream_Write(s, license->ClientRandom, CLIENT_RANDOM_LENGTH);\n\n\t/* Licensing Binary Blob with EncryptedPreMasterSecret: */\n\tif (!license_write_encrypted_premaster_secret_blob(s, license->EncryptedPremasterSecret,\n\t                                                   license->ModulusLength))\n\t\tgoto error;\n\n\t/* Licensing Binary Blob with LicenseInfo: */\n\tif (!license_write_binary_blob(s, calBlob))\n\t\tgoto error;\n\n\t/* Licensing Binary Blob with EncryptedHWID */\n\tif (!license_write_binary_blob(s, license->EncryptedHardwareId))\n\t\tgoto error;\n\n\t/* MACData */\n\tStream_Write(s, signature, LICENSING_ENCRYPTION_KEY_LENGTH);\n\n\treturn license_send(license, s, LICENSE_INFO);\n\nerror:\n\tStream_Release(s);\n\treturn FALSE;\n}\n\n/**\n * Read a LICENSE_REQUEST packet.\\n\n * @msdn{cc241914}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_license_request_packet(rdpLicense* license, wStream* s)\n{\n\t/* ServerRandom (32 bytes) */\n\tif (Stream_GetRemainingLength(s) < 32)\n\t\treturn FALSE;\n\n\tStream_Read(s, license->ServerRandom, 32);\n\n\t/* ProductInfo */\n\tif (!license_read_product_info(s, license->ProductInfo))\n\t\treturn FALSE;\n\n\t/* KeyExchangeList */\n\tif (!license_read_binary_blob(s, license->KeyExchangeList))\n\t\treturn FALSE;\n\n\t/* ServerCertificate */\n\tif (!license_read_binary_blob(s, license->ServerCertificate))\n\t\treturn FALSE;\n\n\t/* ScopeList */\n\tif (!license_read_scope_list(s, license->ScopeList))\n\t\treturn FALSE;\n\n\t/* Parse Server Certificate */\n\tif (!certificate_read_server_certificate(license->certificate, license->ServerCertificate->data,\n\t                                         license->ServerCertificate->length))\n\t\treturn FALSE;\n\n\tif (!license_generate_keys(license) || !license_generate_hwid(license) ||\n\t    !license_encrypt_premaster_secret(license))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"ServerRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ServerRandom, 32);\n\tlicense_print_product_info(license->ProductInfo);\n\tlicense_print_scope_list(license->ScopeList);\n#endif\n\treturn TRUE;\n}\n\n/*\n * Read a PLATFORM_CHALLENGE packet.\\n\n * @msdn{cc241921}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_platform_challenge_packet(rdpLicense* license, wStream* s)\n{\n\tBYTE macData[16];\n\tUINT32 ConnectFlags = 0;\n\n\tDEBUG_LICENSE(\"Receiving Platform Challenge Packet\");\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, ConnectFlags); /* ConnectFlags, Reserved (4 bytes) */\n\n\t/* EncryptedPlatformChallenge */\n\tlicense->EncryptedPlatformChallenge->type = BB_ANY_BLOB;\n\tif (!license_read_binary_blob(s, license->EncryptedPlatformChallenge))\n\t\treturn FALSE;\n\tlicense->EncryptedPlatformChallenge->type = BB_ENCRYPTED_DATA_BLOB;\n\n\t/* MACData (16 bytes) */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn FALSE;\n\n\tStream_Read(s, macData, 16);\n\tif (!license_decrypt_and_check_MAC(license, license->EncryptedPlatformChallenge->data,\n\t                                   license->EncryptedPlatformChallenge->length,\n\t                                   license->PlatformChallenge, macData))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"ConnectFlags: 0x%08\" PRIX32 \"\", ConnectFlags);\n\tWLog_DBG(TAG, \"EncryptedPlatformChallenge:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->EncryptedPlatformChallenge->data,\n\t              license->EncryptedPlatformChallenge->length);\n\tWLog_DBG(TAG, \"PlatformChallenge:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->PlatformChallenge->data,\n\t              license->PlatformChallenge->length);\n\tWLog_DBG(TAG, \"MacData:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, macData, 16);\n#endif\n\treturn TRUE;\n}\n\nstatic BOOL license_read_encrypted_blob(const rdpLicense* license, wStream* s, LICENSE_BLOB* target)\n{\n\tUINT16 wBlobType, wBlobLen;\n\tBYTE* encryptedData;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, wBlobType);\n\tif (wBlobType != BB_ENCRYPTED_DATA_BLOB)\n\t{\n\t\tWLog_DBG(\n\t\t    TAG,\n\t\t    \"expecting BB_ENCRYPTED_DATA_BLOB blob, probably a windows 2003 server, continuing...\");\n\t}\n\n\tStream_Read_UINT16(s, wBlobLen);\n\n\tif (Stream_GetRemainingLength(s) < wBlobLen)\n\t\treturn FALSE;\n\n\tencryptedData = Stream_Pointer(s);\n\tStream_Seek(s, wBlobLen);\n\treturn license_rc4_with_licenseKey(license, encryptedData, wBlobLen, target);\n}\n\n/**\n * Read a NEW_LICENSE packet.\\n\n * @msdn{cc241926}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 os_major;\n\tUINT32 os_minor;\n\tUINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;\n\twStream* licenseStream = NULL;\n\tBOOL ret = FALSE;\n\tBYTE computedMac[16];\n\tLICENSE_BLOB* calBlob;\n\n\tDEBUG_LICENSE(\"Receiving Server New/Upgrade License Packet\");\n\n\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\tif (!calBlob)\n\t\treturn FALSE;\n\n\t/* EncryptedLicenseInfo */\n\tif (!license_read_encrypted_blob(license, s, calBlob))\n\t\tgoto out_free_blob;\n\n\t/* compute MAC and check it */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\tgoto out_free_blob;\n\n\tif (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))\n\t\tgoto out_free_blob;\n\n\tif (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"new or upgrade license MAC mismatch\");\n\t\tgoto out_free_blob;\n\t}\n\n\tif (!Stream_SafeSeek(s, 16))\n\t\tgoto out_free_blob;\n\n\tlicenseStream = Stream_New(calBlob->data, calBlob->length);\n\tif (!licenseStream)\n\t\tgoto out_free_blob;\n\n\tif (Stream_GetRemainingLength(licenseStream) < 8)\n\t\tgoto out_free_stream;\n\n\tStream_Read_UINT16(licenseStream, os_minor);\n\tStream_Read_UINT16(licenseStream, os_major);\n\n\t/* Scope */\n\tStream_Read_UINT32(licenseStream, cbScope);\n\tif (Stream_GetRemainingLength(licenseStream) < cbScope)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Scope:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);\n#endif\n\tStream_Seek(licenseStream, cbScope);\n\n\t/* CompanyName */\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n\tStream_Read_UINT32(licenseStream, cbCompanyName);\n\tif (Stream_GetRemainingLength(licenseStream) < cbCompanyName)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Company name:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);\n#endif\n\tStream_Seek(licenseStream, cbCompanyName);\n\n\t/* productId */\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n\tStream_Read_UINT32(licenseStream, cbProductId);\n\tif (Stream_GetRemainingLength(licenseStream) < cbProductId)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Product id:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);\n#endif\n\tStream_Seek(licenseStream, cbProductId);\n\n\t/* licenseInfo */\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n\tStream_Read_UINT32(licenseStream, cbLicenseInfo);\n\tif (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)\n\t\tgoto out_free_stream;\n\n\tlicense->state = LICENSE_STATE_COMPLETED;\n\n\tret = TRUE;\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,\n\t\t              license->rdp->settings->ClientHostname);\n\nout_free_stream:\n\tStream_Free(licenseStream, FALSE);\nout_free_blob:\n\tlicense_free_binary_blob(calBlob);\n\treturn ret;\n}\n\n/**\n * Read an ERROR_ALERT packet.\\n\n * @msdn{cc240482}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_read_error_alert_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 dwErrorCode;\n\tUINT32 dwStateTransition;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, dwErrorCode);       /* dwErrorCode (4 bytes) */\n\tStream_Read_UINT32(s, dwStateTransition); /* dwStateTransition (4 bytes) */\n\n\tif (!license_read_binary_blob(s, license->ErrorInfo)) /* bbErrorInfo */\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"dwErrorCode: %s, dwStateTransition: %s\", error_codes[dwErrorCode],\n\t         state_transitions[dwStateTransition]);\n#endif\n\n\tif (dwErrorCode == STATUS_VALID_CLIENT)\n\t{\n\t\tlicense->state = LICENSE_STATE_COMPLETED;\n\t\treturn TRUE;\n\t}\n\n\tswitch (dwStateTransition)\n\t{\n\t\tcase ST_TOTAL_ABORT:\n\t\t\tlicense->state = LICENSE_STATE_ABORTED;\n\t\t\tbreak;\n\t\tcase ST_NO_TRANSITION:\n\t\t\tlicense->state = LICENSE_STATE_COMPLETED;\n\t\t\tbreak;\n\t\tcase ST_RESET_PHASE_TO_START:\n\t\t\tlicense->state = LICENSE_STATE_AWAIT;\n\t\t\tbreak;\n\t\tcase ST_RESEND_LAST_MESSAGE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a NEW_LICENSE_REQUEST packet.\\n\n * @msdn{cc241918}\n * @param license license module\n * @param s stream\n */\n\nBOOL license_write_new_license_request_packet(rdpLicense* license, wStream* s)\n{\n\tUINT32 PlatformId = PLATFORMID;\n\tUINT32 PreferredKeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;\n\n\tStream_Write_UINT32(s, PreferredKeyExchangeAlg); /* PreferredKeyExchangeAlg (4 bytes) */\n\tStream_Write_UINT32(s, PlatformId);              /* PlatformId (4 bytes) */\n\tStream_Write(s, license->ClientRandom, 32);      /* ClientRandom (32 bytes) */\n\n\tif (/* EncryptedPremasterSecret */\n\t    !license_write_encrypted_premaster_secret_blob(s, license->EncryptedPremasterSecret,\n\t                                                   license->ModulusLength) ||\n\t    /* ClientUserName */\n\t    !license_write_binary_blob(s, license->ClientUserName) ||\n\t    /* ClientMachineName */\n\t    !license_write_binary_blob(s, license->ClientMachineName))\n\t{\n\t\treturn FALSE;\n\t}\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"PreferredKeyExchangeAlg: 0x%08\" PRIX32 \"\", PreferredKeyExchangeAlg);\n\tWLog_DBG(TAG, \"ClientRandom:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->ClientRandom, 32);\n\tWLog_DBG(TAG, \"EncryptedPremasterSecret\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->EncryptedPremasterSecret->data,\n\t              license->EncryptedPremasterSecret->length);\n\tWLog_DBG(TAG, \"ClientUserName (%\" PRIu16 \"): %s\", license->ClientUserName->length,\n\t         (char*)license->ClientUserName->data);\n\tWLog_DBG(TAG, \"ClientMachineName (%\" PRIu16 \"): %s\", license->ClientMachineName->length,\n\t         (char*)license->ClientMachineName->data);\n#endif\n\treturn TRUE;\n}\n\n/**\n * Send a NEW_LICENSE_REQUEST packet.\\n\n * @msdn{cc241918}\n * @param license license module\n */\n\nBOOL license_answer_license_request(rdpLicense* license)\n{\n\twStream* s;\n\tBYTE* license_data = NULL;\n\tint license_size = 0;\n\tBOOL status;\n\tchar* username;\n\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tlicense_data = loadCalFile(license->rdp->settings, license->rdp->settings->ClientHostname,\n\t\t                           &license_size);\n\n\tif (license_data)\n\t{\n\t\tLICENSE_BLOB* calBlob = NULL;\n\t\tBYTE signature[LICENSING_ENCRYPTION_KEY_LENGTH];\n\n\t\tDEBUG_LICENSE(\"Sending Saved License Packet\");\n\n\t\tlicense->EncryptedHardwareId->type = BB_ENCRYPTED_DATA_BLOB;\n\t\tif (!license_encrypt_and_MAC(license, license->HardwareId, HWID_LENGTH,\n\t\t                             license->EncryptedHardwareId, signature))\n\t\t{\n\t\t\tfree(license_data);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\t\tif (!calBlob)\n\t\t{\n\t\t\tfree(license_data);\n\t\t\treturn FALSE;\n\t\t}\n\t\tcalBlob->data = license_data;\n\t\tcalBlob->length = license_size;\n\n\t\tstatus = license_send_client_info(license, calBlob, signature);\n\t\tlicense_free_binary_blob(calBlob);\n\n\t\treturn status;\n\t}\n\n\tDEBUG_LICENSE(\"Sending New License Packet\");\n\n\ts = license_send_stream_init(license);\n\tif (!s)\n\t\treturn FALSE;\n\tif (license->rdp->settings->Username != NULL)\n\t\tusername = license->rdp->settings->Username;\n\telse\n\t\tusername = \"username\";\n\n\tlicense->ClientUserName->data = (BYTE*)username;\n\tlicense->ClientUserName->length = strlen(username) + 1;\n\tlicense->ClientMachineName->data = (BYTE*)license->rdp->settings->ClientHostname;\n\tlicense->ClientMachineName->length = strlen(license->rdp->settings->ClientHostname) + 1;\n\n\tstatus = license_write_new_license_request_packet(license, s);\n\n\tlicense->ClientUserName->data = NULL;\n\tlicense->ClientUserName->length = 0;\n\tlicense->ClientMachineName->data = NULL;\n\tlicense->ClientMachineName->length = 0;\n\n\tif (!status)\n\t{\n\t\tStream_Release(s);\n\t\treturn FALSE;\n\t}\n\n\treturn license_send(license, s, NEW_LICENSE_REQUEST);\n}\n\n/**\n * Write Client Challenge Response Packet.\\n\n * @msdn{cc241922}\n * @param license license module\n * @param s stream\n * @param mac_data signature\n */\n\nBOOL license_write_platform_challenge_response_packet(rdpLicense* license, wStream* s,\n                                                      const BYTE* macData)\n{\n\tif (!license_write_binary_blob(\n\t        s,\n\t        license->EncryptedPlatformChallengeResponse) || /* EncryptedPlatformChallengeResponse */\n\t    !license_write_binary_blob(s, license->EncryptedHardwareId) || /* EncryptedHWID */\n\t    !Stream_EnsureRemainingCapacity(s, 16))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tStream_Write(s, macData, 16); /* MACData */\n\treturn TRUE;\n}\n\n/**\n * Send Client Challenge Response Packet.\\n\n * @msdn{cc241922}\n * @param license license module\n */\n\nBOOL license_send_platform_challenge_response_packet(rdpLicense* license)\n{\n\twStream* s;\n\twStream* challengeRespData;\n\tint length;\n\tBYTE* buffer;\n\tBYTE mac_data[16];\n\tBOOL status;\n\n\tDEBUG_LICENSE(\"Sending Platform Challenge Response Packet\");\n\ts = license_send_stream_init(license);\n\tlicense->EncryptedPlatformChallenge->type = BB_DATA_BLOB;\n\n\t/* prepare the PLATFORM_CHALLENGE_RESPONSE_DATA */\n\tchallengeRespData = Stream_New(NULL, 8 + license->PlatformChallenge->length);\n\tif (!challengeRespData)\n\t\treturn FALSE;\n\tStream_Write_UINT16(challengeRespData, 0x0100);                        /* wVersion */\n\tStream_Write_UINT16(challengeRespData, OTHER_PLATFORM_CHALLENGE_TYPE); /* wClientType */\n\tStream_Write_UINT16(challengeRespData, LICENSE_DETAIL_DETAIL);         /* wLicenseDetailLevel */\n\tStream_Write_UINT16(challengeRespData, license->PlatformChallenge->length); /* cbChallenge */\n\tStream_Write(challengeRespData, license->PlatformChallenge->data,\n\t             license->PlatformChallenge->length); /* pbChallenge */\n\tStream_SealLength(challengeRespData);\n\n\t/* compute MAC of PLATFORM_CHALLENGE_RESPONSE_DATA + HWID */\n\tlength = Stream_Length(challengeRespData) + HWID_LENGTH;\n\tbuffer = (BYTE*)malloc(length);\n\tif (!buffer)\n\t{\n\t\tStream_Free(challengeRespData, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tCopyMemory(buffer, Stream_Buffer(challengeRespData), Stream_Length(challengeRespData));\n\tCopyMemory(&buffer[Stream_Length(challengeRespData)], license->HardwareId, HWID_LENGTH);\n\tstatus = security_mac_data(license->MacSaltKey, buffer, length, mac_data);\n\tfree(buffer);\n\n\tif (!status)\n\t{\n\t\tStream_Free(challengeRespData, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tlicense->EncryptedHardwareId->type = BB_ENCRYPTED_DATA_BLOB;\n\tif (!license_rc4_with_licenseKey(license, license->HardwareId, HWID_LENGTH,\n\t                                 license->EncryptedHardwareId))\n\t{\n\t\tStream_Free(challengeRespData, TRUE);\n\t\treturn FALSE;\n\t}\n\n\tstatus = license_rc4_with_licenseKey(license, Stream_Buffer(challengeRespData),\n\t                                     Stream_Length(challengeRespData),\n\t                                     license->EncryptedPlatformChallengeResponse);\n\tStream_Free(challengeRespData, TRUE);\n\tif (!status)\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"LicensingEncryptionKey:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->LicensingEncryptionKey, 16);\n\tWLog_DBG(TAG, \"HardwareId:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->HardwareId, HWID_LENGTH);\n\tWLog_DBG(TAG, \"EncryptedHardwareId:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, license->EncryptedHardwareId->data, HWID_LENGTH);\n#endif\n\tif (license_write_platform_challenge_response_packet(license, s, mac_data))\n\t\treturn license_send(license, s, PLATFORM_CHALLENGE_RESPONSE);\n\n\tStream_Release(s);\n\treturn FALSE;\n}\n\n/**\n * Send Server License Error - Valid Client Packet.\\n\n * @msdn{cc241922}\n * @param license license module\n */\n\nBOOL license_send_valid_client_error_packet(rdpRdp* rdp)\n{\n\trdpLicense* license = rdp->license;\n\twStream* s = license_send_stream_init(license);\n\tif (!s)\n\t\treturn FALSE;\n\n\tDEBUG_LICENSE(\"Sending Error Alert Packet\");\n\tStream_Write_UINT32(s, STATUS_VALID_CLIENT); /* dwErrorCode */\n\tStream_Write_UINT32(s, ST_NO_TRANSITION);    /* dwStateTransition */\n\n\tif (license_write_binary_blob(s, license->ErrorInfo))\n\t\treturn license_send(license, s, ERROR_ALERT);\n\n\tStream_Release(s);\n\treturn FALSE;\n}\n\n/**\n * Instantiate new license module.\n * @param rdp RDP module\n * @return new license module\n */\n\nrdpLicense* license_new(rdpRdp* rdp)\n{\n\trdpLicense* license;\n\tlicense = (rdpLicense*)calloc(1, sizeof(rdpLicense));\n\tif (!license)\n\t\treturn NULL;\n\n\tlicense->rdp = rdp;\n\tlicense->state = LICENSE_STATE_AWAIT;\n\tif (!(license->certificate = certificate_new()))\n\t\tgoto out_error;\n\tif (!(license->ProductInfo = license_new_product_info()))\n\t\tgoto out_error;\n\tif (!(license->ErrorInfo = license_new_binary_blob(BB_ERROR_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->KeyExchangeList = license_new_binary_blob(BB_KEY_EXCHG_ALG_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ServerCertificate = license_new_binary_blob(BB_CERTIFICATE_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ClientUserName = license_new_binary_blob(BB_CLIENT_USER_NAME_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ClientMachineName = license_new_binary_blob(BB_CLIENT_MACHINE_NAME_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->PlatformChallenge = license_new_binary_blob(BB_ANY_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedPlatformChallenge = license_new_binary_blob(BB_ANY_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedPlatformChallengeResponse =\n\t          license_new_binary_blob(BB_ENCRYPTED_DATA_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedPremasterSecret = license_new_binary_blob(BB_ANY_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->EncryptedHardwareId = license_new_binary_blob(BB_ENCRYPTED_DATA_BLOB)))\n\t\tgoto out_error;\n\tif (!(license->ScopeList = license_new_scope_list()))\n\t\tgoto out_error;\n\n\tlicense_generate_randoms(license);\n\n\treturn license;\n\nout_error:\n\tlicense_free(license);\n\treturn NULL;\n}\n\n/**\n * Free license module.\n * @param license license module to be freed\n */\n\nvoid license_free(rdpLicense* license)\n{\n\tif (license)\n\t{\n\t\tfree(license->Modulus);\n\t\tcertificate_free(license->certificate);\n\t\tlicense_free_product_info(license->ProductInfo);\n\t\tlicense_free_binary_blob(license->ErrorInfo);\n\t\tlicense_free_binary_blob(license->KeyExchangeList);\n\t\tlicense_free_binary_blob(license->ServerCertificate);\n\t\tlicense_free_binary_blob(license->ClientUserName);\n\t\tlicense_free_binary_blob(license->ClientMachineName);\n\t\tlicense_free_binary_blob(license->PlatformChallenge);\n\t\tlicense_free_binary_blob(license->EncryptedPlatformChallenge);\n\t\tlicense_free_binary_blob(license->EncryptedPlatformChallengeResponse);\n\t\tlicense_free_binary_blob(license->EncryptedPremasterSecret);\n\t\tlicense_free_binary_blob(license->EncryptedHardwareId);\n\t\tlicense_free_scope_list(license->ScopeList);\n\t\tfree(license);\n\t}\n}\n"], "filenames": ["libfreerdp/core/license.c"], "buggy_code_start_loc": [1254], "buggy_code_end_loc": [1288], "fixing_code_start_loc": [1255], "fixing_code_end_loc": [1298], "type": "CWE-125", "message": "In FreeRDP before version 2.1.2, there is an out of bounds read in license_read_new_or_upgrade_license_packet. A manipulated license packet can lead to out of bound reads to an internal buffer. This is fixed in version 2.1.2.", "other": {"cve": {"id": "CVE-2020-11099", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T22:15:12.273", "lastModified": "2022-09-02T15:45:25.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before version 2.1.2, there is an out of bounds read in license_read_new_or_upgrade_license_packet. A manipulated license packet can lead to out of bound reads to an internal buffer. This is fixed in version 2.1.2."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.2, se presenta una lectura fuera de l\u00edmites en license_read_new_or_upgrade_license_packet. Un paquete de licencia manipulado puede conllevar a lecturas fuera del limite en un b\u00fafer interno. Esto es corregido en la versi\u00f3n 2.1.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "DDAC8E89-8F23-4799-AA42-AD419455D1F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.freerdp.com/2020/06/22/2_1_2-released", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-977w-866x-4v5h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6Y35HBHG2INICLSGCIKNAR7GCXEHQACQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XOZLH35OJWIQLM7FYDXAP2EAUBDXE76V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4481-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a"}}