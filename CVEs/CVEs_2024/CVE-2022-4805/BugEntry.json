{"buggy_code": ["package api\n\n// Visibility is the type of a visibility.\ntype Visibility string\n\nconst (\n\t// Public is the PUBLIC visibility.\n\tPublic Visibility = \"PUBLIC\"\n\t// Protected is the PROTECTED visibility.\n\tProtected Visibility = \"PROTECTED\"\n\t// Private is the PRIVATE visibility.\n\tPrivate Visibility = \"PRIVATE\"\n)\n\nfunc (e Visibility) String() string {\n\tswitch e {\n\tcase Public:\n\t\treturn \"PUBLIC\"\n\tcase Protected:\n\t\treturn \"PROTECTED\"\n\tcase Private:\n\t\treturn \"PRIVATE\"\n\t}\n\treturn \"PRIVATE\"\n}\n\ntype Memo struct {\n\tID int `json:\"id\"`\n\n\t// Standard fields\n\tRowStatus RowStatus `json:\"rowStatus\"`\n\tCreatorID int       `json:\"creatorId\"`\n\tCreatedTs int64     `json:\"createdTs\"`\n\tUpdatedTs int64     `json:\"updatedTs\"`\n\n\t// Domain specific fields\n\tContent    string     `json:\"content\"`\n\tVisibility Visibility `json:\"visibility\"`\n\tPinned     bool       `json:\"pinned\"`\n\tDisplayTs  int64      `json:\"displayTs\"`\n\n\t// Related fields\n\tCreator      *User       `json:\"creator\"`\n\tResourceList []*Resource `json:\"resourceList\"`\n}\n\ntype MemoCreate struct {\n\t// Standard fields\n\tCreatorID int\n\n\t// Domain specific fields\n\tVisibility Visibility `json:\"visibility\"`\n\tContent    string     `json:\"content\"`\n\n\t// Related fields\n\tResourceIDList []int `json:\"resourceIdList\"`\n}\n\ntype MemoPatch struct {\n\tID int `json:\"-\"`\n\n\t// Standard fields\n\tCreatedTs *int64 `json:\"createdTs\"`\n\tUpdatedTs *int64\n\tRowStatus *RowStatus `json:\"rowStatus\"`\n\n\t// Domain specific fields\n\tContent    *string     `json:\"content\"`\n\tVisibility *Visibility `json:\"visibility\"`\n\n\t// Related fields\n\tResourceIDList []int `json:\"resourceIdList\"`\n}\n\ntype MemoFind struct {\n\tID *int `json:\"id\"`\n\n\t// Standard fields\n\tRowStatus *RowStatus `json:\"rowStatus\"`\n\tCreatorID *int       `json:\"creatorId\"`\n\n\t// Domain specific fields\n\tPinned         *bool\n\tContentSearch  *string\n\tVisibilityList []Visibility\n\n\t// Pagination\n\tLimit  int\n\tOffset int\n}\n\ntype MemoDelete struct {\n\tID int\n}\n", "package api\n\ntype MemoOrganizer struct {\n\tID int\n\n\t// Domain specific fields\n\tMemoID int\n\tUserID int\n\tPinned bool\n}\n\ntype MemoOrganizerFind struct {\n\tMemoID int\n\tUserID int\n}\n\ntype MemoOrganizerUpsert struct {\n\tMemoID int\n\tUserID int\n\tPinned bool `json:\"pinned\"`\n}\n\ntype MemoOrganizerDelete struct {\n\tMemoID *int\n\tUserID *int\n}\n", "package api\n\ntype MemoResource struct {\n\tMemoID     int\n\tResourceID int\n\tCreatedTs  int64\n\tUpdatedTs  int64\n}\n\ntype MemoResourceUpsert struct {\n\tMemoID     int\n\tResourceID int\n\tUpdatedTs  *int64\n}\n\ntype MemoResourceFind struct {\n\tMemoID     *int\n\tResourceID *int\n}\n\ntype MemoResourceDelete struct {\n\tMemoID     *int\n\tResourceID *int\n}\n", "package api\n\ntype Resource struct {\n\tID int `json:\"id\"`\n\n\t// Standard fields\n\tCreatorID int   `json:\"creatorId\"`\n\tCreatedTs int64 `json:\"createdTs\"`\n\tUpdatedTs int64 `json:\"updatedTs\"`\n\n\t// Domain specific fields\n\tFilename string `json:\"filename\"`\n\tBlob     []byte `json:\"-\"`\n\tType     string `json:\"type\"`\n\tSize     int64  `json:\"size\"`\n\n\t// Related fields\n\tLinkedMemoAmount int `json:\"linkedMemoAmount\"`\n}\n\ntype ResourceCreate struct {\n\t// Standard fields\n\tCreatorID int\n\n\t// Domain specific fields\n\tFilename string `json:\"filename\"`\n\tBlob     []byte `json:\"blob\"`\n\tType     string `json:\"type\"`\n\tSize     int64  `json:\"size\"`\n}\n\ntype ResourceFind struct {\n\tID *int `json:\"id\"`\n\n\t// Standard fields\n\tCreatorID *int `json:\"creatorId\"`\n\n\t// Domain specific fields\n\tFilename *string `json:\"filename\"`\n\tMemoID   *int\n}\n\ntype ResourcePatch struct {\n\tID int `json:\"-\"`\n\n\t// Standard fields\n\tUpdatedTs *int64\n\n\t// Domain specific fields\n\tFilename *string `json:\"filename\"`\n}\n\ntype ResourceDelete struct {\n\tID int\n}\n", "package api\n\ntype Shortcut struct {\n\tID int `json:\"id\"`\n\n\t// Standard fields\n\tRowStatus RowStatus `json:\"rowStatus\"`\n\tCreatorID int       `json:\"creatorId\"`\n\tCreatedTs int64     `json:\"createdTs\"`\n\tUpdatedTs int64     `json:\"updatedTs\"`\n\n\t// Domain specific fields\n\tTitle   string `json:\"title\"`\n\tPayload string `json:\"payload\"`\n}\n\ntype ShortcutCreate struct {\n\t// Standard fields\n\tCreatorID int\n\n\t// Domain specific fields\n\tTitle   string `json:\"title\"`\n\tPayload string `json:\"payload\"`\n}\n\ntype ShortcutPatch struct {\n\tID int `json:\"-\"`\n\n\t// Standard fields\n\tUpdatedTs *int64\n\tRowStatus *RowStatus `json:\"rowStatus\"`\n\n\t// Domain specific fields\n\tTitle   *string `json:\"title\"`\n\tPayload *string `json:\"payload\"`\n}\n\ntype ShortcutFind struct {\n\tID *int\n\n\t// Standard fields\n\tCreatorID *int\n\n\t// Domain specific fields\n\tTitle *string `json:\"title\"`\n}\n\ntype ShortcutDelete struct {\n\tID *int\n\n\t// Standard fields\n\tCreatorID *int\n}\n", "package api\n\ntype Tag struct {\n\tName      string\n\tCreatorID int\n}\n\ntype TagUpsert struct {\n\tName      string\n\tCreatorID int\n}\n\ntype TagFind struct {\n\tCreatorID int\n}\n\ntype TagDelete struct {\n\tName      string\n\tCreatorID int\n}\n", "package api\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"golang.org/x/exp/slices\"\n)\n\ntype UserSettingKey string\n\nconst (\n\t// UserSettingLocaleKey is the key type for user locale.\n\tUserSettingLocaleKey UserSettingKey = \"locale\"\n\t// UserSettingAppearanceKey is the key type for user appearance.\n\tUserSettingAppearanceKey UserSettingKey = \"appearance\"\n\t// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.\n\tUserSettingMemoVisibilityKey UserSettingKey = \"memoVisibility\"\n\t// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.\n\tUserSettingMemoDisplayTsOptionKey UserSettingKey = \"memoDisplayTsOption\"\n)\n\n// String returns the string format of UserSettingKey type.\nfunc (key UserSettingKey) String() string {\n\tswitch key {\n\tcase UserSettingLocaleKey:\n\t\treturn \"locale\"\n\tcase UserSettingAppearanceKey:\n\t\treturn \"appearance\"\n\tcase UserSettingMemoVisibilityKey:\n\t\treturn \"memoVisibility\"\n\tcase UserSettingMemoDisplayTsOptionKey:\n\t\treturn \"memoDisplayTsOption\"\n\t}\n\treturn \"\"\n}\n\nvar (\n\tUserSettingLocaleValue                 = []string{\"en\", \"zh\", \"vi\", \"fr\", \"nl\", \"sv\", \"de\", \"es\", \"uk\"}\n\tUserSettingAppearanceValue             = []string{\"system\", \"light\", \"dark\"}\n\tUserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}\n\tUserSettingMemoDisplayTsOptionKeyValue = []string{\"created_ts\", \"updated_ts\"}\n)\n\ntype UserSetting struct {\n\tUserID int\n\tKey    UserSettingKey `json:\"key\"`\n\t// Value is a JSON string with basic value\n\tValue string `json:\"value\"`\n}\n\ntype UserSettingUpsert struct {\n\tUserID int\n\tKey    UserSettingKey `json:\"key\"`\n\tValue  string         `json:\"value\"`\n}\n\nfunc (upsert UserSettingUpsert) Validate() error {\n\tif upsert.Key == UserSettingLocaleKey {\n\t\tlocaleValue := \"en\"\n\t\terr := json.Unmarshal([]byte(upsert.Value), &localeValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting locale value\")\n\t\t}\n\t\tif !slices.Contains(UserSettingLocaleValue, localeValue) {\n\t\t\treturn fmt.Errorf(\"invalid user setting locale value\")\n\t\t}\n\t} else if upsert.Key == UserSettingAppearanceKey {\n\t\tappearanceValue := \"system\"\n\t\terr := json.Unmarshal([]byte(upsert.Value), &appearanceValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting appearance value\")\n\t\t}\n\t\tif !slices.Contains(UserSettingAppearanceValue, appearanceValue) {\n\t\t\treturn fmt.Errorf(\"invalid user setting appearance value\")\n\t\t}\n\t} else if upsert.Key == UserSettingMemoVisibilityKey {\n\t\tmemoVisibilityValue := Private\n\t\terr := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting memo visibility value\")\n\t\t}\n\t\tif !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {\n\t\t\treturn fmt.Errorf(\"invalid user setting memo visibility value\")\n\t\t}\n\t} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {\n\t\tmemoDisplayTsOption := \"created_ts\"\n\t\terr := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting memo display ts option\")\n\t\t}\n\t\tif !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {\n\t\t\treturn fmt.Errorf(\"invalid user setting memo display ts option value\")\n\t\t}\n\t} else {\n\t\treturn fmt.Errorf(\"invalid user setting key\")\n\t}\n\n\treturn nil\n}\n\ntype UserSettingFind struct {\n\tUserID int\n\n\tKey *UserSettingKey `json:\"key\"`\n}\n\ntype UserSettingDelete struct {\n\tUserID int\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc (s *Server) registerAuthRoutes(g *echo.Group) {\n\tg.POST(\"/auth/signin\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tsignin := &api.Signin{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted signin request\").SetInternal(err)\n\t\t}\n\n\t\tuserFind := &api.UserFind{\n\t\t\tUsername: &signin.Username,\n\t\t}\n\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find user by username %s\", signin.Username)).SetInternal(err)\n\t\t}\n\t\tif user == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(\"User not found with username %s\", signin.Username))\n\t\t} else if user.RowStatus == api.Archived {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(\"User has been archived with username %s\", signin.Username))\n\t\t}\n\n\t\t// Compare the stored hashed password, with the hashed version of the password that was received.\n\t\tif err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {\n\t\t\t// If the two passwords don't match, return a 401 status.\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Incorrect password\").SetInternal(err)\n\t\t}\n\n\t\tif err = setUserSession(c, user); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to set signin session\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user signed in\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/auth/logout\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\terr := removeUserSession(c)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to set logout session\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user logout\",\n\t\t})\n\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\treturn nil\n\t})\n\n\tg.POST(\"/auth/signup\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tsignup := &api.Signup{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted signup request\").SetInternal(err)\n\t\t}\n\n\t\thostUserType := api.Host\n\t\thostUserFind := api.UserFind{\n\t\t\tRole: &hostUserType,\n\t\t}\n\t\thostUser, err := s.Store.FindUser(ctx, &hostUserFind)\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find host user\").SetInternal(err)\n\t\t}\n\t\tif signup.Role == api.Host && hostUser != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly.\").SetInternal(err)\n\t\t}\n\n\t\tsystemSettingAllowSignUpName := api.SystemSettingAllowSignUpName\n\t\tallowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{\n\t\t\tName: &systemSettingAllowSignUpName,\n\t\t})\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find system setting\").SetInternal(err)\n\t\t}\n\n\t\tallowSignUpSettingValue := false\n\t\tif allowSignUpSetting != nil {\n\t\t\terr = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmarshal system setting allow signup\").SetInternal(err)\n\t\t\t}\n\t\t}\n\t\tif !allowSignUpSettingValue && hostUser != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly.\").SetInternal(err)\n\t\t}\n\n\t\tuserCreate := &api.UserCreate{\n\t\t\tUsername: signup.Username,\n\t\t\tRole:     api.Role(signup.Role),\n\t\t\tNickname: signup.Username,\n\t\t\tPassword: signup.Password,\n\t\t\tOpenID:   common.GenUUID(),\n\t\t}\n\t\tif err := userCreate.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format.\").SetInternal(err)\n\t\t}\n\n\t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to generate password hash\").SetInternal(err)\n\t\t}\n\n\t\tuserCreate.PasswordHash = string(passwordHash)\n\n\t\tuser, err := s.Store.CreateUser(ctx, userCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create user\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user signed up\",\n\t\t})\n\n\t\terr = setUserSession(c, user)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to set signup session\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode created user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerMemoRoutes(g *echo.Group) {\n\tg.POST(\"/memo\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tmemoCreate := &api.MemoCreate{\n\t\t\tCreatorID: userID,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo request\").SetInternal(err)\n\t\t}\n\t\tif memoCreate.Content == \"\" {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Memo content shouldn't be empty\")\n\t\t}\n\n\t\tif memoCreate.Visibility == \"\" {\n\t\t\tuserSettingMemoVisibilityKey := api.UserSettingMemoVisibilityKey\n\t\t\tuserMemoVisibilitySetting, err := s.Store.FindUserSetting(ctx, &api.UserSettingFind{\n\t\t\t\tUserID: userID,\n\t\t\t\tKey:    &userSettingMemoVisibilityKey,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user setting\").SetInternal(err)\n\t\t\t}\n\n\t\t\tif userMemoVisibilitySetting != nil {\n\t\t\t\tmemoVisibility := api.Private\n\t\t\t\terr := json.Unmarshal([]byte(userMemoVisibilitySetting.Value), &memoVisibility)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmarshal user setting value\").SetInternal(err)\n\t\t\t\t}\n\t\t\t\tmemoCreate.Visibility = memoVisibility\n\t\t\t} else {\n\t\t\t\t// Private is the default memo visibility.\n\t\t\t\tmemoCreate.Visibility = api.Private\n\t\t\t}\n\t\t}\n\n\t\tmemo, err := s.Store.CreateMemo(ctx, memoCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create memo\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"memo created\",\n\t\t})\n\n\t\tfor _, resourceID := range memoCreate.ResourceIDList {\n\t\t\tif _, err := s.Store.UpsertMemoResource(ctx, &api.MemoResourceUpsert{\n\t\t\t\tMemoID:     memo.ID,\n\t\t\t\tResourceID: resourceID,\n\t\t\t}); err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n\t\t\t}\n\t\t}\n\n\t\tmemo, err = s.Store.ComposeMemo(ctx, memo)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to compose memo\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/memo/:memoId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemoFind := &api.MemoFind{\n\t\t\tID:        &memoID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindMemo(ctx, memoFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tmemoPatch := &api.MemoPatch{\n\t\t\tID:        memoID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoPatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch memo request\").SetInternal(err)\n\t\t}\n\n\t\tmemo, err := s.Store.PatchMemo(ctx, memoPatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch memo\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resourceID := range memoPatch.ResourceIDList {\n\t\t\tif _, err := s.Store.UpsertMemoResource(ctx, &api.MemoResourceUpsert{\n\t\t\t\tMemoID:     memo.ID,\n\t\t\t\tResourceID: resourceID,\n\t\t\t}); err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n\t\t\t}\n\t\t}\n\n\t\tmemo, err = s.Store.ComposeMemo(ctx, memo)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to compose memo\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoFind := &api.MemoFind{}\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &userID\n\t\t}\n\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tif memoFind.CreatorID == nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tif memoFind.CreatorID == nil {\n\t\t\t\tmemoFind.CreatorID = &currentUserID\n\t\t\t} else {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t\t}\n\t\t}\n\n\t\trowStatus := api.RowStatus(c.QueryParam(\"rowStatus\"))\n\t\tif rowStatus != \"\" {\n\t\t\tmemoFind.RowStatus = &rowStatus\n\t\t}\n\t\tpinnedStr := c.QueryParam(\"pinned\")\n\t\tif pinnedStr != \"\" {\n\t\t\tpinned := pinnedStr == \"true\"\n\t\t\tmemoFind.Pinned = &pinned\n\t\t}\n\t\ttag := c.QueryParam(\"tag\")\n\t\tif tag != \"\" {\n\t\t\tcontentSearch := \"#\" + tag + \" \"\n\t\t\tmemoFind.ContentSearch = &contentSearch\n\t\t}\n\t\tvisibilityListStr := c.QueryParam(\"visibility\")\n\t\tif visibilityListStr != \"\" {\n\t\t\tvisibilityList := []api.Visibility{}\n\t\t\tfor _, visibility := range strings.Split(visibilityListStr, \",\") {\n\t\t\t\tvisibilityList = append(visibilityList, api.Visibility(visibility))\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = visibilityList\n\t\t}\n\t\tif limit, err := strconv.Atoi(c.QueryParam(\"limit\")); err == nil {\n\t\t\tmemoFind.Limit = limit\n\t\t}\n\t\tif offset, err := strconv.Atoi(c.QueryParam(\"offset\")); err == nil {\n\t\t\tmemoFind.Offset = offset\n\t\t}\n\n\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch memo list\").SetInternal(err)\n\t\t}\n\n\t\tvar pinnedMemoList []*api.Memo\n\t\tvar unpinnedMemoList []*api.Memo\n\n\t\tfor _, memo := range list {\n\t\t\tif memo.Pinned {\n\t\t\t\tpinnedMemoList = append(pinnedMemoList, memo)\n\t\t\t} else {\n\t\t\t\tunpinnedMemoList = append(unpinnedMemoList, memo)\n\t\t\t}\n\t\t}\n\n\t\tsort.Slice(pinnedMemoList, func(i, j int) bool {\n\t\t\treturn pinnedMemoList[i].DisplayTs > pinnedMemoList[j].DisplayTs\n\t\t})\n\t\tsort.Slice(unpinnedMemoList, func(i, j int) bool {\n\t\t\treturn unpinnedMemoList[i].DisplayTs > unpinnedMemoList[j].DisplayTs\n\t\t})\n\n\t\tmemoList := []*api.Memo{}\n\t\tmemoList = append(memoList, pinnedMemoList...)\n\t\tmemoList = append(memoList, unpinnedMemoList...)\n\n\t\tif memoFind.Limit != 0 {\n\t\t\tmemoList = memoList[memoFind.Offset:common.Min(len(memoList), memoFind.Offset+memoFind.Limit)]\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memoList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/amount\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tnormalRowStatus := api.Normal\n\t\tmemoFind := &api.MemoFind{\n\t\t\tRowStatus: &normalRowStatus,\n\t\t}\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"userId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &userID\n\t\t}\n\n\t\tmemoList, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(len(memoList))); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo amount\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/stats\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tnormalStatus := api.Normal\n\t\tmemoFind := &api.MemoFind{\n\t\t\tRowStatus: &normalStatus,\n\t\t}\n\t\tif creatorID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &creatorID\n\t\t}\n\t\tif memoFind.CreatorID == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n\t\t}\n\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tif *memoFind.CreatorID != currentUserID {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t\t} else {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected, api.Private}\n\t\t\t}\n\t\t}\n\n\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch memo list\").SetInternal(err)\n\t\t}\n\n\t\tdisplayTsList := []int64{}\n\t\tfor _, memo := range list {\n\t\t\tdisplayTsList = append(displayTsList, memo.DisplayTs)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(displayTsList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo stats response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/all\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoFind := &api.MemoFind{}\n\n\t\t_, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t}\n\n\t\tpinnedStr := c.QueryParam(\"pinned\")\n\t\tif pinnedStr != \"\" {\n\t\t\tpinned := pinnedStr == \"true\"\n\t\t\tmemoFind.Pinned = &pinned\n\t\t}\n\t\ttag := c.QueryParam(\"tag\")\n\t\tif tag != \"\" {\n\t\t\tcontentSearch := \"#\" + tag + \" \"\n\t\t\tmemoFind.ContentSearch = &contentSearch\n\t\t}\n\t\tvisibilityListStr := c.QueryParam(\"visibility\")\n\t\tif visibilityListStr != \"\" {\n\t\t\tvisibilityList := []api.Visibility{}\n\t\t\tfor _, visibility := range strings.Split(visibilityListStr, \",\") {\n\t\t\t\tvisibilityList = append(visibilityList, api.Visibility(visibility))\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = visibilityList\n\t\t}\n\t\tif limit, err := strconv.Atoi(c.QueryParam(\"limit\")); err == nil {\n\t\t\tmemoFind.Limit = limit\n\t\t}\n\t\tif offset, err := strconv.Atoi(c.QueryParam(\"offset\")); err == nil {\n\t\t\tmemoFind.Offset = offset\n\t\t}\n\n\t\t// Only fetch normal status memos.\n\t\tnormalStatus := api.Normal\n\t\tmemoFind.RowStatus = &normalStatus\n\n\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch all memo list\").SetInternal(err)\n\t\t}\n\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\treturn list[i].DisplayTs > list[j].DisplayTs\n\t\t})\n\n\t\tif memoFind.Limit != 0 {\n\t\t\tlist = list[memoFind.Offset:common.Min(len(list), memoFind.Offset+memoFind.Limit)]\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode all memo list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/:memoId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemoFind := &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t}\n\t\tmemo, err := s.Store.FindMemo(ctx, memoFind)\n\t\tif err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Memo ID not found: %d\", memoID)).SetInternal(err)\n\t\t\t}\n\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find memo by ID: %v\", memoID)).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif memo.Visibility == api.Private {\n\t\t\tif !ok || memo.CreatorID != userID {\n\t\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"this memo is private only\")\n\t\t\t}\n\t\t} else if memo.Visibility == api.Protected {\n\t\t\tif !ok {\n\t\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"this memo is protected, missing user in session\")\n\t\t\t}\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/memo/:memoId/organizer\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tmemoOrganizerUpsert := &api.MemoOrganizerUpsert{\n\t\t\tMemoID: memoID,\n\t\t\tUserID: userID,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoOrganizerUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo organizer request\").SetInternal(err)\n\t\t}\n\n\t\terr = s.Store.UpsertMemoOrganizer(ctx, memoOrganizerUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo organizer\").SetInternal(err)\n\t\t}\n\n\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t})\n\t\tif err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Memo ID not found: %d\", memoID)).SetInternal(err)\n\t\t\t}\n\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find memo by ID: %v\", memoID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/memo/:memoId/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tmemoResourceUpsert := &api.MemoResourceUpsert{\n\t\t\tMemoID:    memoID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoResourceUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo resource request\").SetInternal(err)\n\t\t}\n\n\t\tif _, err := s.Store.UpsertMemoResource(ctx, memoResourceUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID: &memoResourceUpsert.ResourceID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/:memoId/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tMemoID: &memoID,\n\t\t}\n\t\tresourceList, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resourceList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/memo/:memoId/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Memo ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Resource ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemoResourceDelete := &api.MemoResourceDelete{\n\t\t\tMemoID:     &memoID,\n\t\t\tResourceID: &resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteMemoResource(ctx, memoResourceDelete); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n\n\tg.DELETE(\"/memo/:memoId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemoFind := &api.MemoFind{\n\t\t\tID:        &memoID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindMemo(ctx, memoFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n\t\t}\n\n\t\tmemoDelete := &api.MemoDelete{\n\t\t\tID: memoID,\n\t\t}\n\t\tif err := s.Store.DeleteMemo(ctx, memoDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Memo ID not found: %d\", memoID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to delete memo ID: %v\", memoID)).SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = (32 * 8) << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t\tCreatorID: userID,\n\t\t}\n\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"resource created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tif _, err := s.Store.FindResource(ctx, resourceFind); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tID:        resourceID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Not find resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerShortcutRoutes(g *echo.Group) {\n\tg.POST(\"/shortcut\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tshortcutCreate := &api.ShortcutCreate{\n\t\t\tCreatorID: userID,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post shortcut request\").SetInternal(err)\n\t\t}\n\n\t\tshortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create shortcut\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"shortcut created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tshortcutPatch := &api.ShortcutPatch{\n\t\t\tID:        shortcutID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch shortcut request\").SetInternal(err)\n\t\t}\n\n\t\tshortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch shortcut\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/shortcut\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tshortcutFind := &api.ShortcutFind{}\n\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\tshortcutFind.CreatorID = &userID\n\t\t} else {\n\t\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\t\tif !ok {\n\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find shortcut\")\n\t\t\t}\n\n\t\t\tshortcutFind.CreatorID = &userID\n\t\t}\n\n\t\tlist, err := s.Store.FindShortcutList(ctx, shortcutFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch shortcut list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n\t\t}\n\n\t\tshortcutFind := &api.ShortcutFind{\n\t\t\tID: &shortcutID,\n\t\t}\n\t\tshortcut, err := s.Store.FindShortcut(ctx, shortcutFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch shortcut by ID %d\", *shortcutFind.ID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n\t\t}\n\n\t\tshortcutDelete := &api.ShortcutDelete{\n\t\t\tID: &shortcutID,\n\t\t}\n\t\tif err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Shortcut ID not found: %d\", shortcutID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete shortcut\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerSystemRoutes(g *echo.Group) {\n\tg.GET(\"/ping\", func(c echo.Context) error {\n\t\tdata := s.Profile\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(data)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to compose system profile\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/status\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\thostUserType := api.Host\n\t\thostUserFind := api.UserFind{\n\t\t\tRole: &hostUserType,\n\t\t}\n\t\thostUser, err := s.Store.FindUser(ctx, &hostUserFind)\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find host user\").SetInternal(err)\n\t\t}\n\n\t\tif hostUser != nil {\n\t\t\t// data desensitize\n\t\t\thostUser.OpenID = \"\"\n\t\t\thostUser.Email = \"\"\n\t\t}\n\n\t\tsystemStatus := api.SystemStatus{\n\t\t\tHost:             hostUser,\n\t\t\tProfile:          *s.Profile,\n\t\t\tDBSize:           0,\n\t\t\tAllowSignUp:      false,\n\t\t\tAdditionalStyle:  \"\",\n\t\t\tAdditionalScript: \"\",\n\t\t\tCustomizedProfile: api.CustomizedProfile{\n\t\t\t\tName:        \"memos\",\n\t\t\t\tLogoURL:     \"\",\n\t\t\t\tDescription: \"\",\n\t\t\t\tLocale:      \"en\",\n\t\t\t\tAppearance:  \"system\",\n\t\t\t\tExternalURL: \"\",\n\t\t\t},\n\t\t}\n\n\t\tsystemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find system setting list\").SetInternal(err)\n\t\t}\n\t\tfor _, systemSetting := range systemSettingList {\n\t\t\tvar value interface{}\n\t\t\terr := json.Unmarshal([]byte(systemSetting.Value), &value)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmarshal system setting\").SetInternal(err)\n\t\t\t}\n\n\t\t\tif systemSetting.Name == api.SystemSettingAllowSignUpName {\n\t\t\t\tsystemStatus.AllowSignUp = value.(bool)\n\t\t\t} else if systemSetting.Name == api.SystemSettingAdditionalStyleName {\n\t\t\t\tsystemStatus.AdditionalStyle = value.(string)\n\t\t\t} else if systemSetting.Name == api.SystemSettingAdditionalScriptName {\n\t\t\t\tsystemStatus.AdditionalScript = value.(string)\n\t\t\t} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {\n\t\t\t\tvalueMap := value.(map[string]interface{})\n\t\t\t\tsystemStatus.CustomizedProfile = api.CustomizedProfile{\n\t\t\t\t\tName:        valueMap[\"name\"].(string),\n\t\t\t\t\tLogoURL:     valueMap[\"logoUrl\"].(string),\n\t\t\t\t\tDescription: valueMap[\"description\"].(string),\n\t\t\t\t\tLocale:      valueMap[\"locale\"].(string),\n\t\t\t\t\tAppearance:  valueMap[\"appearance\"].(string),\n\t\t\t\t\tExternalURL: valueMap[\"externalUrl\"].(string),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\t// Get database size for host user.\n\t\tif ok {\n\t\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\t\tID: &userID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t\t}\n\t\t\tif user != nil && user.Role == api.Host {\n\t\t\t\tfi, err := os.Stat(s.Profile.DSN)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read database fileinfo\").SetInternal(err)\n\t\t\t\t}\n\t\t\t\tsystemStatus.DBSize = fi.Size()\n\t\t\t}\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemStatus)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode system status response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/system/setting\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif user == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Current signin user not found\")\n\t\t} else if user.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tsystemSettingUpsert := &api.SystemSettingUpsert{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(systemSettingUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post system setting request\").SetInternal(err)\n\t\t}\n\t\tif err := systemSettingUpsert.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"system setting invalidate\").SetInternal(err)\n\t\t}\n\n\t\tsystemSetting, err := s.Store.UpsertSystemSetting(ctx, systemSettingUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert system setting\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName:   \"systemSetting updated\",\n\t\t\tLabels: map[string]string{\"field\": string(systemSettingUpsert.Name)},\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSetting)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode system setting response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/system/setting\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tsystemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find system setting list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSettingList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode system setting list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/system/vacuum\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif user == nil || user.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\t\tif err := s.Store.Vacuum(ctx); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to vacuum database\").SetInternal(err)\n\t\t}\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerTagRoutes(g *echo.Group) {\n\tg.POST(\"/tag\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\ttagUpsert := &api.TagUpsert{\n\t\t\tCreatorID: userID,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post tag request\").SetInternal(err)\n\t\t}\n\t\tif tagUpsert.Name == \"\" {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Tag name shouldn't be empty\")\n\t\t}\n\n\t\ttag, err := s.Store.UpsertTag(ctx, tagUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert tag\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"tag created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode tag response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/tag\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\ttagFind := &api.TagFind{}\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\ttagFind.CreatorID = userID\n\t\t}\n\n\t\tif tagFind.CreatorID == 0 {\n\t\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\t\tif !ok {\n\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find tag\")\n\t\t\t}\n\t\t\ttagFind.CreatorID = currentUserID\n\t\t}\n\n\t\ttagList, err := s.Store.FindTagList(ctx, tagFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find tag list\").SetInternal(err)\n\t\t}\n\n\t\ttagNameList := []string{}\n\t\tfor _, tag := range tagList {\n\t\t\ttagNameList = append(tagNameList, tag.Name)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode tags response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/tag/suggestion\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tcontentSearch := \"#\"\n\t\tnormalRowStatus := api.Normal\n\t\tmemoFind := api.MemoFind{\n\t\t\tContentSearch: &contentSearch,\n\t\t\tRowStatus:     &normalRowStatus,\n\t\t}\n\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &userID\n\t\t}\n\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tif memoFind.CreatorID == nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tif memoFind.CreatorID == nil {\n\t\t\t\tmemoFind.CreatorID = &currentUserID\n\t\t\t} else {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t\t}\n\t\t}\n\n\t\tmemoList, err := s.Store.FindMemoList(ctx, &memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)\n\t\t}\n\n\t\ttagMapSet := make(map[string]bool)\n\t\tfor _, memo := range memoList {\n\t\t\tfor _, tag := range findTagListFromMemoContent(memo.Content) {\n\t\t\t\ttagMapSet[tag] = true\n\t\t\t}\n\t\t}\n\t\ttagList := []string{}\n\t\tfor tag := range tagMapSet {\n\t\t\ttagList = append(tagList, tag)\n\t\t}\n\t\tsort.Strings(tagList)\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode tags response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/tag/:tagName\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\ttagName := c.Param(\"tagName\")\n\t\tif tagName == \"\" {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Tag name cannot be empty\")\n\t\t}\n\n\t\ttagDelete := &api.TagDelete{\n\t\t\tName:      tagName,\n\t\t\tCreatorID: userID,\n\t\t}\n\t\tif err := s.Store.DeleteTag(ctx, tagDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Tag name not found: %s\", tagName))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to delete tag name: %v\", tagName)).SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nvar tagRegexp = regexp.MustCompile(`#([^\\s#]+)`)\n\nfunc findTagListFromMemoContent(memoContent string) []string {\n\ttagMapSet := make(map[string]bool)\n\tmatches := tagRegexp.FindAllStringSubmatch(memoContent, -1)\n\tfor _, v := range matches {\n\t\ttagName := v[1]\n\t\ttagMapSet[tagName] = true\n\t}\n\n\ttagList := []string{}\n\tfor tag := range tagMapSet {\n\t\ttagList = append(tagList, tag)\n\t}\n\tsort.Strings(tagList)\n\treturn tagList\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc (s *Server) registerUserRoutes(g *echo.Group) {\n\tg.POST(\"/user\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing auth session\")\n\t\t}\n\t\tcurrentUser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user by id\").SetInternal(err)\n\t\t}\n\t\tif currentUser.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Only Host user can create member.\")\n\t\t}\n\n\t\tuserCreate := &api.UserCreate{\n\t\t\tOpenID: common.GenUUID(),\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(userCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post user request\").SetInternal(err)\n\t\t}\n\n\t\tif err := userCreate.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format.\").SetInternal(err)\n\t\t}\n\n\t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(userCreate.Password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to generate password hash\").SetInternal(err)\n\t\t}\n\n\t\tuserCreate.PasswordHash = string(passwordHash)\n\t\tuser, err := s.Store.CreateUser(ctx, userCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create user\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/user\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserList, err := s.Store.FindUserList(ctx, &api.UserFind{})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch user list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, user := range userList {\n\t\t\t// data desensitize\n\t\t\tuser.OpenID = \"\"\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(userList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\t// GET /api/user/me is used to check if the user is logged in.\n\tg.GET(\"/user/me\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing auth session\")\n\t\t}\n\n\t\tuserFind := &api.UserFind{\n\t\t\tID: &userID,\n\t\t}\n\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\n\t\tuserSettingList, err := s.Store.FindUserSettingList(ctx, &api.UserSettingFind{\n\t\t\tUserID: userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find userSettingList\").SetInternal(err)\n\t\t}\n\t\tuser.UserSettingList = userSettingList\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/user/setting\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing auth session\")\n\t\t}\n\n\t\tuserSettingUpsert := &api.UserSettingUpsert{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(userSettingUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post user setting upsert request\").SetInternal(err)\n\t\t}\n\t\tif err := userSettingUpsert.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user setting format\").SetInternal(err)\n\t\t}\n\n\t\tuserSettingUpsert.UserID = userID\n\t\tuserSetting, err := s.Store.UpsertUserSetting(ctx, userSettingUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert user setting\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(userSetting)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user setting response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/user/:id\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tid, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted user id\").SetInternal(err)\n\t\t}\n\n\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &id,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch user\").SetInternal(err)\n\t\t}\n\n\t\tif user != nil {\n\t\t\t// data desensitize\n\t\t\tuser.OpenID = \"\"\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/user/:id\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"id\"))).SetInternal(err)\n\t\t}\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tcurrentUser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &currentUserID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif currentUser == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Current session user not found with ID: %d\", currentUserID)).SetInternal(err)\n\t\t} else if currentUser.Role != api.Host && currentUserID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"Access forbidden for current session user\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tuserPatch := &api.UserPatch{\n\t\t\tID:        userID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(userPatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch user request\").SetInternal(err)\n\t\t}\n\t\tif err := userPatch.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user patch format.\").SetInternal(err)\n\t\t}\n\n\t\tif userPatch.Password != nil && *userPatch.Password != \"\" {\n\t\t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(*userPatch.Password), bcrypt.DefaultCost)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to generate password hash\").SetInternal(err)\n\t\t\t}\n\n\t\t\tpasswordHashStr := string(passwordHash)\n\t\t\tuserPatch.PasswordHash = &passwordHashStr\n\t\t}\n\n\t\tif userPatch.ResetOpenID != nil && *userPatch.ResetOpenID {\n\t\t\topenID := common.GenUUID()\n\t\t\tuserPatch.OpenID = &openID\n\t\t}\n\n\t\tuser, err := s.Store.PatchUser(ctx, userPatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch user\").SetInternal(err)\n\t\t}\n\n\t\tuserSettingList, err := s.Store.FindUserSettingList(ctx, &api.UserSettingFind{\n\t\t\tUserID: userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find userSettingList\").SetInternal(err)\n\t\t}\n\t\tuser.UserSettingList = userSettingList\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/user/:id\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tcurrentUser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &currentUserID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif currentUser == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Current session user not found with ID: %d\", currentUserID)).SetInternal(err)\n\t\t} else if currentUser.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"Access forbidden for current session user\").SetInternal(err)\n\t\t}\n\n\t\tuserID, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"id\"))).SetInternal(err)\n\t\t}\n\n\t\tuserDelete := &api.UserDelete{\n\t\t\tID: userID,\n\t\t}\n\t\tif err := s.Store.DeleteUser(ctx, userDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"User ID not found: %d\", userID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete user\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n"], "fixing_code": ["package api\n\n// Visibility is the type of a visibility.\ntype Visibility string\n\nconst (\n\t// Public is the PUBLIC visibility.\n\tPublic Visibility = \"PUBLIC\"\n\t// Protected is the PROTECTED visibility.\n\tProtected Visibility = \"PROTECTED\"\n\t// Private is the PRIVATE visibility.\n\tPrivate Visibility = \"PRIVATE\"\n)\n\nfunc (e Visibility) String() string {\n\tswitch e {\n\tcase Public:\n\t\treturn \"PUBLIC\"\n\tcase Protected:\n\t\treturn \"PROTECTED\"\n\tcase Private:\n\t\treturn \"PRIVATE\"\n\t}\n\treturn \"PRIVATE\"\n}\n\ntype Memo struct {\n\tID int `json:\"id\"`\n\n\t// Standard fields\n\tRowStatus RowStatus `json:\"rowStatus\"`\n\tCreatorID int       `json:\"creatorId\"`\n\tCreatedTs int64     `json:\"createdTs\"`\n\tUpdatedTs int64     `json:\"updatedTs\"`\n\n\t// Domain specific fields\n\tContent    string     `json:\"content\"`\n\tVisibility Visibility `json:\"visibility\"`\n\tPinned     bool       `json:\"pinned\"`\n\tDisplayTs  int64      `json:\"displayTs\"`\n\n\t// Related fields\n\tCreator      *User       `json:\"creator\"`\n\tResourceList []*Resource `json:\"resourceList\"`\n}\n\ntype MemoCreate struct {\n\t// Standard fields\n\tCreatorID int `json:\"-\"`\n\n\t// Domain specific fields\n\tVisibility Visibility `json:\"visibility\"`\n\tContent    string     `json:\"content\"`\n\n\t// Related fields\n\tResourceIDList []int `json:\"resourceIdList\"`\n}\n\ntype MemoPatch struct {\n\tID int `json:\"-\"`\n\n\t// Standard fields\n\tCreatedTs *int64 `json:\"createdTs\"`\n\tUpdatedTs *int64\n\tRowStatus *RowStatus `json:\"rowStatus\"`\n\n\t// Domain specific fields\n\tContent    *string     `json:\"content\"`\n\tVisibility *Visibility `json:\"visibility\"`\n\n\t// Related fields\n\tResourceIDList []int `json:\"resourceIdList\"`\n}\n\ntype MemoFind struct {\n\tID *int\n\n\t// Standard fields\n\tRowStatus *RowStatus\n\tCreatorID *int\n\n\t// Domain specific fields\n\tPinned         *bool\n\tContentSearch  *string\n\tVisibilityList []Visibility\n\n\t// Pagination\n\tLimit  int\n\tOffset int\n}\n\ntype MemoDelete struct {\n\tID int\n}\n", "package api\n\ntype MemoOrganizer struct {\n\tID int\n\n\t// Domain specific fields\n\tMemoID int\n\tUserID int\n\tPinned bool\n}\n\ntype MemoOrganizerUpsert struct {\n\tMemoID int  `json:\"-\"`\n\tUserID int  `json:\"-\"`\n\tPinned bool `json:\"pinned\"`\n}\n\ntype MemoOrganizerFind struct {\n\tMemoID int\n\tUserID int\n}\n\ntype MemoOrganizerDelete struct {\n\tMemoID *int\n\tUserID *int\n}\n", "package api\n\ntype MemoResource struct {\n\tMemoID     int\n\tResourceID int\n\tCreatedTs  int64\n\tUpdatedTs  int64\n}\n\ntype MemoResourceUpsert struct {\n\tMemoID     int `json:\"-\"`\n\tResourceID int\n\tUpdatedTs  *int64\n}\n\ntype MemoResourceFind struct {\n\tMemoID     *int\n\tResourceID *int\n}\n\ntype MemoResourceDelete struct {\n\tMemoID     *int\n\tResourceID *int\n}\n", "package api\n\ntype Resource struct {\n\tID int `json:\"id\"`\n\n\t// Standard fields\n\tCreatorID int   `json:\"creatorId\"`\n\tCreatedTs int64 `json:\"createdTs\"`\n\tUpdatedTs int64 `json:\"updatedTs\"`\n\n\t// Domain specific fields\n\tFilename string `json:\"filename\"`\n\tBlob     []byte `json:\"-\"`\n\tType     string `json:\"type\"`\n\tSize     int64  `json:\"size\"`\n\n\t// Related fields\n\tLinkedMemoAmount int `json:\"linkedMemoAmount\"`\n}\n\ntype ResourceCreate struct {\n\t// Standard fields\n\tCreatorID int `json:\"-\"`\n\n\t// Domain specific fields\n\tFilename string `json:\"filename\"`\n\tBlob     []byte `json:\"blob\"`\n\tType     string `json:\"type\"`\n\tSize     int64  `json:\"size\"`\n}\n\ntype ResourceFind struct {\n\tID *int `json:\"id\"`\n\n\t// Standard fields\n\tCreatorID *int `json:\"creatorId\"`\n\n\t// Domain specific fields\n\tFilename *string `json:\"filename\"`\n\tMemoID   *int\n}\n\ntype ResourcePatch struct {\n\tID int `json:\"-\"`\n\n\t// Standard fields\n\tUpdatedTs *int64\n\n\t// Domain specific fields\n\tFilename *string `json:\"filename\"`\n}\n\ntype ResourceDelete struct {\n\tID int\n}\n", "package api\n\ntype Shortcut struct {\n\tID int `json:\"id\"`\n\n\t// Standard fields\n\tRowStatus RowStatus `json:\"rowStatus\"`\n\tCreatorID int       `json:\"creatorId\"`\n\tCreatedTs int64     `json:\"createdTs\"`\n\tUpdatedTs int64     `json:\"updatedTs\"`\n\n\t// Domain specific fields\n\tTitle   string `json:\"title\"`\n\tPayload string `json:\"payload\"`\n}\n\ntype ShortcutCreate struct {\n\t// Standard fields\n\tCreatorID int `json:\"-\"`\n\n\t// Domain specific fields\n\tTitle   string `json:\"title\"`\n\tPayload string `json:\"payload\"`\n}\n\ntype ShortcutPatch struct {\n\tID int `json:\"-\"`\n\n\t// Standard fields\n\tUpdatedTs *int64\n\tRowStatus *RowStatus `json:\"rowStatus\"`\n\n\t// Domain specific fields\n\tTitle   *string `json:\"title\"`\n\tPayload *string `json:\"payload\"`\n}\n\ntype ShortcutFind struct {\n\tID *int\n\n\t// Standard fields\n\tCreatorID *int\n\n\t// Domain specific fields\n\tTitle *string `json:\"title\"`\n}\n\ntype ShortcutDelete struct {\n\tID *int\n\n\t// Standard fields\n\tCreatorID *int\n}\n", "package api\n\ntype Tag struct {\n\tName      string\n\tCreatorID int\n}\n\ntype TagUpsert struct {\n\tName      string\n\tCreatorID int `json:\"-\"`\n}\n\ntype TagFind struct {\n\tCreatorID int\n}\n\ntype TagDelete struct {\n\tName      string\n\tCreatorID int\n}\n", "package api\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"golang.org/x/exp/slices\"\n)\n\ntype UserSettingKey string\n\nconst (\n\t// UserSettingLocaleKey is the key type for user locale.\n\tUserSettingLocaleKey UserSettingKey = \"locale\"\n\t// UserSettingAppearanceKey is the key type for user appearance.\n\tUserSettingAppearanceKey UserSettingKey = \"appearance\"\n\t// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.\n\tUserSettingMemoVisibilityKey UserSettingKey = \"memoVisibility\"\n\t// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.\n\tUserSettingMemoDisplayTsOptionKey UserSettingKey = \"memoDisplayTsOption\"\n)\n\n// String returns the string format of UserSettingKey type.\nfunc (key UserSettingKey) String() string {\n\tswitch key {\n\tcase UserSettingLocaleKey:\n\t\treturn \"locale\"\n\tcase UserSettingAppearanceKey:\n\t\treturn \"appearance\"\n\tcase UserSettingMemoVisibilityKey:\n\t\treturn \"memoVisibility\"\n\tcase UserSettingMemoDisplayTsOptionKey:\n\t\treturn \"memoDisplayTsOption\"\n\t}\n\treturn \"\"\n}\n\nvar (\n\tUserSettingLocaleValue                 = []string{\"en\", \"zh\", \"vi\", \"fr\", \"nl\", \"sv\", \"de\", \"es\", \"uk\"}\n\tUserSettingAppearanceValue             = []string{\"system\", \"light\", \"dark\"}\n\tUserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}\n\tUserSettingMemoDisplayTsOptionKeyValue = []string{\"created_ts\", \"updated_ts\"}\n)\n\ntype UserSetting struct {\n\tUserID int\n\tKey    UserSettingKey `json:\"key\"`\n\t// Value is a JSON string with basic value\n\tValue string `json:\"value\"`\n}\n\ntype UserSettingUpsert struct {\n\tUserID int            `json:\"-\"`\n\tKey    UserSettingKey `json:\"key\"`\n\tValue  string         `json:\"value\"`\n}\n\nfunc (upsert UserSettingUpsert) Validate() error {\n\tif upsert.Key == UserSettingLocaleKey {\n\t\tlocaleValue := \"en\"\n\t\terr := json.Unmarshal([]byte(upsert.Value), &localeValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting locale value\")\n\t\t}\n\t\tif !slices.Contains(UserSettingLocaleValue, localeValue) {\n\t\t\treturn fmt.Errorf(\"invalid user setting locale value\")\n\t\t}\n\t} else if upsert.Key == UserSettingAppearanceKey {\n\t\tappearanceValue := \"system\"\n\t\terr := json.Unmarshal([]byte(upsert.Value), &appearanceValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting appearance value\")\n\t\t}\n\t\tif !slices.Contains(UserSettingAppearanceValue, appearanceValue) {\n\t\t\treturn fmt.Errorf(\"invalid user setting appearance value\")\n\t\t}\n\t} else if upsert.Key == UserSettingMemoVisibilityKey {\n\t\tmemoVisibilityValue := Private\n\t\terr := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting memo visibility value\")\n\t\t}\n\t\tif !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {\n\t\t\treturn fmt.Errorf(\"invalid user setting memo visibility value\")\n\t\t}\n\t} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {\n\t\tmemoDisplayTsOption := \"created_ts\"\n\t\terr := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal user setting memo display ts option\")\n\t\t}\n\t\tif !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {\n\t\t\treturn fmt.Errorf(\"invalid user setting memo display ts option value\")\n\t\t}\n\t} else {\n\t\treturn fmt.Errorf(\"invalid user setting key\")\n\t}\n\n\treturn nil\n}\n\ntype UserSettingFind struct {\n\tUserID int\n\n\tKey *UserSettingKey `json:\"key\"`\n}\n\ntype UserSettingDelete struct {\n\tUserID int\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc (s *Server) registerAuthRoutes(g *echo.Group) {\n\tg.POST(\"/auth/signin\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tsignin := &api.Signin{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted signin request\").SetInternal(err)\n\t\t}\n\n\t\tuserFind := &api.UserFind{\n\t\t\tUsername: &signin.Username,\n\t\t}\n\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find user by username %s\", signin.Username)).SetInternal(err)\n\t\t}\n\t\tif user == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(\"User not found with username %s\", signin.Username))\n\t\t} else if user.RowStatus == api.Archived {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(\"User has been archived with username %s\", signin.Username))\n\t\t}\n\n\t\t// Compare the stored hashed password, with the hashed version of the password that was received.\n\t\tif err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {\n\t\t\t// If the two passwords don't match, return a 401 status.\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Incorrect password\").SetInternal(err)\n\t\t}\n\n\t\tif err = setUserSession(c, user); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to set signin session\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user signed in\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/auth/logout\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\terr := removeUserSession(c)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to set logout session\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user logout\",\n\t\t})\n\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\treturn nil\n\t})\n\n\tg.POST(\"/auth/signup\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tsignup := &api.Signup{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted signup request\").SetInternal(err)\n\t\t}\n\n\t\thostUserType := api.Host\n\t\thostUserFind := api.UserFind{\n\t\t\tRole: &hostUserType,\n\t\t}\n\t\thostUser, err := s.Store.FindUser(ctx, &hostUserFind)\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find host user\").SetInternal(err)\n\t\t}\n\t\tif signup.Role == api.Host && hostUser != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly\").SetInternal(err)\n\t\t}\n\n\t\tsystemSettingAllowSignUpName := api.SystemSettingAllowSignUpName\n\t\tallowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{\n\t\t\tName: &systemSettingAllowSignUpName,\n\t\t})\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find system setting\").SetInternal(err)\n\t\t}\n\n\t\tallowSignUpSettingValue := false\n\t\tif allowSignUpSetting != nil {\n\t\t\terr = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmarshal system setting allow signup\").SetInternal(err)\n\t\t\t}\n\t\t}\n\t\tif !allowSignUpSettingValue && hostUser != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly\").SetInternal(err)\n\t\t}\n\n\t\tuserCreate := &api.UserCreate{\n\t\t\tUsername: signup.Username,\n\t\t\tRole:     api.Role(signup.Role),\n\t\t\tNickname: signup.Username,\n\t\t\tPassword: signup.Password,\n\t\t\tOpenID:   common.GenUUID(),\n\t\t}\n\t\tif err := userCreate.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format\").SetInternal(err)\n\t\t}\n\n\t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to generate password hash\").SetInternal(err)\n\t\t}\n\n\t\tuserCreate.PasswordHash = string(passwordHash)\n\n\t\tuser, err := s.Store.CreateUser(ctx, userCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create user\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user signed up\",\n\t\t})\n\n\t\terr = setUserSession(c, user)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to set signup session\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode created user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerMemoRoutes(g *echo.Group) {\n\tg.POST(\"/memo\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tmemoCreate := &api.MemoCreate{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo request\").SetInternal(err)\n\t\t}\n\t\tif memoCreate.Content == \"\" {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Memo content shouldn't be empty\")\n\t\t}\n\n\t\tif memoCreate.Visibility == \"\" {\n\t\t\tuserSettingMemoVisibilityKey := api.UserSettingMemoVisibilityKey\n\t\t\tuserMemoVisibilitySetting, err := s.Store.FindUserSetting(ctx, &api.UserSettingFind{\n\t\t\t\tUserID: userID,\n\t\t\t\tKey:    &userSettingMemoVisibilityKey,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user setting\").SetInternal(err)\n\t\t\t}\n\n\t\t\tif userMemoVisibilitySetting != nil {\n\t\t\t\tmemoVisibility := api.Private\n\t\t\t\terr := json.Unmarshal([]byte(userMemoVisibilitySetting.Value), &memoVisibility)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmarshal user setting value\").SetInternal(err)\n\t\t\t\t}\n\t\t\t\tmemoCreate.Visibility = memoVisibility\n\t\t\t} else {\n\t\t\t\t// Private is the default memo visibility.\n\t\t\t\tmemoCreate.Visibility = api.Private\n\t\t\t}\n\t\t}\n\n\t\tmemoCreate.CreatorID = userID\n\t\tmemo, err := s.Store.CreateMemo(ctx, memoCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create memo\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"memo created\",\n\t\t})\n\n\t\tfor _, resourceID := range memoCreate.ResourceIDList {\n\t\t\tif _, err := s.Store.UpsertMemoResource(ctx, &api.MemoResourceUpsert{\n\t\t\t\tMemoID:     memo.ID,\n\t\t\t\tResourceID: resourceID,\n\t\t\t}); err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n\t\t\t}\n\t\t}\n\n\t\tmemo, err = s.Store.ComposeMemo(ctx, memo)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to compose memo\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/memo/:memoId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n\t\t}\n\t\tif memo.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tmemoPatch := &api.MemoPatch{\n\t\t\tID:        memoID,\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoPatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch memo request\").SetInternal(err)\n\t\t}\n\n\t\tmemo, err = s.Store.PatchMemo(ctx, memoPatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch memo\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resourceID := range memoPatch.ResourceIDList {\n\t\t\tif _, err := s.Store.UpsertMemoResource(ctx, &api.MemoResourceUpsert{\n\t\t\t\tMemoID:     memo.ID,\n\t\t\t\tResourceID: resourceID,\n\t\t\t}); err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n\t\t\t}\n\t\t}\n\n\t\tmemo, err = s.Store.ComposeMemo(ctx, memo)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to compose memo\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoFind := &api.MemoFind{}\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &userID\n\t\t}\n\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tif memoFind.CreatorID == nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tif memoFind.CreatorID == nil {\n\t\t\t\tmemoFind.CreatorID = &currentUserID\n\t\t\t} else {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t\t}\n\t\t}\n\n\t\trowStatus := api.RowStatus(c.QueryParam(\"rowStatus\"))\n\t\tif rowStatus != \"\" {\n\t\t\tmemoFind.RowStatus = &rowStatus\n\t\t}\n\t\tpinnedStr := c.QueryParam(\"pinned\")\n\t\tif pinnedStr != \"\" {\n\t\t\tpinned := pinnedStr == \"true\"\n\t\t\tmemoFind.Pinned = &pinned\n\t\t}\n\t\ttag := c.QueryParam(\"tag\")\n\t\tif tag != \"\" {\n\t\t\tcontentSearch := \"#\" + tag\n\t\t\tmemoFind.ContentSearch = &contentSearch\n\t\t}\n\t\tvisibilityListStr := c.QueryParam(\"visibility\")\n\t\tif visibilityListStr != \"\" {\n\t\t\tvisibilityList := []api.Visibility{}\n\t\t\tfor _, visibility := range strings.Split(visibilityListStr, \",\") {\n\t\t\t\tvisibilityList = append(visibilityList, api.Visibility(visibility))\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = visibilityList\n\t\t}\n\t\tif limit, err := strconv.Atoi(c.QueryParam(\"limit\")); err == nil {\n\t\t\tmemoFind.Limit = limit\n\t\t}\n\t\tif offset, err := strconv.Atoi(c.QueryParam(\"offset\")); err == nil {\n\t\t\tmemoFind.Offset = offset\n\t\t}\n\n\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch memo list\").SetInternal(err)\n\t\t}\n\n\t\tvar pinnedMemoList []*api.Memo\n\t\tvar unpinnedMemoList []*api.Memo\n\n\t\tfor _, memo := range list {\n\t\t\tif memo.Pinned {\n\t\t\t\tpinnedMemoList = append(pinnedMemoList, memo)\n\t\t\t} else {\n\t\t\t\tunpinnedMemoList = append(unpinnedMemoList, memo)\n\t\t\t}\n\t\t}\n\n\t\tsort.Slice(pinnedMemoList, func(i, j int) bool {\n\t\t\treturn pinnedMemoList[i].DisplayTs > pinnedMemoList[j].DisplayTs\n\t\t})\n\t\tsort.Slice(unpinnedMemoList, func(i, j int) bool {\n\t\t\treturn unpinnedMemoList[i].DisplayTs > unpinnedMemoList[j].DisplayTs\n\t\t})\n\n\t\tmemoList := []*api.Memo{}\n\t\tmemoList = append(memoList, pinnedMemoList...)\n\t\tmemoList = append(memoList, unpinnedMemoList...)\n\n\t\tif memoFind.Limit != 0 {\n\t\t\tmemoList = memoList[memoFind.Offset:common.Min(len(memoList), memoFind.Offset+memoFind.Limit)]\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memoList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/:memoId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemoFind := &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t}\n\t\tmemo, err := s.Store.FindMemo(ctx, memoFind)\n\t\tif err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Memo ID not found: %d\", memoID)).SetInternal(err)\n\t\t\t}\n\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find memo by ID: %v\", memoID)).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif memo.Visibility == api.Private {\n\t\t\tif !ok || memo.CreatorID != userID {\n\t\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"this memo is private only\")\n\t\t\t}\n\t\t} else if memo.Visibility == api.Protected {\n\t\t\tif !ok {\n\t\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"this memo is protected, missing user in session\")\n\t\t\t}\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/memo/:memoId/organizer\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tmemoOrganizerUpsert := &api.MemoOrganizerUpsert{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoOrganizerUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo organizer request\").SetInternal(err)\n\t\t}\n\t\tmemoOrganizerUpsert.MemoID = memoID\n\t\tmemoOrganizerUpsert.UserID = userID\n\n\t\terr = s.Store.UpsertMemoOrganizer(ctx, memoOrganizerUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo organizer\").SetInternal(err)\n\t\t}\n\n\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t})\n\t\tif err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Memo ID not found: %d\", memoID)).SetInternal(err)\n\t\t\t}\n\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find memo by ID: %v\", memoID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(memo)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/memo/:memoId/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tmemoResourceUpsert := &api.MemoResourceUpsert{\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(memoResourceUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo resource request\").SetInternal(err)\n\t\t}\n\t\tmemoResourceUpsert.MemoID = memoID\n\n\t\tif _, err := s.Store.UpsertMemoResource(ctx, memoResourceUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID: &memoResourceUpsert.ResourceID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/:memoId/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tMemoID: &memoID,\n\t\t}\n\t\tresourceList, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resourceList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/amount\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tnormalRowStatus := api.Normal\n\t\tmemoFind := &api.MemoFind{\n\t\t\tRowStatus: &normalRowStatus,\n\t\t}\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"userId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &userID\n\t\t}\n\n\t\tmemoList, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(len(memoList))); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo amount\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/stats\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tnormalStatus := api.Normal\n\t\tmemoFind := &api.MemoFind{\n\t\t\tRowStatus: &normalStatus,\n\t\t}\n\t\tif creatorID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\tmemoFind.CreatorID = &creatorID\n\t\t}\n\t\tif memoFind.CreatorID == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n\t\t}\n\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tif *memoFind.CreatorID != currentUserID {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t\t} else {\n\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected, api.Private}\n\t\t\t}\n\t\t}\n\n\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch memo list\").SetInternal(err)\n\t\t}\n\n\t\tdisplayTsList := []int64{}\n\t\tfor _, memo := range list {\n\t\t\tdisplayTsList = append(displayTsList, memo.DisplayTs)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(displayTsList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo stats response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/memo/all\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tmemoFind := &api.MemoFind{}\n\n\t\t_, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n\t\t} else {\n\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n\t\t}\n\n\t\tpinnedStr := c.QueryParam(\"pinned\")\n\t\tif pinnedStr != \"\" {\n\t\t\tpinned := pinnedStr == \"true\"\n\t\t\tmemoFind.Pinned = &pinned\n\t\t}\n\t\ttag := c.QueryParam(\"tag\")\n\t\tif tag != \"\" {\n\t\t\tcontentSearch := \"#\" + tag + \" \"\n\t\t\tmemoFind.ContentSearch = &contentSearch\n\t\t}\n\t\tvisibilityListStr := c.QueryParam(\"visibility\")\n\t\tif visibilityListStr != \"\" {\n\t\t\tvisibilityList := []api.Visibility{}\n\t\t\tfor _, visibility := range strings.Split(visibilityListStr, \",\") {\n\t\t\t\tvisibilityList = append(visibilityList, api.Visibility(visibility))\n\t\t\t}\n\t\t\tmemoFind.VisibilityList = visibilityList\n\t\t}\n\t\tif limit, err := strconv.Atoi(c.QueryParam(\"limit\")); err == nil {\n\t\t\tmemoFind.Limit = limit\n\t\t}\n\t\tif offset, err := strconv.Atoi(c.QueryParam(\"offset\")); err == nil {\n\t\t\tmemoFind.Offset = offset\n\t\t}\n\n\t\t// Only fetch normal status memos.\n\t\tnormalStatus := api.Normal\n\t\tmemoFind.RowStatus = &normalStatus\n\n\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch all memo list\").SetInternal(err)\n\t\t}\n\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\treturn list[i].DisplayTs > list[j].DisplayTs\n\t\t})\n\n\t\tif memoFind.Limit != 0 {\n\t\t\tlist = list[memoFind.Offset:common.Min(len(list), memoFind.Offset+memoFind.Limit)]\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode all memo list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/memo/:memoId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n\t\t}\n\t\tif memo.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tmemoDelete := &api.MemoDelete{\n\t\t\tID: memoID,\n\t\t}\n\t\tif err := s.Store.DeleteMemo(ctx, memoDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Memo ID not found: %d\", memoID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to delete memo ID: %v\", memoID)).SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n\n\tg.DELETE(\"/memo/:memoId/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Memo ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n\t\t}\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Resource ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n\t\t\tID: &memoID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n\t\t}\n\t\tif memo.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tmemoResourceDelete := &api.MemoResourceDelete{\n\t\t\tMemoID:     &memoID,\n\t\t\tResourceID: &resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteMemoResource(ctx, memoResourceDelete); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = (32 * 8) << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tCreatorID: userID,\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t}\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"resource created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID: &resourceID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresource.ID = resourceID\n\t\tresource, err = s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerShortcutRoutes(g *echo.Group) {\n\tg.POST(\"/shortcut\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tshortcutCreate := &api.ShortcutCreate{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post shortcut request\").SetInternal(err)\n\t\t}\n\n\t\tshortcutCreate.CreatorID = userID\n\t\tshortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create shortcut\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"shortcut created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n\t\t}\n\n\t\tshortcutFind := &api.ShortcutFind{\n\t\t\tID: &shortcutID,\n\t\t}\n\t\tshortcut, err := s.Store.FindShortcut(ctx, shortcutFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find shortcut\").SetInternal(err)\n\t\t}\n\t\tif shortcut.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tshortcutPatch := &api.ShortcutPatch{\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch shortcut request\").SetInternal(err)\n\t\t}\n\n\t\tshortcutPatch.ID = shortcutID\n\t\tshortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch shortcut\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/shortcut\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find shortcut\")\n\t\t}\n\t\tshortcutFind := &api.ShortcutFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\n\t\tlist, err := s.Store.FindShortcutList(ctx, shortcutFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch shortcut list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n\t\t}\n\n\t\tshortcutFind := &api.ShortcutFind{\n\t\t\tID: &shortcutID,\n\t\t}\n\t\tshortcut, err := s.Store.FindShortcut(ctx, shortcutFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch shortcut by ID %d\", *shortcutFind.ID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode shortcut response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n\t\t}\n\n\t\tshortcutFind := &api.ShortcutFind{\n\t\t\tID: &shortcutID,\n\t\t}\n\t\tshortcut, err := s.Store.FindShortcut(ctx, shortcutFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find shortcut\").SetInternal(err)\n\t\t}\n\t\tif shortcut.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tshortcutDelete := &api.ShortcutDelete{\n\t\t\tID: &shortcutID,\n\t\t}\n\t\tif err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Shortcut ID not found: %d\", shortcutID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete shortcut\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerSystemRoutes(g *echo.Group) {\n\tg.GET(\"/ping\", func(c echo.Context) error {\n\t\tdata := s.Profile\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(data)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to compose system profile\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/status\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\thostUserType := api.Host\n\t\thostUserFind := api.UserFind{\n\t\t\tRole: &hostUserType,\n\t\t}\n\t\thostUser, err := s.Store.FindUser(ctx, &hostUserFind)\n\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find host user\").SetInternal(err)\n\t\t}\n\n\t\tif hostUser != nil {\n\t\t\t// data desensitize\n\t\t\thostUser.OpenID = \"\"\n\t\t\thostUser.Email = \"\"\n\t\t}\n\n\t\tsystemStatus := api.SystemStatus{\n\t\t\tHost:             hostUser,\n\t\t\tProfile:          *s.Profile,\n\t\t\tDBSize:           0,\n\t\t\tAllowSignUp:      false,\n\t\t\tAdditionalStyle:  \"\",\n\t\t\tAdditionalScript: \"\",\n\t\t\tCustomizedProfile: api.CustomizedProfile{\n\t\t\t\tName:        \"memos\",\n\t\t\t\tLogoURL:     \"\",\n\t\t\t\tDescription: \"\",\n\t\t\t\tLocale:      \"en\",\n\t\t\t\tAppearance:  \"system\",\n\t\t\t\tExternalURL: \"\",\n\t\t\t},\n\t\t}\n\n\t\tsystemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find system setting list\").SetInternal(err)\n\t\t}\n\t\tfor _, systemSetting := range systemSettingList {\n\t\t\tvar value interface{}\n\t\t\terr := json.Unmarshal([]byte(systemSetting.Value), &value)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmarshal system setting\").SetInternal(err)\n\t\t\t}\n\n\t\t\tif systemSetting.Name == api.SystemSettingAllowSignUpName {\n\t\t\t\tsystemStatus.AllowSignUp = value.(bool)\n\t\t\t} else if systemSetting.Name == api.SystemSettingAdditionalStyleName {\n\t\t\t\tsystemStatus.AdditionalStyle = value.(string)\n\t\t\t} else if systemSetting.Name == api.SystemSettingAdditionalScriptName {\n\t\t\t\tsystemStatus.AdditionalScript = value.(string)\n\t\t\t} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {\n\t\t\t\tvalueMap := value.(map[string]interface{})\n\t\t\t\tsystemStatus.CustomizedProfile = api.CustomizedProfile{}\n\t\t\t\tif v := valueMap[\"name\"]; v != nil {\n\t\t\t\t\tsystemStatus.CustomizedProfile.Name = v.(string)\n\t\t\t\t}\n\t\t\t\tif v := valueMap[\"logoUrl\"]; v != nil {\n\t\t\t\t\tsystemStatus.CustomizedProfile.LogoURL = v.(string)\n\t\t\t\t}\n\t\t\t\tif v := valueMap[\"description\"]; v != nil {\n\t\t\t\t\tsystemStatus.CustomizedProfile.Description = v.(string)\n\t\t\t\t}\n\t\t\t\tif v := valueMap[\"locale\"]; v != nil {\n\t\t\t\t\tsystemStatus.CustomizedProfile.Locale = v.(string)\n\t\t\t\t}\n\t\t\t\tif v := valueMap[\"appearance\"]; v != nil {\n\t\t\t\t\tsystemStatus.CustomizedProfile.Appearance = v.(string)\n\t\t\t\t}\n\t\t\t\tif v := valueMap[\"externalUrl\"]; v != nil {\n\t\t\t\t\tsystemStatus.CustomizedProfile.ExternalURL = v.(string)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\t// Get database size for host user.\n\t\tif ok {\n\t\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\t\tID: &userID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t\t}\n\t\t\tif user != nil && user.Role == api.Host {\n\t\t\t\tfi, err := os.Stat(s.Profile.DSN)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read database fileinfo\").SetInternal(err)\n\t\t\t\t}\n\t\t\t\tsystemStatus.DBSize = fi.Size()\n\t\t\t}\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemStatus)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode system status response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/system/setting\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif user == nil || user.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tsystemSettingUpsert := &api.SystemSettingUpsert{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(systemSettingUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post system setting request\").SetInternal(err)\n\t\t}\n\t\tif err := systemSettingUpsert.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"system setting invalidate\").SetInternal(err)\n\t\t}\n\n\t\tsystemSetting, err := s.Store.UpsertSystemSetting(ctx, systemSettingUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert system setting\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName:   \"systemSetting updated\",\n\t\t\tLabels: map[string]string{\"field\": string(systemSettingUpsert.Name)},\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSetting)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode system setting response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/system/setting\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tsystemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find system setting list\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSettingList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode system setting list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/system/vacuum\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif user == nil || user.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\t\tif err := s.Store.Vacuum(ctx); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to vacuum database\").SetInternal(err)\n\t\t}\n\t\tc.Response().WriteHeader(http.StatusOK)\n\t\treturn nil\n\t})\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nfunc (s *Server) registerTagRoutes(g *echo.Group) {\n\tg.POST(\"/tag\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\ttagUpsert := &api.TagUpsert{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post tag request\").SetInternal(err)\n\t\t}\n\t\tif tagUpsert.Name == \"\" {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Tag name shouldn't be empty\")\n\t\t}\n\n\t\ttagUpsert.CreatorID = userID\n\t\ttag, err := s.Store.UpsertTag(ctx, tagUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert tag\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"tag created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode tag response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/tag\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\ttagFind := &api.TagFind{}\n\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\ttagFind.CreatorID = userID\n\t\t}\n\n\t\tif tagFind.CreatorID == 0 {\n\t\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\t\tif !ok {\n\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find tag\")\n\t\t\t}\n\t\t\ttagFind.CreatorID = currentUserID\n\t\t}\n\n\t\ttagList, err := s.Store.FindTagList(ctx, tagFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find tag list\").SetInternal(err)\n\t\t}\n\n\t\ttagNameList := []string{}\n\t\tfor _, tag := range tagList {\n\t\t\ttagNameList = append(tagNameList, tag.Name)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode tags response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/tag/suggestion\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user session\")\n\t\t}\n\t\tcontentSearch := \"#\"\n\t\tnormalRowStatus := api.Normal\n\t\tmemoFind := api.MemoFind{\n\t\t\tCreatorID:     &userID,\n\t\t\tContentSearch: &contentSearch,\n\t\t\tRowStatus:     &normalRowStatus,\n\t\t}\n\n\t\tmemoList, err := s.Store.FindMemoList(ctx, &memoFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)\n\t\t}\n\n\t\ttagMapSet := make(map[string]bool)\n\t\tfor _, memo := range memoList {\n\t\t\tfor _, tag := range findTagListFromMemoContent(memo.Content) {\n\t\t\t\ttagMapSet[tag] = true\n\t\t\t}\n\t\t}\n\t\ttagList := []string{}\n\t\tfor tag := range tagMapSet {\n\t\t\ttagList = append(tagList, tag)\n\t\t}\n\t\tsort.Strings(tagList)\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode tags response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/tag/:tagName\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\ttagName := c.Param(\"tagName\")\n\t\tif tagName == \"\" {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Tag name cannot be empty\")\n\t\t}\n\n\t\ttagDelete := &api.TagDelete{\n\t\t\tName:      tagName,\n\t\t\tCreatorID: userID,\n\t\t}\n\t\tif err := s.Store.DeleteTag(ctx, tagDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Tag name not found: %s\", tagName))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to delete tag name: %v\", tagName)).SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nvar tagRegexp = regexp.MustCompile(`#([^\\s#]+)`)\n\nfunc findTagListFromMemoContent(memoContent string) []string {\n\ttagMapSet := make(map[string]bool)\n\tmatches := tagRegexp.FindAllStringSubmatch(memoContent, -1)\n\tfor _, v := range matches {\n\t\ttagName := v[1]\n\t\ttagMapSet[tagName] = true\n\t}\n\n\ttagList := []string{}\n\tfor tag := range tagMapSet {\n\t\ttagList = append(tagList, tag)\n\t}\n\tsort.Strings(tagList)\n\treturn tagList\n}\n", "package server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc (s *Server) registerUserRoutes(g *echo.Group) {\n\tg.POST(\"/user\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing auth session\")\n\t\t}\n\t\tcurrentUser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user by id\").SetInternal(err)\n\t\t}\n\t\tif currentUser.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Only Host user can create member\")\n\t\t}\n\n\t\tuserCreate := &api.UserCreate{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(userCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post user request\").SetInternal(err)\n\t\t}\n\t\tif userCreate.Role == api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"Could not create host user\")\n\t\t}\n\t\tuserCreate.OpenID = common.GenUUID()\n\n\t\tif err := userCreate.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format\").SetInternal(err)\n\t\t}\n\n\t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(userCreate.Password), bcrypt.DefaultCost)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to generate password hash\").SetInternal(err)\n\t\t}\n\n\t\tuserCreate.PasswordHash = string(passwordHash)\n\t\tuser, err := s.Store.CreateUser(ctx, userCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create user\").SetInternal(err)\n\t\t}\n\t\ts.Collector.Collect(ctx, &metric.Metric{\n\t\t\tName: \"user created\",\n\t\t})\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/user\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserList, err := s.Store.FindUserList(ctx, &api.UserFind{})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch user list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, user := range userList {\n\t\t\t// data desensitize\n\t\t\tuser.OpenID = \"\"\n\t\t\tuser.Email = \"\"\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(userList)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\t// GET /api/user/me is used to check if the user is logged in.\n\tg.GET(\"/user/me\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing auth session\")\n\t\t}\n\n\t\tuserFind := &api.UserFind{\n\t\t\tID: &userID,\n\t\t}\n\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\n\t\tuserSettingList, err := s.Store.FindUserSettingList(ctx, &api.UserSettingFind{\n\t\t\tUserID: userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find userSettingList\").SetInternal(err)\n\t\t}\n\t\tuser.UserSettingList = userSettingList\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/user/setting\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing auth session\")\n\t\t}\n\n\t\tuserSettingUpsert := &api.UserSettingUpsert{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(userSettingUpsert); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post user setting upsert request\").SetInternal(err)\n\t\t}\n\t\tif err := userSettingUpsert.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user setting format\").SetInternal(err)\n\t\t}\n\n\t\tuserSettingUpsert.UserID = userID\n\t\tuserSetting, err := s.Store.UpsertUserSetting(ctx, userSettingUpsert)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert user setting\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(userSetting)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user setting response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/user/:id\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tid, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted user id\").SetInternal(err)\n\t\t}\n\n\t\tuser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &id,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch user\").SetInternal(err)\n\t\t}\n\n\t\tif user != nil {\n\t\t\t// data desensitize\n\t\t\tuser.OpenID = \"\"\n\t\t\tuser.Email = \"\"\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/user/:id\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"id\"))).SetInternal(err)\n\t\t}\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tcurrentUser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &currentUserID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif currentUser == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Current session user not found with ID: %d\", currentUserID)).SetInternal(err)\n\t\t} else if currentUser.Role != api.Host && currentUserID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"Access forbidden for current session user\").SetInternal(err)\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tuserPatch := &api.UserPatch{\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(userPatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch user request\").SetInternal(err)\n\t\t}\n\t\tuserPatch.ID = userID\n\t\tif err := userPatch.Validate(); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user patch format\").SetInternal(err)\n\t\t}\n\n\t\tif userPatch.Password != nil && *userPatch.Password != \"\" {\n\t\t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(*userPatch.Password), bcrypt.DefaultCost)\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to generate password hash\").SetInternal(err)\n\t\t\t}\n\n\t\t\tpasswordHashStr := string(passwordHash)\n\t\t\tuserPatch.PasswordHash = &passwordHashStr\n\t\t}\n\n\t\tif userPatch.ResetOpenID != nil && *userPatch.ResetOpenID {\n\t\t\topenID := common.GenUUID()\n\t\t\tuserPatch.OpenID = &openID\n\t\t}\n\n\t\tuser, err := s.Store.PatchUser(ctx, userPatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch user\").SetInternal(err)\n\t\t}\n\n\t\tuserSettingList, err := s.Store.FindUserSettingList(ctx, &api.UserSettingFind{\n\t\t\tUserID: userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find userSettingList\").SetInternal(err)\n\t\t}\n\t\tuser.UserSettingList = userSettingList\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode user response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/user/:id\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tcurrentUser, err := s.Store.FindUser(ctx, &api.UserFind{\n\t\t\tID: &currentUserID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n\t\t}\n\t\tif currentUser == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Current session user not found with ID: %d\", currentUserID)).SetInternal(err)\n\t\t} else if currentUser.Role != api.Host {\n\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"Access forbidden for current session user\").SetInternal(err)\n\t\t}\n\n\t\tuserID, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"id\"))).SetInternal(err)\n\t\t}\n\n\t\tuserDelete := &api.UserDelete{\n\t\t\tID: userID,\n\t\t}\n\t\tif err := s.Store.DeleteUser(ctx, userDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"User ID not found: %d\", userID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete user\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n"], "filenames": ["api/memo.go", "api/memo_organizer.go", "api/memo_resource.go", "api/resource.go", "api/shortcut.go", "api/tag.go", "api/user_setting.go", "server/auth.go", "server/memo.go", "server/resource.go", "server/shortcut.go", "server/system.go", "server/tag.go", "server/user.go"], "buggy_code_start_loc": [49, 11, 11, 23, 19, 10, 53, 87, 27, 58, 24, 79, 26, 32], "buggy_code_end_loc": [81, 21, 12, 24, 20, 11, 54, 118, 545, 229, 127, 131, 108, 203], "fixing_code_start_loc": [49, 12, 11, 23, 19, 10, 53, 87, 27, 59, 24, 79, 26, 32], "fixing_code_end_loc": [81, 20, 12, 24, 20, 11, 54, 118, 559, 232, 152, 140, 93, 207], "type": "CWE-648", "message": "Incorrect Use of Privileged APIs in GitHub repository usememos/memos prior to 0.9.1.", "other": {"cve": {"id": "CVE-2022-4805", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-28T14:15:10.933", "lastModified": "2023-01-05T23:53:14.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Incorrect Use of Privileged APIs in GitHub repository usememos/memos prior to 0.9.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-648"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.1", "matchCriteriaId": "7E75ADB4-9898-49F3-BF80-3C54F4CE0FB4"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/3556ae4e651d9443dc3bb8a170dd3cc726517a53", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b03f6a9b-e49b-42d6-a318-1d7afd985873", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/3556ae4e651d9443dc3bb8a170dd3cc726517a53"}}