{"buggy_code": ["<?php\n//\n// Definition of ezjscAjaxContent class\n//\n// Created on: <5-Aug-2007 00:00:00 ar>\n//\n// ## BEGIN COPYRIGHT, LICENSE AND WARRANTY NOTICE ##\n// SOFTWARE NAME: eZ JSCore extension for eZ Publish\n// SOFTWARE RELEASE: 1.x\n// COPYRIGHT NOTICE: Copyright (C) 1999-2012 eZ Systems AS\n// SOFTWARE LICENSE: GNU General Public License v2.0\n// NOTICE: >\n//   This program is free software; you can redistribute it and/or\n//   modify it under the terms of version 2.0  of the GNU General\n//   Public License as published by the Free Software Foundation.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of version 2.0 of the GNU General\n//   Public License along with this program; if not, write to the Free\n//   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n//   MA 02110-1301, USA.\n//\n//\n// ## END COPYRIGHT, LICENSE AND WARRANTY NOTICE ##\n//\n\n// Simplifying and encoding content objects / nodes to json\n// using the php json extension included in php 5.2\n\n\nclass ezjscAjaxContent\n{\n    /**\n     * Constructor\n     */\n    protected function __construct()\n    {\n    }\n\n    /**\n     * Clone\n     */\n    protected function __clone()\n    {\n    }\n\n    /**\n     * Gets the first most prefered response type as defined by http_accept\n     * uses post and get parameter if present, if not falls back to the one\n     * defined in http header. First parameter lets you define fallback value\n     * if none of the alternatives in second parameter is found. Second parameter\n     * lets you limit the allowes types with a alias hash. xhtml, json, xml and\n     * text are default allowed types.\n     *\n     * @param string $default\n     * @param array $aliasList\n     * @return string\n     */\n    public static function getHttpAccept( $default = 'xhtml', $aliasList = array( 'html' => 'xhtml',\n                                                                                  'json' => 'json',\n                                                                                  'javascript' => 'json',\n                                                                                  'xml' => 'xml',\n                                                                                  'text' => 'text' ) )\n    {\n        $acceptList = array();\n\n        if ( isset($_POST['http_accept']) )\n            $acceptList = explode( ',', $_POST['http_accept'] );\n        else if ( isset($_POST['HTTP_ACCEPT']) )\n            $acceptList = explode( ',', $_POST['HTTP_ACCEPT'] );\n        else if ( isset($_GET['http_accept']) )\n            $acceptList = explode( ',', $_GET['http_accept'] );\n        else if ( isset($_GET['HTTP_ACCEPT']) )\n            $acceptList = explode( ',', $_GET['HTTP_ACCEPT'] );\n        else if ( isset($_SERVER['HTTP_ACCEPT']) )\n            $acceptList = explode( ',', $_SERVER['HTTP_ACCEPT'] );\n\n        foreach( $acceptList as $accept )\n        {\n            foreach( $aliasList as $alias => $returnType )\n            {\n                if ( strpos( $accept, $alias ) !== false )\n                {\n                    $default = $returnType;\n                    break 2;\n                }\n            }\n        }\n        return $default;\n    }\n\n    /**\n     * Encodes the content based on http accept values, more on\n     * this on the getHttpAccept function.\n     * Will simply implode the return value if array and not xml or\n     * json is prefered return type.\n     *\n     * @param mixed $ret\n     * @param string $type\n     * @return string\n     */\n    public static function autoEncode( $ret, $type = null )\n    {\n        if ( $type === null )\n            $type = self::getHttpAccept( );\n\n        if ( $type === 'xml' )\n            return self::xmlEncode( $ret );\n        else if ( $type === 'json' )\n            return json_encode( $ret );\n        else\n            return self::textEncode( $ret );\n    }\n\n    /**\n     * Encodes mixed value to string or comma seperated list of strings\n     *\n     * @param mixed $mix\n     * @return string\n     */\n    public static function textEncode( $mix )\n    {\n        if ( is_array( $mix ) )\n            return implode(',', array_map( array('ezjscAjaxContent', 'textEncode'), array_filter( $mix ) ) );\n\n        return $mix;\n    }\n\n    /**\n     * Function for encoding content object(s) or node(s) to simplified\n     * json objects, xml or array hash\n     *\n     * @param mixed $obj\n     * @param array $params\n     * @param string $type\n     * @return mixed\n     */\n    public static function nodeEncode( $obj, $params = array(), $type = 'json' )\n    {\n        if ( is_array( $obj ) )\n        {\n            $ret = array();\n            foreach ( $obj as $ob )\n            {\n                $ret[] = self::simplify( $ob, $params );\n            }\n        }\n        else\n        {\n            $ret = self::simplify( $obj, $params );\n        }\n\n        if ( $type === 'xml' )\n            return self::xmlEncode( $ret );\n        else if ( $type === 'json' )\n            return json_encode( $ret );\n        else\n            return $ret;\n    }\n\n    /**\n     * Function for simplifying a content object or node\n     *\n     * @param mixed $obj\n     * @param array $params\n     * @return array\n     */\n    public static function simplify( $obj, $params = array() )\n    {\n        if ( !$obj )\n        {\n            return array();\n        }\n        else if ( $obj instanceof eZContentObject)\n        {\n            $node          = $obj->attribute( 'main_node' );\n            $contentObject = $obj;\n        }\n        else if ( $obj instanceof eZContentObjectTreeNode || $obj instanceof eZFindResultNode )\n        {\n            $node          = $obj;\n            $contentObject = $obj->attribute( 'object' );\n        }\n        else if( isset( $params['fetchNodeFunction'] ) && method_exists( $obj, $params['fetchNodeFunction'] ) )\n        {\n            // You can supply fetchNodeFunction parameter to be able to support other node related classes\n            $node = call_user_func( array( $obj, $params['fetchNodeFunction'] ) );\n            if ( !$node instanceof eZContentObjectTreeNode )\n            {\n                return '';\n            }\n            $contentObject = $node->attribute( 'object' );\n        }\n        else if ( is_array( $obj ) )\n        {\n            return $obj; // Array is returned as is\n        }\n        else\n        {\n            return ''; // Other passed objects are not supported\n        }\n\n        $ini = eZINI::instance( 'site.ini' );\n        $params = array_merge( array(\n                            'dataMap' => array(), // collection of identifiers you want to load, load all with array('all')\n                            'fetchPath' => false, // fetch node path\n                            'fetchSection' => false, // fetch section\n                            'fetchChildrenCount' => false,\n                            'dataMapType' => array(), //if you want to filter datamap by type\n                            'loadImages' => false,\n                            'imagePreGenerateSizes' => array('small') //Pre generated images, loading all can be quite time consuming\n        ), $params );\n\n        if ( !isset( $params['imageSizes'] ) )// list of available image sizes\n        {\n            $imageIni = eZINI::instance( 'image.ini' );\n            $params['imageSizes'] = $imageIni->variable( 'AliasSettings', 'AliasList' );\n        }\n\n        if ( $params['imageSizes'] === null || !isset( $params['imageSizes'][0] ) )\n            $params['imageSizes'] = array();\n\n        if (  !isset( $params['imageDataTypes'] ) )\n            $params['imageDataTypes'] = $ini->variable( 'ImageDataTypeSettings', 'AvailableImageDataTypes' );\n\n        $ret                            \t= array();\n        $attrtibuteArray                \t= array();\n        $ret['name']                    \t= htmlentities( $contentObject->attribute( 'name' ), ENT_QUOTES, \"UTF-8\" );\n        $ret['contentobject_id']        \t= $ret['id'] = (int) $contentObject->attribute( 'id' );\n        $ret['contentobject_remote_id'] \t= $contentObject->attribute( 'remote_id' );\n        $ret['contentobject_state']     \t= implode( \", \", $contentObject->attribute( 'state_identifier_array' ) );\n        $ret['main_node_id']            \t= (int)$contentObject->attribute( 'main_node_id' );\n        $ret['version']                 \t= (int)$contentObject->attribute( 'current_version' );\n        $ret['modified']                \t= $contentObject->attribute( 'modified' );\n        $ret['published']               \t= $contentObject->attribute( 'published' );\n        $ret['section_id']              \t= (int) $contentObject->attribute( 'section_id' );\n        $ret['current_language']        \t= $contentObject->attribute( 'current_language' );\n        $ret['owner_id']                \t= (int) $contentObject->attribute( 'owner_id' );\n        $ret['class_id']                \t= (int) $contentObject->attribute( 'contentclass_id' );\n        $ret['class_name']              \t= $contentObject->attribute( 'class_name' );\n        $ret['path_identification_string'] \t= $node->attribute( 'path_identification_string' );\n        $ret['translations']            \t= eZContentLanguage::decodeLanguageMask($contentObject->attribute( 'language_mask' ), true);\n        $ret['can_edit']                \t= $contentObject->attribute( 'can_edit' );\n\n        if ( isset( $params['formatDate'] ) )\n        {\n            $ret['modified_date'] = self::formatLocaleDate( $contentObject->attribute( 'modified' ), $params['formatDate'] );\n            $ret['published_date'] = self::formatLocaleDate( $contentObject->attribute( 'published' ), $params['formatDate'] );\n        }\n\n        if ( isset( $params['fetchCreator'] ) )\n        {\n            $creator = $contentObject->attribute( 'current' )->attribute('creator');\n            if ( $creator instanceof eZContentObject )\n            {\n                $ret['creator'] = array( 'id'   => $creator->attribute( 'id' ),\n                                         'name' => $creator->attribute('name') );\n            }\n            else\n            {\n                $ret['creator'] = array( 'id'   => $contentObject->attribute( 'creator_id' ),\n                                         'name' => null );// user has been deleted\n            }\n        }\n\n        if ( isset( $params['fetchClassIcon'] ) )\n        {\n            $operator = new eZWordToImageOperator();\n            $tpl = eZTemplate::instance();\n\n            $operatorValue = $contentObject->attribute( 'class_identifier' );\n\n            $operatorParameters = array( array( array( 1, 'small' ) ) );\n            $namedParameters = array();\n\n            $operatorName = 'class_icon';\n\n            $operator->modify(\n                $tpl, $operatorName, $operatorParameters, '', '',\n                $operatorValue, $namedParameters, array()\n            );\n\n            $ret['class_icon'] = $operatorValue;\n        }\n\n        if ( isset( $params['fetchThumbPreview'] ) )\n        {\n            $thumbUrl = '';\n            $thumbWidth = 0;\n            $thumbHeight = 0;\n            $thumbDataType = isset( $params['thumbDataType'] ) ? $params['thumbDataType'] : 'ezimage';\n            $thumbImageSize = isset( $params['thumbImageSize'] ) ? $params['thumbImageSize'] : 'small';\n\n            foreach( $contentObject->attribute( 'data_map' ) as $key => $atr )\n            {\n                if ( $atr->attribute( 'data_type_string' ) == $thumbDataType\n                        && $atr->attribute( 'has_content' ) )\n                {\n                    $imageContent = $atr->attribute( 'content' );\n\n                    if ( $imageContent->hasAttribute( $thumbImageSize ) )\n                        $imageAlias = $imageContent->attribute( $thumbImageSize );\n                    else\n                        eZDebug::writeError( \"Image alias does not exist: '{$thumbImageSize}', missing from image.ini?\",\n                            __METHOD__ );\n\n                    $thumbUrl = isset( $imageAlias['full_path'] ) ? $imageAlias['full_path'] : '';\n                    $thumbWidth = isset( $imageAlias['width'] ) ? (int) $imageAlias['width'] : 0;\n                    $thumbHeight = isset( $imageAlias['height'] ) ? (int) $imageAlias['height'] : 0;\n\n                    if ( $thumbUrl !== '' )\n                        eZURI::transformURI( $thumbUrl, true );\n\n                    break;\n                }\n            }\n\n            $ret['thumbnail_url'] = $thumbUrl;\n            $ret['thumbnail_width'] = $thumbWidth;\n            $ret['thumbnail_height'] = $thumbHeight;\n        }\n\n        if ( $params['fetchSection'] )\n        {\n            $section = eZSection::fetch( $ret['section_id']  );\n            if ( $section instanceof eZSection )\n            {\n                $ret['section'] = array(\n                    'id'                         => $section->attribute('id'),\n                    'name'                       => $section->attribute('name'),\n                    'navigation_part_identifier' => $section->attribute('navigation_part_identifier'),\n                    'locale'                     => $section->attribute('locale'),\n                );\n            }\n            else\n            {\n                $ret['section'] = null;\n            }\n        }\n\n        if ( $node )\n        {\n            // optimization for eZ Publish 4.1 (avoid fetching class)\n            if ( $node->hasAttribute( 'is_container' ) )\n            {\n                $ret['class_identifier'] = $node->attribute( 'class_identifier' );\n                $ret['is_container']     = (int) $node->attribute( 'is_container' );\n            }\n            else\n            {\n                $class                   = $contentObject->attribute( 'content_class' );\n                $ret['class_identifier'] = $class->attribute( 'identifier' );\n                $ret['is_container']     = (int) $class->attribute( 'is_container' );\n            }\n\n            $ret['node_id']              = (int) $node->attribute( 'node_id' );\n            $ret['parent_node_id']       = (int) $node->attribute( 'parent_node_id' );\n            $ret['node_remote_id']       = $node->attribute( 'remote_id' );\n            $ret['url_alias']            = $node->attribute( 'url_alias' );\n            $ret['url']                  = $node->url();\n            // force system url on empty urls (root node)\n            if ( $ret['url'] === '' )\n                $ret['url'] = 'content/view/full/' . $node->attribute( 'node_id' );\n            eZURI::transformURI( $ret['url'] );\n\n            $ret['depth']                = (int) $node->attribute( 'depth' );\n            $ret['priority']             = (int) $node->attribute( 'priority' );\n            $ret['hidden_status_string'] = $node->attribute( 'hidden_status_string' );\n\n            if ( $params['fetchPath'] )\n            {\n                $ret['path'] = array();\n                foreach ( $node->attribute( 'path' ) as $n )\n                {\n                    $ret['path'][] = self::simplify( $n );\n                }\n            }\n            else\n            {\n                $ret['path'] = false;\n            }\n\n            if ( $params['fetchChildrenCount'] )\n            {\n                $ret['children_count'] = $ret['is_container'] ? (int) $node->attribute( 'children_count' ) : 0;\n            }\n            else\n            {\n                $ret['children_count'] = false;\n            }\n        }\n        else\n        {\n            $class                   = $contentObject->attribute( 'content_class' );\n            $ret['class_identifier'] = $class->attribute( 'identifier' );\n            $ret['is_container']     = (int) $class->attribute( 'is_container' );\n        }\n\n        $ret['image_attributes'] = array();\n\n        if ( is_array( $params['dataMap'] ) && is_array(  $params['dataMapType'] ) )\n        {\n            $dataMap = $contentObject->attribute( 'data_map' );\n            $datatypeBlacklist = array_fill_keys(\n                $ini->variable( 'ContentSettings', 'DatatypeBlackListForExternal' ),\n                true\n            );\n            foreach( $dataMap as $key => $atr )\n            {\n                $dataTypeString = $atr->attribute( 'data_type_string' );\n                //if ( in_array( $dataTypeString, $params['imageDataTypes'], true) !== false )\n\n                if ( !in_array( 'all' ,$params['dataMap'], true )\n                   && !in_array( $key ,$params['dataMap'], true )\n                   && !in_array( $dataTypeString, $params['dataMapType'], true )\n                   && !( $params['loadImages'] && in_array( $dataTypeString, $params['imageDataTypes'], true ) ) )\n                {\n                    continue;\n                }\n\n                $attrtibuteArray[ $key ]['id']         = $atr->attribute( 'id' );\n                $attrtibuteArray[ $key ]['type']       = $dataTypeString;\n                $attrtibuteArray[ $key ]['identifier'] = $key;\n                if ( isset ( $datatypeBlacklist[$dataTypeString] ) )\n                    $attrtibuteArray[ $key ]['content'] = null;\n                else\n                    $attrtibuteArray[ $key ]['content'] = $atr->toString();\n\n                // images\n                if ( in_array( $dataTypeString, $params['imageDataTypes'], true) && $atr->hasContent() )\n                {\n                    $content    = $atr->attribute( 'content' );\n                    $imageArray = array();\n                    if ( $content != null )\n                    {\n                        foreach( $params['imageSizes'] as $size )\n                        {\n                            $imageArray[ $size ] = false;\n                            if ( in_array( $size, $params['imagePreGenerateSizes'], true ) )\n                            {\n                                if ( $content->hasAttribute( $size ) )\n                                    $imageArray[ $size ] = $content->attribute( $size );\n                                else\n                                    eZDebug::writeError( \"Image alias does not exist: '$size', missing from image.ini?\",\n                                        __METHOD__ );\n                            }\n                        }\n                        $ret['image_attributes'][] = $key;\n                    }\n\n                    if ( !isset( $imageArray['original'] ) )\n                        $imageArray['original'] = $content->attribute( 'original' );\n\n                    $attrtibuteArray[ $key ]['content'] = $imageArray;\n                }\n            }\n        }\n        $ret['data_map'] = $attrtibuteArray;\n        return $ret;\n    }\n\n    /**\n     * Encodes simple multilevel array and hash values to valid xml string\n     *\n     * @param mixed $hash\n     * @param string $childName\n     * @return string\n    */\n    public static function xmlEncode( $hash, $childName = 'child' )\n    {\n        $xml = new XmlWriter();\n        $xml->openMemory();\n        $xml->startDocument('1.0', 'UTF-8');\n        $xml->startElement('root');\n\n        self::xmlWrite( $xml, $hash, $childName );\n\n        $xml->endElement();\n        return $xml->outputMemory( true );\n\n    }\n\n    /**\n     * Recursive xmlWriter function called by xmlEncode\n     *\n     * @param XMLWriter $xml\n     * @param mixed $hash\n     * @param string $childName\n    */\n    protected static function xmlWrite( XMLWriter $xml, $hash, $childName = 'child' )\n    {\n        foreach( $hash as $key => $value )\n        {\n            if( is_array( $value ) )\n            {\n               if ( is_numeric( $key ) )\n                   $xml->startElement( $childName );\n               else\n                   $xml->startElement( $key );\n                self::xmlWrite( $xml, $value );\n                $xml->endElement();\n                continue;\n            }\n            if ( is_numeric( $key ) )\n            {\n                $xml->writeElement( $childName, $value );\n            }\n            else\n            {\n                $xml->writeElement( $key, $value );\n            }\n        }\n    }\n\n    /**\n     * Format date timestamp according to currently used locale code\n     * Allowed are following types:\n     * - time\n     * - shorttime\n     * - date\n     * - shortdate\n     * - datetime\n     * - shortdatetime\n     *\n     * @param integer $timestamp\n     * @param string $type\n     * @return string\n     */\n    public static function formatLocaleDate( $timestamp, $type )\n    {\n        $formattedDate = null;\n\n        $locale = eZLocale::instance();\n\n        $method = $locale->getFormattingFunction( $type );\n        if ( $method )\n            $formattedDate = $locale->$method( $timestamp );\n\n        return $formattedDate;\n    }\n}\n\n?>\n"], "fixing_code": ["<?php\n//\n// Definition of ezjscAjaxContent class\n//\n// Created on: <5-Aug-2007 00:00:00 ar>\n//\n// ## BEGIN COPYRIGHT, LICENSE AND WARRANTY NOTICE ##\n// SOFTWARE NAME: eZ JSCore extension for eZ Publish\n// SOFTWARE RELEASE: 1.x\n// COPYRIGHT NOTICE: Copyright (C) 1999-2012 eZ Systems AS\n// SOFTWARE LICENSE: GNU General Public License v2.0\n// NOTICE: >\n//   This program is free software; you can redistribute it and/or\n//   modify it under the terms of version 2.0  of the GNU General\n//   Public License as published by the Free Software Foundation.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of version 2.0 of the GNU General\n//   Public License along with this program; if not, write to the Free\n//   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n//   MA 02110-1301, USA.\n//\n//\n// ## END COPYRIGHT, LICENSE AND WARRANTY NOTICE ##\n//\n\n// Simplifying and encoding content objects / nodes to json\n// using the php json extension included in php 5.2\n\n\nclass ezjscAjaxContent\n{\n    /**\n     * Constructor\n     */\n    protected function __construct()\n    {\n    }\n\n    /**\n     * Clone\n     */\n    protected function __clone()\n    {\n    }\n\n    /**\n     * Gets the first most prefered response type as defined by http_accept\n     * uses post and get parameter if present, if not falls back to the one\n     * defined in http header. First parameter lets you define fallback value\n     * if none of the alternatives in second parameter is found. Second parameter\n     * lets you limit the allowes types with a alias hash. xhtml, json, xml and\n     * text are default allowed types.\n     *\n     * @param string $default\n     * @param array $aliasList\n     * @return string\n     */\n    public static function getHttpAccept( $default = 'xhtml', $aliasList = array( 'html' => 'xhtml',\n                                                                                  'json' => 'json',\n                                                                                  'javascript' => 'json',\n                                                                                  'xml' => 'xml',\n                                                                                  'text' => 'text' ) )\n    {\n        $acceptList = array();\n\n        if ( isset($_POST['http_accept']) )\n            $acceptList = explode( ',', $_POST['http_accept'] );\n        else if ( isset($_POST['HTTP_ACCEPT']) )\n            $acceptList = explode( ',', $_POST['HTTP_ACCEPT'] );\n        else if ( isset($_GET['http_accept']) )\n            $acceptList = explode( ',', $_GET['http_accept'] );\n        else if ( isset($_GET['HTTP_ACCEPT']) )\n            $acceptList = explode( ',', $_GET['HTTP_ACCEPT'] );\n        else if ( isset($_SERVER['HTTP_ACCEPT']) )\n            $acceptList = explode( ',', $_SERVER['HTTP_ACCEPT'] );\n\n        foreach( $acceptList as $accept )\n        {\n            foreach( $aliasList as $alias => $returnType )\n            {\n                if ( strpos( $accept, $alias ) !== false )\n                {\n                    $default = $returnType;\n                    break 2;\n                }\n            }\n        }\n        return $default;\n    }\n\n    /**\n     * Encodes the content based on http accept values, more on\n     * this on the getHttpAccept function.\n     * Will simply implode the return value if array and not xml or\n     * json is prefered return type.\n     *\n     * @param mixed $ret\n     * @param string $type\n     * @return string\n     */\n    public static function autoEncode( $ret, $type = null )\n    {\n        if ( $type === null )\n            $type = self::getHttpAccept( );\n\n        if ( $type === 'xml' )\n            return self::xmlEncode( $ret );\n        else if ( $type === 'json' )\n            return json_encode( $ret );\n        else\n            return self::textEncode( $ret );\n    }\n\n    /**\n     * Encodes mixed value to string or comma seperated list of strings\n     *\n     * @param mixed $mix\n     * @return string\n     */\n    public static function textEncode( $mix )\n    {\n        if ( is_array( $mix ) )\n            return implode(',', array_map( array('ezjscAjaxContent', 'textEncode'), array_filter( $mix ) ) );\n\n        return htmlspecialchars( $mix );\n    }\n\n    /**\n     * Function for encoding content object(s) or node(s) to simplified\n     * json objects, xml or array hash\n     *\n     * @param mixed $obj\n     * @param array $params\n     * @param string $type\n     * @return mixed\n     */\n    public static function nodeEncode( $obj, $params = array(), $type = 'json' )\n    {\n        if ( is_array( $obj ) )\n        {\n            $ret = array();\n            foreach ( $obj as $ob )\n            {\n                $ret[] = self::simplify( $ob, $params );\n            }\n        }\n        else\n        {\n            $ret = self::simplify( $obj, $params );\n        }\n\n        if ( $type === 'xml' )\n            return self::xmlEncode( $ret );\n        else if ( $type === 'json' )\n            return json_encode( $ret );\n        else\n            return $ret;\n    }\n\n    /**\n     * Function for simplifying a content object or node\n     *\n     * @param mixed $obj\n     * @param array $params\n     * @return array\n     */\n    public static function simplify( $obj, $params = array() )\n    {\n        if ( !$obj )\n        {\n            return array();\n        }\n        else if ( $obj instanceof eZContentObject)\n        {\n            $node          = $obj->attribute( 'main_node' );\n            $contentObject = $obj;\n        }\n        else if ( $obj instanceof eZContentObjectTreeNode || $obj instanceof eZFindResultNode )\n        {\n            $node          = $obj;\n            $contentObject = $obj->attribute( 'object' );\n        }\n        else if( isset( $params['fetchNodeFunction'] ) && method_exists( $obj, $params['fetchNodeFunction'] ) )\n        {\n            // You can supply fetchNodeFunction parameter to be able to support other node related classes\n            $node = call_user_func( array( $obj, $params['fetchNodeFunction'] ) );\n            if ( !$node instanceof eZContentObjectTreeNode )\n            {\n                return '';\n            }\n            $contentObject = $node->attribute( 'object' );\n        }\n        else if ( is_array( $obj ) )\n        {\n            return $obj; // Array is returned as is\n        }\n        else\n        {\n            return ''; // Other passed objects are not supported\n        }\n\n        $ini = eZINI::instance( 'site.ini' );\n        $params = array_merge( array(\n                            'dataMap' => array(), // collection of identifiers you want to load, load all with array('all')\n                            'fetchPath' => false, // fetch node path\n                            'fetchSection' => false, // fetch section\n                            'fetchChildrenCount' => false,\n                            'dataMapType' => array(), //if you want to filter datamap by type\n                            'loadImages' => false,\n                            'imagePreGenerateSizes' => array('small') //Pre generated images, loading all can be quite time consuming\n        ), $params );\n\n        if ( !isset( $params['imageSizes'] ) )// list of available image sizes\n        {\n            $imageIni = eZINI::instance( 'image.ini' );\n            $params['imageSizes'] = $imageIni->variable( 'AliasSettings', 'AliasList' );\n        }\n\n        if ( $params['imageSizes'] === null || !isset( $params['imageSizes'][0] ) )\n            $params['imageSizes'] = array();\n\n        if (  !isset( $params['imageDataTypes'] ) )\n            $params['imageDataTypes'] = $ini->variable( 'ImageDataTypeSettings', 'AvailableImageDataTypes' );\n\n        $ret                            \t= array();\n        $attrtibuteArray                \t= array();\n        $ret['name']                    \t= htmlentities( $contentObject->attribute( 'name' ), ENT_QUOTES, \"UTF-8\" );\n        $ret['contentobject_id']        \t= $ret['id'] = (int) $contentObject->attribute( 'id' );\n        $ret['contentobject_remote_id'] \t= $contentObject->attribute( 'remote_id' );\n        $ret['contentobject_state']     \t= implode( \", \", $contentObject->attribute( 'state_identifier_array' ) );\n        $ret['main_node_id']            \t= (int)$contentObject->attribute( 'main_node_id' );\n        $ret['version']                 \t= (int)$contentObject->attribute( 'current_version' );\n        $ret['modified']                \t= $contentObject->attribute( 'modified' );\n        $ret['published']               \t= $contentObject->attribute( 'published' );\n        $ret['section_id']              \t= (int) $contentObject->attribute( 'section_id' );\n        $ret['current_language']        \t= $contentObject->attribute( 'current_language' );\n        $ret['owner_id']                \t= (int) $contentObject->attribute( 'owner_id' );\n        $ret['class_id']                \t= (int) $contentObject->attribute( 'contentclass_id' );\n        $ret['class_name']              \t= $contentObject->attribute( 'class_name' );\n        $ret['path_identification_string'] \t= $node->attribute( 'path_identification_string' );\n        $ret['translations']            \t= eZContentLanguage::decodeLanguageMask($contentObject->attribute( 'language_mask' ), true);\n        $ret['can_edit']                \t= $contentObject->attribute( 'can_edit' );\n\n        if ( isset( $params['formatDate'] ) )\n        {\n            $ret['modified_date'] = self::formatLocaleDate( $contentObject->attribute( 'modified' ), $params['formatDate'] );\n            $ret['published_date'] = self::formatLocaleDate( $contentObject->attribute( 'published' ), $params['formatDate'] );\n        }\n\n        if ( isset( $params['fetchCreator'] ) )\n        {\n            $creator = $contentObject->attribute( 'current' )->attribute('creator');\n            if ( $creator instanceof eZContentObject )\n            {\n                $ret['creator'] = array( 'id'   => $creator->attribute( 'id' ),\n                                         'name' => $creator->attribute('name') );\n            }\n            else\n            {\n                $ret['creator'] = array( 'id'   => $contentObject->attribute( 'creator_id' ),\n                                         'name' => null );// user has been deleted\n            }\n        }\n\n        if ( isset( $params['fetchClassIcon'] ) )\n        {\n            $operator = new eZWordToImageOperator();\n            $tpl = eZTemplate::instance();\n\n            $operatorValue = $contentObject->attribute( 'class_identifier' );\n\n            $operatorParameters = array( array( array( 1, 'small' ) ) );\n            $namedParameters = array();\n\n            $operatorName = 'class_icon';\n\n            $operator->modify(\n                $tpl, $operatorName, $operatorParameters, '', '',\n                $operatorValue, $namedParameters, array()\n            );\n\n            $ret['class_icon'] = $operatorValue;\n        }\n\n        if ( isset( $params['fetchThumbPreview'] ) )\n        {\n            $thumbUrl = '';\n            $thumbWidth = 0;\n            $thumbHeight = 0;\n            $thumbDataType = isset( $params['thumbDataType'] ) ? $params['thumbDataType'] : 'ezimage';\n            $thumbImageSize = isset( $params['thumbImageSize'] ) ? $params['thumbImageSize'] : 'small';\n\n            foreach( $contentObject->attribute( 'data_map' ) as $key => $atr )\n            {\n                if ( $atr->attribute( 'data_type_string' ) == $thumbDataType\n                        && $atr->attribute( 'has_content' ) )\n                {\n                    $imageContent = $atr->attribute( 'content' );\n\n                    if ( $imageContent->hasAttribute( $thumbImageSize ) )\n                        $imageAlias = $imageContent->attribute( $thumbImageSize );\n                    else\n                        eZDebug::writeError( \"Image alias does not exist: '{$thumbImageSize}', missing from image.ini?\",\n                            __METHOD__ );\n\n                    $thumbUrl = isset( $imageAlias['full_path'] ) ? $imageAlias['full_path'] : '';\n                    $thumbWidth = isset( $imageAlias['width'] ) ? (int) $imageAlias['width'] : 0;\n                    $thumbHeight = isset( $imageAlias['height'] ) ? (int) $imageAlias['height'] : 0;\n\n                    if ( $thumbUrl !== '' )\n                        eZURI::transformURI( $thumbUrl, true );\n\n                    break;\n                }\n            }\n\n            $ret['thumbnail_url'] = $thumbUrl;\n            $ret['thumbnail_width'] = $thumbWidth;\n            $ret['thumbnail_height'] = $thumbHeight;\n        }\n\n        if ( $params['fetchSection'] )\n        {\n            $section = eZSection::fetch( $ret['section_id']  );\n            if ( $section instanceof eZSection )\n            {\n                $ret['section'] = array(\n                    'id'                         => $section->attribute('id'),\n                    'name'                       => $section->attribute('name'),\n                    'navigation_part_identifier' => $section->attribute('navigation_part_identifier'),\n                    'locale'                     => $section->attribute('locale'),\n                );\n            }\n            else\n            {\n                $ret['section'] = null;\n            }\n        }\n\n        if ( $node )\n        {\n            // optimization for eZ Publish 4.1 (avoid fetching class)\n            if ( $node->hasAttribute( 'is_container' ) )\n            {\n                $ret['class_identifier'] = $node->attribute( 'class_identifier' );\n                $ret['is_container']     = (int) $node->attribute( 'is_container' );\n            }\n            else\n            {\n                $class                   = $contentObject->attribute( 'content_class' );\n                $ret['class_identifier'] = $class->attribute( 'identifier' );\n                $ret['is_container']     = (int) $class->attribute( 'is_container' );\n            }\n\n            $ret['node_id']              = (int) $node->attribute( 'node_id' );\n            $ret['parent_node_id']       = (int) $node->attribute( 'parent_node_id' );\n            $ret['node_remote_id']       = $node->attribute( 'remote_id' );\n            $ret['url_alias']            = $node->attribute( 'url_alias' );\n            $ret['url']                  = $node->url();\n            // force system url on empty urls (root node)\n            if ( $ret['url'] === '' )\n                $ret['url'] = 'content/view/full/' . $node->attribute( 'node_id' );\n            eZURI::transformURI( $ret['url'] );\n\n            $ret['depth']                = (int) $node->attribute( 'depth' );\n            $ret['priority']             = (int) $node->attribute( 'priority' );\n            $ret['hidden_status_string'] = $node->attribute( 'hidden_status_string' );\n\n            if ( $params['fetchPath'] )\n            {\n                $ret['path'] = array();\n                foreach ( $node->attribute( 'path' ) as $n )\n                {\n                    $ret['path'][] = self::simplify( $n );\n                }\n            }\n            else\n            {\n                $ret['path'] = false;\n            }\n\n            if ( $params['fetchChildrenCount'] )\n            {\n                $ret['children_count'] = $ret['is_container'] ? (int) $node->attribute( 'children_count' ) : 0;\n            }\n            else\n            {\n                $ret['children_count'] = false;\n            }\n        }\n        else\n        {\n            $class                   = $contentObject->attribute( 'content_class' );\n            $ret['class_identifier'] = $class->attribute( 'identifier' );\n            $ret['is_container']     = (int) $class->attribute( 'is_container' );\n        }\n\n        $ret['image_attributes'] = array();\n\n        if ( is_array( $params['dataMap'] ) && is_array(  $params['dataMapType'] ) )\n        {\n            $dataMap = $contentObject->attribute( 'data_map' );\n            $datatypeBlacklist = array_fill_keys(\n                $ini->variable( 'ContentSettings', 'DatatypeBlackListForExternal' ),\n                true\n            );\n            foreach( $dataMap as $key => $atr )\n            {\n                $dataTypeString = $atr->attribute( 'data_type_string' );\n                //if ( in_array( $dataTypeString, $params['imageDataTypes'], true) !== false )\n\n                if ( !in_array( 'all' ,$params['dataMap'], true )\n                   && !in_array( $key ,$params['dataMap'], true )\n                   && !in_array( $dataTypeString, $params['dataMapType'], true )\n                   && !( $params['loadImages'] && in_array( $dataTypeString, $params['imageDataTypes'], true ) ) )\n                {\n                    continue;\n                }\n\n                $attrtibuteArray[ $key ]['id']         = $atr->attribute( 'id' );\n                $attrtibuteArray[ $key ]['type']       = $dataTypeString;\n                $attrtibuteArray[ $key ]['identifier'] = $key;\n                if ( isset ( $datatypeBlacklist[$dataTypeString] ) )\n                    $attrtibuteArray[ $key ]['content'] = null;\n                else\n                    $attrtibuteArray[ $key ]['content'] = $atr->toString();\n\n                // images\n                if ( in_array( $dataTypeString, $params['imageDataTypes'], true) && $atr->hasContent() )\n                {\n                    $content    = $atr->attribute( 'content' );\n                    $imageArray = array();\n                    if ( $content != null )\n                    {\n                        foreach( $params['imageSizes'] as $size )\n                        {\n                            $imageArray[ $size ] = false;\n                            if ( in_array( $size, $params['imagePreGenerateSizes'], true ) )\n                            {\n                                if ( $content->hasAttribute( $size ) )\n                                    $imageArray[ $size ] = $content->attribute( $size );\n                                else\n                                    eZDebug::writeError( \"Image alias does not exist: '$size', missing from image.ini?\",\n                                        __METHOD__ );\n                            }\n                        }\n                        $ret['image_attributes'][] = $key;\n                    }\n\n                    if ( !isset( $imageArray['original'] ) )\n                        $imageArray['original'] = $content->attribute( 'original' );\n\n                    $attrtibuteArray[ $key ]['content'] = $imageArray;\n                }\n            }\n        }\n        $ret['data_map'] = $attrtibuteArray;\n        return $ret;\n    }\n\n    /**\n     * Encodes simple multilevel array and hash values to valid xml string\n     *\n     * @param mixed $hash\n     * @param string $childName\n     * @return string\n    */\n    public static function xmlEncode( $hash, $childName = 'child' )\n    {\n        $xml = new XmlWriter();\n        $xml->openMemory();\n        $xml->startDocument('1.0', 'UTF-8');\n        $xml->startElement('root');\n\n        self::xmlWrite( $xml, $hash, $childName );\n\n        $xml->endElement();\n        return $xml->outputMemory( true );\n\n    }\n\n    /**\n     * Recursive xmlWriter function called by xmlEncode\n     *\n     * @param XMLWriter $xml\n     * @param mixed $hash\n     * @param string $childName\n    */\n    protected static function xmlWrite( XMLWriter $xml, $hash, $childName = 'child' )\n    {\n        foreach( $hash as $key => $value )\n        {\n            if( is_array( $value ) )\n            {\n               if ( is_numeric( $key ) )\n                   $xml->startElement( $childName );\n               else\n                   $xml->startElement( $key );\n                self::xmlWrite( $xml, $value );\n                $xml->endElement();\n                continue;\n            }\n            if ( is_numeric( $key ) )\n            {\n                $xml->writeElement( $childName, $value );\n            }\n            else\n            {\n                $xml->writeElement( $key, $value );\n            }\n        }\n    }\n\n    /**\n     * Format date timestamp according to currently used locale code\n     * Allowed are following types:\n     * - time\n     * - shorttime\n     * - date\n     * - shortdate\n     * - datetime\n     * - shortdatetime\n     *\n     * @param integer $timestamp\n     * @param string $type\n     * @return string\n     */\n    public static function formatLocaleDate( $timestamp, $type )\n    {\n        $formattedDate = null;\n\n        $locale = eZLocale::instance();\n\n        $method = $locale->getFormattingFunction( $type );\n        if ( $method )\n            $formattedDate = $locale->$method( $timestamp );\n\n        return $formattedDate;\n    }\n}\n\n?>\n"], "filenames": ["classes/ezjscajaxcontent.php"], "buggy_code_start_loc": [130], "buggy_code_end_loc": [131], "fixing_code_start_loc": [130], "fixing_code_end_loc": [131], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in the textEncode function in classes/ezjscajaxcontent.php in eZ JS Core in eZ Publish before 1.5 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.", "other": {"cve": {"id": "CVE-2012-1597", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-17T00:55:02.657", "lastModified": "2012-08-17T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in the textEncode function in classes/ezjscajaxcontent.php in eZ JS Core in eZ Publish before 1.5 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors."}, {"lang": "es", "value": "Una vulnerabilidad de ejecuci\u00f3n de comandos en sitios cruzados (XSS) en la funci\u00f3n textEncode en classes/ezjscajaxcontent.php en eZ Core JS en eZ Publish antes de v1.5 permite a atacantes remotos inyectar secuencias de comandos web o HTML a trav\u00e9s de vectores no especificados.\r\n"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ez:ezjscore:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4", "matchCriteriaId": "DB738B7E-03B5-4316-B4F5-8241AA6628ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ez:ezjscore:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "09CA3EAC-28D2-4E0F-A5F0-6973C5F41DA5"}]}]}], "references": [{"url": "http://share.ez.no/community-project/security-advisories/ezsa-2012-006-xss-exploit-on-ezjscore-run-command-when-using-firefox", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/05/11/6", "source": "secalert@redhat.com"}, {"url": "https://github.com/ezsystems/ezjscore/commit/58854564c7b8672090c25c4b1677d08620d870f2", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/ezsystems/ezjscore/commit/58854564c7b8672090c25c4b1677d08620d870f2"}}