{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            Y   Y  U   U  V   V                              %\n%                             Y Y   U   U  V   V                              %\n%                              Y    U   U  V   V                              %\n%                              Y    U   U   V V                               %\n%                              Y     UUU     V                                %\n%                                                                             %\n%                                                                             %\n%            Read/Write Raw CCIR 601 4:1:1 or 4:2:2 Image Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteYUVImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d Y U V I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadYUVImage() reads an image with digital YUV (CCIR 601 4:1:1, plane\n%  or partition interlaced, or 4:2:2 plane, partition interlaced or\n%  noninterlaced) bytes and returns it.  It allocates the memory necessary\n%  for the new Image structure and returns a pointer to the new image.\n%\n%  The format of the ReadYUVImage method is:\n%\n%      Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *image,\n    *resize_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *chroma_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  size_t\n    length,\n    quantum;\n\n  unsigned char\n    *scanline;\n\n  /*\n    Allocate image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  quantum=(ssize_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image_info->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowReaderException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open image file.\n      */\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,(MagickSizeType) image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Allocate memory for a scanline.\n  */\n  if (interlace == NoInterlace)\n    scanline=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      image->columns+2UL),(size_t) quantum*sizeof(*scanline));\n  else\n    scanline=(unsigned char *) AcquireQuantumMemory(image->columns,\n      (size_t) quantum*sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  do\n  {\n    chroma_image=CloneImage(image,(image->columns+horizontal_factor-1)/\n      horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n      MagickTrue,exception);\n    if (chroma_image == (Image *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    /*\n      Convert raster image to pixel packets.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      {\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *chroma_pixels;\n\n      if (interlace == NoInterlace)\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=2*quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          chroma_pixels=QueueAuthenticPixels(chroma_image,0,y,\n            chroma_image->columns,1,exception);\n          if (chroma_pixels == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=2)\n          {\n            SetPixelRed(chroma_image,0,chroma_pixels);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),\n                chroma_pixels);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            if (quantum == 1)\n              SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),chroma_pixels);\n            else\n              {\n                SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            chroma_pixels+=GetPixelChannels(chroma_image);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (interlace == NoInterlace)\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (interlace == PartitionInterlace)\n      {\n        (void) CloseBlob(image);\n        AppendImageFormat(\"U\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    if (interlace != NoInterlace)\n      {\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          length=quantum*chroma_image->columns;\n          count=ReadBlob(image,length,scanline);\n          if (count != (ssize_t) length)\n            {\n              status=MagickFalse;\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            SetPixelRed(chroma_image,0,q);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),q);\n                p+=2;\n              }\n            SetPixelBlue(chroma_image,0,q);\n            q+=GetPixelChannels(chroma_image);\n          }\n          if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n            break;\n        }\n      if (interlace == PartitionInterlace)\n        {\n          (void) CloseBlob(image);\n          AppendImageFormat(\"V\",image->filename);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImageList(image);\n              return((Image *) NULL);\n            }\n        }\n      for (y=0; y < (ssize_t) chroma_image->rows; y++)\n      {\n        length=quantum*chroma_image->columns;\n        count=ReadBlob(image,length,scanline);\n        if (count != (ssize_t) length)\n          {\n            status=MagickFalse;\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n        p=scanline;\n        q=GetAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) chroma_image->columns; x++)\n        {\n          if (quantum == 1)\n            SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),q);\n          else\n            {\n              SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                *(p+1)),q);\n              p+=2;\n            }\n          q+=GetPixelChannels(chroma_image);\n        }\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      }\n    }\n    /*\n      Scale image.\n    */\n    resize_image=ResizeImage(chroma_image,image->columns,image->rows,\n      TriangleFilter,exception);\n    chroma_image=DestroyImage(chroma_image);\n    if (resize_image == (Image *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      chroma_pixels=GetVirtualPixels(resize_image,0,y,resize_image->columns,1,\n        exception);\n      if ((q == (Quantum *) NULL) ||\n          (chroma_pixels == (const Quantum *) NULL))\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelGreen(image,GetPixelGreen(resize_image,chroma_pixels),q);\n        SetPixelBlue(image,GetPixelBlue(resize_image,chroma_pixels),q);\n        chroma_pixels+=GetPixelChannels(resize_image);\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    }\n    resize_image=DestroyImage(resize_image);\n    if (SetImageColorspace(image,YCbCrColorspace,exception) == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (interlace == NoInterlace)\n      count=ReadBlob(image,(size_t) (2*quantum*image->columns),scanline);\n    else\n      count=ReadBlob(image,(size_t) quantum*image->columns,scanline);\n    if (count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count != 0);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r Y U V I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterYUVImage() adds attributes for the YUV image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterYUVImage method is:\n%\n%      size_t RegisterYUVImage(void)\n%\n*/\nModuleExport size_t RegisterYUVImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"YUV\",\"YUV\",\"CCIR 601 4:1:1 or 4:2:2\");\n  entry->decoder=(DecodeImageHandler *) ReadYUVImage;\n  entry->encoder=(EncodeImageHandler *) WriteYUVImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderRawSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r Y U V I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterYUVImage() removes format registrations made by the\n%  YUV module from the list of supported formats.\n%\n%  The format of the UnregisterYUVImage method is:\n%\n%      UnregisterYUVImage(void)\n%\n*/\nModuleExport void UnregisterYUVImage(void)\n{\n  (void) UnregisterMagickInfo(\"YUV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e Y U V I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteYUVImage() writes an image to a file in the digital YUV\n%  (CCIR 601 4:1:1, plane or partition interlaced, or 4:2:2 plane, partition\n%  interlaced or noninterlaced) bytes and returns it.\n%\n%  The format of the WriteYUVImage method is:\n%\n%      MagickBooleanType WriteYUVImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteYUVImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *yuv_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const Quantum\n    *p,\n    *s;\n\n  register ssize_t\n    x;\n\n  size_t\n    height,\n    quantum,\n    width;\n\n  ssize_t\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  quantum=(size_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowWriterException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open output image file.\n      */\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n    }\n  else\n    {\n      AppendImageFormat(\"Y\",image->filename);\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n    }\n  scene=0;\n  do\n  {\n    /*\n      Sample image to an even width and height, if necessary.\n    */\n    image->depth=(size_t) (quantum == 1 ? 8 : 16);\n    width=image->columns+(image->columns & (horizontal_factor-1));\n    height=image->rows+(image->rows & (vertical_factor-1));\n    yuv_image=ResizeImage(image,width,height,TriangleFilter,exception);\n    if (yuv_image == (Image *) NULL)\n      {\n        (void) CloseBlob(image);\n        return(MagickFalse);\n      }\n    (void) TransformImageColorspace(yuv_image,YCbCrColorspace,exception);\n    /*\n      Downsample image.\n    */\n    chroma_image=ResizeImage(image,width/horizontal_factor,\n      height/vertical_factor,TriangleFilter,exception);\n    if (chroma_image == (Image *) NULL)\n      {\n        (void) CloseBlob(image);\n        return(MagickFalse);\n      }\n    (void) TransformImageColorspace(chroma_image,YCbCrColorspace,exception);\n    if (interlace == NoInterlace)\n      {\n        /*\n          Write noninterlaced YUV.\n        */\n        for (y=0; y < (ssize_t) yuv_image->rows; y++)\n        {\n          p=GetVirtualPixels(yuv_image,0,y,yuv_image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          s=GetVirtualPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (s == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) yuv_image->columns; x+=2)\n          {\n            if (quantum == 1)\n              {\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelGreen(yuv_image,s)));\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelRed(yuv_image,p)));\n                p+=GetPixelChannels(yuv_image);\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelBlue(yuv_image,s)));\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelRed(yuv_image,p)));\n              }\n            else\n              {\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelGreen(yuv_image,s)));\n                (void) WriteBlobShort(image,ScaleQuantumToShort(\n                  GetPixelRed(yuv_image,p)));\n                p+=GetPixelChannels(yuv_image);\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelBlue(yuv_image,s)));\n                (void) WriteBlobShort(image,ScaleQuantumToShort(\n                  GetPixelRed(yuv_image,p)));\n              }\n            p+=GetPixelChannels(yuv_image);\n            s++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        yuv_image=DestroyImage(yuv_image);\n      }\n    else\n      {\n        /*\n          Initialize Y channel.\n        */\n        for (y=0; y < (ssize_t) yuv_image->rows; y++)\n        {\n          p=GetVirtualPixels(yuv_image,0,y,yuv_image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) yuv_image->columns; x++)\n          {\n            if (quantum == 1)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelRed(yuv_image,p)));\n            else\n              (void) WriteBlobShort(image,ScaleQuantumToShort(\n                GetPixelRed(yuv_image,p)));\n            p+=GetPixelChannels(yuv_image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        yuv_image=DestroyImage(yuv_image);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,1,3);\n            if (status == MagickFalse)\n              break;\n          }\n        /*\n          Initialize U channel.\n        */\n        if (interlace == PartitionInterlace)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"U\",image->filename);\n            status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              return(status);\n          }\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          p=GetVirtualPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            if (quantum == 1)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelGreen(chroma_image,p)));\n            else\n              (void) WriteBlobShort(image,ScaleQuantumToShort(\n                GetPixelGreen(chroma_image,p)));\n            p+=GetPixelChannels(chroma_image);\n          }\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,3);\n            if (status == MagickFalse)\n              break;\n          }\n        /*\n          Initialize V channel.\n        */\n        if (interlace == PartitionInterlace)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"V\",image->filename);\n            status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              return(status);\n          }\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          p=GetVirtualPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            if (quantum == 1)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelBlue(chroma_image,p)));\n            else\n              (void) WriteBlobShort(image,ScaleQuantumToShort(\n                GetPixelBlue(chroma_image,p)));\n            p+=GetPixelChannels(chroma_image);\n          }\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,3);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    chroma_image=DestroyImage(chroma_image);\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            Y   Y  U   U  V   V                              %\n%                             Y Y   U   U  V   V                              %\n%                              Y    U   U  V   V                              %\n%                              Y    U   U   V V                               %\n%                              Y     UUU     V                                %\n%                                                                             %\n%                                                                             %\n%            Read/Write Raw CCIR 601 4:1:1 or 4:2:2 Image Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteYUVImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d Y U V I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadYUVImage() reads an image with digital YUV (CCIR 601 4:1:1, plane\n%  or partition interlaced, or 4:2:2 plane, partition interlaced or\n%  noninterlaced) bytes and returns it.  It allocates the memory necessary\n%  for the new Image structure and returns a pointer to the new image.\n%\n%  The format of the ReadYUVImage method is:\n%\n%      Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *image,\n    *resize_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *chroma_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  size_t\n    length,\n    quantum;\n\n  unsigned char\n    *scanline;\n\n  /*\n    Allocate image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  quantum=(ssize_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image_info->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowReaderException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open image file.\n      */\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,(MagickSizeType) image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Allocate memory for a scanline.\n  */\n  if (interlace == NoInterlace)\n    scanline=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      image->columns+2UL),(size_t) quantum*sizeof(*scanline));\n  else\n    scanline=(unsigned char *) AcquireQuantumMemory(image->columns,\n      (size_t) quantum*sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  do\n  {\n    chroma_image=CloneImage(image,(image->columns+horizontal_factor-1)/\n      horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n      MagickTrue,exception);\n    if (chroma_image == (Image *) NULL)\n      {\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    /*\n      Convert raster image to pixel packets.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      {\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *chroma_pixels;\n\n      if (interlace == NoInterlace)\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=2*quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          chroma_pixels=QueueAuthenticPixels(chroma_image,0,y,\n            chroma_image->columns,1,exception);\n          if (chroma_pixels == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=2)\n          {\n            SetPixelRed(chroma_image,0,chroma_pixels);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),\n                chroma_pixels);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            if (quantum == 1)\n              SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),chroma_pixels);\n            else\n              {\n                SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            chroma_pixels+=GetPixelChannels(chroma_image);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (interlace == NoInterlace)\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (interlace == PartitionInterlace)\n      {\n        (void) CloseBlob(image);\n        AppendImageFormat(\"U\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    if (interlace != NoInterlace)\n      {\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          length=quantum*chroma_image->columns;\n          count=ReadBlob(image,length,scanline);\n          if (count != (ssize_t) length)\n            {\n              status=MagickFalse;\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            SetPixelRed(chroma_image,0,q);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),q);\n                p+=2;\n              }\n            SetPixelBlue(chroma_image,0,q);\n            q+=GetPixelChannels(chroma_image);\n          }\n          if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n            break;\n        }\n      if (interlace == PartitionInterlace)\n        {\n          (void) CloseBlob(image);\n          AppendImageFormat(\"V\",image->filename);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n              image=DestroyImageList(image);\n              return((Image *) NULL);\n            }\n        }\n      for (y=0; y < (ssize_t) chroma_image->rows; y++)\n      {\n        length=quantum*chroma_image->columns;\n        count=ReadBlob(image,length,scanline);\n        if (count != (ssize_t) length)\n          {\n            status=MagickFalse;\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n        p=scanline;\n        q=GetAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) chroma_image->columns; x++)\n        {\n          if (quantum == 1)\n            SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),q);\n          else\n            {\n              SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                *(p+1)),q);\n              p+=2;\n            }\n          q+=GetPixelChannels(chroma_image);\n        }\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      }\n    }\n    /*\n      Scale image.\n    */\n    resize_image=ResizeImage(chroma_image,image->columns,image->rows,\n      TriangleFilter,exception);\n    chroma_image=DestroyImage(chroma_image);\n    if (resize_image == (Image *) NULL)\n      {\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   \n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      chroma_pixels=GetVirtualPixels(resize_image,0,y,resize_image->columns,1,\n        exception);\n      if ((q == (Quantum *) NULL) ||\n          (chroma_pixels == (const Quantum *) NULL))\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelGreen(image,GetPixelGreen(resize_image,chroma_pixels),q);\n        SetPixelBlue(image,GetPixelBlue(resize_image,chroma_pixels),q);\n        chroma_pixels+=GetPixelChannels(resize_image);\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    }\n    resize_image=DestroyImage(resize_image);\n    if (SetImageColorspace(image,YCbCrColorspace,exception) == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (interlace == NoInterlace)\n      count=ReadBlob(image,(size_t) (2*quantum*image->columns),scanline);\n    else\n      count=ReadBlob(image,(size_t) quantum*image->columns,scanline);\n    if (count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count != 0);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r Y U V I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterYUVImage() adds attributes for the YUV image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterYUVImage method is:\n%\n%      size_t RegisterYUVImage(void)\n%\n*/\nModuleExport size_t RegisterYUVImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"YUV\",\"YUV\",\"CCIR 601 4:1:1 or 4:2:2\");\n  entry->decoder=(DecodeImageHandler *) ReadYUVImage;\n  entry->encoder=(EncodeImageHandler *) WriteYUVImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderRawSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r Y U V I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterYUVImage() removes format registrations made by the\n%  YUV module from the list of supported formats.\n%\n%  The format of the UnregisterYUVImage method is:\n%\n%      UnregisterYUVImage(void)\n%\n*/\nModuleExport void UnregisterYUVImage(void)\n{\n  (void) UnregisterMagickInfo(\"YUV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e Y U V I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteYUVImage() writes an image to a file in the digital YUV\n%  (CCIR 601 4:1:1, plane or partition interlaced, or 4:2:2 plane, partition\n%  interlaced or noninterlaced) bytes and returns it.\n%\n%  The format of the WriteYUVImage method is:\n%\n%      MagickBooleanType WriteYUVImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteYUVImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *yuv_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const Quantum\n    *p,\n    *s;\n\n  register ssize_t\n    x;\n\n  size_t\n    height,\n    quantum,\n    width;\n\n  ssize_t\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  quantum=(size_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowWriterException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open output image file.\n      */\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n    }\n  else\n    {\n      AppendImageFormat(\"Y\",image->filename);\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n    }\n  scene=0;\n  do\n  {\n    /*\n      Sample image to an even width and height, if necessary.\n    */\n    image->depth=(size_t) (quantum == 1 ? 8 : 16);\n    width=image->columns+(image->columns & (horizontal_factor-1));\n    height=image->rows+(image->rows & (vertical_factor-1));\n    yuv_image=ResizeImage(image,width,height,TriangleFilter,exception);\n    if (yuv_image == (Image *) NULL)\n      {\n        (void) CloseBlob(image);\n        return(MagickFalse);\n      }\n    (void) TransformImageColorspace(yuv_image,YCbCrColorspace,exception);\n    /*\n      Downsample image.\n    */\n    chroma_image=ResizeImage(image,width/horizontal_factor,\n      height/vertical_factor,TriangleFilter,exception);\n    if (chroma_image == (Image *) NULL)\n      {\n        (void) CloseBlob(image);\n        return(MagickFalse);\n      }\n    (void) TransformImageColorspace(chroma_image,YCbCrColorspace,exception);\n    if (interlace == NoInterlace)\n      {\n        /*\n          Write noninterlaced YUV.\n        */\n        for (y=0; y < (ssize_t) yuv_image->rows; y++)\n        {\n          p=GetVirtualPixels(yuv_image,0,y,yuv_image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          s=GetVirtualPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (s == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) yuv_image->columns; x+=2)\n          {\n            if (quantum == 1)\n              {\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelGreen(yuv_image,s)));\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelRed(yuv_image,p)));\n                p+=GetPixelChannels(yuv_image);\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelBlue(yuv_image,s)));\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelRed(yuv_image,p)));\n              }\n            else\n              {\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelGreen(yuv_image,s)));\n                (void) WriteBlobShort(image,ScaleQuantumToShort(\n                  GetPixelRed(yuv_image,p)));\n                p+=GetPixelChannels(yuv_image);\n                (void) WriteBlobByte(image,ScaleQuantumToChar(\n                  GetPixelBlue(yuv_image,s)));\n                (void) WriteBlobShort(image,ScaleQuantumToShort(\n                  GetPixelRed(yuv_image,p)));\n              }\n            p+=GetPixelChannels(yuv_image);\n            s++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        yuv_image=DestroyImage(yuv_image);\n      }\n    else\n      {\n        /*\n          Initialize Y channel.\n        */\n        for (y=0; y < (ssize_t) yuv_image->rows; y++)\n        {\n          p=GetVirtualPixels(yuv_image,0,y,yuv_image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) yuv_image->columns; x++)\n          {\n            if (quantum == 1)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelRed(yuv_image,p)));\n            else\n              (void) WriteBlobShort(image,ScaleQuantumToShort(\n                GetPixelRed(yuv_image,p)));\n            p+=GetPixelChannels(yuv_image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        yuv_image=DestroyImage(yuv_image);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,1,3);\n            if (status == MagickFalse)\n              break;\n          }\n        /*\n          Initialize U channel.\n        */\n        if (interlace == PartitionInterlace)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"U\",image->filename);\n            status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              return(status);\n          }\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          p=GetVirtualPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            if (quantum == 1)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelGreen(chroma_image,p)));\n            else\n              (void) WriteBlobShort(image,ScaleQuantumToShort(\n                GetPixelGreen(chroma_image,p)));\n            p+=GetPixelChannels(chroma_image);\n          }\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,3);\n            if (status == MagickFalse)\n              break;\n          }\n        /*\n          Initialize V channel.\n        */\n        if (interlace == PartitionInterlace)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"V\",image->filename);\n            status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              return(status);\n          }\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          p=GetVirtualPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            if (quantum == 1)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelBlue(chroma_image,p)));\n            else\n              (void) WriteBlobShort(image,ScaleQuantumToShort(\n                GetPixelBlue(chroma_image,p)));\n            p+=GetPixelChannels(chroma_image);\n          }\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,3);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    chroma_image=DestroyImage(chroma_image);\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/yuv.c"], "buggy_code_start_loc": [217], "buggy_code_end_loc": [496], "fixing_code_start_loc": [217], "fixing_code_end_loc": [507], "type": "CWE-772", "message": "ImageMagick version 7.0.7-2 contains a memory leak in ReadYUVImage in coders/yuv.c.", "other": {"cve": {"id": "CVE-2017-15033", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-05T07:29:00.857", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick version 7.0.7-2 contains a memory leak in ReadYUVImage in coders/yuv.c."}, {"lang": "es", "value": "ImageMagick 7.0.7-2 tiene una vulnerabilidad de fuga de memoria en ReadYUVImage in coders/yuv.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.7-2:*:*:*:*:*:*:*", "matchCriteriaId": "AB2E7C40-868A-40F5-B496-3B15AC111320"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/ef8f40689ac452398026c07da41656a7c87e4683", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/ef8f40689ac452398026c07da41656a7c87e4683"}}