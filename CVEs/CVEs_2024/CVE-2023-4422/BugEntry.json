{"buggy_code": ["<?php\n\n// Register Helpers\n$this->helpers['asset'] = 'Assets\\\\Helper\\\\Asset';\n\n// load admin related code\n$this->on('app.admin.init', function() {\n    include(__DIR__.'/admin.php');\n});\n\n// load api request related code\n$this->on('app.api.request', function() {\n    include(__DIR__.'/api.php');\n});\n\n// assets api\n$this->module('assets')->extend([\n\n    'assets' => function(array $options = []) {\n        $assets = $this->app->dataStorage->find('assets', $options)->toArray();\n        return $assets;\n    },\n\n    'update' => function($assets) {\n\n        $assets = isset($assets[0]) ? $assets : [$assets];\n        $by = $this->app->helper('auth')->getUser('_id', null);\n\n        foreach ($assets as &$asset) {\n\n            $_asset = $this->app->dataStorage->findOne('assets', ['_id' => $asset['_id']]);\n\n            if (!$_asset) continue;\n\n            $asset['_modified'] = time();\n            $asset['_mby'] = $by;\n\n            $this->app->trigger('assets.asset.update', [&$asset]);\n\n            $this->app->dataStorage->save('assets', $asset);\n\n        }\n\n        return $assets;\n    },\n\n    'folders' => function(array $options = []) {\n        return $this->app->dataStorage->find('assets/folders', $options)->toArray();\n    },\n\n    'upload' => function(string $param = 'files', array $meta = []) {\n\n        $files = [];\n\n        if (is_string($param) && isset($this->app->request->files[$param])) {\n            $files = $this->app->request->files[$param];\n        } elseif (is_array($param) && isset($param['name'], $param['error'], $param['tmp_name'])) {\n            $files = $param;\n        }\n\n        $uploaded  = [];\n        $failed    = [];\n        $_files    = [];\n        $assets    = [];\n\n        $allowed   = $this->app->retrieve('assets/allowed_uploads', '*');\n        $allowed   = $allowed == '*' ? true : str_replace([' ', ','], ['', '|'], preg_quote(is_array($allowed) ? implode(',', $allowed) : $allowed));\n        $max_size  = $this->app->retrieve('assets/max_upload_size', 0);\n\n        $forbidden = ['php', 'phar', 'phtml', 'phps', 'htm', 'html', 'htaccess'];\n\n        if (isset($files['name']) && is_array($files['name'])) {\n\n            $cnt = count($files['name']);\n\n            for ($i = 0; $i < $cnt; $i++) {\n\n                $_file  = $this->app->path('#tmp:').'/'.$files['name'][$i];\n                $_isAllowed = $allowed === true ? true : preg_match(\"/\\.({$allowed})$/i\", $_file);\n                $_sizeAllowed = $max_size ? filesize($files['tmp_name'][$i]) < $max_size : true;\n\n                // prevent uploading php files\n                if ($_isAllowed && in_array(strtolower(pathinfo($_file, PATHINFO_EXTENSION)), $forbidden)) {\n                    $_isAllowed = false;\n                }\n\n                if (!$files['error'][$i] && $_isAllowed && $_sizeAllowed && move_uploaded_file($files['tmp_name'][$i], $_file)) {\n\n                    $_files[]   = $_file;\n                    $uploaded[] = $files['name'][$i];\n\n                    if (\\preg_match('/\\.(svg|xml)$/i', $_file)) {\n                        file_put_contents($_file, \\SVGSanitizer::clean(\\file_get_contents($_file)));\n                    }\n\n                } else {\n                    $failed[] = $files['name'][$i];\n                }\n            }\n        }\n\n        if (count($_files)) {\n\n            $assets = $this->add($_files, $meta, isset($meta['_id']));\n\n            foreach ($_files as $file) {\n                unlink($file);\n            }\n        }\n\n        return ['uploaded' => $uploaded, 'failed' => $failed, 'assets' => $assets];\n    },\n\n    'add' => function(array $files, array $meta = [], bool $update = false) {\n\n        $files     = isset($files[0]) ? $files : [$files];\n        $finfo     = finfo_open(FILEINFO_MIME_TYPE);\n        $assets    = [];\n        $created   = time();\n        $by        = $this->app->helper('auth')->getUser('_id', null);\n\n        foreach ($files as $idx => &$file) {\n\n            // clean filename\n            $name = basename($file);\n\n            // clean filename\n            $filename = pathinfo($file, PATHINFO_FILENAME);\n            $ext = pathinfo($file, PATHINFO_EXTENSION);\n            $cleanFilename = preg_replace('/[^a-zA-Z0-9-_\\.]/','', str_replace(' ', '-', $filename));\n            $clean = $cleanFilename.uniqid(\"_uid_\").'.'.$ext;\n            $path  = '/'.date('Y/m/d').'/'.$clean;\n\n            $asset = [\n                'path' => $path,\n                'title' => $name,\n                'mime' => finfo_file($finfo, $file),\n                'type' => 'unknown',\n                'description' => '',\n                'tags' => [],\n                'size' => filesize($file),\n                'colors' => null,\n                'width' => null,\n                'height' => null,\n                '_hash' => hash_file('md5', $file),\n                '_created' => $created,\n                '_modified' => $created,\n                '_cby' => $by\n            ];\n\n            if (!$asset['mime']) {\n                $asset['mime'] = 'unknown';\n            }\n\n            if ($asset['mime'] == 'image/svg') {\n                $asset['mime'] = 'image/svg+xml';\n            }\n\n            $asset['type'] = match(1) {\n                preg_match('/\\.(jpg|jpeg|png|gif|svg|webp)$/i', $file) => 'image',\n                preg_match('/\\.(mp4|mov|ogv|webv|wmv|flv|avi)$/i', $file) => 'video',\n                preg_match('/\\.(mp3|weba|ogg|wav|flac)$/i', $file) => 'audio',\n                preg_match('/\\.(zip|rar|7zip|gz|tar)$/i', $file) => 'archive',\n                preg_match('/\\.(txt|htm|html|pdf|md)$/i', $file) => 'document',\n                preg_match('/\\.(htm|html|php|css|less|js|json|md|markdown|yaml|xml|htaccess)$/i', $file) => 'code',\n                default => 'unknown'\n            };\n\n            if ($asset['type'] == 'image' && !preg_match('/\\.svg$/i', $file)) {\n\n                $info = getimagesize($file);\n                $asset['width']  = $info[0];\n                $asset['height'] = $info[1];\n                $asset['colors'] = [];\n\n                if ($asset['width'] && $asset['height']) {\n\n                    try {\n                        $asset['colors'] = \\ColorThief\\ColorThief::getPalette($file, 5, ceil(($asset['width'] * $asset['height']) / 10000));\n                    } catch (\\Exception $e) {\n                        $asset['colors'] = [];\n                    }\n\n                    foreach ($asset['colors'] as &$color) {\n                        $color = sprintf(\"#%02x%02x%02x\", $color[0], $color[1], $color[2]);\n                    }\n                }\n            }\n\n            $opts  = ['mimetype' => $asset['mime']];\n            $_meta = isset($meta[$idx]) && is_array($meta[$idx]) ? $meta[$idx] : $meta;\n\n            $this->app->trigger('assets.asset.upload', [&$asset, &$_meta, &$opts, &$file, &$path]);\n\n            if (!$asset) {\n                continue;\n            }\n\n            // move file\n            try {\n\n                $stream = fopen($file, 'r+');\n                $this->app->fileStorage->writeStream(\"uploads://{$path}\", $stream, $opts);\n\n                if (is_resource($stream)) {\n                    fclose($stream);\n                }\n\n            } catch (Throwable $exception) {\n                continue;\n            }\n\n            foreach ($_meta as $key => $val) {\n                $asset[$key] = $val;\n            }\n\n            $this->app->trigger('assets.asset', [&$asset]);\n\n            $assets[] = $asset;\n        }\n\n        if (count($assets)) {\n\n            if ($update) {\n                foreach ($assets as $asset) {\n                    $this->app->trigger('assets.asset.update', [&$asset]);\n                    $this->app->dataStorage->save('assets', $asset);\n                }\n            } else {\n                $this->app->trigger('assets.add', [&$assets]);\n                $this->app->dataStorage->insert('assets', $assets);\n            }\n        }\n\n        $this->app->trigger('assets.uploaded', [$assets]);\n\n        return $assets;\n    },\n\n    'remove' => function(mixed $assets) {\n\n        $assets = isset($assets[0]) ? $assets : [$assets];\n\n        foreach ($assets as &$asset) {\n\n            if (is_string($asset)) {\n                $asset = $this->app->dataStorage->findOne('assets', ['_id' => $asset]);\n            }\n\n            if (!isset($asset['_id'])) continue;\n\n            if (!isset($asset['path'])) {\n                $asset = $this->app->dataStorage->findOne('assets', ['_id' => $asset['_id']]);\n            }\n\n            if (!$asset) continue;\n\n            $this->app->dataStorage->remove('assets', ['_id' => $asset['_id']]);\n\n            if ($this->app->fileStorage->fileExists('uploads://'.trim($asset['path'], '/'))) {\n                $this->app->fileStorage->delete('uploads://'.trim($asset['path'], '/'));\n            }\n\n            $this->app->trigger('assets.asset.remove', [$asset]);\n        }\n\n        $this->app->trigger('assets.remove', [$assets]);\n\n        return $assets;\n    },\n\n    'thumbnail' => function(array $options = []) {\n        return $this->app->helper('asset')->thumbnail($options);\n    }\n]);\n"], "fixing_code": ["<?php\n\n// Register Helpers\n$this->helpers['asset'] = 'Assets\\\\Helper\\\\Asset';\n\n// load admin related code\n$this->on('app.admin.init', function() {\n    include(__DIR__.'/admin.php');\n});\n\n// load api request related code\n$this->on('app.api.request', function() {\n    include(__DIR__.'/api.php');\n});\n\n// assets api\n$this->module('assets')->extend([\n\n    'assets' => function(array $options = []) {\n        $assets = $this->app->dataStorage->find('assets', $options)->toArray();\n        return $assets;\n    },\n\n    'update' => function($assets) {\n\n        $assets = isset($assets[0]) ? $assets : [$assets];\n        $by = $this->app->helper('auth')->getUser('_id', null);\n\n        foreach ($assets as &$asset) {\n\n            $_asset = $this->app->dataStorage->findOne('assets', ['_id' => $asset['_id']]);\n\n            if (!$_asset) continue;\n\n            $asset['_modified'] = time();\n            $asset['_mby'] = $by;\n\n            $this->app->trigger('assets.asset.update', [&$asset]);\n\n            $this->app->dataStorage->save('assets', $asset);\n\n        }\n\n        return $assets;\n    },\n\n    'folders' => function(array $options = []) {\n        return $this->app->dataStorage->find('assets/folders', $options)->toArray();\n    },\n\n    'upload' => function(string $param = 'files', array $meta = []) {\n\n        $files = [];\n\n        if (is_string($param) && isset($this->app->request->files[$param])) {\n            $files = $this->app->request->files[$param];\n        } elseif (is_array($param) && isset($param['name'], $param['error'], $param['tmp_name'])) {\n            $files = $param;\n        }\n\n        $finfo      = finfo_open(FILEINFO_MIME_TYPE);\n        $uploaded  = [];\n        $failed    = [];\n        $_files     = [];\n        $assets    = [];\n\n        $allowed   = $this->app->retrieve('assets/allowed_uploads', '*');\n        $allowed   = $allowed == '*' ? true : str_replace([' ', ','], ['', '|'], preg_quote(is_array($allowed) ? implode(',', $allowed) : $allowed));\n        $max_size  = $this->app->retrieve('assets/max_upload_size', 0);\n\n        $forbiddenExtension = ['php', 'phar', 'phtml', 'phps', 'htm', 'html', 'htaccess'];\n        $forbiddenMime = ['application/x-httpd-php', 'text/html'];\n\n        if (isset($files['name']) && is_array($files['name'])) {\n\n            $cnt = count($files['name']);\n\n            for ($i = 0; $i < $cnt; $i++) {\n\n                $_file  = $this->app->path('#tmp:').'/'.$files['name'][$i];\n                $_mime = finfo_file($finfo, $_file);\n                $_isAllowed = $allowed === true ? true : preg_match(\"/\\.({$allowed})$/i\", $_file);\n                $_sizeAllowed = $max_size ? filesize($files['tmp_name'][$i]) < $max_size : true;\n\n                // prevent uploading php / html files\n                if ($_isAllowed && (\n                    in_array(strtolower(pathinfo($_file, PATHINFO_EXTENSION)), $forbiddenExtension) ||\n                    in_array(strtolower($_mime), $forbiddenMime)\n                )) {\n                    $_isAllowed = false;\n                }\n\n                if (!$files['error'][$i] && $_isAllowed && $_sizeAllowed && move_uploaded_file($files['tmp_name'][$i], $_file)) {\n\n                    $_files[]   = $_file;\n                    $uploaded[] = $files['name'][$i];\n\n                    if (\\preg_match('/\\.(svg|xml)$/i', $_file)) {\n                        file_put_contents($_file, \\SVGSanitizer::clean(\\file_get_contents($_file)));\n                    }\n\n                } else {\n                    $failed[] = $files['name'][$i];\n                }\n            }\n        }\n\n        if (count($_files)) {\n\n            $assets = $this->add($_files, $meta, isset($meta['_id']));\n\n            foreach ($_files as $file) {\n                unlink($file);\n            }\n        }\n\n        return ['uploaded' => $uploaded, 'failed' => $failed, 'assets' => $assets];\n    },\n\n    'add' => function(array $files, array $meta = [], bool $update = false) {\n\n        $files     = isset($files[0]) ? $files : [$files];\n        $finfo     = finfo_open(FILEINFO_MIME_TYPE);\n        $assets    = [];\n        $created   = time();\n        $by        = $this->app->helper('auth')->getUser('_id', null);\n\n        foreach ($files as $idx => &$file) {\n\n            // clean filename\n            $name = basename($file);\n\n            // clean filename\n            $filename = pathinfo($file, PATHINFO_FILENAME);\n            $ext = pathinfo($file, PATHINFO_EXTENSION);\n            $cleanFilename = preg_replace('/[^a-zA-Z0-9-_\\.]/','', str_replace(' ', '-', $filename));\n            $clean = $cleanFilename.uniqid(\"_uid_\").'.'.$ext;\n            $path  = '/'.date('Y/m/d').'/'.$clean;\n\n            $asset = [\n                'path' => $path,\n                'title' => $name,\n                'mime' => finfo_file($finfo, $file),\n                'type' => 'unknown',\n                'description' => '',\n                'tags' => [],\n                'size' => filesize($file),\n                'colors' => null,\n                'width' => null,\n                'height' => null,\n                '_hash' => hash_file('md5', $file),\n                '_created' => $created,\n                '_modified' => $created,\n                '_cby' => $by\n            ];\n\n            if (!$asset['mime']) {\n                $asset['mime'] = 'unknown';\n            }\n\n            if ($asset['mime'] == 'image/svg') {\n                $asset['mime'] = 'image/svg+xml';\n            }\n\n            $asset['type'] = match(1) {\n                preg_match('/\\.(jpg|jpeg|png|gif|svg|webp)$/i', $file) => 'image',\n                preg_match('/\\.(mp4|mov|ogv|webv|wmv|flv|avi)$/i', $file) => 'video',\n                preg_match('/\\.(mp3|weba|ogg|wav|flac)$/i', $file) => 'audio',\n                preg_match('/\\.(zip|rar|7zip|gz|tar)$/i', $file) => 'archive',\n                preg_match('/\\.(txt|htm|html|pdf|md)$/i', $file) => 'document',\n                preg_match('/\\.(htm|html|php|css|less|js|json|md|markdown|yaml|xml|htaccess)$/i', $file) => 'code',\n                default => 'unknown'\n            };\n\n            if ($asset['type'] == 'image' && !preg_match('/\\.svg$/i', $file)) {\n\n                $info = getimagesize($file);\n                $asset['width']  = $info[0];\n                $asset['height'] = $info[1];\n                $asset['colors'] = [];\n\n                if ($asset['width'] && $asset['height']) {\n\n                    try {\n                        $asset['colors'] = \\ColorThief\\ColorThief::getPalette($file, 5, ceil(($asset['width'] * $asset['height']) / 10000));\n                    } catch (\\Exception $e) {\n                        $asset['colors'] = [];\n                    }\n\n                    foreach ($asset['colors'] as &$color) {\n                        $color = sprintf(\"#%02x%02x%02x\", $color[0], $color[1], $color[2]);\n                    }\n                }\n            }\n\n            $opts  = ['mimetype' => $asset['mime']];\n            $_meta = isset($meta[$idx]) && is_array($meta[$idx]) ? $meta[$idx] : $meta;\n\n            $this->app->trigger('assets.asset.upload', [&$asset, &$_meta, &$opts, &$file, &$path]);\n\n            if (!$asset) {\n                continue;\n            }\n\n            // move file\n            try {\n\n                $stream = fopen($file, 'r+');\n                $this->app->fileStorage->writeStream(\"uploads://{$path}\", $stream, $opts);\n\n                if (is_resource($stream)) {\n                    fclose($stream);\n                }\n\n            } catch (Throwable $exception) {\n                continue;\n            }\n\n            foreach ($_meta as $key => $val) {\n                $asset[$key] = $val;\n            }\n\n            $this->app->trigger('assets.asset', [&$asset]);\n\n            $assets[] = $asset;\n        }\n\n        if (count($assets)) {\n\n            if ($update) {\n                foreach ($assets as $asset) {\n                    $this->app->trigger('assets.asset.update', [&$asset]);\n                    $this->app->dataStorage->save('assets', $asset);\n                }\n            } else {\n                $this->app->trigger('assets.add', [&$assets]);\n                $this->app->dataStorage->insert('assets', $assets);\n            }\n        }\n\n        $this->app->trigger('assets.uploaded', [$assets]);\n\n        return $assets;\n    },\n\n    'remove' => function(mixed $assets) {\n\n        $assets = isset($assets[0]) ? $assets : [$assets];\n\n        foreach ($assets as &$asset) {\n\n            if (is_string($asset)) {\n                $asset = $this->app->dataStorage->findOne('assets', ['_id' => $asset]);\n            }\n\n            if (!isset($asset['_id'])) continue;\n\n            if (!isset($asset['path'])) {\n                $asset = $this->app->dataStorage->findOne('assets', ['_id' => $asset['_id']]);\n            }\n\n            if (!$asset) continue;\n\n            $this->app->dataStorage->remove('assets', ['_id' => $asset['_id']]);\n\n            if ($this->app->fileStorage->fileExists('uploads://'.trim($asset['path'], '/'))) {\n                $this->app->fileStorage->delete('uploads://'.trim($asset['path'], '/'));\n            }\n\n            $this->app->trigger('assets.asset.remove', [$asset]);\n        }\n\n        $this->app->trigger('assets.remove', [$assets]);\n\n        return $assets;\n    },\n\n    'thumbnail' => function(array $options = []) {\n        return $this->app->helper('asset')->thumbnail($options);\n    }\n]);\n"], "filenames": ["modules/Assets/bootstrap.php"], "buggy_code_start_loc": [60], "buggy_code_end_loc": [84], "fixing_code_start_loc": [61], "fixing_code_end_loc": [90], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository cockpit-hq/cockpit prior to 2.6.3.", "other": {"cve": {"id": "CVE-2023-4422", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-18T19:15:13.250", "lastModified": "2023-08-22T00:58:55.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository cockpit-hq/cockpit prior to 2.6.3."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de Cross-Site Scripting (XSS) almacenado en el repositorio GitHub cockpit-hq/cockpit anterior a la versi\u00f3n 2.6.3. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:agentejo:cockpit:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.3", "matchCriteriaId": "01BAF7D9-ECB6-4E46-B1A5-DD318BBE9C8D"}]}]}], "references": [{"url": "https://github.com/cockpit-hq/cockpit/commit/b8dad5e070608bb5e4ec58fabbee101b5af737cf", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/2e12b773-b6a2-48da-a4bb-55d5d1307d2e", "source": "security@huntr.dev", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/cockpit-hq/cockpit/commit/b8dad5e070608bb5e4ec58fabbee101b5af737cf"}}