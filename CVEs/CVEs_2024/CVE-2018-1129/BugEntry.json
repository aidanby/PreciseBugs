{"buggy_code": ["// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- \n// vim: ts=8 sw=2 smarttab\n/*\n * Ceph - scalable distributed file system\n *\n * Copyright (C) 2004-2009 Sage Weil <sage@newdream.net>\n *\n * This is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License version 2.1, as published by the Free Software \n * Foundation.  See file COPYING.\n * \n */\n\n#include \"CephxSessionHandler.h\"\n#include \"CephxProtocol.h\"\n\n#include <errno.h>\n#include <sstream>\n\n#include \"common/config.h\"\n#include \"include/ceph_features.h\"\n#include \"msg/Message.h\"\n \n#define dout_subsys ceph_subsys_auth\n\nint CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n\n  // optimized signature calculation\n  // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n  // - skip the leading 4 byte wrapper from encode_encrypt\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}\n\nint CephxSessionHandler::sign_message(Message *m)\n{\n  // If runtime signing option is off, just return success without signing.\n  if (!cct->_conf->cephx_sign_messages) {\n    return 0;\n  }\n\n  uint64_t sig;\n  int r = _calc_signature(m, &sig);\n  if (r < 0)\n    return r;\n\n  ceph_msg_footer& f = m->get_footer();\n  f.sig = sig;\n  f.flags = (unsigned)f.flags | CEPH_MSG_FOOTER_SIGNED;\n  ldout(cct, 20) << \"Putting signature in client message(seq # \" << m->get_seq()\n\t\t << \"): sig = \" << sig << dendl;\n  return 0;\n}\n\nint CephxSessionHandler::check_message_signature(Message *m)\n{\n  // If runtime signing option is off, just return success without checking signature.\n  if (!cct->_conf->cephx_sign_messages) {\n    return 0;\n  }\n  if ((features & CEPH_FEATURE_MSG_AUTH) == 0) {\n    // it's fine, we didn't negotiate this feature.\n    return 0;\n  }\n\n  uint64_t sig;\n  int r = _calc_signature(m, &sig);\n  if (r < 0)\n    return r;\n\n  if (sig != m->get_footer().sig) {\n    // Should have been signed, but signature check failed.  PLR\n    if (!(m->get_footer().flags & CEPH_MSG_FOOTER_SIGNED)) {\n      ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \" Sender did not set CEPH_MSG_FOOTER_SIGNED.\" << dendl;\n    }\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \" Message signature does not match contents.\" << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"Signature on message:\" << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"    sig: \" << m->get_footer().sig << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"Locally calculated signature:\" << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"    sig_check:\" << sig << dendl;\n\n    // For the moment, printing an error message to the log and\n    // returning failure is sufficient.  In the long term, we should\n    // probably have code parsing the log looking for this kind of\n    // security failure, particularly when there are large numbers of\n    // them, since the latter is a potential sign of an attack.  PLR\n\n    ldout(cct, 0) << \"Signature failed.\" << dendl;\n    return (SESSION_SIGNATURE_FAILURE);\n  }\n\n  return 0;\n}\n\n"], "fixing_code": ["// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- \n// vim: ts=8 sw=2 smarttab\n/*\n * Ceph - scalable distributed file system\n *\n * Copyright (C) 2004-2009 Sage Weil <sage@newdream.net>\n *\n * This is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License version 2.1, as published by the Free Software \n * Foundation.  See file COPYING.\n * \n */\n\n#include \"CephxSessionHandler.h\"\n#include \"CephxProtocol.h\"\n\n#include <errno.h>\n#include <sstream>\n\n#include \"common/config.h\"\n#include \"include/ceph_features.h\"\n#include \"msg/Message.h\"\n \n#define dout_subsys ceph_subsys_auth\n\nint CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n\n  if (!HAVE_FEATURE(features, CEPHX_V2)) {\n    // legacy pre-mimic behavior for compatibility\n\n    // optimized signature calculation\n    // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n    // - skip the leading 4 byte wrapper from encode_encrypt\n    struct {\n      __u8 v;\n      __le64 magic;\n      __le32 len;\n      __le32 header_crc;\n      __le32 front_crc;\n      __le32 middle_crc;\n      __le32 data_crc;\n    } __attribute__ ((packed)) sigblock = {\n      1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n      mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n      mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n    };\n\n    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n    try {\n      const CryptoKey::in_slice_t in {\n\tsizeof(sigblock),\n\treinterpret_cast<const unsigned char*>(&sigblock)\n      };\n      const CryptoKey::out_slice_t out {\n\tsizeof(exp_buf),\n\treinterpret_cast<unsigned char*>(&exp_buf)\n      };\n      key.encrypt(cct, in, out);\n    } catch (std::exception& e) {\n      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n      return -1;\n    }\n\n    *psig = *reinterpret_cast<__le64*>(exp_buf);\n  } else {\n    // newer mimic+ signatures\n    struct {\n      __le32 header_crc;\n      __le32 front_crc;\n      __le32 front_len;\n      __le32 middle_crc;\n      __le32 middle_len;\n      __le32 data_crc;\n      __le32 data_len;\n      __le32 seq_lower_word;\n    } __attribute__ ((packed)) sigblock = {\n      mswab<uint32_t>(header.crc),\n      mswab<uint32_t>(footer.front_crc),\n      mswab<uint32_t>(header.front_len),\n      mswab<uint32_t>(footer.middle_crc),\n      mswab<uint32_t>(header.middle_len),\n      mswab<uint32_t>(footer.data_crc),\n      mswab<uint32_t>(header.data_len),\n      mswab<uint32_t>(header.seq)\n    };\n\n    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n    try {\n      const CryptoKey::in_slice_t in {\n\tsizeof(sigblock),\n\treinterpret_cast<const unsigned char*>(&sigblock)\n      };\n      const CryptoKey::out_slice_t out {\n\tsizeof(exp_buf),\n\treinterpret_cast<unsigned char*>(&exp_buf)\n      };\n      key.encrypt(cct, in, out);\n    } catch (std::exception& e) {\n      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n      return -1;\n    }\n\n    struct enc {\n      __le64 a, b, c, d;\n    } *penc = reinterpret_cast<enc*>(exp_buf);\n    *psig = penc->a ^ penc->b ^ penc->c ^ penc->d;\n  }\n\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}\n\nint CephxSessionHandler::sign_message(Message *m)\n{\n  // If runtime signing option is off, just return success without signing.\n  if (!cct->_conf->cephx_sign_messages) {\n    return 0;\n  }\n\n  uint64_t sig;\n  int r = _calc_signature(m, &sig);\n  if (r < 0)\n    return r;\n\n  ceph_msg_footer& f = m->get_footer();\n  f.sig = sig;\n  f.flags = (unsigned)f.flags | CEPH_MSG_FOOTER_SIGNED;\n  ldout(cct, 20) << \"Putting signature in client message(seq # \" << m->get_seq()\n\t\t << \"): sig = \" << sig << dendl;\n  return 0;\n}\n\nint CephxSessionHandler::check_message_signature(Message *m)\n{\n  // If runtime signing option is off, just return success without checking signature.\n  if (!cct->_conf->cephx_sign_messages) {\n    return 0;\n  }\n  if ((features & CEPH_FEATURE_MSG_AUTH) == 0) {\n    // it's fine, we didn't negotiate this feature.\n    return 0;\n  }\n\n  uint64_t sig;\n  int r = _calc_signature(m, &sig);\n  if (r < 0)\n    return r;\n\n  if (sig != m->get_footer().sig) {\n    // Should have been signed, but signature check failed.  PLR\n    if (!(m->get_footer().flags & CEPH_MSG_FOOTER_SIGNED)) {\n      ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \" Sender did not set CEPH_MSG_FOOTER_SIGNED.\" << dendl;\n    }\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \" Message signature does not match contents.\" << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"Signature on message:\" << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"    sig: \" << m->get_footer().sig << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"Locally calculated signature:\" << dendl;\n    ldout(cct, 0) << \"SIGN: MSG \" << m->get_seq() << \"    sig_check:\" << sig << dendl;\n\n    // For the moment, printing an error message to the log and\n    // returning failure is sufficient.  In the long term, we should\n    // probably have code parsing the log looking for this kind of\n    // security failure, particularly when there are large numbers of\n    // them, since the latter is a potential sign of an attack.  PLR\n\n    ldout(cct, 0) << \"Signature failed.\" << dendl;\n    return (SESSION_SIGNATURE_FAILURE);\n  }\n\n  return 0;\n}\n\n"], "filenames": ["src/auth/cephx/CephxSessionHandler.cc"], "buggy_code_start_loc": [32], "buggy_code_end_loc": [68], "fixing_code_start_loc": [32], "fixing_code_end_loc": [113], "type": "CWE-287", "message": "A flaw was found in the way signature calculation was handled by cephx authentication protocol. An attacker having access to ceph cluster network who is able to alter the message payload was able to bypass signature checks done by cephx protocol. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable.", "other": {"cve": {"id": "CVE-2018-1129", "sourceIdentifier": "secalert@redhat.com", "published": "2018-07-10T14:29:00.417", "lastModified": "2019-08-29T03:15:10.397", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in the way signature calculation was handled by cephx authentication protocol. An attacker having access to ceph cluster network who is able to alter the message payload was able to bypass signature checks done by cephx protocol. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable."}, {"lang": "es", "value": "Se ha encontrado un error en la forma en la que el c\u00e1lculo de firmas es gestionado por el protocolo de autenticaci\u00f3n cephx. Un atacante que tenga acceso a la red de cl\u00fasters ceph y que pueda alterar la carga \u00fatil de los mensajes podr\u00eda omitir las comprobaciones de firma realizadas por el protocolo cephx. Se cree que las ramas de ceph master, mimic, luminous y jewel son vulnerables."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "26E67C3A-4458-4DC9-B40E-C0B285C87211"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:3:*:*:*:*:*:*:*", "matchCriteriaId": "E9184616-421F-4EA9-AC1A-A4C95BBAAC99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage_mon:2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2EBAD9-F0D5-4176-9C4D-001B230E699E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage_mon:3:*:*:*:*:*:*:*", "matchCriteriaId": "CD2F9BA8-FE0A-43DE-A756-C35A24C3D96E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage_osd:2:*:*:*:*:*:*:*", "matchCriteriaId": "AA5F5227-DBDA-4C01-BF7C-4D53F455404F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage_osd:3:*:*:*:*:*:*:*", "matchCriteriaId": "A80BACB5-7A56-4BC6-9261-58A3860F4E8C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8901022A-8A84-494A-A5BF-358F2CBBDFFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "76788B0A-7776-4D0C-B0D7-C855E9A0231E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "7A925DB4-83DC-45D1-A48B-1675A111213B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "D22BA440-CB28-445C-A7F8-CBD6E8965B2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "A503C653-AFEB-4E5A-872B-AD033C0E2259"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "7C00462A-A1B8-42A7-9336-DE1BF5510B6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "3505D4E2-4EA8-40A4-A57C-46CCA9922EF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "09EC481B-79F0-41DB-B95F-D1A221C96F4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "31F159B5-AF02-48BE-B994-749F21B9D362"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "D9684039-7938-405D-B833-4C54BFBD6476"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "8FAE4350-8F39-4E78-AB25-17DE76FD57AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:10.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "3B2369D2-4413-447C-A0A8-84CA37B1F5B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "3515BF53-4921-462F-820E-B842BB3FF066"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "48067E54-26F5-4020-BCEA-A65C2536618B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "F9A86B91-78C3-4D02-B7C8-11AAFB1CCCEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "CDBD084F-4A0B-4231-8465-61F8BE5E57F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "0885F67A-E01B-4BF2-A760-D452B55C5F69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "DB9D95E9-52F3-459C-89AD-6FCA6A975085"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "087C6821-9A77-4CC8-8AA0-2C51414D9B58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:12.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "A667C6AF-76D4-4192-A8BF-395F368EFAE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:13.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "13BF6806-6E69-4172-9260-2E97FB253339"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ceph:ceph:13.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "DCAE0EE4-BBE9-4DBD-84CC-9A72E97E73E6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00100.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/154245/Kernel-Live-Patch-Security-Notice-LSN-0054-1.html", "source": "secalert@redhat.com"}, {"url": "http://tracker.ceph.com/issues/24837", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2177", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2179", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2261", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2274", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1576057", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ceph/ceph/commit/8f396cf35a3826044b089141667a196454c0a587", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00017.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4339", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ceph/ceph/commit/8f396cf35a3826044b089141667a196454c0a587"}}