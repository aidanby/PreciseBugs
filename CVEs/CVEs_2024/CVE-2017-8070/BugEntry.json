{"buggy_code": ["/*\n *  Copyright (c) 2001 Vojtech Pavlik\n *\n *  CATC EL1210A NetMate USB Ethernet driver\n *\n *  Sponsored by SuSE\n *\n *  Based on the work of\n *\t\tDonald Becker\n * \n *  Old chipset support added by Simon Evans <spse@secret.org.uk> 2002\n *    - adds support for Belkin F5U011\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or \n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n * \n * Should you need to contact me, the author, you can do so either by\n * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:\n * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n\n#undef DEBUG\n\n#include <linux/usb.h>\n\n/*\n * Version information.\n */\n\n#define DRIVER_VERSION \"v2.8\"\n#define DRIVER_AUTHOR \"Vojtech Pavlik <vojtech@suse.cz>\"\n#define DRIVER_DESC \"CATC EL1210A NetMate USB Ethernet driver\"\n#define SHORT_DRIVER_DESC \"EL1210A NetMate USB Ethernet\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char driver_name[] = \"catc\";\n\n/*\n * Some defines.\n */ \n\n#define STATS_UPDATE\t\t(HZ)\t/* Time between stats updates */\n#define TX_TIMEOUT\t\t(5*HZ)\t/* Max time the queue can be stopped */\n#define PKT_SZ\t\t\t1536\t/* Max Ethernet packet size */\n#define RX_MAX_BURST\t\t15\t/* Max packets per rx buffer (> 0, < 16) */\n#define TX_MAX_BURST\t\t15\t/* Max full sized packets per tx buffer (> 0) */\n#define CTRL_QUEUE\t\t16\t/* Max control requests in flight (power of two) */\n#define RX_PKT_SZ\t\t1600\t/* Max size of receive packet for F5U011 */\n\n/*\n * Control requests.\n */\n\nenum control_requests {\n\tReadMem =\t0xf1,\n\tGetMac =\t0xf2,\n\tReset =\t\t0xf4,\n\tSetMac =\t0xf5,\n\tSetRxMode =     0xf5,  /* F5U011 only */\n\tWriteROM =\t0xf8,\n\tSetReg =\t0xfa,\n\tGetReg =\t0xfb,\n\tWriteMem =\t0xfc,\n\tReadROM =\t0xfd,\n};\n\n/*\n * Registers.\n */\n\nenum register_offsets {\n\tTxBufCount =\t0x20,\n\tRxBufCount =\t0x21,\n\tOpModes =\t0x22,\n\tTxQed =\t\t0x23,\n\tRxQed =\t\t0x24,\n\tMaxBurst =\t0x25,\n\tRxUnit =\t0x60,\n\tEthStatus =\t0x61,\n\tStationAddr0 =\t0x67,\n\tEthStats =\t0x69,\n\tLEDCtrl =\t0x81,\n};\n\nenum eth_stats {\n\tTxSingleColl =\t0x00,\n        TxMultiColl =\t0x02,\n        TxExcessColl =\t0x04,\n        RxFramErr =\t0x06,\n};\n\nenum op_mode_bits {\n\tOp3MemWaits =\t0x03,\n\tOpLenInclude =\t0x08,\n\tOpRxMerge =\t0x10,\n\tOpTxMerge =\t0x20,\n\tOpWin95bugfix =\t0x40,\n\tOpLoopback =\t0x80,\n};\n\nenum rx_filter_bits {\n\tRxEnable =\t0x01,\n\tRxPolarity =\t0x02,\n\tRxForceOK =\t0x04,\n\tRxMultiCast =\t0x08,\n\tRxPromisc =\t0x10,\n\tAltRxPromisc =  0x20, /* F5U011 uses different bit */\n};\n\nenum led_values {\n\tLEDFast = \t0x01,\n\tLEDSlow =\t0x02,\n\tLEDFlash =\t0x03,\n\tLEDPulse =\t0x04,\n\tLEDLink =\t0x08,\n};\n\nenum link_status {\n\tLinkNoChange = 0,\n\tLinkGood     = 1,\n\tLinkBad      = 2\n};\n\n/*\n * The catc struct.\n */\n\n#define CTRL_RUNNING\t0\n#define RX_RUNNING\t1\n#define TX_RUNNING\t2\n\nstruct catc {\n\tstruct net_device *netdev;\n\tstruct usb_device *usbdev;\n\n\tunsigned long flags;\n\n\tunsigned int tx_ptr, tx_idx;\n\tunsigned int ctrl_head, ctrl_tail;\n\tspinlock_t tx_lock, ctrl_lock;\n\n\tu8 tx_buf[2][TX_MAX_BURST * (PKT_SZ + 2)];\n\tu8 rx_buf[RX_MAX_BURST * (PKT_SZ + 2)];\n\tu8 irq_buf[2];\n\tu8 ctrl_buf[64];\n\tstruct usb_ctrlrequest ctrl_dr;\n\n\tstruct timer_list timer;\n\tu8 stats_buf[8];\n\tu16 stats_vals[4];\n\tunsigned long last_stats;\n\n\tu8 multicast[64];\n\n\tstruct ctrl_queue {\n\t\tu8 dir;\n\t\tu8 request;\n\t\tu16 value;\n\t\tu16 index;\n\t\tvoid *buf;\n\t\tint len;\n\t\tvoid (*callback)(struct catc *catc, struct ctrl_queue *q);\n\t} ctrl_queue[CTRL_QUEUE];\n\n\tstruct urb *tx_urb, *rx_urb, *irq_urb, *ctrl_urb;\n\n\tu8 is_f5u011;\t/* Set if device is an F5U011 */\n\tu8 rxmode[2];\t/* Used for F5U011 */\n\tatomic_t recq_sz; /* Used for F5U011 - counter of waiting rx packets */\n};\n\n/*\n * Useful macros.\n */\n\n#define catc_get_mac(catc, mac)\t\t\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  GetMac, 0, 0, mac,  6)\n#define catc_reset(catc)\t\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, Reset, 0, 0, NULL, 0)\n#define catc_set_reg(catc, reg, val)\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0)\n#define catc_get_reg(catc, reg, buf)\t\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  GetReg, 0, reg, buf, 1)\n#define catc_write_mem(catc, addr, buf, size)\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size)\n#define catc_read_mem(catc, addr, buf, size)\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  ReadMem, 0, addr, buf, size)\n\n#define f5u011_rxmode(catc, rxmode)\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, SetRxMode, 0, 1, rxmode, 2)\n#define f5u011_rxmode_async(catc, rxmode)\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 1, &rxmode, 2, NULL)\n#define f5u011_mchash_async(catc, hash)\t\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 2, &hash, 8, NULL)\n\n#define catc_set_reg_async(catc, reg, val)\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0, NULL)\n#define catc_get_reg_async(catc, reg, cb)\t\tcatc_ctrl_async(catc, USB_DIR_IN, GetReg, 0, reg, NULL, 1, cb)\n#define catc_write_mem_async(catc, addr, buf, size)\tcatc_ctrl_async(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size, NULL)\n\n/*\n * Receive routines.\n */\n\nstatic void catc_rx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *pkt_start = urb->transfer_buffer;\n\tstruct sk_buff *skb;\n\tint pkt_len, pkt_offset = 0;\n\tint status = urb->status;\n\n\tif (!catc->is_f5u011) {\n\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\tpkt_offset = 2;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"rx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif(!catc->is_f5u011) {\n\t\t\tpkt_len = le16_to_cpup((__le16*)pkt_start);\n\t\t\tif (pkt_len > urb->actual_length) {\n\t\t\t\tcatc->netdev->stats.rx_length_errors++;\n\t\t\t\tcatc->netdev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpkt_len = urb->actual_length;\n\t\t}\n\n\t\tif (!(skb = dev_alloc_skb(pkt_len)))\n\t\t\treturn;\n\n\t\tskb_copy_to_linear_data(skb, pkt_start + pkt_offset, pkt_len);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->protocol = eth_type_trans(skb, catc->netdev);\n\t\tnetif_rx(skb);\n\n\t\tcatc->netdev->stats.rx_packets++;\n\t\tcatc->netdev->stats.rx_bytes += pkt_len;\n\n\t\t/* F5U011 only does one packet per RX */\n\t\tif (catc->is_f5u011)\n\t\t\tbreak;\n\t\tpkt_start += (((pkt_len + 1) >> 6) + 1) << 6;\n\n\t} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);\n\n\tif (catc->is_f5u011) {\n\t\tif (atomic_read(&catc->recq_sz)) {\n\t\t\tint state;\n\t\t\tatomic_dec(&catc->recq_sz);\n\t\t\tnetdev_dbg(catc->netdev, \"getting extra packet\\n\");\n\t\t\turb->dev = catc->usbdev;\n\t\t\tif ((state = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t\t   \"submit(rx_urb) status %d\\n\", state);\n\t\t\t}\n\t\t} else {\n\t\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\t}\n\t}\n}\n\nstatic void catc_irq_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tunsigned int hasdata = 0, linksts = LinkNoChange;\n\tint res;\n\n\tif (!catc->is_f5u011) {\n\t\thasdata = data[1] & 0x80;\n\t\tif (data[1] & 0x40)\n\t\t\tlinksts = LinkGood;\n\t\telse if (data[1] & 0x20)\n\t\t\tlinksts = LinkBad;\n\t} else {\n\t\thasdata = (unsigned int)(be16_to_cpup((__be16*)data) & 0x0fff);\n\t\tif (data[0] == 0x90)\n\t\t\tlinksts = LinkGood;\n\t\telse if (data[0] == 0xA0)\n\t\t\tlinksts = LinkBad;\n\t}\n\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\t\t/* error */\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"irq_done, status %d, data %02x %02x.\\n\",\n\t\t\tstatus, data[0], data[1]);\n\t\tgoto resubmit;\n\t}\n\n\tif (linksts == LinkGood) {\n\t\tnetif_carrier_on(catc->netdev);\n\t\tnetdev_dbg(catc->netdev, \"link ok\\n\");\n\t}\n\n\tif (linksts == LinkBad) {\n\t\tnetif_carrier_off(catc->netdev);\n\t\tnetdev_dbg(catc->netdev, \"link bad\\n\");\n\t}\n\n\tif (hasdata) {\n\t\tif (test_and_set_bit(RX_RUNNING, &catc->flags)) {\n\t\t\tif (catc->is_f5u011)\n\t\t\t\tatomic_inc(&catc->recq_sz);\n\t\t} else {\n\t\t\tcatc->rx_urb->dev = catc->usbdev;\n\t\t\tif ((res = usb_submit_urb(catc->rx_urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tdev_err(&catc->usbdev->dev,\n\t\t\t\t\t\"submit(rx_urb) status %d\\n\", res);\n\t\t\t}\n\t\t} \n\t}\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res)\n\t\tdev_err(&catc->usbdev->dev,\n\t\t\t\"can't resubmit intr, %s-%s, status %d\\n\",\n\t\t\tcatc->usbdev->bus->bus_name,\n\t\t\tcatc->usbdev->devpath, res);\n}\n\n/*\n * Transmit routines.\n */\n\nstatic int catc_tx_run(struct catc *catc)\n{\n\tint status;\n\n\tif (catc->is_f5u011)\n\t\tcatc->tx_ptr = (catc->tx_ptr + 63) & ~63;\n\n\tcatc->tx_urb->transfer_buffer_length = catc->tx_ptr;\n\tcatc->tx_urb->transfer_buffer = catc->tx_buf[catc->tx_idx];\n\tcatc->tx_urb->dev = catc->usbdev;\n\n\tif ((status = usb_submit_urb(catc->tx_urb, GFP_ATOMIC)) < 0)\n\t\tdev_err(&catc->usbdev->dev, \"submit(tx_urb), status %d\\n\",\n\t\t\tstatus);\n\n\tcatc->tx_idx = !catc->tx_idx;\n\tcatc->tx_ptr = 0;\n\n\tnetif_trans_update(catc->netdev);\n\treturn status;\n}\n\nstatic void catc_tx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tunsigned long flags;\n\tint r, status = urb->status;\n\n\tif (status == -ECONNRESET) {\n\t\tdev_dbg(&urb->dev->dev, \"Tx Reset.\\n\");\n\t\turb->status = 0;\n\t\tnetif_trans_update(catc->netdev);\n\t\tcatc->netdev->stats.tx_errors++;\n\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t\tnetif_wake_queue(catc->netdev);\n\t\treturn;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"tx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&catc->tx_lock, flags);\n\n\tif (catc->tx_ptr) {\n\t\tr = catc_tx_run(catc);\n\t\tif (unlikely(r < 0))\n\t\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t} else {\n\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t}\n\n\tnetif_wake_queue(catc->netdev);\n\n\tspin_unlock_irqrestore(&catc->tx_lock, flags);\n}\n\nstatic netdev_tx_t catc_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tunsigned long flags;\n\tint r = 0;\n\tchar *tx_buf;\n\n\tspin_lock_irqsave(&catc->tx_lock, flags);\n\n\tcatc->tx_ptr = (((catc->tx_ptr - 1) >> 6) + 1) << 6;\n\ttx_buf = catc->tx_buf[catc->tx_idx] + catc->tx_ptr;\n\tif (catc->is_f5u011)\n\t\t*(__be16 *)tx_buf = cpu_to_be16(skb->len);\n\telse\n\t\t*(__le16 *)tx_buf = cpu_to_le16(skb->len);\n\tskb_copy_from_linear_data(skb, tx_buf + 2, skb->len);\n\tcatc->tx_ptr += skb->len + 2;\n\n\tif (!test_and_set_bit(TX_RUNNING, &catc->flags)) {\n\t\tr = catc_tx_run(catc);\n\t\tif (r < 0)\n\t\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t}\n\n\tif ((catc->is_f5u011 && catc->tx_ptr) ||\n\t    (catc->tx_ptr >= ((TX_MAX_BURST - 1) * (PKT_SZ + 2))))\n\t\tnetif_stop_queue(netdev);\n\n\tspin_unlock_irqrestore(&catc->tx_lock, flags);\n\n\tif (r >= 0) {\n\t\tcatc->netdev->stats.tx_bytes += skb->len;\n\t\tcatc->netdev->stats.tx_packets++;\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void catc_tx_timeout(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tdev_warn(&netdev->dev, \"Transmit timed out.\\n\");\n\tusb_unlink_urb(catc->tx_urb);\n}\n\n/*\n * Control messages.\n */\n\nstatic int catc_ctrl_msg(struct catc *catc, u8 dir, u8 request, u16 value, u16 index, void *buf, int len)\n{\n        int retval = usb_control_msg(catc->usbdev,\n\t\tdir ? usb_rcvctrlpipe(catc->usbdev, 0) : usb_sndctrlpipe(catc->usbdev, 0),\n\t\t request, 0x40 | dir, value, index, buf, len, 1000);\n        return retval < 0 ? retval : 0;\n}\n\nstatic void catc_ctrl_run(struct catc *catc)\n{\n\tstruct ctrl_queue *q = catc->ctrl_queue + catc->ctrl_tail;\n\tstruct usb_device *usbdev = catc->usbdev;\n\tstruct urb *urb = catc->ctrl_urb;\n\tstruct usb_ctrlrequest *dr = &catc->ctrl_dr;\n\tint status;\n\n\tdr->bRequest = q->request;\n\tdr->bRequestType = 0x40 | q->dir;\n\tdr->wValue = cpu_to_le16(q->value);\n\tdr->wIndex = cpu_to_le16(q->index);\n\tdr->wLength = cpu_to_le16(q->len);\n\n        urb->pipe = q->dir ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0);\n\turb->transfer_buffer_length = q->len;\n\turb->transfer_buffer = catc->ctrl_buf;\n\turb->setup_packet = (void *) dr;\n\turb->dev = usbdev;\n\n\tif (!q->dir && q->buf && q->len)\n\t\tmemcpy(catc->ctrl_buf, q->buf, q->len);\n\n\tif ((status = usb_submit_urb(catc->ctrl_urb, GFP_ATOMIC)))\n\t\tdev_err(&catc->usbdev->dev, \"submit(ctrl_urb) status %d\\n\",\n\t\t\tstatus);\n}\n\nstatic void catc_ctrl_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tstruct ctrl_queue *q;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tif (status)\n\t\tdev_dbg(&urb->dev->dev, \"ctrl_done, status %d, len %d.\\n\",\n\t\t\tstatus, urb->actual_length);\n\n\tspin_lock_irqsave(&catc->ctrl_lock, flags);\n\n\tq = catc->ctrl_queue + catc->ctrl_tail;\n\n\tif (q->dir) {\n\t\tif (q->buf && q->len)\n\t\t\tmemcpy(q->buf, catc->ctrl_buf, q->len);\n\t\telse\n\t\t\tq->buf = catc->ctrl_buf;\n\t}\n\n\tif (q->callback)\n\t\tq->callback(catc, q);\n\n\tcatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\n\n\tif (catc->ctrl_head != catc->ctrl_tail)\n\t\tcatc_ctrl_run(catc);\n\telse\n\t\tclear_bit(CTRL_RUNNING, &catc->flags);\n\n\tspin_unlock_irqrestore(&catc->ctrl_lock, flags);\n}\n\nstatic int catc_ctrl_async(struct catc *catc, u8 dir, u8 request, u16 value,\n\tu16 index, void *buf, int len, void (*callback)(struct catc *catc, struct ctrl_queue *q))\n{\n\tstruct ctrl_queue *q;\n\tint retval = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&catc->ctrl_lock, flags);\n\t\n\tq = catc->ctrl_queue + catc->ctrl_head;\n\n\tq->dir = dir;\n\tq->request = request;\n\tq->value = value;\n\tq->index = index;\n\tq->buf = buf;\n\tq->len = len;\n\tq->callback = callback;\n\n\tcatc->ctrl_head = (catc->ctrl_head + 1) & (CTRL_QUEUE - 1);\n\n\tif (catc->ctrl_head == catc->ctrl_tail) {\n\t\tdev_err(&catc->usbdev->dev, \"ctrl queue full\\n\");\n\t\tcatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\n\t\tretval = -1;\n\t}\n\n\tif (!test_and_set_bit(CTRL_RUNNING, &catc->flags))\n\t\tcatc_ctrl_run(catc);\n\n\tspin_unlock_irqrestore(&catc->ctrl_lock, flags);\n\n\treturn retval;\n}\n\n/*\n * Statistics.\n */\n\nstatic void catc_stats_done(struct catc *catc, struct ctrl_queue *q)\n{\n\tint index = q->index - EthStats;\n\tu16 data, last;\n\n\tcatc->stats_buf[index] = *((char *)q->buf);\n\n\tif (index & 1)\n\t\treturn;\n\n\tdata = ((u16)catc->stats_buf[index] << 8) | catc->stats_buf[index + 1];\n\tlast = catc->stats_vals[index >> 1];\n\n\tswitch (index) {\n\t\tcase TxSingleColl:\n\t\tcase TxMultiColl:\n\t\t\tcatc->netdev->stats.collisions += data - last;\n\t\t\tbreak;\n\t\tcase TxExcessColl:\n\t\t\tcatc->netdev->stats.tx_aborted_errors += data - last;\n\t\t\tcatc->netdev->stats.tx_errors += data - last;\n\t\t\tbreak;\n\t\tcase RxFramErr:\n\t\t\tcatc->netdev->stats.rx_frame_errors += data - last;\n\t\t\tcatc->netdev->stats.rx_errors += data - last;\n\t\t\tbreak;\n\t}\n\n\tcatc->stats_vals[index >> 1] = data;\n}\n\nstatic void catc_stats_timer(unsigned long data)\n{\n\tstruct catc *catc = (void *) data;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tcatc_get_reg_async(catc, EthStats + 7 - i, catc_stats_done);\n\n\tmod_timer(&catc->timer, jiffies + STATS_UPDATE);\n}\n\n/*\n * Receive modes. Broadcast, Multicast, Promisc.\n */\n\nstatic void catc_multicast(unsigned char *addr, u8 *multicast)\n{\n\tu32 crc;\n\n\tcrc = ether_crc_le(6, addr);\n\tmulticast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\n}\n\nstatic void catc_set_multicast_list(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tu8 broadcast[ETH_ALEN];\n\tu8 rx = RxEnable | RxPolarity | RxMultiCast;\n\n\teth_broadcast_addr(broadcast);\n\tmemset(catc->multicast, 0, 64);\n\n\tcatc_multicast(broadcast, catc->multicast);\n\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tmemset(catc->multicast, 0xff, 64);\n\t\trx |= (!catc->is_f5u011) ? RxPromisc : AltRxPromisc;\n\t} \n\n\tif (netdev->flags & IFF_ALLMULTI) {\n\t\tmemset(catc->multicast, 0xff, 64);\n\t} else {\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tu32 crc = ether_crc_le(6, ha->addr);\n\t\t\tif (!catc->is_f5u011) {\n\t\t\t\tcatc->multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\n\t\t\t} else {\n\t\t\t\tcatc->multicast[7-(crc >> 29)] |= 1 << ((crc >> 26) & 7);\n\t\t\t}\n\t\t}\n\t}\n\tif (!catc->is_f5u011) {\n\t\tcatc_set_reg_async(catc, RxUnit, rx);\n\t\tcatc_write_mem_async(catc, 0xfa80, catc->multicast, 64);\n\t} else {\n\t\tf5u011_mchash_async(catc, catc->multicast);\n\t\tif (catc->rxmode[0] != rx) {\n\t\t\tcatc->rxmode[0] = rx;\n\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t   \"Setting RX mode to %2.2X %2.2X\\n\",\n\t\t\t\t   catc->rxmode[0], catc->rxmode[1]);\n\t\t\tf5u011_rxmode_async(catc, catc->rxmode);\n\t\t}\n\t}\n}\n\nstatic void catc_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct catc *catc = netdev_priv(dev);\n\tstrlcpy(info->driver, driver_name, sizeof(info->driver));\n\tstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(catc->usbdev, info->bus_info, sizeof(info->bus_info));\n}\n\nstatic int catc_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tstruct catc *catc = netdev_priv(dev);\n\tif (!catc->is_f5u011)\n\t\treturn -EOPNOTSUPP;\n\n\tcmd->supported = SUPPORTED_10baseT_Half | SUPPORTED_TP;\n\tcmd->advertising = ADVERTISED_10baseT_Half | ADVERTISED_TP;\n\tethtool_cmd_speed_set(cmd, SPEED_10);\n\tcmd->duplex = DUPLEX_HALF;\n\tcmd->port = PORT_TP; \n\tcmd->phy_address = 0;\n\tcmd->transceiver = XCVR_INTERNAL;\n\tcmd->autoneg = AUTONEG_DISABLE;\n\tcmd->maxtxpkt = 1;\n\tcmd->maxrxpkt = 1;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = catc_get_drvinfo,\n\t.get_settings = catc_get_settings,\n\t.get_link = ethtool_op_get_link\n};\n\n/*\n * Open, close.\n */\n\nstatic int catc_open(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tint status;\n\n\tcatc->irq_urb->dev = catc->usbdev;\n\tif ((status = usb_submit_urb(catc->irq_urb, GFP_KERNEL)) < 0) {\n\t\tdev_err(&catc->usbdev->dev, \"submit(irq_urb) status %d\\n\",\n\t\t\tstatus);\n\t\treturn -1;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tmod_timer(&catc->timer, jiffies + STATS_UPDATE);\n\n\treturn 0;\n}\n\nstatic int catc_stop(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tdel_timer_sync(&catc->timer);\n\n\tusb_kill_urb(catc->rx_urb);\n\tusb_kill_urb(catc->tx_urb);\n\tusb_kill_urb(catc->irq_urb);\n\tusb_kill_urb(catc->ctrl_urb);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops catc_netdev_ops = {\n\t.ndo_open\t\t= catc_open,\n\t.ndo_stop\t\t= catc_stop,\n\t.ndo_start_xmit\t\t= catc_start_xmit,\n\n\t.ndo_tx_timeout\t\t= catc_tx_timeout,\n\t.ndo_set_rx_mode\t= catc_set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n/*\n * USB probe, disconnect.\n */\n\nstatic int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint i, pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\tinit_timer(&catc->timer);\n\tcatc->timer.data = (long) catc;\n\tcatc->timer.function = catc_stats_timer;\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) || \n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */\n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 && \n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\t\t\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\t\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\ti = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, &i, 4);\n\t\ti = 0x87654321;\t\n\t\tcatc_write_mem(catc, 0xfa80, &i, 4);\n\t\tcatc_read_mem(catc, 0x7a80, &i, 4);\n\t  \n\t\tswitch (i) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\t  \n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\t\t\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\t\t\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\t\t\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\t\t\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\n\treturn ret;\n}\n\nstatic void catc_disconnect(struct usb_interface *intf)\n{\n\tstruct catc *catc = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (catc) {\n\t\tunregister_netdev(catc->netdev);\n\t\tusb_free_urb(catc->ctrl_urb);\n\t\tusb_free_urb(catc->tx_urb);\n\t\tusb_free_urb(catc->rx_urb);\n\t\tusb_free_urb(catc->irq_urb);\n\t\tfree_netdev(catc->netdev);\n\t}\n}\n\n/*\n * Module functions and tables.\n */\n\nstatic struct usb_device_id catc_id_table [] = {\n\t{ USB_DEVICE(0x0423, 0xa) },\t/* CATC Netmate, Belkin F5U011 */\n\t{ USB_DEVICE(0x0423, 0xc) },\t/* CATC Netmate II, Belkin F5U111 */\n\t{ USB_DEVICE(0x08d1, 0x1) },\t/* smartBridges smartNIC */\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, catc_id_table);\n\nstatic struct usb_driver catc_driver = {\n\t.name =\t\tdriver_name,\n\t.probe =\tcatc_probe,\n\t.disconnect =\tcatc_disconnect,\n\t.id_table =\tcatc_id_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(catc_driver);\n"], "fixing_code": ["/*\n *  Copyright (c) 2001 Vojtech Pavlik\n *\n *  CATC EL1210A NetMate USB Ethernet driver\n *\n *  Sponsored by SuSE\n *\n *  Based on the work of\n *\t\tDonald Becker\n * \n *  Old chipset support added by Simon Evans <spse@secret.org.uk> 2002\n *    - adds support for Belkin F5U011\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or \n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n * \n * Should you need to contact me, the author, you can do so either by\n * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:\n * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n\n#undef DEBUG\n\n#include <linux/usb.h>\n\n/*\n * Version information.\n */\n\n#define DRIVER_VERSION \"v2.8\"\n#define DRIVER_AUTHOR \"Vojtech Pavlik <vojtech@suse.cz>\"\n#define DRIVER_DESC \"CATC EL1210A NetMate USB Ethernet driver\"\n#define SHORT_DRIVER_DESC \"EL1210A NetMate USB Ethernet\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char driver_name[] = \"catc\";\n\n/*\n * Some defines.\n */ \n\n#define STATS_UPDATE\t\t(HZ)\t/* Time between stats updates */\n#define TX_TIMEOUT\t\t(5*HZ)\t/* Max time the queue can be stopped */\n#define PKT_SZ\t\t\t1536\t/* Max Ethernet packet size */\n#define RX_MAX_BURST\t\t15\t/* Max packets per rx buffer (> 0, < 16) */\n#define TX_MAX_BURST\t\t15\t/* Max full sized packets per tx buffer (> 0) */\n#define CTRL_QUEUE\t\t16\t/* Max control requests in flight (power of two) */\n#define RX_PKT_SZ\t\t1600\t/* Max size of receive packet for F5U011 */\n\n/*\n * Control requests.\n */\n\nenum control_requests {\n\tReadMem =\t0xf1,\n\tGetMac =\t0xf2,\n\tReset =\t\t0xf4,\n\tSetMac =\t0xf5,\n\tSetRxMode =     0xf5,  /* F5U011 only */\n\tWriteROM =\t0xf8,\n\tSetReg =\t0xfa,\n\tGetReg =\t0xfb,\n\tWriteMem =\t0xfc,\n\tReadROM =\t0xfd,\n};\n\n/*\n * Registers.\n */\n\nenum register_offsets {\n\tTxBufCount =\t0x20,\n\tRxBufCount =\t0x21,\n\tOpModes =\t0x22,\n\tTxQed =\t\t0x23,\n\tRxQed =\t\t0x24,\n\tMaxBurst =\t0x25,\n\tRxUnit =\t0x60,\n\tEthStatus =\t0x61,\n\tStationAddr0 =\t0x67,\n\tEthStats =\t0x69,\n\tLEDCtrl =\t0x81,\n};\n\nenum eth_stats {\n\tTxSingleColl =\t0x00,\n        TxMultiColl =\t0x02,\n        TxExcessColl =\t0x04,\n        RxFramErr =\t0x06,\n};\n\nenum op_mode_bits {\n\tOp3MemWaits =\t0x03,\n\tOpLenInclude =\t0x08,\n\tOpRxMerge =\t0x10,\n\tOpTxMerge =\t0x20,\n\tOpWin95bugfix =\t0x40,\n\tOpLoopback =\t0x80,\n};\n\nenum rx_filter_bits {\n\tRxEnable =\t0x01,\n\tRxPolarity =\t0x02,\n\tRxForceOK =\t0x04,\n\tRxMultiCast =\t0x08,\n\tRxPromisc =\t0x10,\n\tAltRxPromisc =  0x20, /* F5U011 uses different bit */\n};\n\nenum led_values {\n\tLEDFast = \t0x01,\n\tLEDSlow =\t0x02,\n\tLEDFlash =\t0x03,\n\tLEDPulse =\t0x04,\n\tLEDLink =\t0x08,\n};\n\nenum link_status {\n\tLinkNoChange = 0,\n\tLinkGood     = 1,\n\tLinkBad      = 2\n};\n\n/*\n * The catc struct.\n */\n\n#define CTRL_RUNNING\t0\n#define RX_RUNNING\t1\n#define TX_RUNNING\t2\n\nstruct catc {\n\tstruct net_device *netdev;\n\tstruct usb_device *usbdev;\n\n\tunsigned long flags;\n\n\tunsigned int tx_ptr, tx_idx;\n\tunsigned int ctrl_head, ctrl_tail;\n\tspinlock_t tx_lock, ctrl_lock;\n\n\tu8 tx_buf[2][TX_MAX_BURST * (PKT_SZ + 2)];\n\tu8 rx_buf[RX_MAX_BURST * (PKT_SZ + 2)];\n\tu8 irq_buf[2];\n\tu8 ctrl_buf[64];\n\tstruct usb_ctrlrequest ctrl_dr;\n\n\tstruct timer_list timer;\n\tu8 stats_buf[8];\n\tu16 stats_vals[4];\n\tunsigned long last_stats;\n\n\tu8 multicast[64];\n\n\tstruct ctrl_queue {\n\t\tu8 dir;\n\t\tu8 request;\n\t\tu16 value;\n\t\tu16 index;\n\t\tvoid *buf;\n\t\tint len;\n\t\tvoid (*callback)(struct catc *catc, struct ctrl_queue *q);\n\t} ctrl_queue[CTRL_QUEUE];\n\n\tstruct urb *tx_urb, *rx_urb, *irq_urb, *ctrl_urb;\n\n\tu8 is_f5u011;\t/* Set if device is an F5U011 */\n\tu8 rxmode[2];\t/* Used for F5U011 */\n\tatomic_t recq_sz; /* Used for F5U011 - counter of waiting rx packets */\n};\n\n/*\n * Useful macros.\n */\n\n#define catc_get_mac(catc, mac)\t\t\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  GetMac, 0, 0, mac,  6)\n#define catc_reset(catc)\t\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, Reset, 0, 0, NULL, 0)\n#define catc_set_reg(catc, reg, val)\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0)\n#define catc_get_reg(catc, reg, buf)\t\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  GetReg, 0, reg, buf, 1)\n#define catc_write_mem(catc, addr, buf, size)\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size)\n#define catc_read_mem(catc, addr, buf, size)\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  ReadMem, 0, addr, buf, size)\n\n#define f5u011_rxmode(catc, rxmode)\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, SetRxMode, 0, 1, rxmode, 2)\n#define f5u011_rxmode_async(catc, rxmode)\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 1, &rxmode, 2, NULL)\n#define f5u011_mchash_async(catc, hash)\t\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 2, &hash, 8, NULL)\n\n#define catc_set_reg_async(catc, reg, val)\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0, NULL)\n#define catc_get_reg_async(catc, reg, cb)\t\tcatc_ctrl_async(catc, USB_DIR_IN, GetReg, 0, reg, NULL, 1, cb)\n#define catc_write_mem_async(catc, addr, buf, size)\tcatc_ctrl_async(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size, NULL)\n\n/*\n * Receive routines.\n */\n\nstatic void catc_rx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *pkt_start = urb->transfer_buffer;\n\tstruct sk_buff *skb;\n\tint pkt_len, pkt_offset = 0;\n\tint status = urb->status;\n\n\tif (!catc->is_f5u011) {\n\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\tpkt_offset = 2;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"rx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif(!catc->is_f5u011) {\n\t\t\tpkt_len = le16_to_cpup((__le16*)pkt_start);\n\t\t\tif (pkt_len > urb->actual_length) {\n\t\t\t\tcatc->netdev->stats.rx_length_errors++;\n\t\t\t\tcatc->netdev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpkt_len = urb->actual_length;\n\t\t}\n\n\t\tif (!(skb = dev_alloc_skb(pkt_len)))\n\t\t\treturn;\n\n\t\tskb_copy_to_linear_data(skb, pkt_start + pkt_offset, pkt_len);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->protocol = eth_type_trans(skb, catc->netdev);\n\t\tnetif_rx(skb);\n\n\t\tcatc->netdev->stats.rx_packets++;\n\t\tcatc->netdev->stats.rx_bytes += pkt_len;\n\n\t\t/* F5U011 only does one packet per RX */\n\t\tif (catc->is_f5u011)\n\t\t\tbreak;\n\t\tpkt_start += (((pkt_len + 1) >> 6) + 1) << 6;\n\n\t} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);\n\n\tif (catc->is_f5u011) {\n\t\tif (atomic_read(&catc->recq_sz)) {\n\t\t\tint state;\n\t\t\tatomic_dec(&catc->recq_sz);\n\t\t\tnetdev_dbg(catc->netdev, \"getting extra packet\\n\");\n\t\t\turb->dev = catc->usbdev;\n\t\t\tif ((state = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t\t   \"submit(rx_urb) status %d\\n\", state);\n\t\t\t}\n\t\t} else {\n\t\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\t}\n\t}\n}\n\nstatic void catc_irq_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tunsigned int hasdata = 0, linksts = LinkNoChange;\n\tint res;\n\n\tif (!catc->is_f5u011) {\n\t\thasdata = data[1] & 0x80;\n\t\tif (data[1] & 0x40)\n\t\t\tlinksts = LinkGood;\n\t\telse if (data[1] & 0x20)\n\t\t\tlinksts = LinkBad;\n\t} else {\n\t\thasdata = (unsigned int)(be16_to_cpup((__be16*)data) & 0x0fff);\n\t\tif (data[0] == 0x90)\n\t\t\tlinksts = LinkGood;\n\t\telse if (data[0] == 0xA0)\n\t\t\tlinksts = LinkBad;\n\t}\n\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\t\t/* error */\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"irq_done, status %d, data %02x %02x.\\n\",\n\t\t\tstatus, data[0], data[1]);\n\t\tgoto resubmit;\n\t}\n\n\tif (linksts == LinkGood) {\n\t\tnetif_carrier_on(catc->netdev);\n\t\tnetdev_dbg(catc->netdev, \"link ok\\n\");\n\t}\n\n\tif (linksts == LinkBad) {\n\t\tnetif_carrier_off(catc->netdev);\n\t\tnetdev_dbg(catc->netdev, \"link bad\\n\");\n\t}\n\n\tif (hasdata) {\n\t\tif (test_and_set_bit(RX_RUNNING, &catc->flags)) {\n\t\t\tif (catc->is_f5u011)\n\t\t\t\tatomic_inc(&catc->recq_sz);\n\t\t} else {\n\t\t\tcatc->rx_urb->dev = catc->usbdev;\n\t\t\tif ((res = usb_submit_urb(catc->rx_urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tdev_err(&catc->usbdev->dev,\n\t\t\t\t\t\"submit(rx_urb) status %d\\n\", res);\n\t\t\t}\n\t\t} \n\t}\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res)\n\t\tdev_err(&catc->usbdev->dev,\n\t\t\t\"can't resubmit intr, %s-%s, status %d\\n\",\n\t\t\tcatc->usbdev->bus->bus_name,\n\t\t\tcatc->usbdev->devpath, res);\n}\n\n/*\n * Transmit routines.\n */\n\nstatic int catc_tx_run(struct catc *catc)\n{\n\tint status;\n\n\tif (catc->is_f5u011)\n\t\tcatc->tx_ptr = (catc->tx_ptr + 63) & ~63;\n\n\tcatc->tx_urb->transfer_buffer_length = catc->tx_ptr;\n\tcatc->tx_urb->transfer_buffer = catc->tx_buf[catc->tx_idx];\n\tcatc->tx_urb->dev = catc->usbdev;\n\n\tif ((status = usb_submit_urb(catc->tx_urb, GFP_ATOMIC)) < 0)\n\t\tdev_err(&catc->usbdev->dev, \"submit(tx_urb), status %d\\n\",\n\t\t\tstatus);\n\n\tcatc->tx_idx = !catc->tx_idx;\n\tcatc->tx_ptr = 0;\n\n\tnetif_trans_update(catc->netdev);\n\treturn status;\n}\n\nstatic void catc_tx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tunsigned long flags;\n\tint r, status = urb->status;\n\n\tif (status == -ECONNRESET) {\n\t\tdev_dbg(&urb->dev->dev, \"Tx Reset.\\n\");\n\t\turb->status = 0;\n\t\tnetif_trans_update(catc->netdev);\n\t\tcatc->netdev->stats.tx_errors++;\n\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t\tnetif_wake_queue(catc->netdev);\n\t\treturn;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"tx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&catc->tx_lock, flags);\n\n\tif (catc->tx_ptr) {\n\t\tr = catc_tx_run(catc);\n\t\tif (unlikely(r < 0))\n\t\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t} else {\n\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t}\n\n\tnetif_wake_queue(catc->netdev);\n\n\tspin_unlock_irqrestore(&catc->tx_lock, flags);\n}\n\nstatic netdev_tx_t catc_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tunsigned long flags;\n\tint r = 0;\n\tchar *tx_buf;\n\n\tspin_lock_irqsave(&catc->tx_lock, flags);\n\n\tcatc->tx_ptr = (((catc->tx_ptr - 1) >> 6) + 1) << 6;\n\ttx_buf = catc->tx_buf[catc->tx_idx] + catc->tx_ptr;\n\tif (catc->is_f5u011)\n\t\t*(__be16 *)tx_buf = cpu_to_be16(skb->len);\n\telse\n\t\t*(__le16 *)tx_buf = cpu_to_le16(skb->len);\n\tskb_copy_from_linear_data(skb, tx_buf + 2, skb->len);\n\tcatc->tx_ptr += skb->len + 2;\n\n\tif (!test_and_set_bit(TX_RUNNING, &catc->flags)) {\n\t\tr = catc_tx_run(catc);\n\t\tif (r < 0)\n\t\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t}\n\n\tif ((catc->is_f5u011 && catc->tx_ptr) ||\n\t    (catc->tx_ptr >= ((TX_MAX_BURST - 1) * (PKT_SZ + 2))))\n\t\tnetif_stop_queue(netdev);\n\n\tspin_unlock_irqrestore(&catc->tx_lock, flags);\n\n\tif (r >= 0) {\n\t\tcatc->netdev->stats.tx_bytes += skb->len;\n\t\tcatc->netdev->stats.tx_packets++;\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void catc_tx_timeout(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tdev_warn(&netdev->dev, \"Transmit timed out.\\n\");\n\tusb_unlink_urb(catc->tx_urb);\n}\n\n/*\n * Control messages.\n */\n\nstatic int catc_ctrl_msg(struct catc *catc, u8 dir, u8 request, u16 value, u16 index, void *buf, int len)\n{\n        int retval = usb_control_msg(catc->usbdev,\n\t\tdir ? usb_rcvctrlpipe(catc->usbdev, 0) : usb_sndctrlpipe(catc->usbdev, 0),\n\t\t request, 0x40 | dir, value, index, buf, len, 1000);\n        return retval < 0 ? retval : 0;\n}\n\nstatic void catc_ctrl_run(struct catc *catc)\n{\n\tstruct ctrl_queue *q = catc->ctrl_queue + catc->ctrl_tail;\n\tstruct usb_device *usbdev = catc->usbdev;\n\tstruct urb *urb = catc->ctrl_urb;\n\tstruct usb_ctrlrequest *dr = &catc->ctrl_dr;\n\tint status;\n\n\tdr->bRequest = q->request;\n\tdr->bRequestType = 0x40 | q->dir;\n\tdr->wValue = cpu_to_le16(q->value);\n\tdr->wIndex = cpu_to_le16(q->index);\n\tdr->wLength = cpu_to_le16(q->len);\n\n        urb->pipe = q->dir ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0);\n\turb->transfer_buffer_length = q->len;\n\turb->transfer_buffer = catc->ctrl_buf;\n\turb->setup_packet = (void *) dr;\n\turb->dev = usbdev;\n\n\tif (!q->dir && q->buf && q->len)\n\t\tmemcpy(catc->ctrl_buf, q->buf, q->len);\n\n\tif ((status = usb_submit_urb(catc->ctrl_urb, GFP_ATOMIC)))\n\t\tdev_err(&catc->usbdev->dev, \"submit(ctrl_urb) status %d\\n\",\n\t\t\tstatus);\n}\n\nstatic void catc_ctrl_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tstruct ctrl_queue *q;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tif (status)\n\t\tdev_dbg(&urb->dev->dev, \"ctrl_done, status %d, len %d.\\n\",\n\t\t\tstatus, urb->actual_length);\n\n\tspin_lock_irqsave(&catc->ctrl_lock, flags);\n\n\tq = catc->ctrl_queue + catc->ctrl_tail;\n\n\tif (q->dir) {\n\t\tif (q->buf && q->len)\n\t\t\tmemcpy(q->buf, catc->ctrl_buf, q->len);\n\t\telse\n\t\t\tq->buf = catc->ctrl_buf;\n\t}\n\n\tif (q->callback)\n\t\tq->callback(catc, q);\n\n\tcatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\n\n\tif (catc->ctrl_head != catc->ctrl_tail)\n\t\tcatc_ctrl_run(catc);\n\telse\n\t\tclear_bit(CTRL_RUNNING, &catc->flags);\n\n\tspin_unlock_irqrestore(&catc->ctrl_lock, flags);\n}\n\nstatic int catc_ctrl_async(struct catc *catc, u8 dir, u8 request, u16 value,\n\tu16 index, void *buf, int len, void (*callback)(struct catc *catc, struct ctrl_queue *q))\n{\n\tstruct ctrl_queue *q;\n\tint retval = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&catc->ctrl_lock, flags);\n\t\n\tq = catc->ctrl_queue + catc->ctrl_head;\n\n\tq->dir = dir;\n\tq->request = request;\n\tq->value = value;\n\tq->index = index;\n\tq->buf = buf;\n\tq->len = len;\n\tq->callback = callback;\n\n\tcatc->ctrl_head = (catc->ctrl_head + 1) & (CTRL_QUEUE - 1);\n\n\tif (catc->ctrl_head == catc->ctrl_tail) {\n\t\tdev_err(&catc->usbdev->dev, \"ctrl queue full\\n\");\n\t\tcatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\n\t\tretval = -1;\n\t}\n\n\tif (!test_and_set_bit(CTRL_RUNNING, &catc->flags))\n\t\tcatc_ctrl_run(catc);\n\n\tspin_unlock_irqrestore(&catc->ctrl_lock, flags);\n\n\treturn retval;\n}\n\n/*\n * Statistics.\n */\n\nstatic void catc_stats_done(struct catc *catc, struct ctrl_queue *q)\n{\n\tint index = q->index - EthStats;\n\tu16 data, last;\n\n\tcatc->stats_buf[index] = *((char *)q->buf);\n\n\tif (index & 1)\n\t\treturn;\n\n\tdata = ((u16)catc->stats_buf[index] << 8) | catc->stats_buf[index + 1];\n\tlast = catc->stats_vals[index >> 1];\n\n\tswitch (index) {\n\t\tcase TxSingleColl:\n\t\tcase TxMultiColl:\n\t\t\tcatc->netdev->stats.collisions += data - last;\n\t\t\tbreak;\n\t\tcase TxExcessColl:\n\t\t\tcatc->netdev->stats.tx_aborted_errors += data - last;\n\t\t\tcatc->netdev->stats.tx_errors += data - last;\n\t\t\tbreak;\n\t\tcase RxFramErr:\n\t\t\tcatc->netdev->stats.rx_frame_errors += data - last;\n\t\t\tcatc->netdev->stats.rx_errors += data - last;\n\t\t\tbreak;\n\t}\n\n\tcatc->stats_vals[index >> 1] = data;\n}\n\nstatic void catc_stats_timer(unsigned long data)\n{\n\tstruct catc *catc = (void *) data;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tcatc_get_reg_async(catc, EthStats + 7 - i, catc_stats_done);\n\n\tmod_timer(&catc->timer, jiffies + STATS_UPDATE);\n}\n\n/*\n * Receive modes. Broadcast, Multicast, Promisc.\n */\n\nstatic void catc_multicast(unsigned char *addr, u8 *multicast)\n{\n\tu32 crc;\n\n\tcrc = ether_crc_le(6, addr);\n\tmulticast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\n}\n\nstatic void catc_set_multicast_list(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tu8 broadcast[ETH_ALEN];\n\tu8 rx = RxEnable | RxPolarity | RxMultiCast;\n\n\teth_broadcast_addr(broadcast);\n\tmemset(catc->multicast, 0, 64);\n\n\tcatc_multicast(broadcast, catc->multicast);\n\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tmemset(catc->multicast, 0xff, 64);\n\t\trx |= (!catc->is_f5u011) ? RxPromisc : AltRxPromisc;\n\t} \n\n\tif (netdev->flags & IFF_ALLMULTI) {\n\t\tmemset(catc->multicast, 0xff, 64);\n\t} else {\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tu32 crc = ether_crc_le(6, ha->addr);\n\t\t\tif (!catc->is_f5u011) {\n\t\t\t\tcatc->multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\n\t\t\t} else {\n\t\t\t\tcatc->multicast[7-(crc >> 29)] |= 1 << ((crc >> 26) & 7);\n\t\t\t}\n\t\t}\n\t}\n\tif (!catc->is_f5u011) {\n\t\tcatc_set_reg_async(catc, RxUnit, rx);\n\t\tcatc_write_mem_async(catc, 0xfa80, catc->multicast, 64);\n\t} else {\n\t\tf5u011_mchash_async(catc, catc->multicast);\n\t\tif (catc->rxmode[0] != rx) {\n\t\t\tcatc->rxmode[0] = rx;\n\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t   \"Setting RX mode to %2.2X %2.2X\\n\",\n\t\t\t\t   catc->rxmode[0], catc->rxmode[1]);\n\t\t\tf5u011_rxmode_async(catc, catc->rxmode);\n\t\t}\n\t}\n}\n\nstatic void catc_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct catc *catc = netdev_priv(dev);\n\tstrlcpy(info->driver, driver_name, sizeof(info->driver));\n\tstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(catc->usbdev, info->bus_info, sizeof(info->bus_info));\n}\n\nstatic int catc_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tstruct catc *catc = netdev_priv(dev);\n\tif (!catc->is_f5u011)\n\t\treturn -EOPNOTSUPP;\n\n\tcmd->supported = SUPPORTED_10baseT_Half | SUPPORTED_TP;\n\tcmd->advertising = ADVERTISED_10baseT_Half | ADVERTISED_TP;\n\tethtool_cmd_speed_set(cmd, SPEED_10);\n\tcmd->duplex = DUPLEX_HALF;\n\tcmd->port = PORT_TP; \n\tcmd->phy_address = 0;\n\tcmd->transceiver = XCVR_INTERNAL;\n\tcmd->autoneg = AUTONEG_DISABLE;\n\tcmd->maxtxpkt = 1;\n\tcmd->maxrxpkt = 1;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = catc_get_drvinfo,\n\t.get_settings = catc_get_settings,\n\t.get_link = ethtool_op_get_link\n};\n\n/*\n * Open, close.\n */\n\nstatic int catc_open(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tint status;\n\n\tcatc->irq_urb->dev = catc->usbdev;\n\tif ((status = usb_submit_urb(catc->irq_urb, GFP_KERNEL)) < 0) {\n\t\tdev_err(&catc->usbdev->dev, \"submit(irq_urb) status %d\\n\",\n\t\t\tstatus);\n\t\treturn -1;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tmod_timer(&catc->timer, jiffies + STATS_UPDATE);\n\n\treturn 0;\n}\n\nstatic int catc_stop(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tdel_timer_sync(&catc->timer);\n\n\tusb_kill_urb(catc->rx_urb);\n\tusb_kill_urb(catc->tx_urb);\n\tusb_kill_urb(catc->irq_urb);\n\tusb_kill_urb(catc->ctrl_urb);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops catc_netdev_ops = {\n\t.ndo_open\t\t= catc_open,\n\t.ndo_stop\t\t= catc_stop,\n\t.ndo_start_xmit\t\t= catc_start_xmit,\n\n\t.ndo_tx_timeout\t\t= catc_tx_timeout,\n\t.ndo_set_rx_mode\t= catc_set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n/*\n * USB probe, disconnect.\n */\n\nstatic int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\tinit_timer(&catc->timer);\n\tcatc->timer.data = (long) catc;\n\tcatc->timer.function = catc_stats_timer;\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) || \n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */\n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 && \n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\t\t\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\t\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\t  \n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\t  \n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\t\t\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\t\t\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\t\t\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\t\t\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\n\treturn ret;\n}\n\nstatic void catc_disconnect(struct usb_interface *intf)\n{\n\tstruct catc *catc = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (catc) {\n\t\tunregister_netdev(catc->netdev);\n\t\tusb_free_urb(catc->ctrl_urb);\n\t\tusb_free_urb(catc->tx_urb);\n\t\tusb_free_urb(catc->rx_urb);\n\t\tusb_free_urb(catc->irq_urb);\n\t\tfree_netdev(catc->netdev);\n\t}\n}\n\n/*\n * Module functions and tables.\n */\n\nstatic struct usb_device_id catc_id_table [] = {\n\t{ USB_DEVICE(0x0423, 0xa) },\t/* CATC Netmate, Belkin F5U011 */\n\t{ USB_DEVICE(0x0423, 0xc) },\t/* CATC Netmate II, Belkin F5U111 */\n\t{ USB_DEVICE(0x08d1, 0x1) },\t/* smartBridges smartNIC */\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, catc_id_table);\n\nstatic struct usb_driver catc_driver = {\n\t.name =\t\tdriver_name,\n\t.probe =\tcatc_probe,\n\t.disconnect =\tcatc_disconnect,\n\t.id_table =\tcatc_id_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(catc_driver);\n"], "filenames": ["drivers/net/usb/catc.c"], "buggy_code_start_loc": [779], "buggy_code_end_loc": [865], "fixing_code_start_loc": [779], "fixing_code_end_loc": [877], "type": "CWE-119", "message": "drivers/net/usb/catc.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8070", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.553", "lastModified": "2017-04-28T16:34:41.857", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/usb/catc.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/net/usb/catc.c en el kernel de Linux 4.9.x en versiones anteriores a 4.9.11 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "D249C5D2-9186-498C-9AF7-100162D856EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "783F5C9D-D179-4194-965E-F9A153EAE3B1"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98011", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478"}}