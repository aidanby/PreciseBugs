{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\t\"Ping\" sockets\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Based on ipv4/udp.c code.\n *\n * Authors:\tVasiliy Kulikov / Openwall (for Linux 2.6),\n *\t\tPavel Kankovsky (for Linux 2.4.32)\n *\n * Pavel gave all rights to bugs to Vasiliy,\n * none of the bugs are Pavel's now.\n *\n */\n\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/ping.h>\n#include <net/udp.h>\n#include <net/route.h>\n#include <net/inet_common.h>\n#include <net/checksum.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#endif\n\n\nstruct ping_table ping_table;\nstruct pingv6_ops pingv6_ops;\nEXPORT_SYMBOL_GPL(pingv6_ops);\n\nstatic u16 ping_port_rover;\n\nstatic inline int ping_hashfn(struct net *net, unsigned int num, unsigned int mask)\n{\n\tint res = (num + net_hash_mix(net)) & mask;\n\n\tpr_debug(\"hash(%d) = %d\\n\", num, res);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(ping_hash);\n\nstatic inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,\n\t\t\t\t\t     struct net *net, unsigned int num)\n{\n\treturn &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];\n}\n\nint ping_get_port(struct sock *sk, unsigned short ident)\n{\n\tstruct hlist_nulls_node *node;\n\tstruct hlist_nulls_head *hlist;\n\tstruct inet_sock *isk, *isk2;\n\tstruct sock *sk2 = NULL;\n\n\tisk = inet_sk(sk);\n\twrite_lock_bh(&ping_table.lock);\n\tif (ident == 0) {\n\t\tu32 i;\n\t\tu16 result = ping_port_rover + 1;\n\n\t\tfor (i = 0; i < (1L << 16); i++, result++) {\n\t\t\tif (!result)\n\t\t\t\tresult++; /* avoid zero */\n\t\t\thlist = ping_hashslot(&ping_table, sock_net(sk),\n\t\t\t\t\t    result);\n\t\t\tping_portaddr_for_each_entry(sk2, node, hlist) {\n\t\t\t\tisk2 = inet_sk(sk2);\n\n\t\t\t\tif (isk2->inet_num == result)\n\t\t\t\t\tgoto next_port;\n\t\t\t}\n\n\t\t\t/* found */\n\t\t\tping_port_rover = ident = result;\n\t\t\tbreak;\nnext_port:\n\t\t\t;\n\t\t}\n\t\tif (i >= (1L << 16))\n\t\t\tgoto fail;\n\t} else {\n\t\thlist = ping_hashslot(&ping_table, sock_net(sk), ident);\n\t\tping_portaddr_for_each_entry(sk2, node, hlist) {\n\t\t\tisk2 = inet_sk(sk2);\n\n\t\t\t/* BUG? Why is this reuse and not reuseaddr? ping.c\n\t\t\t * doesn't turn off SO_REUSEADDR, and it doesn't expect\n\t\t\t * that other ping processes can steal its packets.\n\t\t\t */\n\t\t\tif ((isk2->inet_num == ident) &&\n\t\t\t    (sk2 != sk) &&\n\t\t\t    (!sk2->sk_reuse || !sk->sk_reuse))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tpr_debug(\"found port/ident = %d\\n\", ident);\n\tisk->inet_num = ident;\n\tif (sk_unhashed(sk)) {\n\t\tpr_debug(\"was not hashed\\n\");\n\t\tsock_hold(sk);\n\t\thlist_nulls_add_head(&sk->sk_nulls_node, hlist);\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n\treturn 0;\n\nfail:\n\twrite_unlock_bh(&ping_table.lock);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ping_get_port);\n\nvoid ping_hash(struct sock *sk)\n{\n\tpr_debug(\"ping_hash(sk->port=%u)\\n\", inet_sk(sk)->inet_num);\n\tBUG(); /* \"Please do not press this button again.\" */\n}\n\nvoid ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(ping_unhash);\n\nstatic struct sock *ping_lookup(struct net *net, struct sk_buff *skb, u16 ident)\n{\n\tstruct hlist_nulls_head *hslot = ping_hashslot(&ping_table, net, ident);\n\tstruct sock *sk = NULL;\n\tstruct inet_sock *isk;\n\tstruct hlist_nulls_node *hnode;\n\tint dif = skb->dev->ifindex;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tpr_debug(\"try to find: num = %d, daddr = %pI4, dif = %d\\n\",\n\t\t\t (int)ident, &ip_hdr(skb)->daddr, dif);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tpr_debug(\"try to find: num = %d, daddr = %pI6c, dif = %d\\n\",\n\t\t\t (int)ident, &ipv6_hdr(skb)->daddr, dif);\n#endif\n\t}\n\n\tread_lock_bh(&ping_table.lock);\n\n\tping_portaddr_for_each_entry(sk, hnode, hslot) {\n\t\tisk = inet_sk(sk);\n\n\t\tpr_debug(\"iterate\\n\");\n\t\tif (isk->inet_num != ident)\n\t\t\tcontinue;\n\n\t\tif (skb->protocol == htons(ETH_P_IP) &&\n\t\t    sk->sk_family == AF_INET) {\n\t\t\tpr_debug(\"found: %p: num=%d, daddr=%pI4, dif=%d\\n\", sk,\n\t\t\t\t (int) isk->inet_num, &isk->inet_rcv_saddr,\n\t\t\t\t sk->sk_bound_dev_if);\n\n\t\t\tif (isk->inet_rcv_saddr &&\n\t\t\t    isk->inet_rcv_saddr != ip_hdr(skb)->daddr)\n\t\t\t\tcontinue;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (skb->protocol == htons(ETH_P_IPV6) &&\n\t\t\t   sk->sk_family == AF_INET6) {\n\n\t\t\tpr_debug(\"found: %p: num=%d, daddr=%pI6c, dif=%d\\n\", sk,\n\t\t\t\t (int) isk->inet_num,\n\t\t\t\t &sk->sk_v6_rcv_saddr,\n\t\t\t\t sk->sk_bound_dev_if);\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&\n\t\t\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr,\n\t\t\t\t\t     &ipv6_hdr(skb)->daddr))\n\t\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)\n\t\t\tcontinue;\n\n\t\tsock_hold(sk);\n\t\tgoto exit;\n\t}\n\n\tsk = NULL;\nexit:\n\tread_unlock_bh(&ping_table.lock);\n\n\treturn sk;\n}\n\nstatic void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.sysctl_ping_group_range;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.sysctl_local_ports.lock);\n\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.sysctl_local_ports.lock, seq));\n}\n\n\nint ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info = get_current_groups();\n\tint i, j, count = group_info->ngroups;\n\tkgid_t low, high;\n\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcount -= cp_count;\n\t}\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL_GPL(ping_init_sock);\n\nvoid ping_close(struct sock *sk, long timeout)\n{\n\tpr_debug(\"ping_close(sk=%p,sk->num=%u)\\n\",\n\t\t inet_sk(sk), inet_sk(sk)->inet_num);\n\tpr_debug(\"isk->refcnt = %d\\n\", sk->sk_refcnt.counter);\n\n\tsk_common_release(sk);\n}\nEXPORT_SYMBOL_GPL(ping_close);\n\n/* Checks the bind address and possibly modifies sk->sk_bound_dev_if. */\nstatic int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,\n\t\t\t\tstruct sockaddr *uaddr, int addr_len) {\n\tstruct net *net = sock_net(sk);\n\tif (sk->sk_family == AF_INET) {\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\n\t\tint chk_addr_ret;\n\n\t\tif (addr_len < sizeof(*addr))\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI4,port=%d)\\n\",\n\t\t\t sk, &addr->sin_addr.s_addr, ntohs(addr->sin_port));\n\n\t\tchk_addr_ret = inet_addr_type(net, addr->sin_addr.s_addr);\n\n\t\tif (addr->sin_addr.s_addr == htonl(INADDR_ANY))\n\t\t\tchk_addr_ret = RTN_LOCAL;\n\n\t\tif ((sysctl_ip_nonlocal_bind == 0 &&\n\t\t    isk->freebind == 0 && isk->transparent == 0 &&\n\t\t     chk_addr_ret != RTN_LOCAL) ||\n\t\t    chk_addr_ret == RTN_MULTICAST ||\n\t\t    chk_addr_ret == RTN_BROADCAST)\n\t\t\treturn -EADDRNOTAVAIL;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;\n\t\tint addr_type, scoped, has_addr;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_len < sizeof(*addr))\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI6c,port=%d)\\n\",\n\t\t\t sk, addr->sin6_addr.s6_addr, ntohs(addr->sin6_port));\n\n\t\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\t\tscoped = __ipv6_addr_needs_scope_id(addr_type);\n\t\tif ((addr_type != IPV6_ADDR_ANY &&\n\t\t     !(addr_type & IPV6_ADDR_UNICAST)) ||\n\t\t    (scoped && !addr->sin6_scope_id))\n\t\t\treturn -EINVAL;\n\n\t\trcu_read_lock();\n\t\tif (addr->sin6_scope_id) {\n\t\t\tdev = dev_get_by_index_rcu(net, addr->sin6_scope_id);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\thas_addr = pingv6_ops.ipv6_chk_addr(net, &addr->sin6_addr, dev,\n\t\t\t\t\t\t    scoped);\n\t\trcu_read_unlock();\n\n\t\tif (!(isk->freebind || isk->transparent || has_addr ||\n\t\t      addr_type == IPV6_ADDR_ANY))\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tif (scoped)\n\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n#endif\n\t} else {\n\t\treturn -EAFNOSUPPORT;\n\t}\n\treturn 0;\n}\n\nstatic void ping_set_saddr(struct sock *sk, struct sockaddr *saddr)\n{\n\tif (saddr->sa_family == AF_INET) {\n\t\tstruct inet_sock *isk = inet_sk(sk);\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) saddr;\n\t\tisk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (saddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) saddr;\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tsk->sk_v6_rcv_saddr = np->saddr = addr->sin6_addr;\n#endif\n\t}\n}\n\nstatic void ping_clear_saddr(struct sock *sk, int dif)\n{\n\tsk->sk_bound_dev_if = dif;\n\tif (sk->sk_family == AF_INET) {\n\t\tstruct inet_sock *isk = inet_sk(sk);\n\t\tisk->inet_rcv_saddr = isk->inet_saddr = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tmemset(&sk->sk_v6_rcv_saddr, 0, sizeof(sk->sk_v6_rcv_saddr));\n\t\tmemset(&np->saddr, 0, sizeof(np->saddr));\n#endif\n\t}\n}\n/*\n * We need our own bind because there are no privileged id's == local ports.\n * Moreover, we don't allow binding to multi- and broadcast addresses.\n */\n\nint ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"after bind(): num = %d, dif = %d\\n\",\n\t\t (int)isk->inet_num,\n\t\t (int)sk->sk_bound_dev_if);\n\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ping_bind);\n\n/*\n * Is this a supported type of ICMP message?\n */\n\nstatic inline int ping_supported(int family, int type, int code)\n{\n\treturn (family == AF_INET && type == ICMP_ECHO && code == 0) ||\n\t       (family == AF_INET6 && type == ICMPV6_ECHO_REQUEST && code == 0);\n}\n\n/*\n * This routine is called by the ICMP module when it gets some\n * sort of error condition.\n */\n\nvoid ping_err(struct sk_buff *skb, int offset, u32 info)\n{\n\tint family;\n\tstruct icmphdr *icmph;\n\tstruct inet_sock *inet_sock;\n\tint type;\n\tint code;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tint harderr;\n\tint err;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tfamily = AF_INET;\n\t\ttype = icmp_hdr(skb)->type;\n\t\tcode = icmp_hdr(skb)->code;\n\t\ticmph = (struct icmphdr *)(skb->data + offset);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tfamily = AF_INET6;\n\t\ttype = icmp6_hdr(skb)->icmp6_type;\n\t\tcode = icmp6_hdr(skb)->icmp6_code;\n\t\ticmph = (struct icmphdr *) (skb->data + offset);\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* We assume the packet has already been checked by icmp_unreach */\n\n\tif (!ping_supported(family, icmph->type, icmph->code))\n\t\treturn;\n\n\tpr_debug(\"ping_err(proto=0x%x,type=%d,code=%d,id=%04x,seq=%04x)\\n\",\n\t\t skb->protocol, type, code, ntohs(icmph->un.echo.id),\n\t\t ntohs(icmph->un.echo.sequence));\n\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk == NULL) {\n\t\tpr_debug(\"no socket, dropping\\n\");\n\t\treturn;\t/* No socket for error */\n\t}\n\tpr_debug(\"err on socket %p\\n\", sk);\n\n\terr = 0;\n\tharderr = 0;\n\tinet_sock = inet_sk(sk);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tswitch (type) {\n\t\tdefault:\n\t\tcase ICMP_TIME_EXCEEDED:\n\t\t\terr = EHOSTUNREACH;\n\t\t\tbreak;\n\t\tcase ICMP_SOURCE_QUENCH:\n\t\t\t/* This is not a real error but ping wants to see it.\n\t\t\t * Report it with some fake errno.\n\t\t\t */\n\t\t\terr = EREMOTEIO;\n\t\t\tbreak;\n\t\tcase ICMP_PARAMETERPROB:\n\t\t\terr = EPROTO;\n\t\t\tharderr = 1;\n\t\t\tbreak;\n\t\tcase ICMP_DEST_UNREACH:\n\t\t\tif (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */\n\t\t\t\tipv4_sk_update_pmtu(skb, sk, info);\n\t\t\t\tif (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {\n\t\t\t\t\terr = EMSGSIZE;\n\t\t\t\t\tharderr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = EHOSTUNREACH;\n\t\t\tif (code <= NR_ICMP_UNREACH) {\n\t\t\t\tharderr = icmp_err_convert[code].fatal;\n\t\t\t\terr = icmp_err_convert[code].errno;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ICMP_REDIRECT:\n\t\t\t/* See ICMP_SOURCE_QUENCH */\n\t\t\tipv4_sk_redirect(skb, sk);\n\t\t\terr = EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tharderr = pingv6_ops.icmpv6_err_convert(type, code, &err);\n#endif\n\t}\n\n\t/*\n\t *      RFC1122: OK.  Passes ICMP errors back to application, as per\n\t *\t4.1.3.3.\n\t */\n\tif ((family == AF_INET && !inet_sock->recverr) ||\n\t    (family == AF_INET6 && !inet6_sk(sk)->recverr)) {\n\t\tif (!harderr || sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t} else {\n\t\tif (family == AF_INET) {\n\t\t\tip_icmp_error(sk, skb, err, 0 /* no remote port */,\n\t\t\t\t      info, (u8 *)icmph);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\tpingv6_ops.ipv6_icmp_error(sk, skb, err, 0,\n\t\t\t\t\t\t   info, (u8 *)icmph);\n#endif\n\t\t}\n\t}\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\nEXPORT_SYMBOL_GPL(ping_err);\n\n/*\n *\tCopy and checksum an ICMP Echo packet from user space into a buffer\n *\tstarting from the payload.\n */\n\nint ping_getfrag(void *from, char *to,\n\t\t int offset, int fraglen, int odd, struct sk_buff *skb)\n{\n\tstruct pingfakehdr *pfh = (struct pingfakehdr *)from;\n\n\tif (offset == 0) {\n\t\tif (fraglen < sizeof(struct icmphdr))\n\t\t\tBUG();\n\t\tif (csum_partial_copy_fromiovecend(to + sizeof(struct icmphdr),\n\t\t\t    pfh->iov, 0, fraglen - sizeof(struct icmphdr),\n\t\t\t    &pfh->wcheck))\n\t\t\treturn -EFAULT;\n\t} else if (offset < sizeof(struct icmphdr)) {\n\t\t\tBUG();\n\t} else {\n\t\tif (csum_partial_copy_fromiovecend\n\t\t\t\t(to, pfh->iov, offset - sizeof(struct icmphdr),\n\t\t\t\t fraglen, &pfh->wcheck))\n\t\t\treturn -EFAULT;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t/* For IPv6, checksum each skb as we go along, as expected by\n\t * icmpv6_push_pending_frames. For IPv4, accumulate the checksum in\n\t * wcheck, it will be finalized in ping_v4_push_pending_frames.\n\t */\n\tif (pfh->family == AF_INET6) {\n\t\tskb->csum = pfh->wcheck;\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tpfh->wcheck = 0;\n\t}\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_getfrag);\n\nstatic int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,\n\t\t\t\t       struct flowi4 *fl4)\n{\n\tstruct sk_buff *skb = skb_peek(&sk->sk_write_queue);\n\n\tpfh->wcheck = csum_partial((char *)&pfh->icmph,\n\t\tsizeof(struct icmphdr), pfh->wcheck);\n\tpfh->icmph.checksum = csum_fold(pfh->wcheck);\n\tmemcpy(icmp_hdr(skb), &pfh->icmph, sizeof(struct icmphdr));\n\tskb->ip_summed = CHECKSUM_NONE;\n\treturn ip_push_pending_frames(sk, fl4);\n}\n\nint ping_common_sendmsg(int family, struct msghdr *msg, size_t len,\n\t\t\tvoid *user_icmph, size_t icmph_len) {\n\tu8 type, code;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tFetch the ICMP header provided by the userland.\n\t *\tiovec is modified! The ICMP header is consumed.\n\t */\n\tif (memcpy_fromiovec(user_icmph, msg->msg_iov, icmph_len))\n\t\treturn -EFAULT;\n\n\tif (family == AF_INET) {\n\t\ttype = ((struct icmphdr *) user_icmph)->type;\n\t\tcode = ((struct icmphdr *) user_icmph)->code;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\ttype = ((struct icmp6hdr *) user_icmph)->icmp6_type;\n\t\tcode = ((struct icmp6hdr *) user_icmph)->icmp6_code;\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (!ping_supported(family, type, code))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_common_sendmsg);\n\nint ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t    size_t len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct icmphdr user_icmph;\n\tstruct pingfakehdr pfh;\n\tstruct rtable *rt = NULL;\n\tstruct ip_options_data opt_copy;\n\tint free = 0;\n\t__be32 saddr, daddr, faddr;\n\tu8  tos;\n\tint err;\n\n\tpr_debug(\"ping_v4_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);\n\n\terr = ping_common_sendmsg(AF_INET, msg, len, &user_icmph,\n\t\t\t\t  sizeof(user_icmph));\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET)\n\t\t\treturn -EINVAL;\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* no remote port */\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\t/* no remote port */\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.oif = sk->sk_bound_dev_if;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\n\tsock_tx_timestamp(sk, &ipc.tx_flags);\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->opt.srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->opt.faddr;\n\t}\n\ttos = get_rttos(&ipc, inet);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) ||\n\t    (ipc.opt && ipc.opt->opt.is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t}\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk), faddr, saddr, 0, 0);\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\t\tgoto out;\n\t}\n\n\terr = -EACCES;\n\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto out;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (!ipc.addr)\n\t\tipc.addr = fl4.daddr;\n\n\tlock_sock(sk);\n\n\tpfh.icmph.type = user_icmph.type; /* already checked */\n\tpfh.icmph.code = user_icmph.code; /* ditto */\n\tpfh.icmph.checksum = 0;\n\tpfh.icmph.un.echo.id = inet->inet_sport;\n\tpfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;\n\tpfh.iov = msg->msg_iov;\n\tpfh.wcheck = 0;\n\tpfh.family = AF_INET;\n\n\terr = ip_append_data(sk, &fl4, ping_getfrag, &pfh, len,\n\t\t\t0, &ipc, &rt, msg->msg_flags);\n\tif (err)\n\t\tip_flush_pending_frames(sk);\n\telse\n\t\terr = ping_v4_push_pending_frames(sk, &pfh, &fl4);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\ticmp_out_count(sock_net(sk), user_icmph.type);\n\t\treturn len;\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nint ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tint family = sk->sk_family;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", isk, isk->inet_num);\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\tif (family == AF_INET) {\n\t\t\treturn ip_recv_error(sk, msg, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len);\n#endif\n\t\t}\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* Don't bother checking the checksum */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ip6->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tif (np->sndflow)\n\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ping_recvmsg);\n\nint ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tpr_debug(\"ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\\n\",\n\t\t inet_sk(sk), inet_sk(sk)->inet_num, skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\tpr_debug(\"ping_queue_rcv_skb -> failed\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_queue_rcv_skb);\n\n\n/*\n *\tAll we need to do is get the socket.\n */\n\nvoid ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\n\t/* We assume the packet has already been checked by icmp_rcv */\n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t/* Push ICMP header back */\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk != NULL) {\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tping_queue_rcv_skb(sk, skb_get(skb));\n\t\tsock_put(sk);\n\t\treturn;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\n\t/* We're called from icmp_rcv(). kfree_skb() is done there. */\n}\nEXPORT_SYMBOL_GPL(ping_rcv);\n\nstruct proto ping_prot = {\n\t.name =\t\t\"PING\",\n\t.owner =\tTHIS_MODULE,\n\t.init =\t\tping_init_sock,\n\t.close =\tping_close,\n\t.connect =\tip4_datagram_connect,\n\t.disconnect =\tudp_disconnect,\n\t.setsockopt =\tip_setsockopt,\n\t.getsockopt =\tip_getsockopt,\n\t.sendmsg =\tping_v4_sendmsg,\n\t.recvmsg =\tping_recvmsg,\n\t.bind =\t\tping_bind,\n\t.backlog_rcv =\tping_queue_rcv_skb,\n\t.release_cb =\tip4_datagram_release_cb,\n\t.hash =\t\tping_hash,\n\t.unhash =\tping_unhash,\n\t.get_port =\tping_get_port,\n\t.obj_size =\tsizeof(struct inet_sock),\n};\nEXPORT_SYMBOL(ping_prot);\n\n#ifdef CONFIG_PROC_FS\n\nstatic struct sock *ping_get_first(struct seq_file *seq, int start)\n{\n\tstruct sock *sk;\n\tstruct ping_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\tfor (state->bucket = start; state->bucket < PING_HTABLE_SIZE;\n\t     ++state->bucket) {\n\t\tstruct hlist_nulls_node *node;\n\t\tstruct hlist_nulls_head *hslot;\n\n\t\thslot = &ping_table.hash[state->bucket];\n\n\t\tif (hlist_nulls_empty(hslot))\n\t\t\tcontinue;\n\n\t\tsk_nulls_for_each(sk, node, hslot) {\n\t\t\tif (net_eq(sock_net(sk), net) &&\n\t\t\t    sk->sk_family == state->family)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct ping_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\tdo {\n\t\tsk = sk_nulls_next(sk);\n\t} while (sk && (!net_eq(sock_net(sk), net)));\n\n\tif (!sk)\n\t\treturn ping_get_first(seq, state->bucket + 1);\n\treturn sk;\n}\n\nstatic struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = ping_get_first(seq, 0);\n\n\tif (sk)\n\t\twhile (pos && (sk = ping_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}\n\nvoid *ping_seq_start(struct seq_file *seq, loff_t *pos, sa_family_t family)\n{\n\tstruct ping_iter_state *state = seq->private;\n\tstate->bucket = 0;\n\tstate->family = family;\n\n\tread_lock_bh(&ping_table.lock);\n\n\treturn *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL_GPL(ping_seq_start);\n\nstatic void *ping_v4_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn ping_seq_start(seq, pos, AF_INET);\n}\n\nvoid *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = ping_get_idx(seq, 0);\n\telse\n\t\tsk = ping_get_next(seq, v);\n\n\t++*pos;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(ping_seq_next);\n\nvoid ping_seq_stop(struct seq_file *seq, void *v)\n{\n\tread_unlock_bh(&ping_table.lock);\n}\nEXPORT_SYMBOL_GPL(ping_seq_stop);\n\nstatic void ping_v4_format_sock(struct sock *sp, struct seq_file *f,\n\t\tint bucket, int *len)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src = inet->inet_rcv_saddr;\n\t__u16 destp = ntohs(inet->inet_dport);\n\t__u16 srcp = ntohs(inet->inet_sport);\n\n\tseq_printf(f, \"%5d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d%n\",\n\t\tbucket, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\tatomic_read(&sp->sk_refcnt), sp,\n\t\tatomic_read(&sp->sk_drops), len);\n}\n\nstatic int ping_v4_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"%-127s\\n\",\n\t\t\t   \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t   \"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t   \"inode ref pointer drops\");\n\telse {\n\t\tstruct ping_iter_state *state = seq->private;\n\t\tint len;\n\n\t\tping_v4_format_sock(v, seq, state->bucket, &len);\n\t\tseq_printf(seq, \"%*s\\n\", 127 - len, \"\");\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ping_v4_seq_ops = {\n\t.show\t\t= ping_v4_seq_show,\n\t.start\t\t= ping_v4_seq_start,\n\t.next\t\t= ping_seq_next,\n\t.stop\t\t= ping_seq_stop,\n};\n\nstatic int ping_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct ping_seq_afinfo *afinfo = PDE_DATA(inode);\n\treturn seq_open_net(inode, file, &afinfo->seq_ops,\n\t\t\t   sizeof(struct ping_iter_state));\n}\n\nconst struct file_operations ping_seq_fops = {\n\t.open\t\t= ping_seq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_net,\n};\nEXPORT_SYMBOL_GPL(ping_seq_fops);\n\nstatic struct ping_seq_afinfo ping_v4_seq_afinfo = {\n\t.name\t\t= \"icmp\",\n\t.family\t\t= AF_INET,\n\t.seq_fops\t= &ping_seq_fops,\n\t.seq_ops\t= {\n\t\t.start\t\t= ping_v4_seq_start,\n\t\t.show\t\t= ping_v4_seq_show,\n\t\t.next\t\t= ping_seq_next,\n\t\t.stop\t\t= ping_seq_stop,\n\t},\n};\n\nint ping_proc_register(struct net *net, struct ping_seq_afinfo *afinfo)\n{\n\tstruct proc_dir_entry *p;\n\tp = proc_create_data(afinfo->name, S_IRUGO, net->proc_net,\n\t\t\t     afinfo->seq_fops, afinfo);\n\tif (!p)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_proc_register);\n\nvoid ping_proc_unregister(struct net *net, struct ping_seq_afinfo *afinfo)\n{\n\tremove_proc_entry(afinfo->name, net->proc_net);\n}\nEXPORT_SYMBOL_GPL(ping_proc_unregister);\n\nstatic int __net_init ping_v4_proc_init_net(struct net *net)\n{\n\treturn ping_proc_register(net, &ping_v4_seq_afinfo);\n}\n\nstatic void __net_exit ping_v4_proc_exit_net(struct net *net)\n{\n\tping_proc_unregister(net, &ping_v4_seq_afinfo);\n}\n\nstatic struct pernet_operations ping_v4_net_ops = {\n\t.init = ping_v4_proc_init_net,\n\t.exit = ping_v4_proc_exit_net,\n};\n\nint __init ping_proc_init(void)\n{\n\treturn register_pernet_subsys(&ping_v4_net_ops);\n}\n\nvoid ping_proc_exit(void)\n{\n\tunregister_pernet_subsys(&ping_v4_net_ops);\n}\n\n#endif\n\nvoid __init ping_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PING_HTABLE_SIZE; i++)\n\t\tINIT_HLIST_NULLS_HEAD(&ping_table.hash[i], i);\n\trwlock_init(&ping_table.lock);\n}\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\t\"Ping\" sockets\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n * Based on ipv4/udp.c code.\n *\n * Authors:\tVasiliy Kulikov / Openwall (for Linux 2.6),\n *\t\tPavel Kankovsky (for Linux 2.4.32)\n *\n * Pavel gave all rights to bugs to Vasiliy,\n * none of the bugs are Pavel's now.\n *\n */\n\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/ping.h>\n#include <net/udp.h>\n#include <net/route.h>\n#include <net/inet_common.h>\n#include <net/checksum.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#endif\n\n\nstruct ping_table ping_table;\nstruct pingv6_ops pingv6_ops;\nEXPORT_SYMBOL_GPL(pingv6_ops);\n\nstatic u16 ping_port_rover;\n\nstatic inline int ping_hashfn(struct net *net, unsigned int num, unsigned int mask)\n{\n\tint res = (num + net_hash_mix(net)) & mask;\n\n\tpr_debug(\"hash(%d) = %d\\n\", num, res);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(ping_hash);\n\nstatic inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,\n\t\t\t\t\t     struct net *net, unsigned int num)\n{\n\treturn &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];\n}\n\nint ping_get_port(struct sock *sk, unsigned short ident)\n{\n\tstruct hlist_nulls_node *node;\n\tstruct hlist_nulls_head *hlist;\n\tstruct inet_sock *isk, *isk2;\n\tstruct sock *sk2 = NULL;\n\n\tisk = inet_sk(sk);\n\twrite_lock_bh(&ping_table.lock);\n\tif (ident == 0) {\n\t\tu32 i;\n\t\tu16 result = ping_port_rover + 1;\n\n\t\tfor (i = 0; i < (1L << 16); i++, result++) {\n\t\t\tif (!result)\n\t\t\t\tresult++; /* avoid zero */\n\t\t\thlist = ping_hashslot(&ping_table, sock_net(sk),\n\t\t\t\t\t    result);\n\t\t\tping_portaddr_for_each_entry(sk2, node, hlist) {\n\t\t\t\tisk2 = inet_sk(sk2);\n\n\t\t\t\tif (isk2->inet_num == result)\n\t\t\t\t\tgoto next_port;\n\t\t\t}\n\n\t\t\t/* found */\n\t\t\tping_port_rover = ident = result;\n\t\t\tbreak;\nnext_port:\n\t\t\t;\n\t\t}\n\t\tif (i >= (1L << 16))\n\t\t\tgoto fail;\n\t} else {\n\t\thlist = ping_hashslot(&ping_table, sock_net(sk), ident);\n\t\tping_portaddr_for_each_entry(sk2, node, hlist) {\n\t\t\tisk2 = inet_sk(sk2);\n\n\t\t\t/* BUG? Why is this reuse and not reuseaddr? ping.c\n\t\t\t * doesn't turn off SO_REUSEADDR, and it doesn't expect\n\t\t\t * that other ping processes can steal its packets.\n\t\t\t */\n\t\t\tif ((isk2->inet_num == ident) &&\n\t\t\t    (sk2 != sk) &&\n\t\t\t    (!sk2->sk_reuse || !sk->sk_reuse))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tpr_debug(\"found port/ident = %d\\n\", ident);\n\tisk->inet_num = ident;\n\tif (sk_unhashed(sk)) {\n\t\tpr_debug(\"was not hashed\\n\");\n\t\tsock_hold(sk);\n\t\thlist_nulls_add_head(&sk->sk_nulls_node, hlist);\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n\treturn 0;\n\nfail:\n\twrite_unlock_bh(&ping_table.lock);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ping_get_port);\n\nvoid ping_hash(struct sock *sk)\n{\n\tpr_debug(\"ping_hash(sk->port=%u)\\n\", inet_sk(sk)->inet_num);\n\tBUG(); /* \"Please do not press this button again.\" */\n}\n\nvoid ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(ping_unhash);\n\nstatic struct sock *ping_lookup(struct net *net, struct sk_buff *skb, u16 ident)\n{\n\tstruct hlist_nulls_head *hslot = ping_hashslot(&ping_table, net, ident);\n\tstruct sock *sk = NULL;\n\tstruct inet_sock *isk;\n\tstruct hlist_nulls_node *hnode;\n\tint dif = skb->dev->ifindex;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tpr_debug(\"try to find: num = %d, daddr = %pI4, dif = %d\\n\",\n\t\t\t (int)ident, &ip_hdr(skb)->daddr, dif);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tpr_debug(\"try to find: num = %d, daddr = %pI6c, dif = %d\\n\",\n\t\t\t (int)ident, &ipv6_hdr(skb)->daddr, dif);\n#endif\n\t}\n\n\tread_lock_bh(&ping_table.lock);\n\n\tping_portaddr_for_each_entry(sk, hnode, hslot) {\n\t\tisk = inet_sk(sk);\n\n\t\tpr_debug(\"iterate\\n\");\n\t\tif (isk->inet_num != ident)\n\t\t\tcontinue;\n\n\t\tif (skb->protocol == htons(ETH_P_IP) &&\n\t\t    sk->sk_family == AF_INET) {\n\t\t\tpr_debug(\"found: %p: num=%d, daddr=%pI4, dif=%d\\n\", sk,\n\t\t\t\t (int) isk->inet_num, &isk->inet_rcv_saddr,\n\t\t\t\t sk->sk_bound_dev_if);\n\n\t\t\tif (isk->inet_rcv_saddr &&\n\t\t\t    isk->inet_rcv_saddr != ip_hdr(skb)->daddr)\n\t\t\t\tcontinue;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (skb->protocol == htons(ETH_P_IPV6) &&\n\t\t\t   sk->sk_family == AF_INET6) {\n\n\t\t\tpr_debug(\"found: %p: num=%d, daddr=%pI6c, dif=%d\\n\", sk,\n\t\t\t\t (int) isk->inet_num,\n\t\t\t\t &sk->sk_v6_rcv_saddr,\n\t\t\t\t sk->sk_bound_dev_if);\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&\n\t\t\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr,\n\t\t\t\t\t     &ipv6_hdr(skb)->daddr))\n\t\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)\n\t\t\tcontinue;\n\n\t\tsock_hold(sk);\n\t\tgoto exit;\n\t}\n\n\tsk = NULL;\nexit:\n\tread_unlock_bh(&ping_table.lock);\n\n\treturn sk;\n}\n\nstatic void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.sysctl_ping_group_range;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.sysctl_local_ports.lock);\n\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.sysctl_local_ports.lock, seq));\n}\n\n\nint ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info = get_current_groups();\n\tint i, j, count = group_info->ngroups;\n\tkgid_t low, high;\n\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcount -= cp_count;\n\t}\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL_GPL(ping_init_sock);\n\nvoid ping_close(struct sock *sk, long timeout)\n{\n\tpr_debug(\"ping_close(sk=%p,sk->num=%u)\\n\",\n\t\t inet_sk(sk), inet_sk(sk)->inet_num);\n\tpr_debug(\"isk->refcnt = %d\\n\", sk->sk_refcnt.counter);\n\n\tsk_common_release(sk);\n}\nEXPORT_SYMBOL_GPL(ping_close);\n\n/* Checks the bind address and possibly modifies sk->sk_bound_dev_if. */\nstatic int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,\n\t\t\t\tstruct sockaddr *uaddr, int addr_len) {\n\tstruct net *net = sock_net(sk);\n\tif (sk->sk_family == AF_INET) {\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\n\t\tint chk_addr_ret;\n\n\t\tif (addr_len < sizeof(*addr))\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI4,port=%d)\\n\",\n\t\t\t sk, &addr->sin_addr.s_addr, ntohs(addr->sin_port));\n\n\t\tchk_addr_ret = inet_addr_type(net, addr->sin_addr.s_addr);\n\n\t\tif (addr->sin_addr.s_addr == htonl(INADDR_ANY))\n\t\t\tchk_addr_ret = RTN_LOCAL;\n\n\t\tif ((sysctl_ip_nonlocal_bind == 0 &&\n\t\t    isk->freebind == 0 && isk->transparent == 0 &&\n\t\t     chk_addr_ret != RTN_LOCAL) ||\n\t\t    chk_addr_ret == RTN_MULTICAST ||\n\t\t    chk_addr_ret == RTN_BROADCAST)\n\t\t\treturn -EADDRNOTAVAIL;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;\n\t\tint addr_type, scoped, has_addr;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_len < sizeof(*addr))\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI6c,port=%d)\\n\",\n\t\t\t sk, addr->sin6_addr.s6_addr, ntohs(addr->sin6_port));\n\n\t\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\t\tscoped = __ipv6_addr_needs_scope_id(addr_type);\n\t\tif ((addr_type != IPV6_ADDR_ANY &&\n\t\t     !(addr_type & IPV6_ADDR_UNICAST)) ||\n\t\t    (scoped && !addr->sin6_scope_id))\n\t\t\treturn -EINVAL;\n\n\t\trcu_read_lock();\n\t\tif (addr->sin6_scope_id) {\n\t\t\tdev = dev_get_by_index_rcu(net, addr->sin6_scope_id);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\thas_addr = pingv6_ops.ipv6_chk_addr(net, &addr->sin6_addr, dev,\n\t\t\t\t\t\t    scoped);\n\t\trcu_read_unlock();\n\n\t\tif (!(isk->freebind || isk->transparent || has_addr ||\n\t\t      addr_type == IPV6_ADDR_ANY))\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tif (scoped)\n\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n#endif\n\t} else {\n\t\treturn -EAFNOSUPPORT;\n\t}\n\treturn 0;\n}\n\nstatic void ping_set_saddr(struct sock *sk, struct sockaddr *saddr)\n{\n\tif (saddr->sa_family == AF_INET) {\n\t\tstruct inet_sock *isk = inet_sk(sk);\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) saddr;\n\t\tisk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (saddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) saddr;\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tsk->sk_v6_rcv_saddr = np->saddr = addr->sin6_addr;\n#endif\n\t}\n}\n\nstatic void ping_clear_saddr(struct sock *sk, int dif)\n{\n\tsk->sk_bound_dev_if = dif;\n\tif (sk->sk_family == AF_INET) {\n\t\tstruct inet_sock *isk = inet_sk(sk);\n\t\tisk->inet_rcv_saddr = isk->inet_saddr = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tmemset(&sk->sk_v6_rcv_saddr, 0, sizeof(sk->sk_v6_rcv_saddr));\n\t\tmemset(&np->saddr, 0, sizeof(np->saddr));\n#endif\n\t}\n}\n/*\n * We need our own bind because there are no privileged id's == local ports.\n * Moreover, we don't allow binding to multi- and broadcast addresses.\n */\n\nint ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"after bind(): num = %d, dif = %d\\n\",\n\t\t (int)isk->inet_num,\n\t\t (int)sk->sk_bound_dev_if);\n\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ping_bind);\n\n/*\n * Is this a supported type of ICMP message?\n */\n\nstatic inline int ping_supported(int family, int type, int code)\n{\n\treturn (family == AF_INET && type == ICMP_ECHO && code == 0) ||\n\t       (family == AF_INET6 && type == ICMPV6_ECHO_REQUEST && code == 0);\n}\n\n/*\n * This routine is called by the ICMP module when it gets some\n * sort of error condition.\n */\n\nvoid ping_err(struct sk_buff *skb, int offset, u32 info)\n{\n\tint family;\n\tstruct icmphdr *icmph;\n\tstruct inet_sock *inet_sock;\n\tint type;\n\tint code;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tint harderr;\n\tint err;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tfamily = AF_INET;\n\t\ttype = icmp_hdr(skb)->type;\n\t\tcode = icmp_hdr(skb)->code;\n\t\ticmph = (struct icmphdr *)(skb->data + offset);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tfamily = AF_INET6;\n\t\ttype = icmp6_hdr(skb)->icmp6_type;\n\t\tcode = icmp6_hdr(skb)->icmp6_code;\n\t\ticmph = (struct icmphdr *) (skb->data + offset);\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* We assume the packet has already been checked by icmp_unreach */\n\n\tif (!ping_supported(family, icmph->type, icmph->code))\n\t\treturn;\n\n\tpr_debug(\"ping_err(proto=0x%x,type=%d,code=%d,id=%04x,seq=%04x)\\n\",\n\t\t skb->protocol, type, code, ntohs(icmph->un.echo.id),\n\t\t ntohs(icmph->un.echo.sequence));\n\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk == NULL) {\n\t\tpr_debug(\"no socket, dropping\\n\");\n\t\treturn;\t/* No socket for error */\n\t}\n\tpr_debug(\"err on socket %p\\n\", sk);\n\n\terr = 0;\n\tharderr = 0;\n\tinet_sock = inet_sk(sk);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tswitch (type) {\n\t\tdefault:\n\t\tcase ICMP_TIME_EXCEEDED:\n\t\t\terr = EHOSTUNREACH;\n\t\t\tbreak;\n\t\tcase ICMP_SOURCE_QUENCH:\n\t\t\t/* This is not a real error but ping wants to see it.\n\t\t\t * Report it with some fake errno.\n\t\t\t */\n\t\t\terr = EREMOTEIO;\n\t\t\tbreak;\n\t\tcase ICMP_PARAMETERPROB:\n\t\t\terr = EPROTO;\n\t\t\tharderr = 1;\n\t\t\tbreak;\n\t\tcase ICMP_DEST_UNREACH:\n\t\t\tif (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */\n\t\t\t\tipv4_sk_update_pmtu(skb, sk, info);\n\t\t\t\tif (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {\n\t\t\t\t\terr = EMSGSIZE;\n\t\t\t\t\tharderr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = EHOSTUNREACH;\n\t\t\tif (code <= NR_ICMP_UNREACH) {\n\t\t\t\tharderr = icmp_err_convert[code].fatal;\n\t\t\t\terr = icmp_err_convert[code].errno;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ICMP_REDIRECT:\n\t\t\t/* See ICMP_SOURCE_QUENCH */\n\t\t\tipv4_sk_redirect(skb, sk);\n\t\t\terr = EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tharderr = pingv6_ops.icmpv6_err_convert(type, code, &err);\n#endif\n\t}\n\n\t/*\n\t *      RFC1122: OK.  Passes ICMP errors back to application, as per\n\t *\t4.1.3.3.\n\t */\n\tif ((family == AF_INET && !inet_sock->recverr) ||\n\t    (family == AF_INET6 && !inet6_sk(sk)->recverr)) {\n\t\tif (!harderr || sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t} else {\n\t\tif (family == AF_INET) {\n\t\t\tip_icmp_error(sk, skb, err, 0 /* no remote port */,\n\t\t\t\t      info, (u8 *)icmph);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\tpingv6_ops.ipv6_icmp_error(sk, skb, err, 0,\n\t\t\t\t\t\t   info, (u8 *)icmph);\n#endif\n\t\t}\n\t}\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\nEXPORT_SYMBOL_GPL(ping_err);\n\n/*\n *\tCopy and checksum an ICMP Echo packet from user space into a buffer\n *\tstarting from the payload.\n */\n\nint ping_getfrag(void *from, char *to,\n\t\t int offset, int fraglen, int odd, struct sk_buff *skb)\n{\n\tstruct pingfakehdr *pfh = (struct pingfakehdr *)from;\n\n\tif (offset == 0) {\n\t\tif (fraglen < sizeof(struct icmphdr))\n\t\t\tBUG();\n\t\tif (csum_partial_copy_fromiovecend(to + sizeof(struct icmphdr),\n\t\t\t    pfh->iov, 0, fraglen - sizeof(struct icmphdr),\n\t\t\t    &pfh->wcheck))\n\t\t\treturn -EFAULT;\n\t} else if (offset < sizeof(struct icmphdr)) {\n\t\t\tBUG();\n\t} else {\n\t\tif (csum_partial_copy_fromiovecend\n\t\t\t\t(to, pfh->iov, offset - sizeof(struct icmphdr),\n\t\t\t\t fraglen, &pfh->wcheck))\n\t\t\treturn -EFAULT;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t/* For IPv6, checksum each skb as we go along, as expected by\n\t * icmpv6_push_pending_frames. For IPv4, accumulate the checksum in\n\t * wcheck, it will be finalized in ping_v4_push_pending_frames.\n\t */\n\tif (pfh->family == AF_INET6) {\n\t\tskb->csum = pfh->wcheck;\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tpfh->wcheck = 0;\n\t}\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_getfrag);\n\nstatic int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,\n\t\t\t\t       struct flowi4 *fl4)\n{\n\tstruct sk_buff *skb = skb_peek(&sk->sk_write_queue);\n\n\tpfh->wcheck = csum_partial((char *)&pfh->icmph,\n\t\tsizeof(struct icmphdr), pfh->wcheck);\n\tpfh->icmph.checksum = csum_fold(pfh->wcheck);\n\tmemcpy(icmp_hdr(skb), &pfh->icmph, sizeof(struct icmphdr));\n\tskb->ip_summed = CHECKSUM_NONE;\n\treturn ip_push_pending_frames(sk, fl4);\n}\n\nint ping_common_sendmsg(int family, struct msghdr *msg, size_t len,\n\t\t\tvoid *user_icmph, size_t icmph_len) {\n\tu8 type, code;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tFetch the ICMP header provided by the userland.\n\t *\tiovec is modified! The ICMP header is consumed.\n\t */\n\tif (memcpy_fromiovec(user_icmph, msg->msg_iov, icmph_len))\n\t\treturn -EFAULT;\n\n\tif (family == AF_INET) {\n\t\ttype = ((struct icmphdr *) user_icmph)->type;\n\t\tcode = ((struct icmphdr *) user_icmph)->code;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\ttype = ((struct icmp6hdr *) user_icmph)->icmp6_type;\n\t\tcode = ((struct icmp6hdr *) user_icmph)->icmp6_code;\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (!ping_supported(family, type, code))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_common_sendmsg);\n\nint ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t    size_t len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct icmphdr user_icmph;\n\tstruct pingfakehdr pfh;\n\tstruct rtable *rt = NULL;\n\tstruct ip_options_data opt_copy;\n\tint free = 0;\n\t__be32 saddr, daddr, faddr;\n\tu8  tos;\n\tint err;\n\n\tpr_debug(\"ping_v4_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);\n\n\terr = ping_common_sendmsg(AF_INET, msg, len, &user_icmph,\n\t\t\t\t  sizeof(user_icmph));\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET)\n\t\t\treturn -EINVAL;\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* no remote port */\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\t/* no remote port */\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.oif = sk->sk_bound_dev_if;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\n\tsock_tx_timestamp(sk, &ipc.tx_flags);\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->opt.srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->opt.faddr;\n\t}\n\ttos = get_rttos(&ipc, inet);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) ||\n\t    (ipc.opt && ipc.opt->opt.is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t}\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk), faddr, saddr, 0, 0);\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\t\tgoto out;\n\t}\n\n\terr = -EACCES;\n\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto out;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (!ipc.addr)\n\t\tipc.addr = fl4.daddr;\n\n\tlock_sock(sk);\n\n\tpfh.icmph.type = user_icmph.type; /* already checked */\n\tpfh.icmph.code = user_icmph.code; /* ditto */\n\tpfh.icmph.checksum = 0;\n\tpfh.icmph.un.echo.id = inet->inet_sport;\n\tpfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;\n\tpfh.iov = msg->msg_iov;\n\tpfh.wcheck = 0;\n\tpfh.family = AF_INET;\n\n\terr = ip_append_data(sk, &fl4, ping_getfrag, &pfh, len,\n\t\t\t0, &ipc, &rt, msg->msg_flags);\n\tif (err)\n\t\tip_flush_pending_frames(sk);\n\telse\n\t\terr = ping_v4_push_pending_frames(sk, &pfh, &fl4);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\ticmp_out_count(sock_net(sk), user_icmph.type);\n\t\treturn len;\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nint ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tint family = sk->sk_family;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", isk, isk->inet_num);\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\tif (family == AF_INET) {\n\t\t\treturn ip_recv_error(sk, msg, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len);\n#endif\n\t\t}\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* Don't bother checking the checksum */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\t*addr_len = sizeof(*sin);\n\t\t}\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tif (sin6) {\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = 0;\n\t\t\tsin6->sin6_addr = ip6->saddr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t\t*addr_len = sizeof(*sin6);\n\t\t}\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ping_recvmsg);\n\nint ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tpr_debug(\"ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\\n\",\n\t\t inet_sk(sk), inet_sk(sk)->inet_num, skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\tpr_debug(\"ping_queue_rcv_skb -> failed\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_queue_rcv_skb);\n\n\n/*\n *\tAll we need to do is get the socket.\n */\n\nvoid ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\n\t/* We assume the packet has already been checked by icmp_rcv */\n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t/* Push ICMP header back */\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk != NULL) {\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tping_queue_rcv_skb(sk, skb_get(skb));\n\t\tsock_put(sk);\n\t\treturn;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\n\t/* We're called from icmp_rcv(). kfree_skb() is done there. */\n}\nEXPORT_SYMBOL_GPL(ping_rcv);\n\nstruct proto ping_prot = {\n\t.name =\t\t\"PING\",\n\t.owner =\tTHIS_MODULE,\n\t.init =\t\tping_init_sock,\n\t.close =\tping_close,\n\t.connect =\tip4_datagram_connect,\n\t.disconnect =\tudp_disconnect,\n\t.setsockopt =\tip_setsockopt,\n\t.getsockopt =\tip_getsockopt,\n\t.sendmsg =\tping_v4_sendmsg,\n\t.recvmsg =\tping_recvmsg,\n\t.bind =\t\tping_bind,\n\t.backlog_rcv =\tping_queue_rcv_skb,\n\t.release_cb =\tip4_datagram_release_cb,\n\t.hash =\t\tping_hash,\n\t.unhash =\tping_unhash,\n\t.get_port =\tping_get_port,\n\t.obj_size =\tsizeof(struct inet_sock),\n};\nEXPORT_SYMBOL(ping_prot);\n\n#ifdef CONFIG_PROC_FS\n\nstatic struct sock *ping_get_first(struct seq_file *seq, int start)\n{\n\tstruct sock *sk;\n\tstruct ping_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\tfor (state->bucket = start; state->bucket < PING_HTABLE_SIZE;\n\t     ++state->bucket) {\n\t\tstruct hlist_nulls_node *node;\n\t\tstruct hlist_nulls_head *hslot;\n\n\t\thslot = &ping_table.hash[state->bucket];\n\n\t\tif (hlist_nulls_empty(hslot))\n\t\t\tcontinue;\n\n\t\tsk_nulls_for_each(sk, node, hslot) {\n\t\t\tif (net_eq(sock_net(sk), net) &&\n\t\t\t    sk->sk_family == state->family)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct ping_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\tdo {\n\t\tsk = sk_nulls_next(sk);\n\t} while (sk && (!net_eq(sock_net(sk), net)));\n\n\tif (!sk)\n\t\treturn ping_get_first(seq, state->bucket + 1);\n\treturn sk;\n}\n\nstatic struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = ping_get_first(seq, 0);\n\n\tif (sk)\n\t\twhile (pos && (sk = ping_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}\n\nvoid *ping_seq_start(struct seq_file *seq, loff_t *pos, sa_family_t family)\n{\n\tstruct ping_iter_state *state = seq->private;\n\tstate->bucket = 0;\n\tstate->family = family;\n\n\tread_lock_bh(&ping_table.lock);\n\n\treturn *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL_GPL(ping_seq_start);\n\nstatic void *ping_v4_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn ping_seq_start(seq, pos, AF_INET);\n}\n\nvoid *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = ping_get_idx(seq, 0);\n\telse\n\t\tsk = ping_get_next(seq, v);\n\n\t++*pos;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(ping_seq_next);\n\nvoid ping_seq_stop(struct seq_file *seq, void *v)\n{\n\tread_unlock_bh(&ping_table.lock);\n}\nEXPORT_SYMBOL_GPL(ping_seq_stop);\n\nstatic void ping_v4_format_sock(struct sock *sp, struct seq_file *f,\n\t\tint bucket, int *len)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src = inet->inet_rcv_saddr;\n\t__u16 destp = ntohs(inet->inet_dport);\n\t__u16 srcp = ntohs(inet->inet_sport);\n\n\tseq_printf(f, \"%5d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d%n\",\n\t\tbucket, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\tatomic_read(&sp->sk_refcnt), sp,\n\t\tatomic_read(&sp->sk_drops), len);\n}\n\nstatic int ping_v4_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"%-127s\\n\",\n\t\t\t   \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t   \"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t   \"inode ref pointer drops\");\n\telse {\n\t\tstruct ping_iter_state *state = seq->private;\n\t\tint len;\n\n\t\tping_v4_format_sock(v, seq, state->bucket, &len);\n\t\tseq_printf(seq, \"%*s\\n\", 127 - len, \"\");\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ping_v4_seq_ops = {\n\t.show\t\t= ping_v4_seq_show,\n\t.start\t\t= ping_v4_seq_start,\n\t.next\t\t= ping_seq_next,\n\t.stop\t\t= ping_seq_stop,\n};\n\nstatic int ping_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct ping_seq_afinfo *afinfo = PDE_DATA(inode);\n\treturn seq_open_net(inode, file, &afinfo->seq_ops,\n\t\t\t   sizeof(struct ping_iter_state));\n}\n\nconst struct file_operations ping_seq_fops = {\n\t.open\t\t= ping_seq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_net,\n};\nEXPORT_SYMBOL_GPL(ping_seq_fops);\n\nstatic struct ping_seq_afinfo ping_v4_seq_afinfo = {\n\t.name\t\t= \"icmp\",\n\t.family\t\t= AF_INET,\n\t.seq_fops\t= &ping_seq_fops,\n\t.seq_ops\t= {\n\t\t.start\t\t= ping_v4_seq_start,\n\t\t.show\t\t= ping_v4_seq_show,\n\t\t.next\t\t= ping_seq_next,\n\t\t.stop\t\t= ping_seq_stop,\n\t},\n};\n\nint ping_proc_register(struct net *net, struct ping_seq_afinfo *afinfo)\n{\n\tstruct proc_dir_entry *p;\n\tp = proc_create_data(afinfo->name, S_IRUGO, net->proc_net,\n\t\t\t     afinfo->seq_fops, afinfo);\n\tif (!p)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_proc_register);\n\nvoid ping_proc_unregister(struct net *net, struct ping_seq_afinfo *afinfo)\n{\n\tremove_proc_entry(afinfo->name, net->proc_net);\n}\nEXPORT_SYMBOL_GPL(ping_proc_unregister);\n\nstatic int __net_init ping_v4_proc_init_net(struct net *net)\n{\n\treturn ping_proc_register(net, &ping_v4_seq_afinfo);\n}\n\nstatic void __net_exit ping_v4_proc_exit_net(struct net *net)\n{\n\tping_proc_unregister(net, &ping_v4_seq_afinfo);\n}\n\nstatic struct pernet_operations ping_v4_net_ops = {\n\t.init = ping_v4_proc_init_net,\n\t.exit = ping_v4_proc_exit_net,\n};\n\nint __init ping_proc_init(void)\n{\n\treturn register_pernet_subsys(&ping_v4_net_ops);\n}\n\nvoid ping_proc_exit(void)\n{\n\tunregister_pernet_subsys(&ping_v4_net_ops);\n}\n\n#endif\n\nvoid __init ping_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PING_HTABLE_SIZE; i++)\n\t\tINIT_HLIST_NULLS_HEAD(&ping_table.hash[i], i);\n\trwlock_init(&ping_table.lock);\n}\n"], "filenames": ["net/ipv4/ping.c"], "buggy_code_start_loc": [873], "buggy_code_end_loc": [899], "fixing_code_start_loc": [873], "fixing_code_end_loc": [903], "type": "NVD-CWE-Other", "message": "The ping_recvmsg function in net/ipv4/ping.c in the Linux kernel before 3.12.4 does not properly interact with read system calls on ping sockets, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging unspecified privileges to execute a crafted application.", "other": {"cve": {"id": "CVE-2013-6432", "sourceIdentifier": "secalert@redhat.com", "published": "2013-12-09T18:55:10.517", "lastModified": "2023-02-13T04:49:57.943", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/476.html\n\n\"CWE-476: NULL Pointer Dereference\"", "descriptions": [{"lang": "en", "value": "The ping_recvmsg function in net/ipv4/ping.c in the Linux kernel before 3.12.4 does not properly interact with read system calls on ping sockets, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging unspecified privileges to execute a crafted application."}, {"lang": "es", "value": "La funci\u00f3n ping_recvmsg en net/ipv4/ping.c en Linux kernel anterior a  v3.12.4 no interact\u00faa correctamente con la syscall read en socket ping, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (referencia a un puntero NULL y ca\u00edda del sistema) aprovechando privilegios no especificados para ejecutar una aplicaci\u00f3n manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:S/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.1, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.12.3", "matchCriteriaId": "639CEAB6-EF61-4373-94D3-0B6423C0F038"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.19:*:*:*:*:*:*:*", "matchCriteriaId": "9DFF4564-6550-4839-B12A-EA379DDFE4F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.20:*:*:*:*:*:*:*", "matchCriteriaId": "10184594-C707-4A2F-AE28-430EC3102AA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.21:*:*:*:*:*:*:*", "matchCriteriaId": "9AD06026-B85F-412A-A44B-DAEF8D538327"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.22:*:*:*:*:*:*:*", "matchCriteriaId": "DCA2929F-EDF9-433B-9CD7-3EE9D2C5EDD4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.23:*:*:*:*:*:*:*", "matchCriteriaId": "80527FA6-39CD-4A85-BD3A-214AC617B995"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.7:*:*:*:*:*:*:*", "matchCriteriaId": "2422AC23-8410-4524-A733-25E4ABC7515D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.8:*:*:*:*:*:*:*", "matchCriteriaId": "E1BEBC08-884B-4F58-B3C6-B26F1D5BE474"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.9:*:*:*:*:*:*:*", "matchCriteriaId": "B26B7E40-0EEB-44DF-BE2E-917947D41217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.10:*:*:*:*:*:*:*", "matchCriteriaId": "EF5C073C-D0BF-4691-94C4-6E4582032F1E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B291154A-4B91-4A0E-AAAE-716A8BB7BF99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "D835FBA1-49DE-4184-BEC8-7ED2B3F7B0BB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "080BD3C9-0606-4D9A-B7AE-3DF9F75B8FF6"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=cf970c002d270c36202bd5b9c2804d3097a52da0", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.12.4", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/12/06/6", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.ubuntu.com/usn/USN-2113-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2117-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1039046", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/cf970c002d270c36202bd5b9c2804d3097a52da0", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cf970c002d270c36202bd5b9c2804d3097a52da0"}}