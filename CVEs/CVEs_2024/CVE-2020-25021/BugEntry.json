{"buggy_code": ["target\n.classpath\n.metadata\n.project\ndoc\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport com.southernstorm.noise.crypto.GHASH;\nimport com.southernstorm.noise.crypto.RijndaelAES;\n\n/**\n * Fallback implementation of \"AESGCM\" on platforms where\n * the JCA/JCE does not have a suitable GCM or CTR provider.\n */\nclass AESGCMFallbackCipherState implements CipherState {\n\n\tprivate RijndaelAES aes;\n\tprivate long n;\n\tprivate byte[] iv;\n\tprivate byte[] enciv;\n\tprivate byte[] hashKey;\n\tprivate GHASH ghash;\n\tprivate boolean haskey;\n\n\t/**\n\t * Constructs a new cipher state for the \"AESGCM\" algorithm.\n\t */\n\tpublic AESGCMFallbackCipherState()\n\t{\n\t\taes = new RijndaelAES();\n\t\tn = 0;\n\t\tiv = new byte [16];\n\t\tenciv = new byte [16];\n\t\thashKey = new byte [16];\n\t\tghash = new GHASH();\n\t\thaskey = false;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\taes.destroy();\n\t\tghash.destroy();\n\t\tNoise.destroy(hashKey);\n\t\tNoise.destroy(iv);\n\t\tNoise.destroy(enciv);\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"AESGCM\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn haskey ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\t// Set up the AES key.\n\t\taes.setupEnc(key, offset, 256);\n\t\thaskey = true;\n\n\t\t// Generate the hashing key by encrypting a block of zeroes.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\taes.encrypt(hashKey, 0, hashKey, 0);\n\t\tghash.reset(hashKey, 0);\n\t\t\n\t\t// Reset the nonce.\n\t\tn = 0;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn haskey;\n\t}\n\t\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad)\n\t{\n\t\t// Check for nonce wrap-around.\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\t\n\t\t// Format the counter/IV block.\n\t\tiv[0] = 0;\n\t\tiv[1] = 0;\n\t\tiv[2] = 0;\n\t\tiv[3] = 0;\n\t\tiv[4] = (byte)(n >> 56);\n\t\tiv[5] = (byte)(n >> 48);\n\t\tiv[6] = (byte)(n >> 40);\n\t\tiv[7] = (byte)(n >> 32);\n\t\tiv[8] = (byte)(n >> 24);\n\t\tiv[9] = (byte)(n >> 16);\n\t\tiv[10] = (byte)(n >> 8);\n\t\tiv[11] = (byte)n;\n\t\tiv[12] = 0;\n\t\tiv[13] = 0;\n\t\tiv[14] = 0;\n\t\tiv[15] = 1;\n\t\t++n;\n\t\t\n\t\t// Encrypt a block of zeroes to generate the hash key to XOR\n\t\t// the GHASH tag with at the end of the encrypt/decrypt operation.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\taes.encrypt(iv, 0, hashKey, 0);\n\t\t\n\t\t// Initialize the GHASH with the associated data value.\n\t\tghash.reset();\n\t\tif (ad != null) {\n\t\t\tghash.update(ad, 0, ad.length);\n\t\t\tghash.pad();\n\t\t}\n\t}\n\n\t/**\n\t * Encrypts a block in CTR mode.\n\t * \n\t * @param plaintext The plaintext to encrypt.\n\t * @param plaintextOffset Offset of the first plaintext byte.\n\t * @param ciphertext The resulting ciphertext.\n\t * @param ciphertextOffset Offset of the first ciphertext byte.\n\t * @param length The number of bytes to encrypt.\n\t * \n\t * This function can also be used to decrypt.\n\t */\n\tprivate void encryptCTR(byte[] plaintext, int plaintextOffset, byte[] ciphertext, int ciphertextOffset, int length)\n\t{\n\t\twhile (length > 0) {\n\t\t\t// Increment the IV and encrypt it to get the next keystream block.\n\t\t\tif (++(iv[15]) == 0)\n\t\t\t\tif (++(iv[14]) == 0)\n\t\t\t\t\tif (++(iv[13]) == 0)\n\t\t\t\t\t\t++(iv[12]);\n\t\t\taes.encrypt(iv, 0, enciv, 0);\n\t\t\t\n\t\t\t// XOR the keystream block with the plaintext to create the ciphertext.\n\t\t\tint temp = length;\n\t\t\tif (temp > 16)\n\t\t\t\ttemp = 16;\n\t\t\tfor (int index = 0; index < temp; ++index)\n\t\t\t\tciphertext[ciphertextOffset + index] = (byte)(plaintext[plaintextOffset + index] ^ enciv[index]);\n\t\t\t\n\t\t\t// Advance to the next block.\n\t\t\tplaintextOffset += temp;\n\t\t\tciphertextOffset += temp;\n\t\t\tlength -= temp;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length)\n\t\t\tthrows ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tencryptCTR(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\tghash.update(ciphertext, ciphertextOffset, length);\n\t\tghash.pad(ad != null ? ad.length : 0, length);\n\t\tghash.finish(ciphertext, ciphertextOffset + length, 16);\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\tciphertext[ciphertextOffset + length + index] ^= hashKey[index];\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (plaintextOffset > plaintext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tghash.update(ciphertext, ciphertextOffset, dataLen);\n\t\tghash.pad(ad != null ? ad.length : 0, dataLen);\n\t\tghash.finish(enciv, 0, 16);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (hashKey[index] ^ enciv[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\tencryptCTR(ciphertext, ciphertextOffset, plaintext, plaintextOffset, dataLen);\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher;\n\t\tcipher = new AESGCMFallbackCipherState();\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport com.southernstorm.noise.crypto.GHASH;\n\n/**\n * Emulates the \"AESGCM\" cipher for Noise using the \"AES/CTR/NoPadding\"\n * transformation from JCA/JCE.\n * \n * This class is used on platforms that don't have \"AES/GCM/NoPadding\",\n * but which do have the older \"AES/CTR/NoPadding\".\n */\nclass AESGCMOnCtrCipherState implements CipherState {\n\n\tprivate Cipher cipher;\n\tprivate SecretKeySpec keySpec;\n\tprivate long n;\n\tprivate byte[] iv;\n\tprivate byte[] hashKey;\n\tprivate GHASH ghash;\n\n\t/**\n\t * Constructs a new cipher state for the \"AESGCM\" algorithm.\n\t * \n\t * @throws NoSuchAlgorithmException The system does not have a\n\t * provider for this algorithm.\n\t */\n\tpublic AESGCMOnCtrCipherState() throws NoSuchAlgorithmException\n\t{\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\t// AES/CTR is available, but not the unpadded version?  Huh?\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding not available\", e);\n\t\t}\n\t\tkeySpec = null;\n\t\tn = 0;\n\t\tiv = new byte [16];\n\t\thashKey = new byte [16];\n\t\tghash = new GHASH();\n\t\t\n\t\t// Try to set a 256-bit key on the cipher.  Some JCE's are\n\t\t// configured to disallow 256-bit AES if an extra policy\n\t\t// file has not been installed.\n\t\ttry {\n\t\t\tSecretKeySpec spec = new SecretKeySpec(new byte [32], \"AES\");\n\t\t\tIvParameterSpec params = new IvParameterSpec(iv);\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, spec, params);\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding does not support 256-bit keys\", e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding does not support 256-bit keys\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\t// There doesn't seem to be a standard API to clean out a Cipher.\n\t\t// So we instead set the key and IV to all-zeroes to hopefully\n\t\t// destroy the sensitive data in the cipher instance.\n\t\tghash.destroy();\n\t\tNoise.destroy(hashKey);\n\t\tNoise.destroy(iv);\n\t\tkeySpec = new SecretKeySpec(new byte [32], \"AES\");\n\t\tIvParameterSpec params = new IvParameterSpec(iv);\n\t\ttry {\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, params);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"AESGCM\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn keySpec != null ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\t// Set the encryption key.\n\t\tkeySpec = new SecretKeySpec(key, offset, 32, \"AES\");\n\t\t\n\t\t// Generate the hashing key by encrypting a block of zeroes.\n\t\tArrays.fill(iv, (byte)0);\n\t\tArrays.fill(hashKey, (byte)0);\n\t\ttry {\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\ttry {\n\t\t\tint result = cipher.update(hashKey, 0, 16, hashKey, 0);\n\t\t\tcipher.doFinal(hashKey, result);\n\t\t} catch (ShortBufferException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.reset(hashKey, 0);\n\t\t\n\t\t// Reset the nonce.\n\t\tn = 0;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn keySpec != null;\n\t}\n\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad) throws InvalidKeyException, InvalidAlgorithmParameterException\n\t{\n\t\t// Check for nonce wrap-around.\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\t\n\t\t// Format the counter/IV block for AES/CTR/NoPadding.\n\t\tiv[0] = 0;\n\t\tiv[1] = 0;\n\t\tiv[2] = 0;\n\t\tiv[3] = 0;\n\t\tiv[4] = (byte)(n >> 56);\n\t\tiv[5] = (byte)(n >> 48);\n\t\tiv[6] = (byte)(n >> 40);\n\t\tiv[7] = (byte)(n >> 32);\n\t\tiv[8] = (byte)(n >> 24);\n\t\tiv[9] = (byte)(n >> 16);\n\t\tiv[10] = (byte)(n >> 8);\n\t\tiv[11] = (byte)n;\n\t\tiv[12] = 0;\n\t\tiv[13] = 0;\n\t\tiv[14] = 0;\n\t\tiv[15] = 1;\n\t\t++n;\n\t\t\n\t\t// Initialize the CTR mode cipher with the key and IV.\n\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n\t\t\n\t\t// Encrypt a block of zeroes to generate the hash key to XOR\n\t\t// the GHASH tag with at the end of the encrypt/decrypt operation.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\ttry {\n\t\t\tcipher.update(hashKey, 0, 16, hashKey, 0);\n\t\t} catch (ShortBufferException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\t\n\t\t// Initialize the GHASH with the associated data value.\n\t\tghash.reset();\n\t\tif (ad != null) {\n\t\t\tghash.update(ad, 0, ad.length);\n\t\t\tghash.pad();\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length)\n\t\t\tthrows ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (keySpec == null) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\ttry {\n\t\t\tsetup(ad);\n\t\t\tint result = cipher.update(plaintext, plaintextOffset, length, ciphertext, ciphertextOffset);\n\t\t\tcipher.doFinal(ciphertext, ciphertextOffset + result);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.update(ciphertext, ciphertextOffset, length);\n\t\tghash.pad(ad != null ? ad.length : 0, length);\n\t\tghash.finish(ciphertext, ciphertextOffset + length, 16);\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\tciphertext[ciphertextOffset + length + index] ^= hashKey[index];\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (plaintextOffset > plaintext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (keySpec == null) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\ttry {\n\t\t\tsetup(ad);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.update(ciphertext, ciphertextOffset, dataLen);\n\t\tghash.pad(ad != null ? ad.length : 0, dataLen);\n\t\tghash.finish(iv, 0, 16);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (hashKey[index] ^ iv[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\ttry {\n\t\t\tint result = cipher.update(ciphertext, ciphertextOffset, dataLen, plaintext, plaintextOffset);\n\t\t\tcipher.doFinal(plaintext, plaintextOffset + result);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher;\n\t\ttry {\n\t\t\tcipher = new AESGCMOnCtrCipherState();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t// Shouldn't happen.\n\t\t\treturn null;\n\t\t}\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport com.southernstorm.noise.crypto.ChaChaCore;\nimport com.southernstorm.noise.crypto.Poly1305;\n\n/**\n * Implements the ChaChaPoly cipher for Noise.\n */\nclass ChaChaPolyCipherState implements CipherState {\n\n\tprivate Poly1305 poly;\n\tprivate int[] input;\n\tprivate int[] output;\n\tprivate byte[] polyKey;\n\tlong n;\n\tprivate boolean haskey;\n\t\n\t/**\n\t * Constructs a new cipher state for the \"ChaChaPoly\" algorithm.\n\t */\n\tpublic ChaChaPolyCipherState()\n\t{\n\t\tpoly = new Poly1305();\n\t\tinput = new int [16];\n\t\toutput = new int [16];\n\t\tpolyKey = new byte [32];\n\t\tn = 0;\n\t\thaskey = false;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\tpoly.destroy();\n\t\tArrays.fill(input, 0);\n\t\tArrays.fill(output, 0);\n\t\tNoise.destroy(polyKey);\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"ChaChaPoly\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn haskey ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\tChaChaCore.initKey256(input, key, offset);\n\t\tn = 0;\n\t\thaskey = true;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn haskey;\n\t}\n\n\t/**\n\t * XOR's the output of ChaCha20 with a byte buffer.\n\t * \n\t * @param input The input byte buffer.\n\t * @param inputOffset The offset of the first input byte.\n\t * @param output The output byte buffer (can be the same as the input).\n\t * @param outputOffset The offset of the first output byte.\n\t * @param length The number of bytes to XOR between 1 and 64.\n\t * @param block The ChaCha20 output block.\n\t */\n\tprivate static void xorBlock(byte[] input, int inputOffset, byte[] output, int outputOffset, int length, int[] block)\n\t{\n\t\tint posn = 0;\n\t\tint value;\n\t\twhile (length >= 4) {\n\t\t\tvalue = block[posn++];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t\toutput[outputOffset + 1] = (byte)(input[inputOffset + 1] ^ (value >> 8));\n\t\t\toutput[outputOffset + 2] = (byte)(input[inputOffset + 2] ^ (value >> 16));\n\t\t\toutput[outputOffset + 3] = (byte)(input[inputOffset + 3] ^ (value >> 24));\n\t\t\tinputOffset += 4;\n\t\t\toutputOffset += 4;\n\t\t\tlength -= 4;\n\t\t}\n\t\tif (length == 3) {\n\t\t\tvalue = block[posn];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t\toutput[outputOffset + 1] = (byte)(input[inputOffset + 1] ^ (value >> 8));\n\t\t\toutput[outputOffset + 2] = (byte)(input[inputOffset + 2] ^ (value >> 16));\n\t\t} else if (length == 2) {\n\t\t\tvalue = block[posn];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t\toutput[outputOffset + 1] = (byte)(input[inputOffset + 1] ^ (value >> 8));\n\t\t} else if (length == 1) {\n\t\t\tvalue = block[posn];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad)\n\t{\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\tChaChaCore.initIV(input, n++);\n\t\tChaChaCore.hash(output, input);\n\t\tArrays.fill(polyKey, (byte)0);\n\t\txorBlock(polyKey, 0, polyKey, 0, 32, output);\n\t\tpoly.reset(polyKey, 0);\n\t\tif (ad != null) {\n\t\t\tpoly.update(ad, 0, ad.length);\n\t\t\tpoly.pad();\n\t\t}\n\t\tif (++(input[12]) == 0)\n\t\t\t++(input[13]);\n\t}\n\n\t/**\n\t * Puts a 64-bit integer into a buffer in little-endian order.\n\t * \n\t * @param output The output buffer.\n\t * @param offset The offset into the output buffer.\n\t * @param value The 64-bit integer value.\n\t */\n\tprivate static void putLittleEndian64(byte[] output, int offset, long value)\n\t{\n\t\toutput[offset] = (byte)value;\n\t\toutput[offset + 1] = (byte)(value >> 8);\n\t\toutput[offset + 2] = (byte)(value >> 16);\n\t\toutput[offset + 3] = (byte)(value >> 24);\n\t\toutput[offset + 4] = (byte)(value >> 32);\n\t\toutput[offset + 5] = (byte)(value >> 40);\n\t\toutput[offset + 6] = (byte)(value >> 48);\n\t\toutput[offset + 7] = (byte)(value >> 56);\n\t}\n\n\t/**\n\t * Finishes up the authentication tag for a packet.\n\t * \n\t * @param ad The associated data.\n\t * @param length The length of the plaintext data.\n\t */\n\tprivate void finish(byte[] ad, int length)\n\t{\n\t\tpoly.pad();\n\t\tputLittleEndian64(polyKey, 0, ad != null ? ad.length : 0);\n\t\tputLittleEndian64(polyKey, 8, length);\n\t\tpoly.update(polyKey, 0, 16);\n\t\tpoly.finish(polyKey, 0);\n\t}\n\n\t/**\n\t * Encrypts or decrypts a buffer of bytes for the active packet.\n\t * \n\t * @param plaintext The plaintext data to be encrypted.\n\t * @param plaintextOffset The offset to the first plaintext byte.\n\t * @param ciphertext The ciphertext data that results from encryption.\n\t * @param ciphertextOffset The offset to the first ciphertext byte.\n\t * @param length The number of bytes to encrypt.\n\t */\n\tprivate void encrypt(byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length) {\n\t\twhile (length > 0) {\n\t\t\tint tempLen = 64;\n\t\t\tif (tempLen > length)\n\t\t\t\ttempLen = length;\n\t\t\tChaChaCore.hash(output, input);\n\t\t\txorBlock(plaintext, plaintextOffset, ciphertext, ciphertextOffset, tempLen, output);\n\t\t\tif (++(input[12]) == 0)\n\t\t\t\t++(input[13]);\n\t\t\tplaintextOffset += tempLen;\n\t\t\tciphertextOffset += tempLen;\n\t\t\tlength -= tempLen;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length) throws ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tencrypt(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\tpoly.update(ciphertext, ciphertextOffset, length);\n\t\tfinish(ad, length);\n\t\tSystem.arraycopy(polyKey, 0, ciphertext, ciphertextOffset + length, 16);\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (plaintextOffset > plaintext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tpoly.update(ciphertext, ciphertextOffset, dataLen);\n\t\tfinish(ad, dataLen);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (polyKey[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\tencrypt(ciphertext, ciphertextOffset, plaintext, plaintextOffset, dataLen);\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher = new ChaChaPolyCipherState();\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.ShortBufferException;\n\n/**\n * Interface to an authenticated cipher for use in the Noise protocol.\n *\n * CipherState objects are used to encrypt or decrypt data during a\n * session.  Once the handshake has completed, HandshakeState.split()\n * will create two CipherState objects for encrypting packets sent to\n * the other party, and decrypting packets received from the other party.\n */\npublic interface CipherState extends Destroyable {\n\n\t/**\n\t * Gets the Noise protocol name for this cipher.\n\t * \n\t * @return The cipher name.\n\t */\n\tString getCipherName();\n\n\t/**\n\t * Gets the length of the key values for this cipher.\n\t * \n\t * @return The length of the key in bytes; usually 32.\n\t */\n\tint getKeyLength();\n\t\n\t/**\n\t * Gets the length of the MAC values for this cipher.\n\t * \n\t * @return The length of MAC values in bytes, or zero if the\n\t * key has not yet been initialized.\n\t */\n\tint getMACLength();\n\n\t/**\n\t * Initializes the key on this cipher object.\n\t * \n\t * @param key Points to a buffer that contains the key.\n\t * @param offset The offset of the key in the key buffer.\n\t * \n\t * The key buffer must contain at least getKeyLength() bytes\n\t * starting at offset.\n\t * \n\t * @see #hasKey()\n\t */\n\tvoid initializeKey(byte[] key, int offset);\n\n\t/**\n\t * Determine if this cipher object has been configured with a key.\n\t * \n\t * @return true if this cipher object has a key; false if the\n\t * key has not yet been set with initializeKey().\n\t * \n\t * @see #initializeKey(byte[], int)\n\t */\n\tboolean hasKey();\n\t\n\t/**\n\t * Encrypts a plaintext buffer using the cipher and a block of associated data.\n\t * \n\t * @param ad The associated data, or null if there is none.\n\t * @param plaintext The buffer containing the plaintext to encrypt.\n\t * @param plaintextOffset The offset within the plaintext buffer of the\n\t * first byte or plaintext data.\n\t * @param ciphertext The buffer to place the ciphertext in.  This can\n\t * be the same as the plaintext buffer.\n\t * @param ciphertextOffset The first offset within the ciphertext buffer\n\t * to place the ciphertext and the MAC tag.\n\t * @param length The length of the plaintext.\n\t * @return The length of the ciphertext plus the MAC tag, or -1 if the\n\t * ciphertext buffer is not large enough to hold the result.\n\t * \n\t * @throws ShortBufferException The ciphertext buffer does not have\n\t * enough space to hold the ciphertext plus MAC.\n\t * \n\t * @throws IllegalStateException The nonce has wrapped around.\n\t * \n\t * The plaintext and ciphertext buffers can be the same for in-place\n\t * encryption.  In that case, plaintextOffset must be identical to\n\t * ciphertextOffset.\n\t * \n\t * There must be enough space in the ciphertext buffer to accomodate\n\t * length + getMACLength() bytes of data starting at ciphertextOffset.\n\t */\n\tint encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset, byte[] ciphertext, int ciphertextOffset, int length) throws ShortBufferException;\n\n\t/**\n\t * Decrypts a ciphertext buffer using the cipher and a block of associated data.\n\t * \n\t * @param ad The associated data, or null if there is none.\n\t * @param ciphertext The buffer containing the ciphertext to decrypt.\n\t * @param ciphertextOffset The offset within the ciphertext buffer of\n\t * the first byte of ciphertext data.\n\t * @param plaintext The buffer to place the plaintext in.  This can be\n\t * the same as the ciphertext buffer.\n\t * @param plaintextOffset The first offset within the plaintext buffer\n\t * to place the plaintext.\n\t * @param length The length of the incoming ciphertext plus the MAC tag.\n\t * @return The length of the plaintext with the MAC tag stripped off.\n\t * \n\t * @throws ShortBufferException The plaintext buffer does not have\n\t * enough space to store the decrypted data.\n\t * \n\t * @throws BadPaddingException The MAC value failed to verify.\n\t * \n\t * @throws IllegalStateException The nonce has wrapped around.\n\t * \n\t * The plaintext and ciphertext buffers can be the same for in-place\n\t * decryption.  In that case, ciphertextOffset must be identical to\n\t * plaintextOffset.\n\t */\n\tint decryptWithAd(byte[] ad, byte[] ciphertext, int ciphertextOffset, byte[] plaintext, int plaintextOffset, int length) throws ShortBufferException, BadPaddingException;\n\n\t/**\n\t * Creates a new instance of this cipher and initializes it with a key.\n\t * \n\t * @param key The buffer containing the key.\n\t * @param offset The offset into the key buffer of the first key byte.\n\t * @return A new CipherState of the same class as this one.\n\t */\n\tCipherState fork(byte[] key, int offset);\n\t\n\t/**\n\t * Sets the nonce value.\n\t * \n\t * @param nonce The new nonce value, which must be greater than or equal\n\t * to the current value.\n\t * \n\t * This function is intended for testing purposes only.  If the nonce\n\t * value goes backwards then security may be compromised.\n\t */\n\tvoid setNonce(long nonce);\n}\n"], "fixing_code": ["target\n.classpath\n.metadata\n.project\ndoc\n*.class\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport com.southernstorm.noise.crypto.GHASH;\nimport com.southernstorm.noise.crypto.RijndaelAES;\n\n/**\n * Fallback implementation of \"AESGCM\" on platforms where\n * the JCA/JCE does not have a suitable GCM or CTR provider.\n */\nclass AESGCMFallbackCipherState implements CipherState {\n\n\tprivate RijndaelAES aes;\n\tprivate long n;\n\tprivate byte[] iv;\n\tprivate byte[] enciv;\n\tprivate byte[] hashKey;\n\tprivate GHASH ghash;\n\tprivate boolean haskey;\n\n\t/**\n\t * Constructs a new cipher state for the \"AESGCM\" algorithm.\n\t */\n\tpublic AESGCMFallbackCipherState()\n\t{\n\t\taes = new RijndaelAES();\n\t\tn = 0;\n\t\tiv = new byte [16];\n\t\tenciv = new byte [16];\n\t\thashKey = new byte [16];\n\t\tghash = new GHASH();\n\t\thaskey = false;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\taes.destroy();\n\t\tghash.destroy();\n\t\tNoise.destroy(hashKey);\n\t\tNoise.destroy(iv);\n\t\tNoise.destroy(enciv);\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"AESGCM\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn haskey ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\t// Set up the AES key.\n\t\taes.setupEnc(key, offset, 256);\n\t\thaskey = true;\n\n\t\t// Generate the hashing key by encrypting a block of zeroes.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\taes.encrypt(hashKey, 0, hashKey, 0);\n\t\tghash.reset(hashKey, 0);\n\t\t\n\t\t// Reset the nonce.\n\t\tn = 0;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn haskey;\n\t}\n\t\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad)\n\t{\n\t\t// Check for nonce wrap-around.\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\t\n\t\t// Format the counter/IV block.\n\t\tiv[0] = 0;\n\t\tiv[1] = 0;\n\t\tiv[2] = 0;\n\t\tiv[3] = 0;\n\t\tiv[4] = (byte)(n >> 56);\n\t\tiv[5] = (byte)(n >> 48);\n\t\tiv[6] = (byte)(n >> 40);\n\t\tiv[7] = (byte)(n >> 32);\n\t\tiv[8] = (byte)(n >> 24);\n\t\tiv[9] = (byte)(n >> 16);\n\t\tiv[10] = (byte)(n >> 8);\n\t\tiv[11] = (byte)n;\n\t\tiv[12] = 0;\n\t\tiv[13] = 0;\n\t\tiv[14] = 0;\n\t\tiv[15] = 1;\n\t\t++n;\n\t\t\n\t\t// Encrypt a block of zeroes to generate the hash key to XOR\n\t\t// the GHASH tag with at the end of the encrypt/decrypt operation.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\taes.encrypt(iv, 0, hashKey, 0);\n\t\t\n\t\t// Initialize the GHASH with the associated data value.\n\t\tghash.reset();\n\t\tif (ad != null) {\n\t\t\tghash.update(ad, 0, ad.length);\n\t\t\tghash.pad();\n\t\t}\n\t}\n\n\t/**\n\t * Encrypts a block in CTR mode.\n\t * \n\t * @param plaintext The plaintext to encrypt.\n\t * @param plaintextOffset Offset of the first plaintext byte.\n\t * @param ciphertext The resulting ciphertext.\n\t * @param ciphertextOffset Offset of the first ciphertext byte.\n\t * @param length The number of bytes to encrypt.\n\t * \n\t * This function can also be used to decrypt.\n\t */\n\tprivate void encryptCTR(byte[] plaintext, int plaintextOffset, byte[] ciphertext, int ciphertextOffset, int length)\n\t{\n\t\twhile (length > 0) {\n\t\t\t// Increment the IV and encrypt it to get the next keystream block.\n\t\t\tif (++(iv[15]) == 0)\n\t\t\t\tif (++(iv[14]) == 0)\n\t\t\t\t\tif (++(iv[13]) == 0)\n\t\t\t\t\t\t++(iv[12]);\n\t\t\taes.encrypt(iv, 0, enciv, 0);\n\t\t\t\n\t\t\t// XOR the keystream block with the plaintext to create the ciphertext.\n\t\t\tint temp = length;\n\t\t\tif (temp > 16)\n\t\t\t\ttemp = 16;\n\t\t\tfor (int index = 0; index < temp; ++index)\n\t\t\t\tciphertext[ciphertextOffset + index] = (byte)(plaintext[plaintextOffset + index] ^ enciv[index]);\n\t\t\t\n\t\t\t// Advance to the next block.\n\t\t\tplaintextOffset += temp;\n\t\t\tciphertextOffset += temp;\n\t\t\tlength -= temp;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length)\n\t\t\tthrows ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset < 0 || ciphertextOffset > ciphertext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (length < 0 || plaintextOffset < 0 || plaintextOffset > plaintext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tencryptCTR(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\tghash.update(ciphertext, ciphertextOffset, length);\n\t\tghash.pad(ad != null ? ad.length : 0, length);\n\t\tghash.finish(ciphertext, ciphertextOffset + length, 16);\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\tciphertext[ciphertextOffset + length + index] ^= hashKey[index];\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset < 0 || ciphertextOffset > ciphertext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (length < 0 || plaintextOffset < 0 || plaintextOffset > plaintext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tghash.update(ciphertext, ciphertextOffset, dataLen);\n\t\tghash.pad(ad != null ? ad.length : 0, dataLen);\n\t\tghash.finish(enciv, 0, 16);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (hashKey[index] ^ enciv[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\tencryptCTR(ciphertext, ciphertextOffset, plaintext, plaintextOffset, dataLen);\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher;\n\t\tcipher = new AESGCMFallbackCipherState();\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport com.southernstorm.noise.crypto.GHASH;\n\n/**\n * Emulates the \"AESGCM\" cipher for Noise using the \"AES/CTR/NoPadding\"\n * transformation from JCA/JCE.\n * \n * This class is used on platforms that don't have \"AES/GCM/NoPadding\",\n * but which do have the older \"AES/CTR/NoPadding\".\n */\nclass AESGCMOnCtrCipherState implements CipherState {\n\n\tprivate Cipher cipher;\n\tprivate SecretKeySpec keySpec;\n\tprivate long n;\n\tprivate byte[] iv;\n\tprivate byte[] hashKey;\n\tprivate GHASH ghash;\n\n\t/**\n\t * Constructs a new cipher state for the \"AESGCM\" algorithm.\n\t * \n\t * @throws NoSuchAlgorithmException The system does not have a\n\t * provider for this algorithm.\n\t */\n\tpublic AESGCMOnCtrCipherState() throws NoSuchAlgorithmException\n\t{\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\t// AES/CTR is available, but not the unpadded version?  Huh?\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding not available\", e);\n\t\t}\n\t\tkeySpec = null;\n\t\tn = 0;\n\t\tiv = new byte [16];\n\t\thashKey = new byte [16];\n\t\tghash = new GHASH();\n\t\t\n\t\t// Try to set a 256-bit key on the cipher.  Some JCE's are\n\t\t// configured to disallow 256-bit AES if an extra policy\n\t\t// file has not been installed.\n\t\ttry {\n\t\t\tSecretKeySpec spec = new SecretKeySpec(new byte [32], \"AES\");\n\t\t\tIvParameterSpec params = new IvParameterSpec(iv);\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, spec, params);\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding does not support 256-bit keys\", e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding does not support 256-bit keys\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\t// There doesn't seem to be a standard API to clean out a Cipher.\n\t\t// So we instead set the key and IV to all-zeroes to hopefully\n\t\t// destroy the sensitive data in the cipher instance.\n\t\tghash.destroy();\n\t\tNoise.destroy(hashKey);\n\t\tNoise.destroy(iv);\n\t\tkeySpec = new SecretKeySpec(new byte [32], \"AES\");\n\t\tIvParameterSpec params = new IvParameterSpec(iv);\n\t\ttry {\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, params);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"AESGCM\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn keySpec != null ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\t// Set the encryption key.\n\t\tkeySpec = new SecretKeySpec(key, offset, 32, \"AES\");\n\t\t\n\t\t// Generate the hashing key by encrypting a block of zeroes.\n\t\tArrays.fill(iv, (byte)0);\n\t\tArrays.fill(hashKey, (byte)0);\n\t\ttry {\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\ttry {\n\t\t\tint result = cipher.update(hashKey, 0, 16, hashKey, 0);\n\t\t\tcipher.doFinal(hashKey, result);\n\t\t} catch (ShortBufferException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.reset(hashKey, 0);\n\t\t\n\t\t// Reset the nonce.\n\t\tn = 0;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn keySpec != null;\n\t}\n\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad) throws InvalidKeyException, InvalidAlgorithmParameterException\n\t{\n\t\t// Check for nonce wrap-around.\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\t\n\t\t// Format the counter/IV block for AES/CTR/NoPadding.\n\t\tiv[0] = 0;\n\t\tiv[1] = 0;\n\t\tiv[2] = 0;\n\t\tiv[3] = 0;\n\t\tiv[4] = (byte)(n >> 56);\n\t\tiv[5] = (byte)(n >> 48);\n\t\tiv[6] = (byte)(n >> 40);\n\t\tiv[7] = (byte)(n >> 32);\n\t\tiv[8] = (byte)(n >> 24);\n\t\tiv[9] = (byte)(n >> 16);\n\t\tiv[10] = (byte)(n >> 8);\n\t\tiv[11] = (byte)n;\n\t\tiv[12] = 0;\n\t\tiv[13] = 0;\n\t\tiv[14] = 0;\n\t\tiv[15] = 1;\n\t\t++n;\n\t\t\n\t\t// Initialize the CTR mode cipher with the key and IV.\n\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n\t\t\n\t\t// Encrypt a block of zeroes to generate the hash key to XOR\n\t\t// the GHASH tag with at the end of the encrypt/decrypt operation.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\ttry {\n\t\t\tcipher.update(hashKey, 0, 16, hashKey, 0);\n\t\t} catch (ShortBufferException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\t\n\t\t// Initialize the GHASH with the associated data value.\n\t\tghash.reset();\n\t\tif (ad != null) {\n\t\t\tghash.update(ad, 0, ad.length);\n\t\t\tghash.pad();\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length)\n\t\t\tthrows ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset < 0 || ciphertextOffset > ciphertext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (length < 0 || plaintextOffset < 0 || plaintextOffset > plaintext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (keySpec == null) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\ttry {\n\t\t\tsetup(ad);\n\t\t\tint result = cipher.update(plaintext, plaintextOffset, length, ciphertext, ciphertextOffset);\n\t\t\tcipher.doFinal(ciphertext, ciphertextOffset + result);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.update(ciphertext, ciphertextOffset, length);\n\t\tghash.pad(ad != null ? ad.length : 0, length);\n\t\tghash.finish(ciphertext, ciphertextOffset + length, 16);\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\tciphertext[ciphertextOffset + length + index] ^= hashKey[index];\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset < 0 || ciphertextOffset > ciphertext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (length < 0 || plaintextOffset < 0 || plaintextOffset > plaintext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (keySpec == null) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\ttry {\n\t\t\tsetup(ad);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.update(ciphertext, ciphertextOffset, dataLen);\n\t\tghash.pad(ad != null ? ad.length : 0, dataLen);\n\t\tghash.finish(iv, 0, 16);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (hashKey[index] ^ iv[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\ttry {\n\t\t\tint result = cipher.update(ciphertext, ciphertextOffset, dataLen, plaintext, plaintextOffset);\n\t\t\tcipher.doFinal(plaintext, plaintextOffset + result);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher;\n\t\ttry {\n\t\t\tcipher = new AESGCMOnCtrCipherState();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t// Shouldn't happen.\n\t\t\treturn null;\n\t\t}\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport com.southernstorm.noise.crypto.ChaChaCore;\nimport com.southernstorm.noise.crypto.Poly1305;\n\n/**\n * Implements the ChaChaPoly cipher for Noise.\n */\nclass ChaChaPolyCipherState implements CipherState {\n\n\tprivate Poly1305 poly;\n\tprivate int[] input;\n\tprivate int[] output;\n\tprivate byte[] polyKey;\n\tlong n;\n\tprivate boolean haskey;\n\t\n\t/**\n\t * Constructs a new cipher state for the \"ChaChaPoly\" algorithm.\n\t */\n\tpublic ChaChaPolyCipherState()\n\t{\n\t\tpoly = new Poly1305();\n\t\tinput = new int [16];\n\t\toutput = new int [16];\n\t\tpolyKey = new byte [32];\n\t\tn = 0;\n\t\thaskey = false;\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\tpoly.destroy();\n\t\tArrays.fill(input, 0);\n\t\tArrays.fill(output, 0);\n\t\tNoise.destroy(polyKey);\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"ChaChaPoly\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn haskey ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\tChaChaCore.initKey256(input, key, offset);\n\t\tn = 0;\n\t\thaskey = true;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn haskey;\n\t}\n\n\t/**\n\t * XOR's the output of ChaCha20 with a byte buffer.\n\t * \n\t * @param input The input byte buffer.\n\t * @param inputOffset The offset of the first input byte.\n\t * @param output The output byte buffer (can be the same as the input).\n\t * @param outputOffset The offset of the first output byte.\n\t * @param length The number of bytes to XOR between 1 and 64.\n\t * @param block The ChaCha20 output block.\n\t */\n\tprivate static void xorBlock(byte[] input, int inputOffset, byte[] output, int outputOffset, int length, int[] block)\n\t{\n\t\tint posn = 0;\n\t\tint value;\n\t\twhile (length >= 4) {\n\t\t\tvalue = block[posn++];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t\toutput[outputOffset + 1] = (byte)(input[inputOffset + 1] ^ (value >> 8));\n\t\t\toutput[outputOffset + 2] = (byte)(input[inputOffset + 2] ^ (value >> 16));\n\t\t\toutput[outputOffset + 3] = (byte)(input[inputOffset + 3] ^ (value >> 24));\n\t\t\tinputOffset += 4;\n\t\t\toutputOffset += 4;\n\t\t\tlength -= 4;\n\t\t}\n\t\tif (length == 3) {\n\t\t\tvalue = block[posn];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t\toutput[outputOffset + 1] = (byte)(input[inputOffset + 1] ^ (value >> 8));\n\t\t\toutput[outputOffset + 2] = (byte)(input[inputOffset + 2] ^ (value >> 16));\n\t\t} else if (length == 2) {\n\t\t\tvalue = block[posn];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t\toutput[outputOffset + 1] = (byte)(input[inputOffset + 1] ^ (value >> 8));\n\t\t} else if (length == 1) {\n\t\t\tvalue = block[posn];\n\t\t\toutput[outputOffset] = (byte)(input[inputOffset] ^ value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad)\n\t{\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\tChaChaCore.initIV(input, n++);\n\t\tChaChaCore.hash(output, input);\n\t\tArrays.fill(polyKey, (byte)0);\n\t\txorBlock(polyKey, 0, polyKey, 0, 32, output);\n\t\tpoly.reset(polyKey, 0);\n\t\tif (ad != null) {\n\t\t\tpoly.update(ad, 0, ad.length);\n\t\t\tpoly.pad();\n\t\t}\n\t\tif (++(input[12]) == 0)\n\t\t\t++(input[13]);\n\t}\n\n\t/**\n\t * Puts a 64-bit integer into a buffer in little-endian order.\n\t * \n\t * @param output The output buffer.\n\t * @param offset The offset into the output buffer.\n\t * @param value The 64-bit integer value.\n\t */\n\tprivate static void putLittleEndian64(byte[] output, int offset, long value)\n\t{\n\t\toutput[offset] = (byte)value;\n\t\toutput[offset + 1] = (byte)(value >> 8);\n\t\toutput[offset + 2] = (byte)(value >> 16);\n\t\toutput[offset + 3] = (byte)(value >> 24);\n\t\toutput[offset + 4] = (byte)(value >> 32);\n\t\toutput[offset + 5] = (byte)(value >> 40);\n\t\toutput[offset + 6] = (byte)(value >> 48);\n\t\toutput[offset + 7] = (byte)(value >> 56);\n\t}\n\n\t/**\n\t * Finishes up the authentication tag for a packet.\n\t * \n\t * @param ad The associated data.\n\t * @param length The length of the plaintext data.\n\t */\n\tprivate void finish(byte[] ad, int length)\n\t{\n\t\tpoly.pad();\n\t\tputLittleEndian64(polyKey, 0, ad != null ? ad.length : 0);\n\t\tputLittleEndian64(polyKey, 8, length);\n\t\tpoly.update(polyKey, 0, 16);\n\t\tpoly.finish(polyKey, 0);\n\t}\n\n\t/**\n\t * Encrypts or decrypts a buffer of bytes for the active packet.\n\t * \n\t * @param plaintext The plaintext data to be encrypted.\n\t * @param plaintextOffset The offset to the first plaintext byte.\n\t * @param ciphertext The ciphertext data that results from encryption.\n\t * @param ciphertextOffset The offset to the first ciphertext byte.\n\t * @param length The number of bytes to encrypt.\n\t */\n\tprivate void encrypt(byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length) {\n\t\twhile (length > 0) {\n\t\t\tint tempLen = 64;\n\t\t\tif (tempLen > length)\n\t\t\t\ttempLen = length;\n\t\t\tChaChaCore.hash(output, input);\n\t\t\txorBlock(plaintext, plaintextOffset, ciphertext, ciphertextOffset, tempLen, output);\n\t\t\tif (++(input[12]) == 0)\n\t\t\t\t++(input[13]);\n\t\t\tplaintextOffset += tempLen;\n\t\t\tciphertextOffset += tempLen;\n\t\t\tlength -= tempLen;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length) throws ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset < 0 || ciphertextOffset > ciphertext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (length < 0 || plaintextOffset < 0 || plaintextOffset > plaintext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tencrypt(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\tpoly.update(ciphertext, ciphertextOffset, length);\n\t\tfinish(ad, length);\n\t\tSystem.arraycopy(polyKey, 0, ciphertext, ciphertextOffset + length, 16);\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset < 0 || ciphertextOffset > ciphertext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (length < 0 || plaintextOffset < 0 || plaintextOffset > plaintext.length)\n\t\t\tthrow new IllegalArgumentException();\n\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (!haskey) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\tsetup(ad);\n\t\tpoly.update(ciphertext, ciphertextOffset, dataLen);\n\t\tfinish(ad, dataLen);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (polyKey[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\tencrypt(ciphertext, ciphertextOffset, plaintext, plaintextOffset, dataLen);\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher = new ChaChaPolyCipherState();\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.ShortBufferException;\n\n/**\n * Interface to an authenticated cipher for use in the Noise protocol.\n *\n * CipherState objects are used to encrypt or decrypt data during a\n * session.  Once the handshake has completed, HandshakeState.split()\n * will create two CipherState objects for encrypting packets sent to\n * the other party, and decrypting packets received from the other party.\n */\npublic interface CipherState extends Destroyable {\n\n\t/**\n\t * Gets the Noise protocol name for this cipher.\n\t * \n\t * @return The cipher name.\n\t */\n\tString getCipherName();\n\n\t/**\n\t * Gets the length of the key values for this cipher.\n\t * \n\t * @return The length of the key in bytes; usually 32.\n\t */\n\tint getKeyLength();\n\t\n\t/**\n\t * Gets the length of the MAC values for this cipher.\n\t * \n\t * @return The length of MAC values in bytes, or zero if the\n\t * key has not yet been initialized.\n\t */\n\tint getMACLength();\n\n\t/**\n\t * Initializes the key on this cipher object.\n\t * \n\t * @param key Points to a buffer that contains the key.\n\t * @param offset The offset of the key in the key buffer.\n\t * \n\t * The key buffer must contain at least getKeyLength() bytes\n\t * starting at offset.\n\t * \n\t * @see #hasKey()\n\t */\n\tvoid initializeKey(byte[] key, int offset);\n\n\t/**\n\t * Determine if this cipher object has been configured with a key.\n\t * \n\t * @return true if this cipher object has a key; false if the\n\t * key has not yet been set with initializeKey().\n\t * \n\t * @see #initializeKey(byte[], int)\n\t */\n\tboolean hasKey();\n\t\n\t/**\n\t * Encrypts a plaintext buffer using the cipher and a block of associated data.\n\t * \n\t * @param ad The associated data, or null if there is none.\n\t * @param plaintext The buffer containing the plaintext to encrypt.\n\t * @param plaintextOffset The offset within the plaintext buffer of the\n\t * first byte or plaintext data.\n\t * @param ciphertext The buffer to place the ciphertext in.  This can\n\t * be the same as the plaintext buffer.\n\t * @param ciphertextOffset The first offset within the ciphertext buffer\n\t * to place the ciphertext and the MAC tag.\n\t * @param length The length of the plaintext.\n\t * @return The length of the ciphertext plus the MAC tag, or -1 if the\n\t * ciphertext buffer is not large enough to hold the result.\n\t * \n\t * @throws ShortBufferException The ciphertext buffer does not have\n\t * enough space to hold the ciphertext plus MAC.\n\t * \n\t * @throws IllegalStateException The nonce has wrapped around.\n\t * \n\t * @throws IllegalArgumentException One of the parameters is out of range.\n\t *\n\t * The plaintext and ciphertext buffers can be the same for in-place\n\t * encryption.  In that case, plaintextOffset must be identical to\n\t * ciphertextOffset.\n\t * \n\t * There must be enough space in the ciphertext buffer to accomodate\n\t * length + getMACLength() bytes of data starting at ciphertextOffset.\n\t */\n\tint encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset, byte[] ciphertext, int ciphertextOffset, int length) throws ShortBufferException;\n\n\t/**\n\t * Decrypts a ciphertext buffer using the cipher and a block of associated data.\n\t * \n\t * @param ad The associated data, or null if there is none.\n\t * @param ciphertext The buffer containing the ciphertext to decrypt.\n\t * @param ciphertextOffset The offset within the ciphertext buffer of\n\t * the first byte of ciphertext data.\n\t * @param plaintext The buffer to place the plaintext in.  This can be\n\t * the same as the ciphertext buffer.\n\t * @param plaintextOffset The first offset within the plaintext buffer\n\t * to place the plaintext.\n\t * @param length The length of the incoming ciphertext plus the MAC tag.\n\t * @return The length of the plaintext with the MAC tag stripped off.\n\t * \n\t * @throws ShortBufferException The plaintext buffer does not have\n\t * enough space to store the decrypted data.\n\t * \n\t * @throws BadPaddingException The MAC value failed to verify.\n\t * \n\t * @throws IllegalStateException The nonce has wrapped around.\n\t * \n\t * @throws IllegalArgumentException One of the parameters is out of range.\n\t *\n\t * The plaintext and ciphertext buffers can be the same for in-place\n\t * decryption.  In that case, ciphertextOffset must be identical to\n\t * plaintextOffset.\n\t */\n\tint decryptWithAd(byte[] ad, byte[] ciphertext, int ciphertextOffset, byte[] plaintext, int plaintextOffset, int length) throws ShortBufferException, BadPaddingException;\n\n\t/**\n\t * Creates a new instance of this cipher and initializes it with a key.\n\t * \n\t * @param key The buffer containing the key.\n\t * @param offset The offset into the key buffer of the first key byte.\n\t * @return A new CipherState of the same class as this one.\n\t */\n\tCipherState fork(byte[] key, int offset);\n\t\n\t/**\n\t * Sets the nonce value.\n\t * \n\t * @param nonce The new nonce value, which must be greater than or equal\n\t * to the current value.\n\t * \n\t * This function is intended for testing purposes only.  If the nonce\n\t * value goes backwards then security may be compromised.\n\t */\n\tvoid setNonce(long nonce);\n}\n"], "filenames": [".gitignore", "src/main/java/com/southernstorm/noise/protocol/AESGCMFallbackCipherState.java", "src/main/java/com/southernstorm/noise/protocol/AESGCMOnCtrCipherState.java", "src/main/java/com/southernstorm/noise/protocol/ChaChaPolyCipherState.java", "src/main/java/com/southernstorm/noise/protocol/CipherState.java"], "buggy_code_start_loc": [5, 188, 221, 217, 102], "buggy_code_end_loc": [5, 227, 275, 254, 132], "fixing_code_start_loc": [6, 188, 221, 217, 103], "fixing_code_end_loc": [7, 227, 275, 254, 137], "type": "CWE-125", "message": "An issue was discovered in Noise-Java through 2020-08-27. ChaChaPolyCipherState.encryptWithAd() allows out-of-bounds access.", "other": {"cve": {"id": "CVE-2020-25021", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-04T04:15:12.140", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Noise-Java through 2020-08-27. ChaChaPolyCipherState.encryptWithAd() allows out-of-bounds access."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Noise-Java hasta el 27-08-2020.&#xa0;La funci\u00f3n ChaChaPolyCipherState.encryptWithAd() permite un acceso fuera de l\u00edmites"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:noise-java_project:noise-java:*:*:*:*:*:*:*:*", "versionEndIncluding": "2020-08-27", "matchCriteriaId": "37EF510A-14D0-4228-B8D8-B3A992913E96"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/159057/Noise-Java-ChaChaPolyCipherState.encryptWithAd-Insufficient-Boundary-Checks.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2020/Sep/14", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rweather/noise-java/commit/18e86b6f8bea7326934109aa9ffa705ebf4bde90", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rweather/noise-java/pull/12", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rweather/noise-java/commit/18e86b6f8bea7326934109aa9ffa705ebf4bde90"}}