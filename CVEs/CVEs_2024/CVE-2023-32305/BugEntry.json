{"buggy_code": ["DO LANGUAGE plpgsql\n$OUTER$\nDECLARE\n    my_schema pg_catalog.TEXT := pg_catalog.quote_ident(pg_catalog.current_schema());\n    old_path pg_catalog.TEXT := pg_catalog.current_setting('search_path');\nBEGIN\n\n-- for safety, transiently set search_path to just pg_catalog+pg_temp\nPERFORM pg_catalog.set_config('search_path', 'pg_catalog, pg_temp', true);\n\n\nPERFORM 1\n    FROM pg_catalog.pg_type AS t JOIN pg_catalog.pg_roles AS r ON (r.oid = t.typowner)\n    WHERE r.rolsuper\n        AND t.typnamespace = 'aiven_extras'::regnamespace\n        AND t.typname = 'aiven_pg_subscription';\nIF NOT FOUND THEN\n    CREATE TYPE aiven_extras.aiven_pg_subscription AS (\n        subdbid OID,\n        subname NAME,\n        subowner OID,\n        subenabled BOOLEAN,\n        subconninfo TEXT,\n        subslotname NAME,\n        subsynccommit TEXT,\n        subpublications TEXT[]\n    );\nEND IF;\n\nPERFORM 1\n    FROM pg_catalog.pg_type AS t JOIN pg_catalog.pg_roles AS r ON (r.oid = t.typowner)\n    WHERE r.rolsuper\n        AND typnamespace = 'aiven_extras'::regnamespace\n        AND typname = 'aiven_pg_stat_replication';\nIF NOT FOUND THEN\n    CREATE TYPE aiven_extras.aiven_pg_stat_replication AS (\n        pid INT,\n        usesysid OID,\n        usename NAME,\n        application_name TEXT,\n        client_addr INET,\n        client_hostname TEXT,\n        client_port INT,\n        backend_start TIMESTAMP WITH TIME ZONE,\n        backend_xmin XID,\n        state TEXT,\n        sent_lsn PG_LSN,\n        write_lsn PG_LSN,\n        flush_lsn PG_LSN,\n        replay_lsn PG_LSN,\n        write_lag INTERVAL,\n        flush_lag INTERVAL,\n        replay_lag INTERVAL,\n        sync_priority INTEGER,\n        sync_state TEXT\n    );\nEND IF;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.dblink_record_execute(TEXT, TEXT);\nCREATE FUNCTION aiven_extras.dblink_record_execute(TEXT, TEXT)\nRETURNS SETOF record LANGUAGE c\nPARALLEL RESTRICTED STRICT\nAS '$libdir/dblink', $$dblink_record$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.dblink_slot_create_or_drop(TEXT, TEXT, TEXT);\nCREATE FUNCTION aiven_extras.dblink_slot_create_or_drop(\n    arg_connection_string TEXT,\n    arg_slot_name TEXT,\n    arg_action TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSET search_path = pg_catalog, aiven_extras\nAS $$\nDECLARE\n    l_clear_search_path TEXT := 'SET search_path TO pg_catalog, pg_temp;';\n    l_slot_existence_query TEXT := pg_catalog.format('SELECT TRUE FROM pg_catalog.pg_replication_slots WHERE slot_name OPERATOR(pg_catalog.=) %L', arg_slot_name);\n    l_slot_action_query TEXT;\n    l_slot_exists BOOLEAN;\nBEGIN\n    SELECT res INTO l_slot_exists\n        FROM aiven_extras.dblink_record_execute(\n                arg_connection_string,\n                l_clear_search_path || l_slot_existence_query\n            ) AS d (res BOOLEAN);\n    IF arg_action = 'create' AND l_slot_exists IS NOT TRUE THEN\n        l_slot_action_query := pg_catalog.format('SELECT TRUE FROM pg_catalog.pg_create_logical_replication_slot(%L, %L, FALSE)', arg_slot_name, 'pgoutput');\n    ELSIF arg_action = 'drop' AND l_slot_exists IS TRUE THEN\n        l_slot_action_query := pg_catalog.format('SELECT TRUE FROM pg_catalog.pg_drop_replication_slot(%L)', arg_slot_name);\n    END IF;\n    IF l_slot_action_query IS NOT NULL THEN\n        PERFORM 1\n            FROM aiven_extras.dblink_record_execute(\n                    arg_connection_string,\n                    l_clear_search_path || l_slot_action_query\n                ) AS d (res BOOLEAN);\n    END IF;\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_subscription(TEXT, TEXT, TEXT, TEXT, BOOLEAN, BOOLEAN);\nCREATE FUNCTION aiven_extras.pg_create_subscription(\n    arg_subscription_name TEXT,\n    arg_connection_string TEXT,\n    arg_publication_name TEXT,\n    arg_slot_name TEXT,\n    arg_slot_create BOOLEAN = FALSE,\n    arg_copy_data BOOLEAN = TRUE\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    IF (arg_slot_create IS TRUE) THEN\n        PERFORM aiven_extras.dblink_slot_create_or_drop(arg_connection_string, arg_slot_name, 'create');\n    END IF;\n    EXECUTE pg_catalog.format(\n        'CREATE SUBSCRIPTION %I connection %L publication %I WITH (slot_name=%L, create_slot=FALSE, copy_data=%s)',\n        arg_subscription_name, arg_connection_string, arg_publication_name, arg_slot_name, arg_copy_data::TEXT);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_alter_subscription_disable(TEXT);\nCREATE FUNCTION aiven_extras.pg_alter_subscription_disable(\n    arg_subscription_name TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I DISABLE', arg_subscription_name);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_alter_subscription_enable(TEXT);\nCREATE FUNCTION aiven_extras.pg_alter_subscription_enable(\n    arg_subscription_name TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I ENABLE', arg_subscription_name);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_alter_subscription_refresh_publication(TEXT, BOOLEAN);\nCREATE FUNCTION aiven_extras.pg_alter_subscription_refresh_publication(\n    arg_subscription_name TEXT,\n    arg_copy_data BOOLEAN = TRUE\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    PERFORM aiven_extras.dblink_record_execute(\n        pg_catalog.format('user=%L dbname=%L port=%L', current_user, pg_catalog.current_database(), (SELECT setting FROM pg_catalog.pg_settings WHERE name = 'port')),\n        pg_catalog.format('ALTER SUBSCRIPTION %I REFRESH PUBLICATION WITH (copy_data=%s)', arg_subscription_name, arg_copy_data::TEXT)\n    );\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_drop_subscription(TEXT);\nCREATE FUNCTION aiven_extras.pg_drop_subscription(\n    arg_subscription_name TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nDECLARE\n    l_slot_name TEXT;\n    l_subconninfo TEXT;\nBEGIN\n    SELECT subslotname, subconninfo\n        INTO l_slot_name, l_subconninfo\n        FROM pg_catalog.pg_subscription\n        WHERE subname = arg_subscription_name;\n    IF l_slot_name IS NULL AND l_subconninfo IS NULL THEN\n        RAISE EXCEPTION 'No subscription found for name: %', arg_subscription_name;\n    END IF;\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I DISABLE', arg_subscription_name);\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I SET (slot_name = NONE)', arg_subscription_name);\n    EXECUTE pg_catalog.format('DROP SUBSCRIPTION %I', arg_subscription_name);\n    PERFORM aiven_extras.dblink_slot_create_or_drop(l_subconninfo, l_slot_name, 'drop');\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_publication_for_all_tables(TEXT, TEXT);\nCREATE FUNCTION aiven_extras.pg_create_publication_for_all_tables(\n    arg_publication_name TEXT,\n    arg_publish TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('CREATE PUBLICATION %I FOR ALL TABLES WITH (publish = %I)', arg_publication_name, arg_publish);\n    EXECUTE pg_catalog.format('ALTER PUBLICATION %I OWNER TO %I', arg_publication_name, session_user);\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_list_all_subscriptions();\nCREATE FUNCTION aiven_extras.pg_list_all_subscriptions()\nRETURNS SETOF aiven_extras.aiven_pg_subscription LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN QUERY\n        SELECT subdbid, subname, subowner, subenabled, subconninfo, subslotname, subsynccommit, subpublications\n            FROM pg_catalog.pg_subscription;\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.session_replication_role(TEXT);\nCREATE FUNCTION aiven_extras.session_replication_role(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('session_replication_role', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.auto_explain_load();\nCREATE FUNCTION aiven_extras.auto_explain_load()\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    LOAD 'auto_explain';\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_analyze(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_analyze(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_analyze', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_format(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_format(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_format', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_min_duration(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_min_duration(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_min_duration', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_timing(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_timing(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_timing', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_buffers(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_buffers(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_buffers', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_verbose(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_verbose(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_verbose', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_nested_statements(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_nested_statements(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_nested_statements', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.claim_public_schema_ownership();\nCREATE FUNCTION aiven_extras.claim_public_schema_ownership()\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('ALTER SCHEMA public OWNER TO %I', session_user);\nEND;\n$$;\n\n\n-- Temporarily clear out the view so we can replace the function behind it\nCREATE OR REPLACE VIEW aiven_extras.pg_stat_replication AS\n    SELECT\n        NULL::INT AS pid,\n        NULL::OID AS usesysid,\n        NULL::NAME AS usename,\n        NULL::TEXT AS application_name,\n        NULL::INET AS client_addr,\n        NULL::TEXT AS client_hostname,\n        NULL::INT AS client_port,\n        NULL::TIMESTAMPTZ AS backend_start,\n        NULL::XID AS backend_xmin,\n        NULL::TEXT AS state,\n        NULL::PG_LSN AS sent_lsn,\n        NULL::PG_LSN AS write_lsn,\n        NULL::PG_LSN AS flush_lsn,\n        NULL::PG_LSN AS replay_lsn,\n        NULL::INTERVAL AS write_lag,\n        NULL::INTERVAL AS flush_lag,\n        NULL::INTERVAL AS replay_lag,\n        NULL::INTEGER AS sync_priority,\n        NULL::TEXT AS sync_state;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_stat_replication_list();\nCREATE FUNCTION aiven_extras.pg_stat_replication_list()\nRETURNS SETOF aiven_extras.aiven_pg_stat_replication LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN QUERY\n        SELECT  pid, usesysid, usename, application_name, client_addr, client_hostname, client_port,\n                backend_start, backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag,\n                flush_lag, replay_lag, sync_priority, sync_state\n            FROM pg_catalog.pg_stat_replication\n            WHERE usename = session_user;\nEND;\n$$;\n\n\nCREATE OR REPLACE VIEW aiven_extras.pg_stat_replication AS\n        SELECT  pid, usesysid, usename, application_name, client_addr, client_hostname, client_port,\n                backend_start, backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag,\n                flush_lag, replay_lag, sync_priority, sync_state\n            FROM aiven_extras.pg_stat_replication_list();\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_publication(TEXT, TEXT, VARIADIC TEXT[]);\nCREATE FUNCTION aiven_extras.pg_create_publication(\n    arg_publication_name TEXT,\n    arg_publish TEXT,\n    VARIADIC arg_tables TEXT[] DEFAULT ARRAY[]::TEXT[]\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nDECLARE\n  l_ident TEXT;\n  l_table_count INT;\n  l_tables_command TEXT;\n  l_parsed_ident TEXT[];\n  l_parsed_arg_tables TEXT[];\nBEGIN\n    l_table_count = array_length(arg_tables, 1);\n    IF l_table_count >= 1\n    THEN\n        l_parsed_arg_tables = ARRAY[]::TEXT[];\n        l_tables_command = 'CREATE PUBLICATION %I FOR TABLE ';\n        FOREACH l_ident IN ARRAY arg_tables LOOP\n            l_parsed_ident = parse_ident(l_ident);\n            ASSERT array_length(l_parsed_ident, 1) <= 2, 'Only simple table names or tables qualified with schema names allowed';\n            -- Make sure we pass in a simple list of identifiers, so separate the tables from parent schemas\n            IF array_length(l_parsed_ident, 1) = 2\n            THEN\n                l_tables_command = l_tables_command || '%I.%I, ';\n            ELSE\n                l_tables_command = l_tables_command || '%I, ';\n            END IF;\n            l_parsed_arg_tables = l_parsed_arg_tables || l_parsed_ident;\n        END LOOP;\n        -- Remove trailing comma and whitespace, add the rest\n        l_tables_command = left(l_tables_command, -2) || ' WITH (publish = %I)';\n        EXECUTE format(l_tables_command, VARIADIC array[arg_publication_name] || l_parsed_arg_tables || arg_publish);\n    ELSE\n        EXECUTE format('CREATE PUBLICATION %I WITH (publish = %I)', arg_publication_name, arg_publish);\n    END IF;\n    EXECUTE format('ALTER PUBLICATION %I OWNER TO %I', arg_publication_name, session_user);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_pgaudit_parameter(TEXT, TEXT, TEXT);\nCREATE FUNCTION aiven_extras.set_pgaudit_parameter(\n    arg_parameter TEXT,\n    arg_database TEXT,\n    arg_value TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    IF COALESCE(\n        (SELECT usesuper\n            FROM pg_catalog.pg_database d\n                JOIN pg_catalog.pg_user u\n                    ON (u.usesysid = d.datdba)\n                WHERE d.datname = arg_database\n                LIMIT 1\n        ),\n        TRUE\n    ) THEN\n        RAISE EXCEPTION 'Invalid database: %', arg_database;\n    ELSIF arg_parameter NOT IN (\n        'log',\n        'log_catalog',\n        'log_max_string_length',\n        'log_nested_statements',\n        'log_parameter',\n        'log_relation',\n        'log_statement',\n        'log_statement_once'\n    ) THEN\n        RAISE EXCEPTION 'Invalid parameter: %', arg_parameter;\n    END IF;\n\n    EXECUTE format('ALTER DATABASE %I SET pgaudit.%I = %L',\n        arg_database,\n        arg_parameter,\n        arg_value\n    );\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.set_pgaudit_role_parameter(TEXT, TEXT, TEXT);\nCREATE FUNCTION aiven_extras.set_pgaudit_role_parameter(\n    arg_parameter TEXT,\n    arg_role TEXT,\n    arg_value TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    IF COALESCE(\n        (SELECT rolsuper\n            FROM pg_catalog.pg_roles\n                WHERE rolname = arg_role\n                LIMIT 1\n        ),\n        FALSE\n    ) THEN\n        RAISE EXCEPTION 'Configuring superuser roles not allowed: %', arg_role;\n    ELSIF arg_parameter NOT IN (\n        'log',\n        'log_catalog',\n        'log_max_string_length',\n        'log_nested_statements',\n        'log_parameter',\n        'log_relation',\n        'log_statement',\n        'log_statement_once'\n    ) THEN\n        RAISE EXCEPTION 'Invalid parameter: %', arg_parameter;\n    END IF;\n\n    EXECUTE format('ALTER ROLE %I SET pgaudit.%I = %L',\n        arg_role,\n        arg_parameter,\n        arg_value\n    );\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.explain_statement(TEXT);\nCREATE FUNCTION aiven_extras.explain_statement(\n    arg_query TEXT,\n    OUT execution_plan JSON\n)\nRETURNS SETOF JSON\nRETURNS NULL ON NULL INPUT\nLANGUAGE plpgsql\n-- This is needed because otherwise the executing user would need to have the\n-- SELECT privilege on all tables that are part of the plan.\nSECURITY DEFINER\n-- We don't want to force users to change statements (e.g. schema-prefix all\n-- tables in the query), so this intentionally does not specifiy a search_path.\n-- Still, this will not help with users having custom search paths.\nAS $$\nDECLARE\n    curs REFCURSOR;\n    plan JSON;\nBEGIN\n    OPEN curs FOR EXECUTE pg_catalog.concat('EXPLAIN (FORMAT JSON) ', arg_query);\n    FETCH curs INTO plan;\n    CLOSE curs;\n    RETURN QUERY SELECT plan;\nEND;\n$$;\n\n\n-- THIS LINE ALWAYS NEEDS TO BE EXECUTED LAST IN FILE\nPERFORM pg_catalog.set_config('search_path', old_path, true);\n-- NO MORE CODE AFTER THIS\n\nEND;\n$OUTER$;\n\n-- standby slots functions\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_logical_replication_slot_on_standby(name, name, boolean, boolean);\nCREATE FUNCTION aiven_extras.pg_create_logical_replication_slot_on_standby(\n\tslot_name name,\n\tplugin name,\n\ttemporary boolean DEFAULT false,\n\ttwophase boolean DEFAULT false,\n\tOUT slot_name name, OUT lsn pg_lsn)\nAS 'MODULE_PATHNAME', 'standby_slot_create'\nLANGUAGE C;\n"], "fixing_code": ["DO LANGUAGE plpgsql\n$OUTER$\nDECLARE\n    my_schema pg_catalog.TEXT := pg_catalog.quote_ident(pg_catalog.current_schema());\n    old_path pg_catalog.TEXT := pg_catalog.current_setting('search_path');\nBEGIN\n\n-- for safety, transiently set search_path to just pg_catalog+pg_temp\nPERFORM pg_catalog.set_config('search_path', 'pg_catalog, pg_temp', true);\n\n\nPERFORM 1\n    FROM pg_catalog.pg_type AS t JOIN pg_catalog.pg_roles AS r ON (r.oid = t.typowner)\n    WHERE r.rolsuper\n        AND t.typnamespace = 'aiven_extras'::regnamespace\n        AND t.typname = 'aiven_pg_subscription';\nIF NOT FOUND THEN\n    CREATE TYPE aiven_extras.aiven_pg_subscription AS (\n        subdbid OID,\n        subname NAME,\n        subowner OID,\n        subenabled BOOLEAN,\n        subconninfo TEXT,\n        subslotname NAME,\n        subsynccommit TEXT,\n        subpublications TEXT[]\n    );\nEND IF;\n\nPERFORM 1\n    FROM pg_catalog.pg_type AS t JOIN pg_catalog.pg_roles AS r ON (r.oid = t.typowner)\n    WHERE r.rolsuper\n        AND typnamespace = 'aiven_extras'::regnamespace\n        AND typname = 'aiven_pg_stat_replication';\nIF NOT FOUND THEN\n    CREATE TYPE aiven_extras.aiven_pg_stat_replication AS (\n        pid INT,\n        usesysid OID,\n        usename NAME,\n        application_name TEXT,\n        client_addr INET,\n        client_hostname TEXT,\n        client_port INT,\n        backend_start TIMESTAMP WITH TIME ZONE,\n        backend_xmin XID,\n        state TEXT,\n        sent_lsn PG_LSN,\n        write_lsn PG_LSN,\n        flush_lsn PG_LSN,\n        replay_lsn PG_LSN,\n        write_lag INTERVAL,\n        flush_lag INTERVAL,\n        replay_lag INTERVAL,\n        sync_priority INTEGER,\n        sync_state TEXT\n    );\nEND IF;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.dblink_record_execute(TEXT, TEXT);\nCREATE FUNCTION aiven_extras.dblink_record_execute(TEXT, TEXT)\nRETURNS SETOF record LANGUAGE c\nPARALLEL RESTRICTED STRICT\nAS '$libdir/dblink', $$dblink_record$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.dblink_slot_create_or_drop(TEXT, TEXT, TEXT);\nCREATE FUNCTION aiven_extras.dblink_slot_create_or_drop(\n    arg_connection_string TEXT,\n    arg_slot_name TEXT,\n    arg_action TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSET search_path = pg_catalog, aiven_extras\nAS $$\nDECLARE\n    l_clear_search_path TEXT := 'SET search_path TO pg_catalog, pg_temp;';\n    l_slot_existence_query TEXT := pg_catalog.format('SELECT TRUE FROM pg_catalog.pg_replication_slots WHERE slot_name OPERATOR(pg_catalog.=) %L', arg_slot_name);\n    l_slot_action_query TEXT;\n    l_slot_exists BOOLEAN;\nBEGIN\n    SELECT res INTO l_slot_exists\n        FROM aiven_extras.dblink_record_execute(\n                arg_connection_string,\n                l_clear_search_path || l_slot_existence_query\n            ) AS d (res BOOLEAN);\n    IF arg_action = 'create' AND l_slot_exists IS NOT TRUE THEN\n        l_slot_action_query := pg_catalog.format('SELECT TRUE FROM pg_catalog.pg_create_logical_replication_slot(%L, %L, FALSE)', arg_slot_name, 'pgoutput');\n    ELSIF arg_action = 'drop' AND l_slot_exists IS TRUE THEN\n        l_slot_action_query := pg_catalog.format('SELECT TRUE FROM pg_catalog.pg_drop_replication_slot(%L)', arg_slot_name);\n    END IF;\n    IF l_slot_action_query IS NOT NULL THEN\n        PERFORM 1\n            FROM aiven_extras.dblink_record_execute(\n                    arg_connection_string,\n                    l_clear_search_path || l_slot_action_query\n                ) AS d (res BOOLEAN);\n    END IF;\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_subscription(TEXT, TEXT, TEXT, TEXT, BOOLEAN, BOOLEAN);\nCREATE FUNCTION aiven_extras.pg_create_subscription(\n    arg_subscription_name TEXT,\n    arg_connection_string TEXT,\n    arg_publication_name TEXT,\n    arg_slot_name TEXT,\n    arg_slot_create BOOLEAN = FALSE,\n    arg_copy_data BOOLEAN = TRUE\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    IF (arg_slot_create IS TRUE) THEN\n        PERFORM aiven_extras.dblink_slot_create_or_drop(arg_connection_string, arg_slot_name, 'create');\n    END IF;\n    EXECUTE pg_catalog.format(\n        'CREATE SUBSCRIPTION %I connection %L publication %I WITH (slot_name=%L, create_slot=FALSE, copy_data=%s)',\n        arg_subscription_name, arg_connection_string, arg_publication_name, arg_slot_name, arg_copy_data::TEXT);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_alter_subscription_disable(TEXT);\nCREATE FUNCTION aiven_extras.pg_alter_subscription_disable(\n    arg_subscription_name TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I DISABLE', arg_subscription_name);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_alter_subscription_enable(TEXT);\nCREATE FUNCTION aiven_extras.pg_alter_subscription_enable(\n    arg_subscription_name TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I ENABLE', arg_subscription_name);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_alter_subscription_refresh_publication(TEXT, BOOLEAN);\nCREATE FUNCTION aiven_extras.pg_alter_subscription_refresh_publication(\n    arg_subscription_name TEXT,\n    arg_copy_data BOOLEAN = TRUE\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    PERFORM aiven_extras.dblink_record_execute(\n        pg_catalog.format('user=%L dbname=%L port=%L', current_user, pg_catalog.current_database(), (SELECT setting FROM pg_catalog.pg_settings WHERE name = 'port')),\n        pg_catalog.format('ALTER SUBSCRIPTION %I REFRESH PUBLICATION WITH (copy_data=%s)', arg_subscription_name, arg_copy_data::TEXT)\n    );\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_drop_subscription(TEXT);\nCREATE FUNCTION aiven_extras.pg_drop_subscription(\n    arg_subscription_name TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nDECLARE\n    l_slot_name TEXT;\n    l_subconninfo TEXT;\nBEGIN\n    SELECT subslotname, subconninfo\n        INTO l_slot_name, l_subconninfo\n        FROM pg_catalog.pg_subscription\n        WHERE subname = arg_subscription_name;\n    IF l_slot_name IS NULL AND l_subconninfo IS NULL THEN\n        RAISE EXCEPTION 'No subscription found for name: %', arg_subscription_name;\n    END IF;\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I DISABLE', arg_subscription_name);\n    EXECUTE pg_catalog.format('ALTER SUBSCRIPTION %I SET (slot_name = NONE)', arg_subscription_name);\n    EXECUTE pg_catalog.format('DROP SUBSCRIPTION %I', arg_subscription_name);\n    PERFORM aiven_extras.dblink_slot_create_or_drop(l_subconninfo, l_slot_name, 'drop');\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_publication_for_all_tables(TEXT, TEXT);\nCREATE FUNCTION aiven_extras.pg_create_publication_for_all_tables(\n    arg_publication_name TEXT,\n    arg_publish TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('CREATE PUBLICATION %I FOR ALL TABLES WITH (publish = %I)', arg_publication_name, arg_publish);\n    EXECUTE pg_catalog.format('ALTER PUBLICATION %I OWNER TO %I', arg_publication_name, session_user);\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_list_all_subscriptions();\nCREATE FUNCTION aiven_extras.pg_list_all_subscriptions()\nRETURNS SETOF aiven_extras.aiven_pg_subscription LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN QUERY\n        SELECT subdbid, subname, subowner, subenabled, subconninfo, subslotname, subsynccommit, subpublications\n            FROM pg_catalog.pg_subscription;\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.session_replication_role(TEXT);\nCREATE FUNCTION aiven_extras.session_replication_role(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('session_replication_role', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.auto_explain_load();\nCREATE FUNCTION aiven_extras.auto_explain_load()\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    LOAD 'auto_explain';\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_analyze(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_analyze(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_analyze', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_format(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_format(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_format', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_min_duration(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_min_duration(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_min_duration', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_timing(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_timing(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_timing', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_buffers(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_buffers(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_buffers', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_verbose(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_verbose(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_verbose', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_auto_explain_log_nested_statements(TEXT);\nCREATE FUNCTION aiven_extras.set_auto_explain_log_nested_statements(\n    arg_parameter TEXT\n)\nRETURNS TEXT LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN pg_catalog.set_config('auto_explain.log_nested_statements', arg_parameter, false);\nEND\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.claim_public_schema_ownership();\nCREATE FUNCTION aiven_extras.claim_public_schema_ownership()\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    EXECUTE pg_catalog.format('ALTER SCHEMA public OWNER TO %I', session_user);\nEND;\n$$;\n\n\n-- Temporarily clear out the view so we can replace the function behind it\nCREATE OR REPLACE VIEW aiven_extras.pg_stat_replication AS\n    SELECT\n        NULL::INT AS pid,\n        NULL::OID AS usesysid,\n        NULL::NAME AS usename,\n        NULL::TEXT AS application_name,\n        NULL::INET AS client_addr,\n        NULL::TEXT AS client_hostname,\n        NULL::INT AS client_port,\n        NULL::TIMESTAMPTZ AS backend_start,\n        NULL::XID AS backend_xmin,\n        NULL::TEXT AS state,\n        NULL::PG_LSN AS sent_lsn,\n        NULL::PG_LSN AS write_lsn,\n        NULL::PG_LSN AS flush_lsn,\n        NULL::PG_LSN AS replay_lsn,\n        NULL::INTERVAL AS write_lag,\n        NULL::INTERVAL AS flush_lag,\n        NULL::INTERVAL AS replay_lag,\n        NULL::INTEGER AS sync_priority,\n        NULL::TEXT AS sync_state;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_stat_replication_list();\nCREATE FUNCTION aiven_extras.pg_stat_replication_list()\nRETURNS SETOF aiven_extras.aiven_pg_stat_replication LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    RETURN QUERY\n        SELECT  pid, usesysid, usename, application_name, client_addr, client_hostname, client_port,\n                backend_start, backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag,\n                flush_lag, replay_lag, sync_priority, sync_state\n            FROM pg_catalog.pg_stat_replication\n            WHERE usename = session_user;\nEND;\n$$;\n\n\nCREATE OR REPLACE VIEW aiven_extras.pg_stat_replication AS\n        SELECT  pid, usesysid, usename, application_name, client_addr, client_hostname, client_port,\n                backend_start, backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag,\n                flush_lag, replay_lag, sync_priority, sync_state\n            FROM aiven_extras.pg_stat_replication_list();\n\n\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_publication(TEXT, TEXT, VARIADIC TEXT[]);\nCREATE FUNCTION aiven_extras.pg_create_publication(\n    arg_publication_name TEXT,\n    arg_publish TEXT,\n    VARIADIC arg_tables TEXT[] DEFAULT ARRAY[]::TEXT[]\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nDECLARE\n  l_ident TEXT;\n  l_table_count INT;\n  l_tables_command TEXT;\n  l_parsed_ident TEXT[];\n  l_parsed_arg_tables TEXT[];\nBEGIN\n    l_table_count = pg_catalog.array_length(arg_tables, 1);\n    IF l_table_count >= 1\n    THEN\n        l_parsed_arg_tables = ARRAY[]::TEXT[];\n        l_tables_command = 'CREATE PUBLICATION %I FOR TABLE ';\n        FOREACH l_ident IN ARRAY arg_tables LOOP\n            l_parsed_ident = parse_ident(l_ident);\n            ASSERT pg_catalog.array_length(l_parsed_ident, 1) <= 2, 'Only simple table names or tables qualified with schema names allowed';\n            -- Make sure we pass in a simple list of identifiers, so separate the tables from parent schemas\n            IF pg_catalog.array_length(l_parsed_ident, 1) = 2\n            THEN\n                l_tables_command = l_tables_command || '%I.%I, ';\n            ELSE\n                l_tables_command = l_tables_command || '%I, ';\n            END IF;\n            l_parsed_arg_tables = l_parsed_arg_tables || l_parsed_ident;\n        END LOOP;\n        -- Remove trailing comma and whitespace, add the rest\n        l_tables_command = pg_catalog.left(l_tables_command, -2) || ' WITH (publish = %I)';\n        EXECUTE pg_catalog.format(l_tables_command, VARIADIC array[arg_publication_name] || l_parsed_arg_tables || arg_publish);\n    ELSE\n        EXECUTE pg_catalog.format('CREATE PUBLICATION %I WITH (publish = %I)', arg_publication_name, arg_publish);\n    END IF;\n    EXECUTE pg_catalog.format('ALTER PUBLICATION %I OWNER TO %I', arg_publication_name, session_user);\nEND;\n$$;\n\n\nDROP FUNCTION IF EXISTS aiven_extras.set_pgaudit_parameter(TEXT, TEXT, TEXT);\nCREATE FUNCTION aiven_extras.set_pgaudit_parameter(\n    arg_parameter TEXT,\n    arg_database TEXT,\n    arg_value TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    IF COALESCE(\n        (SELECT usesuper\n            FROM pg_catalog.pg_database d\n                JOIN pg_catalog.pg_user u\n                    ON (u.usesysid = d.datdba)\n                WHERE d.datname = arg_database\n                LIMIT 1\n        ),\n        TRUE\n    ) THEN\n        RAISE EXCEPTION 'Invalid database: %', arg_database;\n    ELSIF arg_parameter NOT IN (\n        'log',\n        'log_catalog',\n        'log_max_string_length',\n        'log_nested_statements',\n        'log_parameter',\n        'log_relation',\n        'log_statement',\n        'log_statement_once'\n    ) THEN\n        RAISE EXCEPTION 'Invalid parameter: %', arg_parameter;\n    END IF;\n\n    EXECUTE pg_catalog.format('ALTER DATABASE %I SET pgaudit.%I = %L',\n        arg_database,\n        arg_parameter,\n        arg_value\n    );\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.set_pgaudit_role_parameter(TEXT, TEXT, TEXT);\nCREATE FUNCTION aiven_extras.set_pgaudit_role_parameter(\n    arg_parameter TEXT,\n    arg_role TEXT,\n    arg_value TEXT\n)\nRETURNS VOID LANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = pg_catalog, aiven_extras\nAS $$\nBEGIN\n    IF COALESCE(\n        (SELECT rolsuper\n            FROM pg_catalog.pg_roles\n                WHERE rolname = arg_role\n                LIMIT 1\n        ),\n        FALSE\n    ) THEN\n        RAISE EXCEPTION 'Configuring superuser roles not allowed: %', arg_role;\n    ELSIF arg_parameter NOT IN (\n        'log',\n        'log_catalog',\n        'log_max_string_length',\n        'log_nested_statements',\n        'log_parameter',\n        'log_relation',\n        'log_statement',\n        'log_statement_once'\n    ) THEN\n        RAISE EXCEPTION 'Invalid parameter: %', arg_parameter;\n    END IF;\n\n    EXECUTE format('ALTER ROLE %I SET pgaudit.%I = %L',\n        arg_role,\n        arg_parameter,\n        arg_value\n    );\nEND;\n$$;\n\nDROP FUNCTION IF EXISTS aiven_extras.explain_statement(TEXT);\nCREATE FUNCTION aiven_extras.explain_statement(\n    arg_query TEXT,\n    OUT execution_plan JSON\n)\nRETURNS SETOF JSON\nRETURNS NULL ON NULL INPUT\nLANGUAGE plpgsql\n-- This is needed because otherwise the executing user would need to have the\n-- SELECT privilege on all tables that are part of the plan.\nSECURITY DEFINER\n-- We don't want to force users to change statements (e.g. schema-prefix all\n-- tables in the query), so this intentionally does not specifiy a search_path.\n-- Still, this will not help with users having custom search paths.\nAS $$\nDECLARE\n    curs REFCURSOR;\n    plan JSON;\nBEGIN\n    OPEN curs FOR EXECUTE pg_catalog.concat('EXPLAIN (FORMAT JSON) ', arg_query);\n    FETCH curs INTO plan;\n    CLOSE curs;\n    RETURN QUERY SELECT plan;\nEND;\n$$;\n\n\n-- THIS LINE ALWAYS NEEDS TO BE EXECUTED LAST IN FILE\nPERFORM pg_catalog.set_config('search_path', old_path, true);\n-- NO MORE CODE AFTER THIS\n\nEND;\n$OUTER$;\n\n-- standby slots functions\nDROP FUNCTION IF EXISTS aiven_extras.pg_create_logical_replication_slot_on_standby(name, name, boolean, boolean);\nCREATE FUNCTION aiven_extras.pg_create_logical_replication_slot_on_standby(\n\tslot_name name,\n\tplugin name,\n\ttemporary boolean DEFAULT false,\n\ttwophase boolean DEFAULT false,\n\tOUT slot_name name, OUT lsn pg_lsn)\nAS 'MODULE_PATHNAME', 'standby_slot_create'\nLANGUAGE C;\n"], "filenames": ["sql/aiven_extras.sql"], "buggy_code_start_loc": [429], "buggy_code_end_loc": [493], "fixing_code_start_loc": [429], "fixing_code_end_loc": [493], "type": "NVD-CWE-noinfo", "message": "aiven-extras is a PostgreSQL extension. Versions prior to 1.1.9 contain a privilege escalation vulnerability, allowing elevation to superuser inside PostgreSQL databases that use the aiven-extras package. The vulnerability leverages missing schema qualifiers on privileged functions called by the aiven-extras extension. A low privileged user can create objects that collide with existing function names, which will then be executed instead. Exploiting this vulnerability could allow a low privileged user to acquire `superuser` privileges, which would allow full, unrestricted access to all data and database functions. And could lead to arbitrary code execution or data access on the underlying host as the `postgres` user. The issue has been patched as of version 1.1.9.", "other": {"cve": {"id": "CVE-2023-32305", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-12T19:15:08.953", "lastModified": "2023-05-24T16:45:51.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "aiven-extras is a PostgreSQL extension. Versions prior to 1.1.9 contain a privilege escalation vulnerability, allowing elevation to superuser inside PostgreSQL databases that use the aiven-extras package. The vulnerability leverages missing schema qualifiers on privileged functions called by the aiven-extras extension. A low privileged user can create objects that collide with existing function names, which will then be executed instead. Exploiting this vulnerability could allow a low privileged user to acquire `superuser` privileges, which would allow full, unrestricted access to all data and database functions. And could lead to arbitrary code execution or data access on the underlying host as the `postgres` user. The issue has been patched as of version 1.1.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}, {"lang": "en", "value": "CWE-20"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aiven:aiven:*:*:*:*:*:postgresql:*:*", "versionEndExcluding": "1.1.9", "matchCriteriaId": "4C80E215-A1D4-4455-ABB1-5B9E627B4C82"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0", "versionEndIncluding": "10.22", "matchCriteriaId": "97CCDA2D-D4C8-49E0-924E-2203FC301E71"}, {"vulnerable": false, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndIncluding": "11.7", "matchCriteriaId": "C4E7FCB3-F4AA-47A9-832B-C58FDA1D5523"}, {"vulnerable": false, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndIncluding": "12.12", "matchCriteriaId": "18E1D01F-9DC6-4251-B3EB-879B270991B5"}, {"vulnerable": false, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0", "versionEndIncluding": "13.8", "matchCriteriaId": "F7C1778A-5CB2-4EFF-9F72-B889449CFD07"}, {"vulnerable": false, "criteria": "cpe:2.3:a:postgresql:postgresql:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0", "versionEndIncluding": "14.5", "matchCriteriaId": "355CFA07-D6D1-4E9C-94ED-CBC9560E593B"}]}]}], "references": [{"url": "https://github.com/aiven/aiven-extras/commit/8682ae01bec0791708bf25791786d776e2fb0250", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/aiven/aiven-extras/security/advisories/GHSA-7r4w-fw4h-67gp", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/aiven/aiven-extras/commit/8682ae01bec0791708bf25791786d776e2fb0250"}}