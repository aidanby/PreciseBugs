{"buggy_code": ["/*******************************************************************************\n * Agere Systems Inc.\n * Wireless device driver for Linux (wlags49).\n *\n * Copyright (c) 1998-2003 Agere Systems Inc.\n * All rights reserved.\n *   http://www.agere.com\n *\n * Initially developed by TriplePoint, Inc.\n *   http://www.triplepoint.com\n *\n *------------------------------------------------------------------------------\n *\n *   This file defines handling routines for the private IOCTLs\n *\n *------------------------------------------------------------------------------\n *\n * SOFTWARE LICENSE\n *\n * This software is provided subject to the following terms and conditions,\n * which you should read carefully before using the software.  Using this\n * software indicates your acceptance of these terms and conditions.  If you do\n * not agree with these terms and conditions, do not use the software.\n *\n * Copyright \u00a9 2003 Agere Systems Inc.\n * All rights reserved.\n *\n * Redistribution and use in source or binary forms, with or without\n * modifications, are permitted provided that the following conditions are met:\n *\n * . Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following Disclaimer as comments in the code as\n *    well as in the documentation and/or other materials provided with the\n *    distribution.\n *\n * . Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following Disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * . Neither the name of Agere Systems Inc. nor the names of the contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Disclaimer\n *\n * THIS SOFTWARE IS PROVIDED \u0093AS IS\u0094 AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY\n * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN\n * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n ******************************************************************************/\n\n/*******************************************************************************\n * include files\n ******************************************************************************/\n#include <wl_version.h>\n\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n\n#include <debug.h>\n#include <hcf.h>\n#include <hcfdef.h>\n\n#include <wl_if.h>\n#include <wl_internal.h>\n#include <wl_enc.h>\n#include <wl_main.h>\n#include <wl_priv.h>\n#include <wl_util.h>\n#include <wl_netdev.h>\n\nint wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_action(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_block(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp);\n\nint cfg_driver_info(struct uilreq *urq, struct wl_private *lp);\nint cfg_driver_identity(struct uilreq *urq, struct wl_private *lp);\n\n\n/*******************************************************************************\n * global variables\n ******************************************************************************/\n#if DBG\nextern dbg_info_t *DbgInfo;\n#endif  /* DBG */\n\n\n\n\n/* If USE_UIL is not defined, then none of the UIL Interface code below will\n   be included in the build */\n#ifdef USE_UIL\n\n/*******************************************************************************\n *\twvlan_uil()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      The handler function for the UIL interface.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_uil(struct uilreq *urq, struct wl_private *lp)\n{\n\tint ioctl_ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\tDBG_FUNC(\"wvlan_uil\");\n\tDBG_ENTER(DbgInfo);\n\n\tswitch (urq->command) {\n\tcase UIL_FUN_CONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_CONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_connect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_DISCONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_DISCONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_disconnect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_ACTION:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\\n\");\n\t\tioctl_ret = wvlan_uil_action(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_SEND_DIAG_MSG:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_SEND_DIAG_MSG\\n\");\n\t\tioctl_ret = wvlan_uil_send_diag_msg(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_GET_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_GET_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_get_info(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_PUT_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_PUT_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_put_info(urq, lp);\n\t\tbreak;\n\tdefault:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X\", urq->command);\n\t\tioctl_ret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tDBG_LEAVE(DbgInfo);\n\treturn ioctl_ret;\n} /* wvlan_uil */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_connect()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Connect to the UIL in order to make a request.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_connect\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (!(lp->flags & WVLAN2_UIL_CONNECTED)) {\n\t\tlp->flags |= WVLAN2_UIL_CONNECTED;\n\t\turq->hcfCtx = &(lp->hcfCtx);\n\t\turq->result = UIL_SUCCESS;\n\t} else {\n\t\tDBG_WARNING(DbgInfo, \"UIL_ERR_IN_USE\\n\");\n\t\turq->result = UIL_ERR_IN_USE;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_connect */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_disconnect()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Disconnect from the UIL after a request has been completed.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_disconnect\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (lp->flags & WVLAN2_UIL_CONNECTED) {\n\t\t\tlp->flags &= ~WVLAN2_UIL_CONNECTED;\n\t\t\t/*\n\t\t\tif (lp->flags & WVLAN2_UIL_BUSY) {\n\t\t\t\tlp->flags &= ~WVLAN2_UIL_BUSY;\n\t\t\t\tnetif_start_queue(lp->dev);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\turq->hcfCtx = NULL;\n\t\turq->result = UIL_SUCCESS;\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_disconnect */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_action()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Handler for the UIL_ACT_xxx subcodes associated with UIL_FUN_ACTION\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_action(struct uilreq *urq, struct wl_private *lp)\n{\n\tint     result = 0;\n\tltv_t   *ltv;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_action\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\t/* Make sure there's an LTV in the request buffer */\n\t\tltv = (ltv_t *)urq->data;\n\t\tif (ltv != NULL) {\n\t\t\t/* Switch on the Type field of the LTV contained in the request\n\t\t\t   buffer */\n\t\t\tswitch (ltv->typ) {\n\t\t\tcase UIL_ACT_BLOCK:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_BLOCK\\n\");\n\t\t\t\tresult = wvlan_uil_block(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_UNBLOCK:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_UNBLOCK\\n\");\n\t\t\t\tresult = wvlan_uil_unblock(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_SCAN:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_SCAN\\n\");\n\t\t\t\turq->result = hcf_action(&(lp->hcfCtx), MDD_ACT_SCAN);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_APPLY:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_APPLY\\n\");\n\t\t\t\turq->result = wl_apply(lp);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_RESET:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_RESET\\n\");\n\t\t\t\turq->result = wl_go(lp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDBG_WARNING(DbgInfo, \"Unknown action code: 0x%x\\n\", ltv->typ);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"Bad LTV for this action\\n\");\n\t\t\turq->result = UIL_ERR_LEN;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_action */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_block()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sets a block in the driver to prevent access to the card by other\n *  processes.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\n\nint wvlan_uil_block(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_block\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tlp->flags |= WVLAN2_UIL_BUSY;\n\t\t\tnetif_stop_queue(lp->dev);\n\t\t\tWL_WDS_NETIF_STOP_QUEUE(lp);\n\t\t\turq->result = UIL_SUCCESS;\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_block */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_unblock()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Unblocks the driver to restore access to the card by other processes.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_unblock\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif (lp->flags & WVLAN2_UIL_BUSY) {\n\t\t\t\tlp->flags &= ~WVLAN2_UIL_BUSY;\n\t\t\t\tnetif_wake_queue(lp->dev);\n\t\t\t\tWL_WDS_NETIF_WAKE_QUEUE(lp);\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_unblock */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_send_diag_msg()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sends a diagnostic message to the card.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp)\n{\n\tint         result = 0;\n\tDESC_STRCT  Descp[1];\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_send_diag_msg\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\tif (lp->hcfCtx.IFB_RscInd != 0) {\n\t\t\t\t\tu_char *data;\n\n\t\t\t\t\t/* Verify the user buffer */\n\t\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\t\tif (result != 0) {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area failed, result: %d\\n\", result);\n\t\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (data != NULL) {\n\t\t\t\t\t\tmemset(Descp, 0, sizeof(DESC_STRCT));\n\t\t\t\t\t\tmemcpy(data, urq->data, urq->len);\n\n\t\t\t\t\t\tDescp[0].buf_addr       = (wci_bufp)data;\n\t\t\t\t\t\tDescp[0].BUF_CNT        = urq->len;\n\t\t\t\t\t\tDescp[0].next_desc_addr = 0;    /* terminate list */\n\n\t\t\t\t\t\thcf_send_msg(&(lp->hcfCtx),  &Descp[0], HCF_PORT_0);\n\t\t\t\t\t\tkfree(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"ENOMEM\\n\");\n\t\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\turq->result = UIL_ERR_BUSY;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_send_diag_msg */\n/*============================================================================*/\n\n\n/*******************************************************************************\n *\twvlan_uil_put_info()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sends a specific RID directly to the driver to set configuration info.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n\n/*============================================================================*/\n\n/*******************************************************************************\n *\twvlan_uil_get_info()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sends a specific RID directly to the driver to retrieve configuration\n *      info.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\tint i;\n\t/*------------------------------------------------------------------------*/\n\n\tDBG_FUNC(\"wvlan_uil_get_info\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\tltv_t      *pLtv;\n\t\t\tbool_t      ltvAllocated = FALSE;\n\n\t\t\t/* Make sure that we have at least a command and length */\n\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t/* Verify the user's LTV record header. */\n\t\t\tresult = verify_area(VERIFY_READ, urq->data, sizeof(hcf_16) * 2);\n\t\t\tif (result != 0) {\n\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t/* Get only the command and length information. */\n\t\t\tresult = copy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t/* Make sure the incoming LTV record length is within the bounds of\n\t\t\t   the IOCTL length. */\n\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\tDBG_ERROR(DbgInfo, \"Incoming LTV too big\\n\");\n\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t/* Determine if hcf_get_info() is needed or not */\n\t\t\tswitch (lp->ltvRecord.typ) {\n\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tmemcpy(&lp->ltvRecord.u.u8[0], &lp->NICIdentity, sizeof(lp->NICIdentity));\n\t\t\t\tbreak;\n\t\t\tcase CFG_PRI_IDENTITY:\n\t\t\t\tmemcpy(&lp->ltvRecord.u.u8[0], &lp->PrimaryIdentity, sizeof(lp->PrimaryIdentity));\n\t\t\t\tbreak;\n\t\t\tcase CFG_AP_MODE:\n\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported, so is get useful ????\\n\");\n\t\t\t\tlp->ltvRecord.u.u16[0] =\n\t\t\t\t\tCNV_INT_TO_LITTLE(lp->hcfCtx.IFB_FWIdentity.comp_id) == COMP_ID_FW_AP;\n\t\t\t\tbreak;\n\t\t\t/* case CFG_DRV_INFO: */\n\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\tcase CFG_COUNTRY_STRING:\n\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t/* TODO: determine if we're going to support these */\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\tbreak;\n\t\t\tcase CFG_DRV_INFO:\n\t\t\t\tDBG_TRACE(DbgInfo, \"Intercept CFG_DRV_INFO\\n\");\n\t\t\t\tresult = cfg_driver_info(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase CFG_DRV_IDENTITY:\n\t\t\t\tDBG_TRACE(DbgInfo, \"Intercept CFG_DRV_IDENTITY\\n\");\n\t\t\t\tresult = cfg_driver_identity(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase CFG_IFB:\n\t\t\t\t/* IFB can be a security hole */\n\t\t\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\t\t\tresult = -EPERM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Else fall through to the default */\n\n\t\t\tcase CFG_FW_IDENTITY:   /* For Hermes-1, this is cached */\n\t\t\tdefault:\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_WRITE, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_WRITE FAILED\\n\");\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\n\t\t\t\t\t\t/* Copy the command/length information into the new buffer. */\n\t\t\t\t\t\tmemcpy(pLtv, &(lp->ltvRecord), sizeof(hcf_16) * 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"kmalloc FAILED\\n\");\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\twl_act_int_off(lp);\n\t\t\t\turq->result = hcf_get_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\twl_act_int_on(lp);\n\n\t\t\t\t/* Copy the LTV into the user's buffer. */\n\t\t\t\t/*copy_to_user(urq->data, pLtv, urq->len); */\n\n\t\t\t\t/*if(ltvAllocated)\n\t\t\t\t{\n\t\t\t\t    kfree(pLtv);\n\t\t\t\t}*/\n\n\t\t\t\t/* urq->result = UIL_SUCCESS; */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Handle endian conversion of special fields */\n\t\t\tswitch (lp->ltvRecord.typ) {\n\t\t\t/* simple int gets just need the first hcf_16 byte flipped */\n\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                          /* Own Beacon Interval */\n\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:                            /* Coexistence Behavior */\n\t\t\t/*case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n#endif /* HERMES25 */\n\t\t\tcase CFG_CREATE_IBSS:\n\t\t\tcase CFG_RTS_THRH:\n\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t/*case CFG_WAKE_ON_LAN: */\n\t\t\tcase CFG_RTS_THRH0:\n\t\t\tcase CFG_RTS_THRH1:\n\t\t\tcase CFG_RTS_THRH2:\n\t\t\tcase CFG_RTS_THRH3:\n\t\t\tcase CFG_RTS_THRH4:\n\t\t\tcase CFG_RTS_THRH5:\n\t\t\tcase CFG_RTS_THRH6:\n\t\t\tcase CFG_TX_RATE_CNTL0:\n\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\tcase CFG_TX_KEY_ID:\n\t\t\tcase CFG_TICK_TIME:\n\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\tcase CFG_PORT_STAT:\n\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\tcase CFG_CF_POLLABLE:\n\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\tcase CFG_PHY_TYPE:\n\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t/* case CFG_CCAMODE: */\n\t\t\t/*     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]); */\n\t\t\t/*     break; */\n\t\t\t/* name string gets just need the first hcf_16 byte flipped (length of string) */\n\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\tcase CFG_DESIRED_SSID:\n\t\t\tcase CFG_SCAN_SSID:\n\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tbreak;\n\t\t\t/* non-length counted strings need no byte flipping */\n\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t/* this case is no longer valid: CFG_CNF_WDS_ADDR */\n\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\tcase CFG_GROUP_ADDR:\n\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\tcase CFG_CUR_BSSID:\n\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\tcase CFG_SUPPORTED_DATA_RATES:  /* need to ensure we can treat this as a string */\n\t\t\t\tbreak;\n\t\t\t/* case CFG_CNF_COUNTRY_INFO: */     /* special case, see page 75  of 022486, Rev C. */\n\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */ /* special case, see page 101 of 022486, Rev C. */\n\t\t\t/*\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\n\n\t\t\t\tfor(i = 4; i < lp->ltvRecord.len; i++) {\n\t\t\t\t\tlp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t*/\n\n\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t{\n\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)&lp->ltvRecord.u.u8[0];\n\n\t\t\t\t\tpKeys[0].len = CNV_INT_TO_LITTLE(pKeys[0].len);\n\t\t\t\t\tpKeys[1].len = CNV_INT_TO_LITTLE(pKeys[1].len);\n\t\t\t\t\tpKeys[2].len = CNV_INT_TO_LITTLE(pKeys[2].len);\n\t\t\t\t\tpKeys[3].len = CNV_INT_TO_LITTLE(pKeys[3].len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:    /*  Supported Rate Set Control */\n\t\t\tcase CFG_BASIC_RATE_SET_CNTL:    /*  Basic Rate Set Control */\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tbreak;\n\t\t\tcase CFG_DL_BUF:\n\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\tcase CFG_PCF_INFO:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\n\t\t\t\tbreak;\n\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\n\t\t\t\tlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\n\t\t\t\tbreak;\n\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\tcase CFG_NIC_PROFILE:\n\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\n\t\t\t\tlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\n\t\t\t\tlp->ltvRecord.u.u16[4] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[4]);\n\t\t\t\tbreak;\n\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tfor (i = 0; i < (lp->ltvRecord.len - 1); i++)\n\t\t\t\t\tlp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);\n\t\t\t\tbreak;\n\t\t\t/* done at init time, and endian handled then */\n\t\t\tcase CFG_PRI_IDENTITY:\n\t\t\t\tbreak;\n\t\t\tcase CFG_MB_INFO:\n\t\t\t\t/* wvlanEndianTranslateMailbox(pLtv); */\n\t\t\t\tbreak;\n\t\t\t/* MSF and HCF RIDS */\n\t\t\tcase CFG_IFB:\n\t\t\tcase CFG_DRV_INFO:\n\t\t\tcase CFG_AP_MODE:\n\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\tcase CFG_COUNTRY_STRING:\n\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Copy the LTV into the user's buffer. */\n\t\t\tcopy_to_user(urq->data, &(lp->ltvRecord), urq->len);\n\n\t\t\tif (ltvAllocated)\n\t\t\t\tkfree(&(lp->ltvRecord));\n\t\t\turq->result = UIL_SUCCESS;\n\t\t} else {\n\t\t\turq->result = UIL_FAILURE;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_get_info */\n/*============================================================================*/\n\n\n\n\n\n/*******************************************************************************\n *\tcfg_driver_info()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Retrieves driver information.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint cfg_driver_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"cfg_driver_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\t/* Make sure that user buffer can handle the driver information buffer */\n\tif (urq->len < sizeof(lp->driverInfo)) {\n\t\turq->len = sizeof(lp->driverInfo);\n\t\turq->result = UIL_ERR_LEN;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\t/* Verify the user buffer. */\n\tresult = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverInfo));\n\tif (result != 0) {\n\t\turq->result = UIL_FAILURE;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\tlp->driverInfo.card_stat = lp->hcfCtx.IFB_CardStat;\n\n\t/* Copy the driver information into the user's buffer. */\n\turq->result = UIL_SUCCESS;\n\tcopy_to_user(urq->data, &(lp->driverInfo), sizeof(lp->driverInfo));\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* cfg_driver_info */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\tcfg_driver_identity()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Retrieves ID information from the card.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint cfg_driver_identity(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_driver_identity\");\n\tDBG_ENTER(DbgInfo);\n\n\n\t/* Make sure that user buffer can handle the driver identity structure. */\n\tif (urq->len < sizeof(lp->driverIdentity)) {\n\t\turq->len = sizeof(lp->driverIdentity);\n\t\turq->result = UIL_ERR_LEN;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\t/* Verify the user buffer. */\n\tresult = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverIdentity));\n\tif (result != 0) {\n\t\turq->result = UIL_FAILURE;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\t/* Copy the driver identity into the user's buffer. */\n\turq->result = UIL_SUCCESS;\n\tcopy_to_user(urq->data, &(lp->driverIdentity), sizeof(lp->driverIdentity));\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* cfg_driver_identity */\n/*============================================================================*/\n\n\n#endif  /* USE_UIL */\n\n\n/* If WIRELESS_EXT is not defined, then the functions that follow will not be\n   included in the build. */\n/* NOTE: Are these still even needed? */\n#ifdef WIRELESS_EXT\n\n\n/*******************************************************************************\n *\twvlan_set_netname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Set the ESSID of the card.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_set_netname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_netname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\tmemcpy(lp->NetworkName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_netname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_get_netname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Get the ESSID of the card.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_get_netname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tint         status = -1;\n\twvName_t   *pName;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_get_netname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Get the current network name */\n\tlp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));\n\tlp->ltvRecord.typ = CFG_CUR_SSID;\n\n\tstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\n\n\tif (status == HCF_SUCCESS) {\n\t\tpName = (wvName_t *)&(lp->ltvRecord.u.u32);\n\n\t\tmemset(extra, '\\0', HCF_MAX_NAME_LEN);\n\t\twrqu->data.length = pName->length;\n\n\t\tmemcpy(extra, pName->name, pName->length);\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_get_netname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_set_station_nickname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Set the card's station nickname.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_get_station_nickname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Get the card's station nickname.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_get_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tint         status = -1;\n\twvName_t   *pName;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_get_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Get the current station name */\n\tlp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));\n\tlp->ltvRecord.typ = CFG_CNF_OWN_NAME;\n\n\tstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\n\n\tif (status == HCF_SUCCESS) {\n\t\tpName = (wvName_t *)&(lp->ltvRecord.u.u32);\n\n\t\tmemset(extra, '\\0', HCF_MAX_NAME_LEN);\n\t\twrqu->data.length = pName->length;\n\t\tmemcpy(extra, pName->name, pName->length);\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\n\twl_unlock(lp, &flags);\n\n/* out: */\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_get_station_nickname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_set_porttype()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Set the card's porttype\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_set_porttype(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint     ret = 0;\n\thcf_16  portType;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_porttype\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Validate the new value */\n\tportType = *((__u32 *)extra);\n\n\tif (!((portType == 1) || (portType == 3))) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlp->PortType = portType;\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\nout_unlock:\n\twl_unlock(lp, &flags);\n\n/* out: */\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n}\n\n/*============================================================================*/\n\n\n/*******************************************************************************\n *\twvlan_get_porttype()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Get the card's porttype\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_get_porttype(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint     ret = 0;\n\tint     status = -1;\n\thcf_16  *pPortType;\n\t__u32 *pData = (__u32 *)extra;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_get_porttype\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Get the current port type */\n\tlp->ltvRecord.len = 1 + (sizeof(*pPortType) / sizeof(hcf_16));\n\tlp->ltvRecord.typ = CFG_CNF_PORT_TYPE;\n\n\tstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\n\n\tif (status == HCF_SUCCESS) {\n\t\tpPortType = (hcf_16 *)&(lp->ltvRecord.u.u32);\n\n\t\t*pData = CNV_LITTLE_TO_INT(*pPortType);\n\t} else {\n\t    ret = -EFAULT;\n\t}\n\n\twl_unlock(lp, &flags);\n\n/* out: */\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_get_porttype */\n/*============================================================================*/\n\n#endif  /* WIRELESS_EXT */\n\n\n\n\n#ifdef USE_RTS\n/*******************************************************************************\n *\twvlan_rts()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      IOCTL handler for RTS commands\n *\n *  PARAMETERS:\n *\n *      rrq - a pointer to the rts request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_rts(struct rtsreq *rrq, __u32 io_base)\n{\n\tint ioctl_ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_rts\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tDBG_PRINT(\"io_base: 0x%08x\\n\", io_base);\n\n\tswitch (rrq->typ) {\n\tcase WL_IOCTL_RTS_READ:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_READ\\n\");\n\t\trrq->data[0] = IN_PORT_WORD(io_base + rrq->reg);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x ==> 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));\n\t\tbreak;\n\tcase WL_IOCTL_RTS_WRITE:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_WRITE\\n\");\n\t\tOUT_PORT_WORD(io_base + rrq->reg, rrq->data[0]);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x <== 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));\n\t\tbreak;\n\tcase WL_IOCTL_RTS_BATCH_READ:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_READ\\n\");\n\t\tIN_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x ==> %d bytes\\n\", rrq->reg, rrq->len * sizeof(__u16));\n\t\tbreak;\n\tcase WL_IOCTL_RTS_BATCH_WRITE:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_WRITE\\n\");\n\t\tOUT_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x <== %d bytes\\n\", rrq->reg, rrq->len * sizeof(__u16));\n\t\tbreak;\n\tdefault:\n\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- UNSUPPORTED RTS CODE: 0x%X\", rrq->typ);\n\t\tioctl_ret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ioctl_ret;\n} /* wvlan_rts */\n/*============================================================================*/\n\n#endif  /* USE_RTS */\n"], "fixing_code": ["/*******************************************************************************\n * Agere Systems Inc.\n * Wireless device driver for Linux (wlags49).\n *\n * Copyright (c) 1998-2003 Agere Systems Inc.\n * All rights reserved.\n *   http://www.agere.com\n *\n * Initially developed by TriplePoint, Inc.\n *   http://www.triplepoint.com\n *\n *------------------------------------------------------------------------------\n *\n *   This file defines handling routines for the private IOCTLs\n *\n *------------------------------------------------------------------------------\n *\n * SOFTWARE LICENSE\n *\n * This software is provided subject to the following terms and conditions,\n * which you should read carefully before using the software.  Using this\n * software indicates your acceptance of these terms and conditions.  If you do\n * not agree with these terms and conditions, do not use the software.\n *\n * Copyright \u00a9 2003 Agere Systems Inc.\n * All rights reserved.\n *\n * Redistribution and use in source or binary forms, with or without\n * modifications, are permitted provided that the following conditions are met:\n *\n * . Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following Disclaimer as comments in the code as\n *    well as in the documentation and/or other materials provided with the\n *    distribution.\n *\n * . Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following Disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * . Neither the name of Agere Systems Inc. nor the names of the contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Disclaimer\n *\n * THIS SOFTWARE IS PROVIDED \u0093AS IS\u0094 AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY\n * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN\n * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n ******************************************************************************/\n\n/*******************************************************************************\n * include files\n ******************************************************************************/\n#include <wl_version.h>\n\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n\n#include <debug.h>\n#include <hcf.h>\n#include <hcfdef.h>\n\n#include <wl_if.h>\n#include <wl_internal.h>\n#include <wl_enc.h>\n#include <wl_main.h>\n#include <wl_priv.h>\n#include <wl_util.h>\n#include <wl_netdev.h>\n\nint wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_action(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_block(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp);\nint wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp);\n\nint cfg_driver_info(struct uilreq *urq, struct wl_private *lp);\nint cfg_driver_identity(struct uilreq *urq, struct wl_private *lp);\n\n\n/*******************************************************************************\n * global variables\n ******************************************************************************/\n#if DBG\nextern dbg_info_t *DbgInfo;\n#endif  /* DBG */\n\n\n\n\n/* If USE_UIL is not defined, then none of the UIL Interface code below will\n   be included in the build */\n#ifdef USE_UIL\n\n/*******************************************************************************\n *\twvlan_uil()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      The handler function for the UIL interface.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_uil(struct uilreq *urq, struct wl_private *lp)\n{\n\tint ioctl_ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\tDBG_FUNC(\"wvlan_uil\");\n\tDBG_ENTER(DbgInfo);\n\n\tswitch (urq->command) {\n\tcase UIL_FUN_CONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_CONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_connect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_DISCONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_DISCONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_disconnect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_ACTION:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\\n\");\n\t\tioctl_ret = wvlan_uil_action(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_SEND_DIAG_MSG:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_SEND_DIAG_MSG\\n\");\n\t\tioctl_ret = wvlan_uil_send_diag_msg(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_GET_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_GET_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_get_info(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_PUT_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_PUT_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_put_info(urq, lp);\n\t\tbreak;\n\tdefault:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X\", urq->command);\n\t\tioctl_ret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tDBG_LEAVE(DbgInfo);\n\treturn ioctl_ret;\n} /* wvlan_uil */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_connect()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Connect to the UIL in order to make a request.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_connect\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (!(lp->flags & WVLAN2_UIL_CONNECTED)) {\n\t\tlp->flags |= WVLAN2_UIL_CONNECTED;\n\t\turq->hcfCtx = &(lp->hcfCtx);\n\t\turq->result = UIL_SUCCESS;\n\t} else {\n\t\tDBG_WARNING(DbgInfo, \"UIL_ERR_IN_USE\\n\");\n\t\turq->result = UIL_ERR_IN_USE;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_connect */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_disconnect()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Disconnect from the UIL after a request has been completed.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_disconnect\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (lp->flags & WVLAN2_UIL_CONNECTED) {\n\t\t\tlp->flags &= ~WVLAN2_UIL_CONNECTED;\n\t\t\t/*\n\t\t\tif (lp->flags & WVLAN2_UIL_BUSY) {\n\t\t\t\tlp->flags &= ~WVLAN2_UIL_BUSY;\n\t\t\t\tnetif_start_queue(lp->dev);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\turq->hcfCtx = NULL;\n\t\turq->result = UIL_SUCCESS;\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_disconnect */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_action()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Handler for the UIL_ACT_xxx subcodes associated with UIL_FUN_ACTION\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_action(struct uilreq *urq, struct wl_private *lp)\n{\n\tint     result = 0;\n\tltv_t   *ltv;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_action\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\t/* Make sure there's an LTV in the request buffer */\n\t\tltv = (ltv_t *)urq->data;\n\t\tif (ltv != NULL) {\n\t\t\t/* Switch on the Type field of the LTV contained in the request\n\t\t\t   buffer */\n\t\t\tswitch (ltv->typ) {\n\t\t\tcase UIL_ACT_BLOCK:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_BLOCK\\n\");\n\t\t\t\tresult = wvlan_uil_block(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_UNBLOCK:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_UNBLOCK\\n\");\n\t\t\t\tresult = wvlan_uil_unblock(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_SCAN:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_SCAN\\n\");\n\t\t\t\turq->result = hcf_action(&(lp->hcfCtx), MDD_ACT_SCAN);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_APPLY:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_APPLY\\n\");\n\t\t\t\turq->result = wl_apply(lp);\n\t\t\t\tbreak;\n\t\t\tcase UIL_ACT_RESET:\n\t\t\t\tDBG_TRACE(DbgInfo, \"UIL_ACT_RESET\\n\");\n\t\t\t\turq->result = wl_go(lp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDBG_WARNING(DbgInfo, \"Unknown action code: 0x%x\\n\", ltv->typ);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"Bad LTV for this action\\n\");\n\t\t\turq->result = UIL_ERR_LEN;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_action */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_block()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sets a block in the driver to prevent access to the card by other\n *  processes.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\n\nint wvlan_uil_block(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_block\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tlp->flags |= WVLAN2_UIL_BUSY;\n\t\t\tnetif_stop_queue(lp->dev);\n\t\t\tWL_WDS_NETIF_STOP_QUEUE(lp);\n\t\t\turq->result = UIL_SUCCESS;\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_block */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_unblock()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Unblocks the driver to restore access to the card by other processes.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_unblock\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif (lp->flags & WVLAN2_UIL_BUSY) {\n\t\t\t\tlp->flags &= ~WVLAN2_UIL_BUSY;\n\t\t\t\tnetif_wake_queue(lp->dev);\n\t\t\t\tWL_WDS_NETIF_WAKE_QUEUE(lp);\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_unblock */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_uil_send_diag_msg()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sends a diagnostic message to the card.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp)\n{\n\tint         result = 0;\n\tDESC_STRCT  Descp[1];\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_uil_send_diag_msg\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\tif (lp->hcfCtx.IFB_RscInd != 0) {\n\t\t\t\t\tu_char *data;\n\n\t\t\t\t\t/* Verify the user buffer */\n\t\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\t\tif (result != 0) {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area failed, result: %d\\n\", result);\n\t\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (data != NULL) {\n\t\t\t\t\t\tmemset(Descp, 0, sizeof(DESC_STRCT));\n\t\t\t\t\t\tmemcpy(data, urq->data, urq->len);\n\n\t\t\t\t\t\tDescp[0].buf_addr       = (wci_bufp)data;\n\t\t\t\t\t\tDescp[0].BUF_CNT        = urq->len;\n\t\t\t\t\t\tDescp[0].next_desc_addr = 0;    /* terminate list */\n\n\t\t\t\t\t\thcf_send_msg(&(lp->hcfCtx),  &Descp[0], HCF_PORT_0);\n\t\t\t\t\t\tkfree(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"ENOMEM\\n\");\n\t\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\turq->result = UIL_ERR_BUSY;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_send_diag_msg */\n/*============================================================================*/\n\n\n/*******************************************************************************\n *\twvlan_uil_put_info()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sends a specific RID directly to the driver to set configuration info.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n\n/*============================================================================*/\n\n/*******************************************************************************\n *\twvlan_uil_get_info()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Sends a specific RID directly to the driver to retrieve configuration\n *      info.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\tint i;\n\t/*------------------------------------------------------------------------*/\n\n\tDBG_FUNC(\"wvlan_uil_get_info\");\n\tDBG_ENTER(DbgInfo);\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\tltv_t      *pLtv;\n\t\t\tbool_t      ltvAllocated = FALSE;\n\n\t\t\t/* Make sure that we have at least a command and length */\n\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t/* Verify the user's LTV record header. */\n\t\t\tresult = verify_area(VERIFY_READ, urq->data, sizeof(hcf_16) * 2);\n\t\t\tif (result != 0) {\n\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t/* Get only the command and length information. */\n\t\t\tresult = copy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t/* Make sure the incoming LTV record length is within the bounds of\n\t\t\t   the IOCTL length. */\n\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\tDBG_ERROR(DbgInfo, \"Incoming LTV too big\\n\");\n\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t/* Determine if hcf_get_info() is needed or not */\n\t\t\tswitch (lp->ltvRecord.typ) {\n\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tmemcpy(&lp->ltvRecord.u.u8[0], &lp->NICIdentity, sizeof(lp->NICIdentity));\n\t\t\t\tbreak;\n\t\t\tcase CFG_PRI_IDENTITY:\n\t\t\t\tmemcpy(&lp->ltvRecord.u.u8[0], &lp->PrimaryIdentity, sizeof(lp->PrimaryIdentity));\n\t\t\t\tbreak;\n\t\t\tcase CFG_AP_MODE:\n\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported, so is get useful ????\\n\");\n\t\t\t\tlp->ltvRecord.u.u16[0] =\n\t\t\t\t\tCNV_INT_TO_LITTLE(lp->hcfCtx.IFB_FWIdentity.comp_id) == COMP_ID_FW_AP;\n\t\t\t\tbreak;\n\t\t\t/* case CFG_DRV_INFO: */\n\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\tcase CFG_COUNTRY_STRING:\n\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t/* TODO: determine if we're going to support these */\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\tbreak;\n\t\t\tcase CFG_DRV_INFO:\n\t\t\t\tDBG_TRACE(DbgInfo, \"Intercept CFG_DRV_INFO\\n\");\n\t\t\t\tresult = cfg_driver_info(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase CFG_DRV_IDENTITY:\n\t\t\t\tDBG_TRACE(DbgInfo, \"Intercept CFG_DRV_IDENTITY\\n\");\n\t\t\t\tresult = cfg_driver_identity(urq, lp);\n\t\t\t\tbreak;\n\t\t\tcase CFG_IFB:\n\t\t\t\t/* IFB can be a security hole */\n\t\t\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\t\t\tresult = -EPERM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Else fall through to the default */\n\n\t\t\tcase CFG_FW_IDENTITY:   /* For Hermes-1, this is cached */\n\t\t\tdefault:\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_WRITE, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_WRITE FAILED\\n\");\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\n\t\t\t\t\t\t/* Copy the command/length information into the new buffer. */\n\t\t\t\t\t\tmemcpy(pLtv, &(lp->ltvRecord), sizeof(hcf_16) * 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"kmalloc FAILED\\n\");\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\twl_act_int_off(lp);\n\t\t\t\turq->result = hcf_get_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\twl_act_int_on(lp);\n\n\t\t\t\t/* Copy the LTV into the user's buffer. */\n\t\t\t\t/*copy_to_user(urq->data, pLtv, urq->len); */\n\n\t\t\t\t/*if(ltvAllocated)\n\t\t\t\t{\n\t\t\t\t    kfree(pLtv);\n\t\t\t\t}*/\n\n\t\t\t\t/* urq->result = UIL_SUCCESS; */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Handle endian conversion of special fields */\n\t\t\tswitch (lp->ltvRecord.typ) {\n\t\t\t/* simple int gets just need the first hcf_16 byte flipped */\n\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                          /* Own Beacon Interval */\n\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:                            /* Coexistence Behavior */\n\t\t\t/*case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n#endif /* HERMES25 */\n\t\t\tcase CFG_CREATE_IBSS:\n\t\t\tcase CFG_RTS_THRH:\n\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t/*case CFG_WAKE_ON_LAN: */\n\t\t\tcase CFG_RTS_THRH0:\n\t\t\tcase CFG_RTS_THRH1:\n\t\t\tcase CFG_RTS_THRH2:\n\t\t\tcase CFG_RTS_THRH3:\n\t\t\tcase CFG_RTS_THRH4:\n\t\t\tcase CFG_RTS_THRH5:\n\t\t\tcase CFG_RTS_THRH6:\n\t\t\tcase CFG_TX_RATE_CNTL0:\n\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\tcase CFG_TX_KEY_ID:\n\t\t\tcase CFG_TICK_TIME:\n\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\tcase CFG_PORT_STAT:\n\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\tcase CFG_CF_POLLABLE:\n\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\tcase CFG_PHY_TYPE:\n\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t/* case CFG_CCAMODE: */\n\t\t\t/*     lp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]); */\n\t\t\t/*     break; */\n\t\t\t/* name string gets just need the first hcf_16 byte flipped (length of string) */\n\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\tcase CFG_DESIRED_SSID:\n\t\t\tcase CFG_SCAN_SSID:\n\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tbreak;\n\t\t\t/* non-length counted strings need no byte flipping */\n\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t/* this case is no longer valid: CFG_CNF_WDS_ADDR */\n\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\tcase CFG_GROUP_ADDR:\n\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\tcase CFG_CUR_BSSID:\n\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\tcase CFG_SUPPORTED_DATA_RATES:  /* need to ensure we can treat this as a string */\n\t\t\t\tbreak;\n\t\t\t/* case CFG_CNF_COUNTRY_INFO: */     /* special case, see page 75  of 022486, Rev C. */\n\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */ /* special case, see page 101 of 022486, Rev C. */\n\t\t\t/*\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\n\n\t\t\t\tfor(i = 4; i < lp->ltvRecord.len; i++) {\n\t\t\t\t\tlp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t*/\n\n\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t{\n\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)&lp->ltvRecord.u.u8[0];\n\n\t\t\t\t\tpKeys[0].len = CNV_INT_TO_LITTLE(pKeys[0].len);\n\t\t\t\t\tpKeys[1].len = CNV_INT_TO_LITTLE(pKeys[1].len);\n\t\t\t\t\tpKeys[2].len = CNV_INT_TO_LITTLE(pKeys[2].len);\n\t\t\t\t\tpKeys[3].len = CNV_INT_TO_LITTLE(pKeys[3].len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:    /*  Supported Rate Set Control */\n\t\t\tcase CFG_BASIC_RATE_SET_CNTL:    /*  Basic Rate Set Control */\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tbreak;\n\t\t\tcase CFG_DL_BUF:\n\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\tcase CFG_PCF_INFO:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\n\t\t\t\tbreak;\n\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\n\t\t\t\tlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\n\t\t\t\tbreak;\n\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\tcase CFG_NIC_PROFILE:\n\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\n\t\t\t\tlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\n\t\t\t\tlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\n\t\t\t\tlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\n\t\t\t\tlp->ltvRecord.u.u16[4] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[4]);\n\t\t\t\tbreak;\n\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tfor (i = 0; i < (lp->ltvRecord.len - 1); i++)\n\t\t\t\t\tlp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);\n\t\t\t\tbreak;\n\t\t\t/* done at init time, and endian handled then */\n\t\t\tcase CFG_PRI_IDENTITY:\n\t\t\t\tbreak;\n\t\t\tcase CFG_MB_INFO:\n\t\t\t\t/* wvlanEndianTranslateMailbox(pLtv); */\n\t\t\t\tbreak;\n\t\t\t/* MSF and HCF RIDS */\n\t\t\tcase CFG_IFB:\n\t\t\tcase CFG_DRV_INFO:\n\t\t\tcase CFG_AP_MODE:\n\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\tcase CFG_COUNTRY_STRING:\n\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Copy the LTV into the user's buffer. */\n\t\t\tcopy_to_user(urq->data, &(lp->ltvRecord), urq->len);\n\n\t\t\tif (ltvAllocated)\n\t\t\t\tkfree(&(lp->ltvRecord));\n\t\t\turq->result = UIL_SUCCESS;\n\t\t} else {\n\t\t\turq->result = UIL_FAILURE;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_get_info */\n/*============================================================================*/\n\n\n\n\n\n/*******************************************************************************\n *\tcfg_driver_info()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Retrieves driver information.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint cfg_driver_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"cfg_driver_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\t/* Make sure that user buffer can handle the driver information buffer */\n\tif (urq->len < sizeof(lp->driverInfo)) {\n\t\turq->len = sizeof(lp->driverInfo);\n\t\turq->result = UIL_ERR_LEN;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\t/* Verify the user buffer. */\n\tresult = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverInfo));\n\tif (result != 0) {\n\t\turq->result = UIL_FAILURE;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\tlp->driverInfo.card_stat = lp->hcfCtx.IFB_CardStat;\n\n\t/* Copy the driver information into the user's buffer. */\n\turq->result = UIL_SUCCESS;\n\tcopy_to_user(urq->data, &(lp->driverInfo), sizeof(lp->driverInfo));\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* cfg_driver_info */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\tcfg_driver_identity()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Retrieves ID information from the card.\n *\n *  PARAMETERS:\n *\n *      urq - a pointer to the UIL request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      UIL_SUCCESS\n *      UIL_ERR_xxx value otherwise\n *\n ******************************************************************************/\nint cfg_driver_identity(struct uilreq *urq, struct wl_private *lp)\n{\n\tint result = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_driver_identity\");\n\tDBG_ENTER(DbgInfo);\n\n\n\t/* Make sure that user buffer can handle the driver identity structure. */\n\tif (urq->len < sizeof(lp->driverIdentity)) {\n\t\turq->len = sizeof(lp->driverIdentity);\n\t\turq->result = UIL_ERR_LEN;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\t/* Verify the user buffer. */\n\tresult = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverIdentity));\n\tif (result != 0) {\n\t\turq->result = UIL_FAILURE;\n\t\tDBG_LEAVE(DbgInfo);\n\t\treturn result;\n\t}\n\n\t/* Copy the driver identity into the user's buffer. */\n\turq->result = UIL_SUCCESS;\n\tcopy_to_user(urq->data, &(lp->driverIdentity), sizeof(lp->driverIdentity));\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* cfg_driver_identity */\n/*============================================================================*/\n\n\n#endif  /* USE_UIL */\n\n\n/* If WIRELESS_EXT is not defined, then the functions that follow will not be\n   included in the build. */\n/* NOTE: Are these still even needed? */\n#ifdef WIRELESS_EXT\n\n\n/*******************************************************************************\n *\twvlan_set_netname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Set the ESSID of the card.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_set_netname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_netname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\tmemcpy(lp->NetworkName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_netname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_get_netname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Get the ESSID of the card.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_get_netname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tint         status = -1;\n\twvName_t   *pName;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_get_netname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Get the current network name */\n\tlp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));\n\tlp->ltvRecord.typ = CFG_CUR_SSID;\n\n\tstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\n\n\tif (status == HCF_SUCCESS) {\n\t\tpName = (wvName_t *)&(lp->ltvRecord.u.u32);\n\n\t\tmemset(extra, '\\0', HCF_MAX_NAME_LEN);\n\t\twrqu->data.length = pName->length;\n\n\t\tmemcpy(extra, pName->name, pName->length);\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_get_netname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_set_station_nickname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Set the card's station nickname.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tsize_t len;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\n\tstrlcpy(lp->StationName, extra, len);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_get_station_nickname()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Get the card's station nickname.\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_get_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tint         status = -1;\n\twvName_t   *pName;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_get_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Get the current station name */\n\tlp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));\n\tlp->ltvRecord.typ = CFG_CNF_OWN_NAME;\n\n\tstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\n\n\tif (status == HCF_SUCCESS) {\n\t\tpName = (wvName_t *)&(lp->ltvRecord.u.u32);\n\n\t\tmemset(extra, '\\0', HCF_MAX_NAME_LEN);\n\t\twrqu->data.length = pName->length;\n\t\tmemcpy(extra, pName->name, pName->length);\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\n\twl_unlock(lp, &flags);\n\n/* out: */\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_get_station_nickname */\n/*============================================================================*/\n\n\n\n\n/*******************************************************************************\n *\twvlan_set_porttype()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Set the card's porttype\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_set_porttype(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint     ret = 0;\n\thcf_16  portType;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_porttype\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Validate the new value */\n\tportType = *((__u32 *)extra);\n\n\tif (!((portType == 1) || (portType == 3))) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlp->PortType = portType;\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\nout_unlock:\n\twl_unlock(lp, &flags);\n\n/* out: */\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n}\n\n/*============================================================================*/\n\n\n/*******************************************************************************\n *\twvlan_get_porttype()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      Get the card's porttype\n *\n *  PARAMETERS:\n *\n *      wrq - a pointer to the wireless request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_get_porttype(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint     ret = 0;\n\tint     status = -1;\n\thcf_16  *pPortType;\n\t__u32 *pData = (__u32 *)extra;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_get_porttype\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\t/* Get the current port type */\n\tlp->ltvRecord.len = 1 + (sizeof(*pPortType) / sizeof(hcf_16));\n\tlp->ltvRecord.typ = CFG_CNF_PORT_TYPE;\n\n\tstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\n\n\tif (status == HCF_SUCCESS) {\n\t\tpPortType = (hcf_16 *)&(lp->ltvRecord.u.u32);\n\n\t\t*pData = CNV_LITTLE_TO_INT(*pPortType);\n\t} else {\n\t    ret = -EFAULT;\n\t}\n\n\twl_unlock(lp, &flags);\n\n/* out: */\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_get_porttype */\n/*============================================================================*/\n\n#endif  /* WIRELESS_EXT */\n\n\n\n\n#ifdef USE_RTS\n/*******************************************************************************\n *\twvlan_rts()\n *******************************************************************************\n *\n *  DESCRIPTION:\n *\n *      IOCTL handler for RTS commands\n *\n *  PARAMETERS:\n *\n *      rrq - a pointer to the rts request buffer\n *      lp  - a pointer to the device's private adapter structure\n *\n *  RETURNS:\n *\n *      0 on success\n *      errno value otherwise\n *\n ******************************************************************************/\nint wvlan_rts(struct rtsreq *rrq, __u32 io_base)\n{\n\tint ioctl_ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_rts\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tDBG_PRINT(\"io_base: 0x%08x\\n\", io_base);\n\n\tswitch (rrq->typ) {\n\tcase WL_IOCTL_RTS_READ:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_READ\\n\");\n\t\trrq->data[0] = IN_PORT_WORD(io_base + rrq->reg);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x ==> 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));\n\t\tbreak;\n\tcase WL_IOCTL_RTS_WRITE:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_WRITE\\n\");\n\t\tOUT_PORT_WORD(io_base + rrq->reg, rrq->data[0]);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x <== 0x%04x\\n\", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));\n\t\tbreak;\n\tcase WL_IOCTL_RTS_BATCH_READ:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_READ\\n\");\n\t\tIN_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x ==> %d bytes\\n\", rrq->reg, rrq->len * sizeof(__u16));\n\t\tbreak;\n\tcase WL_IOCTL_RTS_BATCH_WRITE:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_WRITE\\n\");\n\t\tOUT_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);\n\t\tDBG_TRACE(DbgInfo, \"  reg 0x%04x <== %d bytes\\n\", rrq->reg, rrq->len * sizeof(__u16));\n\t\tbreak;\n\tdefault:\n\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_RTS -- UNSUPPORTED RTS CODE: 0x%X\", rrq->typ);\n\t\tioctl_ret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ioctl_ret;\n} /* wvlan_rts */\n/*============================================================================*/\n\n#endif  /* USE_RTS */\n"], "filenames": ["drivers/staging/wlags49_h2/wl_priv.c"], "buggy_code_start_loc": [572], "buggy_code_end_loc": [1798], "fixing_code_start_loc": [573], "fixing_code_end_loc": [1801], "type": "CWE-119", "message": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions.", "other": {"cve": {"id": "CVE-2013-4514", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-12T14:35:12.400", "lastModified": "2023-02-13T04:47:05.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions."}, {"lang": "es", "value": "M\u00faltiples desbordamientos de buffer en drivers/staging/wlags49_h2/wl_priv.c en el kernel de Linux anterior a la versi\u00f3n 3.12 permite a usuarios locales provocar una denegaci\u00f3n de servicio o posiblemente tener otro impacto no especificado mediante el aprovechamiento de la capacidad y disponibilidad de una cadena larga station-name, relacionada con las funciones (1) wvlan_uil_put_info y (2) wvlan_set_station_nickname."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.7", "matchCriteriaId": "74676759-D357-4224-9C07-7FCAB195A0CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.0:*:*:*:*:*:arm64:*", "matchCriteriaId": "C8409226-20A1-4549-9E11-6D0C3C38DCCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=b5e2f339865fb443107e5b10603e53bbc92dc054", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-02/msg00045.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/04/22", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/63509", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2066-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2067-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2068-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2069-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2070-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2071-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2072-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2073-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2074-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2075-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2076-1", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.12.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054"}}