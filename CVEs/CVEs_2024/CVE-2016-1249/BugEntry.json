{"buggy_code": ["2016-10-30 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.038_01)\n* Fix compilation of embedded server (pali)\n  (https://github.com/perl5-dbi/DBD-mysql/pull/68)\n* Fix compilation against libmariadbclient. First version by\n  H.Merijn Brand, improved by Bernt Johnsen @ Oracle.\n* For efficiency use newSVpvn() instead newSVpv() where possible (pali)\n* Correctly coerce fetched scalar values when mysql_server_prepare is\n  not used (pali)\n* Add support for fetching columns of BIT type with\n  mysql_server_prepare = 1 (pali)\n  Fixes https://rt.cpan.org/Public/Bug/Display.html?id=88006\n* Use correct format in printf instead of casting variable types (pali)\n* Include errno.h for MYSQL_ASYNC because it uses errno variable (pali)\n* Travis: also test on perl 5.22 and 5.24.\n\n2016-10-19 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.038)\n* Version 4.037_1 had fixes for MySQL 8.0 provided\n  Bernt Johnsen @ Oracle that were not in the Changelogs\n  (https://github.com/perl5-dbi/DBD-mysql/pull/56)\n* Fixes for compiling against newer libmysqlclient on Windows (kmx)\n* Fix unit test for 40server_prepare_crash on Windows (pali)\n* Perl's IV in scalar can store 64bit integer when perl was compiled\n  with 64 bit support (default on 64bit linux with gcc). Use this\n  feature and stores MYSQL_TYPE_LONGLONG as integers instead of strings\n  when possible. (pali, https://github.com/perl5-dbi/DBD-mysql/pull/57)\n\n2016-10-14 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.037_01)\n* Newest versions of libmysqlclient and the MariaDB C connector no longer\n  export the __WIN__ macro. If this macro is not present we would not\n  compile in the poll.h-based async-support. Changed to use the _WIN32\n  macro instead. Thanks to Sergei Golubchik for suggesting the fix.\n* Fix from Pali Roh\u00e1r for use-after-free in prepared statements,\n  changes to bind logic, and added test 40server_prepare_crash.\n\n2016-10-03 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.037)\n* Security release to patch possible buffer overflow in unsafe sprintf with\n  variable length. Reported and fixed by Pali Roh\u00e1r. This vulnerability\n  is present in all releases at least back to versions 3.0 of the\n  driver, which were released in 2005.\n  The CVE identifier for this vulnerability is CVE-2016-1246.\n\n2016-08-23 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.036)\nStable version, to include all changes since 4.035.\n\n2016-08-19 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035_03)\n* By mistake, when DBD::mysql was compiled against libmariadb, it\n  did not compile in SSL support.\n  Reported by Jitka Plesnikova @ Red Hat\n   (https://rt.cpan.org/Public/Bug/Display.html?id=116959)\n   (https://bugzilla.redhat.com/show_bug.cgi?id=1366773)\n* If the database test server was not on localhost and the test database was\n  not yet created, we would not correctly create the test database.\n  Reported by Vladimir Marek.\n   (https://rt.cpan.org/Ticket/Display.html?id=112072)\n\n2016-08-11 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035_02)\n* Test 56connattr.t failed when run when performance schema is enabled, but\n  tests were run as a user with limited permissions.\n  Reported by J\u00e9r\u00f4me \u00c9t\u00e9v\u00e9.\n  (https://rt.cpan.org/Public/Bug/Display.html?id=115980)\n* In 4.033_03 we added a patch from Petr P\u00edsa\u0159 @ Red Hat for a problem on\n  64-bit big-endian systems. The patch was applied but the unit test was not,\n  also, there was no entry in the change log.\n  Unit test provided by Vladimir Marek.\n  t/40server_prepare.t test failed on s390x platform. Server-prepared\n  values of types int, smallint, and tinyint are passed to application\n  as 32-bit integer. The same buffer was interpreted as long integer\n  by DBD::MySQL. This caused misaligned read/write and bogus\n  interpretation of the values.\n   (https://rt.cpan.org/Public/Bug/Display.html?id=57266)\n* Remove dropdb, createdb, reload and shutdown admin functions from perldoc.\n  These are deprecated by the C API.\n  Use 'CREATE DATABASE..', 'DROP DATABASE...' and other SQL commands instead.\n* Test rt75353-innodb-lock-timeout.t fails on MySQL Server 5.1 and earlier\n  because innodb_lock_wait_timeout is not modifyable per session.\n* Test rt25389-bin-case.t does not work on MySQL Server < 5.1, reported by\n  GAAS.\n\n2016-08-01 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035_01)\n* Apparently, on t/31insertid.t, there is one test that fails when compiled\n  against libmysqlclient 5.7 or up; issuing a SELECT statement on the same\n  database handle that previously executed an INSERT clears\n  $dbh->{mysql_insertid}, while previously this was retained.\n  (https://rt.cpan.org/Ticket/Display.html?id=108000)\n* Removed appveyor.yml and mysql.mtest from CPAN releases.\n* Converted README.pod to README.md because of installation failures on\n  FreeBSD, reported by Don Randolph.\n  (https://rt.cpan.org/Public/Bug/Display.html?id=114177)\n\n2016-07-09 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035)\n*  Add DBI back to configure_requires, fix by miyagawa.\n\n2016-07-06 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.034)\n* Full version, to include all changes since 4.033.\n\n2016-07-04 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033_03)\n* Check for errors after calling mysql_affected_rows(), by Pali.\n   (https://rt.cpan.org/Public/Bug/Display.html?id=75353)\n* Fix reference to MySQL manual, chapter Character Set Support, suggested\n  by Slaven Rezi\u0107 (https://rt.cpan.org/Public/Bug/Display.html?id=114148)\n* Improve documentation on current database, suggested by Vladimir Marek.\n   (https://rt.cpan.org/Ticket/Display.html?id=112587)\n\n2015-12-18 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033_02)\n* Compile against libssl by default. This allows to connect against remote\n  MySQL servers using SSL. Previously this was only achieved with an explicit\n  switch provided to Makefile.PL - if for some reason you can't or don't want\n  to link against libssl, you can use the new --nossl switch to Makefile.PL.\n* Made tests more robust after CPAN Testers failures.\n\n2015-12-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033_01)\n* Raise minimum DBI version to 1.609 (from 2009!) in order to make\n  tests pass on RHEL5.\n* Add explicit documentation for how to enable SSL at build time,\n  provided by genio.\n* Improve test suite to make it more robust using mixed versions of client and\n  server.\n* Fix use after free error in my_login, provided by hannob.\n* Add explicit instructions stating brackets are required around ipv6-addresses\n  in connection strings, provided by Kenny Gryp.\n\n2015-10-26 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033)\n* Full-release to include 03.\n\n2015-10-25 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032_03)\n* Use mysql_get_option to read net_buffer_length and mysql_get_parameter\n   where available, needed for MySQL 5.7.9. Patch from berntm @ Oracle.\n   https://github.com/perl5-dbi/DBD-mysql/pull/42\n* Fix mysql_conn_attrs test when run against MySQL 5.1 server.\n* Fix for memory leak to $sth->{ParamValues} , RT83051\n    https://rt.cpan.org/Public/Bug/Display.html?id=83051\n* Fixes for running test suite on MySQL 5.7.\n* Fix running test suite with InnoDB disabled, reported by bor.\n\n2015-07-20 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032)\n* Full-release to include 02 and 01.\n\n2015-06-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032_02)\n* Added support for utf8mb4 by Dani\u00ebl van Eeden and Eric Herman (Booking.com)\n* Added patch for connection attributes in MySQL 5.6.6+, by Dani\u00ebl van Eeden\n   and Eric Herman (Booking.com).\n\n2015-04-16 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032_01)\n* Fixed test rt88006-bit-prepare on MyISAM storage\n   (Reported both in RT102657 and by Scimon on github)\n* Fix for https://rt.cpan.org/Public/Bug/Display.html?id=102717 \"Fritz\" Friedrich Haubensak (hsk AT fli-leibniz DOT de)\nVielen Danken!\n* Corrected name ofINSTALL.pm in POD David Farrell <davidnmfarrell AT gmail DOT com>\n\n    Corrected name of INSTALL.pm in POD\n\n2015-03-05 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.031)\n* Added LICENSE\n* Reworked installation documentation in POD.\n* Allow use of bracketed IPv6 addresses in connection string (RT70640),\n   fix by Tim Mullin @ cPanel).\n* Locate mysql_config in path on MSWin32 (RT94838, reported by CHORNY).\n* Environment variable DBD_MYSQL_CONFIG actually works now.\n* Makefile.PL now correcly handles MariaDB's mysql_config.\n* Correct attribution to David Dick #86030: PATCH: adding statistics_info support\n* Test suite can now be run in parallel. Fixes RT98994 reported by DOHERTY.\n* Fixes for MySQL 5.6+ and for prepared statement handling (stevenh on github).\n* Fix for RT100792, New test t/05dbcreate.t fails if user has no permissions.\n* Fix for bit test (RT68374, BJDEAN@cpan.org) CaptTofu added 40bit.t to test.\n\n\n2015-03-02 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.030_02)\n* Reworked installation documentation in POD.\n* Allow use of bracketed IPv6 addresses in connection string (RT70640),\n   fix by Tim Mullin @ cPanel).\n* Locate mysql_config in path on MSWin32 (RT94838, reported by CHORNY).\n* Environment variable DBD_MYSQL_CONFIG actually works now.\n* Makefile.PL now correcly handles MariaDB's mysql_config.\n\n2015-01-27 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.030_01)\n* Correct attribution to David Dick #86030: PATCH: adding statistics_info support\n* Test suite can now be run in parallel. Fixes RT98994 reported by DOHERTY.\n* Fixes for MySQL 5.6+ and for prepared statement handling (stevenh on github).\n* Fix for RT100792, New test t/05dbcreate.t fails if user has no permissions.\n* Fix for bit test (RT68374, BJDEAN@cpan.org) CaptTofu added 40bit.t to test.\n\n2014-12-08 Patrick Galbraith (aka CaptTofu) and community (4.029)\n* Added fix to tests to create test database if not exists (contstant failure on Travis) (CaptTofu)\n* Support the fraction of (Oracle) MySQL Fabric that is supported by the most recent Connector/C (Steffen Mueller smueller<at>cpan<dot>org\n* Statistics Info Milan \u00bform <sorm<at>is4u<dot>cz> for work on statistics_info\n* Fix for RT 97625, use after free(), Reini Urban rurban<at>cpan<dot>org\n\n2014-08-01 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.028)\n* Fixed bug in mysql.xs where dbh was being used as error code\n* RT #97570: fix wrong salloc free in mysql_st_internal_execute - (Reini Urban, cPanel)\n* Fix RT #97625 use-after-free in mysql_dr_error, and #86153 - (Reini Urban, cPanel)\n* find mysql.h for MariaDB on Win32 (Graham Ollis)\n* Update mysql.pm to work with ipv6 and ipv4 addresses (katyavoid)\n\n2014-03-19 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.027)\n* Added more OS X notes and fixed compiler warnings\n* Skip tests if test database is not present-RT92330 (zefram <zefram at fysh dot org>\n* metacpan.org and search.cpan.org didn't display module POD, caused by fix for RT90101. Reported by Oleg, RT92350.\n\n2014-01-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.026)\n* t/29warnings.t fails on MySQL Server 5.1.something - Reported by RT91202, Gisle Aas. Now is handled depending on version.\n* README.pod misses proper NAME heading - RT90101 - Damyan Ivanov, Debian Perl Group\n* Added fix and test for RT91715\n* Added feature from Jacob Gelbman (cPanel) mysql_skip_secure_auth\n\n2013-11-05 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.025)\n* Set with parentheses and column_info - RT50304 - reported and fixed by Kevin Bosak.\n* Fix method redefinition warnings in threads on Perl >= 5.16 - Dagfinn Ilmari Manns\u00e5ker\n* use strict and warnings everywhere.\n* Minimum perl version is now 5.8.1, just as for DBI.\n* Improved database version check so tests run correctly on MariaDB 10.\n* Fix manifest - RT89106, reported by Joe Grasse.\n* set auto_increment_offset explicitly to make tests pass if they are set on server - RT83487, reported by Ian Barton.\n* Assume 'localhost' when testport is set but no testhost in Makefile.PL - RT83496, reported by Philip Stoev.\n* Corrected documentation for mysql_init_command option - Alexey Molchanov <alexey.molchanov@portaone.com>\n* Skip stored procedure tests if user is unpriviliged - RT83348 - Chris Weyl <cweyl@alumni.drew.edu>\n* Fix example in POD doc for NUM_OF_FIELDS - RT36730, reported by tapoutmma.\n* Fix for memory leak (RT86153) when connecting with incorrect password\n* Bail if connect fails early on (RT31823)\n\n2013-09-17 Michiel Beijen, Patrick Galbraith, DBI/DBD community (4.024)\n* Fix memory leak if mysql_server_prepare is enabled - RT76462 - Masahiro Chiba\n* Small dist improvements:  Michiel Beijen <michiel.beijen@otrs.com>\n* Undefined $DBI::errstr on execute fail on Windows: Michiel Beijen <michiel.beijen@otrs.com>\n* Better diagnostics for 80procs.t Fixes RT#71199: Alexandr Ciornii <alexchorny@gmail.com>\n* Fix #64013: INSTALL.pod is shown with 'man install': Juergen Weigert <jw@suse.com>\n* Added 'testport' to keys in Makefile.PL Fixes RT#83492: Michiel Beijen <michiel.beijen@otrs.com>\n* Fixed test 70takeimp warning. Michiel Beijen <michiel.beijen@otrs.com>\n* Made test t/87async.t not stop on Win32. Michiel Beijen <michiel.beijen@otrs.com>\n* Update github location.  Update support information. Michiel Beijen <michiel.beijen@otrs.com>\n* POD Fixes  Patch from RT77043 by Gunnar Wolf, Debian Perl Group. Michiel Beijen <michiel.beijen@otrs.com>\n\n2013-04-12 Patrick Galbraith et open source community <patg at patg dot net> (4.023)\n    Fix memory leak if mysql_server_prepare is enabled.\n* Fix primary_key_info result ordering - https://github.com/CaptTofu/DBD-mysql/pull/39 - Dagfinn Ilmari Manns\u00e5ker\n* allow compilation with msvc - https://github.com/CaptTofu/DBD-mysql/pull/37 - Walde Christian\n* just to set MYSQL_OPT_WRITE_TIMEOUT and MYSQL_OPT_READ_TIMEOUT by dsn - https://github.com/CaptTofu/DBD-mysql/pull/36 - Naosuke Yokoe\n* just remove unnecessary \"my\" - https://github.com/CaptTofu/DBD-mysql/pull/34 - Shoichi Kaji\n* eval $ExtUtils::MakeMaker::VERSION requires for old ExtUtils::MakeMaker - https://github.com/CaptTofu/DBD-mysql/pull/32 - Daisuke Murase\n* Updated documentation to reflect that bugs will be reported at rt.cpan.org\n* Updated version\n* Chased tail finding issue with -1 being converted to max unsigned int in PS mode\n* Various typos and other unicode fixes dsteinbrunner <dsteinbrunner@gmail.com>\n* Fixed permissions on files.\n* Clarified documentation and bumped version for next release\n\n2012-08-28 Patrick Galbraith et open source community <patg at patg dot net> (4.022)\n* Fixes for Win32 from Rom Hoelz (https://github.com/hoelzro)\n* Pulling back in work for 4.021 that didn't get pushed and much other work from Chip Salzenberg (https://github.com/chipdude)\n* Column info order fix from Tokuhiro Matsuno (https://github.com/tokuhirom)\n* Fix AutoCommit comparison logic to avoid spurious commands to mysql from Matthew Horsfall (https://github.com/wolfsage)\n* server_preapre can't bind placeholder on comment. from Misahiro Chiba (https://github.com/nihen)\n* server_prepare; data is null, allocate big memory bug. from Misahiro Chiba (https://github.com/nihen)\n\n2012-04-15 Patrick Galbraith (work of others) <patg at patg dot net> (4.021)\n* Fix to enable PERL_NO_GET_CONTEXT to spee up DBD on thread Perls\n(Dave Mitchell <davem at iabyn dot com>) Thank you!\n* Fix to is_prefix not being exported by mysql Aran Deltax <bluefeet at gmail dot com> Thank you!\n* Eliminate DBIS usage Dagfinn Ilmari Manns\u00e5ker <ilmari at ilmari dot org> Thank you!\n* Enhanced / Fixed server side prepared statement checks (Steven Hartland) Thank you!\n* Fix missprint in doc of DBD::mysql of mysql_bind_type_guessing (Perlover http://blog.perloever.com) Thank you!\n* Misprint in lib/DBD/mysql.pm (Perlover) Thank you!\n\n2011-08-15 Patrick Galbraith <patg at patg dot net> (4.020)\n* Numerous (!! Thank you!!) fixes for prepared statements: Masahiro Chiba <nihen at megabbs\ndot com>\n\t- Chop blanks fixed\n\t- UTF8 improvements\n\t- fixed memory allocation for BLOBs\n\t- auto-reconnect\n* Fix in leak test, which failed sometime due to first assignment $prev_size over\npaging (Masahiro Chiba)\n* Catalog test allows use of schemas other than 'test' (Masahiro Chiba)\n* Documentation fix for auto_reconnect (Karen Etheridge <ether at cpan dot\norg>)\n* Win32 and general installation fixes (Alexandr Ciornii, http://chorny.net)\n\n\n2011-05-08 Patrick Galbraith <patg at patg dot net>  Rob Hoelz <rhoelz at inoc dot com> (4.019)\n* Asynchronous support added by Rob Hoelz - Thanks!\n* Amiri Barksdale - Enable environment variables for installation options, add\ndocs to POD - Thanks!\n* Pedro Melo - fix to change sv_undef to PL_sv_undef from 4.018 - Thanks!\n\n2010-10-11 Patrick Galbraith <patg at patg dot net> (4.018)\n* Added client and server info patch from Robert M. Jansen\n* Added documentation and tests for new features\n* More code cleanup\n\n2010-08-11 Patrick Galbraith <patg at patg dot net> (4.017)\n* BUG #60085, Andreas Koenig's patch for DBI changes\n* Updated documents\n\n2010-07-10 Patrick Galbraith <patg at patg dot net> (4.016)\n* Disabled mysql_bind_type_guessing due to one performance issue\n  querying on a indexed character column unquoted will mean the index\n  is not used\n* Fixed int types that should be bools\n\n2010-07-09 Patrick Galbraith <patg at patg dot net> (4.015)\n* BUG #56664 fixed t/40blobs.t skip_all logic (W. Phillip Moore)\n* BUG #57253 Fixed iteration past end of string (crash). (Chris Butler)\n* Added a new parameter for old behavior- mysql_bind_comment_placeholders which\n  will make it possible to have placeholders bound for those who really\n  want that behavior.\n* Fixed bind_type_guessing - always on now\n\n2010-04-14 Patrick Galbraith <patg at patg dot net> (4.014)\n* BUG #30033 Fixed handling of comments to allow comments that contain characters\n  that might otherwise cause placeholder detection to not work properly\n* BUG #53844, Fix for memory leak in stats. (Gregory Burmistrov)\n* BUG #49719, Fix for handling of NULLs in prepared statements (Gert Pache)\n* BUG #55627, Fix for testing failure due to strict mode (Yves)\n* BUG #51784, Fix for mysqladmin on Windows in Makefile (Zeeshan Muhammad)\n* BUG #41630, Typo in Makefile\n* Had to define true and false in dbdimp.h. Didn't work out of the box on Linux\n\n2009-09-16 Patrick Galbraith <patg at patg dot net> (4.013)\n\n* #49484: PATCH add support for MYSQL_INIT_COMMAND - Peter John Edwards\n* #48242: 'mysql_bind_type_guessing' doesn't work correctly\nwith minus sign - Thanks Serguei Trouchelle!\n* #45616: t/40blobs.t cannot pass without database access -\nServerError() not declared - Thanks ysth http://ysth.livejournal.com/\n\n2009-06-18 Patrick Galbraith <patg at patg dot net> (4.012)\n\n* Patch to bind_type_guessing from Craigslist,\n  Thanks to Chris! Happiness is no quoted numbers.\n  Fixed ChopBlanks to work with bind_type_guessing\n* Patch for win32 strawberry build\n  Thanks to Curtis Jewell! Windows needs love\n* Patch for auto-reconnect to set active flag\n  Thanks to Doug Fischer!\n* Fixed bug 32464 http://bugs.mysql.com/bug.php?id=32464.\n  See https://rt.cpan.org/Ticket/Display.html?id=46308\n  Add connection flag mysql_no_autocommit_cmd which users of\n  MySQL Proxy can use to prevent 'set autocommit=#' from being\n  issued by the driver. 'perldoc DBD::mysql' to see how to use\n  this new flag\n* Added bind-type-guessing options to Makefile.PL so the entire\n  test suite can be run with bind_type_guessing set.\n\n2009-04-13 Patrick Galbraith <patg at patg dot net> (4.011)\n* Renamed unsafe_bind_type_guessing, fixed some of the logic. This\ncan be used to deal with bug 43822\n(https://rt.cpan.org/Ticket/Display.html?id=43822)\n* Patch from Daniel Frett (daniel Dot frett At ccci Dot org) to fix\nissue of binding sever side integer parameters (server-side prepare\nstatements) resulting in corrupt data, bug 42723\n(https://rt.cpan.org/Ticket/Display.html?id=42723)\n* Updated documentation, cruft cleanup (as always)\n\n2008-10-24 Patrick Galbraith <patg at patg dot net> (4.010)\n* Fix to dbd_bind_ph() for uninitialized value 'buffer_length'\nthanks for bug report and patch from Askniel.com (thanks!)\n\n2008-10-21 Patrick Galbraith <patg at patg dot net> (4.009)\n* Fix to re-enable TAKE_IMP_DATA_VERSION. Still have to ensure DBI version 1.607 or higher\n* Fix to escaped single quotes throwing off bind param detection. Patch from Zhurs (zhurs@yandex.ru) Spasibo!\n\n2008-8-15 Patrick Galbraith <patg at patg dot net> (4.008)\n* Multi statement patch, thanks to Chris Heath!\n* Disabled TAKE_IMP_DATA_VERSION because segfault with DBI < 1.607\n* #29528: bind_param(..., SQL_FLOAT) ignores exponents - fixed, Thanks to\nTokuhiro Matsuno!\n* Cleanups to make mysqlEmb work under Cygwin - Thanks to Chris Rodgers\n<http://rodgers.org.uk/> !\n* Modified and disabled tests for MySQL version < 4.1 for unsupported features\n\n2008-5-11 Patrick Galbraith <patg at patg dot net> (4.007)\n\n* Took out mysql_server_init call where not needed\n* Complete re-write of test suit to use Test::More - tons of cleanups!\n* Makefile.PL changes to use current user in 'make test' if not defined\n\n2007-12-26 Patrick Galbraith <patg at patg dot net> (4.006)\n\n* Cleanups on OS X compile\n* Fixes to syntax errors on AIX\n* Removed test code that was leaving trace files around\n\n2007-3-22 Patrick Galbraith <patg at patg dot net> (4.005)\n\n* Fixed mysql_warning issue < 4.1 (reminers, patches, help from ROAM, (issue 25713)\n* makerealclean patch from ROAM (issue #25714)\n* sqlstate cleanup patch from ROAM\n* Replaced all references to dbis to use imp_xxh per DBI best practices\n* Fix to dbd_st_destroy - added back previously removed 'free everything' code which\n  had been moved to dbd_st_finish, causing a crash upon freeing of bind values\n  after all rows resulting from one execution of a query have been fetched. This meant\n  that next attempt to execute the prepared statement would segfault. This\n  work thanks to Rainer Weikusat!\n* Removed all 'FindNewTable' calls in all tests. Just use 't1' for all tests to\n  simplify things. Plus, this is how MySQL internall tests.\n* Better 'skip test' logic in some tests that were still running when they shouldn't\n  have been.\n\n\n\n2007-3-22 Patrick Galbraith <patg at patg dot net> Jim Winstead <jimw@mysql.com> (4.004)\n* Work around a bug in old 3.23 servers by specifying NOT NULL for fields used\n  as a primary key in tests. (Bug #20325, reported by Julian Ladisch)\n* Add support for mysql_warning_count statement handle attribute. (Bug #25457,\n  patch from Philip Stoev)\n* Add support for mysql_multi_statements connection option. (RT #12322, based\n  on patch from Doug Morris)\n* Had to bump to 4.003 do to print statement in mysql.pm that made it\n  into the dist. Even though you can delete a file on CPAN, you cannot\n  re-upload it if it's the same name. Mea Culpa.\n* UTF8-Flag not set with flag mysql_enable_utf8 and column collation utf8_bin patch,\n  Joost Diepenmaat, (RT #24738)\n* Fixed do_error definition (Scott Hildreth, Tim Bunce)\n* Conversion of test suite to Test::More\n\n2007-3-5 Patrick Galbraith <patg at patg dot net> Jim Winstead <jimw@mysql.com> (4.003)\n* Fix inclusion of non-primary keys in primary_key_info. (Bug #26786,\n  reported and patch by Dave Rolsky)\n\n2007-3-1 Patrick Galbraith <patg at patg dot net> Jim Winstead <jimw@mysql.com> (4.002)\n* Fix re-exec of Makefile.PL when forcing $ENV{LANG} to 'C'. (RT #25233,\n  reported by Slaven Rezic)\n* Rewrote table_info method to support all arguments (previously it would\n  only ever return all of the tables in the current database, no matter what\n  was specified)\n* Fixed $DBD::mysql::VERSION to be a string instead of a float, which caused\n  problems for certain locales\n* Fixed bug #23974. $dbh->column_info now returns handle with no rows upon\n  table not existing.  Much thanks to Tim Bunce for help fixing the problem\n  in mysql.pm vs. dbdimp.c\n* Removed #ifdefs for do error (sqlstate being passed as last arg depending on\n  version)\n* Fixed insertid test to work with auto_increment_increment replication setup.\n* Patch from Tim Bunce fixing do() not set $dbh->{Statement} attribute,\n  which prevented DBD::Profile from giving correct results for calls to do()\n  and causing ShowErrorStatement to possibly report the wrong statement in the\n  error message\n* Patch from Tim Bunce clearing out the sth attribute cache when switching\n  between result, sets which prevented the adjustedment of NUM_OF_FIELDS\n* Cleanup of several unused variables\n* Added support for wildcards in last argument of column_info().\n* Add mysql_is_auto_increment to results of column_info(). (Bug #26603,\n  original patch from Dave Rolsky)\n* Return the correct table type for both tables and views from the table_info()\n  method. (Bug #26603, original patch from Dave Rolsky)\n* Add implementation of foreign_key_info() (Bug #26604, original patch from\n  Dave Rolsky, and final implementation based on Connector/J code)\n\n\n2007-1-8 Jim Winstead <jimw@mysql.com> Patrick Galbraith <patg at patg dot net> (4.001)\n* Fix handling of unsigned integer values in result sets when using\n  server-side prepared statements (they were not retrieved at all).\n* Fix handling of signed integer values when using server-side prepared\n  statements (they were being forced to unsigned values).\n* Do not tell Perl that the contents of binary fields are UTF-8.\n  [rt.cpan.org #22123], original patch by Joost Diepenmaat\n* Fix double-free of bound parameters when freeing statements. (Bug #20559)\n* Make sure to handle \"magical\" values in a couple of places. (Bug #20104)\n* Update the hints about what to do when zlib is found missing while\n  linking. (Bug #13803, reported by Philip Stoev)\n* Explicitly initialize the MySQL client library to avoid possible race\n  conditions in a multithreaded application. (Bug #21792)\n* Fix warning when no connection attributes are passed to the connect\n  method (Bug #17323, reported by Phil Randal)\n* Removed redundant warnings when commit or rollback is called while\n  AutoCommit is enabled. [rt.cpan.org #15802], reported by Tyler MacDonald\n* Report correct type for decimal columns from MySQL 5.0 and later\n  [rt.cpan.org #18294], reported by Ray Zimmerman\n* Fix t/40bindparam.t to work when ANSI_QUOTES SQL_MODE is set.\n  [rt.cpan.org #21521], reported by David Wheeler\n* Return a statement handle with an error when column_info is called on\n  a table that does not exist. (Bug #23974, patch by Philip Stoev)\n* Fix handling of table names with characters that did not match /\\w/ in\n  the column_info method. (Bug #22005, reported by Philip Stoev)\n* Fix handling of negative integers bound to a column marked as SQL_INTEGER.\n  [rt.cpan.org #18976], patch from Mike Schilli.\n* Add support for the primary_key_info method. [rt.cpan.org #8541]\n* Fixed Bundle::DBD::mysql to only include modules required for using\n  DBD::mysql, not the old Mysql package. [rt.cpan.org #24096]\n* Updated Makefile.PL to not include files in .svn directories\n* Fixed various compile warnings in mysql.xs (ISO C)\n* Cleaned up stored procedure examples, made strict\n* Fixed bug that blew away subsequent result sets if you fetched all rows, only in\n  result sets that had more than one row\n* Added test for bug #14979 http://rt.cpan.org/Ticket/Display.html?id=14979, which still\n  fails\n* Tested with ALL mysql versions, fixed 40types, 40bind_param tests to work with 4.0, 4.1\n* Fixed dbdimp.c to not test for MYSQL_DATA_TRUNCATED unless >= mysql 5.0\n\n2006-12-22 Patrick Galbraith <patg at patg dot net>, Alexey Stroganov (4.00)\n* Added Alexey Stroganov's patch which fixes varying number of columns in\n  multiple result sets. Added new test cases to 80procs.t based of his\n  test script (bug #21028) (Thanks Alexey!). Also fixed 80procs.t to allow\n  'CALL' to be prepared\n* Added Philip Stoev's patch for DATA_TYPE date and time columns (bug #23988)\n  (Thanks Philip!)\n* Reworked (for working with 4.0, which doesn't support sqlstate) Philip Stoev's\n  patch for sqlstate, bug #23935 (Thanks Philip!)\n* New Versioning! 4.00 now. This dev tree will now become trunk\n* Cleaned up much code that failed between versions (!!!)\n* Turned off prepared statements by default\n* Tested this with 5.1, 5.0, 4.1, 4.0. Works with ALL these versions!\n\n2006-10-10 Patrick Galbraith <patg at patg dot net>, Alexey Stroganov (3.0009_1)\n* Added fbind and bind alloc to dbd_st_describe. This was causing a crash\n  when using with mod_perl\n\n2006-10-10 Patrick Galbraith <patg at patg dot net> (3.0008_1)\n* Added patch for SSL Verify Certificate (Thanks Eric Chen!)\n* Added multiple fixes to dbd_st_prepare which fixed variable overwrite\n  and unset increment counter. Also improved loop which checks statements\n  for presence of \"LIMIT\" by using a pointer as opposed to char array\n  increment variable. These errors were showing up in OpenBSD and other\n  Unixen (which I think all BSD-based) (Thanks to Kyle George!)\n* Added fix to Makefile.PL to obtain correct build flags on VMS\n  (Thanks to Eric Milkie!)\n* Fixed casting of num_params to unsigned int in calls to NewZ in mysql.xs\n\n2006-10-07 Patrick Galbraith <patg at patg dot net>, Jim Winstead <jimw@mysql.com>\n  (3.0007_2)\n  * Added UTF8 patch from Dominic Mitchell (Thanks!)\n  * Fixed declaration of \"row\" in mysql_st_internal_execute which caused compile\n    errors on some platforms\n  * Fix documentation for _ListDBs to remove incorrect information about\n    limitations of data_sources(). (RT #20843, patch by Ann Barcomb)\n  * Fix typo in example (missing quote). (RT #15086)\n  * Mention in POD that 'localhost' always means to connect via UNIX socket,\n    and 127.0.0.1 must be used for TCP/IP to localhost (RT #14942, reported by\n    Alessandro Ranellucci)\n  * Fix typos in Makefile.PL (RT#16178, reported by Gavin Shelley)\n\n2006-09-08 Jim Winstead <jimw@mysql.com>, Patrick Galbraith <patg@mysql.com>\n(3.0007_1) (3.0006/3.0006_1 is the same as 3.0005/3.0005_1)\n  * Make sure to call dbd_st_finish when all rows from a statement handle\n    have been fetched. (Bug #20153, Bug #21607, RT #20464, RT #21241)\n  * Patch from Steve Hay to fix bind_param to deal properly with insertion\n    of a NULL into an INT or DOUBLE column using server-side prepare.\n    Converted Steve's dbi.pl script to expose this problem to 40bindparam2\n    test.\n  * Fix to mysql_st_internal_execute to keep from passing undefined dbh\n    handle member (bind_type_guessing) to parse_param causing crash on\n    OpenBSD. Reported on rt.cpan.org (#20868) by Kyle Georg, as well as\n    info from Sam Smith and Federico Giannici\n  * Cleaned up tests to make sure test table is dropped at end of test.\n\n2006-06-10 Patrick Galbraith <patg@mysql.com) (3.0005)\n  * Fix dbd_st_finish in 3.0004 didn't clean up bind buffers resulting in\n    a memory leak. See eg/prepare_memory_usage.pl to see how this manifests\n    itself. Thanks to Jason Snell for giving me a good script to reproduce\n    this!\n  * Fix to parse_params, mysql.xs dbh->do, and bind_param to deal with\n    passing substr to \"do\" for placeholder value. Thanks Martin Waite for\n    the patch to parse_params (extended to mysql.xs \"do\" and bind_param for\n    server-side prepared statements.\n\n2006-05-17 Patrick Galbraith <patg@mysql.com) (3.0004_1)\n  * Fix dbd_st_finish which closed the handle prematurely (Martin Evans)\n  * Compile issues (Martin Evans)\n  * Small change to get utf8 data returned. One still has to:\n      $dbh->do(\"set character set utf8\");\n      $dbh->do(\"set names utf8\");\n\n    to get utf8 back and even then you only get it back if the\n    column is defined as utf8 in mysql.\n  * Fix to dbd_bind_ph to deal with numbers (ints, floats) correctly\n    (Alexey Stroganov)\n  * Test changes - bind_param 41 and 42\n  * Turned off 70takeimp test\n\n2006-04-29 Patrick Galbraith <patg@mysql.com) (3.0003_1)\n  * Removed old Msql-Mysql Driver emulation code - finally!!!\n  * Removed aweful string testing code (that I wrote) for unsported\n    statements and now use mysql_stmt_prepare, if statement not\n    supported, toggle to mysql_emulated_prepare\n  * Fixed bug where failed stmt execution caused later statements\n    to fail with mysql_stmt_reset\n  * Added tests for unsupported statements\n  * Added test for test of failed statement with subsequent executes\n    (thanks to Martin Evans!)\n  * Added typo fix (Martin Evans)\n  * Added support for ParamValues and associated test (Martin Evans)\n  * Removed old emulated driver tests (HOORAY!)\n  * Cleaned up debug printing code\n  * Fixed syntax for create table ENGINE=InnoDB instead of type=innobase\n  * Cleaned up tests\n\n2006-01-31 Patrick Galbraith <patg@mysql.com> (3.0002_5)\n  * Fixed bugs 15546 (selectcol_arrayref failing on SHOW TABLES)\n    and 15665, 'USE dbname' failing when driver is not in emulated\n    prepare mode\n\n2005-10-26 Patrick Galbraith <patg@mysql.com> (3.0002_4)\n  * Added Guy Harrison's patch for multiple result sets\n  * Fixed bugs with declarations in middle of functions\n  * Cleaned up code, rewrote several loops using pointers\n    instead of iterators\n  * Rewrote 'SHOW', 'ALTER', 'CALL', 'CREATE' toggling code that turns\n    off server prepared statements (these calls are not supported)\n  * Updated documentation\n\n2005-09-28 Patrick Galbraith <patg@mysql.com> (3.0002_3)\n  * Added code to  mysql_st_internal_execute that determines whether the\n    SV *h is a sth or dbh, and then imports imp_dbh appropriately\n\n2005-09-26 Patrick Galbraith <patg@mysql.com> (3.0002_2)\n  * Fixed bug in dbd_st_execute where imp_sth was being\n    imported unecessarily, when only imp_dbh is needed. This caused a\n    core dump in some cases. Thanks to Andy Maas at Proofpoint for his\n    execellent detective work!\n  * Small changes to Makefile.PL to make sure --ps-protocol works as\n    advertised.\n  * Updated install.html with current info about prepared statements and FC\n    RPM/YUM packages.\n\n2005-08-04 Patrick Galbraith <patg@mysql.com> (3.0002_1)\n  * Prepared statement support is default now. To turn it off\n    a parameter 'mysql_emulated_prepare' must be turned ON\n  * Better error handling in mysql_internal_execute_ps (renamed\n    from mysql_internal_execute41). Also free the result if error -\n    that could have been a memory bug\n  * Added a simply 'do' to t/35prepare.test to see if you can turn\n    off prepared statements in the 'do' call.\n  * Cleaned up a LOT of cruft. Added more 'caveat' blurbage to old\n    Mysql.pm lib, which will not work with prepared statements\n\n2005-07-06 Parick Galbraith <patg@mysql.com> (3.0001_3)\n  * Fix to ensure MYSQL_BIND is only defined when mysql\n    client version is >= 4.1.3. Thanks to Tom Parkison\n\n2005-07-06 Patrick Galbraith <patg@mysql.com> (3.0001_2)\n  * Fixed runtime bug (when inserting or updating quotes or double quotes)\n    (Thanks to Brad Choate, Six Apart Ltd.)\n\n2005-07-04 Patrick Galbraith <patg@mysql.com> (3.0001_1)\n  * Changed uint argument in safe_sv_fetch to int due to\n    uint not being available on windows unless you include\n    my_globals.h in dbdimp.h, which also breaks on unixen!\n  * Removed // comments from mysql.xs (thanks Bodo Bergman!)\n\n2005-07-03 Patrick Galbraith <patg@mysql.com> (3.0000_0)\n  * Special Thanks to Steve Hay for his patch to fix windows\n  * Fixed Makefile.PM for windows compiles\n  * Removed long long type from dbdimp.h\n  * Changed strncasecmp to strncmp (still need a better long-term solution)\n    in dbdimp.c\n  * Modified Makefile.PM to make prepared statements on by default\n\n2005-04-26 Patrick Galbraith <patg@mysql.com> (2.9015_3)\n  * Added patch from Stas Beckman for new DBI feature take_imp_data, needed\n   for DBI::Pool\n  * Fix to Statement.pm for old API call for numfields that caused\n    warnings on 40numrows and akmisc tests\n  * Fix to bind_ph to throw an error if trying to bind a non-numeric\n    value as numeric\n  * Better fix for dealing with error condition in $sth->rows()\n  * Fix to bind_param to throw error when trying to bind a non-numeric as\n    numeric\n\n\n2005-04-04 Patrick Galbraith <patg@mysql.com> (2.9015_2)\n  * Merged all code changes from 2.900x tree from the last 9\n    months\n    - unsafe bind type guessing patch from Dragonchild\n    - Removed mysql.mtest\n    - Fixed sth->rows to return my_ulongloong and also handle\n      error from client API\n    - Fix to make autocommit work was already part of this version\n    - Auto-reconnect bug fixed in 2.9006 included\n  * Added simple test to 35limit test to check if using malicious code in\n   LIMIT ?, ? placeholders works, which it doesn't.\n  * Fix that sets mysql_server_prepare to 0 if SQL statement is 'SHOW ...'\n    which is not supported by prepared statement API currently\n\n2004-10-28 Rudolf Lippan <rlippan@remotelinux.com> (2.9015_1)\n\t* Merged Makefile.PL from 2.9005_3\n\t* Bumped version number to 2.9015 for release of Dev Branch. Which\n\t  will become 2.9020 when tested and merged into HEAD.\n\t* fixed typo/compiler warning in bind_param_guessing\n\t  '*testchar' should have been 'testchar'.\n\n2004-10-20 Patrick Galbraith patg@mysql.com (Dev-2_9 - 2.9005)\n\n  * merged changes from 2.9005_1\n  * fix to blob in dbd_st_fetch (Alexey Stroganov ranger@mysql.com)\n  In case of BLOB/TEXT fields we allocate only 8192 bytes in dbd_describe()\n  for data. Here we know real size of field so we should increase buffer\n  size and refetch column value\n\n2004-07-25 Patrick Galbraith patg@mysql.com (2.9004)\n  * Prepared statement support\n* Use of mysql_stmt_* API (>= 4.1.3)\n  * mysql_shutdown fix\n* MySQL Embedded Server support (Alexey Stroganov)\n  * Fixed link failure on MacOSX\n  * Cleaned up tests\n  * Fixed various compile warnings\n\n\n2003-10-26  Rudy Lippan  <rlippan@remotelinux.com> (2.9003)\n\t* Applied patch from Aaron and Chuck that added basic testing of the\n\t  table_info/column_info functions [Aaron Ross <aross@plusthree.com>]\n\t* Applied patch removing Jochen Wiedmann's contanct information and\n\t  also removing the restriction on CD ROM distribution.\n\t  [Jochen Wiedmen <joe@ispsoft.de>]\n\t* The check for the innodb table type was broken so the transaction\n\t  tests were skipped even though the database supported transactions.\n\t* :sql_types were not being inported in column info, so SQL_VARCAR was\n\t  thowing an error. Also, the :sql_types were not being pulled into\n\t  DBD::mysq::db package\n\t* Patch for  dbdadmin.t so that it respects username and password\n\t  [Alexey Stroganov <ranger@mysql.com>]\n\t* Fix for memory leak in bind_param() introduced in 2.9002\n\t  (2.9002 changed bind_param so that changing the value of a scalar\n\t  after binding would not affect what was passed to execute eg:\n\t     $sth->bind_param(1,$foo);\n\t     $foo = 'bar'\n\t     $sth->execute() -- $foo would contain 'bar')\n\t  [reported by <shildreth@emsphone.com>]\n\t* don't define dbd_discon_all so that mysql uses DBI's This fixes a\n\t  bug whereby DBD::mysql was dropping perl's destruct level.\n\t* patch to myld so that it uses strict and fixes scoping problem\n\t  with $contents [Jochen Wiedmann <joe@ispsoft.de>]\n\t* Modified Makefile.PL so that it gives a usage message\n\t  if any unknown options are passed in.\n\t* patch to INSTALL.pod on how to link DBD::mysql against\n\t  a static libmysqlclient [Jochen Wiedmann <joe@ispsoft.de>]\n\n2003-06-22  Rudy Lippan  <rlippan@remotelinux.com> (2.9002)\n\t* moved pod into mysql.pm from mysql.pod\n\t* Changed the default behaviour of mysql_found_rows, so now\n\t  'UPDATE table set field=?' will return the number of rows matched\n\t  and not the number of rows physically changed. You can get the old\n\t  behaviour back by adding \"mysql_found_rows=0\" to the dsn passed\n\t  to connect.\n\t* Updated type_info_all() to be more inline with\n\t  what DBD::ODBC returns.\n\t* Added attribute 'mysql_auto_reconnect' that allows the auto reconnect\n\t  behaviour to be toggled. :\n\n\t  ** NOTE** The behaviour of auto reconnect has changed.  If\n\t  either the MOD_PERL or the GATEWAY_INTERFACE environment variable is\n\t  set, auto_reconnect will default to ON; otherwise auto_reconnect\n\t  will default to off.  Earlier versions of this driver would always\n\t  try to reconnect to the database on error; however, this is dangerous\n\t  because table locks could be lost without the application knowing.\n\n\t* Fixed a segfault with failed reconnects that were trapped in an\n\t  eval. The next tine DBD::mysql tried to reconnect, the process\n\t  would segfault.\n\t* Added statistics attribute, 'mysql_dbd_stats' which returns\n\t  a hash ref that contains 2 keys 'auto_reconnects_ok' and\n\t  'auto_reconnects_failed'.\n\t* Fixed bug where strings that were used in numeric\n\t  context were not getting quoted on execute(). Now all\n\t  parameters are bound as varchar by default.\n\n\t  **NOTE** this is a change in behaviour that MAY cause problems\n\t  with some SQL statements. If quoted integers, for example,\n\t  cause any problems, use bind_param(<column_id>, undef, SQL_INTEGER)\n\t  to force a column to be bound as an integer.\n\n\t* Added get_info() method. See 'perldoc DBI' for more info\n\t* Added column_info(). See 'perldoc DBI' for more info [Tim Bunce]\n\n2003-03-03  Jochen Wiedmann  <joe@ispsoft.de> (2.1026)\n\n\t* Fixed the handling of case insensitive file\n\t  names. Jan Dubois, <jand@ActiveState.com>\n\t* lib/Mysql.pm (listdbs): Added support for user\n\t  name and password.\n\n2003-01-21  Jochen Wiedmann <joe@ispsoft.de> (2.1025)\n\n        * lib/DBD/mysql.pm: added support for optional\n          DBI->data_sources() \\%attributes parameter.\n          Georg Rehfeld, <georg.rehfeld@gmx.de>\n        * lib/DBD/mysql.pod: documented optional\n          DBI->data_sources() \\%attributes parameter.\n          Georg Rehfeld, <georg.rehfeld@gmx.de>\n        * t/dbdadmin.t: changed to use optional\n          DBI->data_sources() \\%attributes parameter.\n          Georg Rehfeld, <georg.rehfeld@gmx.de>\n\n2003-01-20  Jochen Wiedmann <joe@ispsoft.de> (2.1024)\n\n\t* dbdimp.c: Fixed missing support for double quotes\n\t  in ParseParam. JUERD@cpan.org\n\t* Test suite: Multiple patches for Windows/CygWin (case\n\t  insensitive file names and the like). Georg Rehfeld,\n\t  <georg.rehfeld@gmx.de>\n\t* lib/DBD/mysql/INSTALL.pod: Added description on how\n\t  to install with Windows/CygWin. Georg Rehfeld,\n\t  <georg.rehfeld@gmx.de>\n\n2003-01-18  Jochen Wiedmann  <joe@ispsoft.de> (2.1023)\n\n\t* Remove compiler warnings\n\t  Fix some small issues to get it to work with MySQL 4.1\n\t  (Mostly checking return values from MySQL API functions)\n\t  Michael Widenius  <monty@mysql.com> (2.1022a)\n\n\n2003-01-03  Jochen Wiedmann  <joe@ispsoft.de> (2.1022)\n\n\t* Added hints to Randy Kobes PPM repository, because\n\t  DBD::mysql is currently missing in ActiveState's\n\t  repository.\n\n2002-11-18  Jochen Wiedmann  <joe@ispsoft.de> (2.1021)\n\n\t* lib/Mysql.pm (errno): Added handling for non-ref\n\t  arguments. Raphael Hertzog <rhertzog@hrnet.fr>\n\n2002-09-23  Jochen Wiedmann  <joe@ispsoft.de> (2.1020)\n\n\t* Added mysql_local_infile option. (Paul DuBois,\n\t  paul@snake.net)\n\n2002-09-16  Jochen Wiedmann  <joe@ispsoft.de> (2.1019)\n\n\t* Added hints to installing DBD::mysql with PPM 3.\n\t  (Stefan Prehn, stefanprehngmx.de)\n\t* Added $DBD::mysql::CLONE\n\n2002-08-12  Jochen Wiedmann  <joe@ispsoft.de> (0.2018)\n\n\t* t/dbdadmin.t: The call to func('createdb') was\n\t  missing user name and password. Wolfgang Friebel\n\t  <friebel@ifh.de>\n\t* mysql.xs: If the connect in func('...', 'admin')\n\t  failed, a core dump was triggered. Wolfgang\n\t  Friebel <friebelqifh.de>\n\n2002-05-02  Jochen Wiedmann  <joe@ispsoft.de> (0.2017)\n\n\t* dbdimp.c: Added a required check for mysql_errno.\n\t  Steve Hay <Steve.Hay@uk.radan.com>\n\n2002-05-01  Jochen Wiedmann  <joe@ispsoft.de> (0.2016)\n\n\t* dbdimp.c: Removed use of mysql_eof. Jay\n\t  Lawrence <jay@lawrence.net>\n\n2002-04-30  Jochen Wiedmann  <joe@ispsoft.de> (0.2015)\n\n\t* Makefile.PL: Removed dbimon and pmysql from\n\t  the EXE_FILES list. Andreas Koenig\n\t  <andreas.koenig@anima.de>\n\n2002-04-17  Jochen Wiedmann  <joe@ispsoft.de> (2.1014)\n\n\t* dbdimp.c: Fixed mysql_is_auto_increment.\n\t  Paul Walmsley <shag-dbdmysql@booyaka.com> and\n\t  Paul Dubois <paul@kitebird.org>\n\n2002-04-12  Jochen Wiedmann  <joe@ispsoft.de> (2.1013)\n\n\t* dbdimp.c: Added use of mysql_ssl_set.\n\t  Chris Hanes <chanes@i-c.net>\n\n2002-04-12  Jochen Wiedmann  <joe@ispsoft.de> (2.1012)\n\n\t* Some fixes in the docs. Paul Dubois <paul@kitebird.com>\n\t* Added mysql_is_auto_increment. (Someone else, but forgot\n\t  his email, sorry!)\n\n2002-02-12  Jochen Wiedmann  <joe@ispsoft.de> (2.1011)\n\n        * Makefile.PL: DBI::DBD is no longer loaded by\n          default, to allow CPAN's requirements detection\n          note and install a missing DBI.\n\n2001-12-28  Jochen Wiedmann  <joe@ispsoft.de> (2.1010)\n\n\t* Bumped version number in Mysql/Statement.pm to\n\t  1.24, so that it is always higher than that\n\t  from the Msql-Mysql-modules.\n\n\n2001-12-28  Jochen Wiedmann  <joe@ispsoft.de> (2.1008)\n\n\t* lib/DBD/mysql.pod: Fixed minor bug in an example.\n\n2001-12-27  Jochen Wiedmann  <joe@ispsoft.de> (2.1007)\n\n\t* Bumped version number in Mysql.pm to 1.24, so that\n\t  it is always higher than that from the Msql-Mysql-\n\t  modules.\n\n2001-12-27  Jochen Wiedmann  <joe@ispsoft.de> (2.1006)\n\n\t* Within AutoCommit mode, reconnect is now turned\n\t  off, because the transaction state is unpredictable\n\t  otherwise.\n\n2001-12-13  Jochen Wiedmann  <joe@ispsoft.de> (2.1005)\n\n\t* dbdimp.c: Added use of SvMAGICAL to dbd_db_quote.\n\t  Rudy Lippan <almighty@randomc.com>\n\n2001-11-13  Jochen Wiedmann  <joe@ispsoft.de> (2.1004)\n\n\t* Makefile.PL: Fixed handling of --testdb, --testuser, ...\n\n2001-11-05  Jochen Wiedmann  <joe@ispsoft.de> (2.1003)\n\n\t* bind_param now using mysql_real_escape_string\n\t  as well. Dave Rolsky <autarch@urth.org>\n\n2001-11-04  Jochen Wiedmann  <joe@ispsoft.de> (2.1002)\n\n\t* Added mysql_ssl flag to DBI->connect.\n\n2001-11-04  Jochen Wiedmann  <joe@ispsoft.de> (2.1001)\n\n\t* Quoting now based on mysql_real_escape_string. Thanks\n\t  to Dave Rolsky <autarch@urth.org> for suggesting this.\n\n2001-11-02  Jochen Wiedmann  <joe@ispsoft.de> (2.1000)\n\n\t* Portability changes for MySQL 4.\n\n2001-05-25  Jochen Wiedmann  <joe@ispsoft.de> (2.0901)\n\n\t* dbdimp.c: Fixed $dbh->{mysql_insertid}; added t/insertid.t\n\n2001-04-01  Jochen Wiedmann  <joe@ispsoft.de> (2.0900)\n\n\t* Added transaction support for MySQL.\n\t  (Bob Lyons <lyons@nextrials.com>)\n\t* dbd/dbdimp.c: Fixed MAXLENGTH warning; used to hint for\n\t  a not existing mysql_maxlength, which should read\n\t  mysql_max_length. (Paul DuBois <paul@snake.net>)\n\t* Fixed installation problem when a directory was specified,\n\t  but did not exist. (Will Partain <partain@dcs.gla.ac.uk>)\n\t* Fixed that mysql_errno wasn't used properly. (Chris Adams\n\t  <cmadams@hiwaay.net>)\n\t* Fixed test suite problem, when user name and password\n\t  have been interpolated. (Bruno Hivert (LMC)\n\t  <lmcbrhi@lmc.ericsson.se>)\n\t* mysql_insertid and mysql_affectedrows are no longer treated\n\t  as integers, but longs. Thanks to Michael G Schwern\n\t  <schwern@pobox.com>.\n\n2000-08-20  Jochen Wiedmann  <joe@ispsoft.de> (1.2215)\n\n\t* lib/DBD/mysql/Install.pm (Initialize): Adding -lz -lgz by\n\t  default now.\n\t* dbd/dbd.pm.in: Minor doc change.\n\n2000-05-10  Jochen Wiedmann  <joe@ispsoft.de> (1.2214)\n\n\t* dbd/dbdimp.c: Fixed bug that timestamp fields weren't quoted.\n\t  Chris Winters <cwinters@intes.net>\n\n2000-04-26  Jochen Wiedmann  <joe@ispsoft.de> (1.2213)\n\n\t* dbd/dbimon.in: Fixed tags in pod.\n\n2000-04-15  Jochen Wiedmann  <joe@ispsoft.de> (1.2212)\n\n\t* Makefile.PL: Fixed use of builder-provided passwords.\n\t  Buck Huppmann <buckh@pobox.com>\n\t* Makefile.PL: Fixed WIN32 installation.\n\n2000-04-03  Jochen Wiedmann  <joe@ispsoft.de> (1.2211)\n\n\t* Fixed $dbh->{Name} (David Jacobs <djacobs@mitre.org>)\n\n1999-11-30  Jochen Wiedmann  <joe@ispsoft.de> (1.2210)\n\n\t* Makefile.PL (SelectDrivers): Hopefully ensured that a README is\n\t  always created successfully.\n\t* Makefile.PL: Fixed docs of --mysql-install etc. (loic@ceic.com)\n\n1999-10-13  Jochen Wiedmann  <joe@ispsoft.de> (1.2209)\n\n\t* Fixed bug in $dbh->tables(): Didnt't work with\n\t  empty databases.\n\n1999-09-17  Jochen Wiedmann  <joe@ispsoft.de> (1.2208)\n\n\t* dbd/bindparam.h: Added support for MySQL's double\n\t  quotes. (Although I don't like it. :-)\n\t* dbd/dbd.pm.in: Fixed a lot of docs for deprecated\n\t  features in favour of current.\n\t* Makefile.PL: Fixed use of -e (should be exists).\n\t  tschulth@debis.com (Thomas Schultheis)\n\t* MONEY seems to be a numeric type with mSQL.\n\t  Ernst Paalvast <ernst@esdmm.nl>\n\n1999-09-15  Jochen Wiedmann  <joe@gate.ispsoft.de> (1.2207)\n\n\t* dbd/dbdimp.c: Added mysql_connect_timeout.\n         Matthias Urlichs (<smurf@noris.de>)\n\n1999-08-29  Jochen Wiedmann  <joe@ispsoft.de> (1.2206)\n\n\t* dbd/dbimon.in: Fixed a bug in tab completion. (FieldList was\n\t  used in scalar context). Thanks to \"Scott R. Every\" <scott@emji.net>\n\t* lib/DBD/mysql/Install.pm (Initialize): Now checking for MySQL\n\t  version 3.22 or later.\n\n1999-08-22  Jochen Wiedmann  <joe@ispsoft.de>\n\n\t* lib/DBD/mysql/Install.pm (Initialize): Added sco\\d+* to the list\n\t  of SCO-like operating systems. Thanks to Jukka Inkeri\n\t  <Jukka.Inkeri@netstar.fi>\n\n1999-08-22  Jochen Wiedmann  <joe@ispsoft.de> (1.2203)\n\n\t* dbd/dbd.xs.in: Fixed a memory leak in $dbh->quote().\n\t  Arun Bhalla <abhalla@usgs.gov>\n\n1999-07-22  Jochen Wiedmann  <joe@ispsoft.de> (1.2202)\n\n\t* dbd/dbd.pm.in: The hint for experimental software is now\n\t  enabled or disabled automatically, thanks to ExtUtils::PerlPP.\n\t* dbd/dbdimp.c: Changed fprintf to PerlIO_printf, required by\n\t  DBI 1.14.\n\t* nodbd/nodbd.pm.in (quote): Changed ~DBD_DRIVER~ to\n\t  ~~dbd_driver~~, thanks to Maurice Aubrey <maurice@hevanet.com>.\n\n1999-07-08  Jochen Wiedmann  <joe@ispsoft.de> (1.2201)\n\n\t* lib/DBD/mSQL/Install.pm (Initialize): Fixed an ugly bug, that\n\t  caused unusable Config.pm files.\n\n1999-03-09  Jochen Wiedmann  <joe@ispsoft.de>\n\n\t* lib/DBD/mysql/Install.pm (CheckForLibGcc): No longer linking\n\t  against libgcc.a with OpenBSD.\n\t* nodbd/nodbd.pm.in (selectdb): Calling selectdb twice triggered\n\t  a warning. (Nick Hibma <nick.hibma@jrc.it>)\n\t* dbd/dbdimp.c: Date and time types now have literal_prefix and\n\t  suffix set to \"'\".\n\n1999-01-25  Jochen Wiedmann  <joe@ispsoft.de> (1.21_15)\n\n\t* dbd/myMsql.h: mSQL 2.0.6 requires including common/\n\t  portability.h.\n\t* dbd/dbdimp.c: Fixed some instances of ~var~ to ~~var~~.\n\t* Makefile.PL: Added PREREQ_PM to WriteMakefile options.\n\t* Renamed Bundle::M(y)sql to Bundle::DBD::mysql and\n\t  Bundle::DBD::mSQL.\n\n1999-01-05  Jochen Wiedmann  <joe@ispsoft.de> (1.21_13)\n\n\t* nodbd/nodbd.pm.in (query): Now setting $db_errstr\n\t  (Andreas K\u00f6nig, andreas.koenig@anima.de).\n\t* dbd/dbdimp.c (dbd_db_quote): Giving up to use \"NULL\" as a\n\t  static string. :-( My thanks to David Foo (dfoo@web.fairfax.com.au)\n\t  and Christian Schwarz (schwarz@monet.m.isar.de) for convincing\n\t  me.\n\t* nodbd/nodbd.pm.in (listdbs): Now setting $db_errstr.\n\n1998-12-30  Jochen Wiedmann  <joe@ispsoft.de> (1.21_12)\n\n\t* dbd/dbd.pm.in (prepare): Fixed missing attribs argument.\n\t  Thanks to Peter Ludemann (ludemann@inxight.com).\n\t* dbd/dbdimp.c: Portability fixes for Perl 5.005_54.\n\n1998-12-29  Jochen Wiedmann  <joe@ispsoft.de> (1.21_11)\n\n\t* Makefile.PL: .pm files are no longer removed, because\n\t  they are missing in MANIFEST otherwise.\n\n1998-12-22  Jochen Wiedmann  <joe@ispsoft.de> (1.21_09)\n\n\t* INSTALL: Updated the WIN32 INSTALLATION section.\n\t* nodbd/statement.pm.in (fetchrow): Enhanced compatibility to\n\t  previous Msql versions by returning the first column now in\n\t  scalar context. (Andreas K\u00f6nig, andreas.koenig@anima.de)\n\t* Makefile.PL (Init): Default of installing Msql, Mysql and Msql1\n\t  is now \"no\", unless you already have the Mysql emulation layer\n\t  installed.\n\t* Makefile.PL: Added --config option.\n\n1998-11-20  Jochen Wiedmann  <joe@ispsoft.de> (1.21_08)\n\n\t* lib/DBD/mysql/Install.pm (Initialize): Added -lc on Unixware;\n\t  thanks to Orion Poplawski <orion@bvt.com>.\n\t* lib/DBD/mysql/Install.pm (Initialize): Added -lzlib on Win32.\n\t* dbd/dbd.pm.in (connect): Added $dbh->{'Name'}.\n\t* t/dbdadmin.t: Forgot to change _DropDB to func(\"dropdb\",\n\t  ..., \"admin). My thanks to schinder@pobox.com.\n\t* Some patches for compatibility with ActiveState Perl.\n\n1998-11-08  Jochen Wiedmann  <joe@ispsoft.de> (1.21_07)\n\n\t* _ListTables is now obsolete.\n\t* _InsertID, affected_rows, IS_PRI_KEY, is_pri_key, IS_NOT_NULL,\n\t  is_not_null, IS_KEY, is_key, IS_BLOB, is_blob, IS_NUM, is_num,\n\t  LENGTH, length, MAXLENGTH, maxlength, NUMROWS, NUMFIELDS,\n\t  RESULT, result, TABLE, table, format_max_size, format_default_size\n\t  and format_type_name are now deprecated.\n\t* _CreateDB, _DropDB, _ListFields, _ListSelectedFields and\n\t  _NumRows have been removed.\n\t* dbd/dbd.xs.in: $dbh->func('_ListDBs') was closing the socket.\n\t  Thanks to Lars Kellogg-Stedman <lars@wolery.bu.edu>.\n\t* dbd/dbd.pm.in: $drh->func('_ListDBs' was documented wrong.\n\t  Thanks to Lars Kellogg-Stedman <lars@wolery.bu.edu>.\n\n1998-11-06  Jochen Wiedmann  <joe@ispsoft.de> (1.21_06)\n\n\t* dbd/dbdimp.c: Changed isspace(c) to c == ' ' in ChopBlanks\n\t  handling.\n\t* dbd/dbdimp.c: Added $dbh->{'mysql_read_default_file'} and\n\t  $dbh->{'mysql_read_default_group'}.\n\t* dbd/dbdimp.c: Added $dbh->{'mysql_insertid'}.\n\n1998-10-23  Jochen Wiedmann  <joe@ispsoft.de> (1.21_05)\n\n\t* dbd/dbd.xs.in: Fixed bug in $dbh->quote($n, SQL_INTEGER).\n\t* Makefile.PL (CheckForLibGcc()): Disabled linking against\n\t  libgcc.a under NetBSD. (Curt Sampson, cjs@portal.com)\n\t* Forgot to remove the warning for experimental software.\n\t* Added Monty's patches for use of mysqlclients.\n\t* dbd/dbdimp.c: Added msql_configfile.\n\t* Makefile.PL: Added option -static.\n\n1998-10-06  Jochen Wiedmann  <joe@ispsoft.de> (1.21_04)\n\n\t* INSTALL: Added hints for Win32 installation.\n\t* lib/DBD/mysql/Install.pm: Added portability fixes for Win32\n\t  installation with MyODBC. This is now the recommended way of\n\t  installing DBD::mysql under Win32.\n\n1998-09-27  Jochen Wiedmann  <joe@ispsoft.de> (1.21_02)\n\n\t* INSTALL: Added a hint for Remote_Access in msql.conf\n\t* nodbd/nodbd.pm.in (quote): Made quote a class method; Andreas\n\t  K\u00f6nig <koenig@anna.mind.de>.\n\t* dbd/myMsql.h (MyReconnect): Fixed $dbh->ping() for MySQL.\n\t  My thanks to Nikki Chumakov (nikki@paranoia.ru).\n\t* dbd/dbimon.in: Added dump mode.\n\t* dbd/dbimon.in: TableList now based on $dbh->tables(), thus\n\t  portable.\n\t* dbd/dbimon.in: Shell completion with TableList case independent.\n\t* tests/60leaks.t: No longer calling exit() within BEGIN.\n\t  (Workaround for a bug within Perl 5.00404)\n\t* tests/ak-dbd.t: Removed \"local $sth->{PrintError} = 0\"; yet\n\t  another workaround.\n\n1998-07-28  Jochen Wiedmann  <joe@ispsoft.de> (1.21_00)\n\n\t* INSTALL: Added a description of the missing-libgcc problem.\n\t* INSTALL: Added a patch for the mSQL problem with ORDER BY.\n\t* dbd/dbd.pm.in: Added a description of mSQL's problem with\n\t  ORDER BY.\n\t* Fixed pointers to DBI home (was www.hermetica.com, now\n\t  www.arcana.co.uk)\n\t* lib/DBD/mysql/Install.pm (Initialize): Added\n\t  $ENV{'MYSQL_HEADERDIR'} and $ENV{'MYSQL_LIBDIR'}.\n\t* dbd/dbdimp.c: mysql_fetch_lengths() returns longs under\n\t  MySQL 3.22.04\n\t* nodbd/nodbd.pm.in (errno): Fixed missing definition of\n\t  $self.\n\t* Makefile.PL (InitializeMysql): Looking for libmysqlclient.a\n\t  and libmysqlclient.so now.\n\t* dbd/dbdimp.c (dbd_st_internal_execute): Fixed memory leak,\n\t  *cdaPtr was not checked for <> NULL. My thanks to Marc\n\t  Lehmann <pcg@goof.com> for the report.\n\t* dbd/dbd.pm.in: Added table_info().\n\n1998-07-16  Jochen Wiedmann  <joe@ispsoft.de> (1.19_22)\n\n\t* dbd/dbdimp.c: Added dTHR to some more functions for 5.005\n\t  compatibility. Thanks to Chris Leach\n\t  <leachcj@vegemite.mel.az.bp.com>.\n\t* nodbd/statement.pm.in: Changed length to CORE::length in\n\t  some cases to prevent 5.005 warnings.\n\t* Added a section on multithrading to the manual.\n\n1998-07-07  Jochen Wiedmann  <joe@ispsoft.de> (1.19_21)\n\n\t* nodbd/nodbd.pm.in (query): Fixed a missing \"bless($sth, ...)\".\n\t  My thanks to Ray Zimmermann <rz10@cornell.edu>. (Gives me\n\t  a familiar feeling to always meet the same people ... :-)\n\n1998-07-06  Jochen Wiedmann  <joe@ispsoft.de> (1.19_20)\n\n\t* Makefile.lib (InitializeMsql): Added /usr to the search path\n\t  for mSQL headers and libraries.\n\t* tests/msql1.t (unctrl): Renamed \"character\" column to\n\t  \"chrctr\". (\"character\" is not a valid column name under\n\t  msql-2.0.4.1)\n\t* dbd/dbd.xs.in (DBD::mysql::ping): Now using mysql_ping().\n\t* dbd/dbdimp.c (_MyLogin): Added mysql_compression.\n\n1998-06-25  Jochen Wiedmann  <joe@ispsoft.de> (1.19_19)\n\n\t* dbd/dbdimp.c: Added $sth->{mysql_type} and\n\t  $sth->{msql_type}, which are in fact just what\n          $sth->{TYPE} used to be. $sth->{TYPE} is now\n\t  returning portable SQL types.\n\t* MANIFEST: Removed nodbd/Makefile.PL.in.\n\t* Makefile.PL: Made test databases configurable.\n\n\n1998-06-14  Jochen Wiedmann  <joe@ispsoft.de> (1.19_18)\n\n\t* Makefile.PL: dbdadmin.t was missing in the list of tests\n\t* nodbd/nodbd.pm.in (query): Now really returning undef in\n\t  case of errors. (Possible Perl bug?)\n\t* Makefile.PL: Fixed realclean attribute of WriteMakefile.\n\t* Makefile.PL (Init): Setting $Data::Dumper::Indent to 1.\n\t* Makefile.PL (InitializeMsql): Fixed query for mSQL, if\n\t  only one version gets installed.\n\t* dbd/dbdimp.c: Now calling mysql_init before mysql_connect.\n\t* dbd/dbdimp.c: For whatever reason, MyGetProtoInfo was\n\t  treated like returning a char* under Mysql.\n\n\n1998-05-16  Jochen Wiedmann  <joe@ispsoft.de> (1.19_17)\n\n\t* Makefile.PL: Fixed typo in InitializeMsql (dbiDriver = mSQL1).\n\t* dbd/dbdimp.c: mysql_real_connect is now using a dbname\n\t  argument\n\n\n1998-05-07  Jochen Wiedmann  <joe@ispsoft.de> (1.19_16)\n\n\t* dbd/dbdimp.c: ChopBlanks no longer chops from the left side.\n\t* dbd/dbdimp.c: Fixed memory leak in dbd_st_FETCH_internal.\n\n\n1998-04-13  Jochen Wiedmann  <joe@ispsoft.de> (1.19_15)\n\n\t* Added the DBD::mSQL1 and Msql1 drivers.\n\t* Fixed minor icompatibilities with perl 5.005.\n\t* nodbd/nodbd.pm.in (errmsg): Msql->errmsg() should\n\t  now recognize error messages in $DBI::errstr (hopefully ...)\n\n\n1998-04-03  Jochen Wiedmann  <joe@ispsoft.de> (1.19_13)\n\n\t* dbd/dbdimp.c: msqlGetProtoInfo returns an int, not a\n\t  char* (Erik Bertelsen, erik@mediator.uni-c.dk)\n\t* dbd/dbdimp.c: Fixed typo in _MyLogin: User was set to\n\t  NULL when password had zero length. (Erik Bertelsen,\n\t  erik@mediator.uni-c.dk)\n\t* dbd/dbdimp.c: One more time fixing reconnect problems with Mysql\n\t  and old client libraries (without mysql_real_connect it's just too\n\t  ugly! :-(\n\n\n1998-03-15  Jochen Wiedmann  <joe@ispsoft.de> (1.19_11)\n\n\t* Makefile.PL: Fixed Bugs in _OdbcParse and version numbers.\n\t* dbd/dbimon.in: Fixed bugs in export mode (Nem W. Schlecht\n\t  <nem@abattoir.cc.ndsu.nodak.edu>)\n\n\n1998-02-26  Jochen Wiedmann  <joe@ispsoft.de> (1.19_10)\n\n\t* M(y)sqlPerl now emulated by DBI drivers.\n\t* dbd/dbdimp.c: Added $dbh->{'info'} and $dbh->{'thread_id'}\n \t  (mysql only)\n\t* dbd/dbimon.in: Fixed minor bug in \"rel db test\"\n\t* dbd/dbimon.in (Connect): Added noecho mode for entering\n\t  passwords.\n\t* dbd/myMsql.c: Fixed bugs in OdbcParse.\n\n1998-02-06  Jochen Wiedmann  <joe@ispsoft.de> (1.19_03)\n\n\t* dbd/dbd.xs.in: Fixed $dbh->quote(undef) to return \"NULL\"\n\t  and not 'undef'.\n\t* Requires DBI 0.93. (I assume it still works with 0.91, but\n\t  whoever reinstalls Msql-Mysql-modules can well reinstall\n\t  DBI.)\n\t* dbd/dbdimp.c: $sth->fetch* now inactivates the sth in case\n\t  of errors or no more data; this follows the specification of\n\t  the 'Active' attribute.\n\t* Added a missing DROP TABLE in ak-dbd.t.\n\t* Added ODBC style DSN's like DBI:mysql:database=test;host=localhost.\n\n1998-01-20  Jochen Wiedmann  <joe@ispsoft.de> (1.19_02)\n\n\t* dbd/dbd.xs.in (quote): Fixed \"int len\" to \"STRLEN len\"; the\n\t  Irix compiler refuses to compile this. (A little bit picky,\n\t  a warning would really be sufficient here ...) My thanks to\n\t  Simon Matthews <sam@peritas.com>.\n\t* Added \"LISTINDEX\" handling.\n\t* Makefile.lib: Now always linking against libgcc.a when using gcc\n\t  and compiling for MySQL.\n\t* tests/mysql.dbtest: Now using \"IS NULL\" in SQL queries instead\n\t  of \"= NULL\". (Required as of mysql 3.21.22)\n\n1998-01-18  Jochen Wiedmann  <joe@ispsoft.de> (1.19_01)\n\n\t* README: Added hint for not using msqlperl mailing lists\n\t  except for MsqlPerl and MysqlPerl related things.\n\t* Makefile.lib: Modified version number to contain underscores,\n\t  so that CPAN considers 1.18xx as the correct version.\n\t* dbd/dbimon.in: Leaving pager mode worked unreliable; fixed.\n\t  Andreas Koenig <koenig@anna.mind.de>\n\t* tests/akmisc.t, tests/mysql.t, tests/mysql2.t: Minor modifications\n\t  in the connect parameters for passing the test suite under\n\t  Windows/NT.\n\n1998-01-07  Jochen Wiedmann  <joe@ispsoft.de> (1.1900)\n\n\t* dbd/dbd.xs.in: Implemented $dbh->quote() in XS.\n\t* dbd/dbd.xs.in: Added '_Admin' function.\n\t* dbd/dbd.xs.in, dbd/dbdimp.c: Added automatic reconnect when\n\t  mysql returns CR_SERVER_GONE_ERROR.\n\t* Makefile.lib (InitializeMysql): Modified order of -I statements\n\t  (Inside MySQL distribution it can happen that headers of recently\n\t  installed DBI versions are used instead of the correct headers.)\n\t* nodbd/nodbd.xs.in, nodbd/typemap: Supressed warning for\n\t  undef'd argument in connect method. (Chris Holt,\n\t  <xris@migraine.stanford.edu>)\n\t* nodbd/nodbd.xs.in: Fixed definition of 'HOST' attribute\n\t  in dbh's.\n\t* Makefile.lib (InitializeMsql): Fixed typo that made MSQL_HOME\n\t  useless. (Ray Zimmermann, <rz10@cornell.edu>)\n\t* Makefile.lib (InitializeMysql): Fixed typo \"lib/mysqlclient.a\"\n\t  to \"lib/libmysqlclient.a\". (Michael 'Monty' Widenius,\n\t  <monty@tcx.se>)\n\n1997-12-31  Jochen Wiedmann  <joe@ispsoft.de> (1.1823)\n\n\t* Added support for mysql_use_result, requested by Jesse\n\t  Eversole <jee@marketdriven.com>.\n\t* nodbd/typemap: Replaced sv_isa with sv_derived_from so that\n\t  subclassing works, reported by Gisle Aas <gisle@aas.no>.\n\n1997-12-11  Jochen Wiedmann  <joe@ispsoft.de> (1.1822)\n\n\t* dbd/myMsql.c: DSN's like DBI:mysql:test;hostname=$host;port=$port\n\t  haven't been working.\n\t* dbd/dbimon.in: POD modifications, suggested by Jesse N. Glick\n\t  <jglick@sig.bsh.com>\n\t* INSTALL: Added hints for \"make test\".\n\t* nodbd/statement.pm.in (as_string): Still bugs in the new\n\t  as_string method, thanks to Frank D. Cringle <fdc@cliwe.ping.de>.\n\t* Enabled SQL_DATE, SQL_TIME, ... (available in DBI 0.91)\n\t* Makefiles: Modified postamble to use a common function which calls\n\t  module dependent hooks.\n\t* nodbd/nodbd.xs.in/fetchinternal: Fixed the problem RETVAL == NULL.\n\nWed Nov 19 19:50:29 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1821)\n\n\t* dbd/dbd.pm.in: Added AUTOLOAD for constants like\n\t  DBD::mysql::FIELD_TYPE_STRING or DBD::mSQL::CHAR_TYPE.\n\n\t* xtract, dbd/Makefile.PL.in nodbd/Makefile.PL.in: Removed\n\t  first line in case users perl is different from\n\t  /usr/local/bin/perl.\n\n\t* All Makefiles: Added chmod for xtracted files.\n\n\t* Added bindparam.h for reuse in DBD::pNET.\n\n\t* Makefile.lib: Some (hopefully) upward compatible modifications\n\t  for integration into the MySQL distribution.\n\nSat Nov  1 17:04:27 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1820)\n\n\t* xtract: Added \"#xtract <driver>\" ... \"#endxtract\".\n\n\t* nodbd/statement.pm.in, nodbd/nodbd.pm.in, nodbd/pmsql.in:\n\t  Using \"#xtract now\".\n\n\t* Reorganized source tree (again).\n\nWed Oct 29 00:41:41 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1819)\n\n\t* nodbd/bundle.pm.in: Fixed syntax error.\n\n\t* Fixed distribution problems. Not all .pm files have been\n\t  included. (Only PAUSE should have noticed.)\n\nMon Oct 27 00:50:08 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1818)\n\n\t* nodbd/Makefile.PL.in: Fixed dependencies for \"xtract\" files.\n\n\t* nodbd/nodbd.xs.in: Fixed ISNUM attribute in fetchinternal.\n\n\t* nodbd/statement.pm.in: Yet one more fix in the new as_string\n\t  method. :-(\n\n\t* nodbd/statement.pm.in: Msql::Statement::maxlength caches\n\t  its return value now\n\nSat Oct 25 16:30:01 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1817)\n\n\t* Makefile.PL,dbd/Makefile.PL.in,nodbd/Makefile.PL.in: Added\n\t  dependencies for files being created from dbd and nodbd\n\t  directories via the \"xtract\" script.\n\t* nodbd/pmsql.in,nodbd/statement.pm.in: Fixed minor problems with\n\t  mSQL1; suggested by Andreas Koenig\n\t* dbd/dbd.pm.in,tests/ak-dbd.t: Removed support and tests for the\n\t  old connect methods.\n\t* nodbd/statement.pm.in: Fixed bug in Msql::Statement::maxlength.\n\nFri Oct 24 01:29:08 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1816)\n\n\t* dbd/myMsql.c (MyConnect): Fixed use of mysql_real_connect\n\n\t* dbd/dbdimp.c: Added automatic type detection to bind_param\n\n\t* nodbd/statement.pm.in: Modified as_string for more efficiency\n\t  under MySQL. Added maxlength and isnum methods. (Direct attribute\n\t  fetches under MySQL, calculated under mSQL.)\n\n\t* nodbd/pmsql.pm.in: Fixed bug in creation of @typelabels:\n\t  defined &Msql::TEXT_TYPE doesn't work before autoloading it.\n\n1997-10-02  Jochen Wiedmann <joe@ispsoft.de> (1.1815)\n\n\t* dbd/dbd.xs: Fixed bug in insertid; &svsock was used instead\n\t  of svsock\n\n\t* Fixed bug in nodbd.xs (formerly Mysql.xs): key INSERTID had\n\t  length of 9 (reported by Maurice Aubrey, <maurice@hevanet.com>)\n\n\t* t/ak-dbd.t, t/akmisc.t: Added tests for mysql's insertid\n\t  feature.\n\n\t* Merged source trees of Mysql and Msql.\n\n\t* lib/M(y)sql.pm: Added some words on createdb, dropdb and\n\t  shutdown to the man page. Missed by Ray Zimmermann\n          (rz10@cornell.edu)\n\n\t* dbd/dbd.xs.in: Implemented $dbh->do as a direct XS call.\n\n\t* dbd/dbd.xs.in, nodbd/nodbd.xs.in: Suppressed some warnings\n\t  due to uninitialized RETVAL. George Hartlieb\n\t  (ghartlieb@mail.arc.nasa.gov)\n\n1997-09-29  Andreas Koenig <koenig@anna.mind.de> (1.1814)\n\n\t* t/50commit.t: Fixed printing of warning message when\n\t  commit issues a warning.\n\n\t* lib/DBD/mSQL.pm (connect): Fixed warning in connect, if\n\t  attrhash is present.\n\n\t* pmsql.PL: Fixed use of Msql 2 constants in @typelabel definition\n\t  and similar things.\n\n\t* lib/Msql/Statement.pm: Fixed use of Msql::TEXT_TYPE without\n\t  checking whether we are running Msql 1.\n\nDBD::mysql for DBI - Written by Jochen Wiedmann <joe@ispsoft.de>\n\n97.09.27 V1.1812\n          Added t/50commit.t to test suite.\n\t  Included <embed.h> in myMsql.h for redefining my_setenv().\n\t  Made AutoCommit, Commit and Rollback DBI conformant.\n\t  Fixed reconnect problems with Mysql: mysql_port was 0 on some\n\t  systems.\n\t  Added support of mysql_real_connect to myMsql.c.\n\t  Fixed Msql::errno returning a char*.\n\t  Added lib/Bundle::Mysql.pm.\n          Fixed 'use Mysql' to 'require Mysql' in t/mysql2.t.\n\n97.09.12 V1.1810\n\t  Fixed bug in dbd_st_FETCH_internal: newRV_noinc was used for\n\t  the return value. This resulted in invalid cache values,\n\t  reported by Michael Bletzinger\n\t  <Michael.Bletzinger@ssa.crane.navy.mil>\n\n97.09.12 V1.1809\n\t  Adapted changes from DBD-Oracle 0.46 to 0.47; in particular\n\t  the files Driver.xst and dbd_xsh.h from the DBI distribution\n\t  are used now. (LongReadLen, LongTruncOk, ... are still\n\t  meaningless, but they are not that important for m(y)sql:\n\t  The complete results are in RAM anyways ...)\n          Fixed man page of DBD::M(y)SQL: \"@names = $sth->{'NAME'}\".\n\t  Added parameter completion for \"set\" command to dbimon.\n\n97.09.08  V1.1808\n\t  Fixed bug in dbimon, a closing brace was missing causing a\n\t  syntax error.\n\t  Fixed problems in the Term::ReadLine::GNU support, reported\n\t  by Nem W. Schlecht (nem@abattoir.cc.ndsu.nodak.edu).\n\t  Modified dbimon for internally using the Data::ShowTable\n\t  module. My thanks to Tim Bunce for the hint.\n\t  Compatibility fixes for SunOS and Solaris, supplied by\n\t  Neil Bowers (neilb@cre.canon.co.uk).\n\n97.09.03  V1.1806\n          Fixed bug in Mysql.xs: $sth->numfields dumped core because no\n\t  check for a result was done.\n\t  Fixed bug in lib/Mysql/Statement.pm: Mysql::Statement.as_string\n\t  did not check for $sth->numfields != 0.\n\t  Added patch from Nem W. Schlecht (nem@abattoir.cc.ndsu.nodak.edu)\n\t  for Term::ReadLine::GNU support to pmysql and dbimon.\n\n97.09.03  V1.1805\n\t  Fixed bug in DBD::mysql: Executing a non-select statement\n\t  always returned -1 (unknown number of rows) although the\n\t  correct number was returned by $sth->rows().\n\t  Fixed bug in DBD::mysql: strlen was executed on a NULL\n\t  value when mysql_fetch_rows returned a NULL field.\n\t  Added all _ListField attributes to statement handles.\n\t  Added support for \"LISTFIELDS <table>\" to $sth->execute.\n\t  Modified $sth->func(\"_ListSelectedFields\") and\n\t  $dbh->func(\"<table>\", \"_ListFields\") to use the new\n\t  possibilities; in fact these are only stubs now.\n\t  Added dbimon.\n\t  Added some internal attributes for dbimon to DBD::mysql:\n\t  format_default_size, format_max_size, format_type_name\n\t  and format_right_justification.\n\n97.08.30  V1.1804\n\t  Added \"fancy\", \"quote\", \"separator\" and \"escape\" commands to\n\t  pm(y)sql.PL, patch supplied by Nem W Schlecht\n\t  (nem@abattoir.cc.ndsu.nodak.edu).\n\t  Modified pm(y)sql.PL and pmsql.PL so that it automatically\n\t  adapts pm(y)sql for use with Msql and Mysql, respectively.\n\t  Makefile.PL and M(y)sqlPerl/Makefile.PL now automatically\n\t  adapt lib/M(y)sql.pm, lib/M(y)sql/Statement.pm and\n\t  lib/DBD/mSQL.pm or lib/DBD/mysql.pm for use in Msql-modules\n\t  or Mysql-modules; just copy these files, rename them and\n\t  run \"perl Makefile.PL\".\n\n97.08.29  V1.1803\n\t  Added mysql_errno()\n\t  Modified perl modules for use of $driver and isa($driver).\n\t  Modified Msql.xs and Mysql.xs for use of Package and\n\t  StPackage.\n\t  Modified test for fetch of non-result sth in akmisc.t: Msql\n\t  returns number of rows and not an sth.\n\n97.08.27  Removed use of TEXT_TYPE from pmysql and Mysql/Statement.pm.\n\n97.08.16  Modified mysql.xs, dbdimp.h and dbdimp.c for use in DBD::mSQL.\n\t  Now using Andreas K\u00f6nig\u00b4s Makefile.PL from the DBD::mSQL\n\t  distribution.\n\t  Added check for disabled '-lgcc' on Linux; this leads to a\n\t  missing __moddi3 symbol in libmysqlclient.a, when running\n\t  mysql.so.\n\n\t  Added mysqlperl support.\n\n97.08.02  Almost completely rewritten, with the exception of private\n          functions like _ListTables.\n          Implemented bind_param.\n          Test suite rewritten for portability.\n          Many sources moved from mysql.pm and mysql.xs to dbdimp.h;\n          mysql.pm and mysql.xs are now close to Oracle.xs and Oracle.pm.\n\n97.07.28  Added $dbh->quote method.\n\t  Modified internal use of \"char* statement\" to \"SV* statement\".\n\t  Modified use of mysql_query to mysql_real_query. (The above\n\t  three things should fix blob problems hopefully.)\n\t  Bumped revision number to 2.00 because of API changes:\n\t  The connect method works now as described in the DBI man\n\t  page, compatibility to DBD::msql seems deprecated.\n\t  Heavy internal modifications in order to use DBIS->get_fbav();\n\t  this gives compatibility to DBI 0.88.\n\t  Modified test suite to use Test::Harness.\n\t  Added blob tests.\n\nDBD::mysql for DBI - Written by Alligator Descartes <descarte@mcqueen.com>\n\n96.06.22  Get new patched version 1.65 from gnat@frii.com\n\t  Added the memory bug patch to this.\n\n96.06.18  Added pod documentation to mysql.pm and the possibility\n\t  to retreive insert_id. This was done by Nathan Torkington.\n\n\t  Fixed memory bug that sql results never was freed.\n\t  Now a result is freed when one calls the 'finish' action.\n\t  The patch was done by gareth@netcom.co.uk & Monty\n\n96.05.27  Changed Makefile.PL after suggestions from Raymond Wiker\n\n96.04.25  Changed the README and fixed a typo in mysql.xs\n\t  Changed version to DBD-mysql-1.63.1 to have a reference to mSQL-0.63\n\n96.04.19  Updated with differences from DBD:mSQL-0.63\n\n\n96.11.03  Changed from DBD:mysql-0.60pl10 to DBD:mysql-1.0 by Michael Widenius\n\n\nOriginal ChangeLog:\n\n18/07/95:\tStarted.\n\n\t\tVersion 0.0.0 ( Totally pre-alpha! )\n\n19/07/95:22:00\tCode now basically seems to work. I've got connection to\n\t\ta database, and clean disconnection.\n\n\t 23:45\tI'm now working on the statement cycle stuff, which I've\n\t\tmapped out. It's just a case of coding, which shouldn't\n\t\ttake too long, hopefully.\n\n\t\tPosted notice of approaching doom to perldb-interest.\n\n20/07/95:01:25\tFetching appears to work OK now. I need to read the API on\n\t\tmsqlFieldSeek, since I can't work out why fetch is returning\n\t\tthe same row over and over!\n\n21/07/95:09:22  Added a field into imp_sth (currow) which keeps track of the\n                current row that's been fetched from the result struct. If I\n                can fix the return codes coming from fetchrow, it'll work!\n\n21/07/95:10:30  Pondered bind variables in cursors. Since there isn't a bind\n                function in the API, I may have to frig the way that prepare/\n                execute works, ie, move the call to msqlQuery *after* it's\n                done some parsing for bind values......Hm.\n\n21/07/95:10:35  Twiddled some bits in the fetchrow cycle.\n\n23/07/95:15:50  Fetch is fetching a row, but it's not returning it to the\n        \tcalling cycle, so I need to fart about with the sv stuff, which\n\t\tis not amusing me greatly!\n\n26/07/95:23:42\tDecided in agreement with Andreas that the first release is\n\t\tto be 0.61!\n\n27/07/95:14:14\tFinally! It fucking works! After splendid quantities of\n      \t\thacking around with the prepare/execute/fetchrow/finish cycle\n\t\tit's actually returning rows correctly!\n\n\t\tNOTE: The SV handling within dbd_describe is shot to buggery,\n\t\t      but I've kludged it in mSQL.xs::fetchrow to do a\n\t\t      sv_2mortal instead of a sv_mortalcopy.\n\n27/07/95:14:22\tTidied up mSQL.xs::finish to do an msqlFreeResult. Annoyingly\n\t\tenough, there's no return code to msqlFR, so I can't test\n\t\twhether or not it's worked! Bah!\n\n27/07/95:15:15\tAltered test to do several bits and bobs. I'm testing INSERT\n\t\tstatements now. These only execute an msqlQuery, but the\n\t\tstuff needs to continue to pass through the execute and finish\n\t\tstages cleanly.......*sigh*\n\n27/07/95:15:22\tMy dubious 'INSERT' check hack works, sort of. Pity it converts\n\t\tthe entire statement to lower case.....!\n\n27/07/95:17:33\tTwiddled some more stuff so it seems to do CREATE TABLE,\n\t\tINSERT statements too. Of course, there's no error checking\n\t\tyet, but it seems to be OK........Hm.\n\n27/07/95:17:38\tMailed out a statement saying the 0.61 code would be up for\n\t\tgrabs as of Monday 31st July! Still waiting on Alpha reports.\n\n27/07/95:12:11\tFixed the lower-case all the INSERT/CREATE &c. statement bug.\n\t\tIt now checks to see if you're in quotes.\n\n28/07/95:xx:xx\tGot a report back from Andreas to say  compilation barfs on\n\t\this Indy. Fixed a load of do_error bugs in dbdimp.c.\n\n13/08/95:18:25  Finally got back to this after a rather long break. Fixed some\n\t\tMakefile.PL bugs that were kicking about. Finally fixed\n\t\t( or appeared to fix ) the strlen signedness bug in dbdimp.c\n\t\tthat may halt compilation on the Indy.\n\n\t\tEmailed Karsten the debug info to see what's causing problems\n\t\ton the NeXTStep platform.\n\n14/08/95:13:48\tGot email back from Andreas. signedness broke mSQL.xs as well!\n\t\tFixed that and emailed him a quick patch.\n\n14/08/95:14:45\tAndreas now has a successful compile. The tests are crap, but\n\t\tappear to ( sort of ) work.\n\n29/08/95:23:18\tConverted driver across to new DBI format. It now appears\n\t\tto compile, install and run fairly reasonably. There are\n\t\tsome serious messes that need cleared up in it, but it's\n\t\tfundamentally OK, I hope. Announced for pl0 testing.\n\n04/09/95:15:04\tStarted back on getting the 0.60pl0 out. Tidied up the parsing\n   \t\tof statements for INSERT, CREATE &c statements. It just takes\n\t\tthe first word of the statement now.\n\n04/09/95:15:19\tLooks OK. Tested against DBI 0.63 and looks reasonable.\n\t\tAnnounced release of 0.60pl1 and put up for ftp.\n\n20/09/95:15:20\tPatched a load of stuff including NULLs, and local device\n\t\thandling ( SV ). Released pl4, which was bogus. Released\n\t\tpl5 which should fix those issues.\n\n20/09/95:22:17\tFixed overhang of old DBI bug with DBIc_ENDING remaining in\n\t\tDESTROY in mSQL.xs. Spotted by Marti Rijken and fixed.\n\t\t( Hopefully! )\n\n18/10/95:15:13\tAdded in the missing API chunks for ListTables, ListDBs\n\t\tand ListFields.\n\n\t\tListFields isnae working, but I'll fix that sometime soon....\n\n05/11/95:11:32\tFixed $sth->readblob to return undef. Fixed Makefile.PL,\n\t\tdbdimp.h, mSQL.h, dbdimp.c for release of 0.60pl7. Also tested\n\t\t'make test' which now works!\n\n23/11/95:19:22\tFixed ListFields from the pointers given to me by Sven V.\n\n24/11/95:03:13\tFixed error handling in all the func methods\n\n24/11/95:13:01\tAdded 'NumRows' method to statement handles to return the\n\t\tnumber of rows returned ( or affected ) by a statement.o\n\n30/12/95:18:10\tAltered mSQL.pm to allow for hostname:port style connections\n\t\tto known remote port machines. Sets ENV var since the\n\t\tmsqlConnect API call doesn't support port arguments.\n\n30/12/95:18:15\tAdded 'length' key into the hash returned by ListFields, so\n\t\twe can get the scale of the field.\n\n24/03/96:22:34\tFixed bugs and upgraded versioning for perl5.002 to work\n\t\tproperly. Released as pl10\n\n-> Lamentable lack of ChangeLog information here!\n\n27/03/97: Tidied up things with regard to 0.61 release.\n\n28/03/97: Patched NULL as undef bug\n", "/*\n *  DBD::mysql - DBI driver for the mysql database\n *\n *  Copyright (c) 2004-2014 Patrick Galbraith\n *  Copyright (c) 2013-2014 Michiel Beijen \n *  Copyright (c) 2004-2007 Alexey Stroganov \n *  Copyright (c) 2003-2005  Rudolf Lippan\n *  Copyright (c) 1997-2003  Jochen Wiedmann\n *\n *  You may distribute this under the terms of either the GNU General Public\n *  License or the Artistic License, as specified in the Perl README file.\n */\n\n\n#ifdef WIN32\n#include \"windows.h\"\n#include \"winsock.h\"\n#endif\n\n#include \"dbdimp.h\"\n\n#if defined(WIN32)  &&  defined(WORD)\n#undef WORD\ntypedef short WORD;\n#endif\n\n#ifdef WIN32\n#define MIN min\n#else\n#ifndef MIN\n#define MIN(a, b)       ((a) < (b) ? (a) : (b))\n#endif\n#endif\n\n#if MYSQL_ASYNC\n#  include <poll.h>\n#  include <errno.h>\n#  define ASYNC_CHECK_RETURN(h, value)\\\n    if(imp_dbh->async_query_in_flight) {\\\n        do_error(h, 2000, \"Calling a synchronous function on an asynchronous handle\", \"HY000\");\\\n        return (value);\\\n    }\n#else\n#  define ASYNC_CHECK_RETURN(h, value)\n#endif\n\nstatic int parse_number(char *string, STRLEN len, char **end);\n\nDBISTATE_DECLARE;\n\ntypedef struct sql_type_info_s\n{\n    const char *type_name;\n    int data_type;\n    int column_size;\n    const char *literal_prefix;\n    const char *literal_suffix;\n    const char *create_params;\n    int nullable;\n    int case_sensitive;\n    int searchable;\n    int unsigned_attribute;\n    int fixed_prec_scale;\n    int auto_unique_value;\n    const char *local_type_name;\n    int minimum_scale;\n    int maximum_scale;\n    int num_prec_radix;\n    int sql_datatype;\n    int sql_datetime_sub;\n    int interval_precision;\n    int native_type;\n    int is_num;\n} sql_type_info_t;\n\n\n/*\n\n  This function manually counts the number of placeholders in an SQL statement,\n  used for emulated prepare statements < 4.1.3\n\n*/\nstatic int\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char* ptr= statement;\n  int num_params= 0;\n  int comment_length= 0;\n  char c;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\n\n  while ( (c = *ptr++) )\n  {\n    switch (c) {\n      /* so, this is a -- comment, so let's burn up characters */\n    case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              /* let's see if the next one is a dash */\n              c = *ptr++;\n\n              if  (c == '-') {\n                  /* if two dashes, ignore everything until newline */\n                  while ((c = *ptr))\n                  {\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\n                      ptr++;\n                      comment_length++;\n                      if (c == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /*\n                    if not comment_end, the comment never ended and we need to iterate\n                    back to the beginning of where we started and let the database \n                    handle whatever is in the statement\n                */\n                  if (! comment_end)\n                      ptr-= comment_length;\n              }\n              /* otherwise, only one dash/hyphen, backtrack by one */\n              else\n                  ptr--;\n              break;\n          }\n      }\n    /* c-type comments */\n    case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              c = *ptr++;\n              /* let's check if the next one is an asterisk */\n              if  (c == '*')\n              {\n                  comment_length= 0;\n                  comment_end= false;\n                  /* ignore everything until closing comment */\n                  while ((c= *ptr))\n                  {\n                      ptr++;\n                      comment_length++;\n\n                      if (c == '*')\n                      {\n                          c = *ptr++;\n                          /* alas, end of comment */\n                          if (c == '/')\n                          {\n                              comment_end= true;\n                              break;\n                          }\n                          /*\n                            nope, just an asterisk, not so fast, not\n                            end of comment, go back one\n                        */\n                          else\n                              ptr--;\n                      }\n                  }\n                  /*\n                    if the end of the comment was never found, we have\n                    to backtrack to wherever we first started skipping\n                    over the possible comment.\n                    This means we will pass the statement to the database\n                    to see its own fate and issue the error\n                */\n                  if (!comment_end)\n                      ptr -= comment_length;\n              }\n              else\n                  ptr--;\n              break;\n          }\n      }\n    case '`':\n    case '\"':\n    case '\\'':\n      /* Skip string */\n      {\n        char end_token = c;\n        while ((c = *ptr)  &&  c != end_token)\n        {\n          if (c == '\\\\')\n            if (! *(++ptr))\n              continue;\n\n          ++ptr;\n        }\n        if (c)\n          ++ptr;\n        break;\n      }\n\n    case '?':\n      ++num_params;\n      break;\n\n    default:\n      break;\n    }\n  }\n  return num_params;\n}\n\n/*\n  allocate memory in statement handle per number of placeholders\n*/\nstatic imp_sth_ph_t *alloc_param(int num_params)\n{\n  imp_sth_ph_t *params;\n\n  if (num_params)\n    Newz(908, params, (unsigned int) num_params, imp_sth_ph_t);\n  else\n    params= NULL;\n\n  return params;\n}\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  allocate memory in MYSQL_BIND bind structure per\n  number of placeholders\n*/\nstatic MYSQL_BIND *alloc_bind(int num_params)\n{\n  MYSQL_BIND *bind;\n\n  if (num_params)\n    Newz(908, bind, (unsigned int) num_params, MYSQL_BIND);\n  else\n    bind= NULL;\n\n  return bind;\n}\n\n/*\n  allocate memory in fbind imp_sth_phb_t structure per\n  number of placeholders\n*/\nstatic imp_sth_phb_t *alloc_fbind(int num_params)\n{\n  imp_sth_phb_t *fbind;\n\n  if (num_params)\n    Newz(908, fbind, (unsigned int) num_params, imp_sth_phb_t);\n  else\n    fbind= NULL;\n\n  return fbind;\n}\n\n/*\n  alloc memory for imp_sth_fbh_t fbuffer per number of fields\n*/\nstatic imp_sth_fbh_t *alloc_fbuffer(int num_fields)\n{\n  imp_sth_fbh_t *fbh;\n\n  if (num_fields)\n    Newz(908, fbh, (unsigned int) num_fields, imp_sth_fbh_t);\n  else\n    fbh= NULL;\n\n  return fbh;\n}\n\n/*\n  free MYSQL_BIND bind struct\n*/\nstatic void free_bind(MYSQL_BIND *bind)\n{\n  if (bind)\n    Safefree(bind);\n}\n\n/*\n   free imp_sth_phb_t fbind structure\n*/\nstatic void free_fbind(imp_sth_phb_t *fbind)\n{\n  if (fbind)\n    Safefree(fbind);\n}\n\n/*\n  free imp_sth_fbh_t fbh structure\n*/\nstatic void free_fbuffer(imp_sth_fbh_t *fbh)\n{\n  if (fbh)\n    Safefree(fbh);\n}\n\n#endif\n\n/*\n  free statement param structure per num_params\n*/\nstatic void\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\n{\n  if (params)\n  {\n    int i;\n    for (i= 0;  i < num_params;  i++)\n    {\n      imp_sth_ph_t *ph= params+i;\n      if (ph->value)\n      {\n        (void) SvREFCNT_dec(ph->value);\n        ph->value= NULL;\n      }\n    }\n    Safefree(params);\n  }\n}\n\n/* \n  Convert a MySQL type to a type that perl can handle\n\n  NOTE: In the future we may want to return a struct with a lot of\n  information for each type\n*/\n\nstatic enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\n{\n  static enum enum_field_types enum_type;\n\n  switch (type) {\n  case MYSQL_TYPE_DOUBLE:\n  case MYSQL_TYPE_FLOAT:\n    enum_type= MYSQL_TYPE_DOUBLE;\n    break;\n\n  case MYSQL_TYPE_SHORT:\n  case MYSQL_TYPE_TINY:\n  case MYSQL_TYPE_LONG:\n  case MYSQL_TYPE_INT24:\n  case MYSQL_TYPE_YEAR:\n#if IVSIZE >= 8\n  case MYSQL_TYPE_LONGLONG:\n#endif\n    enum_type= MYSQL_TYPE_LONG;\n    break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_BIT:\n    enum_type= MYSQL_TYPE_BIT;\n    break;\n#endif\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_NEWDECIMAL:\n#endif\n  case MYSQL_TYPE_DECIMAL:\n    enum_type= MYSQL_TYPE_DECIMAL;\n    break;\n\n#if IVSIZE < 8\n  case MYSQL_TYPE_LONGLONG:\n#endif\n  case MYSQL_TYPE_DATE:\n  case MYSQL_TYPE_TIME:\n  case MYSQL_TYPE_DATETIME:\n  case MYSQL_TYPE_NEWDATE:\n  case MYSQL_TYPE_TIMESTAMP:\n  case MYSQL_TYPE_VAR_STRING:\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_VARCHAR:\n#endif\n  case MYSQL_TYPE_STRING:\n    enum_type= MYSQL_TYPE_STRING;\n    break;\n\n#if MYSQL_VERSION_ID > GEO_DATATYPE_VERSION\n  case MYSQL_TYPE_GEOMETRY:\n#endif\n  case MYSQL_TYPE_BLOB:\n  case MYSQL_TYPE_TINY_BLOB:\n    enum_type= MYSQL_TYPE_BLOB;\n    break;\n\n  default:\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\n  }\n  return(enum_type);\n}\n\n#if defined(DBD_MYSQL_EMBEDDED)\n/* \n  count embedded options\n*/\nint count_embedded_options(char *st)\n{\n  int rc;\n  char c;\n  char *ptr;\n\n  ptr= st;\n  rc= 0;\n\n  if (st)\n  {\n    while ((c= *ptr++))\n    {\n      if (c == ',')\n        rc++;\n    }\n    rc++;\n  }\n\n  return rc;\n}\n\n/*\n  Free embedded options\n*/\nint free_embedded_options(char ** options_list, int options_count)\n{\n  int i;\n\n  for (i= 0; i < options_count; i++)\n  {\n    if (options_list[i])\n      free(options_list[i]);\n  }\n  free(options_list);\n\n  return 1;\n}\n\n/*\n Print out embedded option settings\n\n*/\nint print_embedded_options(PerlIO *stream, char ** options_list, int options_count)\n{\n  int i;\n\n  for (i=0; i<options_count; i++)\n  {\n    if (options_list[i])\n        PerlIO_printf(stream,\n                      \"Embedded server, parameter[%d]=%s\\n\",\n                      i, options_list[i]);\n  }\n  return 1;\n}\n\n/*\n\n*/\nchar **fill_out_embedded_options(PerlIO *stream,\n                                 char *options,\n                                 int options_type,\n                                 int slen, int cnt)\n{\n  int  ind, len;\n  char c;\n  char *ptr;\n  char **options_list= NULL;\n\n  if (!(options_list= (char **) calloc(cnt, sizeof(char *))))\n  {\n    PerlIO_printf(stream,\n                  \"Initialize embedded server. Out of memory \\n\");\n    return NULL;\n  }\n\n  ptr= options;\n  ind= 0;\n\n  if (options_type == 0)\n  {\n    /* server_groups list NULL terminated */\n    options_list[cnt]= (char *) NULL;\n  }\n\n  if (options_type == 1)\n  {\n    /* first item in server_options list is ignored. fill it with \\0 */\n    if (!(options_list[0]= calloc(1,sizeof(char))))\n      return NULL;\n\n    ind++;\n  }\n\n  while ((c= *ptr++))\n  {\n    slen--;\n    if (c == ',' || !slen)\n    {\n      len= ptr - options;\n      if (c == ',')\n        len--;\n      if (!(options_list[ind]=calloc(len+1,sizeof(char))))\n        return NULL;\n\n      strncpy(options_list[ind], options, len);\n      ind++;\n      options= ptr;\n    }\n  }\n  return options_list;\n}\n#endif\n\n/*\n  constructs an SQL statement previously prepared with\n  actual values replacing placeholders\n*/\nstatic char *parse_params(\n                          imp_xxh_t *imp_xxh,\n                          pTHX_ MYSQL *sock,\n                          char *statement,\n                          STRLEN *slen_ptr,\n                          imp_sth_ph_t* params,\n                          int num_params,\n                          bool bind_type_guessing,\n                          bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char *salloc, *statement_ptr;\n  char *statement_ptr_end, *ptr, *valbuf;\n  char *cp, *end;\n  int alen, i;\n  int slen= *slen_ptr;\n  int limit_flag= 0;\n  int comment_length=0;\n  STRLEN vallen;\n  imp_sth_ph_t *ph;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">parse_params statement %s\\n\", statement);\n\n  if (num_params == 0)\n    return NULL;\n\n  while (isspace(*statement))\n  {\n    ++statement;\n    --slen;\n  }\n\n  /* Calculate the number of bytes being allocated for the statement */\n  alen= slen;\n\n  for (i= 0, ph= params; i < num_params; i++, ph++)\n  {\n    int defined= 0;\n    if (ph->value)\n    {\n      if (SvMAGICAL(ph->value))\n        mg_get(ph->value);\n      if (SvOK(ph->value))\n        defined=1;\n    }\n    if (!defined)\n      alen+= 3;  /* Erase '?', insert 'NULL' */\n    else\n    {\n      valbuf= SvPV(ph->value, vallen);\n      alen+= 2+vallen+1;\n      /* this will most likely not happen since line 214 */\n      /* of mysql.xs hardcodes all types to SQL_VARCHAR */\n      if (!ph->type)\n      {\n        if (bind_type_guessing)\n        {\n          valbuf= SvPV(ph->value, vallen);\n          ph->type= SQL_INTEGER;\n\n          if (parse_number(valbuf, vallen, &end) != 0)\n          {\n              ph->type= SQL_VARCHAR;\n          }\n        }\n        else\n          ph->type= SQL_VARCHAR;\n      }\n    }\n  }\n\n  /* Allocate memory, why *2, well, because we have ptr and statement_ptr */\n  New(908, salloc, alen*2, char);\n  ptr= salloc;\n\n  i= 0;\n /* Now create the statement string; compare count_params above */\n  statement_ptr_end= (statement_ptr= statement)+ slen;\n\n  while (statement_ptr < statement_ptr_end)\n  {\n    /* LIMIT should be the last part of the query, in most cases */\n    if (! limit_flag)\n    {\n      /*\n        it would be good to be able to handle any number of cases and orders\n      */\n      if ((*statement_ptr == 'l' || *statement_ptr == 'L') &&\n          (!strncmp(statement_ptr+1, \"imit ?\", 6) ||\n           !strncmp(statement_ptr+1, \"IMIT ?\", 6)))\n      {\n        limit_flag = 1;\n      }\n    }\n    switch (*statement_ptr)\n    {\n      /* comment detection. Anything goes in a comment */\n      case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '-')\n              {\n                  /* ignore everything until newline or end of string */\n                  while (*statement_ptr)\n                  {\n                      comment_length++;\n                      *ptr++ = *statement_ptr++;\n                      if (!*statement_ptr || *statement_ptr == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* if not end of comment, go back to where we started, no end found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      /* c-type comments */\n      case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '*')\n              {\n                  /* use up characters everything until newline */\n                  while (*statement_ptr)\n                  {\n                      *ptr++ = *statement_ptr++;\n                      comment_length++;\n                      if (!strncmp(statement_ptr, \"*/\", 2))\n                      {\n                          comment_length += 2;\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* Go back to where started if comment end not found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      case '`':\n      case '\\'':\n      case '\"':\n      /* Skip string */\n      {\n        char endToken = *statement_ptr++;\n        *ptr++ = endToken;\n        while (statement_ptr != statement_ptr_end &&\n               *statement_ptr != endToken)\n        {\n          if (*statement_ptr == '\\\\')\n          {\n            *ptr++ = *statement_ptr++;\n            if (statement_ptr == statement_ptr_end)\n\t      break;\n\t  }\n          *ptr++= *statement_ptr++;\n\t}\n\tif (statement_ptr != statement_ptr_end)\n          *ptr++= *statement_ptr++;\n      }\n      break;\n\n      case '?':\n        /* Insert parameter */\n        statement_ptr++;\n        if (i >= num_params)\n        {\n          break;\n        }\n\n        ph = params+ (i++);\n        if (!ph->value  ||  !SvOK(ph->value))\n        {\n          *ptr++ = 'N';\n          *ptr++ = 'U';\n          *ptr++ = 'L';\n          *ptr++ = 'L';\n        }\n        else\n        {\n          int is_num = FALSE;\n\n          valbuf= SvPV(ph->value, vallen);\n          if (valbuf)\n          {\n            switch (ph->type)\n            {\n              case SQL_NUMERIC:\n              case SQL_DECIMAL:\n              case SQL_INTEGER:\n              case SQL_SMALLINT:\n              case SQL_FLOAT:\n              case SQL_REAL:\n              case SQL_DOUBLE:\n              case SQL_BIGINT:\n              case SQL_TINYINT:\n                is_num = TRUE;\n                break;\n            }\n\n            /* (note this sets *end, which we use if is_num) */\n            if ( parse_number(valbuf, vallen, &end) != 0 && is_num)\n            {\n              if (bind_type_guessing) {\n                /* .. not a number, so apparently we guessed wrong */\n                is_num = 0;\n                ph->type = SQL_VARCHAR;\n              }\n            }\n\n\n            /* we're at the end of the query, so any placeholders if */\n            /* after a LIMIT clause will be numbers and should not be quoted */\n            if (limit_flag == 1)\n              is_num = TRUE;\n\n            if (!is_num)\n            {\n              *ptr++ = '\\'';\n              ptr += mysql_real_escape_string(sock, ptr, valbuf, vallen);\n              *ptr++ = '\\'';\n            }\n            else\n            {\n              for (cp= valbuf; cp < end; cp++)\n                  *ptr++= *cp;\n            }\n          }\n        }\n        break;\n\n\t/* in case this is a nested LIMIT */\n      case ')':\n        limit_flag = 0;\n\t*ptr++ = *statement_ptr++;\n        break;\n\n      default:\n        *ptr++ = *statement_ptr++;\n        break;\n\n    }\n  }\n\n  *slen_ptr = ptr - salloc;\n  *ptr++ = '\\0';\n\n  return(salloc);\n}\n\nint bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\n{\n  dTHX;\n  if (ph->value)\n  {\n    if (SvMAGICAL(ph->value))\n      mg_get(ph->value);\n    (void) SvREFCNT_dec(ph->value);\n  }\n\n  ph->value= newSVsv(value);\n\n  if (sql_type)\n    ph->type = sql_type;\n\n  return TRUE;\n}\n\nstatic const sql_type_info_t SQL_GET_TYPE_INFO_values[]= {\n  { \"varchar\",    SQL_VARCHAR,                    255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"variable length string\",\n    0, 0, 0,\n    SQL_VARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_VAR_STRING,  0,\n#else\n    MYSQL_TYPE_STRING,  0,\n#endif\n  },\n  { \"decimal\",   SQL_DECIMAL,                      15, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_DECIMAL, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,     1\n#endif\n  },\n  { \"tinyint\",   SQL_TINYINT,                       3, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Tiny integer\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,     1\n#endif\n  },\n  { \"smallint\",  SQL_SMALLINT,                      5, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Short integer\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,     1\n#endif\n  },\n  { \"integer\",   SQL_INTEGER,                      10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,     1\n#endif\n  },\n  { \"float\",     SQL_REAL,                          7,  NULL, NULL, NULL,\n    1, 0, 0, 0, 0, 0, \"float\",\n    0, 2, 10,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_FLOAT,       1\n#else\n    MYSQL_TYPE_FLOAT,     1\n#endif\n  },\n  { \"double\",    SQL_FLOAT,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 2,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  { \"double\",    SQL_DOUBLE,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 10,\n    SQL_DOUBLE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  /*\n    FIELD_TYPE_NULL ?\n  */\n  { \"timestamp\", SQL_TIMESTAMP,                    14, \"'\", \"'\", NULL,\n    0, 0, 3, 0, 0, 0, \"timestamp\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIMESTAMP,   0\n#else\n    MYSQL_TYPE_TIMESTAMP,     0\n#endif\n  },\n  { \"bigint\",    SQL_BIGINT,                       19, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Longlong integer\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,     1\n#endif\n  },\n  { \"mediumint\", SQL_INTEGER,                       8, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,     1\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATE, 0\n#else\n    MYSQL_TYPE_DATE, 0\n#endif\n  },\n  { \"time\", SQL_TIME, 6, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"time\",\n    0, 0, 0,\n    SQL_TIME, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIME,        0\n#else\n    MYSQL_TYPE_TIME,     0\n#endif\n  },\n  { \"datetime\",  SQL_TIMESTAMP, 21, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"datetime\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATETIME,    0\n#else\n    MYSQL_TYPE_DATETIME,     0\n#endif\n  },\n  { \"year\", SQL_SMALLINT, 4, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"year\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_YEAR,        0\n#else\n    MYSQL_TYPE_YEAR,     0\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_NEWDATE,     0\n#else\n    MYSQL_TYPE_NEWDATE,     0\n#endif\n  },\n  { \"enum\",      SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"enum(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_ENUM,        0\n#else\n    MYSQL_TYPE_ENUM,     0\n#endif\n  },\n  { \"set\",       SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"set(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SET,         0\n#else\n    MYSQL_TYPE_SET,     0\n#endif\n  },\n  { \"blob\",       SQL_LONGVARBINARY,              65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,     0\n#endif\n  },\n  { \"tinyblob\",  SQL_VARBINARY,                 255, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-255) \",\n    0, 0, 0,\n    SQL_VARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY_BLOB,   0\n#else\n    FIELD_TYPE_TINY_BLOB,        0\n#endif\n  },\n  { \"mediumblob\", SQL_LONGVARBINARY,           16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"longblob\",   SQL_LONGVARBINARY,         2147483647, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object, use mediumblob instead\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_LONG_BLOB,   0\n#else\n    MYSQL_TYPE_LONG_BLOB,   0\n#endif\n  },\n  { \"char\",       SQL_CHAR,                       255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"string\",\n    0, 0, 0,\n    SQL_CHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_STRING,      0\n#else\n    MYSQL_TYPE_STRING,   0\n#endif\n  },\n\n  { \"decimal\",            SQL_NUMERIC,            15,  NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_NUMERIC, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,   1 \n#endif\n  },\n  { \"tinyint unsigned\",   SQL_TINYINT,              3, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Tiny integer unsigned\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,        1\n#endif\n  },\n  { \"smallint unsigned\",  SQL_SMALLINT,             5, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Short integer unsigned\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,       1\n#endif\n  },\n  { \"mediumint unsigned\", SQL_INTEGER,              8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,       1\n#endif\n  },\n  { \"int unsigned\",       SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"int\",                SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"integer unsigned\",   SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"bigint unsigned\",    SQL_BIGINT,              20, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Longlong integer unsigned\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,    1\n#endif\n  },\n  { \"text\",               SQL_LONGVARCHAR,      65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,        0\n#endif\n  },\n  { \"mediumtext\",         SQL_LONGVARCHAR,   16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"mediumint unsigned auto_increment\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"Medium integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1,\n#endif\n  },\n  { \"tinyint unsigned auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"tinyint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"smallint auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"smallint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"mediumint\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"bit\", SQL_BIT, 1, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"char(1)\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 0\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 0\n#endif\n  },\n\n  { \"numeric\", SQL_NUMERIC, 19, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"numeric\", 0, 19, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_NUMERIC, 0, 0, FIELD_TYPE_DECIMAL, 1,\n#else\n    SQL_NUMERIC, 0, 0, MYSQL_TYPE_DECIMAL, 1,\n#endif\n  },\n\n  { \"integer unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"mediumint unsigned\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"smallint unsigned auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"smallint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"long varbinary\", SQL_LONGVARBINARY, 16777215, \"0x\", NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"mediumblob\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARBINARY, 0, 0, FIELD_TYPE_LONG_BLOB, 0\n#else\n    SQL_LONGVARBINARY, 0, 0, MYSQL_TYPE_LONG_BLOB, 0\n#endif\n  },\n\n  { \"double auto_increment\", SQL_FLOAT, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 2,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"double auto_increment\", SQL_DOUBLE, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_DOUBLE, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_DOUBLE, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"integer auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"bigint auto_increment\", SQL_BIGINT, 19, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"bigint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n  { \"bit auto_increment\", SQL_BIT, 1, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"char(1) auto_increment\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"mediumint auto_increment\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"Medium integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"float auto_increment\", SQL_REAL, 7, NULL, NULL, NULL,\n    0, 0, 0, 0, 0, 1, \"float auto_increment\", 0, 2, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_FLOAT, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_FLOAT, 1\n#endif\n  },\n\n  { \"long varchar\", SQL_LONGVARCHAR, 16777215, \"'\", \"'\", NULL,\n    1, 0, 3, 0, 0, 0, \"mediumtext\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARCHAR, 0, 0, FIELD_TYPE_MEDIUM_BLOB, 1\n#else\n    SQL_LONGVARCHAR, 0, 0, MYSQL_TYPE_MEDIUM_BLOB, 1\n#endif\n\n  },\n\n  { \"tinyint auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"tinyint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"bigint unsigned auto_increment\", SQL_BIGINT, 20, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"bigint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n/* END MORE STUFF */\n};\n\n/* \n  static const sql_type_info_t* native2sql (int t)\n*/\nstatic const sql_type_info_t *native2sql(int t)\n{\n  switch (t) {\n    case FIELD_TYPE_VAR_STRING:  return &SQL_GET_TYPE_INFO_values[0];\n    case FIELD_TYPE_DECIMAL:     return &SQL_GET_TYPE_INFO_values[1];\n#ifdef FIELD_TYPE_NEWDECIMAL\n    case FIELD_TYPE_NEWDECIMAL:  return &SQL_GET_TYPE_INFO_values[1];\n#endif\n    case FIELD_TYPE_TINY:        return &SQL_GET_TYPE_INFO_values[2];\n    case FIELD_TYPE_SHORT:       return &SQL_GET_TYPE_INFO_values[3];\n    case FIELD_TYPE_LONG:        return &SQL_GET_TYPE_INFO_values[4];\n    case FIELD_TYPE_FLOAT:       return &SQL_GET_TYPE_INFO_values[5];\n\n    /* 6  */\n    case FIELD_TYPE_DOUBLE:      return &SQL_GET_TYPE_INFO_values[7];\n    case FIELD_TYPE_TIMESTAMP:   return &SQL_GET_TYPE_INFO_values[8];\n    case FIELD_TYPE_LONGLONG:    return &SQL_GET_TYPE_INFO_values[9];\n    case FIELD_TYPE_INT24:       return &SQL_GET_TYPE_INFO_values[10];\n    case FIELD_TYPE_DATE:        return &SQL_GET_TYPE_INFO_values[11];\n    case FIELD_TYPE_TIME:        return &SQL_GET_TYPE_INFO_values[12];\n    case FIELD_TYPE_DATETIME:    return &SQL_GET_TYPE_INFO_values[13];\n    case FIELD_TYPE_YEAR:        return &SQL_GET_TYPE_INFO_values[14];\n    case FIELD_TYPE_NEWDATE:     return &SQL_GET_TYPE_INFO_values[15];\n    case FIELD_TYPE_ENUM:        return &SQL_GET_TYPE_INFO_values[16];\n    case FIELD_TYPE_SET:         return &SQL_GET_TYPE_INFO_values[17];\n    case FIELD_TYPE_BLOB:        return &SQL_GET_TYPE_INFO_values[18];\n    case FIELD_TYPE_TINY_BLOB:   return &SQL_GET_TYPE_INFO_values[19];\n    case FIELD_TYPE_MEDIUM_BLOB: return &SQL_GET_TYPE_INFO_values[20];\n    case FIELD_TYPE_LONG_BLOB:   return &SQL_GET_TYPE_INFO_values[21];\n    case FIELD_TYPE_STRING:      return &SQL_GET_TYPE_INFO_values[22];\n    default:                     return &SQL_GET_TYPE_INFO_values[0];\n  }\n}\n\n\n#define SQL_GET_TYPE_INFO_num \\\n\t(sizeof(SQL_GET_TYPE_INFO_values)/sizeof(sql_type_info_t))\n\n\n/***************************************************************************\n *\n *  Name:    dbd_init\n *\n *  Purpose: Called when the driver is installed by DBI\n *\n *  Input:   dbistate - pointer to the DBI state variable, used for some\n *               DBI internal things\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_init(dbistate_t* dbistate)\n{\n    dTHX;\n    DBISTATE_INIT;\n}\n\n\n/**************************************************************************\n *\n *  Name:    do_error, do_warn\n *\n *  Purpose: Called to associate an error code and an error message\n *           to some handle\n *\n *  Input:   h - the handle in error condition\n *           rc - the error code\n *           what - the error message\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid do_error(SV* h, int rc, const char* what, const char* sqlstate)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n  SV *errstr;\n  SV *errstate;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\n  errstr= DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n\n#if MYSQL_VERSION_ID >= SQL_STATE_VERSION\n  if (sqlstate)\n  {\n    errstate= DBIc_STATE(imp_xxh);\n    sv_setpvn(errstate, sqlstate, 5);\n  }\n#endif\n\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\n}\n\n/*\n  void do_warn(SV* h, int rc, char* what)\n*/\nvoid do_warn(SV* h, int rc, char* what)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  warn(\"%s\", what);\n}\n\n#if defined(DBD_MYSQL_EMBEDDED)\n #define DBD_MYSQL_NAMESPACE \"DBD::mysqlEmb::QUIET\";\n#else\n #define DBD_MYSQL_NAMESPACE \"DBD::mysql::QUIET\";\n#endif\n\n#define doquietwarn(s) \\\n  { \\\n    SV* sv = perl_get_sv(DBD_MYSQL_NAMESPACE, FALSE);  \\\n    if (!sv  ||  !SvTRUE(sv)) { \\\n      warn s; \\\n    } \\\n  }\n\n\n/***************************************************************************\n *\n *  Name:    mysql_dr_connect\n *\n *  Purpose: Replacement for mysql_connect\n *\n *  Input:   MYSQL* sock - Pointer to a MYSQL structure being\n *             initialized\n *           char* mysql_socket - Name of a UNIX socket being used\n *             or NULL\n *           char* host - Host name being used or NULL for localhost\n *           char* port - Port number being used or NULL for default\n *           char* user - User name being used or NULL\n *           char* password - Password being used or NULL\n *           char* dbname - Database name being used or NULL\n *           char* imp_dbh - Pointer to internal dbh structure\n *\n *  Returns: The sock argument for success, NULL otherwise;\n *           you have to call do_error in the latter case.\n *\n **************************************************************************/\n\nMYSQL *mysql_dr_connect(\n                        SV* dbh,\n                        MYSQL* sock,\n                        char* mysql_socket,\n                        char* host,\n\t\t\t                  char* port,\n                        char* user,\n                        char* password,\n\t\t\t                  char* dbname,\n                        imp_dbh_t *imp_dbh)\n{\n  int portNr;\n  unsigned int client_flag;\n  MYSQL* result;\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* per Monty, already in client.c in API */\n  /* but still not exist in libmysqld.c */\n#if defined(DBD_MYSQL_EMBEDDED)\n   if (host && !*host) host = NULL;\n#endif\n\n  portNr= (port && *port) ? atoi(port) : 0;\n\n  /* already in client.c in API */\n  /* if (user && !*user) user = NULL; */\n  /* if (password && !*password) password = NULL; */\n\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->mysql_dr_connect: host = |%s|, port = %d,\" \\\n\t\t  \" uid = %s, pwd = %s\\n\",\n\t\t  host ? host : \"NULL\", portNr,\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  {\n\n#if defined(DBD_MYSQL_EMBEDDED)\n    if (imp_dbh)\n    {\n      D_imp_drh_from_dbh;\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      if (sv  &&  SvROK(sv))\n      {\n        SV** svp;\n        STRLEN lna;\n        char * options;\n        int server_args_cnt= 0;\n        int server_groups_cnt= 0;\n        int rc= 0;\n\n        char ** server_args = NULL;\n        char ** server_groups = NULL;\n\n        HV* hv = (HV*) SvRV(sv);\n\n        if (SvTYPE(hv) != SVt_PVHV)\n          return NULL;\n\n        if (!imp_drh->embedded.state)\n        {\n          /* Init embedded server */\n          if ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.groups=newSVsv(*svp);\n\n            if ((server_groups_cnt=count_embedded_options(options)))\n            {\n              /* number of server_groups always server_groups+1 */\n              server_groups=fill_out_embedded_options(DBIc_LOGPIO(imp_xxh), options, 0, \n                                                      (int)lna, ++server_groups_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                              \"Groups names passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_groups, server_groups_cnt);\n              }\n            }\n          }\n\n          if ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.args=newSVsv(*svp);\n\n            if ((server_args_cnt=count_embedded_options(options)))\n            {\n              /* number of server_options always server_options+1 */\n              server_args=fill_out_embedded_options(DBIc_LOGPIO(imp_xxh), options, 1, (int)lna, ++server_args_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Server options passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_args, server_args_cnt);\n              }\n            }\n          }\n          if (mysql_server_init(server_args_cnt, server_args, server_groups))\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED, \"Embedded server was not started. \\\n                    Could not initialize environment.\");\n            return NULL;\n          }\n          imp_drh->embedded.state=1;\n\n          if (server_args_cnt)\n            free_embedded_options(server_args, server_args_cnt);\n          if (server_groups_cnt)\n            free_embedded_options(server_groups, server_groups_cnt);\n        }\n        else\n        {\n         /*\n          * Check if embedded parameters passed to connect() differ from\n          * first ones\n          */\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)))\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.groups));\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)) )\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.args));\n\n          if (rc)\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED,\n                    \"Embedded server was already started. You cannot pass init\\\n                    parameters to embedded server once\");\n            return NULL;\n          }\n        }\n      }\n    }\n#endif\n\n#ifdef MYSQL_NO_CLIENT_FOUND_ROWS\n    client_flag = 0;\n#else\n    client_flag = CLIENT_FOUND_ROWS;\n#endif\n    mysql_init(sock);\n\n    if (imp_dbh)\n    {\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\n      if (sv  &&  SvROK(sv))\n      {\n        HV* hv = (HV*) SvRV(sv);\n        SV** svp;\n        STRLEN lna;\n\n        /* thanks to Peter John Edwards for mysql_init_command */ \n        if ((svp = hv_fetch(hv, \"mysql_init_command\", 18, FALSE)) &&\n            *svp && SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                           \"imp_dbh->mysql_dr_connect: Setting\" \\\n                           \" init command (%s).\\n\", df);\n          mysql_options(sock, MYSQL_INIT_COMMAND, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_compression\", 17, FALSE))  &&\n            *svp && SvTRUE(*svp))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Enabling\" \\\n                          \" compression.\\n\");\n          mysql_options(sock, MYSQL_OPT_COMPRESS, NULL);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_connect_timeout\", 21, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" connect timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_CONNECT_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_write_timeout\", 19, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" write timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_WRITE_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_timeout\", 18, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" read timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_READ_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_skip_secure_auth\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          my_bool secauth = 0;\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Skipping\" \\\n                          \" secure auth\\n\");\n          mysql_options(sock, MYSQL_SECURE_AUTH, &secauth);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_file\", 23, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Reading\" \\\n                          \" default file %s.\\n\", df);\n          mysql_options(sock, MYSQL_READ_DEFAULT_FILE, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_group\", 24,\n                            FALSE))  &&\n            *svp  &&  SvTRUE(*svp)) {\n          char* gr = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"imp_dbh->mysql_dr_connect: Using\" \\\n                    \" default group %s.\\n\", gr);\n\n          mysql_options(sock, MYSQL_READ_DEFAULT_GROUP, gr);\n        }\n        #if (MYSQL_VERSION_ID >= 50606)\n          if ((svp = hv_fetch(hv, \"mysql_conn_attrs\", 16, FALSE)) && *svp) {\n              HV* attrs = (HV*) SvRV(*svp);\n              HE* entry = NULL;\n              I32 num_entries = hv_iterinit(attrs);\n              while (num_entries && (entry = hv_iternext(attrs))) {\n                  I32 retlen = 0;\n                  char *attr_name = hv_iterkey(entry, &retlen);\n                  SV *sv_attr_val = hv_iterval(attrs, entry);\n                  char *attr_val  = SvPV(sv_attr_val, lna);\n                  mysql_options4(sock, MYSQL_OPT_CONNECT_ATTR_ADD, attr_name, attr_val);\n              }\n          }\n        #endif\n        if ((svp = hv_fetch(hv, \"mysql_client_found_rows\", 23, FALSE)) && *svp)\n        {\n          if (SvTRUE(*svp))\n            client_flag |= CLIENT_FOUND_ROWS;\n          else\n            client_flag &= ~CLIENT_FOUND_ROWS;\n        }\n        if ((svp = hv_fetch(hv, \"mysql_use_result\", 16, FALSE)) && *svp)\n        {\n          imp_dbh->use_mysql_use_result = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->use_mysql_use_result: %d\\n\",\n                          imp_dbh->use_mysql_use_result);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_type_guessing\", 24, TRUE)) && *svp)\n        {\n          imp_dbh->bind_type_guessing= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_type_guessing: %d\\n\",\n                          imp_dbh->bind_type_guessing);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_comment_placeholders\", 31, FALSE)) && *svp)\n        {\n          imp_dbh->bind_comment_placeholders = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_comment_placeholders: %d\\n\",\n                          imp_dbh->bind_comment_placeholders);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_no_autocommit_cmd\", 23, FALSE)) && *svp)\n        {\n          imp_dbh->no_autocommit_cmd= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->no_autocommit_cmd: %d\\n\",\n                          imp_dbh->no_autocommit_cmd);\n        }\n#if FABRIC_SUPPORT\n        if ((svp = hv_fetch(hv, \"mysql_use_fabric\", 16, FALSE)) &&\n            *svp && SvTRUE(*svp))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->use_fabric: Enabling use of\" \\\n                          \" MySQL Fabric.\\n\");\n          mysql_options(sock, MYSQL_OPT_USE_FABRIC, NULL);\n        }\n#endif\n\n#if defined(CLIENT_MULTI_STATEMENTS)\n\tif ((svp = hv_fetch(hv, \"mysql_multi_statements\", 22, FALSE)) && *svp)\n        {\n\t  if (SvTRUE(*svp))\n\t    client_flag |= CLIENT_MULTI_STATEMENTS;\n          else\n            client_flag &= ~CLIENT_MULTI_STATEMENTS;\n\t}\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\t/* took out  client_flag |= CLIENT_PROTOCOL_41; */\n\t/* because libmysql.c already sets this no matter what */\n\tif ((svp = hv_fetch(hv, \"mysql_server_prepare\", 20, FALSE))\n            && *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    client_flag |= CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = TRUE;\n\t  }\n          else\n          {\n\t    client_flag &= ~CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = FALSE;\n\t  }\n\t}\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"imp_dbh->use_server_side_prepare: %d\\n\",\n                        imp_dbh->use_server_side_prepare);\n#endif\n\n        /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n        if ((svp = hv_fetch(hv, \"mysql_enable_utf8mb4\", 20, FALSE)) && *svp && SvTRUE(*svp)) {\n          mysql_options(sock, MYSQL_SET_CHARSET_NAME, \"utf8mb4\");\n        }\n        else if ((svp = hv_fetch(hv, \"mysql_enable_utf8\", 17, FALSE)) && *svp) {\n          /* Do not touch imp_dbh->enable_utf8 as we are called earlier\n           * than it is set and mysql_options() must be before:\n           * mysql_real_connect()\n          */\n         mysql_options(sock, MYSQL_SET_CHARSET_NAME,\n                       (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n         if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n           PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                         \"mysql_options: MYSQL_SET_CHARSET_NAME=%s\\n\",\n                         (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n        }\n#endif\n\n#if defined(DBD_MYSQL_WITH_SSL) && !defined(DBD_MYSQL_EMBEDDED) && \\\n    (defined(CLIENT_SSL) || (MYSQL_VERSION_ID >= 40000))\n\tif ((svp = hv_fetch(hv, \"mysql_ssl\", 9, FALSE))  &&  *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    char *client_key = NULL;\n\t    char *client_cert = NULL;\n\t    char *ca_file = NULL;\n\t    char *ca_path = NULL;\n\t    char *cipher = NULL;\n\t    STRLEN lna;\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION && MYSQL_VERSION_ID <= SSL_LAST_VERIFY_VERSION\n            /*\n              New code to utilise MySQLs new feature that verifies that the\n              server's hostname that the client connects to matches that of\n              the certificate\n            */\n\t    my_bool ssl_verify_true = 0;\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_verify_server_cert\", 28, FALSE))  &&  *svp)\n\t      ssl_verify_true = SvTRUE(*svp);\n#endif\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_key\", 20, FALSE)) && *svp)\n\t      client_key = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_cert\", 21, FALSE)) &&\n                *svp)\n\t      client_cert = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_file\", 17, FALSE)) &&\n\t\t *svp)\n\t      ca_file = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_path\", 17, FALSE)) &&\n                *svp)\n\t      ca_path = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_cipher\", 16, FALSE)) &&\n\t\t*svp)\n\t      cipher = SvPV(*svp, lna);\n\n\t    mysql_ssl_set(sock, client_key, client_cert, ca_file,\n\t\t\t  ca_path, cipher);\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION && MYSQL_VERSION_ID <= SSL_LAST_VERIFY_VERSION\n\t    mysql_options(sock, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, &ssl_verify_true);\n#endif\n\t    client_flag |= CLIENT_SSL;\n\t  }\n\t}\n#endif\n#if (MYSQL_VERSION_ID >= 32349)\n\t/*\n\t * MySQL 3.23.49 disables LOAD DATA LOCAL by default. Use\n\t * mysql_local_infile=1 in the DSN to enable it.\n\t */\n     if ((svp = hv_fetch( hv, \"mysql_local_infile\", 18, FALSE))  &&  *svp)\n     {\n\t  unsigned int flag = SvTRUE(*svp);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n\t    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n        \"imp_dbh->mysql_dr_connect: Using\" \\\n        \" local infile %u.\\n\", flag);\n\t  mysql_options(sock, MYSQL_OPT_LOCAL_INFILE, (const char *) &flag);\n\t}\n#endif\n      }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: client_flags = %d\\n\",\n\t\t    client_flag);\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n    client_flag|= CLIENT_MULTI_RESULTS;\n#endif\n    result = mysql_real_connect(sock, host, user, password, dbname,\n\t\t\t\tportNr, mysql_socket, client_flag);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: <-\");\n\n    if (result)\n    {\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n      /* connection succeeded. */\n      /* imp_dbh == NULL when mysql_dr_connect() is called from mysql.xs\n         functions (_admin_internal(),_ListDBs()). */\n      if (!(result->client_flag & CLIENT_PROTOCOL_41) && imp_dbh)\n        imp_dbh->use_server_side_prepare = FALSE;\n#endif\n\n#if MYSQL_ASYNC\n      if(imp_dbh) {\n          imp_dbh->async_query_in_flight = NULL;\n      }\n#endif\n\n      /*\n        we turn off Mysql's auto reconnect and handle re-connecting ourselves\n        so that we can keep track of when this happens.\n      */\n      result->reconnect=0;\n    }\n    else {\n      /* \n         sock was allocated with mysql_init() \n         fixes: https://rt.cpan.org/Ticket/Display.html?id=86153\n\n      Safefree(sock);\n\n         rurban: No, we still need this handle later in mysql_dr_error().\n         RT #97625. It will be freed as imp_dbh->pmysql in dbd_db_destroy(),\n         which is called by the DESTROY handler.\n      */\n    }\n    return result;\n  }\n}\n\n/*\n  safe_hv_fetch\n*/\nstatic char *safe_hv_fetch(pTHX_ HV *hv, const char *name, int name_length)\n{\n  SV** svp;\n  STRLEN len;\n  char *res= NULL;\n\n  if ((svp= hv_fetch(hv, name, name_length, FALSE)))\n  {\n    res= SvPV(*svp, len);\n    if (!len)\n      res= NULL;\n  }\n  return res;\n}\n\n/*\n Frontend for mysql_dr_connect\n*/\nstatic int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  return result;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_login\n *\n *  Purpose: Called for connecting to a database and logging in.\n *\n *  Input:   dbh - database handle being initialized\n *           imp_dbh - drivers private database handle data\n *           dbname - the database we want to log into; may be like\n *               \"dbname:host\" or \"dbname:host:port\"\n *           user - user name to connect as\n *           password - password to connect with\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql) {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        Safefree(imp_dbh->pmysql);\n\n    }\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_db_commit\n *           dbd_db_rollback\n *\n *  Purpose: You guess what they should do. \n *\n *  Input:   dbh - database handle being committed or rolled back\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\n{\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"COMMIT\", 6))\n#else\n    if (mysql_commit(imp_dbh->pmysql))\n#endif\n    {\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\n               ,mysql_sqlstate(imp_dbh->pmysql));\n      return FALSE;\n    }\n  }\n  else\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\n            \"Commit ineffective because transactions are not available\");\n  return TRUE;\n}\n\n/*\n dbd_db_rollback\n*/\nint\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\n  /* croak, if not in AutoCommit mode */\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n      if (mysql_rollback(imp_dbh->pmysql))\n#endif\n      {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        return FALSE;\n      }\n  }\n  else\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n             \"Rollback ineffective because transactions are not available\" ,NULL);\n  return TRUE;\n}\n\n/*\n ***************************************************************************\n *\n *  Name:    dbd_db_disconnect\n *\n *  Purpose: Disconnect a database handle from its database\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\n{\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* We assume that disconnect will always work       */\n  /* since most errors imply already disconnected.    */\n  DBIc_ACTIVE_off(imp_dbh);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %p\\n\",\n\t\t              imp_dbh->pmysql);\n  mysql_close(imp_dbh->pmysql );\n\n  /* We don't free imp_dbh since a reference still exists    */\n  /* The DESTROY method is the only one to 'free' memory.    */\n  return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_discon_all\n *\n *  Purpose: Disconnect all database handles at shutdown time\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_discon_all (SV *drh, imp_drh_t *imp_drh) {\n#if defined(dTHR)\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(drh);\n\n#if defined(DBD_MYSQL_EMBEDDED)\n  if (imp_drh->embedded.state)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Stop embedded server\\n\");\n\n    mysql_server_end();\n    if (imp_drh->embedded.groups)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.groups);\n      imp_drh->embedded.groups = NULL;\n    }\n\n    if (imp_drh->embedded.args)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.args);\n      imp_drh->embedded.args = NULL;\n    }\n\n\n  }\n#else\n  mysql_server_end();\n#endif\n\n  /* The disconnect_all concept is flawed and needs more work */\n  if (!PL_dirty && !SvTRUE(perl_get_sv(\"DBI::PERL_ENDING\",0))) {\n    sv_setiv(DBIc_ERR(imp_drh), (IV)1);\n    sv_setpv(DBIc_ERRSTR(imp_drh),\n             (char*)\"disconnect_all not implemented\");\n    /* NO EFFECT DBIh_EVENT2(drh, ERROR_event,\n      DBIc_ERR(imp_drh), DBIc_ERRSTR(imp_drh)); */\n    return FALSE;\n  }\n  PL_perl_destruct_level = 0;\n  return FALSE;\n}\n\n\n/****************************************************************************\n *\n *  Name:    dbd_db_destroy\n *\n *  Purpose: Our part of the dbh destructor\n *\n *  Input:   dbh - database handle being destroyed\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\n\n    /*\n     *  Being on the safe side never hurts ...\n     */\n  if (DBIc_ACTIVE(imp_dbh))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n        if ( mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n        if (mysql_rollback(imp_dbh->pmysql))\n#endif\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\n    }\n    dbd_db_disconnect(dbh, imp_dbh);\n  }\n  Safefree(imp_dbh->pmysql);\n\n  /* Tell DBI, that dbh->destroy must no longer be called */\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\n}\n\n/* \n ***************************************************************************\n *\n *  Name:    dbd_db_STORE_attrib\n *\n *  Purpose: Function for storing dbh attributes; we currently support\n *           just nothing. :-)\n *\n *  Input:   dbh - database handle being modified\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *           valuesv - the attribute value\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\nint\ndbd_db_STORE_attrib(\n                    SV* dbh,\n                    imp_dbh_t* imp_dbh,\n                    SV* keysv,\n                    SV* valuesv\n                   )\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  SV *cachesv = Nullsv;\n  int cacheit = FALSE;\n  const bool bool_value = SvTRUE(valuesv);\n\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\n\n      if (bool_value == oldval)\n        return TRUE;\n\n      /* if setting AutoCommit on ... */\n      if (!imp_dbh->no_autocommit_cmd)\n      {\n        if (\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\n#else\n            mysql_real_query(imp_dbh->pmysql,\n                             bool_value ? \"SET AUTOCOMMIT=1\" : \"SET AUTOCOMMIT=0\",\n                             16)\n#endif\n           )\n        {\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\n                   bool_value ?\n                   \"Turning on AutoCommit failed\" :\n                   \"Turning off AutoCommit failed\"\n                   ,NULL);\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\n        }\n      }\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\n    }\n    else\n    {\n      /*\n       *  We do support neither transactions nor \"AutoCommit\".\n       *  But we stub it. :-)\n      */\n      if (!bool_value)\n      {\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n                 \"Transactions not supported by database\" ,NULL);\n        croak(\"Transactions not supported by database\");\n      }\n    }\n  }\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\n    imp_dbh->use_mysql_use_result = bool_value;\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\n    imp_dbh->auto_reconnect = bool_value;\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\n    imp_dbh->use_server_side_prepare = bool_value;\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\n    imp_dbh->no_autocommit_cmd = bool_value;\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\n    imp_dbh->bind_type_guessing = bool_value;\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\n    imp_dbh->bind_type_guessing = bool_value;\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\n    imp_dbh->enable_utf8 = bool_value;\n  else if (kl == 20 && strEQ(key, \"mysql_enable_utf8mb4\"))\n    imp_dbh->enable_utf8mb4 = bool_value;\n#endif\n#if FABRIC_SUPPORT\n  else if (kl == 22 && strEQ(key, \"mysql_fabric_opt_group\"))\n    mysql_options(imp_dbh->pmysql, FABRIC_OPT_GROUP, (void *)SvPVbyte_nolen(valuesv));\n  else if (kl == 29 && strEQ(key, \"mysql_fabric_opt_default_mode\"))\n  {\n    if (SvOK(valuesv)) {\n      STRLEN len;\n      const char *str = SvPVbyte(valuesv, len);\n      if ( len == 0 || ( len == 2 && (strnEQ(str, \"ro\", 3) || strnEQ(str, \"rw\", 3)) ) )\n        mysql_options(imp_dbh->pmysql, FABRIC_OPT_DEFAULT_MODE, len == 0 ? NULL : str);\n      else\n        croak(\"Valid settings for FABRIC_OPT_DEFAULT_MODE are 'ro', 'rw', or undef/empty string\");\n    }\n    else {\n      mysql_options(imp_dbh->pmysql, FABRIC_OPT_DEFAULT_MODE, NULL);\n    }\n  }\n  else if (kl == 21 && strEQ(key, \"mysql_fabric_opt_mode\"))\n  {\n    STRLEN len;\n    const char *str = SvPVbyte(valuesv, len);\n    if (len != 2 || (strnNE(str, \"ro\", 3) && strnNE(str, \"rw\", 3)))\n      croak(\"Valid settings for FABRIC_OPT_MODE are 'ro' or 'rw'\");\n\n    mysql_options(imp_dbh->pmysql, FABRIC_OPT_MODE, str);\n  }\n  else if (kl == 34 && strEQ(key, \"mysql_fabric_opt_group_credentials\"))\n  {\n    croak(\"'fabric_opt_group_credentials' is not supported\");\n  }\n#endif\n  else\n    return FALSE;\t\t\t\t/* Unknown key */\n\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\n    (void)hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\n  return TRUE;\n}\n\n/***************************************************************************\n *\n *  Name:    dbd_db_FETCH_attrib\n *\n *  Purpose: Function for fetching dbh attributes\n *\n *  Input:   dbh - database handle being queried\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *\n *  Returns: An SV*, if successful; NULL otherwise\n *\n *  Notes:   Do not forget to call sv_2mortal in the former case!\n *\n **************************************************************************/\nstatic SV*\nmy_ulonglong2str(pTHX_ my_ulonglong val)\n{\n  char buf[64];\n  char *ptr = buf + sizeof(buf) - 1;\n\n  if (val == 0)\n    return newSVpvn(\"0\", 1);\n\n  *ptr = '\\0';\n  while (val > 0)\n  {\n    *(--ptr) = ('0' + (val % 10));\n    val = val / 10;\n  }\n  return newSVpvn(ptr, (buf+ sizeof(buf) - 1) - ptr);\n}\n\nSV* dbd_db_FETCH_attrib(SV *dbh, imp_dbh_t *imp_dbh, SV *keysv)\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  SV* result = NULL;\n  dbh= dbh;\n\n  switch (*key) {\n    case 'A':\n      if (strEQ(key, \"AutoCommit\"))\n      {\n        if (imp_dbh->has_transactions)\n          return sv_2mortal(boolSV(DBIc_has(imp_dbh,DBIcf_AutoCommit)));\n        /* Default */\n        return &PL_sv_yes;\n      }\n      break;\n  }\n  if (strncmp(key, \"mysql_\", 6) == 0) {\n    key = key+6;\n    kl = kl-6;\n  }\n\n  /* MONTY:  Check if kl should not be used or used everywhere */\n  switch(*key) {\n  case 'a':\n    if (kl == strlen(\"auto_reconnect\") && strEQ(key, \"auto_reconnect\"))\n      result= sv_2mortal(newSViv(imp_dbh->auto_reconnect));\n    break;\n  case 'b':\n    if (kl == strlen(\"bind_type_guessing\") &&\n        strEQ(key, \"bind_type_guessing\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_type_guessing));\n    }\n    else if (kl == strlen(\"bind_comment_placeholders\") &&\n        strEQ(key, \"bind_comment_placeholders\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_comment_placeholders));\n    }\n    break;\n  case 'c':\n    if (kl == 10 && strEQ(key, \"clientinfo\"))\n    {\n      const char* clientinfo = mysql_get_client_info();\n      result= clientinfo ?\n        sv_2mortal(newSVpvn(clientinfo, strlen(clientinfo))) : &PL_sv_undef;\n    }\n    else if (kl == 13 && strEQ(key, \"clientversion\"))\n    {\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_client_version()));\n    }\n    break;\n  case 'e':\n    if (strEQ(key, \"errno\"))\n      result= sv_2mortal(newSViv((IV)mysql_errno(imp_dbh->pmysql)));\n    else if ( strEQ(key, \"error\") || strEQ(key, \"errmsg\"))\n    {\n    /* Note that errmsg is obsolete, as of 2.09! */\n      const char* msg = mysql_error(imp_dbh->pmysql);\n      result= sv_2mortal(newSVpvn(msg, strlen(msg)));\n    }\n    /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n    else if (kl == strlen(\"enable_utf8mb4\") && strEQ(key, \"enable_utf8mb4\"))\n        result = sv_2mortal(newSViv(imp_dbh->enable_utf8mb4));\n    else if (kl == strlen(\"enable_utf8\") && strEQ(key, \"enable_utf8\"))\n        result = sv_2mortal(newSViv(imp_dbh->enable_utf8));\n#endif\n    break;\n\n  case 'd':\n    if (strEQ(key, \"dbd_stats\"))\n    {\n      HV* hv = newHV();\n      (void)hv_store(\n               hv,\n               \"auto_reconnects_ok\",\n               strlen(\"auto_reconnects_ok\"),\n               newSViv(imp_dbh->stats.auto_reconnects_ok),\n               0\n              );\n      (void)hv_store(\n               hv,\n               \"auto_reconnects_failed\",\n               strlen(\"auto_reconnects_failed\"),\n               newSViv(imp_dbh->stats.auto_reconnects_failed),\n               0\n              );\n\n      result= sv_2mortal((newRV_noinc((SV*)hv)));\n    }\n\n  case 'h':\n    if (strEQ(key, \"hostinfo\"))\n    {\n      const char* hostinfo = mysql_get_host_info(imp_dbh->pmysql);\n      result= hostinfo ?\n        sv_2mortal(newSVpvn(hostinfo, strlen(hostinfo))) : &PL_sv_undef;\n    }\n    break;\n\n  case 'i':\n    if (strEQ(key, \"info\"))\n    {\n      const char* info = mysql_info(imp_dbh->pmysql);\n      result= info ? sv_2mortal(newSVpvn(info, strlen(info))) : &PL_sv_undef;\n    }\n    else if (kl == 8  &&  strEQ(key, \"insertid\"))\n      /* We cannot return an IV, because the insertid is a long. */\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n    break;\n  case 'n':\n    if (kl == strlen(\"no_autocommit_cmd\") &&\n        strEQ(key, \"no_autocommit_cmd\"))\n      result = sv_2mortal(newSViv(imp_dbh->no_autocommit_cmd));\n    break;\n\n  case 'p':\n    if (kl == 9  &&  strEQ(key, \"protoinfo\"))\n      result= sv_2mortal(newSViv(mysql_get_proto_info(imp_dbh->pmysql)));\n    break;\n\n  case 's':\n    if (kl == 10 && strEQ(key, \"serverinfo\")) {\n      const char* serverinfo = mysql_get_server_info(imp_dbh->pmysql);\n      result= serverinfo ?\n        sv_2mortal(newSVpvn(serverinfo, strlen(serverinfo))) : &PL_sv_undef;\n    } \n    else if (kl == 13 && strEQ(key, \"serverversion\"))\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_server_version(imp_dbh->pmysql)));\n    else if (strEQ(key, \"sock\"))\n      result= sv_2mortal(newSViv(PTR2IV(imp_dbh->pmysql)));\n    else if (strEQ(key, \"sockfd\"))\n      result= sv_2mortal(newSViv((IV) imp_dbh->pmysql->net.fd));\n    else if (strEQ(key, \"stat\"))\n    {\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpvn(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (strEQ(key, \"stats\"))\n    {\n      /* Obsolete, as of 2.09 */\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpvn(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (kl == 14 && strEQ(key,\"server_prepare\"))\n        result= sv_2mortal(newSViv((IV) imp_dbh->use_server_side_prepare));\n    break;\n\n  case 't':\n    if (kl == 9  &&  strEQ(key, \"thread_id\"))\n      result= sv_2mortal(newSViv(mysql_thread_id(imp_dbh->pmysql)));\n    break;\n\n  case 'w':\n    if (kl == 13 && strEQ(key, \"warning_count\"))\n      result= sv_2mortal(newSViv(mysql_warning_count(imp_dbh->pmysql)));\n    break;\n  case 'u':\n    if (strEQ(key, \"use_result\"))\n    {\n      result= sv_2mortal(newSViv((IV) imp_dbh->use_mysql_use_result));\n    }\n    break;\n  }\n\n  if (result== NULL)\n    return Nullsv;\n\n  return result;\n}\n\n\n/* \n **************************************************************************\n *\n *  Name:    dbd_st_prepare\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *           statement - pointer to string with SQL statement\n *           attribs - statement attributes, currently not in use\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_prepare(\n  SV *sth,\n  imp_sth_t *imp_sth,\n  char *statement,\n  SV *attribs)\n{\n  int i;\n  SV **svp;\n  dTHX;\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n#if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  char *str_ptr, *str_last_ptr;\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n  int limit_flag=0;\n#endif\n#endif\n  int col_type, prepare_retval;\n  MYSQL_BIND *bind, *bind_end;\n  imp_sth_phb_t *fbind;\n#endif\n  D_imp_xxh(sth);\n  D_imp_dbh_from_sth;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\n                  MYSQL_VERSION_ID, statement);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\n  if (attribs)\n  {\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\n    imp_sth->use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\n\n    if(svp && SvTRUE(*svp)) {\n#if MYSQL_ASYNC\n        imp_sth->is_async = TRUE;\n        imp_sth->use_server_side_prepare = FALSE;\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        return 0;\n#endif\n    }\n  }\n\n  imp_sth->fetch_done= 0;\n#endif\n\n  imp_sth->done_desc= 0;\n  imp_sth->result= NULL;\n  imp_sth->currow= 0;\n\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\n  imp_sth->use_mysql_use_result= svp ?\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\n\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n    imp_sth->av_attr[i]= Nullav;\n\n  /*\n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets(sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set, check restrictions\\n\");\n    /*\n      This code is here because placeholder support is not implemented for\n      statements with :-\n      1. LIMIT < 5.0.7\n      2. CALL < 5.5.3 (Added support for out & inout parameters)\n      In these cases we have to disable server side prepared statements\n      NOTE: These checks could cause a false positive on statements which\n      include columns / table names that match \"call \" or \" limit \"\n    */ \n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n                    \"\\t\\tneed to test for LIMIT & CALL\\n\");\n#else\n                    \"\\t\\tneed to test for restrictions\\n\");\n#endif\n    str_last_ptr = statement + strlen(statement);\n    for (str_ptr= statement; str_ptr < str_last_ptr; str_ptr++)\n    {\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n      /*\n        Place holders not supported in LIMIT's\n      */\n      if (limit_flag)\n      {\n        if (*str_ptr == '?')\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tLIMIT and ? found, set to use_server_side_prepare=0\\n\");\n          /* ... then we do not want to try server side prepare (use emulation) */\n          imp_sth->use_server_side_prepare= 0;\n          break;\n        }\n      }\n      else if (str_ptr < str_last_ptr - 6 &&\n          isspace(*(str_ptr + 0)) &&\n          tolower(*(str_ptr + 1)) == 'l' &&\n          tolower(*(str_ptr + 2)) == 'i' &&\n          tolower(*(str_ptr + 3)) == 'm' &&\n          tolower(*(str_ptr + 4)) == 'i' &&\n          tolower(*(str_ptr + 5)) == 't' &&\n          isspace(*(str_ptr + 6)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"LIMIT set limit flag to 1\\n\");\n        limit_flag= 1;\n      }\n#endif\n      /*\n        Place holders not supported in CALL's\n      */\n      if (str_ptr < str_last_ptr - 4 &&\n           tolower(*(str_ptr + 0)) == 'c' &&\n           tolower(*(str_ptr + 1)) == 'a' &&\n           tolower(*(str_ptr + 2)) == 'l' &&\n           tolower(*(str_ptr + 3)) == 'l' &&\n           isspace(*(str_ptr + 4)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Disable PS mode for CALL()\\n\");\n        imp_sth->use_server_side_prepare= 0;\n        break;\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set\\n\");\n    /* do we really need this? If we do, we should return, not just continue */\n    if (imp_sth->stmt)\n      fprintf(stderr,\n              \"ERROR: Trying to prepare new stmt while we have \\\n              already not closed one \\n\");\n\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if (! imp_sth->stmt)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\n                      mysql_errno(imp_dbh->pmysql),\n                      mysql_error(imp_dbh->pmysql));\n    }\n\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\n                                       statement,\n                                       strlen(statement));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\n                      prepare_retval);\n\n    if (prepare_retval)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\n                      mysql_stmt_errno(imp_sth->stmt),\n                      mysql_stmt_error(imp_sth->stmt));\n\n      /* For commands that are not supported by server side prepared statement\n         mechanism lets try to pass them through regular API */\n      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_sqlstate(imp_dbh->pmysql));\n        mysql_stmt_close(imp_sth->stmt);\n        imp_sth->stmt= NULL;\n        return FALSE;\n      }\n    }\n    else\n    {\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\n      /* mysql_stmt_param_count */\n\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\n      {\n        int has_statement_fields= imp_sth->stmt->fields != 0;\n        /* Allocate memory for bind variables */\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->has_been_bound=  0;\n\n        /* Initialize ph variables with  NULL values */\n        for (i= 0,\n             bind=      imp_sth->bind,\n             fbind=     imp_sth->fbind,\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\n             bind < bind_end ;\n             bind++, fbind++, i++ )\n        {\n          /*\n            if this statement has a result set, field types will be\n            correctly identified. If there is no result set, such as\n            with an INSERT, fields will not be defined, and all buffer_type\n            will default to MYSQL_TYPE_VAR_STRING\n          */\n          col_type= (has_statement_fields ?\n                     imp_sth->stmt->fields[i].type : MYSQL_TYPE_STRING);\n\n          bind->buffer_type=  mysql_to_perl_type(col_type);\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\", col_type);\n\n          bind->buffer=       NULL;\n          bind->length=       &(fbind->length);\n          bind->is_null=      (char*) &(fbind->is_null);\n          fbind->is_null=     1;\n          fbind->length=      0;\n        }\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  /* Count the number of parameters (driver, vs server-side) */\n  if (imp_sth->use_server_side_prepare == 0)\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                            imp_dbh->bind_comment_placeholders);\n#else\n  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                          imp_dbh->bind_comment_placeholders);\n#endif\n\n  /* Allocate memory for parameters */\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\n  DBIc_IMPSET_on(imp_sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\n  return 1;\n}\n\n/***************************************************************************\n * Name: dbd_st_free_result_sets\n *\n * Purpose: Clean-up single or multiple result sets (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 ok\n *          0 error\n *************************************************************************/\nint mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n  int next_result_rc= -1;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  do\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\n\n    if (next_result_rc == 0)\n    {\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\n      {\n        /* Check for possible error */\n        if (mysql_field_count(imp_dbh->pmysql))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\n                                  mysql_error(imp_dbh->pmysql));\n\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n                   mysql_sqlstate(imp_dbh->pmysql));\n          return 0;\n        }\n      }\n    }\n    if (imp_sth->result)\n    {\n      mysql_free_result(imp_sth->result);\n      imp_sth->result=NULL;\n    }\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\n\n  if (next_result_rc > 0)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\n                    mysql_error(imp_dbh->pmysql));\n\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n  }\n\n#else\n\n  if (imp_sth->result)\n  {\n    mysql_free_result(imp_sth->result);\n    imp_sth->result=NULL;\n  }\n#endif\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\n\n  return 1;\n}\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n/***************************************************************************\n * Name: dbd_st_more_results\n *\n * Purpose: Move onto the next result set (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 if there are more results sets\n *          0 if there are not\n *         -1 for errors.\n *************************************************************************/\nint dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\n  int next_result_return_code, i;\n  MYSQL* svsock= imp_dbh->pmysql;\n\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  if (!mysql_more_results(svsock))\n  {\n    /* No more pending result set(s)*/\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\n    return 0;\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\n            \"Processing of multiple result set is not possible with server side prepare\");\n    return 0;\n  }\n\n  /*\n   *  Free cached array attributes\n   */\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  /* Release previous MySQL result*/\n  if (imp_sth->result)\n    mysql_free_result(imp_sth->result);\n\n  if (DBIc_ACTIVE(imp_sth))\n    DBIc_ACTIVE_off(imp_sth);\n\n  next_result_return_code= mysql_next_result(svsock);\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  /*\n    mysql_next_result returns\n      0 if there are more results\n     -1 if there are no more results\n     >0 if there was an error\n   */\n  if (next_result_return_code > 0)\n  {\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\n             mysql_sqlstate(svsock));\n\n    return 0;\n  }\n  else if(next_result_return_code == -1)                                                                                                                  \n  {                                                                                                                                                       \n    return 0;                                                                                                                                             \n  }  \n  else\n  {\n    /* Store the result from the Query */\n    imp_sth->result = use_mysql_use_result ?\n     mysql_use_result(svsock) : mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n    {\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \n               mysql_sqlstate(svsock));\n      return 0;\n    }\n\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\n\n    if (imp_sth->result == NULL)\n    {\n      /* No \"real\" rowset*/\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n\t\t\t               sv_2mortal(newSViv(0)));\n      return 1;\n    }\n    else\n    {\n      /* We have a new rowset */\n      imp_sth->currow=0;\n\n\n      /* delete cached handle attributes */\n      /* XXX should be driven by a list to ease maintenance */\n      (void)hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\n\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\n      );\n\n      DBIc_ACTIVE_on(imp_sth);\n\n      imp_sth->done_desc = 0;\n    }\n    imp_dbh->pmysql->net.last_errno= 0;\n    return 1;\n  }\n}\n#endif\n/**************************************************************************\n *\n *  Name:    mysql_st_internal_execute\n *\n *  Purpose: Internal version for executing a statement, called both from\n *           within the \"do\" and the \"execute\" method.\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n\nmy_ulonglong mysql_st_internal_execute(\n                                       SV *h, /* could be sth or dbh */\n                                       SV *statement,\n                                       SV *attribs,\n                                       int num_params,\n                                       imp_sth_ph_t *params,\n                                       MYSQL_RES **result,\n                                       MYSQL *svsock,\n                                       int use_mysql_use_result\n                                      )\n{\n  dTHX;\n  bool bind_type_guessing= FALSE;\n  bool bind_comment_placeholders= TRUE;\n  STRLEN slen;\n  char *sbuf = SvPV(statement, slen);\n  char *table;\n  char *salloc;\n  int htype;\n#if MYSQL_ASYNC\n  bool async = FALSE;\n#endif\n  my_ulonglong rows= 0;\n  /* thank you DBI.c for this info! */\n  D_imp_xxh(h);\n  attribs= attribs;\n\n  htype= DBIc_TYPE(imp_xxh);\n  /*\n    It is important to import imp_dbh properly according to the htype\n    that it is! Also, one might ask why bind_type_guessing is assigned\n    in each block. Well, it's because D_imp_ macros called in these\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\n    if/else (when compiled, it fails for imp_dbh not being defined).\n  */\n  /* h is a dbh */\n  if (htype == DBIt_DB)\n  {\n    D_imp_dbh(h);\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh && imp_dbh->bind_type_guessing)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\n#endif\n  }\n  /* h is a sth */\n  else\n  {\n    D_imp_sth(h);\n    D_imp_dbh_from_sth;\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = imp_sth->is_async;\n    if(async) {\n        imp_dbh->async_query_in_flight = imp_sth;\n    } else {\n        imp_dbh->async_query_in_flight = NULL;\n    }\n#endif\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\n                  MYSQL_VERSION_ID );\n\n  salloc= parse_params(imp_xxh,\n                              aTHX_ svsock,\n                              sbuf,\n                              &slen,\n                              params,\n                              num_params,\n                              bind_type_guessing,\n                              bind_comment_placeholders);\n\n  if (salloc)\n  {\n    sbuf= salloc;\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\n  }\n\n  if (slen >= 11 && (!strncmp(sbuf, \"listfields \", 11) ||\n                     !strncmp(sbuf, \"LISTFIELDS \", 11)))\n  {\n    /* remove pre-space */\n    slen-= 10;\n    sbuf+= 10;\n    while (slen && isspace(*sbuf)) { --slen;  ++sbuf; }\n\n    if (!slen)\n    {\n      do_error(h, JW_ERR_QUERY, \"Missing table name\" ,NULL);\n      return -2;\n    }\n    if (!(table= malloc(slen+1)))\n    {\n      do_error(h, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      return -2;\n    }\n\n    strncpy(table, sbuf, slen);\n    sbuf= table;\n\n    while (slen && !isspace(*sbuf))\n    {\n      --slen;\n      ++sbuf;\n    }\n    *sbuf++= '\\0';\n\n    *result= mysql_list_fields(svsock, table, NULL);\n\n    free(table);\n\n    if (!(*result))\n    {\n      do_error(h, mysql_errno(svsock), mysql_error(svsock)\n               ,mysql_sqlstate(svsock));\n      return -2;\n    }\n\n    return 0;\n  }\n\n#if MYSQL_ASYNC\n  if(async) {\n    if((mysql_send_query(svsock, sbuf, slen)) &&\n       (!mysql_db_reconnect(h) ||\n        (mysql_send_query(svsock, sbuf, slen))))\n    {\n        rows = -2;\n    } else {\n        rows = 0;\n    }\n  } else {\n#endif\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\n          (!mysql_db_reconnect(h)  ||\n           (mysql_real_query(svsock, sbuf, slen))))\n      {\n        rows = -2;\n      } else {\n          /** Store the result from the Query */\n          *result= use_mysql_use_result ?\n            mysql_use_result(svsock) : mysql_store_result(svsock);\n\n          if (mysql_errno(svsock))\n            rows = -2;\n          else if (*result)\n            rows = mysql_num_rows(*result);\n          else {\n            rows = mysql_affected_rows(svsock);\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\n            if (rows == (my_ulonglong)-1)\n              rows = -2;\n          }\n      }\n#if MYSQL_ASYNC\n  }\n#endif\n\n  if (salloc)\n    Safefree(salloc);\n\n  if(rows == (my_ulonglong)-2) {\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \n             mysql_sqlstate(svsock));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\n  }\n  return(rows);\n}\n\n /**************************************************************************\n *\n *  Name:    mysql_st_internal_execute41\n *\n *  Purpose: Internal version for executing a prepared statement, called both\n *           from within the \"do\" and the \"execute\" method.\n *           MYSQL 4.1 API\n *\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\nmy_ulonglong mysql_st_internal_execute41(\n                                         SV *sth,\n                                         int num_params,\n                                         MYSQL_RES **result,\n                                         MYSQL_STMT *stmt,\n                                         MYSQL_BIND *bind,\n                                         int *has_been_bound\n                                        )\n{\n  int i;\n  enum enum_field_types enum_type;\n  dTHX;\n  int execute_retval;\n  my_ulonglong rows=0;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t-> mysql_st_internal_execute41\\n\");\n\n  /* free result if exists */\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n\n  /*\n    If were performed any changes with ph variables\n    we have to rebind them\n  */\n\n  if (num_params > 0 && !(*has_been_bound))\n  {\n    if (mysql_stmt_bind_param(stmt,bind))\n      goto error;\n\n    *has_been_bound= 1;\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\n                  num_params);\n\n  execute_retval= mysql_stmt_execute(stmt);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\n                  execute_retval);\n  if (execute_retval)\n    goto error;\n\n  /*\n   This statement does not return a result set (INSERT, UPDATE...)\n  */\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\n  {\n    if (mysql_stmt_errno(stmt))\n      goto error;\n\n    rows= mysql_stmt_affected_rows(stmt);\n\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\n    if (rows == (my_ulonglong)-1)\n      goto error;\n  }\n  /*\n    This statement returns a result set (SELECT...)\n  */\n  else\n  {\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_BIT)\n        {\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\n            my_bool on = 1;\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\n            break;\n        }\n    }\n    /* Get the total rows affected and return */\n    if (mysql_stmt_store_result(stmt))\n      goto error;\n    else\n      rows= mysql_stmt_num_rows(stmt);\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_internal_execute_41 returning %llu rows\\n\",\n                  rows);\n  return(rows);\n\nerror:\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"     errno %d err message %s\\n\",\n                  mysql_stmt_errno(stmt),\n                  mysql_stmt_error(stmt));\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\n           mysql_stmt_sqlstate(stmt));\n  mysql_stmt_reset(stmt);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_st_internal_execute41\\n\");\n  return -2;\n\n}\n#endif\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_execute\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  char actual_row_num[64];\n  int i;\n  SV **statement;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  ASYNC_CHECK_RETURN(sth, -2);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n      \" -> dbd_st_execute for %p\\n\", sth);\n\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  /* Free cached array attributes */\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\n\n  /* \n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets (sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare && ! imp_sth->use_mysql_use_result)\n  {\n    imp_sth->row_num= mysql_st_internal_execute41(\n                                                  sth,\n                                                  DBIc_NUM_PARAMS(imp_sth),\n                                                  &imp_sth->result,\n                                                  imp_sth->stmt,\n                                                  imp_sth->bind,\n                                                  &imp_sth->has_been_bound\n                                                 );\n  }\n  else {\n#endif\n    imp_sth->row_num= mysql_st_internal_execute(\n                                                sth,\n                                                *statement,\n                                                NULL,\n                                                DBIc_NUM_PARAMS(imp_sth),\n                                                imp_sth->params,\n                                                &imp_sth->result,\n                                                imp_dbh->pmysql,\n                                                imp_sth->use_mysql_use_result\n                                               );\n#if MYSQL_ASYNC\n    if(imp_dbh->async_query_in_flight) {\n        DBIc_ACTIVE_on(imp_sth);\n        return 0;\n    }\n#endif\n  }\n\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\n  {\n    if (!imp_sth->result)\n    {\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (mysql_more_results(imp_dbh->pmysql))\n        DBIc_ACTIVE_on(imp_sth);\n#endif\n    }\n    else\n    {\n      /** Store the result in the current statement handle */\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n      DBIc_ACTIVE_on(imp_sth);\n      if (!imp_sth->use_server_side_prepare)\n        imp_sth->done_desc= 0;\n      imp_sth->fetch_done= 0;\n    }\n  }\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    /* \n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \n      consistently!!\n    */\n    sprintf(actual_row_num, \"%llu\", imp_sth->row_num);\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\n                  actual_row_num);\n  }\n\n  return (int)imp_sth->row_num;\n}\n\n /**************************************************************************\n *\n *  Name:    dbd_describe\n *\n *  Purpose: Called from within the fetch method to describe the result\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - our part of the statement handle, there's no\n *               need for supplying both; Tim just doesn't remove it\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_describe(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_xxh(sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    int i;\n    int col_type;\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\n    imp_sth_fbh_t *fbh;\n    MYSQL_BIND *buffer;\n    MYSQL_FIELD *fields;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\n                    num_fields);\n\n    if (imp_sth->done_desc)\n      return TRUE;\n\n    if (!num_fields || !imp_sth->result)\n    {\n      /* no metadata */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"no metadata information while trying describe result set\",\n               NULL);\n      return 0;\n    }\n\n    /* allocate fields buffers  */\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\n    {\n      /* Out of memory */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"Out of memory in dbd_sescribe()\",NULL);\n      return 0;\n    }\n\n    fields= mysql_fetch_fields(imp_sth->result);\n\n    for (\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\n         i < num_fields;\n         i++, fbh++, buffer++\n        )\n    {\n      /* get the column type */\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\n\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\n                      i, col_type, fbh->length);\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\n                      fields[i].length, fields[i].max_length, fields[i].type,\n                      fields[i].charsetnr);\n      }\n      fbh->charsetnr = fields[i].charsetnr;\n#if MYSQL_VERSION_ID < FIELD_CHARSETNR_VERSION \n      fbh->flags     = fields[i].flags;\n#endif\n\n      buffer->buffer_type= mysql_to_perl_type(col_type);\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\n                      col_type);\n      buffer->length= &(fbh->length);\n      buffer->is_null= (my_bool*) &(fbh->is_null);\n      buffer->error= (my_bool*) &(fbh->error);\n\n      switch (buffer->buffer_type) {\n      case MYSQL_TYPE_DOUBLE:\n        buffer->buffer_length= sizeof(fbh->ddata);\n        buffer->buffer= (char*) &fbh->ddata;\n        break;\n\n      case MYSQL_TYPE_LONG:\n        buffer->buffer_length= sizeof(fbh->ldata);\n        buffer->buffer= (char*) &fbh->ldata;\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\n        break;\n\n      case MYSQL_TYPE_BIT:\n        buffer->buffer_length= 8;\n        Newz(908, fbh->data, buffer->buffer_length, char);\n        buffer->buffer= (char *) fbh->data;\n        break;\n\n      default:\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\n        Newz(908, fbh->data, buffer->buffer_length, char);\n        buffer->buffer= (char *) fbh->data;\n      }\n    }\n\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\n    {\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n               mysql_stmt_error(imp_sth->stmt),\n               mysql_stmt_sqlstate(imp_sth->stmt));\n      return 0;\n    }\n  }\n#endif\n\n  imp_sth->done_desc= 1;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\n  return TRUE;\n}\n\n/**************************************************************************\n *\n *  Name:    dbd_st_fetch\n *\n *  Purpose: Called for fetching a result row\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: array of columns; the array is allocated by DBI via\n *           DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth), even the values\n *           of the array are prepared, we just need to modify them\n *           appropriately\n *\n **************************************************************************/\n\nAV*\ndbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  We have to fetch all data from stmt\n  There is may be useful for 2 cases:\n  1. st_finish when we have undef statement\n  2. call st_execute again when we have some unfetched data in stmt\n */\n\nint mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\n\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\n      !imp_sth->fetch_done)\n    mysql_stmt_free_result(imp_sth->stmt);\n  return 1;\n}\n#endif\n\n/***************************************************************************\n *\n *  Name:    dbd_st_finish\n *\n *  Purpose: Called for freeing a mysql result\n *\n *  Input:   sth - statement handle being finished\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error() will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n#if MYSQL_ASYNC\n  D_imp_dbh_from_sth;\n  if(imp_dbh->async_query_in_flight) {\n    mysql_db_async_result(sth, &imp_sth->result);\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (imp_sth && imp_sth->stmt)\n    {\n      if (!mysql_st_clean_cursor(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE,\n                 \"Error happened while tried to clean up stmt\",NULL);\n        return 0;\n      }\n    }\n  }\n#endif\n\n  /*\n    Cancel further fetches from this cursor.\n    We don't close the cursor till DESTROY.\n    The application may re execute it.\n  */\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\n  {\n    /*\n      Clean-up previous result set(s) for sth to prevent\n      'Commands out of sync' error\n    */\n    mysql_st_free_result_sets(sth, imp_sth);\n  }\n  DBIc_ACTIVE_off(imp_sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\n  }\n  return 1;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_st_destroy\n *\n *  Purpose: Our part of the statement handles destructor\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  int i;\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  imp_sth_fbh_t *fbh;\n  int n;\n\n  n= DBIc_NUM_PARAMS(imp_sth);\n  if (n)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          n, imp_sth->bind, imp_sth->fbind);\n\n    free_bind(imp_sth->bind);\n    free_fbind(imp_sth->fbind);\n  }\n\n  fbh= imp_sth->fbh;\n  if (fbh)\n  {\n    n = DBIc_NUM_FIELDS(imp_sth);\n    i = 0;\n    while (i < n)\n    {\n      if (fbh[i].data) Safefree(fbh[i].data);\n      ++i;\n    }\n\n    free_fbuffer(fbh);\n    if (imp_sth->buffer)\n      free_bind(imp_sth->buffer);\n  }\n\n  if (imp_sth->stmt)\n  {\n    if (mysql_stmt_close(imp_sth->stmt))\n    {\n      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),\n          mysql_stmt_error(imp_sth->stmt),\n          mysql_stmt_sqlstate(imp_sth->stmt));\n    }\n  }\n#endif\n\n\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\n\n  /* Free values allocated by dbd_bind_ph */\n  if (imp_sth->params)\n  {\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\n    imp_sth->params= NULL;\n  }\n\n  /* Free cached array attributes */\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n    imp_sth->av_attr[i]= Nullav;\n  }\n  /* let DBI know we've done it   */\n  DBIc_IMPSET_off(imp_sth);\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_STORE_attrib\n *\n *  Purpose: Modifies a statement handles attributes; we currently\n *           support just nothing\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *           valuesv - attribute value\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_STORE_attrib(\n                    SV *sth,\n                    imp_sth_t *imp_sth,\n                    SV *keysv,\n                    SV *valuesv\n                   )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  int retval= FALSE;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t-> dbd_st_STORE_attrib for %p, key %s\\n\",\n                  sth, key);\n\n  if (strEQ(key, \"mysql_use_result\"))\n  {\n    imp_sth->use_mysql_use_result= SvTRUE(valuesv);\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t<- dbd_st_STORE_attrib for %p, result %d\\n\",\n                  sth, retval);\n\n  return retval;\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_internal\n *\n *  Purpose: Retrieves a statement handles array attributes; we use\n *           a separate function, because creating the array\n *           attributes shares much code and it aids in supporting\n *           enhanced features like caching.\n *\n *  Input:   sth - statement handle; may even be a database handle,\n *               in which case this will be used for storing error\n *               messages only. This is only valid, if cacheit (the\n *               last argument) is set to TRUE.\n *           what - internal attribute number\n *           res - pointer to a DBMS result\n *           cacheit - TRUE, if results may be cached in the sth.\n *\n *  Returns: RV pointing to result array in case of success, NULL\n *           otherwise; do_error has already been called in the latter\n *           case.\n *\n **************************************************************************/\n\n#ifndef IS_KEY\n#define IS_KEY(A) (((A) & (PRI_KEY_FLAG | UNIQUE_KEY_FLAG | MULTIPLE_KEY_FLAG)) != 0)\n#endif\n\n#if !defined(IS_AUTO_INCREMENT) && defined(AUTO_INCREMENT_FLAG)\n#define IS_AUTO_INCREMENT(A) (((A) & AUTO_INCREMENT_FLAG) != 0)\n#endif\n\nSV*\ndbd_st_FETCH_internal(\n  SV *sth,\n  int what,\n  MYSQL_RES *res,\n  int cacheit\n)\n{\n  dTHX;\n  D_imp_sth(sth);\n  AV *av= Nullav;\n  MYSQL_FIELD *curField;\n\n  /* Are we asking for a legal value? */\n  if (what < 0 ||  what >= AV_ATTRIB_LAST)\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Not implemented\", NULL);\n\n  /* Return cached value, if possible */\n  else if (cacheit  &&  imp_sth->av_attr[what])\n    av= imp_sth->av_attr[what];\n\n  /* Does this sth really have a result? */\n  else if (!res)\n    do_error(sth, JW_ERR_NOT_ACTIVE,\n\t     \"statement contains no result\" ,NULL);\n  /* Do the real work. */\n  else\n  {\n    av= newAV();\n    mysql_field_seek(res, 0);\n    while ((curField= mysql_fetch_field(res)))\n    {\n      SV *sv;\n\n      switch(what) {\n      case AV_ATTRIB_NAME:\n        sv= newSVpvn(curField->name, strlen(curField->name));\n        break;\n\n      case AV_ATTRIB_TABLE:\n        sv= newSVpvn(curField->table, strlen(curField->table));\n        break;\n\n      case AV_ATTRIB_TYPE:\n        sv= newSViv((int) curField->type);\n        break;\n\n      case AV_ATTRIB_SQL_TYPE:\n        sv= newSViv((int) native2sql(curField->type)->data_type);\n        break;\n      case AV_ATTRIB_IS_PRI_KEY:\n        sv= boolSV(IS_PRI_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_NOT_NULL:\n        sv= boolSV(IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_NULLABLE:\n        sv= boolSV(!IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_LENGTH:\n        sv= newSViv((int) curField->length);\n        break;\n\n      case AV_ATTRIB_IS_NUM:\n        sv= newSViv((int) native2sql(curField->type)->is_num);\n        break;\n\n      case AV_ATTRIB_TYPE_NAME:\n        sv= newSVpv((char*) native2sql(curField->type)->type_name, 0);\n        break;\n\n      case AV_ATTRIB_MAX_LENGTH:\n        sv= newSViv((int) curField->max_length);\n        break;\n\n      case AV_ATTRIB_IS_AUTO_INCREMENT:\n#if defined(AUTO_INCREMENT_FLAG)\n        sv= boolSV(IS_AUTO_INCREMENT(curField->flags));\n        break;\n#else\n        croak(\"AUTO_INCREMENT_FLAG is not supported on this machine\");\n#endif\n\n      case AV_ATTRIB_IS_KEY:\n        sv= boolSV(IS_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_BLOB:\n        sv= boolSV(IS_BLOB(curField->flags));\n        break;\n\n      case AV_ATTRIB_SCALE:\n        sv= newSViv((int) curField->decimals);\n        break;\n\n      case AV_ATTRIB_PRECISION:\n        sv= newSViv((int) (curField->length > curField->max_length) ?\n                     curField->length : curField->max_length);\n        break;\n\n      default:\n        sv= &PL_sv_undef;\n        break;\n      }\n      av_push(av, sv);\n    }\n\n    /* Ensure that this value is kept, decremented in\n     *  dbd_st_destroy and dbd_st_execute.  */\n    if (!cacheit)\n      return sv_2mortal(newRV_noinc((SV*)av));\n    imp_sth->av_attr[what]= av;\n  }\n\n  if (av == Nullav)\n    return &PL_sv_undef;\n\n  return sv_2mortal(newRV_inc((SV*)av));\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_attrib\n *\n *  Purpose: Retrieves a statement handles attributes\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *\n *  Returns: NULL for an unknown attribute, \"undef\" for error,\n *           attribute value otherwise.\n *\n **************************************************************************/\n\n#define ST_FETCH_AV(what) \\\n    dbd_st_FETCH_internal(sth, (what), imp_sth->result, TRUE)\n\n  SV* dbd_st_FETCH_attrib(\n                          SV *sth,\n                          imp_sth_t *imp_sth,\n                          SV *keysv\n                         )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  SV *retsv= Nullsv;\n  D_imp_xxh(sth);\n\n  if (kl < 2)\n    return Nullsv;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"    -> dbd_st_FETCH_attrib for %p, key %s\\n\",\n                  sth, key);\n\n  switch (*key) {\n  case 'N':\n    if (strEQ(key, \"NAME\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NAME);\n    else if (strEQ(key, \"NULLABLE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NULLABLE);\n    break;\n  case 'P':\n    if (strEQ(key, \"PRECISION\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_PRECISION);\n    if (strEQ(key, \"ParamValues\"))\n    {\n        HV *pvhv= newHV();\n        if (DBIc_NUM_PARAMS(imp_sth))\n        {\n            int n;\n            char key[100];\n            I32 keylen;\n            for (n= 0; n < DBIc_NUM_PARAMS(imp_sth); n++)\n            {\n                keylen= sprintf(key, \"%d\", n);\n                (void)hv_store(pvhv, key,\n                         keylen, newSVsv(imp_sth->params[n].value), 0);\n            }\n        }\n        retsv= sv_2mortal(newRV_noinc((SV*)pvhv));\n    }\n    break;\n  case 'S':\n    if (strEQ(key, \"SCALE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SCALE);\n    break;\n  case 'T':\n    if (strEQ(key, \"TYPE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SQL_TYPE);\n    break;\n  case 'm':\n    switch (kl) {\n    case 10:\n      if (strEQ(key, \"mysql_type\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TYPE);\n      break;\n    case 11:\n      if (strEQ(key, \"mysql_table\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TABLE);\n      break;\n    case 12:\n      if (       strEQ(key, \"mysql_is_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_KEY);\n      else if (strEQ(key, \"mysql_is_num\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_NUM);\n      else if (strEQ(key, \"mysql_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_LENGTH);\n      else if (strEQ(key, \"mysql_result\"))\n        retsv= sv_2mortal(newSViv(PTR2IV(imp_sth->result)));\n      break;\n    case 13:\n      if (strEQ(key, \"mysql_is_blob\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_BLOB);\n      break;\n    case 14:\n      if (strEQ(key, \"mysql_insertid\"))\n      {\n        /* We cannot return an IV, because the insertid is a long.  */\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"INSERT ID %llu\\n\", imp_sth->insertid);\n\n        return sv_2mortal(my_ulonglong2str(aTHX_ imp_sth->insertid));\n      }\n      break;\n    case 15:\n      if (strEQ(key, \"mysql_type_name\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_TYPE_NAME);\n      break;\n    case 16:\n      if ( strEQ(key, \"mysql_is_pri_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_PRI_KEY);\n      else if (strEQ(key, \"mysql_max_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_MAX_LENGTH);\n      else if (strEQ(key, \"mysql_use_result\"))\n        retsv= boolSV(imp_sth->use_mysql_use_result);\n      break;\n    case 19:\n      if (strEQ(key, \"mysql_warning_count\"))\n        retsv= sv_2mortal(newSViv((IV) imp_sth->warning_count));\n      break;\n    case 20:\n      if (strEQ(key, \"mysql_server_prepare\"))\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n        retsv= sv_2mortal(newSViv((IV) imp_sth->use_server_side_prepare));\n#else\n        retsv= boolSV(0);\n#endif\n      break;\n    case 23:\n      if (strEQ(key, \"mysql_is_auto_increment\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_IS_AUTO_INCREMENT);\n      break;\n    }\n    break;\n  }\n  return retsv;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_blob_read\n *\n *  Purpose: Used for blob reads if the statement handles \"LongTruncOk\"\n *           attribute (currently not supported by DBD::mysql)\n *\n *  Input:   SV* - statement handle from which a blob will be fetched\n *           imp_sth - drivers private statement handle data\n *           field - field number of the blob (note, that a row may\n *               contain more than one blob)\n *           offset - the offset of the field, where to start reading\n *           len - maximum number of bytes to read\n *           destrv - RV* that tells us where to store\n *           destoffset - destination offset\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_blob_read (\n  SV *sth,\n  imp_sth_t *imp_sth,\n  int field,\n  long offset,\n  long len,\n  SV *destrv,\n  long destoffset)\n{\n    /* quell warnings */\n    sth= sth;\n    imp_sth=imp_sth;\n    field= field;\n    offset= offset;\n    len= len;\n    destrv= destrv;\n    destoffset= destoffset;\n    return FALSE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_bind_ph\n *\n *  Purpose: Binds a statement value to a parameter\n *\n *  Input:   sth - statement handle\n *           imp_sth - drivers private statement handle data\n *           param - parameter number, counting starts with 1\n *           value - value being inserted for parameter \"param\"\n *           sql_type - SQL type of the value\n *           attribs - bind parameter attributes, currently this must be\n *               one of the values SQL_CHAR, ...\n *           inout - TRUE, if parameter is an output variable (currently\n *               this is not supported)\n *           maxlen - ???\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char *err_msg;\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upon binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0))));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %\"IVdf\" ->%\"IVdf\"<- IS A INT NUMBER\\n\",\n                          sql_type, *(IV *)buffer);\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %\"IVdf\" ->%f<- IS A FLOAT NUMBER\\n\",\n                          sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %\"IVdf\", buffertype=%d\\n\", sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %\"IVdf\" ->length %d<- IS A STRING or BLOB\\n\",\n                        sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%\"IVdf\"\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has been called */\n    if (imp_sth->has_been_bound)\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n\n    imp_sth->bind[idx].buffer_type= buffer_type;\n    imp_sth->bind[idx].buffer= buffer;\n    imp_sth->bind[idx].buffer_length= buffer_length;\n\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}\n\n\n/***************************************************************************\n *\n *  Name:    mysql_db_reconnect\n *\n *  Purpose: If the server has disconnected, try to reconnect.\n *\n *  Input:   h - database or statement handle\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint mysql_db_reconnect(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* imp_dbh;\n  MYSQL save_socket;\n\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\n  {\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\n    h = DBIc_PARENT_H(imp_xxh);\n  }\n  else\n    imp_dbh= (imp_dbh_t*) imp_xxh;\n\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR)\n    /* Other error */\n    return FALSE;\n\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\n  {\n    /* We never reconnect if AutoCommit is turned off.\n     * Otherwise we might get an inconsistent transaction\n     * state.\n     */\n    return FALSE;\n  }\n\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\n   * fail.  Think server is down & reconnect fails but the application eval{}s\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\n   */\n  save_socket= *(imp_dbh->pmysql);\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\n\n  /* we should disconnect the db handle before reconnecting, this will\n   * prevent my_login from thinking it's adopting an active child which\n   * would prevent the handle from actually reconnecting\n   */\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\n  {\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\n    ++imp_dbh->stats.auto_reconnects_failed;\n    return FALSE;\n  }\n\n  /*\n   *  Tell DBI, that dbh->disconnect should be called for this handle\n   */\n  DBIc_ACTIVE_on(imp_dbh);\n\n  ++imp_dbh->stats.auto_reconnects_ok;\n  return TRUE;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_type_info_all\n *\n *  Purpose: Implements $dbh->type_info_all\n *\n *  Input:   dbh - database handle\n *           imp_sth - drivers private database handle data\n *\n *  Returns: RV to AV of types\n *\n **************************************************************************/\n\n#define PV_PUSH(c)                              \\\n    if (c) {                                    \\\n\tsv= newSVpv((char*) (c), 0);           \\\n\tSvREADONLY_on(sv);                      \\\n    } else {                                    \\\n        sv= &PL_sv_undef;                         \\\n    }                                           \\\n    av_push(row, sv);\n\n#define IV_PUSH(i) sv= newSViv((i)); SvREADONLY_on(sv); av_push(row, sv);\n\nAV *dbd_db_type_info_all(SV *dbh, imp_dbh_t *imp_dbh)\n{\n  dTHX;\n  AV *av= newAV();\n  AV *row;\n  HV *hv;\n  SV *sv;\n  int i;\n  const char *cols[] = {\n    \"TYPE_NAME\",\n    \"DATA_TYPE\",\n    \"COLUMN_SIZE\",\n    \"LITERAL_PREFIX\",\n    \"LITERAL_SUFFIX\",\n    \"CREATE_PARAMS\",\n    \"NULLABLE\",\n    \"CASE_SENSITIVE\",\n    \"SEARCHABLE\",\n    \"UNSIGNED_ATTRIBUTE\",\n    \"FIXED_PREC_SCALE\",\n    \"AUTO_UNIQUE_VALUE\",\n    \"LOCAL_TYPE_NAME\",\n    \"MINIMUM_SCALE\",\n    \"MAXIMUM_SCALE\",\n    \"NUM_PREC_RADIX\",\n    \"SQL_DATATYPE\",\n    \"SQL_DATETIME_SUB\",\n    \"INTERVAL_PRECISION\",\n    \"mysql_native_type\",\n    \"mysql_is_num\"\n  };\n\n  dbh= dbh;\n  imp_dbh= imp_dbh;\n \n  hv= newHV();\n  av_push(av, newRV_noinc((SV*) hv));\n  for (i= 0;  i < (int)(sizeof(cols) / sizeof(const char*));  i++)\n  {\n    if (!hv_store(hv, (char*) cols[i], strlen(cols[i]), newSViv(i), 0))\n    {\n      SvREFCNT_dec((SV*) av);\n      return Nullav;\n    }\n  }\n  for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n  {\n    const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n\n    row= newAV();\n    av_push(av, newRV_noinc((SV*) row));\n    PV_PUSH(t->type_name);\n    IV_PUSH(t->data_type);\n    IV_PUSH(t->column_size);\n    PV_PUSH(t->literal_prefix);\n    PV_PUSH(t->literal_suffix);\n    PV_PUSH(t->create_params);\n    IV_PUSH(t->nullable);\n    IV_PUSH(t->case_sensitive);\n    IV_PUSH(t->searchable);\n    IV_PUSH(t->unsigned_attribute);\n    IV_PUSH(t->fixed_prec_scale);\n    IV_PUSH(t->auto_unique_value);\n    PV_PUSH(t->local_type_name);\n    IV_PUSH(t->minimum_scale);\n    IV_PUSH(t->maximum_scale);\n\n    if (t->num_prec_radix)\n    {\n      IV_PUSH(t->num_prec_radix);\n    }\n    else\n      av_push(row, &PL_sv_undef);\n\n    IV_PUSH(t->sql_datatype); /* SQL_DATATYPE*/\n    IV_PUSH(t->sql_datetime_sub); /* SQL_DATETIME_SUB*/\n    IV_PUSH(t->interval_precision); /* INTERVAL_PERCISION */\n    IV_PUSH(t->native_type);\n    IV_PUSH(t->is_num);\n  }\n  return av;\n}\n\n\n/*\n  dbd_db_quote\n\n  Properly quotes a value \n*/\nSV* dbd_db_quote(SV *dbh, SV *str, SV *type)\n{\n  dTHX;\n  SV *result;\n\n  if (SvGMAGICAL(str))\n    mg_get(str);\n\n  if (!SvOK(str))\n    result= newSVpvn(\"NULL\", 4);\n  else\n  {\n    char *ptr, *sptr;\n    STRLEN len;\n\n    D_imp_dbh(dbh);\n\n    if (type && SvMAGICAL(type))\n      mg_get(type);\n\n    if (type  &&  SvOK(type))\n    {\n      int i;\n      int tp= SvIV(type);\n      for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n      {\n        const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n        if (t->data_type == tp)\n        {\n          if (!t->literal_prefix)\n            return Nullsv;\n          break;\n        }\n      }\n    }\n\n    ptr= SvPV(str, len);\n    result= newSV(len*2+3);\n#ifdef SvUTF8\n    if (SvUTF8(str)) SvUTF8_on(result);\n#endif\n    sptr= SvPVX(result);\n\n    *sptr++ = '\\'';\n    sptr+= mysql_real_escape_string(imp_dbh->pmysql, sptr,\n                                     ptr, len);\n    *sptr++= '\\'';\n    SvPOK_on(result);\n    SvCUR_set(result, sptr - SvPVX(result));\n    /* Never hurts NUL terminating a Per string */\n    *sptr++= '\\0';\n  }\n  return result;\n}\n\n#ifdef DBD_MYSQL_INSERT_ID_IS_GOOD\nSV *mysql_db_last_insert_id(SV *dbh, imp_dbh_t *imp_dbh,\n        SV *catalog, SV *schema, SV *table, SV *field, SV *attr)\n{\n  dTHX;\n  /* all these non-op settings are to stifle OS X compile warnings */\n  imp_dbh= imp_dbh;\n  dbh= dbh;\n  catalog= catalog;\n  schema= schema;\n  table= table;\n  field= field;\n  attr= attr;\n\n  ASYNC_CHECK_RETURN(dbh, &PL_sv_undef);\n  return sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n}\n#endif\n\n#if MYSQL_ASYNC\nint mysql_db_async_result(SV* h, MYSQL_RES** resp)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  MYSQL* svsock = NULL;\n  MYSQL_RES* _res;\n  int retval = 0;\n  int htype;\n\n  if(! resp) {\n      resp = &_res;\n  }\n  htype = DBIc_TYPE(imp_xxh);\n\n\n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(! dbh->async_query_in_flight) {\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\n      return -1;\n  }\n  if(dbh->async_query_in_flight != imp_xxh) {\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\n      return -1;\n  }\n  dbh->async_query_in_flight = NULL;\n\n  svsock= dbh->pmysql;\n  retval= mysql_read_query_result(svsock);\n  if(! retval) {\n    *resp= mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\n    if (!*resp)\n      retval= mysql_affected_rows(svsock);\n    else {\n      retval= mysql_num_rows(*resp);\n      if(resp == &_res) {\n        mysql_free_result(*resp);\n      }\n    }\n    if(htype == DBIt_ST) {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\n        if(! *resp) {\n          imp_sth->insertid= mysql_insert_id(svsock);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n          if(! mysql_more_results(svsock))\n            DBIc_ACTIVE_off(imp_sth);\n#endif\n        } else {\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n          imp_sth->done_desc= 0;\n          imp_sth->fetch_done= 0;\n        }\n      }\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n    }\n  } else {\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\n              mysql_sqlstate(svsock));\n     return -1;\n  }\n return retval;\n}\n\nint mysql_db_async_ready(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  int htype;\n\n  htype = DBIc_TYPE(imp_xxh);\n  \n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(dbh->async_query_in_flight) {\n      if(dbh->async_query_in_flight == imp_xxh) {\n          struct pollfd fds;\n          int retval;\n\n          fds.fd = dbh->pmysql->net.fd;\n          fds.events = POLLIN;\n\n          retval = poll(&fds, 1, 0);\n\n          if(retval < 0) {\n              do_error(h, errno, strerror(errno), \"HY000\");\n          }\n          return retval;\n      } else {\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\n          return -1;\n      }\n  } else {\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\n      return -1;\n  }\n}\n#endif\n\nstatic int parse_number(char *string, STRLEN len, char **end)\n{\n    int seen_neg;\n    int seen_dec;\n    int seen_e;\n    int seen_plus;\n    int seen_digit;\n    char *cp;\n\n    seen_neg= seen_dec= seen_e= seen_plus= seen_digit= 0;\n\n    if (len <= 0) {\n        len= strlen(string);\n    }\n\n    cp= string;\n\n    /* Skip leading whitespace */\n    while (*cp && isspace(*cp))\n      cp++;\n\n    for ( ; *cp; cp++)\n    {\n      if ('-' == *cp)\n      {\n        if (seen_neg >= 2)\n        {\n          /*\n            third '-'. number can contains two '-'.\n            because -1e-10 is valid number */\n          break;\n        }\n        seen_neg += 1;\n      }\n      else if ('.' == *cp)\n      {\n        if (seen_dec)\n        {\n          /* second '.' */\n          break;\n        }\n        seen_dec= 1;\n      }\n      else if ('e' == *cp)\n      {\n        if (seen_e)\n        {\n          /* second 'e' */\n          break;\n        }\n        seen_e= 1;\n      }\n      else if ('+' == *cp)\n      {\n        if (seen_plus)\n        {\n          /* second '+' */\n          break;\n        }\n        seen_plus= 1;\n      }\n      else if (!isdigit(*cp))\n      {\n        /* Not sure why this was changed */\n        /* seen_digit= 1; */\n        break;\n      }\n    }\n\n    *end= cp;\n\n    /* length 0 -> not a number */\n    /* Need to revisit this */\n    /*if (len == 0 || cp - string < (int) len || seen_digit == 0) {*/\n    if (len == 0 || cp - string < (int) len) {\n        return -1;\n    }\n\n    return 0;\n}\n", "package Bundle::DBD::mysql;\n\nuse strict;\nuse warnings;\n\nour $VERSION = '4.038_01';\n\n1;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nBundle::DBD::mysql\n\n=head1 DESCRIPTION\n\nThis package only exists for legacy reasons. Please use the L<DBD::mysql>\npackage instead.\n\n=cut\n", "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nrequire 5.008_001; # just as DBI\n\npackage DBD::mysql;\n\nuse DBI;\nuse DynaLoader();\nuse Carp;\nour @ISA = qw(DynaLoader);\n\n# please make sure the sub-version does not increase above '099'\n# SQL_DRIVER_VER is formatted as dd.dd.dddd\n# for version 5.x please switch to 5.00(_00) version numbering\n# keep $VERSION in Bundle/DBD/mysql.pm in sync\nour $VERSION = '4.038_01';\n\nbootstrap DBD::mysql $VERSION;\n\n\nour $err = 0;\t    # holds error code for DBI::err\nour $errstr = \"\";\t# holds error string for DBI::errstr\nour $drh = undef;\t# holds driver handle once initialised\n\nmy $methods_are_installed = 0;\nsub driver{\n    return $drh if $drh;\n    my($class, $attr) = @_;\n\n    $class .= \"::dr\";\n\n    # not a 'my' since we use it above to prevent multiple drivers\n    $drh = DBI::_new_drh($class, { 'Name' => 'mysql',\n\t\t\t\t   'Version' => $VERSION,\n\t\t\t\t   'Err'    => \\$DBD::mysql::err,\n\t\t\t\t   'Errstr' => \\$DBD::mysql::errstr,\n\t\t\t\t   'Attribution' => 'DBD::mysql by Patrick Galbraith'\n\t\t\t\t });\n\n    if (!$methods_are_installed) {\n\tDBD::mysql::db->install_method('mysql_fd');\n\tDBD::mysql::db->install_method('mysql_async_result');\n\tDBD::mysql::db->install_method('mysql_async_ready');\n\tDBD::mysql::st->install_method('mysql_async_result');\n\tDBD::mysql::st->install_method('mysql_async_ready');\n\n\t$methods_are_installed++;\n    }\n\n    $drh;\n}\n\nsub CLONE {\n  undef $drh;\n}\n\nsub _OdbcParse($$$) {\n    my($class, $dsn, $hash, $args) = @_;\n    my($var, $val);\n    if (!defined($dsn)) {\n\treturn;\n    }\n    while (length($dsn)) {\n\tif ($dsn =~ /([^:;]*\\[.*]|[^:;]*)[:;](.*)/) {\n\t    $val = $1;\n\t    $dsn = $2;\n\t    $val =~ s/\\[|]//g; # Remove [] if present, the rest of the code prefers plain IPv6 addresses\n\t} else {\n\t    $val = $dsn;\n\t    $dsn = '';\n\t}\n\tif ($val =~ /([^=]*)=(.*)/) {\n\t    $var = $1;\n\t    $val = $2;\n\t    if ($var eq 'hostname'  ||  $var eq 'host') {\n\t\t$hash->{'host'} = $val;\n\t    } elsif ($var eq 'db'  ||  $var eq 'dbname') {\n\t\t$hash->{'database'} = $val;\n\t    } else {\n\t\t$hash->{$var} = $val;\n\t    }\n\t} else {\n\t    foreach $var (@$args) {\n\t\tif (!defined($hash->{$var})) {\n\t\t    $hash->{$var} = $val;\n\t\t    last;\n\t\t}\n\t    }\n\t}\n    }\n}\n\nsub _OdbcParseHost ($$) {\n    my($class, $dsn) = @_;\n    my($hash) = {};\n    $class->_OdbcParse($dsn, $hash, ['host', 'port']);\n    ($hash->{'host'}, $hash->{'port'});\n}\n\nsub AUTOLOAD {\n    my ($meth) = $DBD::mysql::AUTOLOAD;\n    my ($smeth) = $meth;\n    $smeth =~ s/(.*)\\:\\://;\n\n    my $val = constant($smeth, @_ ? $_[0] : 0);\n    if ($! == 0) { eval \"sub $meth { $val }\"; return $val; }\n\n    Carp::croak \"$meth: Not defined\";\n}\n\n1;\n\n\npackage DBD::mysql::dr; # ====== DRIVER ======\nuse strict;\nuse DBI qw(:sql_types);\nuse DBI::Const::GetInfoType;\n\nsub connect {\n    my($drh, $dsn, $username, $password, $attrhash) = @_;\n    my($port);\n    my($cWarn);\n    my $connect_ref= { 'Name' => $dsn };\n    my $dbi_imp_data;\n\n    # Avoid warnings for undefined values\n    $username ||= '';\n    $password ||= '';\n    $attrhash ||= {};\n    $attrhash->{mysql_conn_attrs} ||= {};\n    $attrhash->{mysql_conn_attrs}->{'program_name'} ||= $0;\n\n    # create a 'blank' dbh\n    my($this, $privateAttrHash) = (undef, $attrhash);\n    $privateAttrHash = { %$privateAttrHash,\n\t'Name' => $dsn,\n\t'user' => $username,\n\t'password' => $password\n    };\n\n    DBD::mysql->_OdbcParse($dsn, $privateAttrHash,\n\t\t\t\t    ['database', 'host', 'port']);\n\n\n    if ($DBI::VERSION >= 1.49)\n    {\n      $dbi_imp_data = delete $attrhash->{dbi_imp_data};\n      $connect_ref->{'dbi_imp_data'} = $dbi_imp_data;\n    }\n\n    if (!defined($this = DBI::_new_dbh($drh,\n            $connect_ref,\n            $privateAttrHash)))\n    {\n      return undef;\n    }\n\n    DBD::mysql::db::_login($this, $dsn, $username, $password)\n\t  or $this = undef;\n\n    if ($this && ($ENV{MOD_PERL} || $ENV{GATEWAY_INTERFACE})) {\n        $this->{mysql_auto_reconnect} = 1;\n    }\n    $this;\n}\n\nsub data_sources {\n    my($self) = shift;\n    my($attributes) = shift;\n    my($host, $port, $user, $password) = ('', '', '', '');\n    if ($attributes) {\n      $host = $attributes->{host} || '';\n      $port = $attributes->{port} || '';\n      $user = $attributes->{user} || '';\n      $password = $attributes->{password} || '';\n    }\n    my(@dsn) = $self->func($host, $port, $user, $password, '_ListDBs');\n    my($i);\n    for ($i = 0;  $i < @dsn;  $i++) {\n\t$dsn[$i] = \"DBI:mysql:$dsn[$i]\";\n    }\n    @dsn;\n}\n\nsub admin {\n    my($drh) = shift;\n    my($command) = shift;\n    my($dbname) = ($command eq 'createdb'  ||  $command eq 'dropdb') ?\n\tshift : '';\n    my($host, $port) = DBD::mysql->_OdbcParseHost(shift(@_) || '');\n    my($user) = shift || '';\n    my($password) = shift || '';\n\n    $drh->func(undef, $command,\n\t       $dbname || '',\n\t       $host || '',\n\t       $port || '',\n\t       $user, $password, '_admin_internal');\n}\n\npackage DBD::mysql::db; # ====== DATABASE ======\nuse strict;\nuse DBI qw(:sql_types);\n\n%DBD::mysql::db::db2ANSI = (\n    \"INT\"   =>  \"INTEGER\",\n    \"CHAR\"  =>  \"CHAR\",\n    \"REAL\"  =>  \"REAL\",\n    \"IDENT\" =>  \"DECIMAL\"\n);\n\n### ANSI datatype mapping to MySQL datatypes\n%DBD::mysql::db::ANSI2db = (\n    \"CHAR\"          => \"CHAR\",\n    \"VARCHAR\"       => \"CHAR\",\n    \"LONGVARCHAR\"   => \"CHAR\",\n    \"NUMERIC\"       => \"INTEGER\",\n    \"DECIMAL\"       => \"INTEGER\",\n    \"BIT\"           => \"INTEGER\",\n    \"TINYINT\"       => \"INTEGER\",\n    \"SMALLINT\"      => \"INTEGER\",\n    \"INTEGER\"       => \"INTEGER\",\n    \"BIGINT\"        => \"INTEGER\",\n    \"REAL\"          => \"REAL\",\n    \"FLOAT\"         => \"REAL\",\n    \"DOUBLE\"        => \"REAL\",\n    \"BINARY\"        => \"CHAR\",\n    \"VARBINARY\"     => \"CHAR\",\n    \"LONGVARBINARY\" => \"CHAR\",\n    \"DATE\"          => \"CHAR\",\n    \"TIME\"          => \"CHAR\",\n    \"TIMESTAMP\"     => \"CHAR\"\n);\n\nsub prepare {\n    my($dbh, $statement, $attribs)= @_;\n\n    return unless $dbh->func('_async_check');\n\n    # create a 'blank' dbh\n    my $sth = DBI::_new_sth($dbh, {'Statement' => $statement});\n\n    # Populate internal handle data.\n    if (!DBD::mysql::st::_prepare($sth, $statement, $attribs)) {\n\t$sth = undef;\n    }\n\n    $sth;\n}\n\nsub db2ANSI {\n    my $self = shift;\n    my $type = shift;\n    return $DBD::mysql::db::db2ANSI{\"$type\"};\n}\n\nsub ANSI2db {\n    my $self = shift;\n    my $type = shift;\n    return $DBD::mysql::db::ANSI2db{\"$type\"};\n}\n\nsub admin {\n    my($dbh) = shift;\n    my($command) = shift;\n    my($dbname) = ($command eq 'createdb'  ||  $command eq 'dropdb') ?\n\tshift : '';\n    $dbh->{'Driver'}->func($dbh, $command, $dbname, '', '', '',\n\t\t\t   '_admin_internal');\n}\n\nsub _SelectDB ($$) {\n    die \"_SelectDB is removed from this module; use DBI->connect instead.\";\n}\n\nsub table_info ($) {\n  my ($dbh, $catalog, $schema, $table, $type, $attr) = @_;\n  $dbh->{mysql_server_prepare}||= 0;\n  my $mysql_server_prepare_save= $dbh->{mysql_server_prepare};\n  $dbh->{mysql_server_prepare}= 0;\n  my @names = qw(TABLE_CAT TABLE_SCHEM TABLE_NAME TABLE_TYPE REMARKS);\n  my @rows;\n\n  my $sponge = DBI->connect(\"DBI:Sponge:\", '','')\n    or return $dbh->DBI::set_err($DBI::err, \"DBI::Sponge: $DBI::errstr\");\n\n# Return the list of catalogs\n  if (defined $catalog && $catalog eq \"%\" &&\n      (!defined($schema) || $schema eq \"\") &&\n      (!defined($table) || $table eq \"\"))\n  {\n    @rows = (); # Empty, because MySQL doesn't support catalogs (yet)\n  }\n  # Return the list of schemas\n  elsif (defined $schema && $schema eq \"%\" &&\n      (!defined($catalog) || $catalog eq \"\") &&\n      (!defined($table) || $table eq \"\"))\n  {\n    my $sth = $dbh->prepare(\"SHOW DATABASES\")\n      or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return undef);\n\n    $sth->execute()\n      or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return DBI::set_err($dbh, $sth->err(), $sth->errstr()));\n\n    while (my $ref = $sth->fetchrow_arrayref())\n    {\n      push(@rows, [ undef, $ref->[0], undef, undef, undef ]);\n    }\n  }\n  # Return the list of table types\n  elsif (defined $type && $type eq \"%\" &&\n      (!defined($catalog) || $catalog eq \"\") &&\n      (!defined($schema) || $schema eq \"\") &&\n      (!defined($table) || $table eq \"\"))\n  {\n    @rows = (\n        [ undef, undef, undef, \"TABLE\", undef ],\n        [ undef, undef, undef, \"VIEW\",  undef ],\n        );\n  }\n  # Special case: a catalog other than undef, \"\", or \"%\"\n  elsif (defined $catalog && $catalog ne \"\" && $catalog ne \"%\")\n  {\n    @rows = (); # Nothing, because MySQL doesn't support catalogs yet.\n  }\n  # Uh oh, we actually have a meaty table_info call. Work is required!\n  else\n  {\n    my @schemas;\n    # If no table was specified, we want them all\n    $table ||= \"%\";\n\n    # If something was given for the schema, we need to expand it to\n    # a list of schemas, since it may be a wildcard.\n    if (defined $schema && $schema ne \"\")\n    {\n      my $sth = $dbh->prepare(\"SHOW DATABASES LIKE \" .\n          $dbh->quote($schema))\n        or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return undef);\n      $sth->execute()\n        or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return DBI::set_err($dbh, $sth->err(), $sth->errstr()));\n\n      while (my $ref = $sth->fetchrow_arrayref())\n      {\n        push @schemas, $ref->[0];\n      }\n    }\n    # Otherwise we want the current database\n    else\n    {\n      push @schemas, $dbh->selectrow_array(\"SELECT DATABASE()\");\n    }\n\n    # Figure out which table types are desired\n    my ($want_tables, $want_views);\n    if (defined $type && $type ne \"\")\n    {\n      $want_tables = ($type =~ m/table/i);\n      $want_views  = ($type =~ m/view/i);\n    }\n    else\n    {\n      $want_tables = $want_views = 1;\n    }\n\n    for my $database (@schemas)\n    {\n      my $sth = $dbh->prepare(\"SHOW /*!50002 FULL*/ TABLES FROM \" .\n          $dbh->quote_identifier($database) .\n          \" LIKE \" .  $dbh->quote($table))\n          or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return undef);\n\n      $sth->execute() or\n          ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return DBI::set_err($dbh, $sth->err(), $sth->errstr()));\n\n      while (my $ref = $sth->fetchrow_arrayref())\n      {\n        my $type = (defined $ref->[1] &&\n            $ref->[1] =~ /view/i) ? 'VIEW' : 'TABLE';\n        next if $type eq 'TABLE' && not $want_tables;\n        next if $type eq 'VIEW'  && not $want_views;\n        push @rows, [ undef, $database, $ref->[0], $type, undef ];\n      }\n    }\n  }\n\n  my $sth = $sponge->prepare(\"table_info\",\n  {\n    rows          => \\@rows,\n    NUM_OF_FIELDS => scalar @names,\n    NAME          => \\@names,\n  })\n    or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n      return $dbh->DBI::set_err($sponge->err(), $sponge->errstr()));\n\n  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n  return $sth;\n}\n\nsub _ListTables {\n  my $dbh = shift;\n  if (!$DBD::mysql::QUIET) {\n    warn \"_ListTables is deprecated, use \\$dbh->tables()\";\n  }\n  return map { $_ =~ s/.*\\.//; $_ } $dbh->tables();\n}\n\n\nsub column_info {\n  my ($dbh, $catalog, $schema, $table, $column) = @_;\n\n  return unless $dbh->func('_async_check');\n\n  $dbh->{mysql_server_prepare}||= 0;\n  my $mysql_server_prepare_save= $dbh->{mysql_server_prepare};\n  $dbh->{mysql_server_prepare}= 0;\n\n  # ODBC allows a NULL to mean all columns, so we'll accept undef\n  $column = '%' unless defined $column;\n\n  my $ER_NO_SUCH_TABLE= 1146;\n\n  my $table_id = $dbh->quote_identifier($catalog, $schema, $table);\n\n  my @names = qw(\n      TABLE_CAT TABLE_SCHEM TABLE_NAME COLUMN_NAME\n      DATA_TYPE TYPE_NAME COLUMN_SIZE BUFFER_LENGTH DECIMAL_DIGITS\n      NUM_PREC_RADIX NULLABLE REMARKS COLUMN_DEF\n      SQL_DATA_TYPE SQL_DATETIME_SUB CHAR_OCTET_LENGTH\n      ORDINAL_POSITION IS_NULLABLE CHAR_SET_CAT\n      CHAR_SET_SCHEM CHAR_SET_NAME COLLATION_CAT COLLATION_SCHEM COLLATION_NAME\n      UDT_CAT UDT_SCHEM UDT_NAME DOMAIN_CAT DOMAIN_SCHEM DOMAIN_NAME\n      SCOPE_CAT SCOPE_SCHEM SCOPE_NAME MAX_CARDINALITY\n      DTD_IDENTIFIER IS_SELF_REF\n      mysql_is_pri_key mysql_type_name mysql_values\n      mysql_is_auto_increment\n      );\n  my %col_info;\n\n  local $dbh->{FetchHashKeyName} = 'NAME_lc';\n  # only ignore ER_NO_SUCH_TABLE in internal_execute if issued from here\n  my $desc_sth = $dbh->prepare(\"DESCRIBE $table_id \" . $dbh->quote($column));\n  my $desc = $dbh->selectall_arrayref($desc_sth, { Columns=>{} });\n\n  #return $desc_sth if $desc_sth->err();\n  if (my $err = $desc_sth->err())\n  {\n    # return the error, unless it is due to the table not\n    # existing per DBI spec\n    if ($err != $ER_NO_SUCH_TABLE)\n    {\n      $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n      return undef;\n    }\n    $dbh->set_err(undef,undef);\n    $desc = [];\n  }\n\n  my $ordinal_pos = 0;\n  my @fields;\n  for my $row (@$desc)\n  {\n    my $type = $row->{type};\n    $type =~ m/^(\\w+)(\\((.+)\\))?\\s?(.*)?$/;\n    my $basetype  = lc($1);\n    my $typemod   = $3;\n    my $attr      = $4;\n\n    push @fields, $row->{field};\n    my $info = $col_info{ $row->{field} }= {\n\t    TABLE_CAT               => $catalog,\n\t    TABLE_SCHEM             => $schema,\n\t    TABLE_NAME              => $table,\n\t    COLUMN_NAME             => $row->{field},\n\t    NULLABLE                => ($row->{null} eq 'YES') ? 1 : 0,\n\t    IS_NULLABLE             => ($row->{null} eq 'YES') ? \"YES\" : \"NO\",\n\t    TYPE_NAME               => uc($basetype),\n\t    COLUMN_DEF              => $row->{default},\n\t    ORDINAL_POSITION        => ++$ordinal_pos,\n\t    mysql_is_pri_key        => ($row->{key}  eq 'PRI'),\n\t    mysql_type_name         => $row->{type},\n      mysql_is_auto_increment => ($row->{extra} =~ /auto_increment/i ? 1 : 0),\n    };\n    #\n\t  # This code won't deal with a pathological case where a value\n\t  # contains a single quote followed by a comma, and doesn't unescape\n\t  # any escaped values. But who would use those in an enum or set?\n    #\n\t  my @type_params= ($typemod && index($typemod,\"'\")>=0) ?\n      (\"$typemod,\" =~ /'(.*?)',/g)  # assume all are quoted\n\t\t\t: split /,/, $typemod||'';      # no quotes, plain list\n\t  s/''/'/g for @type_params;                # undo doubling of quotes\n\n\t  my @type_attr= split / /, $attr||'';\n\n  \t$info->{DATA_TYPE}= SQL_VARCHAR();\n    if ($basetype =~ /^(char|varchar|\\w*text|\\w*blob)/)\n    {\n      $info->{DATA_TYPE}= SQL_CHAR() if $basetype eq 'char';\n      if ($type_params[0])\n      {\n        $info->{COLUMN_SIZE} = $type_params[0];\n      }\n      else\n      {\n        $info->{COLUMN_SIZE} = 65535;\n        $info->{COLUMN_SIZE} = 255        if $basetype =~ /^tiny/;\n        $info->{COLUMN_SIZE} = 16777215   if $basetype =~ /^medium/;\n        $info->{COLUMN_SIZE} = 4294967295 if $basetype =~ /^long/;\n      }\n    }\n\t  elsif ($basetype =~ /^(binary|varbinary)/)\n    {\n      $info->{COLUMN_SIZE} = $type_params[0];\n\t    # SQL_BINARY & SQL_VARBINARY are tempting here but don't match the\n\t    # semantics for mysql (not hex). SQL_CHAR &  SQL_VARCHAR are correct here.\n\t    $info->{DATA_TYPE} = ($basetype eq 'binary') ? SQL_CHAR() : SQL_VARCHAR();\n    }\n    elsif ($basetype =~ /^(enum|set)/)\n    {\n\t    if ($basetype eq 'set')\n      {\n\t\t    $info->{COLUMN_SIZE} = length(join \",\", @type_params);\n\t    }\n\t    else\n      {\n        my $max_len = 0;\n        length($_) > $max_len and $max_len = length($_) for @type_params;\n        $info->{COLUMN_SIZE} = $max_len;\n\t    }\n\t    $info->{\"mysql_values\"} = \\@type_params;\n    }\n    elsif ($basetype =~ /int/ || $basetype eq 'bit' )\n    {\n      # big/medium/small/tiny etc + unsigned?\n\t    $info->{DATA_TYPE} = SQL_INTEGER();\n\t    $info->{NUM_PREC_RADIX} = 10;\n\t    $info->{COLUMN_SIZE} = $type_params[0];\n    }\n    elsif ($basetype =~ /^decimal/)\n    {\n      $info->{DATA_TYPE} = SQL_DECIMAL();\n      $info->{NUM_PREC_RADIX} = 10;\n      $info->{COLUMN_SIZE}    = $type_params[0];\n      $info->{DECIMAL_DIGITS} = $type_params[1];\n    }\n    elsif ($basetype =~ /^(float|double)/)\n    {\n\t    $info->{DATA_TYPE} = ($basetype eq 'float') ? SQL_FLOAT() : SQL_DOUBLE();\n\t    $info->{NUM_PREC_RADIX} = 2;\n\t    $info->{COLUMN_SIZE} = ($basetype eq 'float') ? 32 : 64;\n    }\n    elsif ($basetype =~ /date|time/)\n    {\n      # date/datetime/time/timestamp\n\t    if ($basetype eq 'time' or $basetype eq 'date')\n      {\n\t\t    #$info->{DATA_TYPE}   = ($basetype eq 'time') ? SQL_TYPE_TIME() : SQL_TYPE_DATE();\n        $info->{DATA_TYPE}   = ($basetype eq 'time') ? SQL_TIME() : SQL_DATE();\n        $info->{COLUMN_SIZE} = ($basetype eq 'time') ? 8 : 10;\n      }\n\t    else\n      {\n        # datetime/timestamp\n        #$info->{DATA_TYPE}     = SQL_TYPE_TIMESTAMP();\n\t\t    $info->{DATA_TYPE}        = SQL_TIMESTAMP();\n\t\t    $info->{SQL_DATA_TYPE}    = SQL_DATETIME();\n        $info->{SQL_DATETIME_SUB} = $info->{DATA_TYPE} - ($info->{SQL_DATA_TYPE} * 10);\n        $info->{COLUMN_SIZE}      = ($basetype eq 'datetime') ? 19 : $type_params[0] || 14;\n\t    }\n\t    $info->{DECIMAL_DIGITS}= 0; # no fractional seconds\n    }\n    elsif ($basetype eq 'year')\n    {\n      # no close standard so treat as int\n\t    $info->{DATA_TYPE}      = SQL_INTEGER();\n\t    $info->{NUM_PREC_RADIX} = 10;\n\t    $info->{COLUMN_SIZE}    = 4;\n\t  }\n\t  else\n    {\n\t    Carp::carp(\"column_info: unrecognized column type '$basetype' of $table_id.$row->{field} treated as varchar\");\n    }\n    $info->{SQL_DATA_TYPE} ||= $info->{DATA_TYPE};\n    #warn Dumper($info);\n  }\n\n  my $sponge = DBI->connect(\"DBI:Sponge:\", '','')\n    or (  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return $dbh->DBI::set_err($DBI::err, \"DBI::Sponge: $DBI::errstr\"));\n\n  my $sth = $sponge->prepare(\"column_info $table\", {\n      rows          => [ map { [ @{$_}{@names} ] } map { $col_info{$_} } @fields ],\n      NUM_OF_FIELDS => scalar @names,\n      NAME          => \\@names,\n      }) or\n  return ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          $dbh->DBI::set_err($sponge->err(), $sponge->errstr()));\n\n  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n  return $sth;\n}\n\n\nsub primary_key_info {\n  my ($dbh, $catalog, $schema, $table) = @_;\n\n  return unless $dbh->func('_async_check');\n\n  $dbh->{mysql_server_prepare}||= 0;\n  my $mysql_server_prepare_save= $dbh->{mysql_server_prepare};\n\n  my $table_id = $dbh->quote_identifier($catalog, $schema, $table);\n\n  my @names = qw(\n      TABLE_CAT TABLE_SCHEM TABLE_NAME COLUMN_NAME KEY_SEQ PK_NAME\n      );\n  my %col_info;\n\n  local $dbh->{FetchHashKeyName} = 'NAME_lc';\n  my $desc_sth = $dbh->prepare(\"SHOW KEYS FROM $table_id\");\n  my $desc= $dbh->selectall_arrayref($desc_sth, { Columns=>{} });\n  my $ordinal_pos = 0;\n  for my $row (grep { $_->{key_name} eq 'PRIMARY'} @$desc)\n  {\n    $col_info{ $row->{column_name} }= {\n      TABLE_CAT   => $catalog,\n      TABLE_SCHEM => $schema,\n      TABLE_NAME  => $table,\n      COLUMN_NAME => $row->{column_name},\n      KEY_SEQ     => $row->{seq_in_index},\n      PK_NAME     => $row->{key_name},\n    };\n  }\n\n  my $sponge = DBI->connect(\"DBI:Sponge:\", '','')\n    or\n     ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n      return $dbh->DBI::set_err($DBI::err, \"DBI::Sponge: $DBI::errstr\"));\n\n  my $sth= $sponge->prepare(\"primary_key_info $table\", {\n      rows          => [\n        map { [ @{$_}{@names} ] }\n        sort { $a->{KEY_SEQ} <=> $b->{KEY_SEQ} }\n        values %col_info\n      ],\n      NUM_OF_FIELDS => scalar @names,\n      NAME          => \\@names,\n      }) or\n       ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return $dbh->DBI::set_err($sponge->err(), $sponge->errstr()));\n\n  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n\n  return $sth;\n}\n\n\nsub foreign_key_info {\n    my ($dbh,\n        $pk_catalog, $pk_schema, $pk_table,\n        $fk_catalog, $fk_schema, $fk_table,\n       ) = @_;\n\n    return unless $dbh->func('_async_check');\n\n    # INFORMATION_SCHEMA.KEY_COLUMN_USAGE was added in 5.0.6\n    # no one is going to be running 5.0.6, taking out the check for $point > .6\n    my ($maj, $min, $point) = _version($dbh);\n    return if $maj < 5 ;\n\n    my $sql = <<'EOF';\nSELECT NULL AS PKTABLE_CAT,\n       A.REFERENCED_TABLE_SCHEMA AS PKTABLE_SCHEM,\n       A.REFERENCED_TABLE_NAME AS PKTABLE_NAME,\n       A.REFERENCED_COLUMN_NAME AS PKCOLUMN_NAME,\n       A.TABLE_CATALOG AS FKTABLE_CAT,\n       A.TABLE_SCHEMA AS FKTABLE_SCHEM,\n       A.TABLE_NAME AS FKTABLE_NAME,\n       A.COLUMN_NAME AS FKCOLUMN_NAME,\n       A.ORDINAL_POSITION AS KEY_SEQ,\n       NULL AS UPDATE_RULE,\n       NULL AS DELETE_RULE,\n       A.CONSTRAINT_NAME AS FK_NAME,\n       NULL AS PK_NAME,\n       NULL AS DEFERABILITY,\n       NULL AS UNIQUE_OR_PRIMARY\n  FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE A,\n       INFORMATION_SCHEMA.TABLE_CONSTRAINTS B\n WHERE A.TABLE_SCHEMA = B.TABLE_SCHEMA AND A.TABLE_NAME = B.TABLE_NAME\n   AND A.CONSTRAINT_NAME = B.CONSTRAINT_NAME AND B.CONSTRAINT_TYPE IS NOT NULL\nEOF\n\n    my @where;\n    my @bind;\n\n    # catalogs are not yet supported by MySQL\n\n#    if (defined $pk_catalog) {\n#        push @where, 'A.REFERENCED_TABLE_CATALOG = ?';\n#        push @bind, $pk_catalog;\n#    }\n\n    if (defined $pk_schema) {\n        push @where, 'A.REFERENCED_TABLE_SCHEMA = ?';\n        push @bind, $pk_schema;\n    }\n\n    if (defined $pk_table) {\n        push @where, 'A.REFERENCED_TABLE_NAME = ?';\n        push @bind, $pk_table;\n    }\n\n#    if (defined $fk_catalog) {\n#        push @where, 'A.TABLE_CATALOG = ?';\n#        push @bind,  $fk_schema;\n#    }\n\n    if (defined $fk_schema) {\n        push @where, 'A.TABLE_SCHEMA = ?';\n        push @bind,  $fk_schema;\n    }\n\n    if (defined $fk_table) {\n        push @where, 'A.TABLE_NAME = ?';\n        push @bind,  $fk_table;\n    }\n\n    if (@where) {\n        $sql .= ' AND ';\n        $sql .= join ' AND ', @where;\n    }\n    $sql .= \" ORDER BY A.TABLE_SCHEMA, A.TABLE_NAME, A.ORDINAL_POSITION\";\n\n    local $dbh->{FetchHashKeyName} = 'NAME_uc';\n    my $sth = $dbh->prepare($sql);\n    $sth->execute(@bind);\n\n    return $sth;\n}\n# #86030: PATCH: adding statistics_info support\n# Thank you to David Dick http://search.cpan.org/~ddick/\nsub statistics_info {\n    my ($dbh,\n        $catalog, $schema, $table,\n        $unique_only, $quick,\n       ) = @_;\n\n    return unless $dbh->func('_async_check');\n\n    # INFORMATION_SCHEMA.KEY_COLUMN_USAGE was added in 5.0.6\n    # no one is going to be running 5.0.6, taking out the check for $point > .6\n    my ($maj, $min, $point) = _version($dbh);\n    return if $maj < 5 ;\n\n    my $sql = <<'EOF';\nSELECT TABLE_CATALOG AS TABLE_CAT,\n       TABLE_SCHEMA AS TABLE_SCHEM,\n       TABLE_NAME AS TABLE_NAME,\n       NON_UNIQUE AS NON_UNIQUE,\n       NULL AS INDEX_QUALIFIER,\n       INDEX_NAME AS INDEX_NAME,\n       LCASE(INDEX_TYPE) AS TYPE,\n       SEQ_IN_INDEX AS ORDINAL_POSITION,\n       COLUMN_NAME AS COLUMN_NAME,\n       COLLATION AS ASC_OR_DESC,\n       CARDINALITY AS CARDINALITY,\n       NULL AS PAGES,\n       NULL AS FILTER_CONDITION\n  FROM INFORMATION_SCHEMA.STATISTICS\nEOF\n\n    my @where;\n    my @bind;\n\n    # catalogs are not yet supported by MySQL\n\n#    if (defined $catalog) {\n#        push @where, 'TABLE_CATALOG = ?';\n#        push @bind, $catalog;\n#    }\n\n    if (defined $schema) {\n        push @where, 'TABLE_SCHEMA = ?';\n        push @bind, $schema;\n    }\n\n    if (defined $table) {\n        push @where, 'TABLE_NAME = ?';\n        push @bind, $table;\n    }\n\n    if (@where) {\n        $sql .= ' WHERE ';\n        $sql .= join ' AND ', @where;\n    }\n    $sql .= \" ORDER BY TABLE_SCHEMA, TABLE_NAME, ORDINAL_POSITION\";\n\n    local $dbh->{FetchHashKeyName} = 'NAME_uc';\n    my $sth = $dbh->prepare($sql);\n    $sth->execute(@bind);\n\n    return $sth;\n}\n\nsub _version {\n    my $dbh = shift;\n\n    return\n        $dbh->get_info($DBI::Const::GetInfoType::GetInfoType{SQL_DBMS_VER})\n            =~ /(\\d+)\\.(\\d+)\\.(\\d+)/;\n}\n\n\n####################\n# get_info()\n# Generated by DBI::DBD::Metadata\n\nsub get_info {\n    my($dbh, $info_type) = @_;\n\n    return unless $dbh->func('_async_check');\n    require DBD::mysql::GetInfo;\n    my $v = $DBD::mysql::GetInfo::info{int($info_type)};\n    $v = $v->($dbh) if ref $v eq 'CODE';\n    return $v;\n}\n\nBEGIN {\n    my @needs_async_check = qw/data_sources quote_identifier begin_work/;\n\n    foreach my $method (@needs_async_check) {\n        no strict 'refs';\n\n        my $super = \"SUPER::$method\";\n        *$method  = sub {\n            my $h = shift;\n            return unless $h->func('_async_check');\n            return $h->$super(@_);\n        };\n    }\n}\n\n\npackage DBD::mysql::st; # ====== STATEMENT ======\nuse strict;\n\nBEGIN {\n    my @needs_async_result = qw/fetchrow_hashref fetchall_hashref/;\n    my @needs_async_check = qw/bind_param_array bind_col bind_columns execute_for_fetch/;\n\n    foreach my $method (@needs_async_result) {\n        no strict 'refs';\n\n        my $super = \"SUPER::$method\";\n        *$method = sub {\n            my $sth = shift;\n            if(defined $sth->mysql_async_ready) {\n                return unless $sth->mysql_async_result;\n            }\n            return $sth->$super(@_);\n        };\n    }\n\n    foreach my $method (@needs_async_check) {\n        no strict 'refs';\n\n        my $super = \"SUPER::$method\";\n        *$method = sub {\n            my $h = shift;\n            return unless $h->func('_async_check');\n            return $h->$super(@_);\n        };\n    }\n}\n\n1;\n\n__END__\n\n=pod\n\n=encoding utf8\n\n=head1 NAME\n\nDBD::mysql - MySQL driver for the Perl5 Database Interface (DBI)\n\n=head1 SYNOPSIS\n\n    use DBI;\n\n    my $dsn = \"DBI:mysql:database=$database;host=$hostname;port=$port\";\n    my $dbh = DBI->connect($dsn, $user, $password);\n\n    my $sth = $dbh->prepare(\n        'SELECT id, first_name, last_name FROM authors WHERE last_name = ?')\n        or die \"prepare statement failed: $dbh->errstr()\";\n    $sth->execute('Eggers') or die \"execution failed: $dbh->errstr()\";\n    print $sth->rows . \" rows found.\\n\";\n    while (my $ref = $sth->fetchrow_hashref()) {\n        print \"Found a row: id = $ref->{'id'}, fn = $ref->{'first_name'}\\n\";\n    }\n    $sth->finish;\n\n\n=head1 EXAMPLE\n\n  #!/usr/bin/perl\n\n  use strict;\n  use warnings;\n  use DBI;\n\n  # Connect to the database.\n  my $dbh = DBI->connect(\"DBI:mysql:database=test;host=localhost\",\n                         \"joe\", \"joe's password\",\n                         {'RaiseError' => 1});\n\n  # Drop table 'foo'. This may fail, if 'foo' doesn't exist\n  # Thus we put an eval around it.\n  eval { $dbh->do(\"DROP TABLE foo\") };\n  print \"Dropping foo failed: $@\\n\" if $@;\n\n  # Create a new table 'foo'. This must not fail, thus we don't\n  # catch errors.\n  $dbh->do(\"CREATE TABLE foo (id INTEGER, name VARCHAR(20))\");\n\n  # INSERT some data into 'foo'. We are using $dbh->quote() for\n  # quoting the name.\n  $dbh->do(\"INSERT INTO foo VALUES (1, \" . $dbh->quote(\"Tim\") . \")\");\n\n  # same thing, but using placeholders (recommended!)\n  $dbh->do(\"INSERT INTO foo VALUES (?, ?)\", undef, 2, \"Jochen\");\n\n  # now retrieve data from the table.\n  my $sth = $dbh->prepare(\"SELECT * FROM foo\");\n  $sth->execute();\n  while (my $ref = $sth->fetchrow_hashref()) {\n    print \"Found a row: id = $ref->{'id'}, name = $ref->{'name'}\\n\";\n  }\n  $sth->finish();\n\n  # Disconnect from the database.\n  $dbh->disconnect();\n\n\n=head1 DESCRIPTION\n\nB<DBD::mysql> is the Perl5 Database Interface driver for the MySQL\ndatabase. In other words: DBD::mysql is an interface between the Perl\nprogramming language and the MySQL programming API that comes with\nthe MySQL relational database management system. Most functions\nprovided by this programming API are supported. Some rarely used\nfunctions are missing, mainly because no-one ever requested\nthem. :-)\n\nIn what follows we first discuss the use of DBD::mysql,\nbecause this is what you will need the most. For installation, see the\nseparate document L<DBD::mysql::INSTALL>.\nSee L</\"EXAMPLE\"> for a simple example above.\n\nFrom perl you activate the interface with the statement\n\n  use DBI;\n\nAfter that you can connect to multiple MySQL database servers\nand send multiple queries to any of them via a simple object oriented\ninterface. Two types of objects are available: database handles and\nstatement handles. Perl returns a database handle to the connect\nmethod like so:\n\n  $dbh = DBI->connect(\"DBI:mysql:database=$db;host=$host\",\n    $user, $password, {RaiseError => 1});\n\nOnce you have connected to a database, you can execute SQL\nstatements with:\n\n  my $query = sprintf(\"INSERT INTO foo VALUES (%d, %s)\",\n\t\t      $number, $dbh->quote(\"name\"));\n  $dbh->do($query);\n\nSee L<DBI> for details on the quote and do methods. An alternative\napproach is\n\n  $dbh->do(\"INSERT INTO foo VALUES (?, ?)\", undef,\n\t   $number, $name);\n\nin which case the quote method is executed automatically. See also\nthe bind_param method in L<DBI>. See L</\"DATABASE HANDLES\"> below\nfor more details on database handles.\n\nIf you want to retrieve results, you need to create a so-called\nstatement handle with:\n\n  $sth = $dbh->prepare(\"SELECT * FROM $table\");\n  $sth->execute();\n\nThis statement handle can be used for multiple things. First of all\nyou can retrieve a row of data:\n\n  my $row = $sth->fetchrow_hashref();\n\nIf your table has columns ID and NAME, then $row will be hash ref with\nkeys ID and NAME. See L</\"STATEMENT HANDLES\"> below for more details on\nstatement handles.\n\nBut now for a more formal approach:\n\n\n=head2 Class Methods\n\n=over\n\n=item B<connect>\n\n    use DBI;\n\n    $dsn = \"DBI:mysql:$database\";\n    $dsn = \"DBI:mysql:database=$database;host=$hostname\";\n    $dsn = \"DBI:mysql:database=$database;host=$hostname;port=$port\";\n\n    $dbh = DBI->connect($dsn, $user, $password);\n\nThe C<database> is not a required attribute, but please note that MySQL\nhas no such thing as a default database. If you don't specify the database\nat connection time your active database will be null and you'd need to prefix\nyour tables with the database name; i.e. 'SELECT * FROM mydb.mytable'.\n\nThis is similar to the behavior of the mysql command line client. Also,\n'SELECT DATABASE()' will return the current database active for the handle.\n\n=over\n\n=item host\n\n=item port\n\nThe hostname, if not specified or specified as '' or 'localhost', will\ndefault to a MySQL server running on the local machine using the default for\nthe UNIX socket. To connect to a MySQL server on the local machine via TCP,\nyou must specify the loopback IP address (127.0.0.1) as the host.\n\nShould the MySQL server be running on a non-standard port number,\nyou may explicitly state the port number to connect to in the C<hostname>\nargument, by concatenating the I<hostname> and I<port number> together\nseparated by a colon ( C<:> ) character or by using the  C<port> argument.\n\nTo connect to a MySQL server on localhost using TCP/IP, you must specify the\nhostname as 127.0.0.1 (with the optional port).\n\nWhen connecting to a MySQL Server with IPv6, a bracketed IPv6 address should be used.\nExample DSN:\n\n  my $dsn = \"DBI:mysql:;host=[1a12:2800:6f2:85::f20:8cf];port=3306\";\n\n\n=item mysql_client_found_rows\n\nEnables (TRUE value) or disables (FALSE value) the flag CLIENT_FOUND_ROWS\nwhile connecting to the MySQL server. This has a somewhat funny effect:\nWithout mysql_client_found_rows, if you perform a query like\n\n  UPDATE $table SET id = 1 WHERE id = 1;\n\nthen the MySQL engine will always return 0, because no rows have changed.\nWith mysql_client_found_rows however, it will return the number of rows\nthat have an id 1, as some people are expecting. (At least for compatibility\nto other engines.)\n\n=item mysql_compression\n\nIf your DSN contains the option \"mysql_compression=1\", then the communication\nbetween client and server will be compressed.\n\n=item mysql_connect_timeout\n\nIf your DSN contains the option \"mysql_connect_timeout=##\", the connect\nrequest to the server will timeout if it has not been successful after\nthe given number of seconds.\n\n=item mysql_write_timeout\n\nIf your DSN contains the option \"mysql_write_timeout=##\", the write\noperation to the server will timeout if it has not been successful after\nthe given number of seconds.\n\n=item mysql_read_timeout\n\nIf your DSN contains the option \"mysql_read_timeout=##\", the read\noperation to the server will timeout if it has not been successful after\nthe given number of seconds.\n\n=item mysql_init_command\n\nIf your DSN contains the option \"mysql_init_command=##\", then\nthis SQL statement is executed when connecting to the MySQL server.\nIt is automatically re-executed if reconnection occurs.\n\n=item mysql_skip_secure_auth\n\nThis option is for older mysql databases that don't have secure auth set.\n\n=item mysql_read_default_file\n\n=item mysql_read_default_group\n\nThese options can be used to read a config file like /etc/my.cnf or\n~/.my.cnf. By default MySQL's C client library doesn't use any config\nfiles unlike the client programs (mysql, mysqladmin, ...) that do, but\noutside of the C client library. Thus you need to explicitly request\nreading a config file, as in\n\n    $dsn = \"DBI:mysql:test;mysql_read_default_file=/home/joe/my.cnf\";\n    $dbh = DBI->connect($dsn, $user, $password)\n\nThe option mysql_read_default_group can be used to specify the default\ngroup in the config file: Usually this is the I<client> group, but\nsee the following example:\n\n    [client]\n    host=localhost\n\n    [perl]\n    host=perlhost\n\n(Note the order of the entries! The example won't work, if you reverse\nthe [client] and [perl] sections!)\n\nIf you read this config file, then you'll be typically connected to\nI<localhost>. However, by using\n\n    $dsn = \"DBI:mysql:test;mysql_read_default_group=perl;\"\n        . \"mysql_read_default_file=/home/joe/my.cnf\";\n    $dbh = DBI->connect($dsn, $user, $password);\n\nyou'll be connected to I<perlhost>. Note that if you specify a\ndefault group and do not specify a file, then the default config\nfiles will all be read.  See the documentation of\nthe C function mysql_options() for details.\n\n=item mysql_socket\n\nIt is possible to choose the Unix socket that is\nused for connecting to the server. This is done, for example, with\n\n    mysql_socket=/dev/mysql\n\nUsually there's no need for this option, unless you are using another\nlocation for the socket than that built into the client.\n\n=item mysql_ssl\n\nA true value turns on the CLIENT_SSL flag when connecting to the MySQL\ndatabase:\n\n  mysql_ssl=1\n\nThis means that your communication with the server will be encrypted.\n\nPlease note that this can only work if you enabled SSL when compiling\nDBD::mysql; this is the default starting version 4.034.\nSee L<DBD::mysql::INSTALL> for more details.\n\nIf you turn mysql_ssl on, you might also wish to use the following\nflags:\n\n=item mysql_ssl_client_key\n\n=item mysql_ssl_client_cert\n\n=item mysql_ssl_ca_file\n\n=item mysql_ssl_ca_path\n\n=item mysql_ssl_cipher\n\nThese are used to specify the respective parameters of a call\nto mysql_ssl_set, if mysql_ssl is turned on.\n\n\n=item mysql_local_infile\n\nThe LOCAL capability for LOAD DATA may be disabled\nin the MySQL client library by default. If your DSN contains the option\n\"mysql_local_infile=1\", LOAD DATA LOCAL will be enabled.  (However,\nthis option is *ineffective* if the server has also been configured to\ndisallow LOCAL.)\n\n=item mysql_multi_statements\n\nSupport for multiple statements separated by a semicolon\n(;) may be enabled by using this option. Enabling this option may cause\nproblems if server-side prepared statements are also enabled.\n\n=item Prepared statement support (server side prepare)\n\nTo use server side prepared statements, all you need to do is set the variable\nmysql_server_prepare in the connect:\n\n  $dbh = DBI->connect(\n    \"DBI:mysql:database=test;host=localhost;mysql_server_prepare=1\",\n    \"\",\n    \"\",\n    { RaiseError => 1, AutoCommit => 1 }\n  );\n\nThere are many benefits to using server side prepare statements, mostly if you are\nperforming many inserts because of that fact that a single statement is prepared\nto accept multiple insert values.\n\nTo make sure that the 'make test' step tests whether server prepare works, you just\nneed to export the env variable MYSQL_SERVER_PREPARE:\n\n  export MYSQL_SERVER_PREPARE=1\n\n\n=item mysql_embedded_options\n\nThe option <mysql_embedded_options> can be used to pass 'command-line'\noptions to embedded server.\n\nExample:\n\n  use DBI;\n  $testdsn=\"DBI:mysqlEmb:database=test;mysql_embedded_options=--help,--verbose\";\n  $dbh = DBI->connect($testdsn,\"a\",\"b\");\n\nThis would cause the command line help to the embedded MySQL server library\nto be printed.\n\n\n=item mysql_embedded_groups\n\nThe option <mysql_embedded_groups> can be used to specify the groups in the\nconfig file(I<my.cnf>) which will be used to get options for embedded server.\nIf not specified [server] and [embedded] groups will be used.\n\nExample:\n\n  $testdsn=\"DBI:mysqlEmb:database=test;mysql_embedded_groups=embedded_server,common\";\n\n=item mysql_conn_attrs\n\nThe option <mysql_conn_attrs> is a hash of attribute names and values which can be\nused to send custom connection attributes to the server. Some attributes like\n'_os', '_platform', '_client_name' and '_client_version' are added by libmysqlclient\nand 'program_name' is added by DBD::mysql.\n\nYou can then later read these attributes from the performance schema tables which\ncan be quite helpful for profiling your database or creating statistics.\nYou'll have to use a MySQL 5.6 server and libmysqlclient or newer to leverage this\nfeature.\n\n  my $dbh= DBI->connect($dsn, $user, $password,\n    { AutoCommit => 0,\n      mysql_conn_attrs => {\n        foo => 'bar',\n        wiz => 'bang'\n      },\n    });\n\nNow you can select the results from the performance schema tables. You can do this\nin the same session, but also afterwards. It can be very useful to answer questions\nlike 'which script sent this query?'.\n\n  my $results = $dbh->selectall_hashref(\n    'SELECT * FROM performance_schema.session_connect_attrs',\n    'ATTR_NAME'\n  );\n\nThis returns:\n\n  $result = {\n    'foo' => {\n        'ATTR_VALUE'       => 'bar',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => 'foo',\n        'ORDINAL_POSITION' => '6'\n    },\n    'wiz' => {\n        'ATTR_VALUE'       => 'bang',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => 'wiz',\n        'ORDINAL_POSITION' => '3'\n    },\n    'program_name' => {\n        'ATTR_VALUE'       => './foo.pl',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => 'program_name',\n        'ORDINAL_POSITION' => '5'\n    },\n    '_client_name' => {\n        'ATTR_VALUE'       => 'libmysql',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_client_name',\n        'ORDINAL_POSITION' => '1'\n    },\n    '_client_version' => {\n        'ATTR_VALUE'       => '5.6.24',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_client_version',\n        'ORDINAL_POSITION' => '7'\n    },\n    '_os' => {\n        'ATTR_VALUE'       => 'osx10.8',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_os',\n        'ORDINAL_POSITION' => '0'\n    },\n    '_pid' => {\n        'ATTR_VALUE'       => '59860',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_pid',\n        'ORDINAL_POSITION' => '2'\n    },\n    '_platform' => {\n        'ATTR_VALUE'       => 'x86_64',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_platform',\n        'ORDINAL_POSITION' => '4'\n    }\n  };\n\n=back\n\n=back\n\n\n=head2 Private MetaData Methods\n\n=over\n\n=item B<ListDBs>\n\n    my $drh = DBI->install_driver(\"mysql\");\n    @dbs = $drh->func(\"$hostname:$port\", '_ListDBs');\n    @dbs = $drh->func($hostname, $port, '_ListDBs');\n    @dbs = $dbh->func('_ListDBs');\n\nReturns a list of all databases managed by the MySQL server\nrunning on C<$hostname>, port C<$port>. This is a legacy\nmethod.  Instead, you should use the portable method\n\n    @dbs = DBI->data_sources(\"mysql\");\n\n=back\n\n\n=head1 DATABASE HANDLES\n\nThe DBD::mysql driver supports the following attributes of database\nhandles (read only):\n\n  $errno = $dbh->{'mysql_errno'};\n  $error = $dbh->{'mysql_error'};\n  $info = $dbh->{'mysql_hostinfo'};\n  $info = $dbh->{'mysql_info'};\n  $insertid = $dbh->{'mysql_insertid'};\n  $info = $dbh->{'mysql_protoinfo'};\n  $info = $dbh->{'mysql_serverinfo'};\n  $info = $dbh->{'mysql_stat'};\n  $threadId = $dbh->{'mysql_thread_id'};\n\nThese correspond to mysql_errno(), mysql_error(), mysql_get_host_info(),\nmysql_info(), mysql_insert_id(), mysql_get_proto_info(),\nmysql_get_server_info(), mysql_stat() and mysql_thread_id(),\nrespectively.\n\n=over 2\n\n=item mysql_clientinfo\n\nList information of the MySQL client library that DBD::mysql was built\nagainst:\n\n  print \"$dbh->{mysql_clientinfo}\\n\";\n\n  5.2.0-MariaDB\n\n=item mysql_clientversion\n\n  print \"$dbh->{mysql_clientversion}\\n\";\n\n  50200\n\n=item mysql_serverversion\n\n  print \"$dbh->{mysql_serverversion}\\n\";\n\n  50200\n\n=item mysql_dbd_stats\n\n  $info_hashref = $dhb->{mysql_dbd_stats};\n\nDBD::mysql keeps track of some statistics in the mysql_dbd_stats attribute.\nThe following stats are being maintained:\n\n=over 8\n\n=item auto_reconnects_ok\n\nThe number of times that DBD::mysql successfully reconnected to the mysql\nserver.\n\n=item auto_reconnects_failed\n\nThe number of times that DBD::mysql tried to reconnect to mysql but failed.\n\n=back\n\n=back\n\nThe DBD::mysql driver also supports the following attributes of database\nhandles (read/write):\n\n=over\n\n=item mysql_auto_reconnect\n\nThis attribute determines whether DBD::mysql will automatically reconnect\nto mysql if the connection be lost. This feature defaults to off; however,\nif either the GATEWAY_INTERFACE or MOD_PERL environment variable is set,\nDBD::mysql will turn mysql_auto_reconnect on.  Setting mysql_auto_reconnect\nto on is not advised if 'lock tables' is used because if DBD::mysql reconnect\nto mysql all table locks will be lost.  This attribute is ignored when\nAutoCommit is turned off, and when AutoCommit is turned off, DBD::mysql will\nnot automatically reconnect to the server.\n\nIt is also possible to set the default value of the C<mysql_auto_reconnect>\nattribute for the $dbh by passing it in the C<\\%attr> hash for C<DBI->connect>.\n\n  $dbh->{mysql_auto_reconnect} = 1;\n\nor\n\n  my $dbh = DBI->connect($dsn, $user, $password, {\n     mysql_auto_reconnect => 1,\n  });\n\nNote that if you are using a module or framework that performs reconnections\nfor you (for example L<DBIx::Connector> in fixup mode), this value must be set\nto 0.\n\n=item mysql_use_result\n\nThis attribute forces the driver to use mysql_use_result rather than\nmysql_store_result.  The former is faster and less memory consuming, but\ntends to block other processes.  mysql_store_result is the default due to that\nfact storing the result is expected behavior with most applications.\n\nIt is possible to set the default value of the C<mysql_use_result> attribute\nfor the $dbh via the DSN:\n\n  $dbh = DBI->connect(\"DBI:mysql:test;mysql_use_result=1\", \"root\", \"\");\n\nYou can also set it after creation of the database handle:\n\n   $dbh->{mysql_use_result} = 0; # disable\n   $dbh->{mysql_use_result} = 1; # enable\n\nYou can also set or unset the C<mysql_use_result> setting on your statement\nhandle, when creating the statement handle or after it has been created.\nSee L</\"STATEMENT HANDLES\">.\n\n=item mysql_enable_utf8\n\nThis attribute determines whether DBD::mysql should assume strings\nstored in the database are utf8.  This feature defaults to off.\n\nWhen set, a data retrieved from a textual column type (char, varchar,\netc) will have the UTF-8 flag turned on if necessary.  This enables\ncharacter semantics on that string.  You will also need to ensure that\nyour database / table / column is configured to use UTF8. See for more\ninformation the chapter on character set support in the MySQL manual:\nL<http://dev.mysql.com/doc/refman/5.7/en/charset.html>\n\nAdditionally, turning on this flag tells MySQL that incoming data should\nbe treated as UTF-8.  This will only take effect if used as part of the\ncall to connect().  If you turn the flag on after connecting, you will\nneed to issue the command C<SET NAMES utf8> to get the same effect.\n\n=item mysql_enable_utf8mb4\n\nThis is similar to mysql_enable_utf8, but is capable of handling 4-byte\nUTF-8 characters.\n\n=item mysql_bind_type_guessing\n\nThis attribute causes the driver (emulated prepare statements)\nto attempt to guess if a value being bound is a numeric value,\nand if so, doesn't quote the value.  This was created by\nDragonchild and is one way to deal with the performance issue\nof using quotes in a statement that is inserting or updating a\nlarge numeric value. This was previously called\nC<unsafe_bind_type_guessing> because it is experimental. I have\nsuccessfully run the full test suite with this option turned on,\nthe name can now be simply C<mysql_bind_type_guessing>.\n\nCAVEAT: Even though you can insert an integer value into a\ncharacter column, if this column is indexed, if you query that\ncolumn with the integer value not being quoted, it will not\nuse the index:\n\n    MariaDB [test]> explain select * from test where value0 = '3' \\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: test\n             type: ref\n    possible_keys: value0\n              key: value0\n          key_len: 13\n              ref: const\n             rows: 1\n            Extra: Using index condition\n    1 row in set (0.00 sec)\n\n    MariaDB [test]> explain select * from test where value0 = 3\n        -> \\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: test\n             type: ALL\n    possible_keys: value0\n              key: NULL\n          key_len: NULL\n              ref: NULL\n             rows: 6\n            Extra: Using where\n    1 row in set (0.00 sec)\n\nSee bug: https://rt.cpan.org/Ticket/Display.html?id=43822\n\nC<mysql_bind_type_guessing> can be turned on via\n\n - through DSN\n\n  my $dbh= DBI->connect('DBI:mysql:test', 'username', 'pass',\n  { mysql_bind_type_guessing => 1})\n\n  - OR after handle creation\n\n  $dbh->{mysql_bind_type_guessing} = 1;\n\n=item mysql_bind_comment_placeholders\n\nThis attribute causes the driver (emulated prepare statements)\nwill cause any placeholders in comments to be bound. This is\nnot correct prepared statement behavior, but some developers\nhave come to depend on this behavior, so I have made it available\nin 4.015\n\n=item mysql_no_autocommit_cmd\n\nThis attribute causes the driver to not issue 'set autocommit'\neither through explicit or using mysql_autocommit(). This is\nparticularly useful in the case of using MySQL Proxy.\n\nSee the bug report:\n\nhttps://rt.cpan.org/Public/Bug/Display.html?id=46308\n\n\nC<mysql_no_autocommit_cmd> can be turned on when creating the database\nhandle:\n\n  my $dbh = DBI->connect('DBI:mysql:test', 'username', 'pass',\n  { mysql_no_autocommit_cmd => 1});\n\nor using an existing database handle:\n\n  $dbh->{mysql_no_autocommit_cmd} = 1;\n\n=item ping\n\nThis can be used to send a ping to the server.\n\n  $rc = $dbh->ping();\n\n=back\n\n\n=head1 STATEMENT HANDLES\n\nThe statement handles of DBD::mysql support a number\nof attributes. You access these by using, for example,\n\n  my $numFields = $sth->{NUM_OF_FIELDS};\n\nNote, that most attributes are valid only after a successful I<execute>.\nAn C<undef> value will returned otherwise. The most important exception\nis the C<mysql_use_result> attribute, which forces the driver to use\nmysql_use_result rather than mysql_store_result. The former is faster\nand less memory consuming, but tends to block other processes. (That's why\nmysql_store_result is the default.)\n\nTo set the C<mysql_use_result> attribute, use either of the following:\n\n  my $sth = $dbh->prepare(\"QUERY\", { mysql_use_result => 1});\n\nor\n\n  my $sth = $dbh->prepare($sql);\n  $sth->{mysql_use_result} = 1;\n\nColumn dependent attributes, for example I<NAME>, the column names,\nare returned as a reference to an array. The array indices are\ncorresponding to the indices of the arrays returned by I<fetchrow>\nand similar methods. For example the following code will print a\nheader of table names together with all rows:\n\n  my $sth = $dbh->prepare(\"SELECT * FROM $table\") ||\n    die \"Error:\" . $dbh->errstr . \"\\n\";\n\n  $sth->execute ||  die \"Error:\" . $sth->errstr . \"\\n\";\n\n  my $names = $sth->{NAME};\n  my $numFields = $sth->{'NUM_OF_FIELDS'} - 1;\n  for my $i ( 0..$numFields ) {\n      printf(\"%s%s\", $i ? \",\" : \"\", $$names[$i]);\n  }\n  print \"\\n\";\n  while (my $ref = $sth->fetchrow_arrayref) {\n      for my $i ( 0..$numFields ) {\n      printf(\"%s%s\", $i ? \",\" : \"\", $$ref[$i]);\n      }\n      print \"\\n\";\n  }\n\nFor portable applications you should restrict yourself to attributes with\ncapitalized or mixed case names. Lower case attribute names are private\nto DBD::mysql. The attribute list includes:\n\n=over\n\n=item ChopBlanks\n\nthis attribute determines whether a I<fetchrow> will chop preceding\nand trailing blanks off the column values. Chopping blanks does not\nhave impact on the I<max_length> attribute.\n\n=item mysql_insertid\n\nIf the statement you executed performs an INSERT, and there is an AUTO_INCREMENT\ncolumn in the table you inserted in, this attribute holds the value stored into\nthe AUTO_INCREMENT column, if that value is automatically generated, by\nstoring NULL or 0 or was specified as an explicit value.\n\nTypically, you'd access the value via $sth->{mysql_insertid}. The value can\nalso be accessed via $dbh->{mysql_insertid} but this can easily\nproduce incorrect results in case one database handle is shared.\n\n=item mysql_is_blob\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column is a blob. This attribute is valid for MySQL only.\n\n=item mysql_is_key\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column is a key. This is valid for MySQL only.\n\n=item mysql_is_num\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column contains numeric values.\n\n=item mysql_is_pri_key\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column is a primary key.\n\n=item mysql_is_auto_increment\n\nReference to an array of boolean values; TRUE indicates that the\nrespective column is an AUTO_INCREMENT column.  This is only valid\nfor MySQL.\n\n=item mysql_length\n\n=item mysql_max_length\n\nA reference to an array of maximum column sizes. The I<max_length> is\nthe maximum physically present in the result table, I<length> gives\nthe theoretically possible maximum. I<max_length> is valid for MySQL\nonly.\n\n=item NAME\n\nA reference to an array of column names.\n\n=item NULLABLE\n\nA reference to an array of boolean values; TRUE indicates that this column\nmay contain NULL's.\n\n=item NUM_OF_FIELDS\n\nNumber of fields returned by a I<SELECT> or I<LISTFIELDS> statement.\nYou may use this for checking whether a statement returned a result:\nA zero value indicates a non-SELECT statement like I<INSERT>,\nI<DELETE> or I<UPDATE>.\n\n=item mysql_table\n\nA reference to an array of table names, useful in a I<JOIN> result.\n\n=item TYPE\n\nA reference to an array of column types. The engine's native column\ntypes are mapped to portable types like DBI::SQL_INTEGER() or\nDBI::SQL_VARCHAR(), as good as possible. Not all native types have\na meaningful equivalent, for example DBD::mysql::FIELD_TYPE_INTERVAL\nis mapped to DBI::SQL_VARCHAR().\nIf you need the native column types, use I<mysql_type>. See below.\n\n=item mysql_type\n\nA reference to an array of MySQL's native column types, for example\nDBD::mysql::FIELD_TYPE_SHORT() or DBD::mysql::FIELD_TYPE_STRING().\nUse the I<TYPE> attribute, if you want portable types like\nDBI::SQL_SMALLINT() or DBI::SQL_VARCHAR().\n\n=item mysql_type_name\n\nSimilar to mysql, but type names and not numbers are returned.\nWhenever possible, the ANSI SQL name is preferred.\n\n=item mysql_warning_count\n\nThe number of warnings generated during execution of the SQL statement.\nThis attribute is available on both statement handles and database handles.\n\n=back\n\n=head1 TRANSACTION SUPPORT\n\nThe transaction support works as follows:\n\n=over\n\n=item *\n\nBy default AutoCommit mode is on, following the DBI specifications.\n\n=item *\n\nIf you execute\n\n  $dbh->{AutoCommit} = 0;\n\nor\n\n  $dbh->{AutoCommit} = 1;\n\nthen the driver will set the MySQL server variable autocommit to 0 or\n1, respectively. Switching from 0 to 1 will also issue a COMMIT,\nfollowing the DBI specifications.\n\n=item *\n\nThe methods\n\n    $dbh->rollback();\n    $dbh->commit();\n\nwill issue the commands ROLLBACK and COMMIT, respectively. A\nROLLBACK will also be issued if AutoCommit mode is off and the\ndatabase handles DESTROY method is called. Again, this is following\nthe DBI specifications.\n\n=back\n\nGiven the above, you should note the following:\n\n=over\n\n=item *\n\nYou should never change the server variable autocommit manually,\nunless you are ignoring DBI's transaction support.\n\n=item *\n\nSwitching AutoCommit mode from on to off or vice versa may fail.\nYou should always check for errors when changing AutoCommit mode.\nThe suggested way of doing so is using the DBI flag RaiseError.\nIf you don't like RaiseError, you have to use code like the\nfollowing:\n\n  $dbh->{AutoCommit} = 0;\n  if ($dbh->{AutoCommit}) {\n    # An error occurred!\n  }\n\n=item *\n\nIf you detect an error while changing the AutoCommit mode, you\nshould no longer use the database handle. In other words, you\nshould disconnect and reconnect again, because the transaction\nmode is unpredictable. Alternatively you may verify the transaction\nmode by checking the value of the server variable autocommit.\nHowever, such behaviour isn't portable.\n\n=item *\n\nDBD::mysql has a \"reconnect\" feature that handles the so-called\nMySQL \"morning bug\": If the server has disconnected, most probably\ndue to a timeout, then by default the driver will reconnect and\nattempt to execute the same SQL statement again. However, this\nbehaviour is disabled when AutoCommit is off: Otherwise the\ntransaction state would be completely unpredictable after a\nreconnect.\n\n=item *\n\nThe \"reconnect\" feature of DBD::mysql can be toggled by using the\nL<mysql_auto_reconnect> attribute. This behaviour should be turned off\nin code that uses LOCK TABLE because if the database server time out\nand DBD::mysql reconnect, table locks will be lost without any\nindication of such loss.\n\n=back\n\n=head1 MULTIPLE RESULT SETS\n\nDBD::mysql supports multiple result sets, thanks to Guy Harrison!\n\nThe basic usage of multiple result sets is\n\n  do\n  {\n    while (@row = $sth->fetchrow_array())\n    {\n      do stuff;\n    }\n  } while ($sth->more_results)\n\nAn example would be:\n\n  $dbh->do(\"drop procedure if exists someproc\") or print $DBI::errstr;\n\n  $dbh->do(\"create procedure someproc() deterministic\n   begin\n   declare a,b,c,d int;\n   set a=1;\n   set b=2;\n   set c=3;\n   set d=4;\n   select a, b, c, d;\n   select d, c, b, a;\n   select b, a, c, d;\n   select c, b, d, a;\n  end\") or print $DBI::errstr;\n\n  $sth=$dbh->prepare('call someproc()') ||\n  die $DBI::err.\": \".$DBI::errstr;\n\n  $sth->execute || die DBI::err.\": \".$DBI::errstr; $rowset=0;\n  do {\n    print \"\\nRowset \".++$i.\"\\n---------------------------------------\\n\\n\";\n    foreach $colno (0..$sth->{NUM_OF_FIELDS}-1) {\n      print $sth->{NAME}->[$colno].\"\\t\";\n    }\n    print \"\\n\";\n    while (@row= $sth->fetchrow_array())  {\n      foreach $field (0..$#row) {\n        print $row[$field].\"\\t\";\n      }\n      print \"\\n\";\n    }\n  } until (!$sth->more_results)\n\n=head2 Issues with multiple result sets\n\nPlease be aware there could be issues if your result sets are \"jagged\",\nmeaning the number of columns of your results vary. Varying numbers of\ncolumns could result in your script crashing.\n\n\n=head1 MULTITHREADING\n\nThe multithreading capabilities of DBD::mysql depend completely\non the underlying C libraries. The modules are working with handle data\nonly, no global variables are accessed or (to the best of my knowledge)\nthread unsafe functions are called. Thus DBD::mysql is believed\nto be completely thread safe, if the C libraries are thread safe\nand you don't share handles among threads.\n\nThe obvious question is: Are the C libraries thread safe?\nIn the case of MySQL the answer is \"mostly\" and, in theory, you should\nbe able to get a \"yes\", if the C library is compiled for being thread\nsafe (By default it isn't.) by passing the option -with-thread-safe-client\nto configure. See the section on I<How to make a threadsafe client> in\nthe manual.\n\n\n=head1 ASYNCHRONOUS QUERIES\n\nYou can make a single asynchronous query per MySQL connection; this allows\nyou to submit a long-running query to the server and have an event loop\ninform you when it's ready.  An asynchronous query is started by either\nsetting the 'async' attribute to a true value in the L<DBI/do> method,\nor in the L<DBI/prepare> method.  Statements created with 'async' set to\ntrue in prepare always run their queries asynchronously when L<DBI/execute>\nis called.  The driver also offers three additional methods:\nC<mysql_async_result>, C<mysql_async_ready>, and C<mysql_fd>.\nC<mysql_async_result> returns what do or execute would have; that is, the\nnumber of rows affected.  C<mysql_async_ready> returns true if\nC<mysql_async_result> will not block, and zero otherwise.  They both return\nC<undef> if that handle is not currently running an asynchronous query.\nC<mysql_fd> returns the file descriptor number for the MySQL connection; you\ncan use this in an event loop.\n\nHere's an example of how to use the asynchronous query interface:\n\n  use feature 'say';\n  $dbh->do('SELECT SLEEP(10)', { async => 1 });\n  until($dbh->mysql_async_ready) {\n    say 'not ready yet!';\n    sleep 1;\n  }\n  my $rows = $dbh->mysql_async_result;\n\n=head1 INSTALLATION\n\nSee L<DBD::mysql::INSTALL>.\n\n=head1 AUTHORS\n\nOriginally, there was a non-DBI driver, Mysql, which was much like\nPHP drivers such as mysql and mysqli. The B<Mysql> module was\noriginally written by Andreas K\u00f6nig <koenig@kulturbox.de> who still, to this\nday, contributes patches to DBD::mysql. An emulated version of Mysql was\nprovided to DBD::mysql from Jochen Wiedmann, but eventually deprecated as it\nwas another bundle of code to maintain.\n\nThe first incarnation of DBD::mysql was developed by Alligator Descartes,\nwho was also aided and abetted by Gary Shea, Andreas K\u00f6nig and\nTim Bunce.\n\nThe current incarnation of B<DBD::mysql> was written by Jochen Wiedmann,\nthen numerous changes and bug-fixes were added by Rudy Lippan. Next,\nprepared statement support was added by Patrick Galbraith and\nAlexy Stroganov (who also solely added embedded server\nsupport).\n\nFor the past nine years DBD::mysql has been maintained by\nPatrick Galbraith (I<patg@patg.net>), and recently with the great help of\nMichiel Beijen (I<michiel.beijen@gmail.com>),  along with the entire community\nof Perl developers who keep sending patches to help continue improving DBD::mysql\n\n\n=head1 CONTRIBUTIONS\n\nAnyone who desires to contribute to this project is encouraged to do so.\nCurrently, the source code for this project can be found at Github:\n\nL<https://github.com/perl5-dbi/DBD-mysql/>\n\nEither fork this repository and produce a branch with your changeset that\nthe maintainer can merge to his tree, or create a diff with git. The maintainer\nis more than glad to take contributions from the community as\nmany features and fixes from DBD::mysql have come from the community.\n\n\n=head1 COPYRIGHT\n\nThis module is\n\n=over\n\n=item *\n\nLarge Portions Copyright (c) 2004-2013 Patrick Galbraith\n\n=item *\n\nLarge Portions Copyright (c) 2004-2006 Alexey Stroganov\n\n=item *\n\nLarge Portions Copyright (c) 2003-2005 Rudolf Lippan\n\n=item *\n\nLarge Portions Copyright (c) 1997-2003 Jochen Wiedmann, with code portions\n\n=item *\n\nCopyright (c)1994-1997 their original authors\n\n=back\n\n\n=head1 LICENSE\n\nThis module is released under the same license as Perl itself. See\nL<http://www.perl.com/perl/misc/Artistic.html> for details.\n\n\n=head1 MAILING LIST SUPPORT\n\nThis module is maintained and supported on a mailing list, dbi-users.\n\nTo subscribe to this list, send an email to\n\ndbi-users-subscribe@perl.org\n\nMailing list archives are at\n\nL<http://groups.google.com/group/perl.dbi.users?hl=en&lr=>\n\n\n=head1 ADDITIONAL DBI INFORMATION\n\nAdditional information on the DBI project can be found on the World\nWide Web at the following URL:\n\nL<http://dbi.perl.org>\n\nwhere documentation, pointers to the mailing lists and mailing list\narchives and pointers to the most current versions of the modules can\nbe used.\n\nInformation on the DBI interface itself can be gained by typing:\n\n    perldoc DBI\n\nInformation on DBD::mysql specifically can be gained by typing:\n\n    perldoc DBD::mysql\n\n(this will display the document you're currently reading)\n\n\n=head1 BUG REPORTING, ENHANCEMENT/FEATURE REQUESTS\n\nPlease report bugs, including all the information needed\nsuch as DBD::mysql version, MySQL version, OS type/version, etc\nto this link:\n\nL<https://rt.cpan.org/Dist/Display.html?Name=DBD-mysql>\n\nNote: until recently, MySQL/Sun/Oracle responded to bugs and assisted in\nfixing bugs which many thanks should be given for their help!\nThis driver is outside the realm of the numerous components they support, and the\nmaintainer and community solely support DBD::mysql\n\n=cut\n", "/* Hej, Emacs, this is -*- C -*- mode!\n\n   Copyright (c) 2003      Rudolf Lippan\n   Copyright (c) 1997-2003 Jochen Wiedmann\n\n   You may distribute under the terms of either the GNU General Public\n   License or the Artistic License, as specified in the Perl README file.\n\n*/\n\n\n#include \"dbdimp.h\"\n#include \"constants.h\"\n\n#include <errno.h>\n#include <string.h>\n\n#if MYSQL_ASYNC\n#  define ASYNC_CHECK_XS(h)\\\n    if(imp_dbh->async_query_in_flight) {\\\n        do_error(h, 2000, \"Calling a synchronous function on an asynchronous handle\", \"HY000\");\\\n        XSRETURN_UNDEF;\\\n    }\n#else\n#  define ASYNC_CHECK_XS(h)\n#endif\n\n\nDBISTATE_DECLARE;\n\n\nMODULE = DBD::mysql\tPACKAGE = DBD::mysql\n\nINCLUDE: mysql.xsi\n\nMODULE = DBD::mysql\tPACKAGE = DBD::mysql\n\ndouble\nconstant(name, arg)\n    char* name\n    char* arg\n  CODE:\n    RETVAL = mysql_constant(name, arg);\n  OUTPUT:\n    RETVAL\n\n\nMODULE = DBD::mysql\tPACKAGE = DBD::mysql::dr\n\nvoid\n_ListDBs(drh, host=NULL, port=NULL, user=NULL, password=NULL)\n    SV *        drh\n    char *\thost\n    char *      port\n    char *      user\n    char *      password\n  PPCODE:\n{\n    MYSQL mysql;\n    MYSQL* sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user, password,\n\t\t\t\t   NULL, NULL);\n    if (sock != NULL)\n    {\n      MYSQL_ROW cur;\n      MYSQL_RES* res = mysql_list_dbs(sock, NULL);\n      if (!res)\n      {\n        do_error(drh, mysql_errno(sock), mysql_error(sock), mysql_sqlstate(sock));\n      }\n      else\n      {\n\tEXTEND(sp, mysql_num_rows(res));\n\twhile ((cur = mysql_fetch_row(res)))\n        {\n\t  PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));\n\t}\n\tmysql_free_result(res);\n      }\n      mysql_close(sock);\n    }\n}\n\n\nvoid\n_admin_internal(drh,dbh,command,dbname=NULL,host=NULL,port=NULL,user=NULL,password=NULL)\n  SV* drh\n  SV* dbh\n  char* command\n  char* dbname\n  char* host\n  char* port\n  char* user\n  char* password\n  PPCODE:\n{\n  MYSQL mysql;\n  int retval;\n  MYSQL* sock;\n#if MYSQL_VERSION_ID >= 50709\n  const char *shutdown = \"SHUTDOWN\";\n#endif\n\n  /*\n   *  Connect to the database, if required.\n */\n  if (SvOK(dbh)) {\n    D_imp_dbh(dbh);\n    sock = imp_dbh->pmysql;\n  }\n  else\n  {\n    sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user,  password, NULL, NULL);\n    if (sock == NULL)\n    {\n      do_error(drh, mysql_errno(&mysql), mysql_error(&mysql),\n               mysql_sqlstate(&mysql));\n      XSRETURN_NO;\n    }\n  }\n\n  if (strEQ(command, \"shutdown\"))\n#if MYSQL_VERSION_ID < 40103\n    retval = mysql_shutdown(sock);\n#else\n#if MYSQL_VERSION_ID < 50709\n    retval = mysql_shutdown(sock, SHUTDOWN_DEFAULT);\n#else\n    retval = mysql_real_query(sock, shutdown, strlen(shutdown));\n#endif\n#endif\n  else if (strEQ(command, \"reload\"))\n    retval = mysql_reload(sock);\n  else if (strEQ(command, \"createdb\"))\n  {\n#if MYSQL_VERSION_ID < 40000\n    retval = mysql_create_db(sock, dbname);\n#else\n    char* buffer = malloc(strlen(dbname)+50);\n    if (buffer == NULL)\n    {\n      do_error(drh, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      XSRETURN_NO;\n    }\n    else\n    {\n      strcpy(buffer, \"CREATE DATABASE \");\n      strcat(buffer, dbname);\n      retval = mysql_real_query(sock, buffer, strlen(buffer));\n      free(buffer);\n    }\n#endif\n  }\n  else if (strEQ(command, \"dropdb\"))\n  {\n#if MYSQL_VERSION_ID < 40000\n    retval = mysql_drop_db(sock, dbname);\n#else\n    char* buffer = malloc(strlen(dbname)+50);\n    if (buffer == NULL)\n    {\n      do_error(drh, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      XSRETURN_NO;\n    }\n    else\n    {\n      strcpy(buffer, \"DROP DATABASE \");\n      strcat(buffer, dbname);\n      retval = mysql_real_query(sock, buffer, strlen(buffer));\n      free(buffer);\n    }\n#endif\n  }\n  else\n  {\n    croak(\"Unknown command: %s\", command);\n  }\n  if (retval)\n  {\n    do_error(SvOK(dbh) ? dbh : drh, mysql_errno(sock),\n             mysql_error(sock) ,mysql_sqlstate(sock));\n  }\n\n  if (SvOK(dbh))\n  {\n    mysql_close(sock);\n  }\n  if (retval)\n    XSRETURN_NO;\n  else \n    XSRETURN_YES;\n}\n\n\nMODULE = DBD::mysql    PACKAGE = DBD::mysql::db\n\n\nvoid\ntype_info_all(dbh)\n  SV* dbh\n  PPCODE:\n{\n  /* \tstatic AV* types = NULL; */\n  /* \tif (!types) { */\n  /* \t    D_imp_dbh(dbh); */\n  /* \t    if (!(types = dbd_db_type_info_all(dbh, imp_dbh))) { */\n  /* \t        croak(\"Cannot create types array (out of memory?)\"); */\n  /* \t    } */\n  /* \t} */\n  /* \tST(0) = sv_2mortal(newRV_inc((SV*) types)); */\n  D_imp_dbh(dbh);\n  ASYNC_CHECK_XS(dbh);\n  ST(0) = sv_2mortal(newRV_noinc((SV*) dbd_db_type_info_all(dbh,\n                                                            imp_dbh)));\n  XSRETURN(1);\n}\n\n\nvoid\n_ListDBs(dbh)\n  SV*\tdbh\n  PPCODE:\n  MYSQL_RES* res;\n  MYSQL_ROW cur;\n\n  D_imp_dbh(dbh);\n\n  ASYNC_CHECK_XS(dbh);\n\n  res = mysql_list_dbs(imp_dbh->pmysql, NULL);\n  if (!res  &&\n      (!mysql_db_reconnect(dbh)  ||\n       !(res = mysql_list_dbs(imp_dbh->pmysql, NULL))))\n{\n  do_error(dbh, mysql_errno(imp_dbh->pmysql),\n           mysql_error(imp_dbh->pmysql), mysql_sqlstate(imp_dbh->pmysql));\n}\nelse\n{\n  EXTEND(sp, mysql_num_rows(res));\n  while ((cur = mysql_fetch_row(res)))\n  {\n    PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));\n  }\n  mysql_free_result(res);\n}\n\n\nvoid\ndo(dbh, statement, attr=Nullsv, ...)\n  SV *        dbh\n  SV *\tstatement\n  SV *        attr\n  PROTOTYPE: $$;$@\n  CODE:\n{\n  D_imp_dbh(dbh);\n  int num_params= 0;\n  int retval;\n  struct imp_sth_ph_st* params= NULL;\n  MYSQL_RES* result= NULL;\n  SV* async = NULL;\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  int next_result_rc;\n#endif\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char            *str_ptr, *buffer;\n  int             has_binded;\n  int             col_type= MYSQL_TYPE_STRING;\n  int             buffer_is_null= 0;\n  int             buffer_length= slen;\n  int             buffer_type= 0;\n  int             param_type= SQL_VARCHAR;\n  int             use_server_side_prepare= 0;\n  MYSQL_STMT      *stmt= NULL;\n  MYSQL_BIND      *bind= NULL;\n  imp_sth_phb_t   *fbind= NULL;\n#endif\n    ASYNC_CHECK_XS(dbh);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n    while (mysql_next_result(imp_dbh->pmysql)==0)\n    {\n      MYSQL_RES* res = mysql_use_result(imp_dbh->pmysql);\n      if (res)\n        mysql_free_result(res);\n      }\n#endif\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  /*\n   * Globaly enabled using of server side prepared statement\n   * for dbh->do() statements. It is possible to force driver\n   * to use server side prepared statement mechanism by adding\n   * 'mysql_server_prepare' attribute to do() method localy:\n   * $dbh->do($stmt, {mysql_server_prepared=>1});\n  */\n\n  use_server_side_prepare = imp_dbh->use_server_side_prepare;\n  if (attr)\n  {\n    SV** svp;\n    DBD_ATTRIBS_CHECK(\"do\", dbh, attr);\n    svp = DBD_ATTRIB_GET_SVP(attr, \"mysql_server_prepare\", 20);\n\n    use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp   = DBD_ATTRIB_GET_SVP(attr, \"async\", 5);\n    async = (svp) ? *svp : &PL_sv_no;\n  }\n  if (DBIc_DBISTATE(imp_dbh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_dbh),\n                  \"mysql.xs do() use_server_side_prepare %d, async %d\\n\",\n                  use_server_side_prepare, SvTRUE(async));\n\n  (void)hv_store((HV*)SvRV(dbh), \"Statement\", 9, SvREFCNT_inc(statement), 0);\n\n  if(SvTRUE(async)) {\n#if MYSQL_ASYNC\n    use_server_side_prepare = FALSE; /* for now */\n    imp_dbh->async_query_in_flight = imp_dbh;\n#else\n    do_error(dbh, 2000,\n             \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n    XSRETURN_UNDEF;\n#endif\n  }\n\n  if (use_server_side_prepare)\n  {\n    str_ptr= SvPV(statement, slen);\n\n    stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if ((mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))  &&\n        (!mysql_db_reconnect(dbh) ||\n         (mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))))\n    {\n      /*\n        For commands that are not supported by server side prepared\n        statement mechanism lets try to pass them through regular API\n      */\n      if (mysql_stmt_errno(stmt) == ER_UNSUPPORTED_PS)\n      {\n        use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(dbh, mysql_stmt_errno(stmt), mysql_stmt_error(stmt)\n                 ,mysql_stmt_sqlstate(stmt));\n        retval=-2;\n      }\n      mysql_stmt_close(stmt);\n      stmt= NULL;\n    }\n    else\n    {\n      /*\n        'items' is the number of arguments passed to XSUB, supplied\n        by xsubpp compiler, as listed in manpage for perlxs\n      */\n      if (items > 3)\n      {\n        /*\n          Handle binding supplied values to placeholders assume user has\n          passed the correct number of parameters\n        */\n        int i;\n        num_params= items - 3;\n        /*num_params = mysql_stmt_param_count(stmt);*/\n        Newz(0, params, sizeof(*params)*num_params, struct imp_sth_ph_st);\n        Newz(0, bind, (unsigned int) num_params, MYSQL_BIND);\n        Newz(0, fbind, (unsigned int) num_params, imp_sth_phb_t);\n\n        for (i = 0; i < num_params; i++)\n        {\n          int defined= 0;\n          params[i].value= ST(i+3);\n\n          if (params[i].value)\n          {\n            if (SvMAGICAL(params[i].value))\n              mg_get(params[i].value);\n            if (SvOK(params[i].value))\n              defined= 1;\n          }\n          if (defined)\n          {\n            buffer= SvPV(params[i].value, slen);\n            buffer_is_null= 0;\n            buffer_length= slen;\n          }\n          else\n          {\n            buffer= NULL;\n            buffer_is_null= 1;\n            buffer_length= 0;\n          }\n\n          /*\n            if this statement has a result set, field types will be\n            correctly identified. If there is no result set, such as\n            with an INSERT, fields will not be defined, and all\n            buffer_type will default to MYSQL_TYPE_VAR_STRING\n          */\n          col_type= (stmt->fields) ? stmt->fields[i].type : MYSQL_TYPE_STRING;\n\n          switch (col_type) {\n#if MYSQL_VERSION_ID > 50003\n          case MYSQL_TYPE_NEWDECIMAL:\n#endif\n          case MYSQL_TYPE_DECIMAL:\n            param_type= SQL_DECIMAL;\n            buffer_type= MYSQL_TYPE_DOUBLE;\n            break;\n\n          case MYSQL_TYPE_DOUBLE:\n            param_type= SQL_DOUBLE;\n            buffer_type= MYSQL_TYPE_DOUBLE;\n            break;\n\n          case MYSQL_TYPE_FLOAT:\n            buffer_type= MYSQL_TYPE_DOUBLE;\n            param_type= SQL_FLOAT;\n            break;\n\n          case MYSQL_TYPE_SHORT:\n            buffer_type= MYSQL_TYPE_DOUBLE;\n            param_type= SQL_FLOAT;\n            break;\n\n          case MYSQL_TYPE_TINY:\n            buffer_type= MYSQL_TYPE_DOUBLE;\n            param_type= SQL_FLOAT;\n            break;\n\n          case MYSQL_TYPE_LONG:\n            buffer_type= MYSQL_TYPE_LONG;\n            param_type= SQL_BIGINT;\n            break;\n\n          case MYSQL_TYPE_INT24:\n          case MYSQL_TYPE_YEAR:\n            buffer_type= MYSQL_TYPE_LONG;\n            param_type= SQL_INTEGER; \n            break;\n\n          case MYSQL_TYPE_LONGLONG:\n#if IVSIZE < 8\n            /* perl handles long long as double\n             * so we'll set this to string */\n            buffer_type= MYSQL_TYPE_STRING;\n            param_type= SQL_VARCHAR;\n#else\n            buffer_type= MYSQL_TYPE_LONG;\n            param_type= SQL_BIGINT;\n#endif\n            break;\n\n          case MYSQL_TYPE_NEWDATE:\n          case MYSQL_TYPE_DATE:\n            buffer_type= MYSQL_TYPE_STRING;\n            param_type= SQL_DATE;\n            break;\n\n          case MYSQL_TYPE_TIME:\n            buffer_type= MYSQL_TYPE_STRING;\n            param_type= SQL_TIME;\n            break;\n\n          case MYSQL_TYPE_TIMESTAMP:\n            buffer_type= MYSQL_TYPE_STRING;\n            param_type= SQL_TIMESTAMP;\n            break;\n\n          case MYSQL_TYPE_VAR_STRING:\n          case MYSQL_TYPE_STRING:\n          case MYSQL_TYPE_DATETIME:\n            buffer_type= MYSQL_TYPE_STRING;\n            param_type= SQL_VARCHAR;\n            break;\n\n          case MYSQL_TYPE_BLOB:\n            buffer_type= MYSQL_TYPE_BLOB;\n            param_type= SQL_BINARY;\n            break;\n\n          case MYSQL_TYPE_GEOMETRY:\n            buffer_type= MYSQL_TYPE_BLOB;\n            param_type= SQL_BINARY;\n            break;\n\n\n          default:\n            buffer_type= MYSQL_TYPE_STRING;\n            param_type= SQL_VARCHAR;\n            break;\n          }\n\n          bind[i].buffer_type = buffer_type;\n          bind[i].buffer_length= buffer_length;\n          bind[i].buffer= buffer;\n          fbind[i].length= buffer_length;\n          fbind[i].is_null= buffer_is_null;\n          params[i].type= param_type;\n        }\n        has_binded= 0;\n      }\n      retval = mysql_st_internal_execute41(dbh,\n                                           num_params,\n                                           &result,\n                                           stmt,\n                                           bind,\n                                           &has_binded);\n      if (bind)\n        Safefree(bind);\n      if (fbind)\n        Safefree(fbind);\n\n      if(mysql_stmt_close(stmt))\n      {\n        fprintf(stderr, \"\\n failed while closing the statement\");\n        fprintf(stderr, \"\\n %s\", mysql_stmt_error(stmt));\n      }\n    }\n  }\n\n  if (! use_server_side_prepare)\n  {\n#endif\n    if (items > 3)\n    {\n      /*  Handle binding supplied values to placeholders\t   */\n      /*  Assume user has passed the correct number of parameters  */\n      int i;\n      num_params= items-3;\n      Newz(0, params, sizeof(*params)*num_params, struct imp_sth_ph_st);\n      for (i= 0;  i < num_params;  i++)\n      {\n        params[i].value= ST(i+3);\n        params[i].type= SQL_VARCHAR;\n      }\n    }\n    retval = mysql_st_internal_execute(dbh, statement, attr, num_params,\n                                       params, &result, imp_dbh->pmysql, 0);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  }\n#endif\n  if (params)\n    Safefree(params);\n\n  if (result)\n  {\n    mysql_free_result(result);\n    result= 0;\n  }\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  if (retval != -2 && !SvTRUE(async)) /* -2 means error */\n    {\n      /* more results? -1 = no, >0 = error, 0 = yes (keep looping) */\n      while ((next_result_rc= mysql_next_result(imp_dbh->pmysql)) == 0)\n      {\n        result = mysql_use_result(imp_dbh->pmysql);\n          if (result)\n            mysql_free_result(result);\n          }\n          if (next_result_rc > 0)\n          {\n            if (DBIc_DBISTATE(imp_dbh)->debug >= 2)\n              PerlIO_printf(DBIc_LOGPIO(imp_dbh),\n                            \"\\t<- do() ERROR: %s\\n\",\n                            mysql_error(imp_dbh->pmysql));\n\n              do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                       mysql_error(imp_dbh->pmysql),\n                       mysql_sqlstate(imp_dbh->pmysql));\n              retval= -2;\n          }\n    }\n#endif\n  /* remember that dbd_st_execute must return <= -2 for error\t*/\n  if (retval == 0)\t\t/* ok with no rows affected\t*/\n    XST_mPV(0, \"0E0\");\t/* (true but zero)\t\t*/\n  else if (retval < -1)\t/* -1 == unknown number of rows\t*/\n    XST_mUNDEF(0);\t\t/* <= -2 means error   \t\t*/\n  else\n    XST_mIV(0, retval);\t/* typically 1, rowcount or -1\t*/\n}\n\n\nSV*\nping(dbh)\n    SV* dbh;\n  PROTOTYPE: $\n  CODE:\n    {\n      int retval;\n\n      D_imp_dbh(dbh);\n      ASYNC_CHECK_XS(dbh);\n      retval = (mysql_ping(imp_dbh->pmysql) == 0);\n      if (!retval) {\n\tif (mysql_db_reconnect(dbh)) {\n\t  retval = (mysql_ping(imp_dbh->pmysql) == 0);\n\t}\n      }\n      RETVAL = boolSV(retval);\n    }\n  OUTPUT:\n    RETVAL\n\n\n\nvoid\nquote(dbh, str, type=NULL)\n    SV* dbh\n    SV* str\n    SV* type\n  PROTOTYPE: $$;$\n  PPCODE:\n    {\n        SV* quoted;\n\n        D_imp_dbh(dbh);\n        ASYNC_CHECK_XS(dbh);\n\n        quoted = dbd_db_quote(dbh, str, type);\n\tST(0) = quoted ? sv_2mortal(quoted) : str;\n\tXSRETURN(1);\n    }\n\nint mysql_fd(dbh)\n    SV* dbh\n  CODE:\n    {\n        D_imp_dbh(dbh);\n        RETVAL = imp_dbh->pmysql->net.fd;\n    }\n  OUTPUT:\n    RETVAL\n\nvoid mysql_async_result(dbh)\n    SV* dbh\n  PPCODE:\n    {\n#if MYSQL_ASYNC\n        int retval;\n\n        retval = mysql_db_async_result(dbh, NULL);\n\n        if(retval > 0) {\n            XSRETURN_IV(retval);\n        } else if(retval == 0) {\n            XSRETURN_PV(\"0E0\");\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(dbh, 2000, \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n\nvoid mysql_async_ready(dbh)\n    SV* dbh\n  PPCODE:\n    {\n#if MYSQL_ASYNC\n        int retval;\n\n        retval = mysql_db_async_ready(dbh);\n        if(retval > 0) {\n            XSRETURN_YES;\n        } else if(retval == 0) {\n            XSRETURN_NO;\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(dbh, 2000, \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n\nvoid _async_check(dbh)\n    SV* dbh\n  PPCODE:\n    {\n        D_imp_dbh(dbh);\n        ASYNC_CHECK_XS(dbh);\n        XSRETURN_YES;\n    }\n\nMODULE = DBD::mysql    PACKAGE = DBD::mysql::st\n\nint\nmore_results(sth)\n    SV *\tsth\n    CODE:\n{\n#if (MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION)\n  D_imp_sth(sth);\n  if (dbd_st_more_results(sth, imp_sth))\n  {\n    RETVAL=1;\n  }\n  else\n  {\n    RETVAL=0;\n  }\n#endif\n}\n    OUTPUT:\n      RETVAL\n\nint\ndataseek(sth, pos)\n    SV* sth\n    int pos\n  PROTOTYPE: $$\n  CODE:\n{\n  D_imp_sth(sth);\n#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION)\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (imp_sth->use_mysql_use_result || 1)\n    {\n      if (imp_sth->result && imp_sth->stmt)\n      {\n        mysql_stmt_data_seek(imp_sth->stmt, pos);\n        imp_sth->fetch_done=0;\n        RETVAL = 1;\n      }\n      else\n      {\n        RETVAL = 0;\n        do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\n      }\n    }\n    else\n    {\n      RETVAL = 0;\n      do_error(sth, JW_ERR_NOT_ACTIVE, \"No result set\" ,NULL);\n    }\n  }\n  else\n  {\n#endif\n  if (imp_sth->result) {\n    mysql_data_seek(imp_sth->result, pos);\n    RETVAL = 1;\n  } else {\n    RETVAL = 0;\n    do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\n  }\n#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION) \n  }\n#endif\n}\n  OUTPUT:\n    RETVAL\n\nvoid\nrows(sth)\n    SV* sth\n  CODE:\n    D_imp_sth(sth);\n    char buf[64];\n#if MYSQL_ASYNC\n    D_imp_dbh_from_sth;\n    if(imp_dbh->async_query_in_flight) {\n        if(mysql_db_async_result(sth, &imp_sth->result) < 0) {\n            XSRETURN_UNDEF;\n        }\n    }\n#endif\n\n  /* fix to make rows able to handle errors and handle max value from \n     affected rows.\n     if mysql_affected_row returns an error, it's value is 18446744073709551614,\n     while a (my_ulonglong)-1 is  18446744073709551615, so we have to add 1 to\n     imp_sth->row_num to know if there's an error\n  */\n  if (imp_sth->row_num+1 ==  (my_ulonglong) -1)\n    sprintf(buf, \"%d\", -1);\n  else\n    sprintf(buf, \"%llu\", imp_sth->row_num);\n\n  ST(0) = sv_2mortal(newSVpvn(buf, strlen(buf)));\n\nint mysql_async_result(sth)\n    SV* sth\n  CODE:\n    {\n#if MYSQL_ASYNC\n        D_imp_sth(sth);\n        int retval;\n\n        retval= mysql_db_async_result(sth, &imp_sth->result);\n\n        if(retval > 0) {\n            imp_sth->row_num = retval;\n            XSRETURN_IV(retval);\n        } else if(retval == 0) {\n            imp_sth->row_num = retval;\n            XSRETURN_PV(\"0E0\");\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n  OUTPUT:\n    RETVAL\n\nvoid mysql_async_ready(sth)\n    SV* sth\n  PPCODE:\n    {\n#if MYSQL_ASYNC\n        int retval;\n\n        retval = mysql_db_async_ready(sth);\n        if(retval > 0) {\n            XSRETURN_YES;\n        } else if(retval == 0) {\n            XSRETURN_NO;\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n\nvoid _async_check(sth)\n    SV* sth\n  PPCODE:\n    {\n        D_imp_sth(sth);\n        D_imp_dbh_from_sth;\n        ASYNC_CHECK_XS(sth);\n        XSRETURN_YES;\n    }\n\n\nMODULE = DBD::mysql    PACKAGE = DBD::mysql::GetInfo\n\n# This probably should be grabed out of some ODBC types header file\n#define SQL_CATALOG_NAME_SEPARATOR 41\n#define SQL_CATALOG_TERM 42\n#define SQL_DBMS_VER 18\n#define SQL_IDENTIFIER_QUOTE_CHAR 29\n#define SQL_MAXIMUM_STATEMENT_LENGTH 105\n#define SQL_MAXIMUM_TABLES_IN_SELECT 106\n#define SQL_MAX_TABLE_NAME_LEN 35\n#define SQL_SERVER_NAME 13\n#define SQL_ASYNC_MODE 10021\n#define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS 10022\n\n#define SQL_AM_NONE       0\n#define SQL_AM_CONNECTION 1\n#define SQL_AM_STATEMENT  2\n\n\n#  dbd_mysql_getinfo()\n#  Return ODBC get_info() information that must needs be accessed from C\n#  This is an undocumented function that should only\n#  be used by DBD::mysql::GetInfo.\n\nvoid\ndbd_mysql_get_info(dbh, sql_info_type)\n    SV* dbh\n    SV* sql_info_type\n  CODE:\n    D_imp_dbh(dbh);\n    IV type = 0;\n    SV* retsv=NULL;\n#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50709\n/* MariaDB 10 is not MySQL source level compatible so this only applies to MySQL*/\n    IV buffer_len;\n#endif \n\n    if (SvMAGICAL(sql_info_type))\n        mg_get(sql_info_type);\n\n    if (SvOK(sql_info_type))\n    \ttype = SvIV(sql_info_type);\n    else\n    \tcroak(\"get_info called with an invalied parameter\");\n    \n    switch(type) {\n    \tcase SQL_CATALOG_NAME_SEPARATOR:\n\t    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */\n\t    retsv = newSVpvn(\".\",1);\n\t    break;\n\tcase SQL_CATALOG_TERM:\n\t    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */\n\t    retsv = newSVpvn(\"database\",8);\n\t    break;\n\tcase SQL_DBMS_VER:\n\t    retsv = newSVpvn(\n\t        imp_dbh->pmysql->server_version,\n\t\tstrlen(imp_dbh->pmysql->server_version)\n\t    );\n\t    break;\n\tcase SQL_IDENTIFIER_QUOTE_CHAR:\n\t    retsv = newSVpvn(\"`\", 1);\n\t    break;\n\tcase SQL_MAXIMUM_STATEMENT_LENGTH:\n#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50709\n        /* MariaDB 10 is not MySQL source level compatible so this\n           only applies to MySQL*/\n\t    /* mysql_get_option() was added in mysql 5.7.3 */\n\t    /* MYSQL_OPT_NET_BUFFER_LENGTH was added in mysql 5.7.9 */\n\t    mysql_get_option(NULL, MYSQL_OPT_NET_BUFFER_LENGTH, &buffer_len);\n\t    retsv = newSViv(buffer_len);\n#else\n\t    /* before mysql 5.7.9 use net_buffer_length macro */\n\t    retsv = newSViv(net_buffer_length);\n#endif\n\t    break;\n\tcase SQL_MAXIMUM_TABLES_IN_SELECT:\n\t    /* newSViv((sizeof(int) > 32) ? sizeof(int)-1 : 31 ); in general? */\n\t    retsv= newSViv((sizeof(int) == 64 ) ? 63 : 31 );\n\t    break;\n\tcase SQL_MAX_TABLE_NAME_LEN:\n\t    retsv= newSViv(NAME_LEN);\n\t    break;\n\tcase SQL_SERVER_NAME:\n\t    retsv= newSVpvn(imp_dbh->pmysql->host_info,strlen(imp_dbh->pmysql->host_info));\n\t    break;\n        case SQL_ASYNC_MODE:\n#if MYSQL_ASYNC\n            retsv = newSViv(SQL_AM_STATEMENT);\n#else\n            retsv = newSViv(SQL_AM_NONE);\n#endif\n            break;\n        case SQL_MAX_ASYNC_CONCURRENT_STATEMENTS:\n#if MYSQL_ASYNC\n            retsv = newSViv(1);\n#else\n            retsv = newSViv(0);\n#endif\n            break;\n    \tdefault:\n \t\tcroak(\"Unknown SQL Info type: %i\", mysql_errno(imp_dbh->pmysql));\n    }\n    ST(0) = sv_2mortal(retsv);\n\n", "use strict;\nuse warnings;\n\nuse Test::More;\nuse DBI;\n\nuse vars qw($test_dsn $test_user $test_password);\nrequire \"t/lib.pl\";\n\nmy $dbh = eval { DBI->connect($test_dsn, $test_user, $test_password, { PrintError => 1, RaiseError => 1, AutoCommit => 0, mysql_server_prepare => 1 }) };\nplan skip_all => \"no database connection\" if $@ or not $dbh;\n\nplan tests => 13;\n\nok $dbh->do(\"CREATE TEMPORARY TABLE t (i INTEGER NOT NULL, n TEXT)\");\n\nok my $sth = $dbh->prepare(\"SELECT * FROM t WHERE i=? AND n=?\");\n\nok $sth->bind_param(2, \"x\" x 1000000);\nok $sth->bind_param(1, \"abcx\", 12);\nok $sth->execute();\n\nok $sth->bind_param(2, \"a\" x 1000000);\nok $sth->bind_param(1, 1, 3);\nok $sth->execute();\n\nok $sth->finish();\n\nok $sth = $dbh->prepare(\"SELECT * FROM t WHERE i=? AND n=?\");\nok $sth->execute();\nok $sth->finish();\n\nok $dbh->disconnect();\n"], "fixing_code": ["2016-11-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.039)\n* Fix for security issue Out-of-bounds read by DBD::mysql CVE-2016-1249 (pali)\n\n2016-10-30 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.038_01)\n* Fix compilation of embedded server (pali)\n  (https://github.com/perl5-dbi/DBD-mysql/pull/68)\n* Fix compilation against libmariadbclient. First version by\n  H.Merijn Brand, improved by Bernt Johnsen @ Oracle.\n* For efficiency use newSVpvn() instead newSVpv() where possible (pali)\n* Correctly coerce fetched scalar values when mysql_server_prepare is\n  not used (pali)\n* Add support for fetching columns of BIT type with\n  mysql_server_prepare = 1 (pali)\n  Fixes https://rt.cpan.org/Public/Bug/Display.html?id=88006\n* Use correct format in printf instead of casting variable types (pali)\n* Include errno.h for MYSQL_ASYNC because it uses errno variable (pali)\n* Travis: also test on perl 5.22 and 5.24.\n\n2016-10-19 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.038)\n* Version 4.037_1 had fixes for MySQL 8.0 provided\n  Bernt Johnsen @ Oracle that were not in the Changelogs\n  (https://github.com/perl5-dbi/DBD-mysql/pull/56)\n* Fixes for compiling against newer libmysqlclient on Windows (kmx)\n* Fix unit test for 40server_prepare_crash on Windows (pali)\n* Perl's IV in scalar can store 64bit integer when perl was compiled\n  with 64 bit support (default on 64bit linux with gcc). Use this\n  feature and stores MYSQL_TYPE_LONGLONG as integers instead of strings\n  when possible. (pali, https://github.com/perl5-dbi/DBD-mysql/pull/57)\n\n2016-10-14 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.037_01)\n* Newest versions of libmysqlclient and the MariaDB C connector no longer\n  export the __WIN__ macro. If this macro is not present we would not\n  compile in the poll.h-based async-support. Changed to use the _WIN32\n  macro instead. Thanks to Sergei Golubchik for suggesting the fix.\n* Fix from Pali Roh\u00e1r for use-after-free in prepared statements,\n  changes to bind logic, and added test 40server_prepare_crash.\n\n2016-10-03 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.037)\n* Security release to patch possible buffer overflow in unsafe sprintf with\n  variable length. Reported and fixed by Pali Roh\u00e1r. This vulnerability\n  is present in all releases at least back to versions 3.0 of the\n  driver, which were released in 2005.\n  The CVE identifier for this vulnerability is CVE-2016-1246.\n\n2016-08-23 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.036)\nStable version, to include all changes since 4.035.\n\n2016-08-19 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035_03)\n* By mistake, when DBD::mysql was compiled against libmariadb, it\n  did not compile in SSL support.\n  Reported by Jitka Plesnikova @ Red Hat\n   (https://rt.cpan.org/Public/Bug/Display.html?id=116959)\n   (https://bugzilla.redhat.com/show_bug.cgi?id=1366773)\n* If the database test server was not on localhost and the test database was\n  not yet created, we would not correctly create the test database.\n  Reported by Vladimir Marek.\n   (https://rt.cpan.org/Ticket/Display.html?id=112072)\n\n2016-08-11 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035_02)\n* Test 56connattr.t failed when run when performance schema is enabled, but\n  tests were run as a user with limited permissions.\n  Reported by J\u00e9r\u00f4me \u00c9t\u00e9v\u00e9.\n  (https://rt.cpan.org/Public/Bug/Display.html?id=115980)\n* In 4.033_03 we added a patch from Petr P\u00edsa\u0159 @ Red Hat for a problem on\n  64-bit big-endian systems. The patch was applied but the unit test was not,\n  also, there was no entry in the change log.\n  Unit test provided by Vladimir Marek.\n  t/40server_prepare.t test failed on s390x platform. Server-prepared\n  values of types int, smallint, and tinyint are passed to application\n  as 32-bit integer. The same buffer was interpreted as long integer\n  by DBD::MySQL. This caused misaligned read/write and bogus\n  interpretation of the values.\n   (https://rt.cpan.org/Public/Bug/Display.html?id=57266)\n* Remove dropdb, createdb, reload and shutdown admin functions from perldoc.\n  These are deprecated by the C API.\n  Use 'CREATE DATABASE..', 'DROP DATABASE...' and other SQL commands instead.\n* Test rt75353-innodb-lock-timeout.t fails on MySQL Server 5.1 and earlier\n  because innodb_lock_wait_timeout is not modifyable per session.\n* Test rt25389-bin-case.t does not work on MySQL Server < 5.1, reported by\n  GAAS.\n\n2016-08-01 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035_01)\n* Apparently, on t/31insertid.t, there is one test that fails when compiled\n  against libmysqlclient 5.7 or up; issuing a SELECT statement on the same\n  database handle that previously executed an INSERT clears\n  $dbh->{mysql_insertid}, while previously this was retained.\n  (https://rt.cpan.org/Ticket/Display.html?id=108000)\n* Removed appveyor.yml and mysql.mtest from CPAN releases.\n* Converted README.pod to README.md because of installation failures on\n  FreeBSD, reported by Don Randolph.\n  (https://rt.cpan.org/Public/Bug/Display.html?id=114177)\n\n2016-07-09 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.035)\n*  Add DBI back to configure_requires, fix by miyagawa.\n\n2016-07-06 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.034)\n* Full version, to include all changes since 4.033.\n\n2016-07-04 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033_03)\n* Check for errors after calling mysql_affected_rows(), by Pali.\n   (https://rt.cpan.org/Public/Bug/Display.html?id=75353)\n* Fix reference to MySQL manual, chapter Character Set Support, suggested\n  by Slaven Rezi\u0107 (https://rt.cpan.org/Public/Bug/Display.html?id=114148)\n* Improve documentation on current database, suggested by Vladimir Marek.\n   (https://rt.cpan.org/Ticket/Display.html?id=112587)\n\n2015-12-18 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033_02)\n* Compile against libssl by default. This allows to connect against remote\n  MySQL servers using SSL. Previously this was only achieved with an explicit\n  switch provided to Makefile.PL - if for some reason you can't or don't want\n  to link against libssl, you can use the new --nossl switch to Makefile.PL.\n* Made tests more robust after CPAN Testers failures.\n\n2015-12-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033_01)\n* Raise minimum DBI version to 1.609 (from 2009!) in order to make\n  tests pass on RHEL5.\n* Add explicit documentation for how to enable SSL at build time,\n  provided by genio.\n* Improve test suite to make it more robust using mixed versions of client and\n  server.\n* Fix use after free error in my_login, provided by hannob.\n* Add explicit instructions stating brackets are required around ipv6-addresses\n  in connection strings, provided by Kenny Gryp.\n\n2015-10-26 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.033)\n* Full-release to include 03.\n\n2015-10-25 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032_03)\n* Use mysql_get_option to read net_buffer_length and mysql_get_parameter\n   where available, needed for MySQL 5.7.9. Patch from berntm @ Oracle.\n   https://github.com/perl5-dbi/DBD-mysql/pull/42\n* Fix mysql_conn_attrs test when run against MySQL 5.1 server.\n* Fix for memory leak to $sth->{ParamValues} , RT83051\n    https://rt.cpan.org/Public/Bug/Display.html?id=83051\n* Fixes for running test suite on MySQL 5.7.\n* Fix running test suite with InnoDB disabled, reported by bor.\n\n2015-07-20 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032)\n* Full-release to include 02 and 01.\n\n2015-06-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032_02)\n* Added support for utf8mb4 by Dani\u00ebl van Eeden and Eric Herman (Booking.com)\n* Added patch for connection attributes in MySQL 5.6.6+, by Dani\u00ebl van Eeden\n   and Eric Herman (Booking.com).\n\n2015-04-16 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.032_01)\n* Fixed test rt88006-bit-prepare on MyISAM storage\n   (Reported both in RT102657 and by Scimon on github)\n* Fix for https://rt.cpan.org/Public/Bug/Display.html?id=102717 \"Fritz\" Friedrich Haubensak (hsk AT fli-leibniz DOT de)\nVielen Danken!\n* Corrected name ofINSTALL.pm in POD David Farrell <davidnmfarrell AT gmail DOT com>\n\n    Corrected name of INSTALL.pm in POD\n\n2015-03-05 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.031)\n* Added LICENSE\n* Reworked installation documentation in POD.\n* Allow use of bracketed IPv6 addresses in connection string (RT70640),\n   fix by Tim Mullin @ cPanel).\n* Locate mysql_config in path on MSWin32 (RT94838, reported by CHORNY).\n* Environment variable DBD_MYSQL_CONFIG actually works now.\n* Makefile.PL now correcly handles MariaDB's mysql_config.\n* Correct attribution to David Dick #86030: PATCH: adding statistics_info support\n* Test suite can now be run in parallel. Fixes RT98994 reported by DOHERTY.\n* Fixes for MySQL 5.6+ and for prepared statement handling (stevenh on github).\n* Fix for RT100792, New test t/05dbcreate.t fails if user has no permissions.\n* Fix for bit test (RT68374, BJDEAN@cpan.org) CaptTofu added 40bit.t to test.\n\n\n2015-03-02 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.030_02)\n* Reworked installation documentation in POD.\n* Allow use of bracketed IPv6 addresses in connection string (RT70640),\n   fix by Tim Mullin @ cPanel).\n* Locate mysql_config in path on MSWin32 (RT94838, reported by CHORNY).\n* Environment variable DBD_MYSQL_CONFIG actually works now.\n* Makefile.PL now correcly handles MariaDB's mysql_config.\n\n2015-01-27 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.030_01)\n* Correct attribution to David Dick #86030: PATCH: adding statistics_info support\n* Test suite can now be run in parallel. Fixes RT98994 reported by DOHERTY.\n* Fixes for MySQL 5.6+ and for prepared statement handling (stevenh on github).\n* Fix for RT100792, New test t/05dbcreate.t fails if user has no permissions.\n* Fix for bit test (RT68374, BJDEAN@cpan.org) CaptTofu added 40bit.t to test.\n\n2014-12-08 Patrick Galbraith (aka CaptTofu) and community (4.029)\n* Added fix to tests to create test database if not exists (contstant failure on Travis) (CaptTofu)\n* Support the fraction of (Oracle) MySQL Fabric that is supported by the most recent Connector/C (Steffen Mueller smueller<at>cpan<dot>org\n* Statistics Info Milan \u00bform <sorm<at>is4u<dot>cz> for work on statistics_info\n* Fix for RT 97625, use after free(), Reini Urban rurban<at>cpan<dot>org\n\n2014-08-01 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.028)\n* Fixed bug in mysql.xs where dbh was being used as error code\n* RT #97570: fix wrong salloc free in mysql_st_internal_execute - (Reini Urban, cPanel)\n* Fix RT #97625 use-after-free in mysql_dr_error, and #86153 - (Reini Urban, cPanel)\n* find mysql.h for MariaDB on Win32 (Graham Ollis)\n* Update mysql.pm to work with ipv6 and ipv4 addresses (katyavoid)\n\n2014-03-19 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.027)\n* Added more OS X notes and fixed compiler warnings\n* Skip tests if test database is not present-RT92330 (zefram <zefram at fysh dot org>\n* metacpan.org and search.cpan.org didn't display module POD, caused by fix for RT90101. Reported by Oleg, RT92350.\n\n2014-01-15 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.026)\n* t/29warnings.t fails on MySQL Server 5.1.something - Reported by RT91202, Gisle Aas. Now is handled depending on version.\n* README.pod misses proper NAME heading - RT90101 - Damyan Ivanov, Debian Perl Group\n* Added fix and test for RT91715\n* Added feature from Jacob Gelbman (cPanel) mysql_skip_secure_auth\n\n2013-11-05 Patrick Galbraith, Michiel Beijen, DBI/DBD community (4.025)\n* Set with parentheses and column_info - RT50304 - reported and fixed by Kevin Bosak.\n* Fix method redefinition warnings in threads on Perl >= 5.16 - Dagfinn Ilmari Manns\u00e5ker\n* use strict and warnings everywhere.\n* Minimum perl version is now 5.8.1, just as for DBI.\n* Improved database version check so tests run correctly on MariaDB 10.\n* Fix manifest - RT89106, reported by Joe Grasse.\n* set auto_increment_offset explicitly to make tests pass if they are set on server - RT83487, reported by Ian Barton.\n* Assume 'localhost' when testport is set but no testhost in Makefile.PL - RT83496, reported by Philip Stoev.\n* Corrected documentation for mysql_init_command option - Alexey Molchanov <alexey.molchanov@portaone.com>\n* Skip stored procedure tests if user is unpriviliged - RT83348 - Chris Weyl <cweyl@alumni.drew.edu>\n* Fix example in POD doc for NUM_OF_FIELDS - RT36730, reported by tapoutmma.\n* Fix for memory leak (RT86153) when connecting with incorrect password\n* Bail if connect fails early on (RT31823)\n\n2013-09-17 Michiel Beijen, Patrick Galbraith, DBI/DBD community (4.024)\n* Fix memory leak if mysql_server_prepare is enabled - RT76462 - Masahiro Chiba\n* Small dist improvements:  Michiel Beijen <michiel.beijen@otrs.com>\n* Undefined $DBI::errstr on execute fail on Windows: Michiel Beijen <michiel.beijen@otrs.com>\n* Better diagnostics for 80procs.t Fixes RT#71199: Alexandr Ciornii <alexchorny@gmail.com>\n* Fix #64013: INSTALL.pod is shown with 'man install': Juergen Weigert <jw@suse.com>\n* Added 'testport' to keys in Makefile.PL Fixes RT#83492: Michiel Beijen <michiel.beijen@otrs.com>\n* Fixed test 70takeimp warning. Michiel Beijen <michiel.beijen@otrs.com>\n* Made test t/87async.t not stop on Win32. Michiel Beijen <michiel.beijen@otrs.com>\n* Update github location.  Update support information. Michiel Beijen <michiel.beijen@otrs.com>\n* POD Fixes  Patch from RT77043 by Gunnar Wolf, Debian Perl Group. Michiel Beijen <michiel.beijen@otrs.com>\n\n2013-04-12 Patrick Galbraith et open source community <patg at patg dot net> (4.023)\n    Fix memory leak if mysql_server_prepare is enabled.\n* Fix primary_key_info result ordering - https://github.com/CaptTofu/DBD-mysql/pull/39 - Dagfinn Ilmari Manns\u00e5ker\n* allow compilation with msvc - https://github.com/CaptTofu/DBD-mysql/pull/37 - Walde Christian\n* just to set MYSQL_OPT_WRITE_TIMEOUT and MYSQL_OPT_READ_TIMEOUT by dsn - https://github.com/CaptTofu/DBD-mysql/pull/36 - Naosuke Yokoe\n* just remove unnecessary \"my\" - https://github.com/CaptTofu/DBD-mysql/pull/34 - Shoichi Kaji\n* eval $ExtUtils::MakeMaker::VERSION requires for old ExtUtils::MakeMaker - https://github.com/CaptTofu/DBD-mysql/pull/32 - Daisuke Murase\n* Updated documentation to reflect that bugs will be reported at rt.cpan.org\n* Updated version\n* Chased tail finding issue with -1 being converted to max unsigned int in PS mode\n* Various typos and other unicode fixes dsteinbrunner <dsteinbrunner@gmail.com>\n* Fixed permissions on files.\n* Clarified documentation and bumped version for next release\n\n2012-08-28 Patrick Galbraith et open source community <patg at patg dot net> (4.022)\n* Fixes for Win32 from Rom Hoelz (https://github.com/hoelzro)\n* Pulling back in work for 4.021 that didn't get pushed and much other work from Chip Salzenberg (https://github.com/chipdude)\n* Column info order fix from Tokuhiro Matsuno (https://github.com/tokuhirom)\n* Fix AutoCommit comparison logic to avoid spurious commands to mysql from Matthew Horsfall (https://github.com/wolfsage)\n* server_preapre can't bind placeholder on comment. from Misahiro Chiba (https://github.com/nihen)\n* server_prepare; data is null, allocate big memory bug. from Misahiro Chiba (https://github.com/nihen)\n\n2012-04-15 Patrick Galbraith (work of others) <patg at patg dot net> (4.021)\n* Fix to enable PERL_NO_GET_CONTEXT to spee up DBD on thread Perls\n(Dave Mitchell <davem at iabyn dot com>) Thank you!\n* Fix to is_prefix not being exported by mysql Aran Deltax <bluefeet at gmail dot com> Thank you!\n* Eliminate DBIS usage Dagfinn Ilmari Manns\u00e5ker <ilmari at ilmari dot org> Thank you!\n* Enhanced / Fixed server side prepared statement checks (Steven Hartland) Thank you!\n* Fix missprint in doc of DBD::mysql of mysql_bind_type_guessing (Perlover http://blog.perloever.com) Thank you!\n* Misprint in lib/DBD/mysql.pm (Perlover) Thank you!\n\n2011-08-15 Patrick Galbraith <patg at patg dot net> (4.020)\n* Numerous (!! Thank you!!) fixes for prepared statements: Masahiro Chiba <nihen at megabbs\ndot com>\n\t- Chop blanks fixed\n\t- UTF8 improvements\n\t- fixed memory allocation for BLOBs\n\t- auto-reconnect\n* Fix in leak test, which failed sometime due to first assignment $prev_size over\npaging (Masahiro Chiba)\n* Catalog test allows use of schemas other than 'test' (Masahiro Chiba)\n* Documentation fix for auto_reconnect (Karen Etheridge <ether at cpan dot\norg>)\n* Win32 and general installation fixes (Alexandr Ciornii, http://chorny.net)\n\n\n2011-05-08 Patrick Galbraith <patg at patg dot net>  Rob Hoelz <rhoelz at inoc dot com> (4.019)\n* Asynchronous support added by Rob Hoelz - Thanks!\n* Amiri Barksdale - Enable environment variables for installation options, add\ndocs to POD - Thanks!\n* Pedro Melo - fix to change sv_undef to PL_sv_undef from 4.018 - Thanks!\n\n2010-10-11 Patrick Galbraith <patg at patg dot net> (4.018)\n* Added client and server info patch from Robert M. Jansen\n* Added documentation and tests for new features\n* More code cleanup\n\n2010-08-11 Patrick Galbraith <patg at patg dot net> (4.017)\n* BUG #60085, Andreas Koenig's patch for DBI changes\n* Updated documents\n\n2010-07-10 Patrick Galbraith <patg at patg dot net> (4.016)\n* Disabled mysql_bind_type_guessing due to one performance issue\n  querying on a indexed character column unquoted will mean the index\n  is not used\n* Fixed int types that should be bools\n\n2010-07-09 Patrick Galbraith <patg at patg dot net> (4.015)\n* BUG #56664 fixed t/40blobs.t skip_all logic (W. Phillip Moore)\n* BUG #57253 Fixed iteration past end of string (crash). (Chris Butler)\n* Added a new parameter for old behavior- mysql_bind_comment_placeholders which\n  will make it possible to have placeholders bound for those who really\n  want that behavior.\n* Fixed bind_type_guessing - always on now\n\n2010-04-14 Patrick Galbraith <patg at patg dot net> (4.014)\n* BUG #30033 Fixed handling of comments to allow comments that contain characters\n  that might otherwise cause placeholder detection to not work properly\n* BUG #53844, Fix for memory leak in stats. (Gregory Burmistrov)\n* BUG #49719, Fix for handling of NULLs in prepared statements (Gert Pache)\n* BUG #55627, Fix for testing failure due to strict mode (Yves)\n* BUG #51784, Fix for mysqladmin on Windows in Makefile (Zeeshan Muhammad)\n* BUG #41630, Typo in Makefile\n* Had to define true and false in dbdimp.h. Didn't work out of the box on Linux\n\n2009-09-16 Patrick Galbraith <patg at patg dot net> (4.013)\n\n* #49484: PATCH add support for MYSQL_INIT_COMMAND - Peter John Edwards\n* #48242: 'mysql_bind_type_guessing' doesn't work correctly\nwith minus sign - Thanks Serguei Trouchelle!\n* #45616: t/40blobs.t cannot pass without database access -\nServerError() not declared - Thanks ysth http://ysth.livejournal.com/\n\n2009-06-18 Patrick Galbraith <patg at patg dot net> (4.012)\n\n* Patch to bind_type_guessing from Craigslist,\n  Thanks to Chris! Happiness is no quoted numbers.\n  Fixed ChopBlanks to work with bind_type_guessing\n* Patch for win32 strawberry build\n  Thanks to Curtis Jewell! Windows needs love\n* Patch for auto-reconnect to set active flag\n  Thanks to Doug Fischer!\n* Fixed bug 32464 http://bugs.mysql.com/bug.php?id=32464.\n  See https://rt.cpan.org/Ticket/Display.html?id=46308\n  Add connection flag mysql_no_autocommit_cmd which users of\n  MySQL Proxy can use to prevent 'set autocommit=#' from being\n  issued by the driver. 'perldoc DBD::mysql' to see how to use\n  this new flag\n* Added bind-type-guessing options to Makefile.PL so the entire\n  test suite can be run with bind_type_guessing set.\n\n2009-04-13 Patrick Galbraith <patg at patg dot net> (4.011)\n* Renamed unsafe_bind_type_guessing, fixed some of the logic. This\ncan be used to deal with bug 43822\n(https://rt.cpan.org/Ticket/Display.html?id=43822)\n* Patch from Daniel Frett (daniel Dot frett At ccci Dot org) to fix\nissue of binding sever side integer parameters (server-side prepare\nstatements) resulting in corrupt data, bug 42723\n(https://rt.cpan.org/Ticket/Display.html?id=42723)\n* Updated documentation, cruft cleanup (as always)\n\n2008-10-24 Patrick Galbraith <patg at patg dot net> (4.010)\n* Fix to dbd_bind_ph() for uninitialized value 'buffer_length'\nthanks for bug report and patch from Askniel.com (thanks!)\n\n2008-10-21 Patrick Galbraith <patg at patg dot net> (4.009)\n* Fix to re-enable TAKE_IMP_DATA_VERSION. Still have to ensure DBI version 1.607 or higher\n* Fix to escaped single quotes throwing off bind param detection. Patch from Zhurs (zhurs@yandex.ru) Spasibo!\n\n2008-8-15 Patrick Galbraith <patg at patg dot net> (4.008)\n* Multi statement patch, thanks to Chris Heath!\n* Disabled TAKE_IMP_DATA_VERSION because segfault with DBI < 1.607\n* #29528: bind_param(..., SQL_FLOAT) ignores exponents - fixed, Thanks to\nTokuhiro Matsuno!\n* Cleanups to make mysqlEmb work under Cygwin - Thanks to Chris Rodgers\n<http://rodgers.org.uk/> !\n* Modified and disabled tests for MySQL version < 4.1 for unsupported features\n\n2008-5-11 Patrick Galbraith <patg at patg dot net> (4.007)\n\n* Took out mysql_server_init call where not needed\n* Complete re-write of test suit to use Test::More - tons of cleanups!\n* Makefile.PL changes to use current user in 'make test' if not defined\n\n2007-12-26 Patrick Galbraith <patg at patg dot net> (4.006)\n\n* Cleanups on OS X compile\n* Fixes to syntax errors on AIX\n* Removed test code that was leaving trace files around\n\n2007-3-22 Patrick Galbraith <patg at patg dot net> (4.005)\n\n* Fixed mysql_warning issue < 4.1 (reminers, patches, help from ROAM, (issue 25713)\n* makerealclean patch from ROAM (issue #25714)\n* sqlstate cleanup patch from ROAM\n* Replaced all references to dbis to use imp_xxh per DBI best practices\n* Fix to dbd_st_destroy - added back previously removed 'free everything' code which\n  had been moved to dbd_st_finish, causing a crash upon freeing of bind values\n  after all rows resulting from one execution of a query have been fetched. This meant\n  that next attempt to execute the prepared statement would segfault. This\n  work thanks to Rainer Weikusat!\n* Removed all 'FindNewTable' calls in all tests. Just use 't1' for all tests to\n  simplify things. Plus, this is how MySQL internall tests.\n* Better 'skip test' logic in some tests that were still running when they shouldn't\n  have been.\n\n\n\n2007-3-22 Patrick Galbraith <patg at patg dot net> Jim Winstead <jimw@mysql.com> (4.004)\n* Work around a bug in old 3.23 servers by specifying NOT NULL for fields used\n  as a primary key in tests. (Bug #20325, reported by Julian Ladisch)\n* Add support for mysql_warning_count statement handle attribute. (Bug #25457,\n  patch from Philip Stoev)\n* Add support for mysql_multi_statements connection option. (RT #12322, based\n  on patch from Doug Morris)\n* Had to bump to 4.003 do to print statement in mysql.pm that made it\n  into the dist. Even though you can delete a file on CPAN, you cannot\n  re-upload it if it's the same name. Mea Culpa.\n* UTF8-Flag not set with flag mysql_enable_utf8 and column collation utf8_bin patch,\n  Joost Diepenmaat, (RT #24738)\n* Fixed do_error definition (Scott Hildreth, Tim Bunce)\n* Conversion of test suite to Test::More\n\n2007-3-5 Patrick Galbraith <patg at patg dot net> Jim Winstead <jimw@mysql.com> (4.003)\n* Fix inclusion of non-primary keys in primary_key_info. (Bug #26786,\n  reported and patch by Dave Rolsky)\n\n2007-3-1 Patrick Galbraith <patg at patg dot net> Jim Winstead <jimw@mysql.com> (4.002)\n* Fix re-exec of Makefile.PL when forcing $ENV{LANG} to 'C'. (RT #25233,\n  reported by Slaven Rezic)\n* Rewrote table_info method to support all arguments (previously it would\n  only ever return all of the tables in the current database, no matter what\n  was specified)\n* Fixed $DBD::mysql::VERSION to be a string instead of a float, which caused\n  problems for certain locales\n* Fixed bug #23974. $dbh->column_info now returns handle with no rows upon\n  table not existing.  Much thanks to Tim Bunce for help fixing the problem\n  in mysql.pm vs. dbdimp.c\n* Removed #ifdefs for do error (sqlstate being passed as last arg depending on\n  version)\n* Fixed insertid test to work with auto_increment_increment replication setup.\n* Patch from Tim Bunce fixing do() not set $dbh->{Statement} attribute,\n  which prevented DBD::Profile from giving correct results for calls to do()\n  and causing ShowErrorStatement to possibly report the wrong statement in the\n  error message\n* Patch from Tim Bunce clearing out the sth attribute cache when switching\n  between result, sets which prevented the adjustedment of NUM_OF_FIELDS\n* Cleanup of several unused variables\n* Added support for wildcards in last argument of column_info().\n* Add mysql_is_auto_increment to results of column_info(). (Bug #26603,\n  original patch from Dave Rolsky)\n* Return the correct table type for both tables and views from the table_info()\n  method. (Bug #26603, original patch from Dave Rolsky)\n* Add implementation of foreign_key_info() (Bug #26604, original patch from\n  Dave Rolsky, and final implementation based on Connector/J code)\n\n\n2007-1-8 Jim Winstead <jimw@mysql.com> Patrick Galbraith <patg at patg dot net> (4.001)\n* Fix handling of unsigned integer values in result sets when using\n  server-side prepared statements (they were not retrieved at all).\n* Fix handling of signed integer values when using server-side prepared\n  statements (they were being forced to unsigned values).\n* Do not tell Perl that the contents of binary fields are UTF-8.\n  [rt.cpan.org #22123], original patch by Joost Diepenmaat\n* Fix double-free of bound parameters when freeing statements. (Bug #20559)\n* Make sure to handle \"magical\" values in a couple of places. (Bug #20104)\n* Update the hints about what to do when zlib is found missing while\n  linking. (Bug #13803, reported by Philip Stoev)\n* Explicitly initialize the MySQL client library to avoid possible race\n  conditions in a multithreaded application. (Bug #21792)\n* Fix warning when no connection attributes are passed to the connect\n  method (Bug #17323, reported by Phil Randal)\n* Removed redundant warnings when commit or rollback is called while\n  AutoCommit is enabled. [rt.cpan.org #15802], reported by Tyler MacDonald\n* Report correct type for decimal columns from MySQL 5.0 and later\n  [rt.cpan.org #18294], reported by Ray Zimmerman\n* Fix t/40bindparam.t to work when ANSI_QUOTES SQL_MODE is set.\n  [rt.cpan.org #21521], reported by David Wheeler\n* Return a statement handle with an error when column_info is called on\n  a table that does not exist. (Bug #23974, patch by Philip Stoev)\n* Fix handling of table names with characters that did not match /\\w/ in\n  the column_info method. (Bug #22005, reported by Philip Stoev)\n* Fix handling of negative integers bound to a column marked as SQL_INTEGER.\n  [rt.cpan.org #18976], patch from Mike Schilli.\n* Add support for the primary_key_info method. [rt.cpan.org #8541]\n* Fixed Bundle::DBD::mysql to only include modules required for using\n  DBD::mysql, not the old Mysql package. [rt.cpan.org #24096]\n* Updated Makefile.PL to not include files in .svn directories\n* Fixed various compile warnings in mysql.xs (ISO C)\n* Cleaned up stored procedure examples, made strict\n* Fixed bug that blew away subsequent result sets if you fetched all rows, only in\n  result sets that had more than one row\n* Added test for bug #14979 http://rt.cpan.org/Ticket/Display.html?id=14979, which still\n  fails\n* Tested with ALL mysql versions, fixed 40types, 40bind_param tests to work with 4.0, 4.1\n* Fixed dbdimp.c to not test for MYSQL_DATA_TRUNCATED unless >= mysql 5.0\n\n2006-12-22 Patrick Galbraith <patg at patg dot net>, Alexey Stroganov (4.00)\n* Added Alexey Stroganov's patch which fixes varying number of columns in\n  multiple result sets. Added new test cases to 80procs.t based of his\n  test script (bug #21028) (Thanks Alexey!). Also fixed 80procs.t to allow\n  'CALL' to be prepared\n* Added Philip Stoev's patch for DATA_TYPE date and time columns (bug #23988)\n  (Thanks Philip!)\n* Reworked (for working with 4.0, which doesn't support sqlstate) Philip Stoev's\n  patch for sqlstate, bug #23935 (Thanks Philip!)\n* New Versioning! 4.00 now. This dev tree will now become trunk\n* Cleaned up much code that failed between versions (!!!)\n* Turned off prepared statements by default\n* Tested this with 5.1, 5.0, 4.1, 4.0. Works with ALL these versions!\n\n2006-10-10 Patrick Galbraith <patg at patg dot net>, Alexey Stroganov (3.0009_1)\n* Added fbind and bind alloc to dbd_st_describe. This was causing a crash\n  when using with mod_perl\n\n2006-10-10 Patrick Galbraith <patg at patg dot net> (3.0008_1)\n* Added patch for SSL Verify Certificate (Thanks Eric Chen!)\n* Added multiple fixes to dbd_st_prepare which fixed variable overwrite\n  and unset increment counter. Also improved loop which checks statements\n  for presence of \"LIMIT\" by using a pointer as opposed to char array\n  increment variable. These errors were showing up in OpenBSD and other\n  Unixen (which I think all BSD-based) (Thanks to Kyle George!)\n* Added fix to Makefile.PL to obtain correct build flags on VMS\n  (Thanks to Eric Milkie!)\n* Fixed casting of num_params to unsigned int in calls to NewZ in mysql.xs\n\n2006-10-07 Patrick Galbraith <patg at patg dot net>, Jim Winstead <jimw@mysql.com>\n  (3.0007_2)\n  * Added UTF8 patch from Dominic Mitchell (Thanks!)\n  * Fixed declaration of \"row\" in mysql_st_internal_execute which caused compile\n    errors on some platforms\n  * Fix documentation for _ListDBs to remove incorrect information about\n    limitations of data_sources(). (RT #20843, patch by Ann Barcomb)\n  * Fix typo in example (missing quote). (RT #15086)\n  * Mention in POD that 'localhost' always means to connect via UNIX socket,\n    and 127.0.0.1 must be used for TCP/IP to localhost (RT #14942, reported by\n    Alessandro Ranellucci)\n  * Fix typos in Makefile.PL (RT#16178, reported by Gavin Shelley)\n\n2006-09-08 Jim Winstead <jimw@mysql.com>, Patrick Galbraith <patg@mysql.com>\n(3.0007_1) (3.0006/3.0006_1 is the same as 3.0005/3.0005_1)\n  * Make sure to call dbd_st_finish when all rows from a statement handle\n    have been fetched. (Bug #20153, Bug #21607, RT #20464, RT #21241)\n  * Patch from Steve Hay to fix bind_param to deal properly with insertion\n    of a NULL into an INT or DOUBLE column using server-side prepare.\n    Converted Steve's dbi.pl script to expose this problem to 40bindparam2\n    test.\n  * Fix to mysql_st_internal_execute to keep from passing undefined dbh\n    handle member (bind_type_guessing) to parse_param causing crash on\n    OpenBSD. Reported on rt.cpan.org (#20868) by Kyle Georg, as well as\n    info from Sam Smith and Federico Giannici\n  * Cleaned up tests to make sure test table is dropped at end of test.\n\n2006-06-10 Patrick Galbraith <patg@mysql.com) (3.0005)\n  * Fix dbd_st_finish in 3.0004 didn't clean up bind buffers resulting in\n    a memory leak. See eg/prepare_memory_usage.pl to see how this manifests\n    itself. Thanks to Jason Snell for giving me a good script to reproduce\n    this!\n  * Fix to parse_params, mysql.xs dbh->do, and bind_param to deal with\n    passing substr to \"do\" for placeholder value. Thanks Martin Waite for\n    the patch to parse_params (extended to mysql.xs \"do\" and bind_param for\n    server-side prepared statements.\n\n2006-05-17 Patrick Galbraith <patg@mysql.com) (3.0004_1)\n  * Fix dbd_st_finish which closed the handle prematurely (Martin Evans)\n  * Compile issues (Martin Evans)\n  * Small change to get utf8 data returned. One still has to:\n      $dbh->do(\"set character set utf8\");\n      $dbh->do(\"set names utf8\");\n\n    to get utf8 back and even then you only get it back if the\n    column is defined as utf8 in mysql.\n  * Fix to dbd_bind_ph to deal with numbers (ints, floats) correctly\n    (Alexey Stroganov)\n  * Test changes - bind_param 41 and 42\n  * Turned off 70takeimp test\n\n2006-04-29 Patrick Galbraith <patg@mysql.com) (3.0003_1)\n  * Removed old Msql-Mysql Driver emulation code - finally!!!\n  * Removed aweful string testing code (that I wrote) for unsported\n    statements and now use mysql_stmt_prepare, if statement not\n    supported, toggle to mysql_emulated_prepare\n  * Fixed bug where failed stmt execution caused later statements\n    to fail with mysql_stmt_reset\n  * Added tests for unsupported statements\n  * Added test for test of failed statement with subsequent executes\n    (thanks to Martin Evans!)\n  * Added typo fix (Martin Evans)\n  * Added support for ParamValues and associated test (Martin Evans)\n  * Removed old emulated driver tests (HOORAY!)\n  * Cleaned up debug printing code\n  * Fixed syntax for create table ENGINE=InnoDB instead of type=innobase\n  * Cleaned up tests\n\n2006-01-31 Patrick Galbraith <patg@mysql.com> (3.0002_5)\n  * Fixed bugs 15546 (selectcol_arrayref failing on SHOW TABLES)\n    and 15665, 'USE dbname' failing when driver is not in emulated\n    prepare mode\n\n2005-10-26 Patrick Galbraith <patg@mysql.com> (3.0002_4)\n  * Added Guy Harrison's patch for multiple result sets\n  * Fixed bugs with declarations in middle of functions\n  * Cleaned up code, rewrote several loops using pointers\n    instead of iterators\n  * Rewrote 'SHOW', 'ALTER', 'CALL', 'CREATE' toggling code that turns\n    off server prepared statements (these calls are not supported)\n  * Updated documentation\n\n2005-09-28 Patrick Galbraith <patg@mysql.com> (3.0002_3)\n  * Added code to  mysql_st_internal_execute that determines whether the\n    SV *h is a sth or dbh, and then imports imp_dbh appropriately\n\n2005-09-26 Patrick Galbraith <patg@mysql.com> (3.0002_2)\n  * Fixed bug in dbd_st_execute where imp_sth was being\n    imported unecessarily, when only imp_dbh is needed. This caused a\n    core dump in some cases. Thanks to Andy Maas at Proofpoint for his\n    execellent detective work!\n  * Small changes to Makefile.PL to make sure --ps-protocol works as\n    advertised.\n  * Updated install.html with current info about prepared statements and FC\n    RPM/YUM packages.\n\n2005-08-04 Patrick Galbraith <patg@mysql.com> (3.0002_1)\n  * Prepared statement support is default now. To turn it off\n    a parameter 'mysql_emulated_prepare' must be turned ON\n  * Better error handling in mysql_internal_execute_ps (renamed\n    from mysql_internal_execute41). Also free the result if error -\n    that could have been a memory bug\n  * Added a simply 'do' to t/35prepare.test to see if you can turn\n    off prepared statements in the 'do' call.\n  * Cleaned up a LOT of cruft. Added more 'caveat' blurbage to old\n    Mysql.pm lib, which will not work with prepared statements\n\n2005-07-06 Parick Galbraith <patg@mysql.com> (3.0001_3)\n  * Fix to ensure MYSQL_BIND is only defined when mysql\n    client version is >= 4.1.3. Thanks to Tom Parkison\n\n2005-07-06 Patrick Galbraith <patg@mysql.com> (3.0001_2)\n  * Fixed runtime bug (when inserting or updating quotes or double quotes)\n    (Thanks to Brad Choate, Six Apart Ltd.)\n\n2005-07-04 Patrick Galbraith <patg@mysql.com> (3.0001_1)\n  * Changed uint argument in safe_sv_fetch to int due to\n    uint not being available on windows unless you include\n    my_globals.h in dbdimp.h, which also breaks on unixen!\n  * Removed // comments from mysql.xs (thanks Bodo Bergman!)\n\n2005-07-03 Patrick Galbraith <patg@mysql.com> (3.0000_0)\n  * Special Thanks to Steve Hay for his patch to fix windows\n  * Fixed Makefile.PM for windows compiles\n  * Removed long long type from dbdimp.h\n  * Changed strncasecmp to strncmp (still need a better long-term solution)\n    in dbdimp.c\n  * Modified Makefile.PM to make prepared statements on by default\n\n2005-04-26 Patrick Galbraith <patg@mysql.com> (2.9015_3)\n  * Added patch from Stas Beckman for new DBI feature take_imp_data, needed\n   for DBI::Pool\n  * Fix to Statement.pm for old API call for numfields that caused\n    warnings on 40numrows and akmisc tests\n  * Fix to bind_ph to throw an error if trying to bind a non-numeric\n    value as numeric\n  * Better fix for dealing with error condition in $sth->rows()\n  * Fix to bind_param to throw error when trying to bind a non-numeric as\n    numeric\n\n\n2005-04-04 Patrick Galbraith <patg@mysql.com> (2.9015_2)\n  * Merged all code changes from 2.900x tree from the last 9\n    months\n    - unsafe bind type guessing patch from Dragonchild\n    - Removed mysql.mtest\n    - Fixed sth->rows to return my_ulongloong and also handle\n      error from client API\n    - Fix to make autocommit work was already part of this version\n    - Auto-reconnect bug fixed in 2.9006 included\n  * Added simple test to 35limit test to check if using malicious code in\n   LIMIT ?, ? placeholders works, which it doesn't.\n  * Fix that sets mysql_server_prepare to 0 if SQL statement is 'SHOW ...'\n    which is not supported by prepared statement API currently\n\n2004-10-28 Rudolf Lippan <rlippan@remotelinux.com> (2.9015_1)\n\t* Merged Makefile.PL from 2.9005_3\n\t* Bumped version number to 2.9015 for release of Dev Branch. Which\n\t  will become 2.9020 when tested and merged into HEAD.\n\t* fixed typo/compiler warning in bind_param_guessing\n\t  '*testchar' should have been 'testchar'.\n\n2004-10-20 Patrick Galbraith patg@mysql.com (Dev-2_9 - 2.9005)\n\n  * merged changes from 2.9005_1\n  * fix to blob in dbd_st_fetch (Alexey Stroganov ranger@mysql.com)\n  In case of BLOB/TEXT fields we allocate only 8192 bytes in dbd_describe()\n  for data. Here we know real size of field so we should increase buffer\n  size and refetch column value\n\n2004-07-25 Patrick Galbraith patg@mysql.com (2.9004)\n  * Prepared statement support\n* Use of mysql_stmt_* API (>= 4.1.3)\n  * mysql_shutdown fix\n* MySQL Embedded Server support (Alexey Stroganov)\n  * Fixed link failure on MacOSX\n  * Cleaned up tests\n  * Fixed various compile warnings\n\n\n2003-10-26  Rudy Lippan  <rlippan@remotelinux.com> (2.9003)\n\t* Applied patch from Aaron and Chuck that added basic testing of the\n\t  table_info/column_info functions [Aaron Ross <aross@plusthree.com>]\n\t* Applied patch removing Jochen Wiedmann's contanct information and\n\t  also removing the restriction on CD ROM distribution.\n\t  [Jochen Wiedmen <joe@ispsoft.de>]\n\t* The check for the innodb table type was broken so the transaction\n\t  tests were skipped even though the database supported transactions.\n\t* :sql_types were not being inported in column info, so SQL_VARCAR was\n\t  thowing an error. Also, the :sql_types were not being pulled into\n\t  DBD::mysq::db package\n\t* Patch for  dbdadmin.t so that it respects username and password\n\t  [Alexey Stroganov <ranger@mysql.com>]\n\t* Fix for memory leak in bind_param() introduced in 2.9002\n\t  (2.9002 changed bind_param so that changing the value of a scalar\n\t  after binding would not affect what was passed to execute eg:\n\t     $sth->bind_param(1,$foo);\n\t     $foo = 'bar'\n\t     $sth->execute() -- $foo would contain 'bar')\n\t  [reported by <shildreth@emsphone.com>]\n\t* don't define dbd_discon_all so that mysql uses DBI's This fixes a\n\t  bug whereby DBD::mysql was dropping perl's destruct level.\n\t* patch to myld so that it uses strict and fixes scoping problem\n\t  with $contents [Jochen Wiedmann <joe@ispsoft.de>]\n\t* Modified Makefile.PL so that it gives a usage message\n\t  if any unknown options are passed in.\n\t* patch to INSTALL.pod on how to link DBD::mysql against\n\t  a static libmysqlclient [Jochen Wiedmann <joe@ispsoft.de>]\n\n2003-06-22  Rudy Lippan  <rlippan@remotelinux.com> (2.9002)\n\t* moved pod into mysql.pm from mysql.pod\n\t* Changed the default behaviour of mysql_found_rows, so now\n\t  'UPDATE table set field=?' will return the number of rows matched\n\t  and not the number of rows physically changed. You can get the old\n\t  behaviour back by adding \"mysql_found_rows=0\" to the dsn passed\n\t  to connect.\n\t* Updated type_info_all() to be more inline with\n\t  what DBD::ODBC returns.\n\t* Added attribute 'mysql_auto_reconnect' that allows the auto reconnect\n\t  behaviour to be toggled. :\n\n\t  ** NOTE** The behaviour of auto reconnect has changed.  If\n\t  either the MOD_PERL or the GATEWAY_INTERFACE environment variable is\n\t  set, auto_reconnect will default to ON; otherwise auto_reconnect\n\t  will default to off.  Earlier versions of this driver would always\n\t  try to reconnect to the database on error; however, this is dangerous\n\t  because table locks could be lost without the application knowing.\n\n\t* Fixed a segfault with failed reconnects that were trapped in an\n\t  eval. The next tine DBD::mysql tried to reconnect, the process\n\t  would segfault.\n\t* Added statistics attribute, 'mysql_dbd_stats' which returns\n\t  a hash ref that contains 2 keys 'auto_reconnects_ok' and\n\t  'auto_reconnects_failed'.\n\t* Fixed bug where strings that were used in numeric\n\t  context were not getting quoted on execute(). Now all\n\t  parameters are bound as varchar by default.\n\n\t  **NOTE** this is a change in behaviour that MAY cause problems\n\t  with some SQL statements. If quoted integers, for example,\n\t  cause any problems, use bind_param(<column_id>, undef, SQL_INTEGER)\n\t  to force a column to be bound as an integer.\n\n\t* Added get_info() method. See 'perldoc DBI' for more info\n\t* Added column_info(). See 'perldoc DBI' for more info [Tim Bunce]\n\n2003-03-03  Jochen Wiedmann  <joe@ispsoft.de> (2.1026)\n\n\t* Fixed the handling of case insensitive file\n\t  names. Jan Dubois, <jand@ActiveState.com>\n\t* lib/Mysql.pm (listdbs): Added support for user\n\t  name and password.\n\n2003-01-21  Jochen Wiedmann <joe@ispsoft.de> (2.1025)\n\n        * lib/DBD/mysql.pm: added support for optional\n          DBI->data_sources() \\%attributes parameter.\n          Georg Rehfeld, <georg.rehfeld@gmx.de>\n        * lib/DBD/mysql.pod: documented optional\n          DBI->data_sources() \\%attributes parameter.\n          Georg Rehfeld, <georg.rehfeld@gmx.de>\n        * t/dbdadmin.t: changed to use optional\n          DBI->data_sources() \\%attributes parameter.\n          Georg Rehfeld, <georg.rehfeld@gmx.de>\n\n2003-01-20  Jochen Wiedmann <joe@ispsoft.de> (2.1024)\n\n\t* dbdimp.c: Fixed missing support for double quotes\n\t  in ParseParam. JUERD@cpan.org\n\t* Test suite: Multiple patches for Windows/CygWin (case\n\t  insensitive file names and the like). Georg Rehfeld,\n\t  <georg.rehfeld@gmx.de>\n\t* lib/DBD/mysql/INSTALL.pod: Added description on how\n\t  to install with Windows/CygWin. Georg Rehfeld,\n\t  <georg.rehfeld@gmx.de>\n\n2003-01-18  Jochen Wiedmann  <joe@ispsoft.de> (2.1023)\n\n\t* Remove compiler warnings\n\t  Fix some small issues to get it to work with MySQL 4.1\n\t  (Mostly checking return values from MySQL API functions)\n\t  Michael Widenius  <monty@mysql.com> (2.1022a)\n\n\n2003-01-03  Jochen Wiedmann  <joe@ispsoft.de> (2.1022)\n\n\t* Added hints to Randy Kobes PPM repository, because\n\t  DBD::mysql is currently missing in ActiveState's\n\t  repository.\n\n2002-11-18  Jochen Wiedmann  <joe@ispsoft.de> (2.1021)\n\n\t* lib/Mysql.pm (errno): Added handling for non-ref\n\t  arguments. Raphael Hertzog <rhertzog@hrnet.fr>\n\n2002-09-23  Jochen Wiedmann  <joe@ispsoft.de> (2.1020)\n\n\t* Added mysql_local_infile option. (Paul DuBois,\n\t  paul@snake.net)\n\n2002-09-16  Jochen Wiedmann  <joe@ispsoft.de> (2.1019)\n\n\t* Added hints to installing DBD::mysql with PPM 3.\n\t  (Stefan Prehn, stefanprehngmx.de)\n\t* Added $DBD::mysql::CLONE\n\n2002-08-12  Jochen Wiedmann  <joe@ispsoft.de> (0.2018)\n\n\t* t/dbdadmin.t: The call to func('createdb') was\n\t  missing user name and password. Wolfgang Friebel\n\t  <friebel@ifh.de>\n\t* mysql.xs: If the connect in func('...', 'admin')\n\t  failed, a core dump was triggered. Wolfgang\n\t  Friebel <friebelqifh.de>\n\n2002-05-02  Jochen Wiedmann  <joe@ispsoft.de> (0.2017)\n\n\t* dbdimp.c: Added a required check for mysql_errno.\n\t  Steve Hay <Steve.Hay@uk.radan.com>\n\n2002-05-01  Jochen Wiedmann  <joe@ispsoft.de> (0.2016)\n\n\t* dbdimp.c: Removed use of mysql_eof. Jay\n\t  Lawrence <jay@lawrence.net>\n\n2002-04-30  Jochen Wiedmann  <joe@ispsoft.de> (0.2015)\n\n\t* Makefile.PL: Removed dbimon and pmysql from\n\t  the EXE_FILES list. Andreas Koenig\n\t  <andreas.koenig@anima.de>\n\n2002-04-17  Jochen Wiedmann  <joe@ispsoft.de> (2.1014)\n\n\t* dbdimp.c: Fixed mysql_is_auto_increment.\n\t  Paul Walmsley <shag-dbdmysql@booyaka.com> and\n\t  Paul Dubois <paul@kitebird.org>\n\n2002-04-12  Jochen Wiedmann  <joe@ispsoft.de> (2.1013)\n\n\t* dbdimp.c: Added use of mysql_ssl_set.\n\t  Chris Hanes <chanes@i-c.net>\n\n2002-04-12  Jochen Wiedmann  <joe@ispsoft.de> (2.1012)\n\n\t* Some fixes in the docs. Paul Dubois <paul@kitebird.com>\n\t* Added mysql_is_auto_increment. (Someone else, but forgot\n\t  his email, sorry!)\n\n2002-02-12  Jochen Wiedmann  <joe@ispsoft.de> (2.1011)\n\n        * Makefile.PL: DBI::DBD is no longer loaded by\n          default, to allow CPAN's requirements detection\n          note and install a missing DBI.\n\n2001-12-28  Jochen Wiedmann  <joe@ispsoft.de> (2.1010)\n\n\t* Bumped version number in Mysql/Statement.pm to\n\t  1.24, so that it is always higher than that\n\t  from the Msql-Mysql-modules.\n\n\n2001-12-28  Jochen Wiedmann  <joe@ispsoft.de> (2.1008)\n\n\t* lib/DBD/mysql.pod: Fixed minor bug in an example.\n\n2001-12-27  Jochen Wiedmann  <joe@ispsoft.de> (2.1007)\n\n\t* Bumped version number in Mysql.pm to 1.24, so that\n\t  it is always higher than that from the Msql-Mysql-\n\t  modules.\n\n2001-12-27  Jochen Wiedmann  <joe@ispsoft.de> (2.1006)\n\n\t* Within AutoCommit mode, reconnect is now turned\n\t  off, because the transaction state is unpredictable\n\t  otherwise.\n\n2001-12-13  Jochen Wiedmann  <joe@ispsoft.de> (2.1005)\n\n\t* dbdimp.c: Added use of SvMAGICAL to dbd_db_quote.\n\t  Rudy Lippan <almighty@randomc.com>\n\n2001-11-13  Jochen Wiedmann  <joe@ispsoft.de> (2.1004)\n\n\t* Makefile.PL: Fixed handling of --testdb, --testuser, ...\n\n2001-11-05  Jochen Wiedmann  <joe@ispsoft.de> (2.1003)\n\n\t* bind_param now using mysql_real_escape_string\n\t  as well. Dave Rolsky <autarch@urth.org>\n\n2001-11-04  Jochen Wiedmann  <joe@ispsoft.de> (2.1002)\n\n\t* Added mysql_ssl flag to DBI->connect.\n\n2001-11-04  Jochen Wiedmann  <joe@ispsoft.de> (2.1001)\n\n\t* Quoting now based on mysql_real_escape_string. Thanks\n\t  to Dave Rolsky <autarch@urth.org> for suggesting this.\n\n2001-11-02  Jochen Wiedmann  <joe@ispsoft.de> (2.1000)\n\n\t* Portability changes for MySQL 4.\n\n2001-05-25  Jochen Wiedmann  <joe@ispsoft.de> (2.0901)\n\n\t* dbdimp.c: Fixed $dbh->{mysql_insertid}; added t/insertid.t\n\n2001-04-01  Jochen Wiedmann  <joe@ispsoft.de> (2.0900)\n\n\t* Added transaction support for MySQL.\n\t  (Bob Lyons <lyons@nextrials.com>)\n\t* dbd/dbdimp.c: Fixed MAXLENGTH warning; used to hint for\n\t  a not existing mysql_maxlength, which should read\n\t  mysql_max_length. (Paul DuBois <paul@snake.net>)\n\t* Fixed installation problem when a directory was specified,\n\t  but did not exist. (Will Partain <partain@dcs.gla.ac.uk>)\n\t* Fixed that mysql_errno wasn't used properly. (Chris Adams\n\t  <cmadams@hiwaay.net>)\n\t* Fixed test suite problem, when user name and password\n\t  have been interpolated. (Bruno Hivert (LMC)\n\t  <lmcbrhi@lmc.ericsson.se>)\n\t* mysql_insertid and mysql_affectedrows are no longer treated\n\t  as integers, but longs. Thanks to Michael G Schwern\n\t  <schwern@pobox.com>.\n\n2000-08-20  Jochen Wiedmann  <joe@ispsoft.de> (1.2215)\n\n\t* lib/DBD/mysql/Install.pm (Initialize): Adding -lz -lgz by\n\t  default now.\n\t* dbd/dbd.pm.in: Minor doc change.\n\n2000-05-10  Jochen Wiedmann  <joe@ispsoft.de> (1.2214)\n\n\t* dbd/dbdimp.c: Fixed bug that timestamp fields weren't quoted.\n\t  Chris Winters <cwinters@intes.net>\n\n2000-04-26  Jochen Wiedmann  <joe@ispsoft.de> (1.2213)\n\n\t* dbd/dbimon.in: Fixed tags in pod.\n\n2000-04-15  Jochen Wiedmann  <joe@ispsoft.de> (1.2212)\n\n\t* Makefile.PL: Fixed use of builder-provided passwords.\n\t  Buck Huppmann <buckh@pobox.com>\n\t* Makefile.PL: Fixed WIN32 installation.\n\n2000-04-03  Jochen Wiedmann  <joe@ispsoft.de> (1.2211)\n\n\t* Fixed $dbh->{Name} (David Jacobs <djacobs@mitre.org>)\n\n1999-11-30  Jochen Wiedmann  <joe@ispsoft.de> (1.2210)\n\n\t* Makefile.PL (SelectDrivers): Hopefully ensured that a README is\n\t  always created successfully.\n\t* Makefile.PL: Fixed docs of --mysql-install etc. (loic@ceic.com)\n\n1999-10-13  Jochen Wiedmann  <joe@ispsoft.de> (1.2209)\n\n\t* Fixed bug in $dbh->tables(): Didnt't work with\n\t  empty databases.\n\n1999-09-17  Jochen Wiedmann  <joe@ispsoft.de> (1.2208)\n\n\t* dbd/bindparam.h: Added support for MySQL's double\n\t  quotes. (Although I don't like it. :-)\n\t* dbd/dbd.pm.in: Fixed a lot of docs for deprecated\n\t  features in favour of current.\n\t* Makefile.PL: Fixed use of -e (should be exists).\n\t  tschulth@debis.com (Thomas Schultheis)\n\t* MONEY seems to be a numeric type with mSQL.\n\t  Ernst Paalvast <ernst@esdmm.nl>\n\n1999-09-15  Jochen Wiedmann  <joe@gate.ispsoft.de> (1.2207)\n\n\t* dbd/dbdimp.c: Added mysql_connect_timeout.\n         Matthias Urlichs (<smurf@noris.de>)\n\n1999-08-29  Jochen Wiedmann  <joe@ispsoft.de> (1.2206)\n\n\t* dbd/dbimon.in: Fixed a bug in tab completion. (FieldList was\n\t  used in scalar context). Thanks to \"Scott R. Every\" <scott@emji.net>\n\t* lib/DBD/mysql/Install.pm (Initialize): Now checking for MySQL\n\t  version 3.22 or later.\n\n1999-08-22  Jochen Wiedmann  <joe@ispsoft.de>\n\n\t* lib/DBD/mysql/Install.pm (Initialize): Added sco\\d+* to the list\n\t  of SCO-like operating systems. Thanks to Jukka Inkeri\n\t  <Jukka.Inkeri@netstar.fi>\n\n1999-08-22  Jochen Wiedmann  <joe@ispsoft.de> (1.2203)\n\n\t* dbd/dbd.xs.in: Fixed a memory leak in $dbh->quote().\n\t  Arun Bhalla <abhalla@usgs.gov>\n\n1999-07-22  Jochen Wiedmann  <joe@ispsoft.de> (1.2202)\n\n\t* dbd/dbd.pm.in: The hint for experimental software is now\n\t  enabled or disabled automatically, thanks to ExtUtils::PerlPP.\n\t* dbd/dbdimp.c: Changed fprintf to PerlIO_printf, required by\n\t  DBI 1.14.\n\t* nodbd/nodbd.pm.in (quote): Changed ~DBD_DRIVER~ to\n\t  ~~dbd_driver~~, thanks to Maurice Aubrey <maurice@hevanet.com>.\n\n1999-07-08  Jochen Wiedmann  <joe@ispsoft.de> (1.2201)\n\n\t* lib/DBD/mSQL/Install.pm (Initialize): Fixed an ugly bug, that\n\t  caused unusable Config.pm files.\n\n1999-03-09  Jochen Wiedmann  <joe@ispsoft.de>\n\n\t* lib/DBD/mysql/Install.pm (CheckForLibGcc): No longer linking\n\t  against libgcc.a with OpenBSD.\n\t* nodbd/nodbd.pm.in (selectdb): Calling selectdb twice triggered\n\t  a warning. (Nick Hibma <nick.hibma@jrc.it>)\n\t* dbd/dbdimp.c: Date and time types now have literal_prefix and\n\t  suffix set to \"'\".\n\n1999-01-25  Jochen Wiedmann  <joe@ispsoft.de> (1.21_15)\n\n\t* dbd/myMsql.h: mSQL 2.0.6 requires including common/\n\t  portability.h.\n\t* dbd/dbdimp.c: Fixed some instances of ~var~ to ~~var~~.\n\t* Makefile.PL: Added PREREQ_PM to WriteMakefile options.\n\t* Renamed Bundle::M(y)sql to Bundle::DBD::mysql and\n\t  Bundle::DBD::mSQL.\n\n1999-01-05  Jochen Wiedmann  <joe@ispsoft.de> (1.21_13)\n\n\t* nodbd/nodbd.pm.in (query): Now setting $db_errstr\n\t  (Andreas K\u00f6nig, andreas.koenig@anima.de).\n\t* dbd/dbdimp.c (dbd_db_quote): Giving up to use \"NULL\" as a\n\t  static string. :-( My thanks to David Foo (dfoo@web.fairfax.com.au)\n\t  and Christian Schwarz (schwarz@monet.m.isar.de) for convincing\n\t  me.\n\t* nodbd/nodbd.pm.in (listdbs): Now setting $db_errstr.\n\n1998-12-30  Jochen Wiedmann  <joe@ispsoft.de> (1.21_12)\n\n\t* dbd/dbd.pm.in (prepare): Fixed missing attribs argument.\n\t  Thanks to Peter Ludemann (ludemann@inxight.com).\n\t* dbd/dbdimp.c: Portability fixes for Perl 5.005_54.\n\n1998-12-29  Jochen Wiedmann  <joe@ispsoft.de> (1.21_11)\n\n\t* Makefile.PL: .pm files are no longer removed, because\n\t  they are missing in MANIFEST otherwise.\n\n1998-12-22  Jochen Wiedmann  <joe@ispsoft.de> (1.21_09)\n\n\t* INSTALL: Updated the WIN32 INSTALLATION section.\n\t* nodbd/statement.pm.in (fetchrow): Enhanced compatibility to\n\t  previous Msql versions by returning the first column now in\n\t  scalar context. (Andreas K\u00f6nig, andreas.koenig@anima.de)\n\t* Makefile.PL (Init): Default of installing Msql, Mysql and Msql1\n\t  is now \"no\", unless you already have the Mysql emulation layer\n\t  installed.\n\t* Makefile.PL: Added --config option.\n\n1998-11-20  Jochen Wiedmann  <joe@ispsoft.de> (1.21_08)\n\n\t* lib/DBD/mysql/Install.pm (Initialize): Added -lc on Unixware;\n\t  thanks to Orion Poplawski <orion@bvt.com>.\n\t* lib/DBD/mysql/Install.pm (Initialize): Added -lzlib on Win32.\n\t* dbd/dbd.pm.in (connect): Added $dbh->{'Name'}.\n\t* t/dbdadmin.t: Forgot to change _DropDB to func(\"dropdb\",\n\t  ..., \"admin). My thanks to schinder@pobox.com.\n\t* Some patches for compatibility with ActiveState Perl.\n\n1998-11-08  Jochen Wiedmann  <joe@ispsoft.de> (1.21_07)\n\n\t* _ListTables is now obsolete.\n\t* _InsertID, affected_rows, IS_PRI_KEY, is_pri_key, IS_NOT_NULL,\n\t  is_not_null, IS_KEY, is_key, IS_BLOB, is_blob, IS_NUM, is_num,\n\t  LENGTH, length, MAXLENGTH, maxlength, NUMROWS, NUMFIELDS,\n\t  RESULT, result, TABLE, table, format_max_size, format_default_size\n\t  and format_type_name are now deprecated.\n\t* _CreateDB, _DropDB, _ListFields, _ListSelectedFields and\n\t  _NumRows have been removed.\n\t* dbd/dbd.xs.in: $dbh->func('_ListDBs') was closing the socket.\n\t  Thanks to Lars Kellogg-Stedman <lars@wolery.bu.edu>.\n\t* dbd/dbd.pm.in: $drh->func('_ListDBs' was documented wrong.\n\t  Thanks to Lars Kellogg-Stedman <lars@wolery.bu.edu>.\n\n1998-11-06  Jochen Wiedmann  <joe@ispsoft.de> (1.21_06)\n\n\t* dbd/dbdimp.c: Changed isspace(c) to c == ' ' in ChopBlanks\n\t  handling.\n\t* dbd/dbdimp.c: Added $dbh->{'mysql_read_default_file'} and\n\t  $dbh->{'mysql_read_default_group'}.\n\t* dbd/dbdimp.c: Added $dbh->{'mysql_insertid'}.\n\n1998-10-23  Jochen Wiedmann  <joe@ispsoft.de> (1.21_05)\n\n\t* dbd/dbd.xs.in: Fixed bug in $dbh->quote($n, SQL_INTEGER).\n\t* Makefile.PL (CheckForLibGcc()): Disabled linking against\n\t  libgcc.a under NetBSD. (Curt Sampson, cjs@portal.com)\n\t* Forgot to remove the warning for experimental software.\n\t* Added Monty's patches for use of mysqlclients.\n\t* dbd/dbdimp.c: Added msql_configfile.\n\t* Makefile.PL: Added option -static.\n\n1998-10-06  Jochen Wiedmann  <joe@ispsoft.de> (1.21_04)\n\n\t* INSTALL: Added hints for Win32 installation.\n\t* lib/DBD/mysql/Install.pm: Added portability fixes for Win32\n\t  installation with MyODBC. This is now the recommended way of\n\t  installing DBD::mysql under Win32.\n\n1998-09-27  Jochen Wiedmann  <joe@ispsoft.de> (1.21_02)\n\n\t* INSTALL: Added a hint for Remote_Access in msql.conf\n\t* nodbd/nodbd.pm.in (quote): Made quote a class method; Andreas\n\t  K\u00f6nig <koenig@anna.mind.de>.\n\t* dbd/myMsql.h (MyReconnect): Fixed $dbh->ping() for MySQL.\n\t  My thanks to Nikki Chumakov (nikki@paranoia.ru).\n\t* dbd/dbimon.in: Added dump mode.\n\t* dbd/dbimon.in: TableList now based on $dbh->tables(), thus\n\t  portable.\n\t* dbd/dbimon.in: Shell completion with TableList case independent.\n\t* tests/60leaks.t: No longer calling exit() within BEGIN.\n\t  (Workaround for a bug within Perl 5.00404)\n\t* tests/ak-dbd.t: Removed \"local $sth->{PrintError} = 0\"; yet\n\t  another workaround.\n\n1998-07-28  Jochen Wiedmann  <joe@ispsoft.de> (1.21_00)\n\n\t* INSTALL: Added a description of the missing-libgcc problem.\n\t* INSTALL: Added a patch for the mSQL problem with ORDER BY.\n\t* dbd/dbd.pm.in: Added a description of mSQL's problem with\n\t  ORDER BY.\n\t* Fixed pointers to DBI home (was www.hermetica.com, now\n\t  www.arcana.co.uk)\n\t* lib/DBD/mysql/Install.pm (Initialize): Added\n\t  $ENV{'MYSQL_HEADERDIR'} and $ENV{'MYSQL_LIBDIR'}.\n\t* dbd/dbdimp.c: mysql_fetch_lengths() returns longs under\n\t  MySQL 3.22.04\n\t* nodbd/nodbd.pm.in (errno): Fixed missing definition of\n\t  $self.\n\t* Makefile.PL (InitializeMysql): Looking for libmysqlclient.a\n\t  and libmysqlclient.so now.\n\t* dbd/dbdimp.c (dbd_st_internal_execute): Fixed memory leak,\n\t  *cdaPtr was not checked for <> NULL. My thanks to Marc\n\t  Lehmann <pcg@goof.com> for the report.\n\t* dbd/dbd.pm.in: Added table_info().\n\n1998-07-16  Jochen Wiedmann  <joe@ispsoft.de> (1.19_22)\n\n\t* dbd/dbdimp.c: Added dTHR to some more functions for 5.005\n\t  compatibility. Thanks to Chris Leach\n\t  <leachcj@vegemite.mel.az.bp.com>.\n\t* nodbd/statement.pm.in: Changed length to CORE::length in\n\t  some cases to prevent 5.005 warnings.\n\t* Added a section on multithrading to the manual.\n\n1998-07-07  Jochen Wiedmann  <joe@ispsoft.de> (1.19_21)\n\n\t* nodbd/nodbd.pm.in (query): Fixed a missing \"bless($sth, ...)\".\n\t  My thanks to Ray Zimmermann <rz10@cornell.edu>. (Gives me\n\t  a familiar feeling to always meet the same people ... :-)\n\n1998-07-06  Jochen Wiedmann  <joe@ispsoft.de> (1.19_20)\n\n\t* Makefile.lib (InitializeMsql): Added /usr to the search path\n\t  for mSQL headers and libraries.\n\t* tests/msql1.t (unctrl): Renamed \"character\" column to\n\t  \"chrctr\". (\"character\" is not a valid column name under\n\t  msql-2.0.4.1)\n\t* dbd/dbd.xs.in (DBD::mysql::ping): Now using mysql_ping().\n\t* dbd/dbdimp.c (_MyLogin): Added mysql_compression.\n\n1998-06-25  Jochen Wiedmann  <joe@ispsoft.de> (1.19_19)\n\n\t* dbd/dbdimp.c: Added $sth->{mysql_type} and\n\t  $sth->{msql_type}, which are in fact just what\n          $sth->{TYPE} used to be. $sth->{TYPE} is now\n\t  returning portable SQL types.\n\t* MANIFEST: Removed nodbd/Makefile.PL.in.\n\t* Makefile.PL: Made test databases configurable.\n\n\n1998-06-14  Jochen Wiedmann  <joe@ispsoft.de> (1.19_18)\n\n\t* Makefile.PL: dbdadmin.t was missing in the list of tests\n\t* nodbd/nodbd.pm.in (query): Now really returning undef in\n\t  case of errors. (Possible Perl bug?)\n\t* Makefile.PL: Fixed realclean attribute of WriteMakefile.\n\t* Makefile.PL (Init): Setting $Data::Dumper::Indent to 1.\n\t* Makefile.PL (InitializeMsql): Fixed query for mSQL, if\n\t  only one version gets installed.\n\t* dbd/dbdimp.c: Now calling mysql_init before mysql_connect.\n\t* dbd/dbdimp.c: For whatever reason, MyGetProtoInfo was\n\t  treated like returning a char* under Mysql.\n\n\n1998-05-16  Jochen Wiedmann  <joe@ispsoft.de> (1.19_17)\n\n\t* Makefile.PL: Fixed typo in InitializeMsql (dbiDriver = mSQL1).\n\t* dbd/dbdimp.c: mysql_real_connect is now using a dbname\n\t  argument\n\n\n1998-05-07  Jochen Wiedmann  <joe@ispsoft.de> (1.19_16)\n\n\t* dbd/dbdimp.c: ChopBlanks no longer chops from the left side.\n\t* dbd/dbdimp.c: Fixed memory leak in dbd_st_FETCH_internal.\n\n\n1998-04-13  Jochen Wiedmann  <joe@ispsoft.de> (1.19_15)\n\n\t* Added the DBD::mSQL1 and Msql1 drivers.\n\t* Fixed minor icompatibilities with perl 5.005.\n\t* nodbd/nodbd.pm.in (errmsg): Msql->errmsg() should\n\t  now recognize error messages in $DBI::errstr (hopefully ...)\n\n\n1998-04-03  Jochen Wiedmann  <joe@ispsoft.de> (1.19_13)\n\n\t* dbd/dbdimp.c: msqlGetProtoInfo returns an int, not a\n\t  char* (Erik Bertelsen, erik@mediator.uni-c.dk)\n\t* dbd/dbdimp.c: Fixed typo in _MyLogin: User was set to\n\t  NULL when password had zero length. (Erik Bertelsen,\n\t  erik@mediator.uni-c.dk)\n\t* dbd/dbdimp.c: One more time fixing reconnect problems with Mysql\n\t  and old client libraries (without mysql_real_connect it's just too\n\t  ugly! :-(\n\n\n1998-03-15  Jochen Wiedmann  <joe@ispsoft.de> (1.19_11)\n\n\t* Makefile.PL: Fixed Bugs in _OdbcParse and version numbers.\n\t* dbd/dbimon.in: Fixed bugs in export mode (Nem W. Schlecht\n\t  <nem@abattoir.cc.ndsu.nodak.edu>)\n\n\n1998-02-26  Jochen Wiedmann  <joe@ispsoft.de> (1.19_10)\n\n\t* M(y)sqlPerl now emulated by DBI drivers.\n\t* dbd/dbdimp.c: Added $dbh->{'info'} and $dbh->{'thread_id'}\n \t  (mysql only)\n\t* dbd/dbimon.in: Fixed minor bug in \"rel db test\"\n\t* dbd/dbimon.in (Connect): Added noecho mode for entering\n\t  passwords.\n\t* dbd/myMsql.c: Fixed bugs in OdbcParse.\n\n1998-02-06  Jochen Wiedmann  <joe@ispsoft.de> (1.19_03)\n\n\t* dbd/dbd.xs.in: Fixed $dbh->quote(undef) to return \"NULL\"\n\t  and not 'undef'.\n\t* Requires DBI 0.93. (I assume it still works with 0.91, but\n\t  whoever reinstalls Msql-Mysql-modules can well reinstall\n\t  DBI.)\n\t* dbd/dbdimp.c: $sth->fetch* now inactivates the sth in case\n\t  of errors or no more data; this follows the specification of\n\t  the 'Active' attribute.\n\t* Added a missing DROP TABLE in ak-dbd.t.\n\t* Added ODBC style DSN's like DBI:mysql:database=test;host=localhost.\n\n1998-01-20  Jochen Wiedmann  <joe@ispsoft.de> (1.19_02)\n\n\t* dbd/dbd.xs.in (quote): Fixed \"int len\" to \"STRLEN len\"; the\n\t  Irix compiler refuses to compile this. (A little bit picky,\n\t  a warning would really be sufficient here ...) My thanks to\n\t  Simon Matthews <sam@peritas.com>.\n\t* Added \"LISTINDEX\" handling.\n\t* Makefile.lib: Now always linking against libgcc.a when using gcc\n\t  and compiling for MySQL.\n\t* tests/mysql.dbtest: Now using \"IS NULL\" in SQL queries instead\n\t  of \"= NULL\". (Required as of mysql 3.21.22)\n\n1998-01-18  Jochen Wiedmann  <joe@ispsoft.de> (1.19_01)\n\n\t* README: Added hint for not using msqlperl mailing lists\n\t  except for MsqlPerl and MysqlPerl related things.\n\t* Makefile.lib: Modified version number to contain underscores,\n\t  so that CPAN considers 1.18xx as the correct version.\n\t* dbd/dbimon.in: Leaving pager mode worked unreliable; fixed.\n\t  Andreas Koenig <koenig@anna.mind.de>\n\t* tests/akmisc.t, tests/mysql.t, tests/mysql2.t: Minor modifications\n\t  in the connect parameters for passing the test suite under\n\t  Windows/NT.\n\n1998-01-07  Jochen Wiedmann  <joe@ispsoft.de> (1.1900)\n\n\t* dbd/dbd.xs.in: Implemented $dbh->quote() in XS.\n\t* dbd/dbd.xs.in: Added '_Admin' function.\n\t* dbd/dbd.xs.in, dbd/dbdimp.c: Added automatic reconnect when\n\t  mysql returns CR_SERVER_GONE_ERROR.\n\t* Makefile.lib (InitializeMysql): Modified order of -I statements\n\t  (Inside MySQL distribution it can happen that headers of recently\n\t  installed DBI versions are used instead of the correct headers.)\n\t* nodbd/nodbd.xs.in, nodbd/typemap: Supressed warning for\n\t  undef'd argument in connect method. (Chris Holt,\n\t  <xris@migraine.stanford.edu>)\n\t* nodbd/nodbd.xs.in: Fixed definition of 'HOST' attribute\n\t  in dbh's.\n\t* Makefile.lib (InitializeMsql): Fixed typo that made MSQL_HOME\n\t  useless. (Ray Zimmermann, <rz10@cornell.edu>)\n\t* Makefile.lib (InitializeMysql): Fixed typo \"lib/mysqlclient.a\"\n\t  to \"lib/libmysqlclient.a\". (Michael 'Monty' Widenius,\n\t  <monty@tcx.se>)\n\n1997-12-31  Jochen Wiedmann  <joe@ispsoft.de> (1.1823)\n\n\t* Added support for mysql_use_result, requested by Jesse\n\t  Eversole <jee@marketdriven.com>.\n\t* nodbd/typemap: Replaced sv_isa with sv_derived_from so that\n\t  subclassing works, reported by Gisle Aas <gisle@aas.no>.\n\n1997-12-11  Jochen Wiedmann  <joe@ispsoft.de> (1.1822)\n\n\t* dbd/myMsql.c: DSN's like DBI:mysql:test;hostname=$host;port=$port\n\t  haven't been working.\n\t* dbd/dbimon.in: POD modifications, suggested by Jesse N. Glick\n\t  <jglick@sig.bsh.com>\n\t* INSTALL: Added hints for \"make test\".\n\t* nodbd/statement.pm.in (as_string): Still bugs in the new\n\t  as_string method, thanks to Frank D. Cringle <fdc@cliwe.ping.de>.\n\t* Enabled SQL_DATE, SQL_TIME, ... (available in DBI 0.91)\n\t* Makefiles: Modified postamble to use a common function which calls\n\t  module dependent hooks.\n\t* nodbd/nodbd.xs.in/fetchinternal: Fixed the problem RETVAL == NULL.\n\nWed Nov 19 19:50:29 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1821)\n\n\t* dbd/dbd.pm.in: Added AUTOLOAD for constants like\n\t  DBD::mysql::FIELD_TYPE_STRING or DBD::mSQL::CHAR_TYPE.\n\n\t* xtract, dbd/Makefile.PL.in nodbd/Makefile.PL.in: Removed\n\t  first line in case users perl is different from\n\t  /usr/local/bin/perl.\n\n\t* All Makefiles: Added chmod for xtracted files.\n\n\t* Added bindparam.h for reuse in DBD::pNET.\n\n\t* Makefile.lib: Some (hopefully) upward compatible modifications\n\t  for integration into the MySQL distribution.\n\nSat Nov  1 17:04:27 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1820)\n\n\t* xtract: Added \"#xtract <driver>\" ... \"#endxtract\".\n\n\t* nodbd/statement.pm.in, nodbd/nodbd.pm.in, nodbd/pmsql.in:\n\t  Using \"#xtract now\".\n\n\t* Reorganized source tree (again).\n\nWed Oct 29 00:41:41 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1819)\n\n\t* nodbd/bundle.pm.in: Fixed syntax error.\n\n\t* Fixed distribution problems. Not all .pm files have been\n\t  included. (Only PAUSE should have noticed.)\n\nMon Oct 27 00:50:08 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1818)\n\n\t* nodbd/Makefile.PL.in: Fixed dependencies for \"xtract\" files.\n\n\t* nodbd/nodbd.xs.in: Fixed ISNUM attribute in fetchinternal.\n\n\t* nodbd/statement.pm.in: Yet one more fix in the new as_string\n\t  method. :-(\n\n\t* nodbd/statement.pm.in: Msql::Statement::maxlength caches\n\t  its return value now\n\nSat Oct 25 16:30:01 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1817)\n\n\t* Makefile.PL,dbd/Makefile.PL.in,nodbd/Makefile.PL.in: Added\n\t  dependencies for files being created from dbd and nodbd\n\t  directories via the \"xtract\" script.\n\t* nodbd/pmsql.in,nodbd/statement.pm.in: Fixed minor problems with\n\t  mSQL1; suggested by Andreas Koenig\n\t* dbd/dbd.pm.in,tests/ak-dbd.t: Removed support and tests for the\n\t  old connect methods.\n\t* nodbd/statement.pm.in: Fixed bug in Msql::Statement::maxlength.\n\nFri Oct 24 01:29:08 1997  Jochen Wiedmann  <joe@ispsoft.de> (1.1816)\n\n\t* dbd/myMsql.c (MyConnect): Fixed use of mysql_real_connect\n\n\t* dbd/dbdimp.c: Added automatic type detection to bind_param\n\n\t* nodbd/statement.pm.in: Modified as_string for more efficiency\n\t  under MySQL. Added maxlength and isnum methods. (Direct attribute\n\t  fetches under MySQL, calculated under mSQL.)\n\n\t* nodbd/pmsql.pm.in: Fixed bug in creation of @typelabels:\n\t  defined &Msql::TEXT_TYPE doesn't work before autoloading it.\n\n1997-10-02  Jochen Wiedmann <joe@ispsoft.de> (1.1815)\n\n\t* dbd/dbd.xs: Fixed bug in insertid; &svsock was used instead\n\t  of svsock\n\n\t* Fixed bug in nodbd.xs (formerly Mysql.xs): key INSERTID had\n\t  length of 9 (reported by Maurice Aubrey, <maurice@hevanet.com>)\n\n\t* t/ak-dbd.t, t/akmisc.t: Added tests for mysql's insertid\n\t  feature.\n\n\t* Merged source trees of Mysql and Msql.\n\n\t* lib/M(y)sql.pm: Added some words on createdb, dropdb and\n\t  shutdown to the man page. Missed by Ray Zimmermann\n          (rz10@cornell.edu)\n\n\t* dbd/dbd.xs.in: Implemented $dbh->do as a direct XS call.\n\n\t* dbd/dbd.xs.in, nodbd/nodbd.xs.in: Suppressed some warnings\n\t  due to uninitialized RETVAL. George Hartlieb\n\t  (ghartlieb@mail.arc.nasa.gov)\n\n1997-09-29  Andreas Koenig <koenig@anna.mind.de> (1.1814)\n\n\t* t/50commit.t: Fixed printing of warning message when\n\t  commit issues a warning.\n\n\t* lib/DBD/mSQL.pm (connect): Fixed warning in connect, if\n\t  attrhash is present.\n\n\t* pmsql.PL: Fixed use of Msql 2 constants in @typelabel definition\n\t  and similar things.\n\n\t* lib/Msql/Statement.pm: Fixed use of Msql::TEXT_TYPE without\n\t  checking whether we are running Msql 1.\n\nDBD::mysql for DBI - Written by Jochen Wiedmann <joe@ispsoft.de>\n\n97.09.27 V1.1812\n          Added t/50commit.t to test suite.\n\t  Included <embed.h> in myMsql.h for redefining my_setenv().\n\t  Made AutoCommit, Commit and Rollback DBI conformant.\n\t  Fixed reconnect problems with Mysql: mysql_port was 0 on some\n\t  systems.\n\t  Added support of mysql_real_connect to myMsql.c.\n\t  Fixed Msql::errno returning a char*.\n\t  Added lib/Bundle::Mysql.pm.\n          Fixed 'use Mysql' to 'require Mysql' in t/mysql2.t.\n\n97.09.12 V1.1810\n\t  Fixed bug in dbd_st_FETCH_internal: newRV_noinc was used for\n\t  the return value. This resulted in invalid cache values,\n\t  reported by Michael Bletzinger\n\t  <Michael.Bletzinger@ssa.crane.navy.mil>\n\n97.09.12 V1.1809\n\t  Adapted changes from DBD-Oracle 0.46 to 0.47; in particular\n\t  the files Driver.xst and dbd_xsh.h from the DBI distribution\n\t  are used now. (LongReadLen, LongTruncOk, ... are still\n\t  meaningless, but they are not that important for m(y)sql:\n\t  The complete results are in RAM anyways ...)\n          Fixed man page of DBD::M(y)SQL: \"@names = $sth->{'NAME'}\".\n\t  Added parameter completion for \"set\" command to dbimon.\n\n97.09.08  V1.1808\n\t  Fixed bug in dbimon, a closing brace was missing causing a\n\t  syntax error.\n\t  Fixed problems in the Term::ReadLine::GNU support, reported\n\t  by Nem W. Schlecht (nem@abattoir.cc.ndsu.nodak.edu).\n\t  Modified dbimon for internally using the Data::ShowTable\n\t  module. My thanks to Tim Bunce for the hint.\n\t  Compatibility fixes for SunOS and Solaris, supplied by\n\t  Neil Bowers (neilb@cre.canon.co.uk).\n\n97.09.03  V1.1806\n          Fixed bug in Mysql.xs: $sth->numfields dumped core because no\n\t  check for a result was done.\n\t  Fixed bug in lib/Mysql/Statement.pm: Mysql::Statement.as_string\n\t  did not check for $sth->numfields != 0.\n\t  Added patch from Nem W. Schlecht (nem@abattoir.cc.ndsu.nodak.edu)\n\t  for Term::ReadLine::GNU support to pmysql and dbimon.\n\n97.09.03  V1.1805\n\t  Fixed bug in DBD::mysql: Executing a non-select statement\n\t  always returned -1 (unknown number of rows) although the\n\t  correct number was returned by $sth->rows().\n\t  Fixed bug in DBD::mysql: strlen was executed on a NULL\n\t  value when mysql_fetch_rows returned a NULL field.\n\t  Added all _ListField attributes to statement handles.\n\t  Added support for \"LISTFIELDS <table>\" to $sth->execute.\n\t  Modified $sth->func(\"_ListSelectedFields\") and\n\t  $dbh->func(\"<table>\", \"_ListFields\") to use the new\n\t  possibilities; in fact these are only stubs now.\n\t  Added dbimon.\n\t  Added some internal attributes for dbimon to DBD::mysql:\n\t  format_default_size, format_max_size, format_type_name\n\t  and format_right_justification.\n\n97.08.30  V1.1804\n\t  Added \"fancy\", \"quote\", \"separator\" and \"escape\" commands to\n\t  pm(y)sql.PL, patch supplied by Nem W Schlecht\n\t  (nem@abattoir.cc.ndsu.nodak.edu).\n\t  Modified pm(y)sql.PL and pmsql.PL so that it automatically\n\t  adapts pm(y)sql for use with Msql and Mysql, respectively.\n\t  Makefile.PL and M(y)sqlPerl/Makefile.PL now automatically\n\t  adapt lib/M(y)sql.pm, lib/M(y)sql/Statement.pm and\n\t  lib/DBD/mSQL.pm or lib/DBD/mysql.pm for use in Msql-modules\n\t  or Mysql-modules; just copy these files, rename them and\n\t  run \"perl Makefile.PL\".\n\n97.08.29  V1.1803\n\t  Added mysql_errno()\n\t  Modified perl modules for use of $driver and isa($driver).\n\t  Modified Msql.xs and Mysql.xs for use of Package and\n\t  StPackage.\n\t  Modified test for fetch of non-result sth in akmisc.t: Msql\n\t  returns number of rows and not an sth.\n\n97.08.27  Removed use of TEXT_TYPE from pmysql and Mysql/Statement.pm.\n\n97.08.16  Modified mysql.xs, dbdimp.h and dbdimp.c for use in DBD::mSQL.\n\t  Now using Andreas K\u00f6nig\u00b4s Makefile.PL from the DBD::mSQL\n\t  distribution.\n\t  Added check for disabled '-lgcc' on Linux; this leads to a\n\t  missing __moddi3 symbol in libmysqlclient.a, when running\n\t  mysql.so.\n\n\t  Added mysqlperl support.\n\n97.08.02  Almost completely rewritten, with the exception of private\n          functions like _ListTables.\n          Implemented bind_param.\n          Test suite rewritten for portability.\n          Many sources moved from mysql.pm and mysql.xs to dbdimp.h;\n          mysql.pm and mysql.xs are now close to Oracle.xs and Oracle.pm.\n\n97.07.28  Added $dbh->quote method.\n\t  Modified internal use of \"char* statement\" to \"SV* statement\".\n\t  Modified use of mysql_query to mysql_real_query. (The above\n\t  three things should fix blob problems hopefully.)\n\t  Bumped revision number to 2.00 because of API changes:\n\t  The connect method works now as described in the DBI man\n\t  page, compatibility to DBD::msql seems deprecated.\n\t  Heavy internal modifications in order to use DBIS->get_fbav();\n\t  this gives compatibility to DBI 0.88.\n\t  Modified test suite to use Test::Harness.\n\t  Added blob tests.\n\nDBD::mysql for DBI - Written by Alligator Descartes <descarte@mcqueen.com>\n\n96.06.22  Get new patched version 1.65 from gnat@frii.com\n\t  Added the memory bug patch to this.\n\n96.06.18  Added pod documentation to mysql.pm and the possibility\n\t  to retreive insert_id. This was done by Nathan Torkington.\n\n\t  Fixed memory bug that sql results never was freed.\n\t  Now a result is freed when one calls the 'finish' action.\n\t  The patch was done by gareth@netcom.co.uk & Monty\n\n96.05.27  Changed Makefile.PL after suggestions from Raymond Wiker\n\n96.04.25  Changed the README and fixed a typo in mysql.xs\n\t  Changed version to DBD-mysql-1.63.1 to have a reference to mSQL-0.63\n\n96.04.19  Updated with differences from DBD:mSQL-0.63\n\n\n96.11.03  Changed from DBD:mysql-0.60pl10 to DBD:mysql-1.0 by Michael Widenius\n\n\nOriginal ChangeLog:\n\n18/07/95:\tStarted.\n\n\t\tVersion 0.0.0 ( Totally pre-alpha! )\n\n19/07/95:22:00\tCode now basically seems to work. I've got connection to\n\t\ta database, and clean disconnection.\n\n\t 23:45\tI'm now working on the statement cycle stuff, which I've\n\t\tmapped out. It's just a case of coding, which shouldn't\n\t\ttake too long, hopefully.\n\n\t\tPosted notice of approaching doom to perldb-interest.\n\n20/07/95:01:25\tFetching appears to work OK now. I need to read the API on\n\t\tmsqlFieldSeek, since I can't work out why fetch is returning\n\t\tthe same row over and over!\n\n21/07/95:09:22  Added a field into imp_sth (currow) which keeps track of the\n                current row that's been fetched from the result struct. If I\n                can fix the return codes coming from fetchrow, it'll work!\n\n21/07/95:10:30  Pondered bind variables in cursors. Since there isn't a bind\n                function in the API, I may have to frig the way that prepare/\n                execute works, ie, move the call to msqlQuery *after* it's\n                done some parsing for bind values......Hm.\n\n21/07/95:10:35  Twiddled some bits in the fetchrow cycle.\n\n23/07/95:15:50  Fetch is fetching a row, but it's not returning it to the\n        \tcalling cycle, so I need to fart about with the sv stuff, which\n\t\tis not amusing me greatly!\n\n26/07/95:23:42\tDecided in agreement with Andreas that the first release is\n\t\tto be 0.61!\n\n27/07/95:14:14\tFinally! It fucking works! After splendid quantities of\n      \t\thacking around with the prepare/execute/fetchrow/finish cycle\n\t\tit's actually returning rows correctly!\n\n\t\tNOTE: The SV handling within dbd_describe is shot to buggery,\n\t\t      but I've kludged it in mSQL.xs::fetchrow to do a\n\t\t      sv_2mortal instead of a sv_mortalcopy.\n\n27/07/95:14:22\tTidied up mSQL.xs::finish to do an msqlFreeResult. Annoyingly\n\t\tenough, there's no return code to msqlFR, so I can't test\n\t\twhether or not it's worked! Bah!\n\n27/07/95:15:15\tAltered test to do several bits and bobs. I'm testing INSERT\n\t\tstatements now. These only execute an msqlQuery, but the\n\t\tstuff needs to continue to pass through the execute and finish\n\t\tstages cleanly.......*sigh*\n\n27/07/95:15:22\tMy dubious 'INSERT' check hack works, sort of. Pity it converts\n\t\tthe entire statement to lower case.....!\n\n27/07/95:17:33\tTwiddled some more stuff so it seems to do CREATE TABLE,\n\t\tINSERT statements too. Of course, there's no error checking\n\t\tyet, but it seems to be OK........Hm.\n\n27/07/95:17:38\tMailed out a statement saying the 0.61 code would be up for\n\t\tgrabs as of Monday 31st July! Still waiting on Alpha reports.\n\n27/07/95:12:11\tFixed the lower-case all the INSERT/CREATE &c. statement bug.\n\t\tIt now checks to see if you're in quotes.\n\n28/07/95:xx:xx\tGot a report back from Andreas to say  compilation barfs on\n\t\this Indy. Fixed a load of do_error bugs in dbdimp.c.\n\n13/08/95:18:25  Finally got back to this after a rather long break. Fixed some\n\t\tMakefile.PL bugs that were kicking about. Finally fixed\n\t\t( or appeared to fix ) the strlen signedness bug in dbdimp.c\n\t\tthat may halt compilation on the Indy.\n\n\t\tEmailed Karsten the debug info to see what's causing problems\n\t\ton the NeXTStep platform.\n\n14/08/95:13:48\tGot email back from Andreas. signedness broke mSQL.xs as well!\n\t\tFixed that and emailed him a quick patch.\n\n14/08/95:14:45\tAndreas now has a successful compile. The tests are crap, but\n\t\tappear to ( sort of ) work.\n\n29/08/95:23:18\tConverted driver across to new DBI format. It now appears\n\t\tto compile, install and run fairly reasonably. There are\n\t\tsome serious messes that need cleared up in it, but it's\n\t\tfundamentally OK, I hope. Announced for pl0 testing.\n\n04/09/95:15:04\tStarted back on getting the 0.60pl0 out. Tidied up the parsing\n   \t\tof statements for INSERT, CREATE &c statements. It just takes\n\t\tthe first word of the statement now.\n\n04/09/95:15:19\tLooks OK. Tested against DBI 0.63 and looks reasonable.\n\t\tAnnounced release of 0.60pl1 and put up for ftp.\n\n20/09/95:15:20\tPatched a load of stuff including NULLs, and local device\n\t\thandling ( SV ). Released pl4, which was bogus. Released\n\t\tpl5 which should fix those issues.\n\n20/09/95:22:17\tFixed overhang of old DBI bug with DBIc_ENDING remaining in\n\t\tDESTROY in mSQL.xs. Spotted by Marti Rijken and fixed.\n\t\t( Hopefully! )\n\n18/10/95:15:13\tAdded in the missing API chunks for ListTables, ListDBs\n\t\tand ListFields.\n\n\t\tListFields isnae working, but I'll fix that sometime soon....\n\n05/11/95:11:32\tFixed $sth->readblob to return undef. Fixed Makefile.PL,\n\t\tdbdimp.h, mSQL.h, dbdimp.c for release of 0.60pl7. Also tested\n\t\t'make test' which now works!\n\n23/11/95:19:22\tFixed ListFields from the pointers given to me by Sven V.\n\n24/11/95:03:13\tFixed error handling in all the func methods\n\n24/11/95:13:01\tAdded 'NumRows' method to statement handles to return the\n\t\tnumber of rows returned ( or affected ) by a statement.o\n\n30/12/95:18:10\tAltered mSQL.pm to allow for hostname:port style connections\n\t\tto known remote port machines. Sets ENV var since the\n\t\tmsqlConnect API call doesn't support port arguments.\n\n30/12/95:18:15\tAdded 'length' key into the hash returned by ListFields, so\n\t\twe can get the scale of the field.\n\n24/03/96:22:34\tFixed bugs and upgraded versioning for perl5.002 to work\n\t\tproperly. Released as pl10\n\n-> Lamentable lack of ChangeLog information here!\n\n27/03/97: Tidied up things with regard to 0.61 release.\n\n28/03/97: Patched NULL as undef bug\n", "/*\n *  DBD::mysql - DBI driver for the mysql database\n *\n *  Copyright (c) 2004-2014 Patrick Galbraith\n *  Copyright (c) 2013-2014 Michiel Beijen \n *  Copyright (c) 2004-2007 Alexey Stroganov \n *  Copyright (c) 2003-2005  Rudolf Lippan\n *  Copyright (c) 1997-2003  Jochen Wiedmann\n *\n *  You may distribute this under the terms of either the GNU General Public\n *  License or the Artistic License, as specified in the Perl README file.\n */\n\n\n#ifdef WIN32\n#include \"windows.h\"\n#include \"winsock.h\"\n#endif\n\n#include \"dbdimp.h\"\n\n#if defined(WIN32)  &&  defined(WORD)\n#undef WORD\ntypedef short WORD;\n#endif\n\n#ifdef WIN32\n#define MIN min\n#else\n#ifndef MIN\n#define MIN(a, b)       ((a) < (b) ? (a) : (b))\n#endif\n#endif\n\n#if MYSQL_ASYNC\n#  include <poll.h>\n#  include <errno.h>\n#  define ASYNC_CHECK_RETURN(h, value)\\\n    if(imp_dbh->async_query_in_flight) {\\\n        do_error(h, 2000, \"Calling a synchronous function on an asynchronous handle\", \"HY000\");\\\n        return (value);\\\n    }\n#else\n#  define ASYNC_CHECK_RETURN(h, value)\n#endif\n\nstatic int parse_number(char *string, STRLEN len, char **end);\n\nDBISTATE_DECLARE;\n\ntypedef struct sql_type_info_s\n{\n    const char *type_name;\n    int data_type;\n    int column_size;\n    const char *literal_prefix;\n    const char *literal_suffix;\n    const char *create_params;\n    int nullable;\n    int case_sensitive;\n    int searchable;\n    int unsigned_attribute;\n    int fixed_prec_scale;\n    int auto_unique_value;\n    const char *local_type_name;\n    int minimum_scale;\n    int maximum_scale;\n    int num_prec_radix;\n    int sql_datatype;\n    int sql_datetime_sub;\n    int interval_precision;\n    int native_type;\n    int is_num;\n} sql_type_info_t;\n\n\n/*\n\n  This function manually counts the number of placeholders in an SQL statement,\n  used for emulated prepare statements < 4.1.3\n\n*/\nstatic int\ncount_params(imp_xxh_t *imp_xxh, pTHX_ char *statement, bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char* ptr= statement;\n  int num_params= 0;\n  int comment_length= 0;\n  char c;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">count_params statement %s\\n\", statement);\n\n  while ( (c = *ptr++) )\n  {\n    switch (c) {\n      /* so, this is a -- comment, so let's burn up characters */\n    case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              /* let's see if the next one is a dash */\n              c = *ptr++;\n\n              if  (c == '-') {\n                  /* if two dashes, ignore everything until newline */\n                  while ((c = *ptr))\n                  {\n                      if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n                          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\\n\", c);\n                      ptr++;\n                      comment_length++;\n                      if (c == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /*\n                    if not comment_end, the comment never ended and we need to iterate\n                    back to the beginning of where we started and let the database \n                    handle whatever is in the statement\n                */\n                  if (! comment_end)\n                      ptr-= comment_length;\n              }\n              /* otherwise, only one dash/hyphen, backtrack by one */\n              else\n                  ptr--;\n              break;\n          }\n      }\n    /* c-type comments */\n    case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              c = *ptr++;\n              break;\n          }\n          else\n          {\n              c = *ptr++;\n              /* let's check if the next one is an asterisk */\n              if  (c == '*')\n              {\n                  comment_length= 0;\n                  comment_end= false;\n                  /* ignore everything until closing comment */\n                  while ((c= *ptr))\n                  {\n                      ptr++;\n                      comment_length++;\n\n                      if (c == '*')\n                      {\n                          c = *ptr++;\n                          /* alas, end of comment */\n                          if (c == '/')\n                          {\n                              comment_end= true;\n                              break;\n                          }\n                          /*\n                            nope, just an asterisk, not so fast, not\n                            end of comment, go back one\n                        */\n                          else\n                              ptr--;\n                      }\n                  }\n                  /*\n                    if the end of the comment was never found, we have\n                    to backtrack to wherever we first started skipping\n                    over the possible comment.\n                    This means we will pass the statement to the database\n                    to see its own fate and issue the error\n                */\n                  if (!comment_end)\n                      ptr -= comment_length;\n              }\n              else\n                  ptr--;\n              break;\n          }\n      }\n    case '`':\n    case '\"':\n    case '\\'':\n      /* Skip string */\n      {\n        char end_token = c;\n        while ((c = *ptr)  &&  c != end_token)\n        {\n          if (c == '\\\\')\n            if (! *(++ptr))\n              continue;\n\n          ++ptr;\n        }\n        if (c)\n          ++ptr;\n        break;\n      }\n\n    case '?':\n      ++num_params;\n      break;\n\n    default:\n      break;\n    }\n  }\n  return num_params;\n}\n\n/*\n  allocate memory in statement handle per number of placeholders\n*/\nstatic imp_sth_ph_t *alloc_param(int num_params)\n{\n  imp_sth_ph_t *params;\n\n  if (num_params)\n    Newz(908, params, (unsigned int) num_params, imp_sth_ph_t);\n  else\n    params= NULL;\n\n  return params;\n}\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  allocate memory in MYSQL_BIND bind structure per\n  number of placeholders\n*/\nstatic MYSQL_BIND *alloc_bind(int num_params)\n{\n  MYSQL_BIND *bind;\n\n  if (num_params)\n    Newz(908, bind, (unsigned int) num_params, MYSQL_BIND);\n  else\n    bind= NULL;\n\n  return bind;\n}\n\n/*\n  allocate memory in fbind imp_sth_phb_t structure per\n  number of placeholders\n*/\nstatic imp_sth_phb_t *alloc_fbind(int num_params)\n{\n  imp_sth_phb_t *fbind;\n\n  if (num_params)\n    Newz(908, fbind, (unsigned int) num_params, imp_sth_phb_t);\n  else\n    fbind= NULL;\n\n  return fbind;\n}\n\n/*\n  alloc memory for imp_sth_fbh_t fbuffer per number of fields\n*/\nstatic imp_sth_fbh_t *alloc_fbuffer(int num_fields)\n{\n  imp_sth_fbh_t *fbh;\n\n  if (num_fields)\n    Newz(908, fbh, (unsigned int) num_fields, imp_sth_fbh_t);\n  else\n    fbh= NULL;\n\n  return fbh;\n}\n\n/*\n  free MYSQL_BIND bind struct\n*/\nstatic void free_bind(MYSQL_BIND *bind)\n{\n  if (bind)\n    Safefree(bind);\n}\n\n/*\n   free imp_sth_phb_t fbind structure\n*/\nstatic void free_fbind(imp_sth_phb_t *fbind)\n{\n  if (fbind)\n    Safefree(fbind);\n}\n\n/*\n  free imp_sth_fbh_t fbh structure\n*/\nstatic void free_fbuffer(imp_sth_fbh_t *fbh)\n{\n  if (fbh)\n    Safefree(fbh);\n}\n\n#endif\n\n/*\n  free statement param structure per num_params\n*/\nstatic void\nfree_param(pTHX_ imp_sth_ph_t *params, int num_params)\n{\n  if (params)\n  {\n    int i;\n    for (i= 0;  i < num_params;  i++)\n    {\n      imp_sth_ph_t *ph= params+i;\n      if (ph->value)\n      {\n        (void) SvREFCNT_dec(ph->value);\n        ph->value= NULL;\n      }\n    }\n    Safefree(params);\n  }\n}\n\n/* \n  Convert a MySQL type to a type that perl can handle\n\n  NOTE: In the future we may want to return a struct with a lot of\n  information for each type\n*/\n\nstatic enum enum_field_types mysql_to_perl_type(enum enum_field_types type)\n{\n  static enum enum_field_types enum_type;\n\n  switch (type) {\n  case MYSQL_TYPE_DOUBLE:\n  case MYSQL_TYPE_FLOAT:\n    enum_type= MYSQL_TYPE_DOUBLE;\n    break;\n\n  case MYSQL_TYPE_SHORT:\n  case MYSQL_TYPE_TINY:\n  case MYSQL_TYPE_LONG:\n  case MYSQL_TYPE_INT24:\n  case MYSQL_TYPE_YEAR:\n#if IVSIZE >= 8\n  case MYSQL_TYPE_LONGLONG:\n#endif\n    enum_type= MYSQL_TYPE_LONG;\n    break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_BIT:\n    enum_type= MYSQL_TYPE_BIT;\n    break;\n#endif\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_NEWDECIMAL:\n#endif\n  case MYSQL_TYPE_DECIMAL:\n    enum_type= MYSQL_TYPE_DECIMAL;\n    break;\n\n#if IVSIZE < 8\n  case MYSQL_TYPE_LONGLONG:\n#endif\n  case MYSQL_TYPE_DATE:\n  case MYSQL_TYPE_TIME:\n  case MYSQL_TYPE_DATETIME:\n  case MYSQL_TYPE_NEWDATE:\n  case MYSQL_TYPE_TIMESTAMP:\n  case MYSQL_TYPE_VAR_STRING:\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n  case MYSQL_TYPE_VARCHAR:\n#endif\n  case MYSQL_TYPE_STRING:\n    enum_type= MYSQL_TYPE_STRING;\n    break;\n\n#if MYSQL_VERSION_ID > GEO_DATATYPE_VERSION\n  case MYSQL_TYPE_GEOMETRY:\n#endif\n  case MYSQL_TYPE_BLOB:\n  case MYSQL_TYPE_TINY_BLOB:\n    enum_type= MYSQL_TYPE_BLOB;\n    break;\n\n  default:\n    enum_type= MYSQL_TYPE_STRING;    /* MySQL can handle all types as strings */\n  }\n  return(enum_type);\n}\n\n#if defined(DBD_MYSQL_EMBEDDED)\n/* \n  count embedded options\n*/\nint count_embedded_options(char *st)\n{\n  int rc;\n  char c;\n  char *ptr;\n\n  ptr= st;\n  rc= 0;\n\n  if (st)\n  {\n    while ((c= *ptr++))\n    {\n      if (c == ',')\n        rc++;\n    }\n    rc++;\n  }\n\n  return rc;\n}\n\n/*\n  Free embedded options\n*/\nint free_embedded_options(char ** options_list, int options_count)\n{\n  int i;\n\n  for (i= 0; i < options_count; i++)\n  {\n    if (options_list[i])\n      free(options_list[i]);\n  }\n  free(options_list);\n\n  return 1;\n}\n\n/*\n Print out embedded option settings\n\n*/\nint print_embedded_options(PerlIO *stream, char ** options_list, int options_count)\n{\n  int i;\n\n  for (i=0; i<options_count; i++)\n  {\n    if (options_list[i])\n        PerlIO_printf(stream,\n                      \"Embedded server, parameter[%d]=%s\\n\",\n                      i, options_list[i]);\n  }\n  return 1;\n}\n\n/*\n\n*/\nchar **fill_out_embedded_options(PerlIO *stream,\n                                 char *options,\n                                 int options_type,\n                                 int slen, int cnt)\n{\n  int  ind, len;\n  char c;\n  char *ptr;\n  char **options_list= NULL;\n\n  if (!(options_list= (char **) calloc(cnt, sizeof(char *))))\n  {\n    PerlIO_printf(stream,\n                  \"Initialize embedded server. Out of memory \\n\");\n    return NULL;\n  }\n\n  ptr= options;\n  ind= 0;\n\n  if (options_type == 0)\n  {\n    /* server_groups list NULL terminated */\n    options_list[cnt]= (char *) NULL;\n  }\n\n  if (options_type == 1)\n  {\n    /* first item in server_options list is ignored. fill it with \\0 */\n    if (!(options_list[0]= calloc(1,sizeof(char))))\n      return NULL;\n\n    ind++;\n  }\n\n  while ((c= *ptr++))\n  {\n    slen--;\n    if (c == ',' || !slen)\n    {\n      len= ptr - options;\n      if (c == ',')\n        len--;\n      if (!(options_list[ind]=calloc(len+1,sizeof(char))))\n        return NULL;\n\n      strncpy(options_list[ind], options, len);\n      ind++;\n      options= ptr;\n    }\n  }\n  return options_list;\n}\n#endif\n\n/*\n  constructs an SQL statement previously prepared with\n  actual values replacing placeholders\n*/\nstatic char *parse_params(\n                          imp_xxh_t *imp_xxh,\n                          pTHX_ MYSQL *sock,\n                          char *statement,\n                          STRLEN *slen_ptr,\n                          imp_sth_ph_t* params,\n                          int num_params,\n                          bool bind_type_guessing,\n                          bool bind_comment_placeholders)\n{\n  bool comment_end= false;\n  char *salloc, *statement_ptr;\n  char *statement_ptr_end, *ptr, *valbuf;\n  char *cp, *end;\n  int alen, i;\n  int slen= *slen_ptr;\n  int limit_flag= 0;\n  int comment_length=0;\n  STRLEN vallen;\n  imp_sth_ph_t *ph;\n\n  if (DBIc_DBISTATE(imp_xxh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \">parse_params statement %s\\n\", statement);\n\n  if (num_params == 0)\n    return NULL;\n\n  while (isspace(*statement))\n  {\n    ++statement;\n    --slen;\n  }\n\n  /* Calculate the number of bytes being allocated for the statement */\n  alen= slen;\n\n  for (i= 0, ph= params; i < num_params; i++, ph++)\n  {\n    int defined= 0;\n    if (ph->value)\n    {\n      if (SvMAGICAL(ph->value))\n        mg_get(ph->value);\n      if (SvOK(ph->value))\n        defined=1;\n    }\n    if (!defined)\n      alen+= 3;  /* Erase '?', insert 'NULL' */\n    else\n    {\n      valbuf= SvPV(ph->value, vallen);\n      alen+= 2+vallen+1;\n      /* this will most likely not happen since line 214 */\n      /* of mysql.xs hardcodes all types to SQL_VARCHAR */\n      if (!ph->type)\n      {\n        if (bind_type_guessing)\n        {\n          valbuf= SvPV(ph->value, vallen);\n          ph->type= SQL_INTEGER;\n\n          if (parse_number(valbuf, vallen, &end) != 0)\n          {\n              ph->type= SQL_VARCHAR;\n          }\n        }\n        else\n          ph->type= SQL_VARCHAR;\n      }\n    }\n  }\n\n  /* Allocate memory, why *2, well, because we have ptr and statement_ptr */\n  New(908, salloc, alen*2, char);\n  ptr= salloc;\n\n  i= 0;\n /* Now create the statement string; compare count_params above */\n  statement_ptr_end= (statement_ptr= statement)+ slen;\n\n  while (statement_ptr < statement_ptr_end)\n  {\n    /* LIMIT should be the last part of the query, in most cases */\n    if (! limit_flag)\n    {\n      /*\n        it would be good to be able to handle any number of cases and orders\n      */\n      if ((*statement_ptr == 'l' || *statement_ptr == 'L') &&\n          (!strncmp(statement_ptr+1, \"imit ?\", 6) ||\n           !strncmp(statement_ptr+1, \"IMIT ?\", 6)))\n      {\n        limit_flag = 1;\n      }\n    }\n    switch (*statement_ptr)\n    {\n      /* comment detection. Anything goes in a comment */\n      case '-':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '-')\n              {\n                  /* ignore everything until newline or end of string */\n                  while (*statement_ptr)\n                  {\n                      comment_length++;\n                      *ptr++ = *statement_ptr++;\n                      if (!*statement_ptr || *statement_ptr == '\\n')\n                      {\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* if not end of comment, go back to where we started, no end found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      /* c-type comments */\n      case '/':\n      {\n          if (bind_comment_placeholders)\n          {\n              *ptr++= *statement_ptr++;\n              break;\n          }\n          else\n          {\n              comment_length= 1;\n              comment_end= false;\n              *ptr++ = *statement_ptr++;\n              if  (*statement_ptr == '*')\n              {\n                  /* use up characters everything until newline */\n                  while (*statement_ptr)\n                  {\n                      *ptr++ = *statement_ptr++;\n                      comment_length++;\n                      if (!strncmp(statement_ptr, \"*/\", 2))\n                      {\n                          comment_length += 2;\n                          comment_end= true;\n                          break;\n                      }\n                  }\n                  /* Go back to where started if comment end not found */\n                  if (! comment_end)\n                  {\n                      statement_ptr -= comment_length;\n                      ptr -= comment_length;\n                  }\n              }\n              break;\n          }\n      }\n      case '`':\n      case '\\'':\n      case '\"':\n      /* Skip string */\n      {\n        char endToken = *statement_ptr++;\n        *ptr++ = endToken;\n        while (statement_ptr != statement_ptr_end &&\n               *statement_ptr != endToken)\n        {\n          if (*statement_ptr == '\\\\')\n          {\n            *ptr++ = *statement_ptr++;\n            if (statement_ptr == statement_ptr_end)\n\t      break;\n\t  }\n          *ptr++= *statement_ptr++;\n\t}\n\tif (statement_ptr != statement_ptr_end)\n          *ptr++= *statement_ptr++;\n      }\n      break;\n\n      case '?':\n        /* Insert parameter */\n        statement_ptr++;\n        if (i >= num_params)\n        {\n          break;\n        }\n\n        ph = params+ (i++);\n        if (!ph->value  ||  !SvOK(ph->value))\n        {\n          *ptr++ = 'N';\n          *ptr++ = 'U';\n          *ptr++ = 'L';\n          *ptr++ = 'L';\n        }\n        else\n        {\n          int is_num = FALSE;\n\n          valbuf= SvPV(ph->value, vallen);\n          if (valbuf)\n          {\n            switch (ph->type)\n            {\n              case SQL_NUMERIC:\n              case SQL_DECIMAL:\n              case SQL_INTEGER:\n              case SQL_SMALLINT:\n              case SQL_FLOAT:\n              case SQL_REAL:\n              case SQL_DOUBLE:\n              case SQL_BIGINT:\n              case SQL_TINYINT:\n                is_num = TRUE;\n                break;\n            }\n\n            /* (note this sets *end, which we use if is_num) */\n            if ( parse_number(valbuf, vallen, &end) != 0 && is_num)\n            {\n              if (bind_type_guessing) {\n                /* .. not a number, so apparently we guessed wrong */\n                is_num = 0;\n                ph->type = SQL_VARCHAR;\n              }\n            }\n\n\n            /* we're at the end of the query, so any placeholders if */\n            /* after a LIMIT clause will be numbers and should not be quoted */\n            if (limit_flag == 1)\n              is_num = TRUE;\n\n            if (!is_num)\n            {\n              *ptr++ = '\\'';\n              ptr += mysql_real_escape_string(sock, ptr, valbuf, vallen);\n              *ptr++ = '\\'';\n            }\n            else\n            {\n              for (cp= valbuf; cp < end; cp++)\n                  *ptr++= *cp;\n            }\n          }\n        }\n        break;\n\n\t/* in case this is a nested LIMIT */\n      case ')':\n        limit_flag = 0;\n\t*ptr++ = *statement_ptr++;\n        break;\n\n      default:\n        *ptr++ = *statement_ptr++;\n        break;\n\n    }\n  }\n\n  *slen_ptr = ptr - salloc;\n  *ptr++ = '\\0';\n\n  return(salloc);\n}\n\nint bind_param(imp_sth_ph_t *ph, SV *value, IV sql_type)\n{\n  dTHX;\n  if (ph->value)\n  {\n    if (SvMAGICAL(ph->value))\n      mg_get(ph->value);\n    (void) SvREFCNT_dec(ph->value);\n  }\n\n  ph->value= newSVsv(value);\n\n  if (sql_type)\n    ph->type = sql_type;\n\n  return TRUE;\n}\n\nstatic const sql_type_info_t SQL_GET_TYPE_INFO_values[]= {\n  { \"varchar\",    SQL_VARCHAR,                    255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"variable length string\",\n    0, 0, 0,\n    SQL_VARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_VAR_STRING,  0,\n#else\n    MYSQL_TYPE_STRING,  0,\n#endif\n  },\n  { \"decimal\",   SQL_DECIMAL,                      15, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_DECIMAL, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,     1\n#endif\n  },\n  { \"tinyint\",   SQL_TINYINT,                       3, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Tiny integer\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,     1\n#endif\n  },\n  { \"smallint\",  SQL_SMALLINT,                      5, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Short integer\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,     1\n#endif\n  },\n  { \"integer\",   SQL_INTEGER,                      10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,     1\n#endif\n  },\n  { \"float\",     SQL_REAL,                          7,  NULL, NULL, NULL,\n    1, 0, 0, 0, 0, 0, \"float\",\n    0, 2, 10,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_FLOAT,       1\n#else\n    MYSQL_TYPE_FLOAT,     1\n#endif\n  },\n  { \"double\",    SQL_FLOAT,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 2,\n    SQL_FLOAT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  { \"double\",    SQL_DOUBLE,                       15,  NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 4, 10,\n    SQL_DOUBLE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DOUBLE,      1\n#else\n    MYSQL_TYPE_DOUBLE,     1\n#endif\n  },\n  /*\n    FIELD_TYPE_NULL ?\n  */\n  { \"timestamp\", SQL_TIMESTAMP,                    14, \"'\", \"'\", NULL,\n    0, 0, 3, 0, 0, 0, \"timestamp\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIMESTAMP,   0\n#else\n    MYSQL_TYPE_TIMESTAMP,     0\n#endif\n  },\n  { \"bigint\",    SQL_BIGINT,                       19, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Longlong integer\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,     1\n#endif\n  },\n  { \"mediumint\", SQL_INTEGER,                       8, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,     1\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATE, 0\n#else\n    MYSQL_TYPE_DATE, 0\n#endif\n  },\n  { \"time\", SQL_TIME, 6, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"time\",\n    0, 0, 0,\n    SQL_TIME, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TIME,        0\n#else\n    MYSQL_TYPE_TIME,     0\n#endif\n  },\n  { \"datetime\",  SQL_TIMESTAMP, 21, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"datetime\",\n    0, 0, 0,\n    SQL_TIMESTAMP, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DATETIME,    0\n#else\n    MYSQL_TYPE_DATETIME,     0\n#endif\n  },\n  { \"year\", SQL_SMALLINT, 4, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"year\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_YEAR,        0\n#else\n    MYSQL_TYPE_YEAR,     0\n#endif\n  },\n  { \"date\", SQL_DATE, 10, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"date\",\n    0, 0, 0,\n    SQL_DATE, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_NEWDATE,     0\n#else\n    MYSQL_TYPE_NEWDATE,     0\n#endif\n  },\n  { \"enum\",      SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"enum(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_ENUM,        0\n#else\n    MYSQL_TYPE_ENUM,     0\n#endif\n  },\n  { \"set\",       SQL_VARCHAR,                     255, \"'\",  \"'\",  NULL,\n    1, 0, 1, 0, 0, 0, \"set(value1,value2,value3...)\",\n    0, 0, 0,\n    0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SET,         0\n#else\n    MYSQL_TYPE_SET,     0\n#endif\n  },\n  { \"blob\",       SQL_LONGVARBINARY,              65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,     0\n#endif\n  },\n  { \"tinyblob\",  SQL_VARBINARY,                 255, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object (0-255) \",\n    0, 0, 0,\n    SQL_VARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY_BLOB,   0\n#else\n    FIELD_TYPE_TINY_BLOB,        0\n#endif\n  },\n  { \"mediumblob\", SQL_LONGVARBINARY,           16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"longblob\",   SQL_LONGVARBINARY,         2147483647, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"binary large object, use mediumblob instead\",\n    0, 0, 0,\n    SQL_LONGVARBINARY, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_LONG_BLOB,   0\n#else\n    MYSQL_TYPE_LONG_BLOB,   0\n#endif\n  },\n  { \"char\",       SQL_CHAR,                       255, \"'\",  \"'\",  \"max length\",\n    1, 0, 3, 0, 0, 0, \"string\",\n    0, 0, 0,\n    SQL_CHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0 \n    FIELD_TYPE_STRING,      0\n#else\n    MYSQL_TYPE_STRING,   0\n#endif\n  },\n\n  { \"decimal\",            SQL_NUMERIC,            15,  NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"double\",\n    0, 6, 2,\n    SQL_NUMERIC, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_DECIMAL,     1\n#else\n    MYSQL_TYPE_DECIMAL,   1 \n#endif\n  },\n  { \"tinyint unsigned\",   SQL_TINYINT,              3, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Tiny integer unsigned\",\n    0, 0, 10,\n    SQL_TINYINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_TINY,        1\n#else\n    MYSQL_TYPE_TINY,        1\n#endif\n  },\n  { \"smallint unsigned\",  SQL_SMALLINT,             5, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Short integer unsigned\",\n    0, 0, 10,\n    SQL_SMALLINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_SHORT,       1\n#else\n    MYSQL_TYPE_SHORT,       1\n#endif\n  },\n  { \"mediumint unsigned\", SQL_INTEGER,              8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_INT24,       1\n#else\n    MYSQL_TYPE_INT24,       1\n#endif\n  },\n  { \"int unsigned\",       SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer unsigned\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"int\",                SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"integer unsigned\",   SQL_INTEGER,             10, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"integer\",\n    0, 0, 10,\n    SQL_INTEGER, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONG,        1\n#else\n    MYSQL_TYPE_LONG,        1\n#endif\n  },\n  { \"bigint unsigned\",    SQL_BIGINT,              20, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Longlong integer unsigned\",\n    0, 0, 10,\n    SQL_BIGINT, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_LONGLONG,    1\n#else\n    MYSQL_TYPE_LONGLONG,    1\n#endif\n  },\n  { \"text\",               SQL_LONGVARCHAR,      65535, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object (0-65535)\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_BLOB,        0\n#else\n    MYSQL_TYPE_BLOB,        0\n#endif\n  },\n  { \"mediumtext\",         SQL_LONGVARCHAR,   16777215, \"'\",  \"'\",  NULL,\n    1, 0, 3, 0, 0, 0, \"large text object\",\n    0, 0, 0,\n    SQL_LONGVARCHAR, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    FIELD_TYPE_MEDIUM_BLOB, 0\n#else\n    MYSQL_TYPE_MEDIUM_BLOB, 0\n#endif\n  },\n  { \"mediumint unsigned auto_increment\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"Medium integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1,\n#endif\n  },\n  { \"tinyint unsigned auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"tinyint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"smallint auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"smallint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"mediumint\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"Medium integer\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"bit\", SQL_BIT, 1, NULL, NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"char(1)\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 0\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 0\n#endif\n  },\n\n  { \"numeric\", SQL_NUMERIC, 19, NULL, NULL, \"precision,scale\",\n    1, 0, 3, 0, 0, 0, \"numeric\", 0, 19, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_NUMERIC, 0, 0, FIELD_TYPE_DECIMAL, 1,\n#else\n    SQL_NUMERIC, 0, 0, MYSQL_TYPE_DECIMAL, 1,\n#endif\n  },\n\n  { \"integer unsigned auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"integer unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"mediumint unsigned\", SQL_INTEGER, 8, NULL, NULL, NULL,\n    1, 0, 3, 1, 0, 0, \"Medium integer unsigned\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"smallint unsigned auto_increment\", SQL_SMALLINT, 5, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"smallint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_SMALLINT, 0, 0, FIELD_TYPE_SHORT, 1\n#else\n    SQL_SMALLINT, 0, 0, MYSQL_TYPE_SHORT, 1\n#endif\n  },\n\n  { \"int auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1\n#endif\n  },\n\n  { \"long varbinary\", SQL_LONGVARBINARY, 16777215, \"0x\", NULL, NULL,\n    1, 0, 3, 0, 0, 0, \"mediumblob\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARBINARY, 0, 0, FIELD_TYPE_LONG_BLOB, 0\n#else\n    SQL_LONGVARBINARY, 0, 0, MYSQL_TYPE_LONG_BLOB, 0\n#endif\n  },\n\n  { \"double auto_increment\", SQL_FLOAT, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 2,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"double auto_increment\", SQL_DOUBLE, 15, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"double auto_increment\", 0, 4, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_DOUBLE, 0, 0, FIELD_TYPE_DOUBLE, 1\n#else\n    SQL_DOUBLE, 0, 0, MYSQL_TYPE_DOUBLE, 1\n#endif\n  },\n\n  { \"integer auto_increment\", SQL_INTEGER, 10, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_LONG, 1,\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_LONG, 1,\n#endif\n  },\n\n  { \"bigint auto_increment\", SQL_BIGINT, 19, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"bigint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n  { \"bit auto_increment\", SQL_BIT, 1, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"char(1) auto_increment\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_BIT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"mediumint auto_increment\", SQL_INTEGER, 7, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"Medium integer auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_INTEGER, 0, 0, FIELD_TYPE_INT24, 1\n#else\n    SQL_INTEGER, 0, 0, MYSQL_TYPE_INT24, 1\n#endif\n  },\n\n  { \"float auto_increment\", SQL_REAL, 7, NULL, NULL, NULL,\n    0, 0, 0, 0, 0, 1, \"float auto_increment\", 0, 2, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_FLOAT, 0, 0, FIELD_TYPE_FLOAT, 1\n#else\n    SQL_FLOAT, 0, 0, MYSQL_TYPE_FLOAT, 1\n#endif\n  },\n\n  { \"long varchar\", SQL_LONGVARCHAR, 16777215, \"'\", \"'\", NULL,\n    1, 0, 3, 0, 0, 0, \"mediumtext\", 0, 0, 0,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_LONGVARCHAR, 0, 0, FIELD_TYPE_MEDIUM_BLOB, 1\n#else\n    SQL_LONGVARCHAR, 0, 0, MYSQL_TYPE_MEDIUM_BLOB, 1\n#endif\n\n  },\n\n  { \"tinyint auto_increment\", SQL_TINYINT, 3, NULL, NULL, NULL,\n    0, 0, 3, 0, 0, 1, \"tinyint auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_TINYINT, 0, 0, FIELD_TYPE_TINY, 1\n#else\n    SQL_TINYINT, 0, 0, MYSQL_TYPE_TINY, 1\n#endif\n  },\n\n  { \"bigint unsigned auto_increment\", SQL_BIGINT, 20, NULL, NULL, NULL,\n    0, 0, 3, 1, 0, 1, \"bigint unsigned auto_increment\", 0, 0, 10,\n#if MYSQL_VERSION_ID < MYSQL_VERSION_5_0\n    SQL_BIGINT, 0, 0, FIELD_TYPE_LONGLONG, 1\n#else\n    SQL_BIGINT, 0, 0, MYSQL_TYPE_LONGLONG, 1\n#endif\n  },\n\n/* END MORE STUFF */\n};\n\n/* \n  static const sql_type_info_t* native2sql (int t)\n*/\nstatic const sql_type_info_t *native2sql(int t)\n{\n  switch (t) {\n    case FIELD_TYPE_VAR_STRING:  return &SQL_GET_TYPE_INFO_values[0];\n    case FIELD_TYPE_DECIMAL:     return &SQL_GET_TYPE_INFO_values[1];\n#ifdef FIELD_TYPE_NEWDECIMAL\n    case FIELD_TYPE_NEWDECIMAL:  return &SQL_GET_TYPE_INFO_values[1];\n#endif\n    case FIELD_TYPE_TINY:        return &SQL_GET_TYPE_INFO_values[2];\n    case FIELD_TYPE_SHORT:       return &SQL_GET_TYPE_INFO_values[3];\n    case FIELD_TYPE_LONG:        return &SQL_GET_TYPE_INFO_values[4];\n    case FIELD_TYPE_FLOAT:       return &SQL_GET_TYPE_INFO_values[5];\n\n    /* 6  */\n    case FIELD_TYPE_DOUBLE:      return &SQL_GET_TYPE_INFO_values[7];\n    case FIELD_TYPE_TIMESTAMP:   return &SQL_GET_TYPE_INFO_values[8];\n    case FIELD_TYPE_LONGLONG:    return &SQL_GET_TYPE_INFO_values[9];\n    case FIELD_TYPE_INT24:       return &SQL_GET_TYPE_INFO_values[10];\n    case FIELD_TYPE_DATE:        return &SQL_GET_TYPE_INFO_values[11];\n    case FIELD_TYPE_TIME:        return &SQL_GET_TYPE_INFO_values[12];\n    case FIELD_TYPE_DATETIME:    return &SQL_GET_TYPE_INFO_values[13];\n    case FIELD_TYPE_YEAR:        return &SQL_GET_TYPE_INFO_values[14];\n    case FIELD_TYPE_NEWDATE:     return &SQL_GET_TYPE_INFO_values[15];\n    case FIELD_TYPE_ENUM:        return &SQL_GET_TYPE_INFO_values[16];\n    case FIELD_TYPE_SET:         return &SQL_GET_TYPE_INFO_values[17];\n    case FIELD_TYPE_BLOB:        return &SQL_GET_TYPE_INFO_values[18];\n    case FIELD_TYPE_TINY_BLOB:   return &SQL_GET_TYPE_INFO_values[19];\n    case FIELD_TYPE_MEDIUM_BLOB: return &SQL_GET_TYPE_INFO_values[20];\n    case FIELD_TYPE_LONG_BLOB:   return &SQL_GET_TYPE_INFO_values[21];\n    case FIELD_TYPE_STRING:      return &SQL_GET_TYPE_INFO_values[22];\n    default:                     return &SQL_GET_TYPE_INFO_values[0];\n  }\n}\n\n\n#define SQL_GET_TYPE_INFO_num \\\n\t(sizeof(SQL_GET_TYPE_INFO_values)/sizeof(sql_type_info_t))\n\n\n/***************************************************************************\n *\n *  Name:    dbd_init\n *\n *  Purpose: Called when the driver is installed by DBI\n *\n *  Input:   dbistate - pointer to the DBI state variable, used for some\n *               DBI internal things\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_init(dbistate_t* dbistate)\n{\n    dTHX;\n    DBISTATE_INIT;\n}\n\n\n/**************************************************************************\n *\n *  Name:    do_error, do_warn\n *\n *  Purpose: Called to associate an error code and an error message\n *           to some handle\n *\n *  Input:   h - the handle in error condition\n *           rc - the error code\n *           what - the error message\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid do_error(SV* h, int rc, const char* what, const char* sqlstate)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n  SV *errstr;\n  SV *errstate;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t--> do_error\\n\");\n  errstr= DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n\n#if MYSQL_VERSION_ID >= SQL_STATE_VERSION\n  if (sqlstate)\n  {\n    errstate= DBIc_STATE(imp_xxh);\n    sv_setpvn(errstate, sqlstate, 5);\n  }\n#endif\n\n  /* NO EFFECT DBIh_EVENT2(h, ERROR_event, DBIc_ERR(imp_xxh), errstr); */\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s error %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\t<-- do_error\\n\");\n}\n\n/*\n  void do_warn(SV* h, int rc, char* what)\n*/\nvoid do_warn(SV* h, int rc, char* what)\n{\n  dTHX;\n  D_imp_xxh(h);\n  STRLEN lna;\n\n  SV *errstr = DBIc_ERRSTR(imp_xxh);\n  sv_setiv(DBIc_ERR(imp_xxh), (IV)rc);\t/* set err early\t*/\n  sv_setpv(errstr, what);\n  /* NO EFFECT DBIh_EVENT2(h, WARN_event, DBIc_ERR(imp_xxh), errstr);*/\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%s warning %d recorded: %s\\n\",\n    what, rc, SvPV(errstr,lna));\n  warn(\"%s\", what);\n}\n\n#if defined(DBD_MYSQL_EMBEDDED)\n #define DBD_MYSQL_NAMESPACE \"DBD::mysqlEmb::QUIET\";\n#else\n #define DBD_MYSQL_NAMESPACE \"DBD::mysql::QUIET\";\n#endif\n\n#define doquietwarn(s) \\\n  { \\\n    SV* sv = perl_get_sv(DBD_MYSQL_NAMESPACE, FALSE);  \\\n    if (!sv  ||  !SvTRUE(sv)) { \\\n      warn s; \\\n    } \\\n  }\n\n\n/***************************************************************************\n *\n *  Name:    mysql_dr_connect\n *\n *  Purpose: Replacement for mysql_connect\n *\n *  Input:   MYSQL* sock - Pointer to a MYSQL structure being\n *             initialized\n *           char* mysql_socket - Name of a UNIX socket being used\n *             or NULL\n *           char* host - Host name being used or NULL for localhost\n *           char* port - Port number being used or NULL for default\n *           char* user - User name being used or NULL\n *           char* password - Password being used or NULL\n *           char* dbname - Database name being used or NULL\n *           char* imp_dbh - Pointer to internal dbh structure\n *\n *  Returns: The sock argument for success, NULL otherwise;\n *           you have to call do_error in the latter case.\n *\n **************************************************************************/\n\nMYSQL *mysql_dr_connect(\n                        SV* dbh,\n                        MYSQL* sock,\n                        char* mysql_socket,\n                        char* host,\n\t\t\t                  char* port,\n                        char* user,\n                        char* password,\n\t\t\t                  char* dbname,\n                        imp_dbh_t *imp_dbh)\n{\n  int portNr;\n  unsigned int client_flag;\n  MYSQL* result;\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* per Monty, already in client.c in API */\n  /* but still not exist in libmysqld.c */\n#if defined(DBD_MYSQL_EMBEDDED)\n   if (host && !*host) host = NULL;\n#endif\n\n  portNr= (port && *port) ? atoi(port) : 0;\n\n  /* already in client.c in API */\n  /* if (user && !*user) user = NULL; */\n  /* if (password && !*password) password = NULL; */\n\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->mysql_dr_connect: host = |%s|, port = %d,\" \\\n\t\t  \" uid = %s, pwd = %s\\n\",\n\t\t  host ? host : \"NULL\", portNr,\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  {\n\n#if defined(DBD_MYSQL_EMBEDDED)\n    if (imp_dbh)\n    {\n      D_imp_drh_from_dbh;\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      if (sv  &&  SvROK(sv))\n      {\n        SV** svp;\n        STRLEN lna;\n        char * options;\n        int server_args_cnt= 0;\n        int server_groups_cnt= 0;\n        int rc= 0;\n\n        char ** server_args = NULL;\n        char ** server_groups = NULL;\n\n        HV* hv = (HV*) SvRV(sv);\n\n        if (SvTYPE(hv) != SVt_PVHV)\n          return NULL;\n\n        if (!imp_drh->embedded.state)\n        {\n          /* Init embedded server */\n          if ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.groups=newSVsv(*svp);\n\n            if ((server_groups_cnt=count_embedded_options(options)))\n            {\n              /* number of server_groups always server_groups+1 */\n              server_groups=fill_out_embedded_options(DBIc_LOGPIO(imp_xxh), options, 0, \n                                                      (int)lna, ++server_groups_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                              \"Groups names passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_groups, server_groups_cnt);\n              }\n            }\n          }\n\n          if ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE))  &&\n              *svp  &&  SvTRUE(*svp))\n          {\n            options = SvPV(*svp, lna);\n            imp_drh->embedded.args=newSVsv(*svp);\n\n            if ((server_args_cnt=count_embedded_options(options)))\n            {\n              /* number of server_options always server_options+1 */\n              server_args=fill_out_embedded_options(DBIc_LOGPIO(imp_xxh), options, 1, (int)lna, ++server_args_cnt);\n              if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n              {\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Server options passed to embedded server:\\n\");\n                print_embedded_options(DBIc_LOGPIO(imp_xxh), server_args, server_args_cnt);\n              }\n            }\n          }\n          if (mysql_server_init(server_args_cnt, server_args, server_groups))\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED, \"Embedded server was not started. \\\n                    Could not initialize environment.\");\n            return NULL;\n          }\n          imp_drh->embedded.state=1;\n\n          if (server_args_cnt)\n            free_embedded_options(server_args, server_args_cnt);\n          if (server_groups_cnt)\n            free_embedded_options(server_groups, server_groups_cnt);\n        }\n        else\n        {\n         /*\n          * Check if embedded parameters passed to connect() differ from\n          * first ones\n          */\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_groups\", 21, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)))\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.groups));\n\n          if ( ((svp = hv_fetch(hv, \"mysql_embedded_options\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp)) )\n            rc =+ abs(sv_cmp(*svp, imp_drh->embedded.args));\n\n          if (rc)\n          {\n            do_warn(dbh, AS_ERR_EMBEDDED,\n                    \"Embedded server was already started. You cannot pass init\\\n                    parameters to embedded server once\");\n            return NULL;\n          }\n        }\n      }\n    }\n#endif\n\n#ifdef MYSQL_NO_CLIENT_FOUND_ROWS\n    client_flag = 0;\n#else\n    client_flag = CLIENT_FOUND_ROWS;\n#endif\n    mysql_init(sock);\n\n    if (imp_dbh)\n    {\n      SV* sv = DBIc_IMP_DATA(imp_dbh);\n\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, TRUE);\n      if (sv  &&  SvROK(sv))\n      {\n        HV* hv = (HV*) SvRV(sv);\n        SV** svp;\n        STRLEN lna;\n\n        /* thanks to Peter John Edwards for mysql_init_command */ \n        if ((svp = hv_fetch(hv, \"mysql_init_command\", 18, FALSE)) &&\n            *svp && SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                           \"imp_dbh->mysql_dr_connect: Setting\" \\\n                           \" init command (%s).\\n\", df);\n          mysql_options(sock, MYSQL_INIT_COMMAND, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_compression\", 17, FALSE))  &&\n            *svp && SvTRUE(*svp))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Enabling\" \\\n                          \" compression.\\n\");\n          mysql_options(sock, MYSQL_OPT_COMPRESS, NULL);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_connect_timeout\", 21, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" connect timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_CONNECT_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_write_timeout\", 19, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" write timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_WRITE_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_timeout\", 18, FALSE))\n            &&  *svp  &&  SvTRUE(*svp))\n        {\n          int to = SvIV(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Setting\" \\\n                          \" read timeout (%d).\\n\",to);\n          mysql_options(sock, MYSQL_OPT_READ_TIMEOUT,\n                        (const char *)&to);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_skip_secure_auth\", 22, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          my_bool secauth = 0;\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Skipping\" \\\n                          \" secure auth\\n\");\n          mysql_options(sock, MYSQL_SECURE_AUTH, &secauth);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_file\", 23, FALSE)) &&\n            *svp  &&  SvTRUE(*svp))\n        {\n          char* df = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->mysql_dr_connect: Reading\" \\\n                          \" default file %s.\\n\", df);\n          mysql_options(sock, MYSQL_READ_DEFAULT_FILE, df);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_read_default_group\", 24,\n                            FALSE))  &&\n            *svp  &&  SvTRUE(*svp)) {\n          char* gr = SvPV(*svp, lna);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"imp_dbh->mysql_dr_connect: Using\" \\\n                    \" default group %s.\\n\", gr);\n\n          mysql_options(sock, MYSQL_READ_DEFAULT_GROUP, gr);\n        }\n        #if (MYSQL_VERSION_ID >= 50606)\n          if ((svp = hv_fetch(hv, \"mysql_conn_attrs\", 16, FALSE)) && *svp) {\n              HV* attrs = (HV*) SvRV(*svp);\n              HE* entry = NULL;\n              I32 num_entries = hv_iterinit(attrs);\n              while (num_entries && (entry = hv_iternext(attrs))) {\n                  I32 retlen = 0;\n                  char *attr_name = hv_iterkey(entry, &retlen);\n                  SV *sv_attr_val = hv_iterval(attrs, entry);\n                  char *attr_val  = SvPV(sv_attr_val, lna);\n                  mysql_options4(sock, MYSQL_OPT_CONNECT_ATTR_ADD, attr_name, attr_val);\n              }\n          }\n        #endif\n        if ((svp = hv_fetch(hv, \"mysql_client_found_rows\", 23, FALSE)) && *svp)\n        {\n          if (SvTRUE(*svp))\n            client_flag |= CLIENT_FOUND_ROWS;\n          else\n            client_flag &= ~CLIENT_FOUND_ROWS;\n        }\n        if ((svp = hv_fetch(hv, \"mysql_use_result\", 16, FALSE)) && *svp)\n        {\n          imp_dbh->use_mysql_use_result = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->use_mysql_use_result: %d\\n\",\n                          imp_dbh->use_mysql_use_result);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_type_guessing\", 24, TRUE)) && *svp)\n        {\n          imp_dbh->bind_type_guessing= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_type_guessing: %d\\n\",\n                          imp_dbh->bind_type_guessing);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_bind_comment_placeholders\", 31, FALSE)) && *svp)\n        {\n          imp_dbh->bind_comment_placeholders = SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->bind_comment_placeholders: %d\\n\",\n                          imp_dbh->bind_comment_placeholders);\n        }\n        if ((svp = hv_fetch(hv, \"mysql_no_autocommit_cmd\", 23, FALSE)) && *svp)\n        {\n          imp_dbh->no_autocommit_cmd= SvTRUE(*svp);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->no_autocommit_cmd: %d\\n\",\n                          imp_dbh->no_autocommit_cmd);\n        }\n#if FABRIC_SUPPORT\n        if ((svp = hv_fetch(hv, \"mysql_use_fabric\", 16, FALSE)) &&\n            *svp && SvTRUE(*svp))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"imp_dbh->use_fabric: Enabling use of\" \\\n                          \" MySQL Fabric.\\n\");\n          mysql_options(sock, MYSQL_OPT_USE_FABRIC, NULL);\n        }\n#endif\n\n#if defined(CLIENT_MULTI_STATEMENTS)\n\tif ((svp = hv_fetch(hv, \"mysql_multi_statements\", 22, FALSE)) && *svp)\n        {\n\t  if (SvTRUE(*svp))\n\t    client_flag |= CLIENT_MULTI_STATEMENTS;\n          else\n            client_flag &= ~CLIENT_MULTI_STATEMENTS;\n\t}\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\t/* took out  client_flag |= CLIENT_PROTOCOL_41; */\n\t/* because libmysql.c already sets this no matter what */\n\tif ((svp = hv_fetch(hv, \"mysql_server_prepare\", 20, FALSE))\n            && *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    client_flag |= CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = TRUE;\n\t  }\n          else\n          {\n\t    client_flag &= ~CLIENT_PROTOCOL_41;\n            imp_dbh->use_server_side_prepare = FALSE;\n\t  }\n\t}\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"imp_dbh->use_server_side_prepare: %d\\n\",\n                        imp_dbh->use_server_side_prepare);\n#endif\n\n        /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n        if ((svp = hv_fetch(hv, \"mysql_enable_utf8mb4\", 20, FALSE)) && *svp && SvTRUE(*svp)) {\n          mysql_options(sock, MYSQL_SET_CHARSET_NAME, \"utf8mb4\");\n        }\n        else if ((svp = hv_fetch(hv, \"mysql_enable_utf8\", 17, FALSE)) && *svp) {\n          /* Do not touch imp_dbh->enable_utf8 as we are called earlier\n           * than it is set and mysql_options() must be before:\n           * mysql_real_connect()\n          */\n         mysql_options(sock, MYSQL_SET_CHARSET_NAME,\n                       (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n         if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n           PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                         \"mysql_options: MYSQL_SET_CHARSET_NAME=%s\\n\",\n                         (SvTRUE(*svp) ? \"utf8\" : \"latin1\"));\n        }\n#endif\n\n#if defined(DBD_MYSQL_WITH_SSL) && !defined(DBD_MYSQL_EMBEDDED) && \\\n    (defined(CLIENT_SSL) || (MYSQL_VERSION_ID >= 40000))\n\tif ((svp = hv_fetch(hv, \"mysql_ssl\", 9, FALSE))  &&  *svp)\n        {\n\t  if (SvTRUE(*svp))\n          {\n\t    char *client_key = NULL;\n\t    char *client_cert = NULL;\n\t    char *ca_file = NULL;\n\t    char *ca_path = NULL;\n\t    char *cipher = NULL;\n\t    STRLEN lna;\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION && MYSQL_VERSION_ID <= SSL_LAST_VERIFY_VERSION\n            /*\n              New code to utilise MySQLs new feature that verifies that the\n              server's hostname that the client connects to matches that of\n              the certificate\n            */\n\t    my_bool ssl_verify_true = 0;\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_verify_server_cert\", 28, FALSE))  &&  *svp)\n\t      ssl_verify_true = SvTRUE(*svp);\n#endif\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_key\", 20, FALSE)) && *svp)\n\t      client_key = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_client_cert\", 21, FALSE)) &&\n                *svp)\n\t      client_cert = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_file\", 17, FALSE)) &&\n\t\t *svp)\n\t      ca_file = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_ca_path\", 17, FALSE)) &&\n                *svp)\n\t      ca_path = SvPV(*svp, lna);\n\n\t    if ((svp = hv_fetch(hv, \"mysql_ssl_cipher\", 16, FALSE)) &&\n\t\t*svp)\n\t      cipher = SvPV(*svp, lna);\n\n\t    mysql_ssl_set(sock, client_key, client_cert, ca_file,\n\t\t\t  ca_path, cipher);\n#if MYSQL_VERSION_ID >= SSL_VERIFY_VERSION && MYSQL_VERSION_ID <= SSL_LAST_VERIFY_VERSION\n\t    mysql_options(sock, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, &ssl_verify_true);\n#endif\n\t    client_flag |= CLIENT_SSL;\n\t  }\n\t}\n#endif\n#if (MYSQL_VERSION_ID >= 32349)\n\t/*\n\t * MySQL 3.23.49 disables LOAD DATA LOCAL by default. Use\n\t * mysql_local_infile=1 in the DSN to enable it.\n\t */\n     if ((svp = hv_fetch( hv, \"mysql_local_infile\", 18, FALSE))  &&  *svp)\n     {\n\t  unsigned int flag = SvTRUE(*svp);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n\t    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n        \"imp_dbh->mysql_dr_connect: Using\" \\\n        \" local infile %u.\\n\", flag);\n\t  mysql_options(sock, MYSQL_OPT_LOCAL_INFILE, (const char *) &flag);\n\t}\n#endif\n      }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: client_flags = %d\\n\",\n\t\t    client_flag);\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n    client_flag|= CLIENT_MULTI_RESULTS;\n#endif\n    result = mysql_real_connect(sock, host, user, password, dbname,\n\t\t\t\tportNr, mysql_socket, client_flag);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->mysql_dr_connect: <-\");\n\n    if (result)\n    {\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n      /* connection succeeded. */\n      /* imp_dbh == NULL when mysql_dr_connect() is called from mysql.xs\n         functions (_admin_internal(),_ListDBs()). */\n      if (!(result->client_flag & CLIENT_PROTOCOL_41) && imp_dbh)\n        imp_dbh->use_server_side_prepare = FALSE;\n#endif\n\n#if MYSQL_ASYNC\n      if(imp_dbh) {\n          imp_dbh->async_query_in_flight = NULL;\n      }\n#endif\n\n      /*\n        we turn off Mysql's auto reconnect and handle re-connecting ourselves\n        so that we can keep track of when this happens.\n      */\n      result->reconnect=0;\n    }\n    else {\n      /* \n         sock was allocated with mysql_init() \n         fixes: https://rt.cpan.org/Ticket/Display.html?id=86153\n\n      Safefree(sock);\n\n         rurban: No, we still need this handle later in mysql_dr_error().\n         RT #97625. It will be freed as imp_dbh->pmysql in dbd_db_destroy(),\n         which is called by the DESTROY handler.\n      */\n    }\n    return result;\n  }\n}\n\n/*\n  safe_hv_fetch\n*/\nstatic char *safe_hv_fetch(pTHX_ HV *hv, const char *name, int name_length)\n{\n  SV** svp;\n  STRLEN len;\n  char *res= NULL;\n\n  if ((svp= hv_fetch(hv, name, name_length, FALSE)))\n  {\n    res= SvPV(*svp, len);\n    if (!len)\n      res= NULL;\n  }\n  return res;\n}\n\n/*\n Frontend for mysql_dr_connect\n*/\nstatic int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"my_login skip connect\\n\");\n      /* tell our parent we've adopted an active child */\n      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));\n      return TRUE;\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"my_login IMPSET but not ACTIVE so connect not skipped\\n\");\n  }\n#endif\n\n  sv = DBIc_IMP_DATA(imp_dbh);\n\n  if (!sv  ||  !SvROK(sv))\n    return FALSE;\n\n  hv = (HV*) SvRV(sv);\n  if (SvTYPE(hv) != SVt_PVHV)\n    return FALSE;\n\n  host=\t\tsafe_hv_fetch(aTHX_ hv, \"host\", 4);\n  port=\t\tsafe_hv_fetch(aTHX_ hv, \"port\", 4);\n  user=\t\tsafe_hv_fetch(aTHX_ hv, \"user\", 4);\n  password=\tsafe_hv_fetch(aTHX_ hv, \"password\", 8);\n  dbname=\tsafe_hv_fetch(aTHX_ hv, \"database\", 8);\n  mysql_socket=\tsafe_hv_fetch(aTHX_ hv, \"mysql_socket\", 12);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  return result;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_login\n *\n *  Purpose: Called for connecting to a database and logging in.\n *\n *  Input:   dbh - database handle being initialized\n *           imp_dbh - drivers private database handle data\n *           dbname - the database we want to log into; may be like\n *               \"dbname:host\" or \"dbname:host:port\"\n *           user - user name to connect as\n *           password - password to connect with\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_login(SV* dbh, imp_dbh_t* imp_dbh, char* dbname, char* user,\n\t\t char* password) {\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX; \n  D_imp_xxh(dbh);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\");\n\n  imp_dbh->stats.auto_reconnects_ok= 0;\n  imp_dbh->stats.auto_reconnects_failed= 0;\n  imp_dbh->bind_type_guessing= FALSE;\n  imp_dbh->bind_comment_placeholders= FALSE;\n  imp_dbh->has_transactions= TRUE;\n /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;     /* initialize mysql_enable_utf8 */\n  imp_dbh->enable_utf8mb4 = FALSE;  /* initialize mysql_enable_utf8mb4 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql) {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        Safefree(imp_dbh->pmysql);\n\n    }\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);\n\n    return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_db_commit\n *           dbd_db_rollback\n *\n *  Purpose: You guess what they should do. \n *\n *  Input:   dbh - database handle being committed or rolled back\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint\ndbd_db_commit(SV* dbh, imp_dbh_t* imp_dbh)\n{\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"COMMIT\", 6))\n#else\n    if (mysql_commit(imp_dbh->pmysql))\n#endif\n    {\n      do_error(dbh, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql)\n               ,mysql_sqlstate(imp_dbh->pmysql));\n      return FALSE;\n    }\n  }\n  else\n    do_warn(dbh, JW_ERR_NOT_IMPLEMENTED,\n            \"Commit ineffective because transactions are not available\");\n  return TRUE;\n}\n\n/*\n dbd_db_rollback\n*/\nint\ndbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh) {\n  /* croak, if not in AutoCommit mode */\n  if (DBIc_has(imp_dbh, DBIcf_AutoCommit))\n    return FALSE;\n\n  ASYNC_CHECK_RETURN(dbh, FALSE);\n\n  if (imp_dbh->has_transactions)\n  {\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n    if (mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n      if (mysql_rollback(imp_dbh->pmysql))\n#endif\n      {\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n        return FALSE;\n      }\n  }\n  else\n    do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n             \"Rollback ineffective because transactions are not available\" ,NULL);\n  return TRUE;\n}\n\n/*\n ***************************************************************************\n *\n *  Name:    dbd_db_disconnect\n *\n *  Purpose: Disconnect a database handle from its database\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh)\n{\n#ifdef dTHR\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(dbh);\n\n  /* We assume that disconnect will always work       */\n  /* since most errors imply already disconnected.    */\n  DBIc_ACTIVE_off(imp_dbh);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"imp_dbh->pmysql: %p\\n\",\n\t\t              imp_dbh->pmysql);\n  mysql_close(imp_dbh->pmysql );\n\n  /* We don't free imp_dbh since a reference still exists    */\n  /* The DESTROY method is the only one to 'free' memory.    */\n  return TRUE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_discon_all\n *\n *  Purpose: Disconnect all database handles at shutdown time\n *\n *  Input:   dbh - database handle being disconnected\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error has already\n *           been called in the latter case\n *\n **************************************************************************/\n\nint dbd_discon_all (SV *drh, imp_drh_t *imp_drh) {\n#if defined(dTHR)\n  dTHR;\n#endif\n  dTHX;\n  D_imp_xxh(drh);\n\n#if defined(DBD_MYSQL_EMBEDDED)\n  if (imp_drh->embedded.state)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Stop embedded server\\n\");\n\n    mysql_server_end();\n    if (imp_drh->embedded.groups)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.groups);\n      imp_drh->embedded.groups = NULL;\n    }\n\n    if (imp_drh->embedded.args)\n    {\n      (void) SvREFCNT_dec(imp_drh->embedded.args);\n      imp_drh->embedded.args = NULL;\n    }\n\n\n  }\n#else\n  mysql_server_end();\n#endif\n\n  /* The disconnect_all concept is flawed and needs more work */\n  if (!PL_dirty && !SvTRUE(perl_get_sv(\"DBI::PERL_ENDING\",0))) {\n    sv_setiv(DBIc_ERR(imp_drh), (IV)1);\n    sv_setpv(DBIc_ERRSTR(imp_drh),\n             (char*)\"disconnect_all not implemented\");\n    /* NO EFFECT DBIh_EVENT2(drh, ERROR_event,\n      DBIc_ERR(imp_drh), DBIc_ERRSTR(imp_drh)); */\n    return FALSE;\n  }\n  PL_perl_destruct_level = 0;\n  return FALSE;\n}\n\n\n/****************************************************************************\n *\n *  Name:    dbd_db_destroy\n *\n *  Purpose: Our part of the dbh destructor\n *\n *  Input:   dbh - database handle being destroyed\n *           imp_dbh - drivers private database handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh) {\n\n    /*\n     *  Being on the safe side never hurts ...\n     */\n  if (DBIc_ACTIVE(imp_dbh))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      if (!DBIc_has(imp_dbh, DBIcf_AutoCommit))\n#if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION\n        if ( mysql_real_query(imp_dbh->pmysql, \"ROLLBACK\", 8))\n#else\n        if (mysql_rollback(imp_dbh->pmysql))\n#endif\n            do_error(dbh, TX_ERR_ROLLBACK,\"ROLLBACK failed\" ,NULL);\n    }\n    dbd_db_disconnect(dbh, imp_dbh);\n  }\n  Safefree(imp_dbh->pmysql);\n\n  /* Tell DBI, that dbh->destroy must no longer be called */\n  DBIc_off(imp_dbh, DBIcf_IMPSET);\n}\n\n/* \n ***************************************************************************\n *\n *  Name:    dbd_db_STORE_attrib\n *\n *  Purpose: Function for storing dbh attributes; we currently support\n *           just nothing. :-)\n *\n *  Input:   dbh - database handle being modified\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *           valuesv - the attribute value\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\nint\ndbd_db_STORE_attrib(\n                    SV* dbh,\n                    imp_dbh_t* imp_dbh,\n                    SV* keysv,\n                    SV* valuesv\n                   )\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  SV *cachesv = Nullsv;\n  int cacheit = FALSE;\n  const bool bool_value = SvTRUE(valuesv);\n\n  if (kl==10 && strEQ(key, \"AutoCommit\"))\n  {\n    if (imp_dbh->has_transactions)\n    {\n      bool oldval = DBIc_has(imp_dbh,DBIcf_AutoCommit) ? 1 : 0;\n\n      if (bool_value == oldval)\n        return TRUE;\n\n      /* if setting AutoCommit on ... */\n      if (!imp_dbh->no_autocommit_cmd)\n      {\n        if (\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n            mysql_autocommit(imp_dbh->pmysql, bool_value)\n#else\n            mysql_real_query(imp_dbh->pmysql,\n                             bool_value ? \"SET AUTOCOMMIT=1\" : \"SET AUTOCOMMIT=0\",\n                             16)\n#endif\n           )\n        {\n          do_error(dbh, TX_ERR_AUTOCOMMIT,\n                   bool_value ?\n                   \"Turning on AutoCommit failed\" :\n                   \"Turning off AutoCommit failed\"\n                   ,NULL);\n          return TRUE;  /* TRUE means we handled it - important to avoid spurious errors */\n        }\n      }\n      DBIc_set(imp_dbh, DBIcf_AutoCommit, bool_value);\n    }\n    else\n    {\n      /*\n       *  We do support neither transactions nor \"AutoCommit\".\n       *  But we stub it. :-)\n      */\n      if (!bool_value)\n      {\n        do_error(dbh, JW_ERR_NOT_IMPLEMENTED,\n                 \"Transactions not supported by database\" ,NULL);\n        croak(\"Transactions not supported by database\");\n      }\n    }\n  }\n  else if (kl == 16 && strEQ(key,\"mysql_use_result\"))\n    imp_dbh->use_mysql_use_result = bool_value;\n  else if (kl == 20 && strEQ(key,\"mysql_auto_reconnect\"))\n    imp_dbh->auto_reconnect = bool_value;\n  else if (kl == 20 && strEQ(key, \"mysql_server_prepare\"))\n    imp_dbh->use_server_side_prepare = bool_value;\n  else if (kl == 23 && strEQ(key,\"mysql_no_autocommit_cmd\"))\n    imp_dbh->no_autocommit_cmd = bool_value;\n  else if (kl == 24 && strEQ(key,\"mysql_bind_type_guessing\"))\n    imp_dbh->bind_type_guessing = bool_value;\n  else if (kl == 31 && strEQ(key,\"mysql_bind_comment_placeholders\"))\n    imp_dbh->bind_type_guessing = bool_value;\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  else if (kl == 17 && strEQ(key, \"mysql_enable_utf8\"))\n    imp_dbh->enable_utf8 = bool_value;\n  else if (kl == 20 && strEQ(key, \"mysql_enable_utf8mb4\"))\n    imp_dbh->enable_utf8mb4 = bool_value;\n#endif\n#if FABRIC_SUPPORT\n  else if (kl == 22 && strEQ(key, \"mysql_fabric_opt_group\"))\n    mysql_options(imp_dbh->pmysql, FABRIC_OPT_GROUP, (void *)SvPVbyte_nolen(valuesv));\n  else if (kl == 29 && strEQ(key, \"mysql_fabric_opt_default_mode\"))\n  {\n    if (SvOK(valuesv)) {\n      STRLEN len;\n      const char *str = SvPVbyte(valuesv, len);\n      if ( len == 0 || ( len == 2 && (strnEQ(str, \"ro\", 3) || strnEQ(str, \"rw\", 3)) ) )\n        mysql_options(imp_dbh->pmysql, FABRIC_OPT_DEFAULT_MODE, len == 0 ? NULL : str);\n      else\n        croak(\"Valid settings for FABRIC_OPT_DEFAULT_MODE are 'ro', 'rw', or undef/empty string\");\n    }\n    else {\n      mysql_options(imp_dbh->pmysql, FABRIC_OPT_DEFAULT_MODE, NULL);\n    }\n  }\n  else if (kl == 21 && strEQ(key, \"mysql_fabric_opt_mode\"))\n  {\n    STRLEN len;\n    const char *str = SvPVbyte(valuesv, len);\n    if (len != 2 || (strnNE(str, \"ro\", 3) && strnNE(str, \"rw\", 3)))\n      croak(\"Valid settings for FABRIC_OPT_MODE are 'ro' or 'rw'\");\n\n    mysql_options(imp_dbh->pmysql, FABRIC_OPT_MODE, str);\n  }\n  else if (kl == 34 && strEQ(key, \"mysql_fabric_opt_group_credentials\"))\n  {\n    croak(\"'fabric_opt_group_credentials' is not supported\");\n  }\n#endif\n  else\n    return FALSE;\t\t\t\t/* Unknown key */\n\n  if (cacheit) /* cache value for later DBI 'quick' fetch? */\n    (void)hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);\n  return TRUE;\n}\n\n/***************************************************************************\n *\n *  Name:    dbd_db_FETCH_attrib\n *\n *  Purpose: Function for fetching dbh attributes\n *\n *  Input:   dbh - database handle being queried\n *           imp_dbh - drivers private database handle data\n *           keysv - the attribute name\n *\n *  Returns: An SV*, if successful; NULL otherwise\n *\n *  Notes:   Do not forget to call sv_2mortal in the former case!\n *\n **************************************************************************/\nstatic SV*\nmy_ulonglong2str(pTHX_ my_ulonglong val)\n{\n  char buf[64];\n  char *ptr = buf + sizeof(buf) - 1;\n\n  if (val == 0)\n    return newSVpvn(\"0\", 1);\n\n  *ptr = '\\0';\n  while (val > 0)\n  {\n    *(--ptr) = ('0' + (val % 10));\n    val = val / 10;\n  }\n  return newSVpvn(ptr, (buf+ sizeof(buf) - 1) - ptr);\n}\n\nSV* dbd_db_FETCH_attrib(SV *dbh, imp_dbh_t *imp_dbh, SV *keysv)\n{\n  dTHX;\n  STRLEN kl;\n  char *key = SvPV(keysv, kl);\n  SV* result = NULL;\n  dbh= dbh;\n\n  switch (*key) {\n    case 'A':\n      if (strEQ(key, \"AutoCommit\"))\n      {\n        if (imp_dbh->has_transactions)\n          return sv_2mortal(boolSV(DBIc_has(imp_dbh,DBIcf_AutoCommit)));\n        /* Default */\n        return &PL_sv_yes;\n      }\n      break;\n  }\n  if (strncmp(key, \"mysql_\", 6) == 0) {\n    key = key+6;\n    kl = kl-6;\n  }\n\n  /* MONTY:  Check if kl should not be used or used everywhere */\n  switch(*key) {\n  case 'a':\n    if (kl == strlen(\"auto_reconnect\") && strEQ(key, \"auto_reconnect\"))\n      result= sv_2mortal(newSViv(imp_dbh->auto_reconnect));\n    break;\n  case 'b':\n    if (kl == strlen(\"bind_type_guessing\") &&\n        strEQ(key, \"bind_type_guessing\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_type_guessing));\n    }\n    else if (kl == strlen(\"bind_comment_placeholders\") &&\n        strEQ(key, \"bind_comment_placeholders\"))\n    {\n      result = sv_2mortal(newSViv(imp_dbh->bind_comment_placeholders));\n    }\n    break;\n  case 'c':\n    if (kl == 10 && strEQ(key, \"clientinfo\"))\n    {\n      const char* clientinfo = mysql_get_client_info();\n      result= clientinfo ?\n        sv_2mortal(newSVpvn(clientinfo, strlen(clientinfo))) : &PL_sv_undef;\n    }\n    else if (kl == 13 && strEQ(key, \"clientversion\"))\n    {\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_client_version()));\n    }\n    break;\n  case 'e':\n    if (strEQ(key, \"errno\"))\n      result= sv_2mortal(newSViv((IV)mysql_errno(imp_dbh->pmysql)));\n    else if ( strEQ(key, \"error\") || strEQ(key, \"errmsg\"))\n    {\n    /* Note that errmsg is obsolete, as of 2.09! */\n      const char* msg = mysql_error(imp_dbh->pmysql);\n      result= sv_2mortal(newSVpvn(msg, strlen(msg)));\n    }\n    /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n    else if (kl == strlen(\"enable_utf8mb4\") && strEQ(key, \"enable_utf8mb4\"))\n        result = sv_2mortal(newSViv(imp_dbh->enable_utf8mb4));\n    else if (kl == strlen(\"enable_utf8\") && strEQ(key, \"enable_utf8\"))\n        result = sv_2mortal(newSViv(imp_dbh->enable_utf8));\n#endif\n    break;\n\n  case 'd':\n    if (strEQ(key, \"dbd_stats\"))\n    {\n      HV* hv = newHV();\n      (void)hv_store(\n               hv,\n               \"auto_reconnects_ok\",\n               strlen(\"auto_reconnects_ok\"),\n               newSViv(imp_dbh->stats.auto_reconnects_ok),\n               0\n              );\n      (void)hv_store(\n               hv,\n               \"auto_reconnects_failed\",\n               strlen(\"auto_reconnects_failed\"),\n               newSViv(imp_dbh->stats.auto_reconnects_failed),\n               0\n              );\n\n      result= sv_2mortal((newRV_noinc((SV*)hv)));\n    }\n\n  case 'h':\n    if (strEQ(key, \"hostinfo\"))\n    {\n      const char* hostinfo = mysql_get_host_info(imp_dbh->pmysql);\n      result= hostinfo ?\n        sv_2mortal(newSVpvn(hostinfo, strlen(hostinfo))) : &PL_sv_undef;\n    }\n    break;\n\n  case 'i':\n    if (strEQ(key, \"info\"))\n    {\n      const char* info = mysql_info(imp_dbh->pmysql);\n      result= info ? sv_2mortal(newSVpvn(info, strlen(info))) : &PL_sv_undef;\n    }\n    else if (kl == 8  &&  strEQ(key, \"insertid\"))\n      /* We cannot return an IV, because the insertid is a long. */\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n    break;\n  case 'n':\n    if (kl == strlen(\"no_autocommit_cmd\") &&\n        strEQ(key, \"no_autocommit_cmd\"))\n      result = sv_2mortal(newSViv(imp_dbh->no_autocommit_cmd));\n    break;\n\n  case 'p':\n    if (kl == 9  &&  strEQ(key, \"protoinfo\"))\n      result= sv_2mortal(newSViv(mysql_get_proto_info(imp_dbh->pmysql)));\n    break;\n\n  case 's':\n    if (kl == 10 && strEQ(key, \"serverinfo\")) {\n      const char* serverinfo = mysql_get_server_info(imp_dbh->pmysql);\n      result= serverinfo ?\n        sv_2mortal(newSVpvn(serverinfo, strlen(serverinfo))) : &PL_sv_undef;\n    } \n    else if (kl == 13 && strEQ(key, \"serverversion\"))\n      result= sv_2mortal(my_ulonglong2str(aTHX_ mysql_get_server_version(imp_dbh->pmysql)));\n    else if (strEQ(key, \"sock\"))\n      result= sv_2mortal(newSViv(PTR2IV(imp_dbh->pmysql)));\n    else if (strEQ(key, \"sockfd\"))\n      result= sv_2mortal(newSViv((IV) imp_dbh->pmysql->net.fd));\n    else if (strEQ(key, \"stat\"))\n    {\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpvn(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (strEQ(key, \"stats\"))\n    {\n      /* Obsolete, as of 2.09 */\n      const char* stats = mysql_stat(imp_dbh->pmysql);\n      result= stats ?\n        sv_2mortal(newSVpvn(stats, strlen(stats))) : &PL_sv_undef;\n    }\n    else if (kl == 14 && strEQ(key,\"server_prepare\"))\n        result= sv_2mortal(newSViv((IV) imp_dbh->use_server_side_prepare));\n    break;\n\n  case 't':\n    if (kl == 9  &&  strEQ(key, \"thread_id\"))\n      result= sv_2mortal(newSViv(mysql_thread_id(imp_dbh->pmysql)));\n    break;\n\n  case 'w':\n    if (kl == 13 && strEQ(key, \"warning_count\"))\n      result= sv_2mortal(newSViv(mysql_warning_count(imp_dbh->pmysql)));\n    break;\n  case 'u':\n    if (strEQ(key, \"use_result\"))\n    {\n      result= sv_2mortal(newSViv((IV) imp_dbh->use_mysql_use_result));\n    }\n    break;\n  }\n\n  if (result== NULL)\n    return Nullsv;\n\n  return result;\n}\n\n\n/* \n **************************************************************************\n *\n *  Name:    dbd_st_prepare\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *           statement - pointer to string with SQL statement\n *           attribs - statement attributes, currently not in use\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_prepare(\n  SV *sth,\n  imp_sth_t *imp_sth,\n  char *statement,\n  SV *attribs)\n{\n  int i;\n  SV **svp;\n  dTHX;\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n#if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  char *str_ptr, *str_last_ptr;\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n  int limit_flag=0;\n#endif\n#endif\n  int prepare_retval;\n  MYSQL_BIND *bind, *bind_end;\n  imp_sth_phb_t *fbind;\n#endif\n  D_imp_xxh(sth);\n  D_imp_dbh_from_sth;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\n                  MYSQL_VERSION_ID, statement);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\n  if (attribs)\n  {\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\n    imp_sth->use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\n\n    if(svp && SvTRUE(*svp)) {\n#if MYSQL_ASYNC\n        imp_sth->is_async = TRUE;\n        imp_sth->use_server_side_prepare = FALSE;\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        return 0;\n#endif\n    }\n  }\n\n  imp_sth->fetch_done= 0;\n#endif\n\n  imp_sth->done_desc= 0;\n  imp_sth->result= NULL;\n  imp_sth->currow= 0;\n\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\n  imp_sth->use_mysql_use_result= svp ?\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\n\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n    imp_sth->av_attr[i]= Nullav;\n\n  /*\n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets(sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set, check restrictions\\n\");\n    /*\n      This code is here because placeholder support is not implemented for\n      statements with :-\n      1. LIMIT < 5.0.7\n      2. CALL < 5.5.3 (Added support for out & inout parameters)\n      In these cases we have to disable server side prepared statements\n      NOTE: These checks could cause a false positive on statements which\n      include columns / table names that match \"call \" or \" limit \"\n    */ \n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n                    \"\\t\\tneed to test for LIMIT & CALL\\n\");\n#else\n                    \"\\t\\tneed to test for restrictions\\n\");\n#endif\n    str_last_ptr = statement + strlen(statement);\n    for (str_ptr= statement; str_ptr < str_last_ptr; str_ptr++)\n    {\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n      /*\n        Place holders not supported in LIMIT's\n      */\n      if (limit_flag)\n      {\n        if (*str_ptr == '?')\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tLIMIT and ? found, set to use_server_side_prepare=0\\n\");\n          /* ... then we do not want to try server side prepare (use emulation) */\n          imp_sth->use_server_side_prepare= 0;\n          break;\n        }\n      }\n      else if (str_ptr < str_last_ptr - 6 &&\n          isspace(*(str_ptr + 0)) &&\n          tolower(*(str_ptr + 1)) == 'l' &&\n          tolower(*(str_ptr + 2)) == 'i' &&\n          tolower(*(str_ptr + 3)) == 'm' &&\n          tolower(*(str_ptr + 4)) == 'i' &&\n          tolower(*(str_ptr + 5)) == 't' &&\n          isspace(*(str_ptr + 6)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"LIMIT set limit flag to 1\\n\");\n        limit_flag= 1;\n      }\n#endif\n      /*\n        Place holders not supported in CALL's\n      */\n      if (str_ptr < str_last_ptr - 4 &&\n           tolower(*(str_ptr + 0)) == 'c' &&\n           tolower(*(str_ptr + 1)) == 'a' &&\n           tolower(*(str_ptr + 2)) == 'l' &&\n           tolower(*(str_ptr + 3)) == 'l' &&\n           isspace(*(str_ptr + 4)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Disable PS mode for CALL()\\n\");\n        imp_sth->use_server_side_prepare= 0;\n        break;\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set\\n\");\n    /* do we really need this? If we do, we should return, not just continue */\n    if (imp_sth->stmt)\n      fprintf(stderr,\n              \"ERROR: Trying to prepare new stmt while we have \\\n              already not closed one \\n\");\n\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if (! imp_sth->stmt)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\n                      mysql_errno(imp_dbh->pmysql),\n                      mysql_error(imp_dbh->pmysql));\n    }\n\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\n                                       statement,\n                                       strlen(statement));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\n                      prepare_retval);\n\n    if (prepare_retval)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\n                      mysql_stmt_errno(imp_sth->stmt),\n                      mysql_stmt_error(imp_sth->stmt));\n\n      /* For commands that are not supported by server side prepared statement\n         mechanism lets try to pass them through regular API */\n      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_sqlstate(imp_dbh->pmysql));\n        mysql_stmt_close(imp_sth->stmt);\n        imp_sth->stmt= NULL;\n        return FALSE;\n      }\n    }\n    else\n    {\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\n      /* mysql_stmt_param_count */\n\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\n      {\n        /* Allocate memory for bind variables */\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->has_been_bound=  0;\n\n        /* Initialize ph variables with  NULL values */\n        for (i= 0,\n             bind=      imp_sth->bind,\n             fbind=     imp_sth->fbind,\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\n             bind < bind_end ;\n             bind++, fbind++, i++ )\n        {\n          bind->buffer_type=  MYSQL_TYPE_STRING;\n          bind->buffer=       NULL;\n          bind->length=       &(fbind->length);\n          bind->is_null=      (char*) &(fbind->is_null);\n          fbind->is_null=     1;\n          fbind->length=      0;\n        }\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  /* Count the number of parameters (driver, vs server-side) */\n  if (imp_sth->use_server_side_prepare == 0)\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                            imp_dbh->bind_comment_placeholders);\n#else\n  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                          imp_dbh->bind_comment_placeholders);\n#endif\n\n  /* Allocate memory for parameters */\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\n  DBIc_IMPSET_on(imp_sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\n  return 1;\n}\n\n/***************************************************************************\n * Name: dbd_st_free_result_sets\n *\n * Purpose: Clean-up single or multiple result sets (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 ok\n *          0 error\n *************************************************************************/\nint mysql_st_free_result_sets (SV * sth, imp_sth_t * imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n  int next_result_rc= -1;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t>- dbd_st_free_result_sets\\n\");\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  do\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets RC %d\\n\", next_result_rc);\n\n    if (next_result_rc == 0)\n    {\n      if (!(imp_sth->result = mysql_use_result(imp_dbh->pmysql)))\n      {\n        /* Check for possible error */\n        if (mysql_field_count(imp_dbh->pmysql))\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets ERROR: %s\\n\",\n                                  mysql_error(imp_dbh->pmysql));\n\n          do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n                   mysql_sqlstate(imp_dbh->pmysql));\n          return 0;\n        }\n      }\n    }\n    if (imp_sth->result)\n    {\n      mysql_free_result(imp_sth->result);\n      imp_sth->result=NULL;\n    }\n  } while ((next_result_rc=mysql_next_result(imp_dbh->pmysql))==0);\n\n  if (next_result_rc > 0)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets: Error while processing multi-result set: %s\\n\",\n                    mysql_error(imp_dbh->pmysql));\n\n    do_error(sth, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n  }\n\n#else\n\n  if (imp_sth->result)\n  {\n    mysql_free_result(imp_sth->result);\n    imp_sth->result=NULL;\n  }\n#endif\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_free_result_sets\\n\");\n\n  return 1;\n}\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n/***************************************************************************\n * Name: dbd_st_more_results\n *\n * Purpose: Move onto the next result set (if any)\n *\n * Inputs: sth - Statement handle\n *         imp_sth - driver's private statement handle\n *\n * Returns: 1 if there are more results sets\n *          0 if there are not\n *         -1 for errors.\n *************************************************************************/\nint dbd_st_more_results(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n\n  int use_mysql_use_result=imp_sth->use_mysql_use_result;\n  int next_result_return_code, i;\n  MYSQL* svsock= imp_dbh->pmysql;\n\n  if (!SvROK(sth) || SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  if (!mysql_more_results(svsock))\n  {\n    /* No more pending result set(s)*/\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t    \"\\n      <- dbs_st_more_results no more results\\n\");\n    return 0;\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    do_warn(sth, JW_ERR_NOT_IMPLEMENTED,\n            \"Processing of multiple result set is not possible with server side prepare\");\n    return 0;\n  }\n\n  /*\n   *  Free cached array attributes\n   */\n  for (i= 0; i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  /* Release previous MySQL result*/\n  if (imp_sth->result)\n    mysql_free_result(imp_sth->result);\n\n  if (DBIc_ACTIVE(imp_sth))\n    DBIc_ACTIVE_off(imp_sth);\n\n  next_result_return_code= mysql_next_result(svsock);\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  /*\n    mysql_next_result returns\n      0 if there are more results\n     -1 if there are no more results\n     >0 if there was an error\n   */\n  if (next_result_return_code > 0)\n  {\n    do_error(sth, mysql_errno(svsock), mysql_error(svsock),\n             mysql_sqlstate(svsock));\n\n    return 0;\n  }\n  else if(next_result_return_code == -1)                                                                                                                  \n  {                                                                                                                                                       \n    return 0;                                                                                                                                             \n  }  \n  else\n  {\n    /* Store the result from the Query */\n    imp_sth->result = use_mysql_use_result ?\n     mysql_use_result(svsock) : mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n    {\n      do_error(sth, mysql_errno(svsock), mysql_error(svsock), \n               mysql_sqlstate(svsock));\n      return 0;\n    }\n\n    imp_sth->row_num= mysql_affected_rows(imp_dbh->pmysql);\n\n    if (imp_sth->result == NULL)\n    {\n      /* No \"real\" rowset*/\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIS->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n\t\t\t               sv_2mortal(newSViv(0)));\n      return 1;\n    }\n    else\n    {\n      /* We have a new rowset */\n      imp_sth->currow=0;\n\n\n      /* delete cached handle attributes */\n      /* XXX should be driven by a list to ease maintenance */\n      (void)hv_delete((HV*)SvRV(sth), \"NAME\", 4, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"NULLABLE\", 8, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"PRECISION\", 9, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"SCALE\", 5, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"TYPE\", 4, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_insertid\", 14, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_auto_increment\", 23, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_blob\", 13, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_key\", 12, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_num\", 12, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_is_pri_key\", 16, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_length\", 12, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_max_length\", 16, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_table\", 11, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type\", 10, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_type_name\", 15, G_DISCARD);\n      (void)hv_delete((HV*)SvRV(sth), \"mysql_warning_count\", 20, G_DISCARD);\n\n      /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */\n      DBIc_NUM_FIELDS(imp_sth)= 0; /* for DBI <= 1.53 */\n      DBIc_DBISTATE(imp_sth)->set_attr_k(sth, sv_2mortal(newSVpvn(\"NUM_OF_FIELDS\",13)), 0,\n          sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))\n      );\n\n      DBIc_ACTIVE_on(imp_sth);\n\n      imp_sth->done_desc = 0;\n    }\n    imp_dbh->pmysql->net.last_errno= 0;\n    return 1;\n  }\n}\n#endif\n/**************************************************************************\n *\n *  Name:    mysql_st_internal_execute\n *\n *  Purpose: Internal version for executing a statement, called both from\n *           within the \"do\" and the \"execute\" method.\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n\nmy_ulonglong mysql_st_internal_execute(\n                                       SV *h, /* could be sth or dbh */\n                                       SV *statement,\n                                       SV *attribs,\n                                       int num_params,\n                                       imp_sth_ph_t *params,\n                                       MYSQL_RES **result,\n                                       MYSQL *svsock,\n                                       int use_mysql_use_result\n                                      )\n{\n  dTHX;\n  bool bind_type_guessing= FALSE;\n  bool bind_comment_placeholders= TRUE;\n  STRLEN slen;\n  char *sbuf = SvPV(statement, slen);\n  char *table;\n  char *salloc;\n  int htype;\n#if MYSQL_ASYNC\n  bool async = FALSE;\n#endif\n  my_ulonglong rows= 0;\n  /* thank you DBI.c for this info! */\n  D_imp_xxh(h);\n  attribs= attribs;\n\n  htype= DBIc_TYPE(imp_xxh);\n  /*\n    It is important to import imp_dbh properly according to the htype\n    that it is! Also, one might ask why bind_type_guessing is assigned\n    in each block. Well, it's because D_imp_ macros called in these\n    blocks make it so imp_dbh is not \"visible\" or defined outside of the\n    if/else (when compiled, it fails for imp_dbh not being defined).\n  */\n  /* h is a dbh */\n  if (htype == DBIt_DB)\n  {\n    D_imp_dbh(h);\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh && imp_dbh->bind_type_guessing)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = (bool) (imp_dbh->async_query_in_flight != NULL);\n#endif\n  }\n  /* h is a sth */\n  else\n  {\n    D_imp_sth(h);\n    D_imp_dbh_from_sth;\n    /* if imp_dbh is not available, it causes segfault (proper) on OpenBSD */\n    if (imp_dbh)\n    {\n      bind_type_guessing= imp_dbh->bind_type_guessing;\n      bind_comment_placeholders= imp_dbh->bind_comment_placeholders;\n    }\n#if MYSQL_ASYNC\n    async = imp_sth->is_async;\n    if(async) {\n        imp_dbh->async_query_in_flight = imp_sth;\n    } else {\n        imp_dbh->async_query_in_flight = NULL;\n    }\n#endif\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"mysql_st_internal_execute MYSQL_VERSION_ID %d\\n\",\n                  MYSQL_VERSION_ID );\n\n  salloc= parse_params(imp_xxh,\n                              aTHX_ svsock,\n                              sbuf,\n                              &slen,\n                              params,\n                              num_params,\n                              bind_type_guessing,\n                              bind_comment_placeholders);\n\n  if (salloc)\n  {\n    sbuf= salloc;\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Binding parameters: %s\\n\", sbuf);\n  }\n\n  if (slen >= 11 && (!strncmp(sbuf, \"listfields \", 11) ||\n                     !strncmp(sbuf, \"LISTFIELDS \", 11)))\n  {\n    /* remove pre-space */\n    slen-= 10;\n    sbuf+= 10;\n    while (slen && isspace(*sbuf)) { --slen;  ++sbuf; }\n\n    if (!slen)\n    {\n      do_error(h, JW_ERR_QUERY, \"Missing table name\" ,NULL);\n      return -2;\n    }\n    if (!(table= malloc(slen+1)))\n    {\n      do_error(h, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      return -2;\n    }\n\n    strncpy(table, sbuf, slen);\n    sbuf= table;\n\n    while (slen && !isspace(*sbuf))\n    {\n      --slen;\n      ++sbuf;\n    }\n    *sbuf++= '\\0';\n\n    *result= mysql_list_fields(svsock, table, NULL);\n\n    free(table);\n\n    if (!(*result))\n    {\n      do_error(h, mysql_errno(svsock), mysql_error(svsock)\n               ,mysql_sqlstate(svsock));\n      return -2;\n    }\n\n    return 0;\n  }\n\n#if MYSQL_ASYNC\n  if(async) {\n    if((mysql_send_query(svsock, sbuf, slen)) &&\n       (!mysql_db_reconnect(h) ||\n        (mysql_send_query(svsock, sbuf, slen))))\n    {\n        rows = -2;\n    } else {\n        rows = 0;\n    }\n  } else {\n#endif\n      if ((mysql_real_query(svsock, sbuf, slen))  &&\n          (!mysql_db_reconnect(h)  ||\n           (mysql_real_query(svsock, sbuf, slen))))\n      {\n        rows = -2;\n      } else {\n          /** Store the result from the Query */\n          *result= use_mysql_use_result ?\n            mysql_use_result(svsock) : mysql_store_result(svsock);\n\n          if (mysql_errno(svsock))\n            rows = -2;\n          else if (*result)\n            rows = mysql_num_rows(*result);\n          else {\n            rows = mysql_affected_rows(svsock);\n            /* mysql_affected_rows(): -1 indicates that the query returned an error */\n            if (rows == (my_ulonglong)-1)\n              rows = -2;\n          }\n      }\n#if MYSQL_ASYNC\n  }\n#endif\n\n  if (salloc)\n    Safefree(salloc);\n\n  if(rows == (my_ulonglong)-2) {\n    do_error(h, mysql_errno(svsock), mysql_error(svsock), \n             mysql_sqlstate(svsock));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"IGNORING ERROR errno %d\\n\", mysql_errno(svsock));\n  }\n  return(rows);\n}\n\n /**************************************************************************\n *\n *  Name:    mysql_st_internal_execute41\n *\n *  Purpose: Internal version for executing a prepared statement, called both\n *           from within the \"do\" and the \"execute\" method.\n *           MYSQL 4.1 API\n *\n *\n *  Inputs:  h - object handle, for storing error messages\n *           statement - query being executed\n *           attribs - statement attributes, currently ignored\n *           num_params - number of parameters being bound\n *           params - parameter array\n *           result - where to store results, if any\n *           svsock - socket connected to the database\n *\n **************************************************************************/\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\nmy_ulonglong mysql_st_internal_execute41(\n                                         SV *sth,\n                                         int num_params,\n                                         MYSQL_RES **result,\n                                         MYSQL_STMT *stmt,\n                                         MYSQL_BIND *bind,\n                                         int *has_been_bound\n                                        )\n{\n  int i;\n  enum enum_field_types enum_type;\n  dTHX;\n  int execute_retval;\n  my_ulonglong rows=0;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t-> mysql_st_internal_execute41\\n\");\n\n  /* free result if exists */\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n\n  /*\n    If were performed any changes with ph variables\n    we have to rebind them\n  */\n\n  if (num_params > 0 && !(*has_been_bound))\n  {\n    if (mysql_stmt_bind_param(stmt,bind))\n      goto error;\n\n    *has_been_bound= 1;\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_st_internal_execute41 calling mysql_execute with %d num_params\\n\",\n                  num_params);\n\n  execute_retval= mysql_stmt_execute(stmt);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tmysql_stmt_execute returned %d\\n\",\n                  execute_retval);\n  if (execute_retval)\n    goto error;\n\n  /*\n   This statement does not return a result set (INSERT, UPDATE...)\n  */\n  if (!(*result= mysql_stmt_result_metadata(stmt)))\n  {\n    if (mysql_stmt_errno(stmt))\n      goto error;\n\n    rows= mysql_stmt_affected_rows(stmt);\n\n    /* mysql_stmt_affected_rows(): -1 indicates that the query returned an error */\n    if (rows == (my_ulonglong)-1)\n      goto error;\n  }\n  /*\n    This statement returns a result set (SELECT...)\n  */\n  else\n  {\n    for (i = mysql_stmt_field_count(stmt) - 1; i >=0; --i) {\n        enum_type = mysql_to_perl_type(stmt->fields[i].type);\n        if (enum_type != MYSQL_TYPE_DOUBLE && enum_type != MYSQL_TYPE_LONG && enum_type != MYSQL_TYPE_BIT)\n        {\n            /* mysql_stmt_store_result to update MYSQL_FIELD->max_length */\n            my_bool on = 1;\n            mysql_stmt_attr_set(stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &on);\n            break;\n        }\n    }\n    /* Get the total rows affected and return */\n    if (mysql_stmt_store_result(stmt))\n      goto error;\n    else\n      rows= mysql_stmt_num_rows(stmt);\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_internal_execute_41 returning %llu rows\\n\",\n                  rows);\n  return(rows);\n\nerror:\n  if (*result)\n  {\n    mysql_free_result(*result);\n    *result= 0;\n  }\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"     errno %d err message %s\\n\",\n                  mysql_stmt_errno(stmt),\n                  mysql_stmt_error(stmt));\n  do_error(sth, mysql_stmt_errno(stmt), mysql_stmt_error(stmt),\n           mysql_stmt_sqlstate(stmt));\n  mysql_stmt_reset(stmt);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t<- mysql_st_internal_execute41\\n\");\n  return -2;\n\n}\n#endif\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_execute\n *\n *  Purpose: Called for preparing an SQL statement; our part of the\n *           statement handle constructor\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_execute(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  char actual_row_num[64];\n  int i;\n  SV **statement;\n  D_imp_dbh_from_sth;\n  D_imp_xxh(sth);\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  ASYNC_CHECK_RETURN(sth, -2);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n      \" -> dbd_st_execute for %p\\n\", sth);\n\n  if (!SvROK(sth)  ||  SvTYPE(SvRV(sth)) != SVt_PVHV)\n    croak(\"Expected hash array\");\n\n  /* Free cached array attributes */\n  for (i= 0;  i < AV_ATTRIB_LAST;  i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n\n    imp_sth->av_attr[i]= Nullav;\n  }\n\n  statement= hv_fetch((HV*) SvRV(sth), \"Statement\", 9, FALSE);\n\n  /* \n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets (sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare && ! imp_sth->use_mysql_use_result)\n  {\n    imp_sth->row_num= mysql_st_internal_execute41(\n                                                  sth,\n                                                  DBIc_NUM_PARAMS(imp_sth),\n                                                  &imp_sth->result,\n                                                  imp_sth->stmt,\n                                                  imp_sth->bind,\n                                                  &imp_sth->has_been_bound\n                                                 );\n  }\n  else {\n#endif\n    imp_sth->row_num= mysql_st_internal_execute(\n                                                sth,\n                                                *statement,\n                                                NULL,\n                                                DBIc_NUM_PARAMS(imp_sth),\n                                                imp_sth->params,\n                                                &imp_sth->result,\n                                                imp_dbh->pmysql,\n                                                imp_sth->use_mysql_use_result\n                                               );\n#if MYSQL_ASYNC\n    if(imp_dbh->async_query_in_flight) {\n        DBIc_ACTIVE_on(imp_sth);\n        return 0;\n    }\n#endif\n  }\n\n  if (imp_sth->row_num+1 != (my_ulonglong)-1)\n  {\n    if (!imp_sth->result)\n    {\n      imp_sth->insertid= mysql_insert_id(imp_dbh->pmysql);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (mysql_more_results(imp_dbh->pmysql))\n        DBIc_ACTIVE_on(imp_sth);\n#endif\n    }\n    else\n    {\n      /** Store the result in the current statement handle */\n      DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n      DBIc_ACTIVE_on(imp_sth);\n      if (!imp_sth->use_server_side_prepare)\n        imp_sth->done_desc= 0;\n      imp_sth->fetch_done= 0;\n    }\n  }\n\n  imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    /* \n      PerlIO_printf doesn't always handle imp_sth->row_num %llu \n      consistently!!\n    */\n    sprintf(actual_row_num, \"%llu\", imp_sth->row_num);\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \" <- dbd_st_execute returning imp_sth->row_num %s\\n\",\n                  actual_row_num);\n  }\n\n  return (int)imp_sth->row_num;\n}\n\n /**************************************************************************\n *\n *  Name:    dbd_describe\n *\n *  Purpose: Called from within the fetch method to describe the result\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - our part of the statement handle, there's no\n *               need for supplying both; Tim just doesn't remove it\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_describe(SV* sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  D_imp_xxh(sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t--> dbd_describe\\n\");\n\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    int i;\n    int col_type;\n    int num_fields= DBIc_NUM_FIELDS(imp_sth);\n    imp_sth_fbh_t *fbh;\n    MYSQL_BIND *buffer;\n    MYSQL_FIELD *fields;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_describe() num_fields %d\\n\",\n                    num_fields);\n\n    if (imp_sth->done_desc)\n      return TRUE;\n\n    if (!num_fields || !imp_sth->result)\n    {\n      /* no metadata */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"no metadata information while trying describe result set\",\n               NULL);\n      return 0;\n    }\n\n    /* allocate fields buffers  */\n    if (  !(imp_sth->fbh= alloc_fbuffer(num_fields))\n          || !(imp_sth->buffer= alloc_bind(num_fields)) )\n    {\n      /* Out of memory */\n      do_error(sth, JW_ERR_SEQUENCE,\n               \"Out of memory in dbd_sescribe()\",NULL);\n      return 0;\n    }\n\n    fields= mysql_fetch_fields(imp_sth->result);\n\n    for (\n         fbh= imp_sth->fbh, buffer= (MYSQL_BIND*)imp_sth->buffer, i= 0;\n         i < num_fields;\n         i++, fbh++, buffer++\n        )\n    {\n      /* get the column type */\n      col_type = fields ? fields[i].type : MYSQL_TYPE_STRING;\n\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\ti %d col_type %d fbh->length %lu\\n\",\n                      i, col_type, fbh->length);\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tfields[i].length %lu fields[i].max_length %lu fields[i].type %d fields[i].charsetnr %d\\n\",\n                      fields[i].length, fields[i].max_length, fields[i].type,\n                      fields[i].charsetnr);\n      }\n      fbh->charsetnr = fields[i].charsetnr;\n#if MYSQL_VERSION_ID < FIELD_CHARSETNR_VERSION \n      fbh->flags     = fields[i].flags;\n#endif\n\n      buffer->buffer_type= mysql_to_perl_type(col_type);\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\",\n                      col_type);\n      buffer->length= &(fbh->length);\n      buffer->is_null= (my_bool*) &(fbh->is_null);\n      buffer->error= (my_bool*) &(fbh->error);\n\n      switch (buffer->buffer_type) {\n      case MYSQL_TYPE_DOUBLE:\n        buffer->buffer_length= sizeof(fbh->ddata);\n        buffer->buffer= (char*) &fbh->ddata;\n        break;\n\n      case MYSQL_TYPE_LONG:\n        buffer->buffer_length= sizeof(fbh->ldata);\n        buffer->buffer= (char*) &fbh->ldata;\n        buffer->is_unsigned= (fields[i].flags & UNSIGNED_FLAG) ? 1 : 0;\n        break;\n\n      case MYSQL_TYPE_BIT:\n        buffer->buffer_length= 8;\n        Newz(908, fbh->data, buffer->buffer_length, char);\n        buffer->buffer= (char *) fbh->data;\n        break;\n\n      default:\n        buffer->buffer_length= fields[i].max_length ? fields[i].max_length : 1;\n        Newz(908, fbh->data, buffer->buffer_length, char);\n        buffer->buffer= (char *) fbh->data;\n      }\n    }\n\n    if (mysql_stmt_bind_result(imp_sth->stmt, imp_sth->buffer))\n    {\n      do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n               mysql_stmt_error(imp_sth->stmt),\n               mysql_stmt_sqlstate(imp_sth->stmt));\n      return 0;\n    }\n  }\n#endif\n\n  imp_sth->done_desc= 1;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_describe\\n\");\n  return TRUE;\n}\n\n/**************************************************************************\n *\n *  Name:    dbd_st_fetch\n *\n *  Purpose: Called for fetching a result row\n *\n *  Input:   sth - statement handle being initialized\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: array of columns; the array is allocated by DBI via\n *           DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth), even the values\n *           of the array are prepared, we just need to modify them\n *           appropriately\n *\n **************************************************************************/\n\nAV*\ndbd_st_fetch(SV *sth, imp_sth_t* imp_sth)\n{\n  dTHX;\n  int num_fields, ChopBlanks, i, rc;\n  unsigned long *lengths;\n  AV *av;\n  int av_length, av_readonly;\n  MYSQL_ROW cols;\n  D_imp_dbh_from_sth;\n  MYSQL* svsock= imp_dbh->pmysql;\n  imp_sth_fbh_t *fbh;\n  D_imp_xxh(sth);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  MYSQL_BIND *buffer;\n#endif\n  MYSQL_FIELD *fields;\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t-> dbd_st_fetch\\n\");\n\n#if MYSQL_ASYNC\n  if(imp_dbh->async_query_in_flight) {\n      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {\n        return Nullav;\n      }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (!DBIc_ACTIVE(imp_sth) )\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"no statement executing\\n\",NULL);\n      return Nullav;\n    }\n\n    if (imp_sth->fetch_done)\n    {\n      do_error(sth, JW_ERR_SEQUENCE, \"fetch() but fetch already done\",NULL);\n      return Nullav;\n    }\n\n    if (!imp_sth->done_desc)\n    {\n      if (!dbd_describe(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE, \"Error while describe result set.\",\n                 NULL);\n        return Nullav;\n      }\n    }\n  }\n#endif\n\n  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\tdbd_st_fetch for %p, chopblanks %d\\n\",\n                  sth, ChopBlanks);\n\n  if (!imp_sth->result)\n  {\n    do_error(sth, JW_ERR_SEQUENCE, \"fetch() without execute()\" ,NULL);\n    return Nullav;\n  }\n\n  /* fix from 2.9008 */\n  imp_dbh->pmysql->net.last_errno = 0;\n\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch calling mysql_fetch\\n\");\n\n    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))\n    {\n      if (rc == 1)\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_stmt_sqlstate(imp_sth->stmt));\n\n#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 \n      if (rc == MYSQL_DATA_TRUNCATED) {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch data truncated\\n\");\n        goto process;\n      }\n#endif\n\n      if (rc == MYSQL_NO_DATA)\n      {\n        /* Update row_num to affected_rows value */\n        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);\n        imp_sth->fetch_done=1;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tdbd_st_fetch no data\\n\");\n      }\n\n      dbd_st_finish(sth, imp_sth);\n\n      return Nullav;\n    }\n\nprocess:\n    imp_sth->currow++;\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n    num_fields=mysql_stmt_field_count(imp_sth->stmt);\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\\n\",\n                    rc, num_fields);\n\n    for (\n         buffer= imp_sth->buffer,\n         fbh= imp_sth->fbh,\n         i= 0;\n         i < num_fields;\n         i++,\n         fbh++,\n         buffer++\n        )\n    {\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n      STRLEN len;\n\n      /* This is wrong, null is not being set correctly\n       * This is not the way to determine length (this would break blobs!)\n       */\n      if (fbh->is_null)\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n      else\n      {\n        /* In case of BLOB/TEXT fields we allocate only 8192 bytes\n           in dbd_describe() for data. Here we know real size of field\n           so we should increase buffer size and refetch column value\n        */\n        if (fbh->length > buffer->buffer_length || fbh->error)\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n              \"\\t\\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\\n\",\n              i, fbh->length, fbh->error);\n\n          Renew(fbh->data, fbh->length, char);\n          buffer->buffer_length= fbh->length;\n          buffer->buffer= (char *) fbh->data;\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tbefore buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n\n          /*TODO: Use offset instead of 0 to fetch only remain part of data*/\n          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))\n            do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                     mysql_stmt_error(imp_sth->stmt),\n                     mysql_stmt_sqlstate(imp_sth->stmt));\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {\n            int j;\n            int m = MIN(*buffer->length, buffer->buffer_length);\n            char *ptr = (char*)buffer->buffer;\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\t\\tafter buffer->buffer: \");\n            for (j = 0; j < m; j++) {\n              PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"%c\", *ptr++);\n            }\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"\\n\");\n          }\n        }\n\n        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */\n        /* Credit due to Georg - mysqli_api.c  ;) --PMG */\n        switch (buffer->buffer_type) {\n        case MYSQL_TYPE_DOUBLE:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch double data %f\\n\", fbh->ddata);\n          sv_setnv(sv, fbh->ddata);\n          break;\n\n        case MYSQL_TYPE_LONG:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tst_fetch int data %\"IVdf\", unsigned? %d\\n\",\n                          fbh->ldata, buffer->is_unsigned);\n          if (buffer->is_unsigned)\n            sv_setuv(sv, fbh->ldata);\n          else\n            sv_setiv(sv, fbh->ldata);\n\n          break;\n\n        case MYSQL_TYPE_BIT:\n          sv_setpvn(sv, fbh->data, fbh->length);\n\n          break;\n\n        default:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tERROR IN st_fetch_string\");\n          len= fbh->length;\n\t  /* ChopBlanks server-side prepared statement */\n          if (ChopBlanks)\n          {\n            /* \n              see bottom of:\n              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html\n            */\n            if (fbh->charsetnr != 63)\n              while (len && fbh->data[len-1] == ' ') { --len; }\n          }\n\t  /* END OF ChopBlanks */\n\n          sv_setpvn(sv, fbh->data, len);\n\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION \n  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)\n#else\n\tif ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))\n#endif\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n\n        }\n\n      }\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n\n    return av;\n  }\n  else\n  {\n#endif\n\n    imp_sth->currow++;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    {\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch result set details\\n\");\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\timp_sth->result=%p\\n\", imp_sth->result);\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_fields=%u\\n\",\n                    mysql_num_fields(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_num_rows=%llu\\n\",\n                    mysql_num_rows(imp_sth->result));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tmysql_affected_rows=%llu\\n\",\n                    mysql_affected_rows(imp_dbh->pmysql));\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch for %p, currow= %d\\n\",\n                    sth,imp_sth->currow);\n    }\n\n    if (!(cols= mysql_fetch_row(imp_sth->result)))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      {\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tdbd_st_fetch, no more rows to fetch\");\n      }\n      if (mysql_errno(imp_dbh->pmysql))\n        do_error(sth, mysql_errno(imp_dbh->pmysql),\n                 mysql_error(imp_dbh->pmysql),\n                 mysql_sqlstate(imp_dbh->pmysql));\n\n\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n      if (!mysql_more_results(svsock))\n#endif\n        dbd_st_finish(sth, imp_sth);\n      return Nullav;\n    }\n\n    num_fields= mysql_num_fields(imp_sth->result);\n    fields= mysql_fetch_fields(imp_sth->result);\n    lengths= mysql_fetch_lengths(imp_sth->result);\n\n    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)\n    {\n      av_length= av_len(av)+1;\n\n      if (av_length != num_fields)              /* Resize array if necessary */\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\\n\",\n                                   av_length, num_fields);\n\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, result fields(%d)\\n\",\n                                   DBIc_NUM_FIELDS(imp_sth));\n\n        av_readonly = SvREADONLY(av);\n\n        if (av_readonly)\n          SvREADONLY_off( av );              /* DBI sets this readonly */\n\n        while (av_length < num_fields)\n        {\n          av_store(av, av_length++, newSV(0));\n        }\n\n        while (av_length > num_fields)\n        {\n          SvREFCNT_dec(av_pop(av));\n          av_length--;\n        }\n        if (av_readonly)\n          SvREADONLY_on(av);\n      }\n    }\n\n    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);\n\n    for (i= 0;  i < num_fields; ++i)\n    {\n      char *col= cols[i];\n      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV\t*/\n\n      if (col)\n      {\n        STRLEN len= lengths[i];\n        if (ChopBlanks)\n        {\n          while (len && col[len-1] == ' ')\n          {\t--len; }\n        }\n\n        /* Set string value returned from mysql server */\n        sv_setpvn(sv, col, len);\n\n        switch (mysql_to_perl_type(fields[i].type)) {\n        case MYSQL_TYPE_DOUBLE:\n          /* Coerce to dobule and set scalar as NV */\n          (void) SvNV(sv);\n          SvNOK_only(sv);\n          break;\n\n        case MYSQL_TYPE_LONG:\n          /* Coerce to integer and set scalar as UV resp. IV */\n          if (fields[i].flags & UNSIGNED_FLAG)\n          {\n            (void) SvUV(sv);\n            SvIOK_only_UV(sv);\n          }\n          else\n          {\n            (void) SvIV(sv);\n            SvIOK_only(sv);\n          }\n          break;\n\n#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION\n        case MYSQL_TYPE_BIT:\n          /* Let it as binary string */\n          break;\n#endif\n\n        default:\n\t/* UTF8 */\n        /*HELMUT*/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n\n  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */\n        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)\n\t  sv_utf8_decode(sv);\n#endif\n\t/* END OF UTF8 */\n          break;\n        }\n      }\n      else\n        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */\n    }\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_fetch, %d cols\\n\", num_fields);\n    return av;\n\n#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION\n  }\n#endif\n\n}\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n/*\n  We have to fetch all data from stmt\n  There is may be useful for 2 cases:\n  1. st_finish when we have undef statement\n  2. call st_execute again when we have some unfetched data in stmt\n */\n\nint mysql_st_clean_cursor(SV* sth, imp_sth_t* imp_sth) {\n\n  if (DBIc_ACTIVE(imp_sth) && dbd_describe(sth, imp_sth) &&\n      !imp_sth->fetch_done)\n    mysql_stmt_free_result(imp_sth->stmt);\n  return 1;\n}\n#endif\n\n/***************************************************************************\n *\n *  Name:    dbd_st_finish\n *\n *  Purpose: Called for freeing a mysql result\n *\n *  Input:   sth - statement handle being finished\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error() will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_finish(SV* sth, imp_sth_t* imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n#if MYSQL_ASYNC\n  D_imp_dbh_from_sth;\n  if(imp_dbh->async_query_in_flight) {\n    mysql_db_async_result(sth, &imp_sth->result);\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n--> dbd_st_finish\\n\");\n  }\n\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (imp_sth && imp_sth->stmt)\n    {\n      if (!mysql_st_clean_cursor(sth, imp_sth))\n      {\n        do_error(sth, JW_ERR_SEQUENCE,\n                 \"Error happened while tried to clean up stmt\",NULL);\n        return 0;\n      }\n    }\n  }\n#endif\n\n  /*\n    Cancel further fetches from this cursor.\n    We don't close the cursor till DESTROY.\n    The application may re execute it.\n  */\n  if (imp_sth && DBIc_ACTIVE(imp_sth))\n  {\n    /*\n      Clean-up previous result set(s) for sth to prevent\n      'Commands out of sync' error\n    */\n    mysql_st_free_result_sets(sth, imp_sth);\n  }\n  DBIc_ACTIVE_off(imp_sth);\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  {\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\n<-- dbd_st_finish\\n\");\n  }\n  return 1;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_st_destroy\n *\n *  Purpose: Our part of the statement handles destructor\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *\n *  Returns: Nothing\n *\n **************************************************************************/\n\nvoid dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  int i;\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  imp_sth_fbh_t *fbh;\n  int n;\n\n  n= DBIc_NUM_PARAMS(imp_sth);\n  if (n)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          n, imp_sth->bind, imp_sth->fbind);\n\n    free_bind(imp_sth->bind);\n    free_fbind(imp_sth->fbind);\n  }\n\n  fbh= imp_sth->fbh;\n  if (fbh)\n  {\n    n = DBIc_NUM_FIELDS(imp_sth);\n    i = 0;\n    while (i < n)\n    {\n      if (fbh[i].data) Safefree(fbh[i].data);\n      ++i;\n    }\n\n    free_fbuffer(fbh);\n    if (imp_sth->buffer)\n      free_bind(imp_sth->buffer);\n  }\n\n  if (imp_sth->stmt)\n  {\n    if (mysql_stmt_close(imp_sth->stmt))\n    {\n      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),\n          mysql_stmt_error(imp_sth->stmt),\n          mysql_stmt_sqlstate(imp_sth->stmt));\n    }\n  }\n#endif\n\n\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\n\n  /* Free values allocated by dbd_bind_ph */\n  if (imp_sth->params)\n  {\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\n    imp_sth->params= NULL;\n  }\n\n  /* Free cached array attributes */\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n    imp_sth->av_attr[i]= Nullav;\n  }\n  /* let DBI know we've done it   */\n  DBIc_IMPSET_off(imp_sth);\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_STORE_attrib\n *\n *  Purpose: Modifies a statement handles attributes; we currently\n *           support just nothing\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *           valuesv - attribute value\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\nint\ndbd_st_STORE_attrib(\n                    SV *sth,\n                    imp_sth_t *imp_sth,\n                    SV *keysv,\n                    SV *valuesv\n                   )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  int retval= FALSE;\n  D_imp_xxh(sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t-> dbd_st_STORE_attrib for %p, key %s\\n\",\n                  sth, key);\n\n  if (strEQ(key, \"mysql_use_result\"))\n  {\n    imp_sth->use_mysql_use_result= SvTRUE(valuesv);\n  }\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"\\t\\t<- dbd_st_STORE_attrib for %p, result %d\\n\",\n                  sth, retval);\n\n  return retval;\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_internal\n *\n *  Purpose: Retrieves a statement handles array attributes; we use\n *           a separate function, because creating the array\n *           attributes shares much code and it aids in supporting\n *           enhanced features like caching.\n *\n *  Input:   sth - statement handle; may even be a database handle,\n *               in which case this will be used for storing error\n *               messages only. This is only valid, if cacheit (the\n *               last argument) is set to TRUE.\n *           what - internal attribute number\n *           res - pointer to a DBMS result\n *           cacheit - TRUE, if results may be cached in the sth.\n *\n *  Returns: RV pointing to result array in case of success, NULL\n *           otherwise; do_error has already been called in the latter\n *           case.\n *\n **************************************************************************/\n\n#ifndef IS_KEY\n#define IS_KEY(A) (((A) & (PRI_KEY_FLAG | UNIQUE_KEY_FLAG | MULTIPLE_KEY_FLAG)) != 0)\n#endif\n\n#if !defined(IS_AUTO_INCREMENT) && defined(AUTO_INCREMENT_FLAG)\n#define IS_AUTO_INCREMENT(A) (((A) & AUTO_INCREMENT_FLAG) != 0)\n#endif\n\nSV*\ndbd_st_FETCH_internal(\n  SV *sth,\n  int what,\n  MYSQL_RES *res,\n  int cacheit\n)\n{\n  dTHX;\n  D_imp_sth(sth);\n  AV *av= Nullav;\n  MYSQL_FIELD *curField;\n\n  /* Are we asking for a legal value? */\n  if (what < 0 ||  what >= AV_ATTRIB_LAST)\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Not implemented\", NULL);\n\n  /* Return cached value, if possible */\n  else if (cacheit  &&  imp_sth->av_attr[what])\n    av= imp_sth->av_attr[what];\n\n  /* Does this sth really have a result? */\n  else if (!res)\n    do_error(sth, JW_ERR_NOT_ACTIVE,\n\t     \"statement contains no result\" ,NULL);\n  /* Do the real work. */\n  else\n  {\n    av= newAV();\n    mysql_field_seek(res, 0);\n    while ((curField= mysql_fetch_field(res)))\n    {\n      SV *sv;\n\n      switch(what) {\n      case AV_ATTRIB_NAME:\n        sv= newSVpvn(curField->name, strlen(curField->name));\n        break;\n\n      case AV_ATTRIB_TABLE:\n        sv= newSVpvn(curField->table, strlen(curField->table));\n        break;\n\n      case AV_ATTRIB_TYPE:\n        sv= newSViv((int) curField->type);\n        break;\n\n      case AV_ATTRIB_SQL_TYPE:\n        sv= newSViv((int) native2sql(curField->type)->data_type);\n        break;\n      case AV_ATTRIB_IS_PRI_KEY:\n        sv= boolSV(IS_PRI_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_NOT_NULL:\n        sv= boolSV(IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_NULLABLE:\n        sv= boolSV(!IS_NOT_NULL(curField->flags));\n        break;\n\n      case AV_ATTRIB_LENGTH:\n        sv= newSViv((int) curField->length);\n        break;\n\n      case AV_ATTRIB_IS_NUM:\n        sv= newSViv((int) native2sql(curField->type)->is_num);\n        break;\n\n      case AV_ATTRIB_TYPE_NAME:\n        sv= newSVpv((char*) native2sql(curField->type)->type_name, 0);\n        break;\n\n      case AV_ATTRIB_MAX_LENGTH:\n        sv= newSViv((int) curField->max_length);\n        break;\n\n      case AV_ATTRIB_IS_AUTO_INCREMENT:\n#if defined(AUTO_INCREMENT_FLAG)\n        sv= boolSV(IS_AUTO_INCREMENT(curField->flags));\n        break;\n#else\n        croak(\"AUTO_INCREMENT_FLAG is not supported on this machine\");\n#endif\n\n      case AV_ATTRIB_IS_KEY:\n        sv= boolSV(IS_KEY(curField->flags));\n        break;\n\n      case AV_ATTRIB_IS_BLOB:\n        sv= boolSV(IS_BLOB(curField->flags));\n        break;\n\n      case AV_ATTRIB_SCALE:\n        sv= newSViv((int) curField->decimals);\n        break;\n\n      case AV_ATTRIB_PRECISION:\n        sv= newSViv((int) (curField->length > curField->max_length) ?\n                     curField->length : curField->max_length);\n        break;\n\n      default:\n        sv= &PL_sv_undef;\n        break;\n      }\n      av_push(av, sv);\n    }\n\n    /* Ensure that this value is kept, decremented in\n     *  dbd_st_destroy and dbd_st_execute.  */\n    if (!cacheit)\n      return sv_2mortal(newRV_noinc((SV*)av));\n    imp_sth->av_attr[what]= av;\n  }\n\n  if (av == Nullav)\n    return &PL_sv_undef;\n\n  return sv_2mortal(newRV_inc((SV*)av));\n}\n\n\n/*\n **************************************************************************\n *\n *  Name:    dbd_st_FETCH_attrib\n *\n *  Purpose: Retrieves a statement handles attributes\n *\n *  Input:   sth - statement handle being destroyed\n *           imp_sth - drivers private statement handle data\n *           keysv - attribute name\n *\n *  Returns: NULL for an unknown attribute, \"undef\" for error,\n *           attribute value otherwise.\n *\n **************************************************************************/\n\n#define ST_FETCH_AV(what) \\\n    dbd_st_FETCH_internal(sth, (what), imp_sth->result, TRUE)\n\n  SV* dbd_st_FETCH_attrib(\n                          SV *sth,\n                          imp_sth_t *imp_sth,\n                          SV *keysv\n                         )\n{\n  dTHX;\n  STRLEN(kl);\n  char *key= SvPV(keysv, kl);\n  SV *retsv= Nullsv;\n  D_imp_xxh(sth);\n\n  if (kl < 2)\n    return Nullsv;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"    -> dbd_st_FETCH_attrib for %p, key %s\\n\",\n                  sth, key);\n\n  switch (*key) {\n  case 'N':\n    if (strEQ(key, \"NAME\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NAME);\n    else if (strEQ(key, \"NULLABLE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_NULLABLE);\n    break;\n  case 'P':\n    if (strEQ(key, \"PRECISION\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_PRECISION);\n    if (strEQ(key, \"ParamValues\"))\n    {\n        HV *pvhv= newHV();\n        if (DBIc_NUM_PARAMS(imp_sth))\n        {\n            int n;\n            char key[100];\n            I32 keylen;\n            for (n= 0; n < DBIc_NUM_PARAMS(imp_sth); n++)\n            {\n                keylen= sprintf(key, \"%d\", n);\n                (void)hv_store(pvhv, key,\n                         keylen, newSVsv(imp_sth->params[n].value), 0);\n            }\n        }\n        retsv= sv_2mortal(newRV_noinc((SV*)pvhv));\n    }\n    break;\n  case 'S':\n    if (strEQ(key, \"SCALE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SCALE);\n    break;\n  case 'T':\n    if (strEQ(key, \"TYPE\"))\n      retsv= ST_FETCH_AV(AV_ATTRIB_SQL_TYPE);\n    break;\n  case 'm':\n    switch (kl) {\n    case 10:\n      if (strEQ(key, \"mysql_type\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TYPE);\n      break;\n    case 11:\n      if (strEQ(key, \"mysql_table\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_TABLE);\n      break;\n    case 12:\n      if (       strEQ(key, \"mysql_is_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_KEY);\n      else if (strEQ(key, \"mysql_is_num\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_NUM);\n      else if (strEQ(key, \"mysql_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_LENGTH);\n      else if (strEQ(key, \"mysql_result\"))\n        retsv= sv_2mortal(newSViv(PTR2IV(imp_sth->result)));\n      break;\n    case 13:\n      if (strEQ(key, \"mysql_is_blob\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_BLOB);\n      break;\n    case 14:\n      if (strEQ(key, \"mysql_insertid\"))\n      {\n        /* We cannot return an IV, because the insertid is a long.  */\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"INSERT ID %llu\\n\", imp_sth->insertid);\n\n        return sv_2mortal(my_ulonglong2str(aTHX_ imp_sth->insertid));\n      }\n      break;\n    case 15:\n      if (strEQ(key, \"mysql_type_name\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_TYPE_NAME);\n      break;\n    case 16:\n      if ( strEQ(key, \"mysql_is_pri_key\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_IS_PRI_KEY);\n      else if (strEQ(key, \"mysql_max_length\"))\n        retsv= ST_FETCH_AV(AV_ATTRIB_MAX_LENGTH);\n      else if (strEQ(key, \"mysql_use_result\"))\n        retsv= boolSV(imp_sth->use_mysql_use_result);\n      break;\n    case 19:\n      if (strEQ(key, \"mysql_warning_count\"))\n        retsv= sv_2mortal(newSViv((IV) imp_sth->warning_count));\n      break;\n    case 20:\n      if (strEQ(key, \"mysql_server_prepare\"))\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n        retsv= sv_2mortal(newSViv((IV) imp_sth->use_server_side_prepare));\n#else\n        retsv= boolSV(0);\n#endif\n      break;\n    case 23:\n      if (strEQ(key, \"mysql_is_auto_increment\"))\n        retsv = ST_FETCH_AV(AV_ATTRIB_IS_AUTO_INCREMENT);\n      break;\n    }\n    break;\n  }\n  return retsv;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_st_blob_read\n *\n *  Purpose: Used for blob reads if the statement handles \"LongTruncOk\"\n *           attribute (currently not supported by DBD::mysql)\n *\n *  Input:   SV* - statement handle from which a blob will be fetched\n *           imp_sth - drivers private statement handle data\n *           field - field number of the blob (note, that a row may\n *               contain more than one blob)\n *           offset - the offset of the field, where to start reading\n *           len - maximum number of bytes to read\n *           destrv - RV* that tells us where to store\n *           destoffset - destination offset\n *\n *  Returns: TRUE for success, FALSE otherwise; do_error will\n *           be called in the latter case\n *\n **************************************************************************/\n\nint dbd_st_blob_read (\n  SV *sth,\n  imp_sth_t *imp_sth,\n  int field,\n  long offset,\n  long len,\n  SV *destrv,\n  long destoffset)\n{\n    /* quell warnings */\n    sth= sth;\n    imp_sth=imp_sth;\n    field= field;\n    offset= offset;\n    len= len;\n    destrv= destrv;\n    destoffset= destoffset;\n    return FALSE;\n}\n\n\n/***************************************************************************\n *\n *  Name:    dbd_bind_ph\n *\n *  Purpose: Binds a statement value to a parameter\n *\n *  Input:   sth - statement handle\n *           imp_sth - drivers private statement handle data\n *           param - parameter number, counting starts with 1\n *           value - value being inserted for parameter \"param\"\n *           sql_type - SQL type of the value\n *           attribs - bind parameter attributes, currently this must be\n *               one of the values SQL_CHAR, ...\n *           inout - TRUE, if parameter is an output variable (currently\n *               this is not supported)\n *           maxlen - ???\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value,\n\t\t IV sql_type, SV *attribs, int is_inout, IV maxlen) {\n  dTHX;\n  int rc;\n  int param_num= SvIV(param);\n  int idx= param_num - 1;\n  char *err_msg;\n  D_imp_xxh(sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char *buffer= NULL;\n  int buffer_is_null= 0;\n  int buffer_length= slen;\n  unsigned int buffer_type= 0;\n#endif\n\n  D_imp_dbh_from_sth;\n  ASYNC_CHECK_RETURN(sth, FALSE);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                  \"   Called: dbd_bind_ph\\n\");\n\n  attribs= attribs;\n  maxlen= maxlen;\n\n  if (param_num <= 0  ||  param_num > DBIc_NUM_PARAMS(imp_sth))\n  {\n    do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, \"Illegal parameter number\", NULL);\n    return FALSE;\n  }\n\n  /*\n     This fixes the bug whereby no warning was issued upon binding a\n     defined non-numeric as numeric\n   */\n  if (SvOK(value) &&\n      (sql_type == SQL_NUMERIC  ||\n       sql_type == SQL_DECIMAL  ||\n       sql_type == SQL_INTEGER  ||\n       sql_type == SQL_SMALLINT ||\n       sql_type == SQL_FLOAT    ||\n       sql_type == SQL_REAL     ||\n       sql_type == SQL_DOUBLE) )\n  {\n    if (! looks_like_number(value))\n    {\n      err_msg = SvPVX(sv_2mortal(newSVpvf(\n              \"Binding non-numeric field %d, value %s as a numeric!\",\n              param_num, neatsvpv(value,0))));\n      do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL);\n    }\n  }\n\n  if (is_inout)\n  {\n    do_error(sth, JW_ERR_NOT_IMPLEMENTED, \"Output parameters not implemented\", NULL);\n    return FALSE;\n  }\n\n  rc = bind_param(&imp_sth->params[idx], value, sql_type);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n      switch(sql_type) {\n      case SQL_NUMERIC:\n      case SQL_INTEGER:\n      case SQL_SMALLINT:\n      case SQL_BIGINT:\n      case SQL_TINYINT:\n          buffer_type= MYSQL_TYPE_LONG;\n          break;\n      case SQL_DOUBLE:\n      case SQL_DECIMAL: \n      case SQL_FLOAT: \n      case SQL_REAL:\n          buffer_type= MYSQL_TYPE_DOUBLE;\n          break;\n      case SQL_CHAR: \n      case SQL_VARCHAR: \n      case SQL_DATE: \n      case SQL_TIME: \n      case SQL_TIMESTAMP: \n      case SQL_LONGVARCHAR: \n      case SQL_BINARY: \n      case SQL_VARBINARY: \n      case SQL_LONGVARBINARY:\n          buffer_type= MYSQL_TYPE_BLOB;\n          break;\n      default:\n          buffer_type= MYSQL_TYPE_STRING;\n    }\n    buffer_is_null = !(SvOK(imp_sth->params[idx].value) && imp_sth->params[idx].value);\n    if (! buffer_is_null) {\n      switch(buffer_type) {\n        case MYSQL_TYPE_LONG:\n          /* INT */\n          if (!SvIOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND AN INT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.lval;\n          imp_sth->fbind[idx].numeric_val.lval= SvIV(imp_sth->params[idx].value);\n          buffer=(void*)&(imp_sth->fbind[idx].numeric_val.lval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %\"IVdf\" ->%\"IVdf\"<- IS A INT NUMBER\\n\",\n                          sql_type, *(IV *)buffer);\n          break;\n\n        case MYSQL_TYPE_DOUBLE:\n          if (!SvNOK(imp_sth->params[idx].value) && DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tTRY TO BIND A FLOAT NUMBER\\n\");\n          buffer_length = sizeof imp_sth->fbind[idx].numeric_val.dval;\n          imp_sth->fbind[idx].numeric_val.dval= SvNV(imp_sth->params[idx].value);\n          buffer=(char*)&(imp_sth->fbind[idx].numeric_val.dval);\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type %\"IVdf\" ->%f<- IS A FLOAT NUMBER\\n\",\n                          sql_type, (double)(*buffer));\n          break;\n\n        case MYSQL_TYPE_BLOB:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type BLOB\\n\");\n          break;\n\n        case MYSQL_TYPE_STRING:\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                          \"   SCALAR type STRING %\"IVdf\", buffertype=%d\\n\", sql_type, buffer_type);\n          break;\n\n        default:\n          croak(\"Bug in DBD::Mysql file dbdimp.c#dbd_bind_ph: do not know how to handle unknown buffer type.\");\n      }\n\n      if (buffer_type == MYSQL_TYPE_STRING || buffer_type == MYSQL_TYPE_BLOB)\n      {\n        buffer= SvPV(imp_sth->params[idx].value, slen);\n        buffer_length= slen;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \" SCALAR type %\"IVdf\" ->length %d<- IS A STRING or BLOB\\n\",\n                        sql_type, buffer_length);\n      }\n    }\n    else\n    {\n      /*case: buffer_is_null != 0*/\n      buffer= NULL;\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"   SCALAR NULL VALUE: buffer type is: %d\\n\", buffer_type);\n    }\n\n    /* Type of column was changed. Force to rebind */\n    if (imp_sth->bind[idx].buffer_type != buffer_type) {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                        \"   FORCE REBIND: buffer type changed from %d to %d, sql-type=%\"IVdf\"\\n\",\n                        (int) imp_sth->bind[idx].buffer_type, buffer_type, sql_type);\n      imp_sth->has_been_bound = 0;\n    }\n\n    /* prepare has been called */\n    if (imp_sth->has_been_bound)\n    {\n      imp_sth->stmt->params[idx].buffer= buffer;\n      imp_sth->stmt->params[idx].buffer_length= buffer_length;\n    }\n\n    imp_sth->bind[idx].buffer_type= buffer_type;\n    imp_sth->bind[idx].buffer= buffer;\n    imp_sth->bind[idx].buffer_length= buffer_length;\n\n    imp_sth->fbind[idx].length= buffer_length;\n    imp_sth->fbind[idx].is_null= buffer_is_null;\n  }\n#endif\n  return rc;\n}\n\n\n/***************************************************************************\n *\n *  Name:    mysql_db_reconnect\n *\n *  Purpose: If the server has disconnected, try to reconnect.\n *\n *  Input:   h - database or statement handle\n *\n *  Returns: TRUE for success, FALSE otherwise\n *\n **************************************************************************/\n\nint mysql_db_reconnect(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* imp_dbh;\n  MYSQL save_socket;\n\n  if (DBIc_TYPE(imp_xxh) == DBIt_ST)\n  {\n    imp_dbh = (imp_dbh_t*) DBIc_PARENT_COM(imp_xxh);\n    h = DBIc_PARENT_H(imp_xxh);\n  }\n  else\n    imp_dbh= (imp_dbh_t*) imp_xxh;\n\n  if (mysql_errno(imp_dbh->pmysql) != CR_SERVER_GONE_ERROR)\n    /* Other error */\n    return FALSE;\n\n  if (!DBIc_has(imp_dbh, DBIcf_AutoCommit) || !imp_dbh->auto_reconnect)\n  {\n    /* We never reconnect if AutoCommit is turned off.\n     * Otherwise we might get an inconsistent transaction\n     * state.\n     */\n    return FALSE;\n  }\n\n  /* my_login will blow away imp_dbh->mysql so we save a copy of\n   * imp_dbh->mysql and put it back where it belongs if the reconnect\n   * fail.  Think server is down & reconnect fails but the application eval{}s\n   * the execute, so next time $dbh->quote() gets called, instant SIGSEGV!\n   */\n  save_socket= *(imp_dbh->pmysql);\n  memcpy (&save_socket, imp_dbh->pmysql,sizeof(save_socket));\n  memset (imp_dbh->pmysql,0,sizeof(*(imp_dbh->pmysql)));\n\n  /* we should disconnect the db handle before reconnecting, this will\n   * prevent my_login from thinking it's adopting an active child which\n   * would prevent the handle from actually reconnecting\n   */\n  if (!dbd_db_disconnect(h, imp_dbh) || !my_login(aTHX_ h, imp_dbh))\n  {\n    do_error(h, mysql_errno(imp_dbh->pmysql), mysql_error(imp_dbh->pmysql),\n             mysql_sqlstate(imp_dbh->pmysql));\n    memcpy (imp_dbh->pmysql, &save_socket, sizeof(save_socket));\n    ++imp_dbh->stats.auto_reconnects_failed;\n    return FALSE;\n  }\n\n  /*\n   *  Tell DBI, that dbh->disconnect should be called for this handle\n   */\n  DBIc_ACTIVE_on(imp_dbh);\n\n  ++imp_dbh->stats.auto_reconnects_ok;\n  return TRUE;\n}\n\n\n/**************************************************************************\n *\n *  Name:    dbd_db_type_info_all\n *\n *  Purpose: Implements $dbh->type_info_all\n *\n *  Input:   dbh - database handle\n *           imp_sth - drivers private database handle data\n *\n *  Returns: RV to AV of types\n *\n **************************************************************************/\n\n#define PV_PUSH(c)                              \\\n    if (c) {                                    \\\n\tsv= newSVpv((char*) (c), 0);           \\\n\tSvREADONLY_on(sv);                      \\\n    } else {                                    \\\n        sv= &PL_sv_undef;                         \\\n    }                                           \\\n    av_push(row, sv);\n\n#define IV_PUSH(i) sv= newSViv((i)); SvREADONLY_on(sv); av_push(row, sv);\n\nAV *dbd_db_type_info_all(SV *dbh, imp_dbh_t *imp_dbh)\n{\n  dTHX;\n  AV *av= newAV();\n  AV *row;\n  HV *hv;\n  SV *sv;\n  int i;\n  const char *cols[] = {\n    \"TYPE_NAME\",\n    \"DATA_TYPE\",\n    \"COLUMN_SIZE\",\n    \"LITERAL_PREFIX\",\n    \"LITERAL_SUFFIX\",\n    \"CREATE_PARAMS\",\n    \"NULLABLE\",\n    \"CASE_SENSITIVE\",\n    \"SEARCHABLE\",\n    \"UNSIGNED_ATTRIBUTE\",\n    \"FIXED_PREC_SCALE\",\n    \"AUTO_UNIQUE_VALUE\",\n    \"LOCAL_TYPE_NAME\",\n    \"MINIMUM_SCALE\",\n    \"MAXIMUM_SCALE\",\n    \"NUM_PREC_RADIX\",\n    \"SQL_DATATYPE\",\n    \"SQL_DATETIME_SUB\",\n    \"INTERVAL_PRECISION\",\n    \"mysql_native_type\",\n    \"mysql_is_num\"\n  };\n\n  dbh= dbh;\n  imp_dbh= imp_dbh;\n \n  hv= newHV();\n  av_push(av, newRV_noinc((SV*) hv));\n  for (i= 0;  i < (int)(sizeof(cols) / sizeof(const char*));  i++)\n  {\n    if (!hv_store(hv, (char*) cols[i], strlen(cols[i]), newSViv(i), 0))\n    {\n      SvREFCNT_dec((SV*) av);\n      return Nullav;\n    }\n  }\n  for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n  {\n    const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n\n    row= newAV();\n    av_push(av, newRV_noinc((SV*) row));\n    PV_PUSH(t->type_name);\n    IV_PUSH(t->data_type);\n    IV_PUSH(t->column_size);\n    PV_PUSH(t->literal_prefix);\n    PV_PUSH(t->literal_suffix);\n    PV_PUSH(t->create_params);\n    IV_PUSH(t->nullable);\n    IV_PUSH(t->case_sensitive);\n    IV_PUSH(t->searchable);\n    IV_PUSH(t->unsigned_attribute);\n    IV_PUSH(t->fixed_prec_scale);\n    IV_PUSH(t->auto_unique_value);\n    PV_PUSH(t->local_type_name);\n    IV_PUSH(t->minimum_scale);\n    IV_PUSH(t->maximum_scale);\n\n    if (t->num_prec_radix)\n    {\n      IV_PUSH(t->num_prec_radix);\n    }\n    else\n      av_push(row, &PL_sv_undef);\n\n    IV_PUSH(t->sql_datatype); /* SQL_DATATYPE*/\n    IV_PUSH(t->sql_datetime_sub); /* SQL_DATETIME_SUB*/\n    IV_PUSH(t->interval_precision); /* INTERVAL_PERCISION */\n    IV_PUSH(t->native_type);\n    IV_PUSH(t->is_num);\n  }\n  return av;\n}\n\n\n/*\n  dbd_db_quote\n\n  Properly quotes a value \n*/\nSV* dbd_db_quote(SV *dbh, SV *str, SV *type)\n{\n  dTHX;\n  SV *result;\n\n  if (SvGMAGICAL(str))\n    mg_get(str);\n\n  if (!SvOK(str))\n    result= newSVpvn(\"NULL\", 4);\n  else\n  {\n    char *ptr, *sptr;\n    STRLEN len;\n\n    D_imp_dbh(dbh);\n\n    if (type && SvMAGICAL(type))\n      mg_get(type);\n\n    if (type  &&  SvOK(type))\n    {\n      int i;\n      int tp= SvIV(type);\n      for (i= 0;  i < (int)SQL_GET_TYPE_INFO_num;  i++)\n      {\n        const sql_type_info_t *t= &SQL_GET_TYPE_INFO_values[i];\n        if (t->data_type == tp)\n        {\n          if (!t->literal_prefix)\n            return Nullsv;\n          break;\n        }\n      }\n    }\n\n    ptr= SvPV(str, len);\n    result= newSV(len*2+3);\n#ifdef SvUTF8\n    if (SvUTF8(str)) SvUTF8_on(result);\n#endif\n    sptr= SvPVX(result);\n\n    *sptr++ = '\\'';\n    sptr+= mysql_real_escape_string(imp_dbh->pmysql, sptr,\n                                     ptr, len);\n    *sptr++= '\\'';\n    SvPOK_on(result);\n    SvCUR_set(result, sptr - SvPVX(result));\n    /* Never hurts NUL terminating a Per string */\n    *sptr++= '\\0';\n  }\n  return result;\n}\n\n#ifdef DBD_MYSQL_INSERT_ID_IS_GOOD\nSV *mysql_db_last_insert_id(SV *dbh, imp_dbh_t *imp_dbh,\n        SV *catalog, SV *schema, SV *table, SV *field, SV *attr)\n{\n  dTHX;\n  /* all these non-op settings are to stifle OS X compile warnings */\n  imp_dbh= imp_dbh;\n  dbh= dbh;\n  catalog= catalog;\n  schema= schema;\n  table= table;\n  field= field;\n  attr= attr;\n\n  ASYNC_CHECK_RETURN(dbh, &PL_sv_undef);\n  return sv_2mortal(my_ulonglong2str(aTHX_ mysql_insert_id(imp_dbh->pmysql)));\n}\n#endif\n\n#if MYSQL_ASYNC\nint mysql_db_async_result(SV* h, MYSQL_RES** resp)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  MYSQL* svsock = NULL;\n  MYSQL_RES* _res;\n  int retval = 0;\n  int htype;\n\n  if(! resp) {\n      resp = &_res;\n  }\n  htype = DBIc_TYPE(imp_xxh);\n\n\n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(! dbh->async_query_in_flight) {\n      do_error(h, 2000, \"Gathering asynchronous results for a synchronous handle\", \"HY000\");\n      return -1;\n  }\n  if(dbh->async_query_in_flight != imp_xxh) {\n      do_error(h, 2000, \"Gathering async_query_in_flight results for the wrong handle\", \"HY000\");\n      return -1;\n  }\n  dbh->async_query_in_flight = NULL;\n\n  svsock= dbh->pmysql;\n  retval= mysql_read_query_result(svsock);\n  if(! retval) {\n    *resp= mysql_store_result(svsock);\n\n    if (mysql_errno(svsock))\n      do_error(h, mysql_errno(svsock), mysql_error(svsock), mysql_sqlstate(svsock));\n    if (!*resp)\n      retval= mysql_affected_rows(svsock);\n    else {\n      retval= mysql_num_rows(*resp);\n      if(resp == &_res) {\n        mysql_free_result(*resp);\n      }\n    }\n    if(htype == DBIt_ST) {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n\n      if((my_ulonglong)retval+1 != (my_ulonglong)-1) {\n        if(! *resp) {\n          imp_sth->insertid= mysql_insert_id(svsock);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n          if(! mysql_more_results(svsock))\n            DBIc_ACTIVE_off(imp_sth);\n#endif\n        } else {\n          DBIc_NUM_FIELDS(imp_sth)= mysql_num_fields(imp_sth->result);\n          imp_sth->done_desc= 0;\n          imp_sth->fetch_done= 0;\n        }\n      }\n      imp_sth->warning_count = mysql_warning_count(imp_dbh->pmysql);\n    }\n  } else {\n     do_error(h, mysql_errno(svsock), mysql_error(svsock),\n              mysql_sqlstate(svsock));\n     return -1;\n  }\n return retval;\n}\n\nint mysql_db_async_ready(SV* h)\n{\n  dTHX;\n  D_imp_xxh(h);\n  imp_dbh_t* dbh;\n  int htype;\n\n  htype = DBIc_TYPE(imp_xxh);\n  \n  if(htype == DBIt_DB) {\n      D_imp_dbh(h);\n      dbh = imp_dbh;\n  } else {\n      D_imp_sth(h);\n      D_imp_dbh_from_sth;\n      dbh = imp_dbh;\n  }\n\n  if(dbh->async_query_in_flight) {\n      if(dbh->async_query_in_flight == imp_xxh) {\n          struct pollfd fds;\n          int retval;\n\n          fds.fd = dbh->pmysql->net.fd;\n          fds.events = POLLIN;\n\n          retval = poll(&fds, 1, 0);\n\n          if(retval < 0) {\n              do_error(h, errno, strerror(errno), \"HY000\");\n          }\n          return retval;\n      } else {\n          do_error(h, 2000, \"Calling mysql_async_ready on the wrong handle\", \"HY000\");\n          return -1;\n      }\n  } else {\n      do_error(h, 2000, \"Handle is not in asynchronous mode\", \"HY000\");\n      return -1;\n  }\n}\n#endif\n\nstatic int parse_number(char *string, STRLEN len, char **end)\n{\n    int seen_neg;\n    int seen_dec;\n    int seen_e;\n    int seen_plus;\n    int seen_digit;\n    char *cp;\n\n    seen_neg= seen_dec= seen_e= seen_plus= seen_digit= 0;\n\n    if (len <= 0) {\n        len= strlen(string);\n    }\n\n    cp= string;\n\n    /* Skip leading whitespace */\n    while (*cp && isspace(*cp))\n      cp++;\n\n    for ( ; *cp; cp++)\n    {\n      if ('-' == *cp)\n      {\n        if (seen_neg >= 2)\n        {\n          /*\n            third '-'. number can contains two '-'.\n            because -1e-10 is valid number */\n          break;\n        }\n        seen_neg += 1;\n      }\n      else if ('.' == *cp)\n      {\n        if (seen_dec)\n        {\n          /* second '.' */\n          break;\n        }\n        seen_dec= 1;\n      }\n      else if ('e' == *cp)\n      {\n        if (seen_e)\n        {\n          /* second 'e' */\n          break;\n        }\n        seen_e= 1;\n      }\n      else if ('+' == *cp)\n      {\n        if (seen_plus)\n        {\n          /* second '+' */\n          break;\n        }\n        seen_plus= 1;\n      }\n      else if (!isdigit(*cp))\n      {\n        /* Not sure why this was changed */\n        /* seen_digit= 1; */\n        break;\n      }\n    }\n\n    *end= cp;\n\n    /* length 0 -> not a number */\n    /* Need to revisit this */\n    /*if (len == 0 || cp - string < (int) len || seen_digit == 0) {*/\n    if (len == 0 || cp - string < (int) len) {\n        return -1;\n    }\n\n    return 0;\n}\n", "package Bundle::DBD::mysql;\n\nuse strict;\nuse warnings;\n\nour $VERSION = '4.039';\n\n1;\n\n__END__\n\n=pod\n\n=head1 NAME\n\nBundle::DBD::mysql\n\n=head1 DESCRIPTION\n\nThis package only exists for legacy reasons. Please use the L<DBD::mysql>\npackage instead.\n\n=cut\n", "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nrequire 5.008_001; # just as DBI\n\npackage DBD::mysql;\n\nuse DBI;\nuse DynaLoader();\nuse Carp;\nour @ISA = qw(DynaLoader);\n\n# please make sure the sub-version does not increase above '099'\n# SQL_DRIVER_VER is formatted as dd.dd.dddd\n# for version 5.x please switch to 5.00(_00) version numbering\n# keep $VERSION in Bundle/DBD/mysql.pm in sync\nour $VERSION = '4.039';\n\nbootstrap DBD::mysql $VERSION;\n\n\nour $err = 0;\t    # holds error code for DBI::err\nour $errstr = \"\";\t# holds error string for DBI::errstr\nour $drh = undef;\t# holds driver handle once initialised\n\nmy $methods_are_installed = 0;\nsub driver{\n    return $drh if $drh;\n    my($class, $attr) = @_;\n\n    $class .= \"::dr\";\n\n    # not a 'my' since we use it above to prevent multiple drivers\n    $drh = DBI::_new_drh($class, { 'Name' => 'mysql',\n\t\t\t\t   'Version' => $VERSION,\n\t\t\t\t   'Err'    => \\$DBD::mysql::err,\n\t\t\t\t   'Errstr' => \\$DBD::mysql::errstr,\n\t\t\t\t   'Attribution' => 'DBD::mysql by Patrick Galbraith'\n\t\t\t\t });\n\n    if (!$methods_are_installed) {\n\tDBD::mysql::db->install_method('mysql_fd');\n\tDBD::mysql::db->install_method('mysql_async_result');\n\tDBD::mysql::db->install_method('mysql_async_ready');\n\tDBD::mysql::st->install_method('mysql_async_result');\n\tDBD::mysql::st->install_method('mysql_async_ready');\n\n\t$methods_are_installed++;\n    }\n\n    $drh;\n}\n\nsub CLONE {\n  undef $drh;\n}\n\nsub _OdbcParse($$$) {\n    my($class, $dsn, $hash, $args) = @_;\n    my($var, $val);\n    if (!defined($dsn)) {\n\treturn;\n    }\n    while (length($dsn)) {\n\tif ($dsn =~ /([^:;]*\\[.*]|[^:;]*)[:;](.*)/) {\n\t    $val = $1;\n\t    $dsn = $2;\n\t    $val =~ s/\\[|]//g; # Remove [] if present, the rest of the code prefers plain IPv6 addresses\n\t} else {\n\t    $val = $dsn;\n\t    $dsn = '';\n\t}\n\tif ($val =~ /([^=]*)=(.*)/) {\n\t    $var = $1;\n\t    $val = $2;\n\t    if ($var eq 'hostname'  ||  $var eq 'host') {\n\t\t$hash->{'host'} = $val;\n\t    } elsif ($var eq 'db'  ||  $var eq 'dbname') {\n\t\t$hash->{'database'} = $val;\n\t    } else {\n\t\t$hash->{$var} = $val;\n\t    }\n\t} else {\n\t    foreach $var (@$args) {\n\t\tif (!defined($hash->{$var})) {\n\t\t    $hash->{$var} = $val;\n\t\t    last;\n\t\t}\n\t    }\n\t}\n    }\n}\n\nsub _OdbcParseHost ($$) {\n    my($class, $dsn) = @_;\n    my($hash) = {};\n    $class->_OdbcParse($dsn, $hash, ['host', 'port']);\n    ($hash->{'host'}, $hash->{'port'});\n}\n\nsub AUTOLOAD {\n    my ($meth) = $DBD::mysql::AUTOLOAD;\n    my ($smeth) = $meth;\n    $smeth =~ s/(.*)\\:\\://;\n\n    my $val = constant($smeth, @_ ? $_[0] : 0);\n    if ($! == 0) { eval \"sub $meth { $val }\"; return $val; }\n\n    Carp::croak \"$meth: Not defined\";\n}\n\n1;\n\n\npackage DBD::mysql::dr; # ====== DRIVER ======\nuse strict;\nuse DBI qw(:sql_types);\nuse DBI::Const::GetInfoType;\n\nsub connect {\n    my($drh, $dsn, $username, $password, $attrhash) = @_;\n    my($port);\n    my($cWarn);\n    my $connect_ref= { 'Name' => $dsn };\n    my $dbi_imp_data;\n\n    # Avoid warnings for undefined values\n    $username ||= '';\n    $password ||= '';\n    $attrhash ||= {};\n    $attrhash->{mysql_conn_attrs} ||= {};\n    $attrhash->{mysql_conn_attrs}->{'program_name'} ||= $0;\n\n    # create a 'blank' dbh\n    my($this, $privateAttrHash) = (undef, $attrhash);\n    $privateAttrHash = { %$privateAttrHash,\n\t'Name' => $dsn,\n\t'user' => $username,\n\t'password' => $password\n    };\n\n    DBD::mysql->_OdbcParse($dsn, $privateAttrHash,\n\t\t\t\t    ['database', 'host', 'port']);\n\n\n    if ($DBI::VERSION >= 1.49)\n    {\n      $dbi_imp_data = delete $attrhash->{dbi_imp_data};\n      $connect_ref->{'dbi_imp_data'} = $dbi_imp_data;\n    }\n\n    if (!defined($this = DBI::_new_dbh($drh,\n            $connect_ref,\n            $privateAttrHash)))\n    {\n      return undef;\n    }\n\n    DBD::mysql::db::_login($this, $dsn, $username, $password)\n\t  or $this = undef;\n\n    if ($this && ($ENV{MOD_PERL} || $ENV{GATEWAY_INTERFACE})) {\n        $this->{mysql_auto_reconnect} = 1;\n    }\n    $this;\n}\n\nsub data_sources {\n    my($self) = shift;\n    my($attributes) = shift;\n    my($host, $port, $user, $password) = ('', '', '', '');\n    if ($attributes) {\n      $host = $attributes->{host} || '';\n      $port = $attributes->{port} || '';\n      $user = $attributes->{user} || '';\n      $password = $attributes->{password} || '';\n    }\n    my(@dsn) = $self->func($host, $port, $user, $password, '_ListDBs');\n    my($i);\n    for ($i = 0;  $i < @dsn;  $i++) {\n\t$dsn[$i] = \"DBI:mysql:$dsn[$i]\";\n    }\n    @dsn;\n}\n\nsub admin {\n    my($drh) = shift;\n    my($command) = shift;\n    my($dbname) = ($command eq 'createdb'  ||  $command eq 'dropdb') ?\n\tshift : '';\n    my($host, $port) = DBD::mysql->_OdbcParseHost(shift(@_) || '');\n    my($user) = shift || '';\n    my($password) = shift || '';\n\n    $drh->func(undef, $command,\n\t       $dbname || '',\n\t       $host || '',\n\t       $port || '',\n\t       $user, $password, '_admin_internal');\n}\n\npackage DBD::mysql::db; # ====== DATABASE ======\nuse strict;\nuse DBI qw(:sql_types);\n\n%DBD::mysql::db::db2ANSI = (\n    \"INT\"   =>  \"INTEGER\",\n    \"CHAR\"  =>  \"CHAR\",\n    \"REAL\"  =>  \"REAL\",\n    \"IDENT\" =>  \"DECIMAL\"\n);\n\n### ANSI datatype mapping to MySQL datatypes\n%DBD::mysql::db::ANSI2db = (\n    \"CHAR\"          => \"CHAR\",\n    \"VARCHAR\"       => \"CHAR\",\n    \"LONGVARCHAR\"   => \"CHAR\",\n    \"NUMERIC\"       => \"INTEGER\",\n    \"DECIMAL\"       => \"INTEGER\",\n    \"BIT\"           => \"INTEGER\",\n    \"TINYINT\"       => \"INTEGER\",\n    \"SMALLINT\"      => \"INTEGER\",\n    \"INTEGER\"       => \"INTEGER\",\n    \"BIGINT\"        => \"INTEGER\",\n    \"REAL\"          => \"REAL\",\n    \"FLOAT\"         => \"REAL\",\n    \"DOUBLE\"        => \"REAL\",\n    \"BINARY\"        => \"CHAR\",\n    \"VARBINARY\"     => \"CHAR\",\n    \"LONGVARBINARY\" => \"CHAR\",\n    \"DATE\"          => \"CHAR\",\n    \"TIME\"          => \"CHAR\",\n    \"TIMESTAMP\"     => \"CHAR\"\n);\n\nsub prepare {\n    my($dbh, $statement, $attribs)= @_;\n\n    return unless $dbh->func('_async_check');\n\n    # create a 'blank' dbh\n    my $sth = DBI::_new_sth($dbh, {'Statement' => $statement});\n\n    # Populate internal handle data.\n    if (!DBD::mysql::st::_prepare($sth, $statement, $attribs)) {\n\t$sth = undef;\n    }\n\n    $sth;\n}\n\nsub db2ANSI {\n    my $self = shift;\n    my $type = shift;\n    return $DBD::mysql::db::db2ANSI{\"$type\"};\n}\n\nsub ANSI2db {\n    my $self = shift;\n    my $type = shift;\n    return $DBD::mysql::db::ANSI2db{\"$type\"};\n}\n\nsub admin {\n    my($dbh) = shift;\n    my($command) = shift;\n    my($dbname) = ($command eq 'createdb'  ||  $command eq 'dropdb') ?\n\tshift : '';\n    $dbh->{'Driver'}->func($dbh, $command, $dbname, '', '', '',\n\t\t\t   '_admin_internal');\n}\n\nsub _SelectDB ($$) {\n    die \"_SelectDB is removed from this module; use DBI->connect instead.\";\n}\n\nsub table_info ($) {\n  my ($dbh, $catalog, $schema, $table, $type, $attr) = @_;\n  $dbh->{mysql_server_prepare}||= 0;\n  my $mysql_server_prepare_save= $dbh->{mysql_server_prepare};\n  $dbh->{mysql_server_prepare}= 0;\n  my @names = qw(TABLE_CAT TABLE_SCHEM TABLE_NAME TABLE_TYPE REMARKS);\n  my @rows;\n\n  my $sponge = DBI->connect(\"DBI:Sponge:\", '','')\n    or return $dbh->DBI::set_err($DBI::err, \"DBI::Sponge: $DBI::errstr\");\n\n# Return the list of catalogs\n  if (defined $catalog && $catalog eq \"%\" &&\n      (!defined($schema) || $schema eq \"\") &&\n      (!defined($table) || $table eq \"\"))\n  {\n    @rows = (); # Empty, because MySQL doesn't support catalogs (yet)\n  }\n  # Return the list of schemas\n  elsif (defined $schema && $schema eq \"%\" &&\n      (!defined($catalog) || $catalog eq \"\") &&\n      (!defined($table) || $table eq \"\"))\n  {\n    my $sth = $dbh->prepare(\"SHOW DATABASES\")\n      or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return undef);\n\n    $sth->execute()\n      or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return DBI::set_err($dbh, $sth->err(), $sth->errstr()));\n\n    while (my $ref = $sth->fetchrow_arrayref())\n    {\n      push(@rows, [ undef, $ref->[0], undef, undef, undef ]);\n    }\n  }\n  # Return the list of table types\n  elsif (defined $type && $type eq \"%\" &&\n      (!defined($catalog) || $catalog eq \"\") &&\n      (!defined($schema) || $schema eq \"\") &&\n      (!defined($table) || $table eq \"\"))\n  {\n    @rows = (\n        [ undef, undef, undef, \"TABLE\", undef ],\n        [ undef, undef, undef, \"VIEW\",  undef ],\n        );\n  }\n  # Special case: a catalog other than undef, \"\", or \"%\"\n  elsif (defined $catalog && $catalog ne \"\" && $catalog ne \"%\")\n  {\n    @rows = (); # Nothing, because MySQL doesn't support catalogs yet.\n  }\n  # Uh oh, we actually have a meaty table_info call. Work is required!\n  else\n  {\n    my @schemas;\n    # If no table was specified, we want them all\n    $table ||= \"%\";\n\n    # If something was given for the schema, we need to expand it to\n    # a list of schemas, since it may be a wildcard.\n    if (defined $schema && $schema ne \"\")\n    {\n      my $sth = $dbh->prepare(\"SHOW DATABASES LIKE \" .\n          $dbh->quote($schema))\n        or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return undef);\n      $sth->execute()\n        or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return DBI::set_err($dbh, $sth->err(), $sth->errstr()));\n\n      while (my $ref = $sth->fetchrow_arrayref())\n      {\n        push @schemas, $ref->[0];\n      }\n    }\n    # Otherwise we want the current database\n    else\n    {\n      push @schemas, $dbh->selectrow_array(\"SELECT DATABASE()\");\n    }\n\n    # Figure out which table types are desired\n    my ($want_tables, $want_views);\n    if (defined $type && $type ne \"\")\n    {\n      $want_tables = ($type =~ m/table/i);\n      $want_views  = ($type =~ m/view/i);\n    }\n    else\n    {\n      $want_tables = $want_views = 1;\n    }\n\n    for my $database (@schemas)\n    {\n      my $sth = $dbh->prepare(\"SHOW /*!50002 FULL*/ TABLES FROM \" .\n          $dbh->quote_identifier($database) .\n          \" LIKE \" .  $dbh->quote($table))\n          or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return undef);\n\n      $sth->execute() or\n          ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return DBI::set_err($dbh, $sth->err(), $sth->errstr()));\n\n      while (my $ref = $sth->fetchrow_arrayref())\n      {\n        my $type = (defined $ref->[1] &&\n            $ref->[1] =~ /view/i) ? 'VIEW' : 'TABLE';\n        next if $type eq 'TABLE' && not $want_tables;\n        next if $type eq 'VIEW'  && not $want_views;\n        push @rows, [ undef, $database, $ref->[0], $type, undef ];\n      }\n    }\n  }\n\n  my $sth = $sponge->prepare(\"table_info\",\n  {\n    rows          => \\@rows,\n    NUM_OF_FIELDS => scalar @names,\n    NAME          => \\@names,\n  })\n    or ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n      return $dbh->DBI::set_err($sponge->err(), $sponge->errstr()));\n\n  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n  return $sth;\n}\n\nsub _ListTables {\n  my $dbh = shift;\n  if (!$DBD::mysql::QUIET) {\n    warn \"_ListTables is deprecated, use \\$dbh->tables()\";\n  }\n  return map { $_ =~ s/.*\\.//; $_ } $dbh->tables();\n}\n\n\nsub column_info {\n  my ($dbh, $catalog, $schema, $table, $column) = @_;\n\n  return unless $dbh->func('_async_check');\n\n  $dbh->{mysql_server_prepare}||= 0;\n  my $mysql_server_prepare_save= $dbh->{mysql_server_prepare};\n  $dbh->{mysql_server_prepare}= 0;\n\n  # ODBC allows a NULL to mean all columns, so we'll accept undef\n  $column = '%' unless defined $column;\n\n  my $ER_NO_SUCH_TABLE= 1146;\n\n  my $table_id = $dbh->quote_identifier($catalog, $schema, $table);\n\n  my @names = qw(\n      TABLE_CAT TABLE_SCHEM TABLE_NAME COLUMN_NAME\n      DATA_TYPE TYPE_NAME COLUMN_SIZE BUFFER_LENGTH DECIMAL_DIGITS\n      NUM_PREC_RADIX NULLABLE REMARKS COLUMN_DEF\n      SQL_DATA_TYPE SQL_DATETIME_SUB CHAR_OCTET_LENGTH\n      ORDINAL_POSITION IS_NULLABLE CHAR_SET_CAT\n      CHAR_SET_SCHEM CHAR_SET_NAME COLLATION_CAT COLLATION_SCHEM COLLATION_NAME\n      UDT_CAT UDT_SCHEM UDT_NAME DOMAIN_CAT DOMAIN_SCHEM DOMAIN_NAME\n      SCOPE_CAT SCOPE_SCHEM SCOPE_NAME MAX_CARDINALITY\n      DTD_IDENTIFIER IS_SELF_REF\n      mysql_is_pri_key mysql_type_name mysql_values\n      mysql_is_auto_increment\n      );\n  my %col_info;\n\n  local $dbh->{FetchHashKeyName} = 'NAME_lc';\n  # only ignore ER_NO_SUCH_TABLE in internal_execute if issued from here\n  my $desc_sth = $dbh->prepare(\"DESCRIBE $table_id \" . $dbh->quote($column));\n  my $desc = $dbh->selectall_arrayref($desc_sth, { Columns=>{} });\n\n  #return $desc_sth if $desc_sth->err();\n  if (my $err = $desc_sth->err())\n  {\n    # return the error, unless it is due to the table not\n    # existing per DBI spec\n    if ($err != $ER_NO_SUCH_TABLE)\n    {\n      $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n      return undef;\n    }\n    $dbh->set_err(undef,undef);\n    $desc = [];\n  }\n\n  my $ordinal_pos = 0;\n  my @fields;\n  for my $row (@$desc)\n  {\n    my $type = $row->{type};\n    $type =~ m/^(\\w+)(\\((.+)\\))?\\s?(.*)?$/;\n    my $basetype  = lc($1);\n    my $typemod   = $3;\n    my $attr      = $4;\n\n    push @fields, $row->{field};\n    my $info = $col_info{ $row->{field} }= {\n\t    TABLE_CAT               => $catalog,\n\t    TABLE_SCHEM             => $schema,\n\t    TABLE_NAME              => $table,\n\t    COLUMN_NAME             => $row->{field},\n\t    NULLABLE                => ($row->{null} eq 'YES') ? 1 : 0,\n\t    IS_NULLABLE             => ($row->{null} eq 'YES') ? \"YES\" : \"NO\",\n\t    TYPE_NAME               => uc($basetype),\n\t    COLUMN_DEF              => $row->{default},\n\t    ORDINAL_POSITION        => ++$ordinal_pos,\n\t    mysql_is_pri_key        => ($row->{key}  eq 'PRI'),\n\t    mysql_type_name         => $row->{type},\n      mysql_is_auto_increment => ($row->{extra} =~ /auto_increment/i ? 1 : 0),\n    };\n    #\n\t  # This code won't deal with a pathological case where a value\n\t  # contains a single quote followed by a comma, and doesn't unescape\n\t  # any escaped values. But who would use those in an enum or set?\n    #\n\t  my @type_params= ($typemod && index($typemod,\"'\")>=0) ?\n      (\"$typemod,\" =~ /'(.*?)',/g)  # assume all are quoted\n\t\t\t: split /,/, $typemod||'';      # no quotes, plain list\n\t  s/''/'/g for @type_params;                # undo doubling of quotes\n\n\t  my @type_attr= split / /, $attr||'';\n\n  \t$info->{DATA_TYPE}= SQL_VARCHAR();\n    if ($basetype =~ /^(char|varchar|\\w*text|\\w*blob)/)\n    {\n      $info->{DATA_TYPE}= SQL_CHAR() if $basetype eq 'char';\n      if ($type_params[0])\n      {\n        $info->{COLUMN_SIZE} = $type_params[0];\n      }\n      else\n      {\n        $info->{COLUMN_SIZE} = 65535;\n        $info->{COLUMN_SIZE} = 255        if $basetype =~ /^tiny/;\n        $info->{COLUMN_SIZE} = 16777215   if $basetype =~ /^medium/;\n        $info->{COLUMN_SIZE} = 4294967295 if $basetype =~ /^long/;\n      }\n    }\n\t  elsif ($basetype =~ /^(binary|varbinary)/)\n    {\n      $info->{COLUMN_SIZE} = $type_params[0];\n\t    # SQL_BINARY & SQL_VARBINARY are tempting here but don't match the\n\t    # semantics for mysql (not hex). SQL_CHAR &  SQL_VARCHAR are correct here.\n\t    $info->{DATA_TYPE} = ($basetype eq 'binary') ? SQL_CHAR() : SQL_VARCHAR();\n    }\n    elsif ($basetype =~ /^(enum|set)/)\n    {\n\t    if ($basetype eq 'set')\n      {\n\t\t    $info->{COLUMN_SIZE} = length(join \",\", @type_params);\n\t    }\n\t    else\n      {\n        my $max_len = 0;\n        length($_) > $max_len and $max_len = length($_) for @type_params;\n        $info->{COLUMN_SIZE} = $max_len;\n\t    }\n\t    $info->{\"mysql_values\"} = \\@type_params;\n    }\n    elsif ($basetype =~ /int/ || $basetype eq 'bit' )\n    {\n      # big/medium/small/tiny etc + unsigned?\n\t    $info->{DATA_TYPE} = SQL_INTEGER();\n\t    $info->{NUM_PREC_RADIX} = 10;\n\t    $info->{COLUMN_SIZE} = $type_params[0];\n    }\n    elsif ($basetype =~ /^decimal/)\n    {\n      $info->{DATA_TYPE} = SQL_DECIMAL();\n      $info->{NUM_PREC_RADIX} = 10;\n      $info->{COLUMN_SIZE}    = $type_params[0];\n      $info->{DECIMAL_DIGITS} = $type_params[1];\n    }\n    elsif ($basetype =~ /^(float|double)/)\n    {\n\t    $info->{DATA_TYPE} = ($basetype eq 'float') ? SQL_FLOAT() : SQL_DOUBLE();\n\t    $info->{NUM_PREC_RADIX} = 2;\n\t    $info->{COLUMN_SIZE} = ($basetype eq 'float') ? 32 : 64;\n    }\n    elsif ($basetype =~ /date|time/)\n    {\n      # date/datetime/time/timestamp\n\t    if ($basetype eq 'time' or $basetype eq 'date')\n      {\n\t\t    #$info->{DATA_TYPE}   = ($basetype eq 'time') ? SQL_TYPE_TIME() : SQL_TYPE_DATE();\n        $info->{DATA_TYPE}   = ($basetype eq 'time') ? SQL_TIME() : SQL_DATE();\n        $info->{COLUMN_SIZE} = ($basetype eq 'time') ? 8 : 10;\n      }\n\t    else\n      {\n        # datetime/timestamp\n        #$info->{DATA_TYPE}     = SQL_TYPE_TIMESTAMP();\n\t\t    $info->{DATA_TYPE}        = SQL_TIMESTAMP();\n\t\t    $info->{SQL_DATA_TYPE}    = SQL_DATETIME();\n        $info->{SQL_DATETIME_SUB} = $info->{DATA_TYPE} - ($info->{SQL_DATA_TYPE} * 10);\n        $info->{COLUMN_SIZE}      = ($basetype eq 'datetime') ? 19 : $type_params[0] || 14;\n\t    }\n\t    $info->{DECIMAL_DIGITS}= 0; # no fractional seconds\n    }\n    elsif ($basetype eq 'year')\n    {\n      # no close standard so treat as int\n\t    $info->{DATA_TYPE}      = SQL_INTEGER();\n\t    $info->{NUM_PREC_RADIX} = 10;\n\t    $info->{COLUMN_SIZE}    = 4;\n\t  }\n\t  else\n    {\n\t    Carp::carp(\"column_info: unrecognized column type '$basetype' of $table_id.$row->{field} treated as varchar\");\n    }\n    $info->{SQL_DATA_TYPE} ||= $info->{DATA_TYPE};\n    #warn Dumper($info);\n  }\n\n  my $sponge = DBI->connect(\"DBI:Sponge:\", '','')\n    or (  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          return $dbh->DBI::set_err($DBI::err, \"DBI::Sponge: $DBI::errstr\"));\n\n  my $sth = $sponge->prepare(\"column_info $table\", {\n      rows          => [ map { [ @{$_}{@names} ] } map { $col_info{$_} } @fields ],\n      NUM_OF_FIELDS => scalar @names,\n      NAME          => \\@names,\n      }) or\n  return ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n          $dbh->DBI::set_err($sponge->err(), $sponge->errstr()));\n\n  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n  return $sth;\n}\n\n\nsub primary_key_info {\n  my ($dbh, $catalog, $schema, $table) = @_;\n\n  return unless $dbh->func('_async_check');\n\n  $dbh->{mysql_server_prepare}||= 0;\n  my $mysql_server_prepare_save= $dbh->{mysql_server_prepare};\n\n  my $table_id = $dbh->quote_identifier($catalog, $schema, $table);\n\n  my @names = qw(\n      TABLE_CAT TABLE_SCHEM TABLE_NAME COLUMN_NAME KEY_SEQ PK_NAME\n      );\n  my %col_info;\n\n  local $dbh->{FetchHashKeyName} = 'NAME_lc';\n  my $desc_sth = $dbh->prepare(\"SHOW KEYS FROM $table_id\");\n  my $desc= $dbh->selectall_arrayref($desc_sth, { Columns=>{} });\n  my $ordinal_pos = 0;\n  for my $row (grep { $_->{key_name} eq 'PRIMARY'} @$desc)\n  {\n    $col_info{ $row->{column_name} }= {\n      TABLE_CAT   => $catalog,\n      TABLE_SCHEM => $schema,\n      TABLE_NAME  => $table,\n      COLUMN_NAME => $row->{column_name},\n      KEY_SEQ     => $row->{seq_in_index},\n      PK_NAME     => $row->{key_name},\n    };\n  }\n\n  my $sponge = DBI->connect(\"DBI:Sponge:\", '','')\n    or\n     ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n      return $dbh->DBI::set_err($DBI::err, \"DBI::Sponge: $DBI::errstr\"));\n\n  my $sth= $sponge->prepare(\"primary_key_info $table\", {\n      rows          => [\n        map { [ @{$_}{@names} ] }\n        sort { $a->{KEY_SEQ} <=> $b->{KEY_SEQ} }\n        values %col_info\n      ],\n      NUM_OF_FIELDS => scalar @names,\n      NAME          => \\@names,\n      }) or\n       ($dbh->{mysql_server_prepare}= $mysql_server_prepare_save &&\n        return $dbh->DBI::set_err($sponge->err(), $sponge->errstr()));\n\n  $dbh->{mysql_server_prepare}= $mysql_server_prepare_save;\n\n  return $sth;\n}\n\n\nsub foreign_key_info {\n    my ($dbh,\n        $pk_catalog, $pk_schema, $pk_table,\n        $fk_catalog, $fk_schema, $fk_table,\n       ) = @_;\n\n    return unless $dbh->func('_async_check');\n\n    # INFORMATION_SCHEMA.KEY_COLUMN_USAGE was added in 5.0.6\n    # no one is going to be running 5.0.6, taking out the check for $point > .6\n    my ($maj, $min, $point) = _version($dbh);\n    return if $maj < 5 ;\n\n    my $sql = <<'EOF';\nSELECT NULL AS PKTABLE_CAT,\n       A.REFERENCED_TABLE_SCHEMA AS PKTABLE_SCHEM,\n       A.REFERENCED_TABLE_NAME AS PKTABLE_NAME,\n       A.REFERENCED_COLUMN_NAME AS PKCOLUMN_NAME,\n       A.TABLE_CATALOG AS FKTABLE_CAT,\n       A.TABLE_SCHEMA AS FKTABLE_SCHEM,\n       A.TABLE_NAME AS FKTABLE_NAME,\n       A.COLUMN_NAME AS FKCOLUMN_NAME,\n       A.ORDINAL_POSITION AS KEY_SEQ,\n       NULL AS UPDATE_RULE,\n       NULL AS DELETE_RULE,\n       A.CONSTRAINT_NAME AS FK_NAME,\n       NULL AS PK_NAME,\n       NULL AS DEFERABILITY,\n       NULL AS UNIQUE_OR_PRIMARY\n  FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE A,\n       INFORMATION_SCHEMA.TABLE_CONSTRAINTS B\n WHERE A.TABLE_SCHEMA = B.TABLE_SCHEMA AND A.TABLE_NAME = B.TABLE_NAME\n   AND A.CONSTRAINT_NAME = B.CONSTRAINT_NAME AND B.CONSTRAINT_TYPE IS NOT NULL\nEOF\n\n    my @where;\n    my @bind;\n\n    # catalogs are not yet supported by MySQL\n\n#    if (defined $pk_catalog) {\n#        push @where, 'A.REFERENCED_TABLE_CATALOG = ?';\n#        push @bind, $pk_catalog;\n#    }\n\n    if (defined $pk_schema) {\n        push @where, 'A.REFERENCED_TABLE_SCHEMA = ?';\n        push @bind, $pk_schema;\n    }\n\n    if (defined $pk_table) {\n        push @where, 'A.REFERENCED_TABLE_NAME = ?';\n        push @bind, $pk_table;\n    }\n\n#    if (defined $fk_catalog) {\n#        push @where, 'A.TABLE_CATALOG = ?';\n#        push @bind,  $fk_schema;\n#    }\n\n    if (defined $fk_schema) {\n        push @where, 'A.TABLE_SCHEMA = ?';\n        push @bind,  $fk_schema;\n    }\n\n    if (defined $fk_table) {\n        push @where, 'A.TABLE_NAME = ?';\n        push @bind,  $fk_table;\n    }\n\n    if (@where) {\n        $sql .= ' AND ';\n        $sql .= join ' AND ', @where;\n    }\n    $sql .= \" ORDER BY A.TABLE_SCHEMA, A.TABLE_NAME, A.ORDINAL_POSITION\";\n\n    local $dbh->{FetchHashKeyName} = 'NAME_uc';\n    my $sth = $dbh->prepare($sql);\n    $sth->execute(@bind);\n\n    return $sth;\n}\n# #86030: PATCH: adding statistics_info support\n# Thank you to David Dick http://search.cpan.org/~ddick/\nsub statistics_info {\n    my ($dbh,\n        $catalog, $schema, $table,\n        $unique_only, $quick,\n       ) = @_;\n\n    return unless $dbh->func('_async_check');\n\n    # INFORMATION_SCHEMA.KEY_COLUMN_USAGE was added in 5.0.6\n    # no one is going to be running 5.0.6, taking out the check for $point > .6\n    my ($maj, $min, $point) = _version($dbh);\n    return if $maj < 5 ;\n\n    my $sql = <<'EOF';\nSELECT TABLE_CATALOG AS TABLE_CAT,\n       TABLE_SCHEMA AS TABLE_SCHEM,\n       TABLE_NAME AS TABLE_NAME,\n       NON_UNIQUE AS NON_UNIQUE,\n       NULL AS INDEX_QUALIFIER,\n       INDEX_NAME AS INDEX_NAME,\n       LCASE(INDEX_TYPE) AS TYPE,\n       SEQ_IN_INDEX AS ORDINAL_POSITION,\n       COLUMN_NAME AS COLUMN_NAME,\n       COLLATION AS ASC_OR_DESC,\n       CARDINALITY AS CARDINALITY,\n       NULL AS PAGES,\n       NULL AS FILTER_CONDITION\n  FROM INFORMATION_SCHEMA.STATISTICS\nEOF\n\n    my @where;\n    my @bind;\n\n    # catalogs are not yet supported by MySQL\n\n#    if (defined $catalog) {\n#        push @where, 'TABLE_CATALOG = ?';\n#        push @bind, $catalog;\n#    }\n\n    if (defined $schema) {\n        push @where, 'TABLE_SCHEMA = ?';\n        push @bind, $schema;\n    }\n\n    if (defined $table) {\n        push @where, 'TABLE_NAME = ?';\n        push @bind, $table;\n    }\n\n    if (@where) {\n        $sql .= ' WHERE ';\n        $sql .= join ' AND ', @where;\n    }\n    $sql .= \" ORDER BY TABLE_SCHEMA, TABLE_NAME, ORDINAL_POSITION\";\n\n    local $dbh->{FetchHashKeyName} = 'NAME_uc';\n    my $sth = $dbh->prepare($sql);\n    $sth->execute(@bind);\n\n    return $sth;\n}\n\nsub _version {\n    my $dbh = shift;\n\n    return\n        $dbh->get_info($DBI::Const::GetInfoType::GetInfoType{SQL_DBMS_VER})\n            =~ /(\\d+)\\.(\\d+)\\.(\\d+)/;\n}\n\n\n####################\n# get_info()\n# Generated by DBI::DBD::Metadata\n\nsub get_info {\n    my($dbh, $info_type) = @_;\n\n    return unless $dbh->func('_async_check');\n    require DBD::mysql::GetInfo;\n    my $v = $DBD::mysql::GetInfo::info{int($info_type)};\n    $v = $v->($dbh) if ref $v eq 'CODE';\n    return $v;\n}\n\nBEGIN {\n    my @needs_async_check = qw/data_sources quote_identifier begin_work/;\n\n    foreach my $method (@needs_async_check) {\n        no strict 'refs';\n\n        my $super = \"SUPER::$method\";\n        *$method  = sub {\n            my $h = shift;\n            return unless $h->func('_async_check');\n            return $h->$super(@_);\n        };\n    }\n}\n\n\npackage DBD::mysql::st; # ====== STATEMENT ======\nuse strict;\n\nBEGIN {\n    my @needs_async_result = qw/fetchrow_hashref fetchall_hashref/;\n    my @needs_async_check = qw/bind_param_array bind_col bind_columns execute_for_fetch/;\n\n    foreach my $method (@needs_async_result) {\n        no strict 'refs';\n\n        my $super = \"SUPER::$method\";\n        *$method = sub {\n            my $sth = shift;\n            if(defined $sth->mysql_async_ready) {\n                return unless $sth->mysql_async_result;\n            }\n            return $sth->$super(@_);\n        };\n    }\n\n    foreach my $method (@needs_async_check) {\n        no strict 'refs';\n\n        my $super = \"SUPER::$method\";\n        *$method = sub {\n            my $h = shift;\n            return unless $h->func('_async_check');\n            return $h->$super(@_);\n        };\n    }\n}\n\n1;\n\n__END__\n\n=pod\n\n=encoding utf8\n\n=head1 NAME\n\nDBD::mysql - MySQL driver for the Perl5 Database Interface (DBI)\n\n=head1 SYNOPSIS\n\n    use DBI;\n\n    my $dsn = \"DBI:mysql:database=$database;host=$hostname;port=$port\";\n    my $dbh = DBI->connect($dsn, $user, $password);\n\n    my $sth = $dbh->prepare(\n        'SELECT id, first_name, last_name FROM authors WHERE last_name = ?')\n        or die \"prepare statement failed: $dbh->errstr()\";\n    $sth->execute('Eggers') or die \"execution failed: $dbh->errstr()\";\n    print $sth->rows . \" rows found.\\n\";\n    while (my $ref = $sth->fetchrow_hashref()) {\n        print \"Found a row: id = $ref->{'id'}, fn = $ref->{'first_name'}\\n\";\n    }\n    $sth->finish;\n\n\n=head1 EXAMPLE\n\n  #!/usr/bin/perl\n\n  use strict;\n  use warnings;\n  use DBI;\n\n  # Connect to the database.\n  my $dbh = DBI->connect(\"DBI:mysql:database=test;host=localhost\",\n                         \"joe\", \"joe's password\",\n                         {'RaiseError' => 1});\n\n  # Drop table 'foo'. This may fail, if 'foo' doesn't exist\n  # Thus we put an eval around it.\n  eval { $dbh->do(\"DROP TABLE foo\") };\n  print \"Dropping foo failed: $@\\n\" if $@;\n\n  # Create a new table 'foo'. This must not fail, thus we don't\n  # catch errors.\n  $dbh->do(\"CREATE TABLE foo (id INTEGER, name VARCHAR(20))\");\n\n  # INSERT some data into 'foo'. We are using $dbh->quote() for\n  # quoting the name.\n  $dbh->do(\"INSERT INTO foo VALUES (1, \" . $dbh->quote(\"Tim\") . \")\");\n\n  # same thing, but using placeholders (recommended!)\n  $dbh->do(\"INSERT INTO foo VALUES (?, ?)\", undef, 2, \"Jochen\");\n\n  # now retrieve data from the table.\n  my $sth = $dbh->prepare(\"SELECT * FROM foo\");\n  $sth->execute();\n  while (my $ref = $sth->fetchrow_hashref()) {\n    print \"Found a row: id = $ref->{'id'}, name = $ref->{'name'}\\n\";\n  }\n  $sth->finish();\n\n  # Disconnect from the database.\n  $dbh->disconnect();\n\n\n=head1 DESCRIPTION\n\nB<DBD::mysql> is the Perl5 Database Interface driver for the MySQL\ndatabase. In other words: DBD::mysql is an interface between the Perl\nprogramming language and the MySQL programming API that comes with\nthe MySQL relational database management system. Most functions\nprovided by this programming API are supported. Some rarely used\nfunctions are missing, mainly because no-one ever requested\nthem. :-)\n\nIn what follows we first discuss the use of DBD::mysql,\nbecause this is what you will need the most. For installation, see the\nseparate document L<DBD::mysql::INSTALL>.\nSee L</\"EXAMPLE\"> for a simple example above.\n\nFrom perl you activate the interface with the statement\n\n  use DBI;\n\nAfter that you can connect to multiple MySQL database servers\nand send multiple queries to any of them via a simple object oriented\ninterface. Two types of objects are available: database handles and\nstatement handles. Perl returns a database handle to the connect\nmethod like so:\n\n  $dbh = DBI->connect(\"DBI:mysql:database=$db;host=$host\",\n    $user, $password, {RaiseError => 1});\n\nOnce you have connected to a database, you can execute SQL\nstatements with:\n\n  my $query = sprintf(\"INSERT INTO foo VALUES (%d, %s)\",\n\t\t      $number, $dbh->quote(\"name\"));\n  $dbh->do($query);\n\nSee L<DBI> for details on the quote and do methods. An alternative\napproach is\n\n  $dbh->do(\"INSERT INTO foo VALUES (?, ?)\", undef,\n\t   $number, $name);\n\nin which case the quote method is executed automatically. See also\nthe bind_param method in L<DBI>. See L</\"DATABASE HANDLES\"> below\nfor more details on database handles.\n\nIf you want to retrieve results, you need to create a so-called\nstatement handle with:\n\n  $sth = $dbh->prepare(\"SELECT * FROM $table\");\n  $sth->execute();\n\nThis statement handle can be used for multiple things. First of all\nyou can retrieve a row of data:\n\n  my $row = $sth->fetchrow_hashref();\n\nIf your table has columns ID and NAME, then $row will be hash ref with\nkeys ID and NAME. See L</\"STATEMENT HANDLES\"> below for more details on\nstatement handles.\n\nBut now for a more formal approach:\n\n\n=head2 Class Methods\n\n=over\n\n=item B<connect>\n\n    use DBI;\n\n    $dsn = \"DBI:mysql:$database\";\n    $dsn = \"DBI:mysql:database=$database;host=$hostname\";\n    $dsn = \"DBI:mysql:database=$database;host=$hostname;port=$port\";\n\n    $dbh = DBI->connect($dsn, $user, $password);\n\nThe C<database> is not a required attribute, but please note that MySQL\nhas no such thing as a default database. If you don't specify the database\nat connection time your active database will be null and you'd need to prefix\nyour tables with the database name; i.e. 'SELECT * FROM mydb.mytable'.\n\nThis is similar to the behavior of the mysql command line client. Also,\n'SELECT DATABASE()' will return the current database active for the handle.\n\n=over\n\n=item host\n\n=item port\n\nThe hostname, if not specified or specified as '' or 'localhost', will\ndefault to a MySQL server running on the local machine using the default for\nthe UNIX socket. To connect to a MySQL server on the local machine via TCP,\nyou must specify the loopback IP address (127.0.0.1) as the host.\n\nShould the MySQL server be running on a non-standard port number,\nyou may explicitly state the port number to connect to in the C<hostname>\nargument, by concatenating the I<hostname> and I<port number> together\nseparated by a colon ( C<:> ) character or by using the  C<port> argument.\n\nTo connect to a MySQL server on localhost using TCP/IP, you must specify the\nhostname as 127.0.0.1 (with the optional port).\n\nWhen connecting to a MySQL Server with IPv6, a bracketed IPv6 address should be used.\nExample DSN:\n\n  my $dsn = \"DBI:mysql:;host=[1a12:2800:6f2:85::f20:8cf];port=3306\";\n\n\n=item mysql_client_found_rows\n\nEnables (TRUE value) or disables (FALSE value) the flag CLIENT_FOUND_ROWS\nwhile connecting to the MySQL server. This has a somewhat funny effect:\nWithout mysql_client_found_rows, if you perform a query like\n\n  UPDATE $table SET id = 1 WHERE id = 1;\n\nthen the MySQL engine will always return 0, because no rows have changed.\nWith mysql_client_found_rows however, it will return the number of rows\nthat have an id 1, as some people are expecting. (At least for compatibility\nto other engines.)\n\n=item mysql_compression\n\nIf your DSN contains the option \"mysql_compression=1\", then the communication\nbetween client and server will be compressed.\n\n=item mysql_connect_timeout\n\nIf your DSN contains the option \"mysql_connect_timeout=##\", the connect\nrequest to the server will timeout if it has not been successful after\nthe given number of seconds.\n\n=item mysql_write_timeout\n\nIf your DSN contains the option \"mysql_write_timeout=##\", the write\noperation to the server will timeout if it has not been successful after\nthe given number of seconds.\n\n=item mysql_read_timeout\n\nIf your DSN contains the option \"mysql_read_timeout=##\", the read\noperation to the server will timeout if it has not been successful after\nthe given number of seconds.\n\n=item mysql_init_command\n\nIf your DSN contains the option \"mysql_init_command=##\", then\nthis SQL statement is executed when connecting to the MySQL server.\nIt is automatically re-executed if reconnection occurs.\n\n=item mysql_skip_secure_auth\n\nThis option is for older mysql databases that don't have secure auth set.\n\n=item mysql_read_default_file\n\n=item mysql_read_default_group\n\nThese options can be used to read a config file like /etc/my.cnf or\n~/.my.cnf. By default MySQL's C client library doesn't use any config\nfiles unlike the client programs (mysql, mysqladmin, ...) that do, but\noutside of the C client library. Thus you need to explicitly request\nreading a config file, as in\n\n    $dsn = \"DBI:mysql:test;mysql_read_default_file=/home/joe/my.cnf\";\n    $dbh = DBI->connect($dsn, $user, $password)\n\nThe option mysql_read_default_group can be used to specify the default\ngroup in the config file: Usually this is the I<client> group, but\nsee the following example:\n\n    [client]\n    host=localhost\n\n    [perl]\n    host=perlhost\n\n(Note the order of the entries! The example won't work, if you reverse\nthe [client] and [perl] sections!)\n\nIf you read this config file, then you'll be typically connected to\nI<localhost>. However, by using\n\n    $dsn = \"DBI:mysql:test;mysql_read_default_group=perl;\"\n        . \"mysql_read_default_file=/home/joe/my.cnf\";\n    $dbh = DBI->connect($dsn, $user, $password);\n\nyou'll be connected to I<perlhost>. Note that if you specify a\ndefault group and do not specify a file, then the default config\nfiles will all be read.  See the documentation of\nthe C function mysql_options() for details.\n\n=item mysql_socket\n\nIt is possible to choose the Unix socket that is\nused for connecting to the server. This is done, for example, with\n\n    mysql_socket=/dev/mysql\n\nUsually there's no need for this option, unless you are using another\nlocation for the socket than that built into the client.\n\n=item mysql_ssl\n\nA true value turns on the CLIENT_SSL flag when connecting to the MySQL\ndatabase:\n\n  mysql_ssl=1\n\nThis means that your communication with the server will be encrypted.\n\nPlease note that this can only work if you enabled SSL when compiling\nDBD::mysql; this is the default starting version 4.034.\nSee L<DBD::mysql::INSTALL> for more details.\n\nIf you turn mysql_ssl on, you might also wish to use the following\nflags:\n\n=item mysql_ssl_client_key\n\n=item mysql_ssl_client_cert\n\n=item mysql_ssl_ca_file\n\n=item mysql_ssl_ca_path\n\n=item mysql_ssl_cipher\n\nThese are used to specify the respective parameters of a call\nto mysql_ssl_set, if mysql_ssl is turned on.\n\n\n=item mysql_local_infile\n\nThe LOCAL capability for LOAD DATA may be disabled\nin the MySQL client library by default. If your DSN contains the option\n\"mysql_local_infile=1\", LOAD DATA LOCAL will be enabled.  (However,\nthis option is *ineffective* if the server has also been configured to\ndisallow LOCAL.)\n\n=item mysql_multi_statements\n\nSupport for multiple statements separated by a semicolon\n(;) may be enabled by using this option. Enabling this option may cause\nproblems if server-side prepared statements are also enabled.\n\n=item Prepared statement support (server side prepare)\n\nTo use server side prepared statements, all you need to do is set the variable\nmysql_server_prepare in the connect:\n\n  $dbh = DBI->connect(\n    \"DBI:mysql:database=test;host=localhost;mysql_server_prepare=1\",\n    \"\",\n    \"\",\n    { RaiseError => 1, AutoCommit => 1 }\n  );\n\nThere are many benefits to using server side prepare statements, mostly if you are\nperforming many inserts because of that fact that a single statement is prepared\nto accept multiple insert values.\n\nTo make sure that the 'make test' step tests whether server prepare works, you just\nneed to export the env variable MYSQL_SERVER_PREPARE:\n\n  export MYSQL_SERVER_PREPARE=1\n\n\n=item mysql_embedded_options\n\nThe option <mysql_embedded_options> can be used to pass 'command-line'\noptions to embedded server.\n\nExample:\n\n  use DBI;\n  $testdsn=\"DBI:mysqlEmb:database=test;mysql_embedded_options=--help,--verbose\";\n  $dbh = DBI->connect($testdsn,\"a\",\"b\");\n\nThis would cause the command line help to the embedded MySQL server library\nto be printed.\n\n\n=item mysql_embedded_groups\n\nThe option <mysql_embedded_groups> can be used to specify the groups in the\nconfig file(I<my.cnf>) which will be used to get options for embedded server.\nIf not specified [server] and [embedded] groups will be used.\n\nExample:\n\n  $testdsn=\"DBI:mysqlEmb:database=test;mysql_embedded_groups=embedded_server,common\";\n\n=item mysql_conn_attrs\n\nThe option <mysql_conn_attrs> is a hash of attribute names and values which can be\nused to send custom connection attributes to the server. Some attributes like\n'_os', '_platform', '_client_name' and '_client_version' are added by libmysqlclient\nand 'program_name' is added by DBD::mysql.\n\nYou can then later read these attributes from the performance schema tables which\ncan be quite helpful for profiling your database or creating statistics.\nYou'll have to use a MySQL 5.6 server and libmysqlclient or newer to leverage this\nfeature.\n\n  my $dbh= DBI->connect($dsn, $user, $password,\n    { AutoCommit => 0,\n      mysql_conn_attrs => {\n        foo => 'bar',\n        wiz => 'bang'\n      },\n    });\n\nNow you can select the results from the performance schema tables. You can do this\nin the same session, but also afterwards. It can be very useful to answer questions\nlike 'which script sent this query?'.\n\n  my $results = $dbh->selectall_hashref(\n    'SELECT * FROM performance_schema.session_connect_attrs',\n    'ATTR_NAME'\n  );\n\nThis returns:\n\n  $result = {\n    'foo' => {\n        'ATTR_VALUE'       => 'bar',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => 'foo',\n        'ORDINAL_POSITION' => '6'\n    },\n    'wiz' => {\n        'ATTR_VALUE'       => 'bang',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => 'wiz',\n        'ORDINAL_POSITION' => '3'\n    },\n    'program_name' => {\n        'ATTR_VALUE'       => './foo.pl',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => 'program_name',\n        'ORDINAL_POSITION' => '5'\n    },\n    '_client_name' => {\n        'ATTR_VALUE'       => 'libmysql',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_client_name',\n        'ORDINAL_POSITION' => '1'\n    },\n    '_client_version' => {\n        'ATTR_VALUE'       => '5.6.24',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_client_version',\n        'ORDINAL_POSITION' => '7'\n    },\n    '_os' => {\n        'ATTR_VALUE'       => 'osx10.8',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_os',\n        'ORDINAL_POSITION' => '0'\n    },\n    '_pid' => {\n        'ATTR_VALUE'       => '59860',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_pid',\n        'ORDINAL_POSITION' => '2'\n    },\n    '_platform' => {\n        'ATTR_VALUE'       => 'x86_64',\n        'PROCESSLIST_ID'   => '3',\n        'ATTR_NAME'        => '_platform',\n        'ORDINAL_POSITION' => '4'\n    }\n  };\n\n=back\n\n=back\n\n\n=head2 Private MetaData Methods\n\n=over\n\n=item B<ListDBs>\n\n    my $drh = DBI->install_driver(\"mysql\");\n    @dbs = $drh->func(\"$hostname:$port\", '_ListDBs');\n    @dbs = $drh->func($hostname, $port, '_ListDBs');\n    @dbs = $dbh->func('_ListDBs');\n\nReturns a list of all databases managed by the MySQL server\nrunning on C<$hostname>, port C<$port>. This is a legacy\nmethod.  Instead, you should use the portable method\n\n    @dbs = DBI->data_sources(\"mysql\");\n\n=back\n\n\n=head1 DATABASE HANDLES\n\nThe DBD::mysql driver supports the following attributes of database\nhandles (read only):\n\n  $errno = $dbh->{'mysql_errno'};\n  $error = $dbh->{'mysql_error'};\n  $info = $dbh->{'mysql_hostinfo'};\n  $info = $dbh->{'mysql_info'};\n  $insertid = $dbh->{'mysql_insertid'};\n  $info = $dbh->{'mysql_protoinfo'};\n  $info = $dbh->{'mysql_serverinfo'};\n  $info = $dbh->{'mysql_stat'};\n  $threadId = $dbh->{'mysql_thread_id'};\n\nThese correspond to mysql_errno(), mysql_error(), mysql_get_host_info(),\nmysql_info(), mysql_insert_id(), mysql_get_proto_info(),\nmysql_get_server_info(), mysql_stat() and mysql_thread_id(),\nrespectively.\n\n=over 2\n\n=item mysql_clientinfo\n\nList information of the MySQL client library that DBD::mysql was built\nagainst:\n\n  print \"$dbh->{mysql_clientinfo}\\n\";\n\n  5.2.0-MariaDB\n\n=item mysql_clientversion\n\n  print \"$dbh->{mysql_clientversion}\\n\";\n\n  50200\n\n=item mysql_serverversion\n\n  print \"$dbh->{mysql_serverversion}\\n\";\n\n  50200\n\n=item mysql_dbd_stats\n\n  $info_hashref = $dhb->{mysql_dbd_stats};\n\nDBD::mysql keeps track of some statistics in the mysql_dbd_stats attribute.\nThe following stats are being maintained:\n\n=over 8\n\n=item auto_reconnects_ok\n\nThe number of times that DBD::mysql successfully reconnected to the mysql\nserver.\n\n=item auto_reconnects_failed\n\nThe number of times that DBD::mysql tried to reconnect to mysql but failed.\n\n=back\n\n=back\n\nThe DBD::mysql driver also supports the following attributes of database\nhandles (read/write):\n\n=over\n\n=item mysql_auto_reconnect\n\nThis attribute determines whether DBD::mysql will automatically reconnect\nto mysql if the connection be lost. This feature defaults to off; however,\nif either the GATEWAY_INTERFACE or MOD_PERL environment variable is set,\nDBD::mysql will turn mysql_auto_reconnect on.  Setting mysql_auto_reconnect\nto on is not advised if 'lock tables' is used because if DBD::mysql reconnect\nto mysql all table locks will be lost.  This attribute is ignored when\nAutoCommit is turned off, and when AutoCommit is turned off, DBD::mysql will\nnot automatically reconnect to the server.\n\nIt is also possible to set the default value of the C<mysql_auto_reconnect>\nattribute for the $dbh by passing it in the C<\\%attr> hash for C<DBI->connect>.\n\n  $dbh->{mysql_auto_reconnect} = 1;\n\nor\n\n  my $dbh = DBI->connect($dsn, $user, $password, {\n     mysql_auto_reconnect => 1,\n  });\n\nNote that if you are using a module or framework that performs reconnections\nfor you (for example L<DBIx::Connector> in fixup mode), this value must be set\nto 0.\n\n=item mysql_use_result\n\nThis attribute forces the driver to use mysql_use_result rather than\nmysql_store_result.  The former is faster and less memory consuming, but\ntends to block other processes.  mysql_store_result is the default due to that\nfact storing the result is expected behavior with most applications.\n\nIt is possible to set the default value of the C<mysql_use_result> attribute\nfor the $dbh via the DSN:\n\n  $dbh = DBI->connect(\"DBI:mysql:test;mysql_use_result=1\", \"root\", \"\");\n\nYou can also set it after creation of the database handle:\n\n   $dbh->{mysql_use_result} = 0; # disable\n   $dbh->{mysql_use_result} = 1; # enable\n\nYou can also set or unset the C<mysql_use_result> setting on your statement\nhandle, when creating the statement handle or after it has been created.\nSee L</\"STATEMENT HANDLES\">.\n\n=item mysql_enable_utf8\n\nThis attribute determines whether DBD::mysql should assume strings\nstored in the database are utf8.  This feature defaults to off.\n\nWhen set, a data retrieved from a textual column type (char, varchar,\netc) will have the UTF-8 flag turned on if necessary.  This enables\ncharacter semantics on that string.  You will also need to ensure that\nyour database / table / column is configured to use UTF8. See for more\ninformation the chapter on character set support in the MySQL manual:\nL<http://dev.mysql.com/doc/refman/5.7/en/charset.html>\n\nAdditionally, turning on this flag tells MySQL that incoming data should\nbe treated as UTF-8.  This will only take effect if used as part of the\ncall to connect().  If you turn the flag on after connecting, you will\nneed to issue the command C<SET NAMES utf8> to get the same effect.\n\n=item mysql_enable_utf8mb4\n\nThis is similar to mysql_enable_utf8, but is capable of handling 4-byte\nUTF-8 characters.\n\n=item mysql_bind_type_guessing\n\nThis attribute causes the driver (emulated prepare statements)\nto attempt to guess if a value being bound is a numeric value,\nand if so, doesn't quote the value.  This was created by\nDragonchild and is one way to deal with the performance issue\nof using quotes in a statement that is inserting or updating a\nlarge numeric value. This was previously called\nC<unsafe_bind_type_guessing> because it is experimental. I have\nsuccessfully run the full test suite with this option turned on,\nthe name can now be simply C<mysql_bind_type_guessing>.\n\nCAVEAT: Even though you can insert an integer value into a\ncharacter column, if this column is indexed, if you query that\ncolumn with the integer value not being quoted, it will not\nuse the index:\n\n    MariaDB [test]> explain select * from test where value0 = '3' \\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: test\n             type: ref\n    possible_keys: value0\n              key: value0\n          key_len: 13\n              ref: const\n             rows: 1\n            Extra: Using index condition\n    1 row in set (0.00 sec)\n\n    MariaDB [test]> explain select * from test where value0 = 3\n        -> \\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: test\n             type: ALL\n    possible_keys: value0\n              key: NULL\n          key_len: NULL\n              ref: NULL\n             rows: 6\n            Extra: Using where\n    1 row in set (0.00 sec)\n\nSee bug: https://rt.cpan.org/Ticket/Display.html?id=43822\n\nC<mysql_bind_type_guessing> can be turned on via\n\n - through DSN\n\n  my $dbh= DBI->connect('DBI:mysql:test', 'username', 'pass',\n  { mysql_bind_type_guessing => 1})\n\n  - OR after handle creation\n\n  $dbh->{mysql_bind_type_guessing} = 1;\n\n=item mysql_bind_comment_placeholders\n\nThis attribute causes the driver (emulated prepare statements)\nwill cause any placeholders in comments to be bound. This is\nnot correct prepared statement behavior, but some developers\nhave come to depend on this behavior, so I have made it available\nin 4.015\n\n=item mysql_no_autocommit_cmd\n\nThis attribute causes the driver to not issue 'set autocommit'\neither through explicit or using mysql_autocommit(). This is\nparticularly useful in the case of using MySQL Proxy.\n\nSee the bug report:\n\nhttps://rt.cpan.org/Public/Bug/Display.html?id=46308\n\n\nC<mysql_no_autocommit_cmd> can be turned on when creating the database\nhandle:\n\n  my $dbh = DBI->connect('DBI:mysql:test', 'username', 'pass',\n  { mysql_no_autocommit_cmd => 1});\n\nor using an existing database handle:\n\n  $dbh->{mysql_no_autocommit_cmd} = 1;\n\n=item ping\n\nThis can be used to send a ping to the server.\n\n  $rc = $dbh->ping();\n\n=back\n\n\n=head1 STATEMENT HANDLES\n\nThe statement handles of DBD::mysql support a number\nof attributes. You access these by using, for example,\n\n  my $numFields = $sth->{NUM_OF_FIELDS};\n\nNote, that most attributes are valid only after a successful I<execute>.\nAn C<undef> value will returned otherwise. The most important exception\nis the C<mysql_use_result> attribute, which forces the driver to use\nmysql_use_result rather than mysql_store_result. The former is faster\nand less memory consuming, but tends to block other processes. (That's why\nmysql_store_result is the default.)\n\nTo set the C<mysql_use_result> attribute, use either of the following:\n\n  my $sth = $dbh->prepare(\"QUERY\", { mysql_use_result => 1});\n\nor\n\n  my $sth = $dbh->prepare($sql);\n  $sth->{mysql_use_result} = 1;\n\nColumn dependent attributes, for example I<NAME>, the column names,\nare returned as a reference to an array. The array indices are\ncorresponding to the indices of the arrays returned by I<fetchrow>\nand similar methods. For example the following code will print a\nheader of table names together with all rows:\n\n  my $sth = $dbh->prepare(\"SELECT * FROM $table\") ||\n    die \"Error:\" . $dbh->errstr . \"\\n\";\n\n  $sth->execute ||  die \"Error:\" . $sth->errstr . \"\\n\";\n\n  my $names = $sth->{NAME};\n  my $numFields = $sth->{'NUM_OF_FIELDS'} - 1;\n  for my $i ( 0..$numFields ) {\n      printf(\"%s%s\", $i ? \",\" : \"\", $$names[$i]);\n  }\n  print \"\\n\";\n  while (my $ref = $sth->fetchrow_arrayref) {\n      for my $i ( 0..$numFields ) {\n      printf(\"%s%s\", $i ? \",\" : \"\", $$ref[$i]);\n      }\n      print \"\\n\";\n  }\n\nFor portable applications you should restrict yourself to attributes with\ncapitalized or mixed case names. Lower case attribute names are private\nto DBD::mysql. The attribute list includes:\n\n=over\n\n=item ChopBlanks\n\nthis attribute determines whether a I<fetchrow> will chop preceding\nand trailing blanks off the column values. Chopping blanks does not\nhave impact on the I<max_length> attribute.\n\n=item mysql_insertid\n\nIf the statement you executed performs an INSERT, and there is an AUTO_INCREMENT\ncolumn in the table you inserted in, this attribute holds the value stored into\nthe AUTO_INCREMENT column, if that value is automatically generated, by\nstoring NULL or 0 or was specified as an explicit value.\n\nTypically, you'd access the value via $sth->{mysql_insertid}. The value can\nalso be accessed via $dbh->{mysql_insertid} but this can easily\nproduce incorrect results in case one database handle is shared.\n\n=item mysql_is_blob\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column is a blob. This attribute is valid for MySQL only.\n\n=item mysql_is_key\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column is a key. This is valid for MySQL only.\n\n=item mysql_is_num\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column contains numeric values.\n\n=item mysql_is_pri_key\n\nReference to an array of boolean values; TRUE indicates, that the\nrespective column is a primary key.\n\n=item mysql_is_auto_increment\n\nReference to an array of boolean values; TRUE indicates that the\nrespective column is an AUTO_INCREMENT column.  This is only valid\nfor MySQL.\n\n=item mysql_length\n\n=item mysql_max_length\n\nA reference to an array of maximum column sizes. The I<max_length> is\nthe maximum physically present in the result table, I<length> gives\nthe theoretically possible maximum. I<max_length> is valid for MySQL\nonly.\n\n=item NAME\n\nA reference to an array of column names.\n\n=item NULLABLE\n\nA reference to an array of boolean values; TRUE indicates that this column\nmay contain NULL's.\n\n=item NUM_OF_FIELDS\n\nNumber of fields returned by a I<SELECT> or I<LISTFIELDS> statement.\nYou may use this for checking whether a statement returned a result:\nA zero value indicates a non-SELECT statement like I<INSERT>,\nI<DELETE> or I<UPDATE>.\n\n=item mysql_table\n\nA reference to an array of table names, useful in a I<JOIN> result.\n\n=item TYPE\n\nA reference to an array of column types. The engine's native column\ntypes are mapped to portable types like DBI::SQL_INTEGER() or\nDBI::SQL_VARCHAR(), as good as possible. Not all native types have\na meaningful equivalent, for example DBD::mysql::FIELD_TYPE_INTERVAL\nis mapped to DBI::SQL_VARCHAR().\nIf you need the native column types, use I<mysql_type>. See below.\n\n=item mysql_type\n\nA reference to an array of MySQL's native column types, for example\nDBD::mysql::FIELD_TYPE_SHORT() or DBD::mysql::FIELD_TYPE_STRING().\nUse the I<TYPE> attribute, if you want portable types like\nDBI::SQL_SMALLINT() or DBI::SQL_VARCHAR().\n\n=item mysql_type_name\n\nSimilar to mysql, but type names and not numbers are returned.\nWhenever possible, the ANSI SQL name is preferred.\n\n=item mysql_warning_count\n\nThe number of warnings generated during execution of the SQL statement.\nThis attribute is available on both statement handles and database handles.\n\n=back\n\n=head1 TRANSACTION SUPPORT\n\nThe transaction support works as follows:\n\n=over\n\n=item *\n\nBy default AutoCommit mode is on, following the DBI specifications.\n\n=item *\n\nIf you execute\n\n  $dbh->{AutoCommit} = 0;\n\nor\n\n  $dbh->{AutoCommit} = 1;\n\nthen the driver will set the MySQL server variable autocommit to 0 or\n1, respectively. Switching from 0 to 1 will also issue a COMMIT,\nfollowing the DBI specifications.\n\n=item *\n\nThe methods\n\n    $dbh->rollback();\n    $dbh->commit();\n\nwill issue the commands ROLLBACK and COMMIT, respectively. A\nROLLBACK will also be issued if AutoCommit mode is off and the\ndatabase handles DESTROY method is called. Again, this is following\nthe DBI specifications.\n\n=back\n\nGiven the above, you should note the following:\n\n=over\n\n=item *\n\nYou should never change the server variable autocommit manually,\nunless you are ignoring DBI's transaction support.\n\n=item *\n\nSwitching AutoCommit mode from on to off or vice versa may fail.\nYou should always check for errors when changing AutoCommit mode.\nThe suggested way of doing so is using the DBI flag RaiseError.\nIf you don't like RaiseError, you have to use code like the\nfollowing:\n\n  $dbh->{AutoCommit} = 0;\n  if ($dbh->{AutoCommit}) {\n    # An error occurred!\n  }\n\n=item *\n\nIf you detect an error while changing the AutoCommit mode, you\nshould no longer use the database handle. In other words, you\nshould disconnect and reconnect again, because the transaction\nmode is unpredictable. Alternatively you may verify the transaction\nmode by checking the value of the server variable autocommit.\nHowever, such behaviour isn't portable.\n\n=item *\n\nDBD::mysql has a \"reconnect\" feature that handles the so-called\nMySQL \"morning bug\": If the server has disconnected, most probably\ndue to a timeout, then by default the driver will reconnect and\nattempt to execute the same SQL statement again. However, this\nbehaviour is disabled when AutoCommit is off: Otherwise the\ntransaction state would be completely unpredictable after a\nreconnect.\n\n=item *\n\nThe \"reconnect\" feature of DBD::mysql can be toggled by using the\nL<mysql_auto_reconnect> attribute. This behaviour should be turned off\nin code that uses LOCK TABLE because if the database server time out\nand DBD::mysql reconnect, table locks will be lost without any\nindication of such loss.\n\n=back\n\n=head1 MULTIPLE RESULT SETS\n\nDBD::mysql supports multiple result sets, thanks to Guy Harrison!\n\nThe basic usage of multiple result sets is\n\n  do\n  {\n    while (@row = $sth->fetchrow_array())\n    {\n      do stuff;\n    }\n  } while ($sth->more_results)\n\nAn example would be:\n\n  $dbh->do(\"drop procedure if exists someproc\") or print $DBI::errstr;\n\n  $dbh->do(\"create procedure someproc() deterministic\n   begin\n   declare a,b,c,d int;\n   set a=1;\n   set b=2;\n   set c=3;\n   set d=4;\n   select a, b, c, d;\n   select d, c, b, a;\n   select b, a, c, d;\n   select c, b, d, a;\n  end\") or print $DBI::errstr;\n\n  $sth=$dbh->prepare('call someproc()') ||\n  die $DBI::err.\": \".$DBI::errstr;\n\n  $sth->execute || die DBI::err.\": \".$DBI::errstr; $rowset=0;\n  do {\n    print \"\\nRowset \".++$i.\"\\n---------------------------------------\\n\\n\";\n    foreach $colno (0..$sth->{NUM_OF_FIELDS}-1) {\n      print $sth->{NAME}->[$colno].\"\\t\";\n    }\n    print \"\\n\";\n    while (@row= $sth->fetchrow_array())  {\n      foreach $field (0..$#row) {\n        print $row[$field].\"\\t\";\n      }\n      print \"\\n\";\n    }\n  } until (!$sth->more_results)\n\n=head2 Issues with multiple result sets\n\nPlease be aware there could be issues if your result sets are \"jagged\",\nmeaning the number of columns of your results vary. Varying numbers of\ncolumns could result in your script crashing.\n\n\n=head1 MULTITHREADING\n\nThe multithreading capabilities of DBD::mysql depend completely\non the underlying C libraries. The modules are working with handle data\nonly, no global variables are accessed or (to the best of my knowledge)\nthread unsafe functions are called. Thus DBD::mysql is believed\nto be completely thread safe, if the C libraries are thread safe\nand you don't share handles among threads.\n\nThe obvious question is: Are the C libraries thread safe?\nIn the case of MySQL the answer is \"mostly\" and, in theory, you should\nbe able to get a \"yes\", if the C library is compiled for being thread\nsafe (By default it isn't.) by passing the option -with-thread-safe-client\nto configure. See the section on I<How to make a threadsafe client> in\nthe manual.\n\n\n=head1 ASYNCHRONOUS QUERIES\n\nYou can make a single asynchronous query per MySQL connection; this allows\nyou to submit a long-running query to the server and have an event loop\ninform you when it's ready.  An asynchronous query is started by either\nsetting the 'async' attribute to a true value in the L<DBI/do> method,\nor in the L<DBI/prepare> method.  Statements created with 'async' set to\ntrue in prepare always run their queries asynchronously when L<DBI/execute>\nis called.  The driver also offers three additional methods:\nC<mysql_async_result>, C<mysql_async_ready>, and C<mysql_fd>.\nC<mysql_async_result> returns what do or execute would have; that is, the\nnumber of rows affected.  C<mysql_async_ready> returns true if\nC<mysql_async_result> will not block, and zero otherwise.  They both return\nC<undef> if that handle is not currently running an asynchronous query.\nC<mysql_fd> returns the file descriptor number for the MySQL connection; you\ncan use this in an event loop.\n\nHere's an example of how to use the asynchronous query interface:\n\n  use feature 'say';\n  $dbh->do('SELECT SLEEP(10)', { async => 1 });\n  until($dbh->mysql_async_ready) {\n    say 'not ready yet!';\n    sleep 1;\n  }\n  my $rows = $dbh->mysql_async_result;\n\n=head1 INSTALLATION\n\nSee L<DBD::mysql::INSTALL>.\n\n=head1 AUTHORS\n\nOriginally, there was a non-DBI driver, Mysql, which was much like\nPHP drivers such as mysql and mysqli. The B<Mysql> module was\noriginally written by Andreas K\u00f6nig <koenig@kulturbox.de> who still, to this\nday, contributes patches to DBD::mysql. An emulated version of Mysql was\nprovided to DBD::mysql from Jochen Wiedmann, but eventually deprecated as it\nwas another bundle of code to maintain.\n\nThe first incarnation of DBD::mysql was developed by Alligator Descartes,\nwho was also aided and abetted by Gary Shea, Andreas K\u00f6nig and\nTim Bunce.\n\nThe current incarnation of B<DBD::mysql> was written by Jochen Wiedmann,\nthen numerous changes and bug-fixes were added by Rudy Lippan. Next,\nprepared statement support was added by Patrick Galbraith and\nAlexy Stroganov (who also solely added embedded server\nsupport).\n\nFor the past nine years DBD::mysql has been maintained by\nPatrick Galbraith (I<patg@patg.net>), and recently with the great help of\nMichiel Beijen (I<michiel.beijen@gmail.com>),  along with the entire community\nof Perl developers who keep sending patches to help continue improving DBD::mysql\n\n\n=head1 CONTRIBUTIONS\n\nAnyone who desires to contribute to this project is encouraged to do so.\nCurrently, the source code for this project can be found at Github:\n\nL<https://github.com/perl5-dbi/DBD-mysql/>\n\nEither fork this repository and produce a branch with your changeset that\nthe maintainer can merge to his tree, or create a diff with git. The maintainer\nis more than glad to take contributions from the community as\nmany features and fixes from DBD::mysql have come from the community.\n\n\n=head1 COPYRIGHT\n\nThis module is\n\n=over\n\n=item *\n\nLarge Portions Copyright (c) 2004-2013 Patrick Galbraith\n\n=item *\n\nLarge Portions Copyright (c) 2004-2006 Alexey Stroganov\n\n=item *\n\nLarge Portions Copyright (c) 2003-2005 Rudolf Lippan\n\n=item *\n\nLarge Portions Copyright (c) 1997-2003 Jochen Wiedmann, with code portions\n\n=item *\n\nCopyright (c)1994-1997 their original authors\n\n=back\n\n\n=head1 LICENSE\n\nThis module is released under the same license as Perl itself. See\nL<http://www.perl.com/perl/misc/Artistic.html> for details.\n\n\n=head1 MAILING LIST SUPPORT\n\nThis module is maintained and supported on a mailing list, dbi-users.\n\nTo subscribe to this list, send an email to\n\ndbi-users-subscribe@perl.org\n\nMailing list archives are at\n\nL<http://groups.google.com/group/perl.dbi.users?hl=en&lr=>\n\n\n=head1 ADDITIONAL DBI INFORMATION\n\nAdditional information on the DBI project can be found on the World\nWide Web at the following URL:\n\nL<http://dbi.perl.org>\n\nwhere documentation, pointers to the mailing lists and mailing list\narchives and pointers to the most current versions of the modules can\nbe used.\n\nInformation on the DBI interface itself can be gained by typing:\n\n    perldoc DBI\n\nInformation on DBD::mysql specifically can be gained by typing:\n\n    perldoc DBD::mysql\n\n(this will display the document you're currently reading)\n\n\n=head1 BUG REPORTING, ENHANCEMENT/FEATURE REQUESTS\n\nPlease report bugs, including all the information needed\nsuch as DBD::mysql version, MySQL version, OS type/version, etc\nto this link:\n\nL<https://rt.cpan.org/Dist/Display.html?Name=DBD-mysql>\n\nNote: until recently, MySQL/Sun/Oracle responded to bugs and assisted in\nfixing bugs which many thanks should be given for their help!\nThis driver is outside the realm of the numerous components they support, and the\nmaintainer and community solely support DBD::mysql\n\n=cut\n", "/* Hej, Emacs, this is -*- C -*- mode!\n\n   Copyright (c) 2003      Rudolf Lippan\n   Copyright (c) 1997-2003 Jochen Wiedmann\n\n   You may distribute under the terms of either the GNU General Public\n   License or the Artistic License, as specified in the Perl README file.\n\n*/\n\n\n#include \"dbdimp.h\"\n#include \"constants.h\"\n\n#include <errno.h>\n#include <string.h>\n\n#if MYSQL_ASYNC\n#  define ASYNC_CHECK_XS(h)\\\n    if(imp_dbh->async_query_in_flight) {\\\n        do_error(h, 2000, \"Calling a synchronous function on an asynchronous handle\", \"HY000\");\\\n        XSRETURN_UNDEF;\\\n    }\n#else\n#  define ASYNC_CHECK_XS(h)\n#endif\n\n\nDBISTATE_DECLARE;\n\n\nMODULE = DBD::mysql\tPACKAGE = DBD::mysql\n\nINCLUDE: mysql.xsi\n\nMODULE = DBD::mysql\tPACKAGE = DBD::mysql\n\ndouble\nconstant(name, arg)\n    char* name\n    char* arg\n  CODE:\n    RETVAL = mysql_constant(name, arg);\n  OUTPUT:\n    RETVAL\n\n\nMODULE = DBD::mysql\tPACKAGE = DBD::mysql::dr\n\nvoid\n_ListDBs(drh, host=NULL, port=NULL, user=NULL, password=NULL)\n    SV *        drh\n    char *\thost\n    char *      port\n    char *      user\n    char *      password\n  PPCODE:\n{\n    MYSQL mysql;\n    MYSQL* sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user, password,\n\t\t\t\t   NULL, NULL);\n    if (sock != NULL)\n    {\n      MYSQL_ROW cur;\n      MYSQL_RES* res = mysql_list_dbs(sock, NULL);\n      if (!res)\n      {\n        do_error(drh, mysql_errno(sock), mysql_error(sock), mysql_sqlstate(sock));\n      }\n      else\n      {\n\tEXTEND(sp, mysql_num_rows(res));\n\twhile ((cur = mysql_fetch_row(res)))\n        {\n\t  PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));\n\t}\n\tmysql_free_result(res);\n      }\n      mysql_close(sock);\n    }\n}\n\n\nvoid\n_admin_internal(drh,dbh,command,dbname=NULL,host=NULL,port=NULL,user=NULL,password=NULL)\n  SV* drh\n  SV* dbh\n  char* command\n  char* dbname\n  char* host\n  char* port\n  char* user\n  char* password\n  PPCODE:\n{\n  MYSQL mysql;\n  int retval;\n  MYSQL* sock;\n#if MYSQL_VERSION_ID >= 50709\n  const char *shutdown = \"SHUTDOWN\";\n#endif\n\n  /*\n   *  Connect to the database, if required.\n */\n  if (SvOK(dbh)) {\n    D_imp_dbh(dbh);\n    sock = imp_dbh->pmysql;\n  }\n  else\n  {\n    sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user,  password, NULL, NULL);\n    if (sock == NULL)\n    {\n      do_error(drh, mysql_errno(&mysql), mysql_error(&mysql),\n               mysql_sqlstate(&mysql));\n      XSRETURN_NO;\n    }\n  }\n\n  if (strEQ(command, \"shutdown\"))\n#if MYSQL_VERSION_ID < 40103\n    retval = mysql_shutdown(sock);\n#else\n#if MYSQL_VERSION_ID < 50709\n    retval = mysql_shutdown(sock, SHUTDOWN_DEFAULT);\n#else\n    retval = mysql_real_query(sock, shutdown, strlen(shutdown));\n#endif\n#endif\n  else if (strEQ(command, \"reload\"))\n    retval = mysql_reload(sock);\n  else if (strEQ(command, \"createdb\"))\n  {\n#if MYSQL_VERSION_ID < 40000\n    retval = mysql_create_db(sock, dbname);\n#else\n    char* buffer = malloc(strlen(dbname)+50);\n    if (buffer == NULL)\n    {\n      do_error(drh, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      XSRETURN_NO;\n    }\n    else\n    {\n      strcpy(buffer, \"CREATE DATABASE \");\n      strcat(buffer, dbname);\n      retval = mysql_real_query(sock, buffer, strlen(buffer));\n      free(buffer);\n    }\n#endif\n  }\n  else if (strEQ(command, \"dropdb\"))\n  {\n#if MYSQL_VERSION_ID < 40000\n    retval = mysql_drop_db(sock, dbname);\n#else\n    char* buffer = malloc(strlen(dbname)+50);\n    if (buffer == NULL)\n    {\n      do_error(drh, JW_ERR_MEM, \"Out of memory\" ,NULL);\n      XSRETURN_NO;\n    }\n    else\n    {\n      strcpy(buffer, \"DROP DATABASE \");\n      strcat(buffer, dbname);\n      retval = mysql_real_query(sock, buffer, strlen(buffer));\n      free(buffer);\n    }\n#endif\n  }\n  else\n  {\n    croak(\"Unknown command: %s\", command);\n  }\n  if (retval)\n  {\n    do_error(SvOK(dbh) ? dbh : drh, mysql_errno(sock),\n             mysql_error(sock) ,mysql_sqlstate(sock));\n  }\n\n  if (SvOK(dbh))\n  {\n    mysql_close(sock);\n  }\n  if (retval)\n    XSRETURN_NO;\n  else \n    XSRETURN_YES;\n}\n\n\nMODULE = DBD::mysql    PACKAGE = DBD::mysql::db\n\n\nvoid\ntype_info_all(dbh)\n  SV* dbh\n  PPCODE:\n{\n  /* \tstatic AV* types = NULL; */\n  /* \tif (!types) { */\n  /* \t    D_imp_dbh(dbh); */\n  /* \t    if (!(types = dbd_db_type_info_all(dbh, imp_dbh))) { */\n  /* \t        croak(\"Cannot create types array (out of memory?)\"); */\n  /* \t    } */\n  /* \t} */\n  /* \tST(0) = sv_2mortal(newRV_inc((SV*) types)); */\n  D_imp_dbh(dbh);\n  ASYNC_CHECK_XS(dbh);\n  ST(0) = sv_2mortal(newRV_noinc((SV*) dbd_db_type_info_all(dbh,\n                                                            imp_dbh)));\n  XSRETURN(1);\n}\n\n\nvoid\n_ListDBs(dbh)\n  SV*\tdbh\n  PPCODE:\n  MYSQL_RES* res;\n  MYSQL_ROW cur;\n\n  D_imp_dbh(dbh);\n\n  ASYNC_CHECK_XS(dbh);\n\n  res = mysql_list_dbs(imp_dbh->pmysql, NULL);\n  if (!res  &&\n      (!mysql_db_reconnect(dbh)  ||\n       !(res = mysql_list_dbs(imp_dbh->pmysql, NULL))))\n{\n  do_error(dbh, mysql_errno(imp_dbh->pmysql),\n           mysql_error(imp_dbh->pmysql), mysql_sqlstate(imp_dbh->pmysql));\n}\nelse\n{\n  EXTEND(sp, mysql_num_rows(res));\n  while ((cur = mysql_fetch_row(res)))\n  {\n    PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));\n  }\n  mysql_free_result(res);\n}\n\n\nvoid\ndo(dbh, statement, attr=Nullsv, ...)\n  SV *        dbh\n  SV *\tstatement\n  SV *        attr\n  PROTOTYPE: $$;$@\n  CODE:\n{\n  D_imp_dbh(dbh);\n  int num_params= 0;\n  int retval;\n  struct imp_sth_ph_st* params= NULL;\n  MYSQL_RES* result= NULL;\n  SV* async = NULL;\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  int next_result_rc;\n#endif\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  STRLEN slen;\n  char            *str_ptr, *buffer;\n  int             has_binded;\n  int             buffer_length= slen;\n  int             buffer_type= 0;\n  int             use_server_side_prepare= 0;\n  MYSQL_STMT      *stmt= NULL;\n  MYSQL_BIND      *bind= NULL;\n#endif\n    ASYNC_CHECK_XS(dbh);\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n    while (mysql_next_result(imp_dbh->pmysql)==0)\n    {\n      MYSQL_RES* res = mysql_use_result(imp_dbh->pmysql);\n      if (res)\n        mysql_free_result(res);\n      }\n#endif\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n\n  /*\n   * Globaly enabled using of server side prepared statement\n   * for dbh->do() statements. It is possible to force driver\n   * to use server side prepared statement mechanism by adding\n   * 'mysql_server_prepare' attribute to do() method localy:\n   * $dbh->do($stmt, {mysql_server_prepared=>1});\n  */\n\n  use_server_side_prepare = imp_dbh->use_server_side_prepare;\n  if (attr)\n  {\n    SV** svp;\n    DBD_ATTRIBS_CHECK(\"do\", dbh, attr);\n    svp = DBD_ATTRIB_GET_SVP(attr, \"mysql_server_prepare\", 20);\n\n    use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp   = DBD_ATTRIB_GET_SVP(attr, \"async\", 5);\n    async = (svp) ? *svp : &PL_sv_no;\n  }\n  if (DBIc_DBISTATE(imp_dbh)->debug >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_dbh),\n                  \"mysql.xs do() use_server_side_prepare %d, async %d\\n\",\n                  use_server_side_prepare, SvTRUE(async));\n\n  (void)hv_store((HV*)SvRV(dbh), \"Statement\", 9, SvREFCNT_inc(statement), 0);\n\n  if(SvTRUE(async)) {\n#if MYSQL_ASYNC\n    use_server_side_prepare = FALSE; /* for now */\n    imp_dbh->async_query_in_flight = imp_dbh;\n#else\n    do_error(dbh, 2000,\n             \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n    XSRETURN_UNDEF;\n#endif\n  }\n\n  if (use_server_side_prepare)\n  {\n    str_ptr= SvPV(statement, slen);\n\n    stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if ((mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))  &&\n        (!mysql_db_reconnect(dbh) ||\n         (mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))))\n    {\n      /*\n        For commands that are not supported by server side prepared\n        statement mechanism lets try to pass them through regular API\n      */\n      if (mysql_stmt_errno(stmt) == ER_UNSUPPORTED_PS)\n      {\n        use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(dbh, mysql_stmt_errno(stmt), mysql_stmt_error(stmt)\n                 ,mysql_stmt_sqlstate(stmt));\n        retval=-2;\n      }\n      mysql_stmt_close(stmt);\n      stmt= NULL;\n    }\n    else\n    {\n      /*\n        'items' is the number of arguments passed to XSUB, supplied\n        by xsubpp compiler, as listed in manpage for perlxs\n      */\n      if (items > 3)\n      {\n        /*\n          Handle binding supplied values to placeholders assume user has\n          passed the correct number of parameters\n        */\n        int i;\n        num_params= items - 3;\n        Newz(0, bind, (unsigned int) num_params, MYSQL_BIND);\n\n        for (i = 0; i < num_params; i++)\n        {\n          int defined= 0;\n          SV *param= ST(i+3);\n\n          if (param)\n          {\n            if (SvMAGICAL(param))\n              mg_get(param);\n            if (SvOK(param))\n              defined= 1;\n          }\n          if (defined)\n          {\n            buffer= SvPV(param, slen);\n            buffer_length= slen;\n            buffer_type= MYSQL_TYPE_STRING;\n          }\n          else\n          {\n            buffer= NULL;\n            buffer_length= 0;\n            buffer_type= MYSQL_TYPE_NULL;\n          }\n\n          bind[i].buffer_type = buffer_type;\n          bind[i].buffer_length= buffer_length;\n          bind[i].buffer= buffer;\n        }\n        has_binded= 0;\n      }\n      retval = mysql_st_internal_execute41(dbh,\n                                           num_params,\n                                           &result,\n                                           stmt,\n                                           bind,\n                                           &has_binded);\n      if (bind)\n        Safefree(bind);\n\n      if(mysql_stmt_close(stmt))\n      {\n        fprintf(stderr, \"\\n failed while closing the statement\");\n        fprintf(stderr, \"\\n %s\", mysql_stmt_error(stmt));\n      }\n    }\n  }\n\n  if (! use_server_side_prepare)\n  {\n#endif\n    if (items > 3)\n    {\n      /*  Handle binding supplied values to placeholders\t   */\n      /*  Assume user has passed the correct number of parameters  */\n      int i;\n      num_params= items-3;\n      Newz(0, params, sizeof(*params)*num_params, struct imp_sth_ph_st);\n      for (i= 0;  i < num_params;  i++)\n      {\n        params[i].value= ST(i+3);\n        params[i].type= SQL_VARCHAR;\n      }\n    }\n    retval = mysql_st_internal_execute(dbh, statement, attr, num_params,\n                                       params, &result, imp_dbh->pmysql, 0);\n#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  }\n#endif\n  if (params)\n    Safefree(params);\n\n  if (result)\n  {\n    mysql_free_result(result);\n    result= 0;\n  }\n#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n  if (retval != -2 && !SvTRUE(async)) /* -2 means error */\n    {\n      /* more results? -1 = no, >0 = error, 0 = yes (keep looping) */\n      while ((next_result_rc= mysql_next_result(imp_dbh->pmysql)) == 0)\n      {\n        result = mysql_use_result(imp_dbh->pmysql);\n          if (result)\n            mysql_free_result(result);\n          }\n          if (next_result_rc > 0)\n          {\n            if (DBIc_DBISTATE(imp_dbh)->debug >= 2)\n              PerlIO_printf(DBIc_LOGPIO(imp_dbh),\n                            \"\\t<- do() ERROR: %s\\n\",\n                            mysql_error(imp_dbh->pmysql));\n\n              do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                       mysql_error(imp_dbh->pmysql),\n                       mysql_sqlstate(imp_dbh->pmysql));\n              retval= -2;\n          }\n    }\n#endif\n  /* remember that dbd_st_execute must return <= -2 for error\t*/\n  if (retval == 0)\t\t/* ok with no rows affected\t*/\n    XST_mPV(0, \"0E0\");\t/* (true but zero)\t\t*/\n  else if (retval < -1)\t/* -1 == unknown number of rows\t*/\n    XST_mUNDEF(0);\t\t/* <= -2 means error   \t\t*/\n  else\n    XST_mIV(0, retval);\t/* typically 1, rowcount or -1\t*/\n}\n\n\nSV*\nping(dbh)\n    SV* dbh;\n  PROTOTYPE: $\n  CODE:\n    {\n      int retval;\n\n      D_imp_dbh(dbh);\n      ASYNC_CHECK_XS(dbh);\n      retval = (mysql_ping(imp_dbh->pmysql) == 0);\n      if (!retval) {\n\tif (mysql_db_reconnect(dbh)) {\n\t  retval = (mysql_ping(imp_dbh->pmysql) == 0);\n\t}\n      }\n      RETVAL = boolSV(retval);\n    }\n  OUTPUT:\n    RETVAL\n\n\n\nvoid\nquote(dbh, str, type=NULL)\n    SV* dbh\n    SV* str\n    SV* type\n  PROTOTYPE: $$;$\n  PPCODE:\n    {\n        SV* quoted;\n\n        D_imp_dbh(dbh);\n        ASYNC_CHECK_XS(dbh);\n\n        quoted = dbd_db_quote(dbh, str, type);\n\tST(0) = quoted ? sv_2mortal(quoted) : str;\n\tXSRETURN(1);\n    }\n\nint mysql_fd(dbh)\n    SV* dbh\n  CODE:\n    {\n        D_imp_dbh(dbh);\n        RETVAL = imp_dbh->pmysql->net.fd;\n    }\n  OUTPUT:\n    RETVAL\n\nvoid mysql_async_result(dbh)\n    SV* dbh\n  PPCODE:\n    {\n#if MYSQL_ASYNC\n        int retval;\n\n        retval = mysql_db_async_result(dbh, NULL);\n\n        if(retval > 0) {\n            XSRETURN_IV(retval);\n        } else if(retval == 0) {\n            XSRETURN_PV(\"0E0\");\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(dbh, 2000, \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n\nvoid mysql_async_ready(dbh)\n    SV* dbh\n  PPCODE:\n    {\n#if MYSQL_ASYNC\n        int retval;\n\n        retval = mysql_db_async_ready(dbh);\n        if(retval > 0) {\n            XSRETURN_YES;\n        } else if(retval == 0) {\n            XSRETURN_NO;\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(dbh, 2000, \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n\nvoid _async_check(dbh)\n    SV* dbh\n  PPCODE:\n    {\n        D_imp_dbh(dbh);\n        ASYNC_CHECK_XS(dbh);\n        XSRETURN_YES;\n    }\n\nMODULE = DBD::mysql    PACKAGE = DBD::mysql::st\n\nint\nmore_results(sth)\n    SV *\tsth\n    CODE:\n{\n#if (MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION)\n  D_imp_sth(sth);\n  if (dbd_st_more_results(sth, imp_sth))\n  {\n    RETVAL=1;\n  }\n  else\n  {\n    RETVAL=0;\n  }\n#endif\n}\n    OUTPUT:\n      RETVAL\n\nint\ndataseek(sth, pos)\n    SV* sth\n    int pos\n  PROTOTYPE: $$\n  CODE:\n{\n  D_imp_sth(sth);\n#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION)\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (imp_sth->use_mysql_use_result || 1)\n    {\n      if (imp_sth->result && imp_sth->stmt)\n      {\n        mysql_stmt_data_seek(imp_sth->stmt, pos);\n        imp_sth->fetch_done=0;\n        RETVAL = 1;\n      }\n      else\n      {\n        RETVAL = 0;\n        do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\n      }\n    }\n    else\n    {\n      RETVAL = 0;\n      do_error(sth, JW_ERR_NOT_ACTIVE, \"No result set\" ,NULL);\n    }\n  }\n  else\n  {\n#endif\n  if (imp_sth->result) {\n    mysql_data_seek(imp_sth->result, pos);\n    RETVAL = 1;\n  } else {\n    RETVAL = 0;\n    do_error(sth, JW_ERR_NOT_ACTIVE, \"Statement not active\" ,NULL);\n  }\n#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION) \n  }\n#endif\n}\n  OUTPUT:\n    RETVAL\n\nvoid\nrows(sth)\n    SV* sth\n  CODE:\n    D_imp_sth(sth);\n    char buf[64];\n#if MYSQL_ASYNC\n    D_imp_dbh_from_sth;\n    if(imp_dbh->async_query_in_flight) {\n        if(mysql_db_async_result(sth, &imp_sth->result) < 0) {\n            XSRETURN_UNDEF;\n        }\n    }\n#endif\n\n  /* fix to make rows able to handle errors and handle max value from \n     affected rows.\n     if mysql_affected_row returns an error, it's value is 18446744073709551614,\n     while a (my_ulonglong)-1 is  18446744073709551615, so we have to add 1 to\n     imp_sth->row_num to know if there's an error\n  */\n  if (imp_sth->row_num+1 ==  (my_ulonglong) -1)\n    sprintf(buf, \"%d\", -1);\n  else\n    sprintf(buf, \"%llu\", imp_sth->row_num);\n\n  ST(0) = sv_2mortal(newSVpvn(buf, strlen(buf)));\n\nint mysql_async_result(sth)\n    SV* sth\n  CODE:\n    {\n#if MYSQL_ASYNC\n        D_imp_sth(sth);\n        int retval;\n\n        retval= mysql_db_async_result(sth, &imp_sth->result);\n\n        if(retval > 0) {\n            imp_sth->row_num = retval;\n            XSRETURN_IV(retval);\n        } else if(retval == 0) {\n            imp_sth->row_num = retval;\n            XSRETURN_PV(\"0E0\");\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n  OUTPUT:\n    RETVAL\n\nvoid mysql_async_ready(sth)\n    SV* sth\n  PPCODE:\n    {\n#if MYSQL_ASYNC\n        int retval;\n\n        retval = mysql_db_async_ready(sth);\n        if(retval > 0) {\n            XSRETURN_YES;\n        } else if(retval == 0) {\n            XSRETURN_NO;\n        } else {\n            XSRETURN_UNDEF;\n        }\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        XSRETURN_UNDEF;\n#endif\n    }\n\nvoid _async_check(sth)\n    SV* sth\n  PPCODE:\n    {\n        D_imp_sth(sth);\n        D_imp_dbh_from_sth;\n        ASYNC_CHECK_XS(sth);\n        XSRETURN_YES;\n    }\n\n\nMODULE = DBD::mysql    PACKAGE = DBD::mysql::GetInfo\n\n# This probably should be grabed out of some ODBC types header file\n#define SQL_CATALOG_NAME_SEPARATOR 41\n#define SQL_CATALOG_TERM 42\n#define SQL_DBMS_VER 18\n#define SQL_IDENTIFIER_QUOTE_CHAR 29\n#define SQL_MAXIMUM_STATEMENT_LENGTH 105\n#define SQL_MAXIMUM_TABLES_IN_SELECT 106\n#define SQL_MAX_TABLE_NAME_LEN 35\n#define SQL_SERVER_NAME 13\n#define SQL_ASYNC_MODE 10021\n#define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS 10022\n\n#define SQL_AM_NONE       0\n#define SQL_AM_CONNECTION 1\n#define SQL_AM_STATEMENT  2\n\n\n#  dbd_mysql_getinfo()\n#  Return ODBC get_info() information that must needs be accessed from C\n#  This is an undocumented function that should only\n#  be used by DBD::mysql::GetInfo.\n\nvoid\ndbd_mysql_get_info(dbh, sql_info_type)\n    SV* dbh\n    SV* sql_info_type\n  CODE:\n    D_imp_dbh(dbh);\n    IV type = 0;\n    SV* retsv=NULL;\n#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50709\n/* MariaDB 10 is not MySQL source level compatible so this only applies to MySQL*/\n    IV buffer_len;\n#endif \n\n    if (SvMAGICAL(sql_info_type))\n        mg_get(sql_info_type);\n\n    if (SvOK(sql_info_type))\n    \ttype = SvIV(sql_info_type);\n    else\n    \tcroak(\"get_info called with an invalied parameter\");\n    \n    switch(type) {\n    \tcase SQL_CATALOG_NAME_SEPARATOR:\n\t    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */\n\t    retsv = newSVpvn(\".\",1);\n\t    break;\n\tcase SQL_CATALOG_TERM:\n\t    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */\n\t    retsv = newSVpvn(\"database\",8);\n\t    break;\n\tcase SQL_DBMS_VER:\n\t    retsv = newSVpvn(\n\t        imp_dbh->pmysql->server_version,\n\t\tstrlen(imp_dbh->pmysql->server_version)\n\t    );\n\t    break;\n\tcase SQL_IDENTIFIER_QUOTE_CHAR:\n\t    retsv = newSVpvn(\"`\", 1);\n\t    break;\n\tcase SQL_MAXIMUM_STATEMENT_LENGTH:\n#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50709\n        /* MariaDB 10 is not MySQL source level compatible so this\n           only applies to MySQL*/\n\t    /* mysql_get_option() was added in mysql 5.7.3 */\n\t    /* MYSQL_OPT_NET_BUFFER_LENGTH was added in mysql 5.7.9 */\n\t    mysql_get_option(NULL, MYSQL_OPT_NET_BUFFER_LENGTH, &buffer_len);\n\t    retsv = newSViv(buffer_len);\n#else\n\t    /* before mysql 5.7.9 use net_buffer_length macro */\n\t    retsv = newSViv(net_buffer_length);\n#endif\n\t    break;\n\tcase SQL_MAXIMUM_TABLES_IN_SELECT:\n\t    /* newSViv((sizeof(int) > 32) ? sizeof(int)-1 : 31 ); in general? */\n\t    retsv= newSViv((sizeof(int) == 64 ) ? 63 : 31 );\n\t    break;\n\tcase SQL_MAX_TABLE_NAME_LEN:\n\t    retsv= newSViv(NAME_LEN);\n\t    break;\n\tcase SQL_SERVER_NAME:\n\t    retsv= newSVpvn(imp_dbh->pmysql->host_info,strlen(imp_dbh->pmysql->host_info));\n\t    break;\n        case SQL_ASYNC_MODE:\n#if MYSQL_ASYNC\n            retsv = newSViv(SQL_AM_STATEMENT);\n#else\n            retsv = newSViv(SQL_AM_NONE);\n#endif\n            break;\n        case SQL_MAX_ASYNC_CONCURRENT_STATEMENTS:\n#if MYSQL_ASYNC\n            retsv = newSViv(1);\n#else\n            retsv = newSViv(0);\n#endif\n            break;\n    \tdefault:\n \t\tcroak(\"Unknown SQL Info type: %i\", mysql_errno(imp_dbh->pmysql));\n    }\n    ST(0) = sv_2mortal(retsv);\n\n", "use strict;\nuse warnings;\n\nuse Test::More;\nuse DBI;\n\nuse vars qw($test_dsn $test_user $test_password);\nrequire \"t/lib.pl\";\n\nmy $dbh = eval { DBI->connect($test_dsn, $test_user, $test_password, { PrintError => 1, RaiseError => 1, AutoCommit => 0, mysql_server_prepare => 1 }) };\nplan skip_all => \"no database connection\" if $@ or not $dbh;\n\nplan tests => 17;\n\nok $dbh->do(\"CREATE TEMPORARY TABLE t (i INTEGER NOT NULL, n TEXT)\");\n\nok my $sth = $dbh->prepare(\"SELECT * FROM t WHERE i=? AND n=?\");\n\nok $sth->bind_param(2, \"x\" x 1000000);\nok $sth->bind_param(1, \"abcx\", 12);\nok $sth->execute();\n\nok $sth->bind_param(2, \"a\" x 1000000);\nok $sth->bind_param(1, 1, 3);\nok $sth->execute();\n\nok $sth->finish();\n\nok $sth = $dbh->prepare(\"SELECT * FROM t WHERE i=? AND n=?\");\nok $sth->execute();\nok $sth->finish();\n\nok $sth = $dbh->prepare(\"SELECT 1 FROM t WHERE i = ?\" . (\" OR i = ?\" x 10000));\nok $sth->execute((1) x (10001));\nok $sth->finish();\n\nok $dbh->do(\"SELECT 1 FROM t WHERE i = ?\" . (\" OR i = ?\" x 10000), {}, (1) x (10001));\n\nok $dbh->disconnect();\n"], "filenames": ["Changes", "dbdimp.c", "lib/Bundle/DBD/mysql.pm", "lib/DBD/mysql.pm", "mysql.xs", "t/40server_prepare_crash.t"], "buggy_code_start_loc": [0, 2753, 6, 18, 269, 13], "buggy_code_end_loc": [0, 2977, 7, 19, 519, 32], "fixing_code_start_loc": [1, 2753, 6, 18, 268, 13], "fixing_code_end_loc": [4, 2963, 7, 19, 406, 39], "type": "CWE-125", "message": "The DBD::mysql module before 4.039 for Perl, when using server-side prepared statement support, allows attackers to cause a denial of service (out-of-bounds read) via vectors involving an unaligned number of placeholders in WHERE condition and output fields in SELECT expression.", "other": {"cve": {"id": "CVE-2016-1249", "sourceIdentifier": "security@debian.org", "published": "2017-02-17T02:59:10.780", "lastModified": "2021-08-09T13:52:09.370", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The DBD::mysql module before 4.039 for Perl, when using server-side prepared statement support, allows attackers to cause a denial of service (out-of-bounds read) via vectors involving an unaligned number of placeholders in WHERE condition and output fields in SELECT expression."}, {"lang": "es", "value": "El m\u00f3dulo DBD::mysql en versiones anteriores a 4.039 para Perl, cuando se utiliza el soporte de sentencia preparada en el servidor, permite a atacantes provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) a trav\u00e9s de vectores que implican un n\u00famero no alineado de marcadores de posici\u00f3n en la condici\u00f3n WHERE y campos de salida en expresi\u00f3n SELECT."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dbd-mysql_project:dbd-mysql:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.038_01", "matchCriteriaId": "C776DED8-B178-4AAA-9A14-23FBA456A3BB"}]}]}], "references": [{"url": "http://cpansearch.perl.org/src/CAPTTOFU/DBD-mysql-4.039/Changes", "source": "security@debian.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/16/1", "source": "security@debian.org", "tags": ["Mailing List", "Mitigation", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94350", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-51", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe"}}