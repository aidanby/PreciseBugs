{"buggy_code": ["/*\n * Copyright 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.internal.resource.local;\n\nimport org.apache.commons.io.FileUtils;\nimport org.gradle.api.Action;\nimport org.gradle.api.NonNullApi;\nimport org.gradle.api.file.EmptyFileVisitor;\nimport org.gradle.api.file.FileVisitDetails;\nimport org.gradle.api.internal.file.collections.MinimalFileTree;\nimport org.gradle.api.internal.file.collections.SingleIncludePatternFileTree;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.hash.ChecksumService;\nimport org.gradle.util.internal.GFileUtils;\nimport org.gradle.util.internal.RelativePathUtil;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport static org.gradle.internal.FileUtils.hasExtension;\n\n/**\n * File store that accepts the target path as the key for the entry.\n *\n * This implementation is explicitly NOT THREAD SAFE. Concurrent access must be organised externally.\n * <p>\n * There is always at most one entry for a given key for this file store. If an entry already exists at the given path, it will be overwritten.\n * Paths can contain directory components, which will be created on demand.\n * <p>\n * This file store is self repairing in so far that any files partially written before a fatal error will be ignored and\n * removed at a later time.\n * <p>\n * This file store also provides searching via relative ant path patterns.\n */\n@NonNullApi\npublic class DefaultPathKeyFileStore implements PathKeyFileStore {\n\n    private final ChecksumService checksumService;\n\n    /*\n        When writing a file into the filestore a marker file with this suffix is written alongside,\n        then removed after the write. This is used to detect partially written files (due to a serious crash)\n        and to silently clean them.\n     */\n    public static final String IN_PROGRESS_MARKER_FILE_SUFFIX = \".fslck\";\n\n    private File baseDir;\n\n    public DefaultPathKeyFileStore(ChecksumService checksumService, File baseDir) {\n        this.checksumService = checksumService;\n        this.baseDir = baseDir;\n    }\n\n    protected File getBaseDir() {\n        return baseDir;\n    }\n\n    private File getFile(String... path) {\n        File result = baseDir;\n        for (String p : path) {\n            result = new File(result, p);\n        }\n        return result;\n    }\n\n    private File getFileWhileCleaningInProgress(String... path) {\n        File file = getFile(path);\n        File markerFile = getInProgressMarkerFile(file);\n        if (markerFile.exists()) {\n            deleteFileQuietly(file);\n            deleteFileQuietly(markerFile);\n        }\n        return file;\n    }\n\n    @Override\n    public LocallyAvailableResource add(final String path, final Action<File> addAction) {\n        try {\n            return doAdd(path, new Action<File>() {\n                @Override\n                public void execute(File file) {\n                    try {\n                        addAction.execute(file);\n                    } catch (Throwable e) {\n                        throw new FileStoreAddActionException(String.format(\"Failed to add into filestore '%s' at '%s' \", getBaseDir().getAbsolutePath(), path), e);\n                    }\n                }\n            });\n        } catch (FileStoreAddActionException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new FileStoreException(String.format(\"Failed to add into filestore '%s' at '%s' \", getBaseDir().getAbsolutePath(), path), e);\n        }\n    }\n\n    @Override\n    public LocallyAvailableResource move(String path, final File source) {\n        if (!source.exists()) {\n            throw new FileStoreException(String.format(\"Cannot move '%s' into filestore @ '%s' as it does not exist\", source, path));\n        }\n\n        try {\n            return doAdd(path, new Action<File>() {\n                @Override\n                public void execute(File file) {\n                    if (source.isDirectory()) {\n                        GFileUtils.moveExistingDirectory(source, file);\n                    } else {\n                        GFileUtils.moveExistingFile(source, file);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            throw new FileStoreException(String.format(\"Failed to move file '%s' into filestore at '%s' \", source, path), e);\n        }\n    }\n\n    private LocallyAvailableResource doAdd(String path, Action<File> action) {\n        File destination = getFile(path);\n        doAdd(destination, action);\n        return entryAt(path);\n    }\n\n    protected void doAdd(File destination, Action<File> action) {\n        GFileUtils.parentMkdirs(destination);\n        File inProgressMarkerFile = getInProgressMarkerFile(destination);\n        GFileUtils.touch(inProgressMarkerFile);\n        try {\n            FileUtils.deleteQuietly(destination);\n            action.execute(destination);\n        } catch (Throwable t) {\n            FileUtils.deleteQuietly(destination);\n            throw UncheckedException.throwAsUncheckedException(t);\n        } finally {\n            deleteFileQuietly(inProgressMarkerFile);\n        }\n    }\n\n    @Override\n    public Set<? extends LocallyAvailableResource> search(String pattern) {\n        if (!getBaseDir().exists()) {\n            return Collections.emptySet();\n        }\n\n        final Set<LocallyAvailableResource> entries = new HashSet<LocallyAvailableResource>();\n        findFiles(pattern).visit(new EmptyFileVisitor() {\n            @Override\n            public void visitFile(FileVisitDetails fileDetails) {\n                final File file = fileDetails.getFile();\n                // We cannot clean in progress markers, or in progress files here because\n                // the file system visitor stuff can't handle the file system mutating while visiting\n                if (!isInProgressMarkerFile(file) && !isInProgressFile(file)) {\n                    entries.add(entryAt(file));\n                }\n            }\n        });\n\n        return entries;\n    }\n\n    private File getInProgressMarkerFile(File file) {\n        return new File(file.getParent(), file.getName() + IN_PROGRESS_MARKER_FILE_SUFFIX);\n    }\n\n    private boolean isInProgressMarkerFile(File file) {\n        return hasExtension(file, IN_PROGRESS_MARKER_FILE_SUFFIX);\n    }\n\n    private boolean isInProgressFile(File file) {\n        return getInProgressMarkerFile(file).exists();\n    }\n\n    private MinimalFileTree findFiles(String pattern) {\n        return new SingleIncludePatternFileTree(baseDir, pattern);\n    }\n\n    protected LocallyAvailableResource entryAt(File file) {\n        return entryAt(RelativePathUtil.relativePath(baseDir, file));\n    }\n\n    protected LocallyAvailableResource entryAt(final String path) {\n        return new DefaultLocallyAvailableResource(getFile(path), checksumService);\n    }\n\n    @Override\n    public LocallyAvailableResource get(String... path) {\n        final File file = getFileWhileCleaningInProgress(path);\n        if (file.exists()) {\n            return new DefaultLocallyAvailableResource(getFile(path), checksumService);\n        } else {\n            return null;\n        }\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static void deleteFileQuietly(File file) {\n        file.delete();\n    }\n}\n", "/*\n * Copyright 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.internal.resource.local\n\nimport org.gradle.api.Action\nimport org.gradle.test.fixtures.file.TestFile\nimport org.gradle.test.fixtures.file.TestNameTestDirectoryProvider\nimport org.gradle.util.TestUtil\nimport org.gradle.util.UsesNativeServices\nimport org.junit.Rule\nimport spock.lang.Specification\n\n@UsesNativeServices\nclass DefaultPathKeyFileStoreTest extends Specification {\n    @Rule TestNameTestDirectoryProvider dir = new TestNameTestDirectoryProvider(getClass())\n    TestFile fsBase\n    PathKeyFileStore store\n\n    def pathCounter = 0\n\n    def setup() {\n        fsBase = dir.file(\"fs\")\n        store = new DefaultPathKeyFileStore(TestUtil.checksumService, fsBase)\n    }\n\n    def \"can move file to filestore\"() {\n        def a = createFile(\"abc\")\n        def b = createFile(\"def\")\n\n        when:\n        store.move(\"a\", a)\n        store.move(\"b\", b)\n\n        then:\n        def storedA = store.get(\"a\")\n        storedA.file.text == \"abc\"\n        storedA.file == fsBase.file(\"a\")\n        !a.exists()\n\n        def storedB = store.get(\"b\")\n        storedB.file.text == \"def\"\n        storedB.file == fsBase.file(\"b\")\n        !b.exists()\n    }\n\n    def \"can move directory to filestore\"() {\n        def a = dir.createDir(\"a\")\n        a.file(\"child-1\").createFile()\n        a.file(\"dir/child-2\").createFile()\n\n        when:\n        store.move(\"a\", a)\n\n        then:\n        def stored = store.get(\"a\")\n        stored.file.directory\n        stored.file == fsBase.file(\"a\")\n        fsBase.file(\"a\").assertHasDescendants(\"child-1\", \"dir/child-2\")\n        !a.exists()\n    }\n\n    def \"can add file to filestore\"() {\n        when:\n        store.add(\"a\", { File f -> f.text = \"abc\"} as Action<File>)\n        store.add(\"b\", { File f -> f.text = \"def\"} as Action<File>)\n\n        then:\n        def storedA = store.get(\"a\")\n        storedA.file.text == \"abc\"\n        storedA.file == fsBase.file(\"a\")\n\n        def storedB = store.get(\"b\")\n        storedB.file.text == \"def\"\n        storedB.file == fsBase.file(\"b\")\n    }\n\n    def \"can add directory to filestore\"() {\n        when:\n        store.add(\"a\") { File f ->\n            f.mkdirs()\n            new File(f, \"a\").text = \"abc\"\n        }\n        store.add(\"b\") { File f ->\n            f.mkdirs()\n            new File(f, \"b\").text = \"def\"\n        }\n\n        then:\n        def storedA = store.get(\"a\")\n        storedA.file == fsBase.file(\"a\")\n        fsBase.file(\"a\").assertHasDescendants(\"a\")\n\n        def storedB = store.get(\"b\")\n        storedB.file == fsBase.file(\"b\")\n        fsBase.file(\"b\").assertHasDescendants(\"b\")\n    }\n\n    def \"add throws FileStoreAddActionException if exception in action occurred and cleans up\"() {\n        def failure = new RuntimeException(\"TestException\")\n\n        when:\n        store.add(\"a\", { File f ->\n            throw failure\n        } as Action<File>)\n        then:\n        def e = thrown(FileStoreAddActionException)\n        e.cause == failure\n\n        !fsBase.file(\"a\").exists()\n        !fsBase.file(\"a.fslock\").exists()\n    }\n\n    def \"cleans up left-over files when action fails\"() {\n        when:\n        store.add(\"a\", { File f ->\n            new File(f, \"child\").text = \"delete-me\"\n            throw new RuntimeException(\"TestException\")\n        } as Action<File>)\n\n        then:\n        thrown(FileStoreAddActionException)\n        !fsBase.file(\"a\").exists()\n        !fsBase.file(\"a.fslock\").exists()\n    }\n\n    def \"can get from backing filestore\"() {\n        when:\n        createFile(\"abc\", \"fs/a\")\n        then:\n        store.get(\"a\") != null\n        store.get(\"b\") == null\n    }\n\n    def \"get cleans up filestore\"() {\n        when:\n        createFile(\"abc\", \"fs/a\").exists()\n        createFile(\"lock\", \"fs/a.fslck\").exists()\n        then:\n        store.get(\"a\") == null\n        store.get(\"a.fslock\") == null\n    }\n\n    def \"can overwrite stale files \"() {\n        given:\n        createFile(\"abc\", \"fs/a\").exists()\n        createFile(\"lock\", \"fs/a.fslck\").exists()\n        when:\n        store.add(\"a\", { File f -> f.text = \"def\"} as Action<File>)\n        then:\n        store.get(\"a\").file.text == \"def\"\n    }\n\n    def \"get on stale file with marker removes file from filestore\"() {\n        when:\n        createFile(\"abc\", \"fs/a\")\n        createFile(\"def\", \"fs/b\")\n        then:\n        store.get(\"a\").file.text == \"abc\"\n        store.get(\"b\").file.text == \"def\"\n    }\n\n    def \"can overwrite file entry\"() {\n        when:\n        store.move(\"a\", createFile(\"abc\"))\n        store.move(\"a\", createFile(\"def\"))\n\n        then:\n        fsBase.file(\"a\").text == \"def\"\n    }\n\n    def \"creates intermediary directories\"() {\n        when:\n        store.move(\"a/b/c\", createFile(\"abc\"))\n        store.move(\"a/b/d\", createFile(\"abd\"))\n        store.move(\"a/c/a\", createFile(\"aca\"))\n\n        then:\n        fsBase.file(\"a/b\").directory\n        fsBase.file(\"a/b/c\").text == \"abc\"\n        fsBase.file(\"a/c/a\").text == \"aca\"\n    }\n\n    def \"can search via globs\"() {\n        when:\n        store.move(\"a/a/a\", createFile(\"a\"))\n        store.move(\"a/a/b\", createFile(\"b\"))\n        store.move(\"a/b/a\", createFile(\"c\"))\n\n        then:\n        store.search(\"**/a\").size() == 2\n        store.search(\"*/b/*\").size() == 1\n        store.search(\"a/b/a\").size() == 1\n    }\n\n    def \"search ignores stale entries with marker file\"() {\n        when:\n        store.move(\"a/a/a\", createFile(\"a\"))\n        store.move(\"a/b/b\", createFile(\"b\"))\n        store.move(\"a/c/c\", createFile(\"c\"))\n        createFile(\"lock\", \"fs/a/b/b.fslck\")\n        def search = store.search(\"**/*\")\n        then:\n        search.size() == 2\n        search.collect {entry -> entry.file.name}.sort() == [\"a\", \"c\"]\n    }\n\n    def createFile(String content, String path = \"f${pathCounter++}\") {\n        dir.createFile(path) << content\n    }\n}\n", "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.integtests.resolve\n\nimport org.gradle.api.internal.artifacts.ivyservice.CacheLayout\nimport org.gradle.cache.internal.scopes.DefaultCacheScopeMapping\nimport org.gradle.integtests.fixtures.AbstractHttpDependencyResolutionTest\nimport org.gradle.integtests.fixtures.ToBeFixedForConfigurationCache\nimport org.gradle.integtests.fixtures.cache.CachingIntegrationFixture\n\nimport java.nio.file.Files\n\nclass CacheResolveIntegrationTest extends AbstractHttpDependencyResolutionTest implements CachingIntegrationFixture {\n\n    @ToBeFixedForConfigurationCache(because = \"CC does not check for deleted or modified artifacts in local cache\")\n    void \"cache handles manual deletion of cached artifacts\"() {\n        given:\n        def module = ivyHttpRepo.module('group', 'projectA', '1.2').publish()\n\n        def cacheDir = getUserHomeCacheDir().toURI()\n\n        and:\n        buildFile << \"\"\"\nrepositories {\n    ivy { url \"${ivyHttpRepo.uri}\" }\n}\nconfigurations { compile }\ndependencies { compile 'group:projectA:1.2' }\ntask listJars {\n    def files = configurations.compile\n    doLast {\n        assert files.collect { it.name } == ['projectA-1.2.jar']\n    }\n}\ntask deleteCacheFiles(type: Delete) {\n    delete fileTree(dir: '${cacheDir}', includes: ['**/projectA/**'])\n}\n\"\"\"\n\n        and:\n        module.allowAll()\n\n        and:\n        succeeds('listJars')\n        succeeds('deleteCacheFiles')\n\n        when:\n        server.resetExpectations()\n        module.ivy.expectGet()\n        module.jar.expectGet()\n\n        then:\n        succeeds('listJars')\n    }\n\n    void \"cache entries are segregated between different repositories\"() {\n        given:\n        def repo1 = ivyHttpRepo('ivy-repo-a')\n        def module1 = repo1.module('org.gradle', 'testproject', '1.0').publish()\n        def repo2 = ivyHttpRepo('ivy-repo-b')\n        def module2 = repo2.module('org.gradle', 'testproject', '1.0').publishWithChangedContent()\n\n        and:\n        settingsFile << \"include 'a','b'\"\n        buildFile << \"\"\"\nsubprojects {\n    configurations {\n        test\n    }\n    dependencies {\n        test \"org.gradle:testproject:1.0\"\n    }\n    task retrieve(type: Sync) {\n        into 'build'\n        from configurations.test\n    }\n}\nproject('a') {\n    repositories {\n        ivy { url \"${repo1.uri}\" }\n    }\n}\nproject('b') {\n    repositories {\n        ivy { url \"${repo2.uri}\" }\n    }\n    retrieve.dependsOn(':a:retrieve')\n}\n\"\"\"\n\n        when:\n        module1.ivy.expectGet()\n        module1.jar.expectGet()\n\n        module2.ivy.expectHead()\n        module2.ivy.sha1.expectGet()\n        module2.ivy.expectGet()\n        module2.jar.expectHead()\n        module2.jar.sha1.expectGet()\n        module2.jar.expectGet()\n\n        then:\n        succeeds 'retrieve'\n\n        and:\n        file('a/build/testproject-1.0.jar').assertIsCopyOf(module1.jarFile)\n        file('b/build/testproject-1.0.jar').assertIsCopyOf(module2.jarFile)\n    }\n\n    def 'dependency cache can be relocated'() {\n        given:\n        def module = ivyHttpRepo.module('group', 'projectA', '1.2').publish()\n\n        and:\n        buildFile << \"\"\"\nrepositories {\n    ivy { url \"${ivyHttpRepo.uri}\" }\n}\nconfigurations { compile }\ndependencies { compile 'group:projectA:1.2' }\ntask listJars {\n    def files = configurations.compile\n    doLast {\n        assert files.collect { it.name } == ['projectA-1.2.jar']\n    }\n}\n\"\"\"\n\n        and:\n        module.allowAll()\n\n        and:\n        succeeds('listJars')\n\n        when:\n        server.resetExpectations()\n        relocateCachesAndChangeGradleHome()\n\n        then:\n        succeeds('listJars')\n    }\n\n    def relocateCachesAndChangeGradleHome() {\n        def otherHome = executer.gradleUserHomeDir.parentFile.createDir('other-home')\n        def otherCacheDir = otherHome.toPath().resolve(DefaultCacheScopeMapping.GLOBAL_CACHE_DIR_NAME)\n        Files.createDirectory(otherCacheDir)\n        Files.move(getMetadataCacheDir().toPath(), otherCacheDir.resolve(CacheLayout.ROOT.key))\n        executer.withGradleUserHomeDir(otherHome)\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.internal.resource.local;\n\nimport org.apache.commons.io.FileUtils;\nimport org.gradle.api.Action;\nimport org.gradle.api.NonNullApi;\nimport org.gradle.api.file.EmptyFileVisitor;\nimport org.gradle.api.file.FileVisitDetails;\nimport org.gradle.api.internal.file.collections.MinimalFileTree;\nimport org.gradle.api.internal.file.collections.SingleIncludePatternFileTree;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.hash.ChecksumService;\nimport org.gradle.util.internal.GFileUtils;\nimport org.gradle.util.internal.RelativePathUtil;\nimport org.gradle.util.internal.ZipSlip;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport static org.gradle.internal.FileUtils.hasExtension;\n\n/**\n * File store that accepts the target path as the key for the entry.\n *\n * This implementation is explicitly NOT THREAD SAFE. Concurrent access must be organised externally.\n * <p>\n * There is always at most one entry for a given key for this file store. If an entry already exists at the given path, it will be overwritten.\n * Paths can contain directory components, which will be created on demand.\n * <p>\n * This file store is self repairing in so far that any files partially written before a fatal error will be ignored and\n * removed at a later time.\n * <p>\n * This file store also provides searching via relative ant path patterns.\n */\n@NonNullApi\npublic class DefaultPathKeyFileStore implements PathKeyFileStore {\n\n    private final ChecksumService checksumService;\n\n    /*\n        When writing a file into the filestore a marker file with this suffix is written alongside,\n        then removed after the write. This is used to detect partially written files (due to a serious crash)\n        and to silently clean them.\n     */\n    public static final String IN_PROGRESS_MARKER_FILE_SUFFIX = \".fslck\";\n\n    private File baseDir;\n\n    public DefaultPathKeyFileStore(ChecksumService checksumService, File baseDir) {\n        this.checksumService = checksumService;\n        this.baseDir = baseDir;\n    }\n\n    protected File getBaseDir() {\n        return baseDir;\n    }\n\n    private File getFile(String... path) {\n        String composedPath;\n        if (path.length == 1) {\n            composedPath = path[0];\n        } else {\n            // We need to ignore empty Strings as this is what \"new File(parent, path)\" was doing for \"path\" empty.\n            composedPath = Arrays.stream(path)\n                .filter(((Predicate<String>) String::isEmpty).negate())\n                .collect(Collectors.joining(File.separator));\n        }\n        return new File(baseDir, ZipSlip.safeZipEntryName(trimLeadingSlash(composedPath)));\n    }\n\n\n    private File getFileWhileCleaningInProgress(String... path) {\n        File file = getFile(path);\n        File markerFile = getInProgressMarkerFile(file);\n        if (markerFile.exists()) {\n            deleteFileQuietly(file);\n            deleteFileQuietly(markerFile);\n        }\n        return file;\n    }\n\n    @Override\n    public LocallyAvailableResource add(final String path, final Action<File> addAction) {\n        try {\n            return doAdd(path, new Action<File>() {\n                @Override\n                public void execute(File file) {\n                    try {\n                        addAction.execute(file);\n                    } catch (Throwable e) {\n                        throw new FileStoreAddActionException(String.format(\"Failed to add into filestore '%s' at '%s' \", getBaseDir().getAbsolutePath(), path), e);\n                    }\n                }\n            });\n        } catch (FileStoreAddActionException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new FileStoreException(String.format(\"Failed to add into filestore '%s' at '%s' \", getBaseDir().getAbsolutePath(), path), e);\n        }\n    }\n\n    @Override\n    public LocallyAvailableResource move(String path, final File source) {\n        if (!source.exists()) {\n            throw new FileStoreException(String.format(\"Cannot move '%s' into filestore @ '%s' as it does not exist\", source, path));\n        }\n\n        try {\n            return doAdd(path, new Action<File>() {\n                @Override\n                public void execute(File file) {\n                    if (source.isDirectory()) {\n                        GFileUtils.moveExistingDirectory(source, file);\n                    } else {\n                        GFileUtils.moveExistingFile(source, file);\n                    }\n                }\n            });\n        } catch (Throwable e) {\n            throw new FileStoreException(String.format(\"Failed to move file '%s' into filestore at '%s' \", source, path), e);\n        }\n    }\n\n    private LocallyAvailableResource doAdd(String path, Action<File> action) {\n        File destination = getFile(path);\n        doAdd(destination, action);\n        return entryAt(path);\n    }\n\n    protected void doAdd(File destination, Action<File> action) {\n        GFileUtils.parentMkdirs(destination);\n        File inProgressMarkerFile = getInProgressMarkerFile(destination);\n        GFileUtils.touch(inProgressMarkerFile);\n        try {\n            FileUtils.deleteQuietly(destination);\n            action.execute(destination);\n        } catch (Throwable t) {\n            FileUtils.deleteQuietly(destination);\n            throw UncheckedException.throwAsUncheckedException(t);\n        } finally {\n            deleteFileQuietly(inProgressMarkerFile);\n        }\n    }\n\n    @Override\n    public Set<? extends LocallyAvailableResource> search(String pattern) {\n        if (!getBaseDir().exists()) {\n            return Collections.emptySet();\n        }\n\n        final Set<LocallyAvailableResource> entries = new HashSet<LocallyAvailableResource>();\n        findFiles(pattern).visit(new EmptyFileVisitor() {\n            @Override\n            public void visitFile(FileVisitDetails fileDetails) {\n                final File file = fileDetails.getFile();\n                // We cannot clean in progress markers, or in progress files here because\n                // the file system visitor stuff can't handle the file system mutating while visiting\n                if (!isInProgressMarkerFile(file) && !isInProgressFile(file)) {\n                    entries.add(entryAt(file));\n                }\n            }\n        });\n\n        return entries;\n    }\n\n    private File getInProgressMarkerFile(File file) {\n        return new File(file.getParent(), file.getName() + IN_PROGRESS_MARKER_FILE_SUFFIX);\n    }\n\n    private boolean isInProgressMarkerFile(File file) {\n        return hasExtension(file, IN_PROGRESS_MARKER_FILE_SUFFIX);\n    }\n\n    private boolean isInProgressFile(File file) {\n        return getInProgressMarkerFile(file).exists();\n    }\n\n    private MinimalFileTree findFiles(String pattern) {\n        return new SingleIncludePatternFileTree(baseDir, pattern);\n    }\n\n    protected LocallyAvailableResource entryAt(File file) {\n        return entryAt(RelativePathUtil.relativePath(baseDir, file));\n    }\n\n    protected LocallyAvailableResource entryAt(final String path) {\n        return new DefaultLocallyAvailableResource(getFile(path), checksumService);\n    }\n\n    @Override\n    public LocallyAvailableResource get(String... path) {\n        final File file = getFileWhileCleaningInProgress(path);\n        if (file.exists()) {\n            return new DefaultLocallyAvailableResource(getFile(path), checksumService);\n        } else {\n            return null;\n        }\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static void deleteFileQuietly(File file) {\n        file.delete();\n    }\n\n    private static String trimLeadingSlash(String composedPath) {\n        if (!composedPath.isEmpty() && composedPath.charAt(0) == '/') {\n            return composedPath.substring(1);\n        }\n        return composedPath;\n    }}\n", "/*\n * Copyright 2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.internal.resource.local\n\nimport org.gradle.api.Action\nimport org.gradle.test.fixtures.file.TestFile\nimport org.gradle.test.fixtures.file.TestNameTestDirectoryProvider\nimport org.gradle.util.TestUtil\nimport org.gradle.util.UsesNativeServices\nimport org.junit.Rule\nimport spock.lang.Specification\n\n@UsesNativeServices\nclass DefaultPathKeyFileStoreTest extends Specification {\n    @Rule TestNameTestDirectoryProvider dir = new TestNameTestDirectoryProvider(getClass())\n    TestFile fsBase\n    PathKeyFileStore store\n\n    def pathCounter = 0\n\n    def setup() {\n        fsBase = dir.file(\"fs\")\n        store = new DefaultPathKeyFileStore(TestUtil.checksumService, fsBase)\n    }\n\n    def \"can move file to filestore\"() {\n        def a = createFile(\"abc\")\n        def b = createFile(\"def\")\n\n        when:\n        // leading slash does not mean absolute path\n        store.move(\"/a\", a)\n        store.move(\"b\", b)\n\n        then:\n        def storedA = store.get(\"a\")\n        storedA.file.text == \"abc\"\n        storedA.file == fsBase.file(\"a\")\n        !a.exists()\n\n        def storedB = store.get(\"b\")\n        storedB.file.text == \"def\"\n        storedB.file == fsBase.file(\"b\")\n        !b.exists()\n    }\n\n    def \"can move directory to filestore\"() {\n        def a = dir.createDir(\"a\")\n        a.file(\"child-1\").createFile()\n        a.file(\"dir/child-2\").createFile()\n\n        when:\n        store.move(\"a\", a)\n\n        then:\n        def stored = store.get(\"a\")\n        stored.file.directory\n        stored.file == fsBase.file(\"a\")\n        fsBase.file(\"a\").assertHasDescendants(\"child-1\", \"dir/child-2\")\n        !a.exists()\n    }\n\n    def \"can add file to filestore\"() {\n        when:\n        store.add(\"a\", { File f -> f.text = \"abc\"} as Action<File>)\n        store.add(\"b\", { File f -> f.text = \"def\"} as Action<File>)\n\n        then:\n        def storedA = store.get(\"a\")\n        storedA.file.text == \"abc\"\n        storedA.file == fsBase.file(\"a\")\n\n        def storedB = store.get(\"b\")\n        storedB.file.text == \"def\"\n        storedB.file == fsBase.file(\"b\")\n    }\n\n    def \"can add directory to filestore\"() {\n        when:\n        store.add(\"a\") { File f ->\n            f.mkdirs()\n            new File(f, \"a\").text = \"abc\"\n        }\n        store.add(\"b\") { File f ->\n            f.mkdirs()\n            new File(f, \"b\").text = \"def\"\n        }\n\n        then:\n        def storedA = store.get(\"a\")\n        storedA.file == fsBase.file(\"a\")\n        fsBase.file(\"a\").assertHasDescendants(\"a\")\n\n        def storedB = store.get(\"b\")\n        storedB.file == fsBase.file(\"b\")\n        fsBase.file(\"b\").assertHasDescendants(\"b\")\n    }\n\n    def \"add throws FileStoreAddActionException if exception in action occurred and cleans up\"() {\n        def failure = new RuntimeException(\"TestException\")\n\n        when:\n        store.add(\"a\", { File f ->\n            throw failure\n        } as Action<File>)\n        then:\n        def e = thrown(FileStoreAddActionException)\n        e.cause == failure\n\n        !fsBase.file(\"a\").exists()\n        !fsBase.file(\"a.fslock\").exists()\n    }\n\n    def \"cleans up left-over files when action fails\"() {\n        when:\n        store.add(\"a\", { File f ->\n            new File(f, \"child\").text = \"delete-me\"\n            throw new RuntimeException(\"TestException\")\n        } as Action<File>)\n\n        then:\n        thrown(FileStoreAddActionException)\n        !fsBase.file(\"a\").exists()\n        !fsBase.file(\"a.fslock\").exists()\n    }\n\n    def \"can get from backing filestore\"() {\n        when:\n        createFile(\"abc\", \"fs/a\")\n        then:\n        store.get(\"a\") != null\n        store.get(\"b\") == null\n    }\n\n    def \"get cleans up filestore\"() {\n        when:\n        createFile(\"abc\", \"fs/a\").exists()\n        createFile(\"lock\", \"fs/a.fslck\").exists()\n        then:\n        store.get(\"a\") == null\n        store.get(\"a.fslock\") == null\n    }\n\n    def \"can overwrite stale files \"() {\n        given:\n        createFile(\"abc\", \"fs/a\").exists()\n        createFile(\"lock\", \"fs/a.fslck\").exists()\n        when:\n        store.add(\"a\", { File f -> f.text = \"def\"} as Action<File>)\n        then:\n        store.get(\"a\").file.text == \"def\"\n    }\n\n    def \"get on stale file with marker removes file from filestore\"() {\n        when:\n        createFile(\"abc\", \"fs/a\")\n        createFile(\"def\", \"fs/b\")\n        then:\n        store.get(\"a\").file.text == \"abc\"\n        store.get(\"b\").file.text == \"def\"\n    }\n\n    def \"can overwrite file entry\"() {\n        when:\n        store.move(\"a\", createFile(\"abc\"))\n        store.move(\"a\", createFile(\"def\"))\n\n        then:\n        fsBase.file(\"a\").text == \"def\"\n    }\n\n    def \"creates intermediary directories\"() {\n        when:\n        store.move(\"a/b/c\", createFile(\"abc\"))\n        store.move(\"a/b/d\", createFile(\"abd\"))\n        store.move(\"a/c/a\", createFile(\"aca\"))\n\n        then:\n        fsBase.file(\"a/b\").directory\n        fsBase.file(\"a/b/c\").text == \"abc\"\n        fsBase.file(\"a/c/a\").text == \"aca\"\n    }\n\n    def \"can search via globs\"() {\n        when:\n        store.move(\"a/a/a\", createFile(\"a\"))\n        store.move(\"a/a/b\", createFile(\"b\"))\n        store.move(\"a/b/a\", createFile(\"c\"))\n\n        then:\n        store.search(\"**/a\").size() == 2\n        store.search(\"*/b/*\").size() == 1\n        store.search(\"a/b/a\").size() == 1\n    }\n\n    def \"search ignores stale entries with marker file\"() {\n        when:\n        store.move(\"a/a/a\", createFile(\"a\"))\n        store.move(\"a/b/b\", createFile(\"b\"))\n        store.move(\"a/c/c\", createFile(\"c\"))\n        createFile(\"lock\", \"fs/a/b/b.fslck\")\n        def search = store.search(\"**/*\")\n        then:\n        search.size() == 2\n        search.collect {entry -> entry.file.name}.sort() == [\"a\", \"c\"]\n    }\n\n    def createFile(String content, String path = \"f${pathCounter++}\") {\n        dir.createFile(path) << content\n    }\n}\n", "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.integtests.resolve\n\nimport org.gradle.api.internal.artifacts.ivyservice.CacheLayout\nimport org.gradle.cache.internal.scopes.DefaultCacheScopeMapping\nimport org.gradle.integtests.fixtures.AbstractHttpDependencyResolutionTest\nimport org.gradle.integtests.fixtures.ToBeFixedForConfigurationCache\nimport org.gradle.integtests.fixtures.cache.CachingIntegrationFixture\nimport org.gradle.internal.hash.Hashing\nimport org.gradle.test.fixtures.file.TestFile\n\nimport java.nio.file.Files\n\nclass CacheResolveIntegrationTest extends AbstractHttpDependencyResolutionTest implements CachingIntegrationFixture {\n\n    @ToBeFixedForConfigurationCache(because = \"CC does not check for deleted or modified artifacts in local cache\")\n    void \"cache handles manual deletion of cached artifacts\"() {\n        given:\n        def module = ivyHttpRepo.module('group', 'projectA', '1.2').publish()\n\n        def cacheDir = getUserHomeCacheDir().toURI()\n\n        and:\n        buildFile << \"\"\"\nrepositories {\n    ivy { url \"${ivyHttpRepo.uri}\" }\n}\nconfigurations { compile }\ndependencies { compile 'group:projectA:1.2' }\ntask listJars {\n    def files = configurations.compile\n    doLast {\n        assert files.collect { it.name } == ['projectA-1.2.jar']\n    }\n}\ntask deleteCacheFiles(type: Delete) {\n    delete fileTree(dir: '${cacheDir}', includes: ['**/projectA/**'])\n}\n\"\"\"\n\n        and:\n        module.allowAll()\n\n        and:\n        succeeds('listJars')\n        succeeds('deleteCacheFiles')\n\n        when:\n        server.resetExpectations()\n        module.ivy.expectGet()\n        module.jar.expectGet()\n\n        then:\n        succeeds('listJars')\n    }\n\n    void \"cache entries are segregated between different repositories\"() {\n        given:\n        def repo1 = ivyHttpRepo('ivy-repo-a')\n        def module1 = repo1.module('org.gradle', 'testproject', '1.0').publish()\n        def repo2 = ivyHttpRepo('ivy-repo-b')\n        def module2 = repo2.module('org.gradle', 'testproject', '1.0').publishWithChangedContent()\n\n        and:\n        settingsFile << \"include 'a','b'\"\n        buildFile << \"\"\"\nsubprojects {\n    configurations {\n        test\n    }\n    dependencies {\n        test \"org.gradle:testproject:1.0\"\n    }\n    task retrieve(type: Sync) {\n        into 'build'\n        from configurations.test\n    }\n}\nproject('a') {\n    repositories {\n        ivy { url \"${repo1.uri}\" }\n    }\n}\nproject('b') {\n    repositories {\n        ivy { url \"${repo2.uri}\" }\n    }\n    retrieve.dependsOn(':a:retrieve')\n}\n\"\"\"\n\n        when:\n        module1.ivy.expectGet()\n        module1.jar.expectGet()\n\n        module2.ivy.expectHead()\n        module2.ivy.sha1.expectGet()\n        module2.ivy.expectGet()\n        module2.jar.expectHead()\n        module2.jar.sha1.expectGet()\n        module2.jar.expectGet()\n\n        then:\n        succeeds 'retrieve'\n\n        and:\n        file('a/build/testproject-1.0.jar').assertIsCopyOf(module1.jarFile)\n        file('b/build/testproject-1.0.jar').assertIsCopyOf(module2.jarFile)\n    }\n\n    def 'dependency cache can be relocated'() {\n        given:\n        def module = ivyHttpRepo.module('group', 'projectA', '1.2').publish()\n\n        and:\n        buildFile << \"\"\"\nrepositories {\n    ivy { url \"${ivyHttpRepo.uri}\" }\n}\nconfigurations { compile }\ndependencies { compile 'group:projectA:1.2' }\ntask listJars {\n    def files = configurations.compile\n    doLast {\n        assert files.collect { it.name } == ['projectA-1.2.jar']\n    }\n}\n\"\"\"\n\n        and:\n        module.allowAll()\n\n        and:\n        succeeds('listJars')\n\n        when:\n        server.resetExpectations()\n        relocateCachesAndChangeGradleHome()\n\n        then:\n        succeeds('listJars')\n    }\n\n    def 'cannot write cache entries outside of GAV'() {\n        given:\n        def fakeDep = temporaryFolder.testDirectory.file('fake-repo/pwned.txt')\n        fakeDep << \"\"\"\nHello world!\n\"\"\"\n        def hash = Hashing.sha1().hashFile(fakeDep).toString()\n        def hashOfBootJar = '1234' // for demo purpose\n        def invalidPath = \"org.spring/core/1.0/$hash/artifact-1.0./../../../../boot/2.0/$hashOfBootJar/pwned.txt\"\n        def invalidLocation = executer.gradleUserHomeDir.file(cachePath + invalidPath).canonicalFile\n\n        server.allowGetOrHead(\"/repo/org/boot/2.0/$hashOfBootJar/pwned.txt\", fakeDep)\n\n        and:\n        withValidJavaSource()\n        buildWithJavaLibraryAndMavenRepoArtifactOnly()\n\n        and:\n        buildFile << \"\"\"\ndependencies { implementation 'org.spring:core:1.0@/../../../../boot/2.0/$hashOfBootJar/pwned.txt' }\n\"\"\"\n\n        when:\n        fails('compileJava')\n\n        then:\n        failureCauseContains('is not a safe zip entry name')\n        // If the build did not fail, Gradle would effectively write a file inside org.spring/boot/2.0 instead of inside org.spring/core/1.0\n        // If we have the real hash of a JAR in those other coordinates, Gradle could overwrite and replace the real JAR with a malicious one\n        !invalidLocation.exists()\n    }\n\n    def 'cannot write cache entries outside of dependency cache'() {\n        given:\n        def fakeDep = temporaryFolder.testDirectory.file('fake-repo/pwned.txt')\n        fakeDep << \"\"\"\nHello world!\n\"\"\"\n        // Code block used to verify what happens if the build succeeds\n        def hash = Hashing.sha1().hashFile(fakeDep).toString()\n        def invalidPath = \"org.spring/../../../../../core/1.0/$hash/artifact-1.0./../../../../.ssh/pwned.txt\"\n        def invalidLocation = executer.gradleUserHomeDir.file(cachePath + invalidPath).canonicalFile\n\n        server.allowGetOrHead('/repo/org/.ssh/pwned.txt', fakeDep)\n\n        and:\n        withValidJavaSource()\n        buildWithJavaLibraryAndMavenRepoArtifactOnly()\n\n        and:\n        buildFile << \"\"\"\ndependencies { implementation 'org.spring/../../../../../:core:1.0@/../../../../.ssh/pwned.txt' }\n\"\"\"\n\n        when:\n        fails('compileJava')\n\n        then:\n        failureCauseContains('is not a safe zip entry name')\n        // If the build did not fail, Gradle would effectively write a file inside a folder that is a sibling to the Gradle User Home\n        // If this was ~/.gradle, Gradle would have written in ~/.ssh\n        !invalidLocation.exists()\n    }\n\n    def 'cannot write cache entries anywhere on disk using metadata'() {\n        given:\n        // Our crafty coordinates\n        def pwnedDep = mavenRepo.module('org.spring/../../../../../', 'core')\n        // Our abused coordinates that will see a POM request\n        def abusedCoordinates = mavenHttpRepo.module('org.spring', 'core', '1.0').publish()\n        // Defeat the Gradle validation that will verify metadata content match requested coordinates\n        abusedCoordinates.pom.file.replace('<groupId>org.spring</groupId>', '<groupId>org.spring/../../../../../</groupId>')\n        // Our test dependency that now has a crafty dependency itself\n        def testDep = mavenHttpRepo.module('org.test', 'test').dependsOn(pwnedDep, type: '/../../../../.ssh/pwned.txt').publish()\n\n        def fakeDep = temporaryFolder.testDirectory.file('fake-repo/pwned.txt')\n        fakeDep << \"\"\"\nHello world!\n\"\"\"\n        def hash = Hashing.sha1().hashFile(fakeDep).toString()\n        def invalidPath = \"org.spring/../../../../../core/1.0/$hash/artifact-1.0./../../../../.ssh/pwned.txt\"\n        def invalidLocation = executer.gradleUserHomeDir.file(cachePath + invalidPath).canonicalFile\n\n        testDep.allowAll()\n        abusedCoordinates.allowAll()\n        server.allowGetOrHead('/repo/org/.ssh/pwned.txt', fakeDep)\n\n        and:\n        withValidJavaSource()\n        buildWithJavaLibraryAndMavenRepo()\n\n        and:\n        buildFile << \"\"\"\ndependencies { implementation 'org.test:test:1.0' }\n\"\"\"\n\n        when:\n        fails('compileJava')\n\n        then:\n        failureCauseContains('is not a safe zip entry name')\n        // If the build did not fail, Gradle would effectively write a file inside a folder that is a sibling to the Gradle User Home\n        // If this was ~/.gradle, Gradle would have written in ~/.ssh\n        !invalidLocation.exists()\n    }\n\n    private String getCachePath() {\n        \"caches/${CacheLayout.ROOT.key}/${CacheLayout.FILE_STORE.key}/\"\n    }\n\n    private void buildWithJavaLibraryAndMavenRepoArtifactOnly() {\n        buildFile << \"\"\"\nplugins {\n    id('java-library')\n}\n\nrepositories {\n    maven {\n        url \"${mavenHttpRepo.uri}\"\n        metadataSources {\n            artifact()\n        }\n    }\n}\n\"\"\"\n    }\n\n    private void buildWithJavaLibraryAndMavenRepo() {\n        buildFile << \"\"\"\nplugins {\n    id('java-library')\n}\n\nrepositories {\n    maven {\n        url \"${mavenHttpRepo.uri}\"\n    }\n}\n\"\"\"\n    }\n\n    private TestFile withValidJavaSource() {\n        temporaryFolder.testDirectory.file('src/main/java/org/test/Base.java') << \"\"\"\npackage org.test;\n\npublic class Base {}\n\"\"\"\n    }\n\n    def relocateCachesAndChangeGradleHome() {\n        def otherHome = executer.gradleUserHomeDir.parentFile.createDir('other-home')\n        def otherCacheDir = otherHome.toPath().resolve(DefaultCacheScopeMapping.GLOBAL_CACHE_DIR_NAME)\n        Files.createDirectory(otherCacheDir)\n        Files.move(getMetadataCacheDir().toPath(), otherCacheDir.resolve(CacheLayout.ROOT.key))\n        executer.withGradleUserHomeDir(otherHome)\n    }\n}\n"], "filenames": ["subprojects/core/src/main/java/org/gradle/internal/resource/local/DefaultPathKeyFileStore.java", "subprojects/core/src/test/groovy/org/gradle/internal/resource/local/DefaultPathKeyFileStoreTest.groovy", "subprojects/dependency-management/src/integTest/groovy/org/gradle/integtests/resolve/CacheResolveIntegrationTest.groovy"], "buggy_code_start_loc": [29, 45, 22], "buggy_code_end_loc": [216, 46, 155], "fixing_code_start_loc": [30, 45, 23], "fixing_code_end_loc": [232, 47, 307], "type": "CWE-22", "message": "Gradle is a build tool with a focus on build automation and support for multi-language development. When Gradle writes a dependency into its dependency cache, it uses the dependency's coordinates to compute a file location. With specially crafted dependency coordinates, Gradle can be made to write files into an unintended location. The file may be written outside the dependency cache or over another file in the dependency cache. This vulnerability could be used to poison the dependency cache or overwrite important files elsewhere on the filesystem where the Gradle process has write permissions. Exploiting this vulnerability requires an attacker to have control over a dependency repository used by the Gradle build or have the ability to modify the build's configuration. It is unlikely that this would go unnoticed. A fix has been released in Gradle 7.6.2 and 8.2 to protect against this vulnerability. Gradle will refuse to cache dependencies that have path traversal elements in their dependency coordinates. It is recommended that users upgrade to a patched version. If you are unable to upgrade to Gradle 7.6.2 or 8.2, `dependency verification` will make this vulnerability more difficult to exploit.", "other": {"cve": {"id": "CVE-2023-35946", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-30T21:15:09.070", "lastModified": "2024-03-06T15:20:18.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gradle is a build tool with a focus on build automation and support for multi-language development. When Gradle writes a dependency into its dependency cache, it uses the dependency's coordinates to compute a file location. With specially crafted dependency coordinates, Gradle can be made to write files into an unintended location. The file may be written outside the dependency cache or over another file in the dependency cache. This vulnerability could be used to poison the dependency cache or overwrite important files elsewhere on the filesystem where the Gradle process has write permissions. Exploiting this vulnerability requires an attacker to have control over a dependency repository used by the Gradle build or have the ability to modify the build's configuration. It is unlikely that this would go unnoticed. A fix has been released in Gradle 7.6.2 and 8.2 to protect against this vulnerability. Gradle will refuse to cache dependencies that have path traversal elements in their dependency coordinates. It is recommended that users upgrade to a patched version. If you are unable to upgrade to Gradle 7.6.2 or 8.2, `dependency verification` will make this vulnerability more difficult to exploit."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:L/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.3}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gradle:gradle:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.6.2", "matchCriteriaId": "625A3013-4C8A-46A0-9559-A01BDB4C23CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gradle:gradle:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.2.0", "matchCriteriaId": "8E909D6A-5F91-434F-8506-50CBC384EAB5"}]}]}], "references": [{"url": "https://docs.gradle.org/current/userguide/dependency_verification.html", "source": "security-advisories@github.com", "tags": ["Product", "Vendor Advisory"]}, {"url": "https://github.com/gradle/gradle/commit/859eae2b2acf751ae7db3c9ffefe275aa5da0d5d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gradle/gradle/commit/b07e528feb3a5ffa66bdcc358549edd73e4c8a12", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gradle/gradle/security/advisories/GHSA-2h6c-rv6q-494v", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230731-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gradle/gradle/commit/859eae2b2acf751ae7db3c9ffefe275aa5da0d5d"}}