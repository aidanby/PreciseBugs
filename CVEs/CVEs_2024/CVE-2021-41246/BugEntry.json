{"buggy_code": ["const { strict: assert, AssertionError } = require('assert');\nconst {\n  JWK,\n  JWKS,\n  JWE,\n  errors: { JOSEError },\n} = require('jose');\nconst { promisify } = require('util');\nconst cookie = require('cookie');\nconst onHeaders = require('on-headers');\nconst COOKIES = require('./cookies');\nconst { encryption: deriveKey } = require('./hkdf');\nconst debug = require('./debug')('appSession');\n\nconst epoch = () => (Date.now() / 1000) | 0;\nconst MAX_COOKIE_SIZE = 4096;\n\nfunction attachSessionObject(req, sessionName, value) {\n  Object.defineProperty(req, sessionName, {\n    enumerable: true,\n    get() {\n      return value;\n    },\n    set(arg) {\n      if (arg === null || arg === undefined) {\n        value = arg;\n      } else {\n        throw new TypeError('session object cannot be reassigned');\n      }\n      return undefined;\n    },\n  });\n}\n\nmodule.exports = (config) => {\n  let current;\n\n  const alg = 'dir';\n  const enc = 'A256GCM';\n  const secrets = Array.isArray(config.secret)\n    ? config.secret\n    : [config.secret];\n  const sessionName = config.session.name;\n  const cookieConfig = config.session.cookie;\n  const {\n    genid: generateId,\n    absoluteDuration,\n    rolling: rollingEnabled,\n    rollingDuration,\n  } = config.session;\n\n  const { transient: emptyTransient, ...emptyCookieOptions } = cookieConfig;\n  emptyCookieOptions.expires = emptyTransient ? 0 : new Date();\n  emptyCookieOptions.path = emptyCookieOptions.path || '/';\n\n  const emptyCookie = cookie.serialize(\n    `${sessionName}.0`,\n    '',\n    emptyCookieOptions\n  );\n  const cookieChunkSize = MAX_COOKIE_SIZE - emptyCookie.length;\n\n  let keystore = new JWKS.KeyStore();\n\n  secrets.forEach((secretString, i) => {\n    const key = JWK.asKey(deriveKey(secretString));\n    if (i === 0) {\n      current = key;\n    }\n    keystore.add(key);\n  });\n\n  if (keystore.size === 1) {\n    keystore = current;\n  }\n\n  function encrypt(payload, headers) {\n    return JWE.encrypt(payload, current, { alg, enc, ...headers });\n  }\n\n  function decrypt(jwe) {\n    return JWE.decrypt(jwe, keystore, {\n      complete: true,\n      contentEncryptionAlgorithms: [enc],\n      keyManagementAlgorithms: [alg],\n    });\n  }\n\n  function calculateExp(iat, uat) {\n    if (!rollingEnabled) {\n      return iat + absoluteDuration;\n    }\n\n    return Math.min(\n      ...[uat + rollingDuration, iat + absoluteDuration].filter(Boolean)\n    );\n  }\n\n  function setCookie(\n    req,\n    res,\n    { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n  ) {\n    const cookies = req[COOKIES];\n    const { transient: cookieTransient, ...cookieOptions } = cookieConfig;\n    cookieOptions.expires = cookieTransient ? 0 : new Date(exp * 1000);\n\n    // session was deleted or is empty, this matches all session cookies (chunked or unchunked)\n    // and clears them, essentially cleaning up what we've set in the past that is now trash\n    if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n      debug(\n        'session was deleted or is empty, clearing all matching session cookies'\n      );\n      for (const cookieName of Object.keys(cookies)) {\n        if (cookieName.match(`^${sessionName}(?:\\\\.\\\\d)?$`)) {\n          res.clearCookie(cookieName, {\n            domain: cookieOptions.domain,\n            path: cookieOptions.path,\n          });\n        }\n      }\n    } else {\n      debug(\n        'found session, creating signed session cookie(s) with name %o(.i)',\n        sessionName\n      );\n\n      const value = encrypt(JSON.stringify(req[sessionName]), {\n        iat,\n        uat,\n        exp,\n      });\n\n      const chunkCount = Math.ceil(value.length / cookieChunkSize);\n\n      if (chunkCount > 1) {\n        debug('cookie size greater than %d, chunking', cookieChunkSize);\n        for (let i = 0; i < chunkCount; i++) {\n          const chunkValue = value.slice(\n            i * cookieChunkSize,\n            (i + 1) * cookieChunkSize\n          );\n\n          const chunkCookieName = `${sessionName}.${i}`;\n          res.cookie(chunkCookieName, chunkValue, cookieOptions);\n        }\n        if (sessionName in cookies) {\n          debug('replacing non chunked cookie with chunked cookies');\n          res.clearCookie(sessionName, {\n            domain: cookieConfig.domain,\n            path: cookieConfig.path,\n          });\n        }\n      } else {\n        res.cookie(sessionName, value, cookieOptions);\n        for (const cookieName of Object.keys(cookies)) {\n          debug('replacing chunked cookies with non chunked cookies');\n          if (cookieName.match(`^${sessionName}\\\\.\\\\d$`)) {\n            res.clearCookie(cookieName, {\n              domain: cookieConfig.domain,\n              path: cookieConfig.path,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  class CookieStore {\n    async get(idOrVal) {\n      const { protected: header, cleartext } = decrypt(idOrVal);\n      return {\n        header,\n        data: JSON.parse(cleartext),\n      };\n    }\n\n    setCookie(id, req, res, iat) {\n      setCookie(req, res, iat);\n    }\n  }\n\n  class CustomStore {\n    constructor(store) {\n      this._get = promisify(store.get).bind(store);\n      this._set = promisify(store.set).bind(store);\n      this._destroy = promisify(store.destroy).bind(store);\n    }\n\n    async get(id) {\n      return this._get(id);\n    }\n\n    async set(\n      id,\n      req,\n      res,\n      { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n    ) {\n      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n        if (req[COOKIES][sessionName]) {\n          await this._destroy(id);\n        }\n      } else {\n        await this._set(id, {\n          header: { iat, uat, exp },\n          data: req[sessionName],\n        });\n      }\n    }\n\n    setCookie(\n      id,\n      req,\n      res,\n      { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n    ) {\n      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n        if (req[COOKIES][sessionName]) {\n          res.clearCookie(sessionName, {\n            domain: cookieConfig.domain,\n            path: cookieConfig.path,\n          });\n        }\n      } else {\n        const cookieOptions = {\n          ...cookieConfig,\n          expires: cookieConfig.transient ? 0 : new Date(exp * 1000),\n        };\n        delete cookieOptions.transient;\n        res.cookie(sessionName, id, cookieOptions);\n      }\n    }\n  }\n\n  const store = config.session.store\n    ? new CustomStore(config.session.store)\n    : new CookieStore();\n\n  return async (req, res, next) => {\n    if (req.hasOwnProperty(sessionName)) {\n      debug(\n        'request object (req) already has %o property, this is indicative of a middleware setup problem',\n        sessionName\n      );\n      return next(\n        new Error(\n          `req[${sessionName}] is already set, did you run this middleware twice?`\n        )\n      );\n    }\n\n    req[COOKIES] = cookie.parse(req.get('cookie') || '');\n\n    let iat;\n    let uat;\n    let exp;\n    let existingSessionValue;\n\n    try {\n      if (req[COOKIES].hasOwnProperty(sessionName)) {\n        // get JWE from unchunked session cookie\n        debug('reading session from %s cookie', sessionName);\n        existingSessionValue = req[COOKIES][sessionName];\n      } else if (req[COOKIES].hasOwnProperty(`${sessionName}.0`)) {\n        // get JWE from chunked session cookie\n        // iterate all cookie names\n        // match and filter for the ones that match sessionName.<number>\n        // sort by chunk index\n        // concat\n        existingSessionValue = Object.entries(req[COOKIES])\n          .map(([cookie, value]) => {\n            const match = cookie.match(`^${sessionName}\\\\.(\\\\d+)$`);\n            if (match) {\n              return [match[1], value];\n            }\n          })\n          .filter(Boolean)\n          .sort(([a], [b]) => {\n            return parseInt(a, 10) - parseInt(b, 10);\n          })\n          .map(([i, chunk]) => {\n            debug('reading session chunk from %s.%d cookie', sessionName, i);\n            return chunk;\n          })\n          .join('');\n      }\n      if (existingSessionValue) {\n        const { header, data } = await store.get(existingSessionValue);\n        ({ iat, uat, exp } = header);\n\n        // check that the existing session isn't expired based on options when it was established\n        assert(\n          exp > epoch(),\n          'it is expired based on options when it was established'\n        );\n\n        // check that the existing session isn't expired based on current rollingDuration rules\n        if (rollingDuration) {\n          assert(\n            uat + rollingDuration > epoch(),\n            'it is expired based on current rollingDuration rules'\n          );\n        }\n\n        // check that the existing session isn't expired based on current absoluteDuration rules\n        if (absoluteDuration) {\n          assert(\n            iat + absoluteDuration > epoch(),\n            'it is expired based on current absoluteDuration rules'\n          );\n        }\n\n        attachSessionObject(req, sessionName, data);\n      }\n    } catch (err) {\n      if (err instanceof AssertionError) {\n        debug('existing session was rejected because', err.message);\n      } else if (err instanceof JOSEError) {\n        debug(\n          'existing session was rejected because it could not be decrypted',\n          err\n        );\n      } else {\n        debug('unexpected error handling session', err);\n      }\n    }\n\n    if (!req.hasOwnProperty(sessionName) || !req[sessionName]) {\n      attachSessionObject(req, sessionName, {});\n    }\n\n    const id = existingSessionValue || generateId(req);\n\n    onHeaders(res, () => store.setCookie(id, req, res, { iat }));\n\n    if (store.set) {\n      const { end: origEnd } = res;\n      res.end = async function resEnd(...args) {\n        try {\n          await store.set(id, req, res, {\n            iat,\n          });\n          origEnd.call(res, ...args);\n        } catch (e) {\n          // need to restore the original `end` so that it gets\n          // called after `next(e)` calls the express error handling mw\n          res.end = origEnd;\n          process.nextTick(() => next(e));\n        }\n      };\n    }\n\n    return next();\n  };\n};\n", "const express = require('express');\nconst cb = require('cb');\nconst createError = require('http-errors');\n\nconst debug = require('../lib/debug')('auth');\nconst { get: getConfig } = require('../lib/config');\nconst { get: getClient } = require('../lib/client');\nconst { requiresAuth } = require('./requiresAuth');\nconst attemptSilentLogin = require('./attemptSilentLogin');\nconst TransientCookieHandler = require('../lib/transientHandler');\nconst { RequestContext, ResponseContext } = require('../lib/context');\nconst appSession = require('../lib/appSession');\nconst { decodeState } = require('../lib/hooks/getLoginState');\n\nconst enforceLeadingSlash = (path) => {\n  return path.split('')[0] === '/' ? path : '/' + path;\n};\n\n/**\n * Returns a router with two routes /login and /callback\n *\n * @param {Object} [params] The parameters object; see index.d.ts for types and descriptions.\n *\n * @returns {express.Router} the router\n */\nconst auth = function (params) {\n  const config = getConfig(params);\n  debug('configuration object processed, resulting configuration: %O', config);\n  const router = new express.Router();\n  const transient = new TransientCookieHandler(config);\n\n  router.use(appSession(config));\n\n  // Express context and OpenID Issuer discovery.\n  router.use(async (req, res, next) => {\n    req.oidc = new RequestContext(config, req, res, next);\n    res.oidc = new ResponseContext(config, req, res, next, transient);\n    next();\n  });\n\n  // Login route, configurable with routes.login\n  if (config.routes.login) {\n    const path = enforceLeadingSlash(config.routes.login);\n    debug('adding GET %s route', path);\n    router.get(path, express.urlencoded({ extended: false }), (req, res) =>\n      res.oidc.login({ returnTo: config.baseURL })\n    );\n  } else {\n    debug('login handling route not applied');\n  }\n\n  // Logout route, configurable with routes.logout\n  if (config.routes.logout) {\n    const path = enforceLeadingSlash(config.routes.logout);\n    debug('adding GET %s route', path);\n    router.get(path, (req, res) => res.oidc.logout());\n  } else {\n    debug('logout handling route not applied');\n  }\n\n  // Callback route, configured with routes.callback.\n  {\n    let client;\n    const path = enforceLeadingSlash(config.routes.callback);\n    const callbackStack = [\n      (req, res, next) => {\n        debug('%s %s called', req.method, path);\n        next();\n      },\n      async (req, res, next) => {\n        next = cb(next).once();\n\n        client =\n          client ||\n          (await getClient(config).catch((err) => {\n            next(err);\n          }));\n\n        if (!client) {\n          return;\n        }\n\n        try {\n          const redirectUri = res.oidc.getRedirectUri();\n\n          let session;\n\n          try {\n            const callbackParams = client.callbackParams(req);\n            const authVerification = transient.getOnce(\n              'auth_verification',\n              req,\n              res\n            );\n\n            const { max_age, code_verifier, nonce, state } = authVerification\n              ? JSON.parse(authVerification)\n              : {};\n\n            req.openidState = decodeState(state);\n            const checks = {\n              max_age,\n              code_verifier,\n              nonce,\n              state,\n            };\n\n            let extras;\n            if (config.tokenEndpointParams) {\n              extras = { exchangeBody: config.tokenEndpointParams };\n            }\n\n            session = await client.callback(\n              redirectUri,\n              callbackParams,\n              checks,\n              extras\n            );\n          } catch (err) {\n            throw createError.BadRequest(err.message);\n          }\n\n          if (config.afterCallback) {\n            session = await config.afterCallback(\n              req,\n              res,\n              Object.assign({}, session), // Remove non-enumerable methods from the TokenSet\n              req.openidState\n            );\n          }\n\n          Object.assign(req[config.session.name], session);\n          attemptSilentLogin.resumeSilentLogin(req, res);\n\n          next();\n        } catch (err) {\n          // Swallow errors if this is a silentLogin\n          if (req.openidState && req.openidState.attemptingSilentLogin) {\n            next();\n          } else {\n            next(err);\n          }\n        }\n      },\n      (req, res) => res.redirect(req.openidState.returnTo || config.baseURL),\n    ];\n\n    debug('adding GET %s route', path);\n    router.get(path, ...callbackStack);\n    debug('adding POST %s route', path);\n    router.post(\n      path,\n      express.urlencoded({ extended: false }),\n      ...callbackStack\n    );\n  }\n\n  if (config.authRequired) {\n    debug(\n      'authentication is required for all routes this middleware is applied to'\n    );\n    router.use(requiresAuth());\n  } else {\n    debug(\n      'authentication is not required for any of the routes this middleware is applied to ' +\n        'see and apply `requiresAuth` middlewares to your protected resources'\n    );\n  }\n  if (config.attemptSilentLogin) {\n    debug(\"silent login will be attempted on end-user's initial HTML request\");\n    router.use(attemptSilentLogin());\n  }\n\n  return router;\n};\n\n/**\n * Used for instantiating a custom session store. eg\n *\n * ```js\n * const { auth } = require('express-openid-connect');\n * const MemoryStore = require('memorystore')(auth);\n * ```\n *\n * @constructor\n */\nauth.Store = function () {};\n\nmodule.exports = auth;\n", "const { promisify } = require('util');\nconst express = require('express');\nconst { assert } = require('chai').use(require('chai-as-promised'));\nconst request = require('request-promise-native').defaults({\n  simple: false,\n  resolveWithFullResponse: true,\n});\n\nconst appSession = require('../lib/appSession');\nconst { get: getConfig } = require('../lib/config');\nconst { create: createServer } = require('./fixture/server');\nconst redis = require('redis-mock');\nconst RedisStore = require('connect-redis')({ Store: class Store {} });\n\nconst defaultConfig = {\n  clientID: '__test_client_id__',\n  clientSecret: '__test_client_secret__',\n  issuerBaseURL: 'https://op.example.com',\n  baseURL: 'http://example.org',\n  secret: '__test_secret__',\n  errorOnRequiredAuth: true,\n};\n\nconst sessionData = () => {\n  const epoch = () => (Date.now() / 1000) | 0;\n  const epochNow = epoch();\n  const weekInSeconds = 7 * 24 * 60 * 60;\n\n  return JSON.stringify({\n    header: {\n      uat: epochNow,\n      iat: epochNow,\n      exp: epochNow + weekInSeconds,\n    },\n    data: { sub: '__test_sub__' },\n  });\n};\n\nconst login = async (claims) => {\n  const jar = request.jar();\n  await request.post('/session', {\n    baseUrl,\n    jar,\n    json: claims,\n  });\n  return jar;\n};\n\nconst baseUrl = 'http://localhost:3000';\n\ndescribe('appSession custom store', () => {\n  let server;\n  let redisClient;\n\n  const setup = async (config) => {\n    redisClient = redis.createClient();\n    const store = new RedisStore({ client: redisClient, prefix: '' });\n    redisClient.asyncSet = promisify(redisClient.set).bind(redisClient);\n    redisClient.asyncGet = promisify(redisClient.get).bind(redisClient);\n\n    const conf = getConfig({\n      ...defaultConfig,\n      ...config,\n      session: { ...(config && config.session), store },\n    });\n\n    server = await createServer(appSession(conf));\n  };\n\n  afterEach(async () => {\n    if (server) {\n      await new Promise((resolve) => server.close(resolve));\n    }\n    if (redisClient) {\n      await new Promise((resolve) => redisClient.quit(resolve));\n    }\n  });\n\n  it('should not create a session when there are no cookies', async () => {\n    await setup();\n    const res = await request.get('/session', { baseUrl, json: true });\n    assert.isEmpty(res.body);\n  });\n\n  it('should not error for non existent sessions', async () => {\n    await setup();\n    const res = await request.get('/session', {\n      baseUrl,\n      json: true,\n      headers: {\n        cookie: 'appSession=__invalid_identity__',\n      },\n    });\n    assert.equal(res.statusCode, 200);\n    assert.isEmpty(res.body);\n  });\n\n  it('should get an existing session', async () => {\n    await setup();\n    await redisClient.asyncSet('foo', sessionData());\n    const jar = request.jar();\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n      headers: {\n        cookie: `appSession=foo`,\n      },\n    });\n    assert.equal(res.statusCode, 200);\n    assert.deepEqual(res.body, { sub: '__test_sub__' });\n    const [cookie] = jar.getCookies(baseUrl);\n    assert.deepInclude(cookie, {\n      key: 'appSession',\n      value: 'foo',\n    });\n  });\n\n  it('should get a new session', async () => {\n    await setup();\n    const jar = await login({ sub: '__foo_user__' });\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n    });\n    assert.equal(res.statusCode, 200);\n    assert.deepEqual(res.body, { sub: '__foo_user__' });\n  });\n\n  it('should destroy an existing session', async () => {\n    await setup({ idpLogout: false });\n    await redisClient.asyncSet('foo', sessionData());\n    const jar = request.jar();\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n      headers: {\n        cookie: `appSession=foo`,\n      },\n    });\n    assert.deepEqual(res.body, { sub: '__test_sub__' });\n    await request.post('/session', {\n      baseUrl,\n      jar,\n      json: {},\n    });\n    const loggedOutRes = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n    });\n    assert.isEmpty(loggedOutRes.body);\n    assert.isEmpty(jar.getCookies(baseUrl));\n  });\n\n  it('uses custom session id generator when provided', async () => {\n    const immId = 'apple';\n    await setup({\n      session: { genid: () => immId },\n    });\n    const jar = await login({\n      sub: '__foo_user__',\n      role: 'test',\n      userid: immId,\n    });\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n    });\n    assert.equal(res.statusCode, 200);\n    const storedSessionJson = await redisClient.asyncGet(immId);\n    const { data: sessionValues } = JSON.parse(storedSessionJson);\n    assert.deepEqual(sessionValues, {\n      sub: '__foo_user__',\n      role: 'test',\n      userid: immId,\n    });\n  });\n\n  it('should handle storage errors', async () => {\n    const store = {\n      get(id, cb) {\n        process.nextTick(() => cb(null, JSON.parse(sessionData())));\n      },\n      async set(id, val, cb) {\n        process.nextTick(() => cb(new Error('storage error')));\n      },\n      async destroy(id, cb) {\n        process.nextTick(() => cb());\n      },\n    };\n\n    const conf = getConfig({\n      ...defaultConfig,\n      session: { store },\n    });\n\n    server = await createServer(appSession(conf));\n\n    const jar = request.jar();\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n      headers: {\n        cookie: `appSession=foo`,\n      },\n    });\n    assert.equal(res.statusCode, 500);\n    assert.equal(res.body.err.message, 'storage error');\n  });\n\n  it('should not throw if another mw writes the header', async () => {\n    const app = express();\n\n    redisClient = redis.createClient();\n    const store = new RedisStore({ client: redisClient, prefix: '' });\n    await promisify(redisClient.set).bind(redisClient)('foo', sessionData());\n\n    app.use(\n      appSession(\n        getConfig({\n          ...defaultConfig,\n          session: { store },\n        })\n      )\n    );\n\n    app.get('/', (req, res, next) => {\n      res.json(req.appSession);\n      next();\n    });\n\n    app.use((req, res, next) => {\n      if (!res.headersSent) {\n        res.writeHead(200);\n      }\n      next();\n    });\n\n    server = await new Promise((resolve) => {\n      const server = app.listen(3000, () => resolve(server));\n    });\n\n    await assert.becomes(\n      request.get('/', {\n        baseUrl,\n        json: true,\n        headers: {\n          cookie: `appSession=foo`,\n        },\n        resolveWithFullResponse: false,\n      }),\n      { sub: '__test_sub__' }\n    );\n  });\n});\n", "const assert = require('chai').assert;\nconst sinon = require('sinon');\nconst jose = require('jose');\nconst request = require('request-promise-native').defaults({\n  simple: false,\n  resolveWithFullResponse: true,\n});\n\nconst TransientCookieHandler = require('../lib/transientHandler');\nconst { encodeState } = require('../lib/hooks/getLoginState');\nconst { auth } = require('..');\nconst { create: createServer } = require('./fixture/server');\nconst { makeIdToken } = require('./fixture/cert');\nconst clientID = '__test_client_id__';\nconst expectedDefaultState = encodeState({ returnTo: 'https://example.org' });\nconst nock = require('nock');\n\nconst baseUrl = 'http://localhost:3000';\nconst defaultConfig = {\n  secret: '__test_session_secret__',\n  clientID: clientID,\n  baseURL: 'http://example.org',\n  issuerBaseURL: 'https://op.example.com',\n  authRequired: false,\n};\nlet server;\n\nconst generateCookies = (values) => ({\n  auth_verification: JSON.stringify(values),\n});\n\nconst setup = async (params) => {\n  const authOpts = Object.assign({}, defaultConfig, params.authOpts || {});\n  const router = params.router || auth(authOpts);\n  const transient = new TransientCookieHandler(authOpts);\n\n  const jar = params.jar || request.jar();\n  server = await createServer(router);\n  let tokenReqHeader;\n  let tokenReqBody;\n\n  Object.keys(params.cookies).forEach(function (cookieName) {\n    let value;\n\n    transient.store(\n      cookieName,\n      {},\n      {\n        cookie(key, ...args) {\n          if (key === cookieName) {\n            value = args[0];\n          }\n        },\n      },\n      { value: params.cookies[cookieName] }\n    );\n\n    jar.setCookie(\n      `${cookieName}=${value}; Max-Age=3600; Path=/; HttpOnly;`,\n      baseUrl + '/callback'\n    );\n  });\n\n  const {\n    interceptors: [interceptor],\n  } = nock('https://op.example.com', { allowUnmocked: true })\n    .post('/oauth/token')\n    .reply(200, function (uri, requestBody) {\n      tokenReqHeader = this.req.headers;\n      tokenReqBody = requestBody;\n      return {\n        access_token: '__test_access_token__',\n        refresh_token: '__test_refresh_token__',\n        id_token: params.body.id_token,\n        token_type: 'Bearer',\n        expires_in: 86400,\n      };\n    });\n\n  const response = await request.post('/callback', {\n    baseUrl,\n    jar,\n    json: params.body,\n  });\n  const currentUser = await request\n    .get('/user', { baseUrl, jar, json: true })\n    .then((r) => r.body);\n  const tokens = await request\n    .get('/tokens', { baseUrl, jar, json: true })\n    .then((r) => r.body);\n\n  nock.removeInterceptor(interceptor);\n\n  return {\n    baseUrl,\n    jar,\n    response,\n    currentUser,\n    tokenReqHeader,\n    tokenReqBody,\n    tokens,\n  };\n};\n\n// For the purpose of this test the fake SERVER returns the error message in the body directly\n// production application should have an error middleware.\n// http://expressjs.com/en/guide/error-handling.html\n\ndescribe('callback response_mode: form_post', () => {\n  afterEach(() => {\n    if (server) {\n      server.close();\n    }\n  });\n\n  it('should error when the body is empty', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: true,\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(err.message, 'state missing from the response');\n  });\n\n  it('should error when the state is missing', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: {},\n      body: {\n        state: '__test_state__',\n        id_token: '__invalid_token__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(err.message, 'checks.state argument is missing');\n  });\n\n  it(\"should error when state doesn't match\", async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__valid_state__',\n      }),\n      body: {\n        state: '__invalid_state__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /state mismatch/i);\n  });\n\n  it(\"should error when id_token can't be parsed\", async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: '__invalid_token__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(\n      err.message,\n      'failed to decode JWT (JWTMalformed: JWTs must have three components)'\n    );\n  });\n\n  it('should error when id_token has invalid alg', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: jose.JWT.sign({ sub: '__test_sub__' }, 'secret', {\n          algorithm: 'HS256',\n        }),\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /unexpected JWT alg received/i);\n  });\n\n  it('should error when id_token is missing issuer', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: makeIdToken({ iss: undefined }),\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /missing required JWT property iss/i);\n  });\n\n  it('should error when nonce is missing from cookies', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: makeIdToken(),\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /nonce mismatch/i);\n  });\n\n  it('should error when legacy samesite fallback is off', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      authOpts: {\n        // Do not check the fallback cookie value.\n        legacySameSiteCookie: false,\n      },\n      cookies: {\n        _auth_verification: JSON.stringify({ state: '__test_state__' }),\n      },\n      body: {\n        state: '__test_state__',\n        id_token: '__invalid_token__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(err.message, 'checks.state argument is missing');\n  });\n\n  it('should use legacy samesite fallback', async () => {\n    const { currentUser } = await setup({\n      authOpts: {\n        identityClaimFilter: [],\n      },\n      cookies: {\n        _auth_verification: JSON.stringify({\n          state: expectedDefaultState,\n          nonce: '__test_nonce__',\n        }),\n      },\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken(),\n      },\n    });\n\n    assert.exists(currentUser);\n  });\n\n  it('should not strip claims when using custom claim filtering', async () => {\n    const { currentUser } = await setup({\n      authOpts: {\n        identityClaimFilter: [],\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken(),\n      },\n    });\n    assert.equal(currentUser.iss, 'https://op.example.com/');\n    assert.equal(currentUser.aud, clientID);\n    assert.equal(currentUser.nonce, '__test_nonce__');\n    assert.exists(currentUser.iat);\n    assert.exists(currentUser.exp);\n  });\n\n  it('should expose the id token when id_token is valid', async () => {\n    const idToken = makeIdToken();\n    const {\n      response: { statusCode, headers },\n      currentUser,\n      tokens,\n    } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n      },\n    });\n    assert.equal(statusCode, 302);\n    assert.equal(headers.location, 'https://example.org');\n    assert.ok(currentUser);\n    assert.equal(currentUser.sub, '__test_sub__');\n    assert.equal(currentUser.nickname, '__test_nickname__');\n    assert.notExists(currentUser.iat);\n    assert.notExists(currentUser.iss);\n    assert.notExists(currentUser.aud);\n    assert.notExists(currentUser.exp);\n    assert.notExists(currentUser.nonce);\n    assert.equal(tokens.isAuthenticated, true);\n    assert.equal(tokens.idToken, idToken);\n    assert.isUndefined(tokens.refreshToken);\n    assert.isUndefined(tokens.accessToken);\n    assert.include(tokens.idTokenClaims, {\n      sub: '__test_sub__',\n    });\n  });\n\n  it(\"should expose all tokens when id_token is valid and response_type is 'code id_token'\", async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const { tokens } = await setup({\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    assert.equal(tokens.isAuthenticated, true);\n    assert.equal(tokens.idToken, idToken);\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.include(tokens.accessToken, {\n      access_token: '__test_access_token__',\n      token_type: 'Bearer',\n    });\n    assert.include(tokens.idTokenClaims, {\n      sub: '__test_sub__',\n    });\n  });\n\n  it('should handle access token expiry', async () => {\n    const clock = sinon.useFakeTimers({ toFake: ['Date'] });\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n    const hrSecs = 60 * 60;\n    const hrMs = hrSecs * 1000;\n\n    const { tokens, jar } = await setup({\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n    assert.equal(tokens.accessToken.expires_in, 24 * hrSecs);\n    clock.tick(4 * hrMs);\n    const tokens2 = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    assert.equal(tokens2.accessToken.expires_in, 20 * hrSecs);\n    assert.isFalse(tokens2.accessTokenExpired);\n    clock.tick(21 * hrMs);\n    const tokens3 = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    assert.isTrue(tokens3.accessTokenExpired);\n    clock.restore();\n  });\n\n  it('should refresh an access token', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access',\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/refresh', async (req, res) => {\n      const accessToken = await req.oidc.accessToken.refresh();\n      res.json({\n        accessToken,\n        refreshToken: req.oidc.refreshToken,\n      });\n    });\n\n    const { tokens, jar } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const reply = sinon.spy(() => ({\n      access_token: '__new_access_token__',\n      refresh_token: '__new_refresh_token__',\n      id_token: tokens.idToken,\n      token_type: 'Bearer',\n      expires_in: 86400,\n    }));\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .post('/oauth/token')\n      .reply(200, reply);\n\n    const newTokens = await request\n      .get('/refresh', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    nock.removeInterceptor(interceptor);\n\n    sinon.assert.calledWith(\n      reply,\n      '/oauth/token',\n      'grant_type=refresh_token&refresh_token=__test_refresh_token__'\n    );\n\n    assert.equal(tokens.accessToken.access_token, '__test_access_token__');\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.equal(newTokens.accessToken.access_token, '__new_access_token__');\n    assert.equal(newTokens.refreshToken, '__new_refresh_token__');\n\n    const newerTokens = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n\n    assert.equal(\n      newerTokens.accessToken.access_token,\n      '__new_access_token__',\n      'the new access token should be persisted in the session'\n    );\n  });\n\n  it('should refresh an access token and keep original refresh token', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access',\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/refresh', async (req, res) => {\n      const accessToken = await req.oidc.accessToken.refresh();\n      res.json({\n        accessToken,\n        refreshToken: req.oidc.refreshToken,\n      });\n    });\n\n    const { tokens, jar } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const reply = sinon.spy(() => ({\n      access_token: '__new_access_token__',\n      id_token: tokens.id_token,\n      token_type: 'Bearer',\n      expires_in: 86400,\n    }));\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .post('/oauth/token')\n      .reply(200, reply);\n\n    const newTokens = await request\n      .get('/refresh', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    nock.removeInterceptor(interceptor);\n\n    sinon.assert.calledWith(\n      reply,\n      '/oauth/token',\n      'grant_type=refresh_token&refresh_token=__test_refresh_token__'\n    );\n\n    assert.equal(tokens.accessToken.access_token, '__test_access_token__');\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.equal(newTokens.accessToken.access_token, '__new_access_token__');\n    assert.equal(newTokens.refreshToken, '__test_refresh_token__');\n  });\n\n  it('should refresh an access token and pass tokenEndpointParams and refresh argument params to the request', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access',\n      },\n      tokenEndpointParams: {\n        longeLiveToken: true,\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/refresh', async (req, res) => {\n      const accessToken = await req.oidc.accessToken.refresh({\n        tokenEndpointParams: { force: true },\n      });\n      res.json({\n        accessToken,\n        refreshToken: req.oidc.refreshToken,\n      });\n    });\n\n    const { tokens, jar, tokenReqBody } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const reply = sinon.spy(() => ({\n      access_token: '__new_access_token__',\n      refresh_token: '__new_refresh_token__',\n      id_token: tokens.idToken,\n      token_type: 'Bearer',\n      expires_in: 86400,\n    }));\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .post('/oauth/token')\n      .reply(200, reply);\n\n    const newTokens = await request\n      .get('/refresh', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    nock.removeInterceptor(interceptor);\n\n    sinon.assert.calledWith(\n      reply,\n      '/oauth/token',\n      'longeLiveToken=true&force=true&grant_type=refresh_token&refresh_token=__test_refresh_token__'\n    );\n\n    assert.equal(tokens.accessToken.access_token, '__test_access_token__');\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.equal(newTokens.accessToken.access_token, '__new_access_token__');\n    assert.equal(newTokens.refreshToken, '__new_refresh_token__');\n    assert.match(tokenReqBody, /longeLiveToken=true/);\n\n    const newerTokens = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n\n    assert.equal(\n      newerTokens.accessToken.access_token,\n      '__new_access_token__',\n      'the new access token should be persisted in the session'\n    );\n  });\n\n  it('should fetch userinfo', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email',\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/user-info', async (req, res) => {\n      res.json(await req.oidc.fetchUserInfo());\n    });\n\n    const { jar } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .get('/userinfo')\n      .reply(200, () => ({\n        userInfo: true,\n        sub: '__test_sub__',\n      }));\n\n    const userInfo = await request\n      .get('/user-info', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n\n    nock.removeInterceptor(interceptor);\n\n    assert.deepEqual(userInfo, { userInfo: true, sub: '__test_sub__' });\n  });\n\n  it('should use basic auth on token endpoint when using code flow', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const { tokenReqBody, tokenReqHeader } = await setup({\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const credentials = Buffer.from(\n      tokenReqHeader.authorization.replace('Basic ', ''),\n      'base64'\n    );\n    assert.equal(credentials, '__test_client_id__:__test_client_secret__');\n    assert.match(\n      tokenReqBody,\n      /code=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y/\n    );\n  });\n\n  it('should resume silent logins when user successfully logs in', async () => {\n    const idToken = makeIdToken();\n    const jar = request.jar();\n    jar.setCookie('skipSilentLogin=true', baseUrl);\n    await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n        skipSilentLogin: '1',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n      },\n      jar,\n    });\n    const cookies = jar.getCookies(baseUrl);\n    assert.notOk(cookies.find(({ key }) => key === 'skipSilentLogin'));\n  });\n\n  context('when afterCallack is configured', async () => {\n    it('should allow modification of the session', async () => {\n      const idToken = makeIdToken({\n        c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n      });\n\n      const authOpts = {\n        ...defaultConfig,\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email',\n        },\n        afterCallback: async (req, res, session) => {\n          const userInfo = await req.oidc.fetchUserInfo();\n          return { ...session, ...userInfo };\n        },\n      };\n\n      // userinfo endpoint will be returned to req.oidc.fetchUserInfo\n      const {\n        interceptors: [interceptor],\n      } = nock('https://op.example.com', { allowUnmocked: true })\n        .get('/userinfo')\n        .reply(200, () => ({\n          org_id: 'auth_org_123',\n        }));\n\n      const router = auth(authOpts);\n      router.get('/session', async (req, res) => {\n        res.json({ session: req['appSession'] });\n      });\n\n      const { jar } = await setup({\n        router,\n        authOpts: {\n          clientSecret: '__test_client_secret__',\n          authorizationParams: {\n            response_type: 'code id_token',\n            audience: 'https://api.example.com/',\n            scope: 'openid profile email',\n          },\n        },\n        cookies: generateCookies({\n          state: expectedDefaultState,\n          nonce: '__test_nonce__',\n        }),\n        body: {\n          state: expectedDefaultState,\n          id_token: idToken,\n          code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n        },\n      });\n\n      nock.removeInterceptor(interceptor);\n\n      const body = await request\n        .get('/session', { baseUrl, jar, json: true })\n        .then((r) => r.body);\n\n      assert.deepEqual(body.session.org_id, 'auth_org_123');\n    });\n\n    it('should allow thrown error to fail the request', async () => {\n      const idToken = makeIdToken({\n        c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n      });\n\n      const authOpts = {\n        ...defaultConfig,\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email',\n        },\n        afterCallback: async () => {\n          throw { status: 999 };\n        },\n      };\n      const {\n        response: { statusCode },\n      } = await setup({\n        router: auth(authOpts),\n        authOpts,\n        cookies: generateCookies({\n          state: expectedDefaultState,\n          nonce: '__test_nonce__',\n        }),\n        body: {\n          state: expectedDefaultState,\n          id_token: idToken,\n          code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n        },\n      });\n\n      assert.equal(statusCode, 999);\n    });\n  });\n});\n"], "fixing_code": ["const { strict: assert, AssertionError } = require('assert');\nconst {\n  JWK,\n  JWKS,\n  JWE,\n  errors: { JOSEError },\n} = require('jose');\nconst { promisify } = require('util');\nconst cookie = require('cookie');\nconst onHeaders = require('on-headers');\nconst COOKIES = require('./cookies');\nconst { encryption: deriveKey } = require('./hkdf');\nconst debug = require('./debug')('appSession');\n\nconst epoch = () => (Date.now() / 1000) | 0;\nconst MAX_COOKIE_SIZE = 4096;\n\nconst REASSIGN = Symbol('reassign');\nconst REGENERATED_SESSION_ID = Symbol('regenerated_session_id');\n\nfunction attachSessionObject(req, sessionName, value) {\n  Object.defineProperty(req, sessionName, {\n    enumerable: true,\n    get() {\n      return value;\n    },\n    set(arg) {\n      if (arg === null || arg === undefined || arg[REASSIGN]) {\n        value = arg;\n      } else {\n        throw new TypeError('session object cannot be reassigned');\n      }\n      return undefined;\n    },\n  });\n}\n\nfunction regenerateSessionStoreId(req, config) {\n  if (config.session.store) {\n    req[REGENERATED_SESSION_ID] = config.session.genid(req);\n  }\n}\n\nfunction replaceSession(req, session, config) {\n  session[REASSIGN] = true;\n  req[config.session.name] = session;\n}\n\nmodule.exports = (config) => {\n  let current;\n\n  const alg = 'dir';\n  const enc = 'A256GCM';\n  const secrets = Array.isArray(config.secret)\n    ? config.secret\n    : [config.secret];\n  const sessionName = config.session.name;\n  const cookieConfig = config.session.cookie;\n  const {\n    genid: generateId,\n    absoluteDuration,\n    rolling: rollingEnabled,\n    rollingDuration,\n  } = config.session;\n\n  const { transient: emptyTransient, ...emptyCookieOptions } = cookieConfig;\n  emptyCookieOptions.expires = emptyTransient ? 0 : new Date();\n  emptyCookieOptions.path = emptyCookieOptions.path || '/';\n\n  const emptyCookie = cookie.serialize(\n    `${sessionName}.0`,\n    '',\n    emptyCookieOptions\n  );\n  const cookieChunkSize = MAX_COOKIE_SIZE - emptyCookie.length;\n\n  let keystore = new JWKS.KeyStore();\n\n  secrets.forEach((secretString, i) => {\n    const key = JWK.asKey(deriveKey(secretString));\n    if (i === 0) {\n      current = key;\n    }\n    keystore.add(key);\n  });\n\n  if (keystore.size === 1) {\n    keystore = current;\n  }\n\n  function encrypt(payload, headers) {\n    return JWE.encrypt(payload, current, { alg, enc, ...headers });\n  }\n\n  function decrypt(jwe) {\n    return JWE.decrypt(jwe, keystore, {\n      complete: true,\n      contentEncryptionAlgorithms: [enc],\n      keyManagementAlgorithms: [alg],\n    });\n  }\n\n  function calculateExp(iat, uat) {\n    if (!rollingEnabled) {\n      return iat + absoluteDuration;\n    }\n\n    return Math.min(\n      ...[uat + rollingDuration, iat + absoluteDuration].filter(Boolean)\n    );\n  }\n\n  function setCookie(\n    req,\n    res,\n    { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n  ) {\n    const cookies = req[COOKIES];\n    const { transient: cookieTransient, ...cookieOptions } = cookieConfig;\n    cookieOptions.expires = cookieTransient ? 0 : new Date(exp * 1000);\n\n    // session was deleted or is empty, this matches all session cookies (chunked or unchunked)\n    // and clears them, essentially cleaning up what we've set in the past that is now trash\n    if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n      debug(\n        'session was deleted or is empty, clearing all matching session cookies'\n      );\n      for (const cookieName of Object.keys(cookies)) {\n        if (cookieName.match(`^${sessionName}(?:\\\\.\\\\d)?$`)) {\n          res.clearCookie(cookieName, {\n            domain: cookieOptions.domain,\n            path: cookieOptions.path,\n          });\n        }\n      }\n    } else {\n      debug(\n        'found session, creating signed session cookie(s) with name %o(.i)',\n        sessionName\n      );\n\n      const value = encrypt(JSON.stringify(req[sessionName]), {\n        iat,\n        uat,\n        exp,\n      });\n\n      const chunkCount = Math.ceil(value.length / cookieChunkSize);\n\n      if (chunkCount > 1) {\n        debug('cookie size greater than %d, chunking', cookieChunkSize);\n        for (let i = 0; i < chunkCount; i++) {\n          const chunkValue = value.slice(\n            i * cookieChunkSize,\n            (i + 1) * cookieChunkSize\n          );\n\n          const chunkCookieName = `${sessionName}.${i}`;\n          res.cookie(chunkCookieName, chunkValue, cookieOptions);\n        }\n        if (sessionName in cookies) {\n          debug('replacing non chunked cookie with chunked cookies');\n          res.clearCookie(sessionName, {\n            domain: cookieConfig.domain,\n            path: cookieConfig.path,\n          });\n        }\n      } else {\n        res.cookie(sessionName, value, cookieOptions);\n        for (const cookieName of Object.keys(cookies)) {\n          debug('replacing chunked cookies with non chunked cookies');\n          if (cookieName.match(`^${sessionName}\\\\.\\\\d$`)) {\n            res.clearCookie(cookieName, {\n              domain: cookieConfig.domain,\n              path: cookieConfig.path,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  class CookieStore {\n    async get(idOrVal) {\n      const { protected: header, cleartext } = decrypt(idOrVal);\n      return {\n        header,\n        data: JSON.parse(cleartext),\n      };\n    }\n\n    setCookie(req, res, iat) {\n      setCookie(req, res, iat);\n    }\n  }\n\n  class CustomStore {\n    constructor(store) {\n      this._get = promisify(store.get).bind(store);\n      this._set = promisify(store.set).bind(store);\n      this._destroy = promisify(store.destroy).bind(store);\n    }\n\n    async get(id) {\n      return this._get(id);\n    }\n\n    async set(\n      id,\n      req,\n      res,\n      { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n    ) {\n      const hasPrevSession = !!req[COOKIES][sessionName];\n      const replacingPrevSession = !!req[REGENERATED_SESSION_ID];\n      const hasCurrentSession = req[sessionName] && Object.keys(req[sessionName]).length;\n      if (hasPrevSession && (replacingPrevSession || !hasCurrentSession)) {\n        await this._destroy(id);\n      }\n      if (hasCurrentSession) {\n        await this._set(req[REGENERATED_SESSION_ID] || id, {\n          header: { iat, uat, exp },\n          data: req[sessionName],\n        });\n      }\n    }\n\n    setCookie(\n      id,\n      req,\n      res,\n      { uat = epoch(), iat = uat, exp = calculateExp(iat, uat) }\n    ) {\n      if (!req[sessionName] || !Object.keys(req[sessionName]).length) {\n        if (req[COOKIES][sessionName]) {\n          res.clearCookie(sessionName, {\n            domain: cookieConfig.domain,\n            path: cookieConfig.path,\n          });\n        }\n      } else {\n        const cookieOptions = {\n          ...cookieConfig,\n          expires: cookieConfig.transient ? 0 : new Date(exp * 1000),\n        };\n        delete cookieOptions.transient;\n        res.cookie(sessionName, id, cookieOptions);\n      }\n    }\n  }\n\n  const isCustomStore = !!config.session.store;\n  const store = isCustomStore\n    ? new CustomStore(config.session.store)\n    : new CookieStore();\n\n  return async (req, res, next) => {\n    if (req.hasOwnProperty(sessionName)) {\n      debug(\n        'request object (req) already has %o property, this is indicative of a middleware setup problem',\n        sessionName\n      );\n      return next(\n        new Error(\n          `req[${sessionName}] is already set, did you run this middleware twice?`\n        )\n      );\n    }\n\n    req[COOKIES] = cookie.parse(req.get('cookie') || '');\n\n    let iat;\n    let uat;\n    let exp;\n    let existingSessionValue;\n\n    try {\n      if (req[COOKIES].hasOwnProperty(sessionName)) {\n        // get JWE from unchunked session cookie\n        debug('reading session from %s cookie', sessionName);\n        existingSessionValue = req[COOKIES][sessionName];\n      } else if (req[COOKIES].hasOwnProperty(`${sessionName}.0`)) {\n        // get JWE from chunked session cookie\n        // iterate all cookie names\n        // match and filter for the ones that match sessionName.<number>\n        // sort by chunk index\n        // concat\n        existingSessionValue = Object.entries(req[COOKIES])\n          .map(([cookie, value]) => {\n            const match = cookie.match(`^${sessionName}\\\\.(\\\\d+)$`);\n            if (match) {\n              return [match[1], value];\n            }\n          })\n          .filter(Boolean)\n          .sort(([a], [b]) => {\n            return parseInt(a, 10) - parseInt(b, 10);\n          })\n          .map(([i, chunk]) => {\n            debug('reading session chunk from %s.%d cookie', sessionName, i);\n            return chunk;\n          })\n          .join('');\n      }\n      if (existingSessionValue) {\n        const { header, data } = await store.get(existingSessionValue);\n        ({ iat, uat, exp } = header);\n\n        // check that the existing session isn't expired based on options when it was established\n        assert(\n          exp > epoch(),\n          'it is expired based on options when it was established'\n        );\n\n        // check that the existing session isn't expired based on current rollingDuration rules\n        if (rollingDuration) {\n          assert(\n            uat + rollingDuration > epoch(),\n            'it is expired based on current rollingDuration rules'\n          );\n        }\n\n        // check that the existing session isn't expired based on current absoluteDuration rules\n        if (absoluteDuration) {\n          assert(\n            iat + absoluteDuration > epoch(),\n            'it is expired based on current absoluteDuration rules'\n          );\n        }\n\n        attachSessionObject(req, sessionName, data);\n      }\n    } catch (err) {\n      if (err instanceof AssertionError) {\n        debug('existing session was rejected because', err.message);\n      } else if (err instanceof JOSEError) {\n        debug(\n          'existing session was rejected because it could not be decrypted',\n          err\n        );\n      } else {\n        debug('unexpected error handling session', err);\n      }\n    }\n\n    if (!req.hasOwnProperty(sessionName) || !req[sessionName]) {\n      attachSessionObject(req, sessionName, {});\n    }\n\n    if (isCustomStore) {\n      const id = existingSessionValue || generateId(req);\n\n      onHeaders(res, () =>\n        store.setCookie(req[REGENERATED_SESSION_ID] || id, req, res, { iat })\n      );\n\n      const { end: origEnd } = res;\n      res.end = async function resEnd(...args) {\n        try {\n          await store.set(id, req, res, {\n            iat,\n          });\n          origEnd.call(res, ...args);\n        } catch (e) {\n          // need to restore the original `end` so that it gets\n          // called after `next(e)` calls the express error handling mw\n          res.end = origEnd;\n          process.nextTick(() => next(e));\n        }\n      };\n    } else {\n      onHeaders(res, () =>\n        store.setCookie(req, res, { iat })\n      );\n    }\n\n    return next();\n  };\n};\n\nmodule.exports.regenerateSessionStoreId = regenerateSessionStoreId;\nmodule.exports.replaceSession = replaceSession;\n", "const express = require('express');\nconst cb = require('cb');\nconst createError = require('http-errors');\n\nconst debug = require('../lib/debug')('auth');\nconst { get: getConfig } = require('../lib/config');\nconst { get: getClient } = require('../lib/client');\nconst { requiresAuth } = require('./requiresAuth');\nconst attemptSilentLogin = require('./attemptSilentLogin');\nconst TransientCookieHandler = require('../lib/transientHandler');\nconst { RequestContext, ResponseContext } = require('../lib/context');\nconst appSession = require('../lib/appSession');\nconst { regenerateSessionStoreId, replaceSession } = appSession;\nconst { decodeState } = require('../lib/hooks/getLoginState');\n\nconst enforceLeadingSlash = (path) => {\n  return path.split('')[0] === '/' ? path : '/' + path;\n};\n\n/**\n * Returns a router with two routes /login and /callback\n *\n * @param {Object} [params] The parameters object; see index.d.ts for types and descriptions.\n *\n * @returns {express.Router} the router\n */\nconst auth = function (params) {\n  const config = getConfig(params);\n  debug('configuration object processed, resulting configuration: %O', config);\n  const router = new express.Router();\n  const transient = new TransientCookieHandler(config);\n\n  router.use(appSession(config));\n\n  // Express context and OpenID Issuer discovery.\n  router.use(async (req, res, next) => {\n    req.oidc = new RequestContext(config, req, res, next);\n    res.oidc = new ResponseContext(config, req, res, next, transient);\n    next();\n  });\n\n  // Login route, configurable with routes.login\n  if (config.routes.login) {\n    const path = enforceLeadingSlash(config.routes.login);\n    debug('adding GET %s route', path);\n    router.get(path, express.urlencoded({ extended: false }), (req, res) =>\n      res.oidc.login({ returnTo: config.baseURL })\n    );\n  } else {\n    debug('login handling route not applied');\n  }\n\n  // Logout route, configurable with routes.logout\n  if (config.routes.logout) {\n    const path = enforceLeadingSlash(config.routes.logout);\n    debug('adding GET %s route', path);\n    router.get(path, (req, res) => res.oidc.logout());\n  } else {\n    debug('logout handling route not applied');\n  }\n\n  // Callback route, configured with routes.callback.\n  {\n    let client;\n    const path = enforceLeadingSlash(config.routes.callback);\n    const callbackStack = [\n      (req, res, next) => {\n        debug('%s %s called', req.method, path);\n        next();\n      },\n      async (req, res, next) => {\n        next = cb(next).once();\n\n        client =\n          client ||\n          (await getClient(config).catch((err) => {\n            next(err);\n          }));\n\n        if (!client) {\n          return;\n        }\n\n        try {\n          const redirectUri = res.oidc.getRedirectUri();\n\n          let tokenSet;\n\n          try {\n            const callbackParams = client.callbackParams(req);\n            const authVerification = transient.getOnce(\n              'auth_verification',\n              req,\n              res\n            );\n\n            const { max_age, code_verifier, nonce, state } = authVerification\n              ? JSON.parse(authVerification)\n              : {};\n\n            req.openidState = decodeState(state);\n            const checks = {\n              max_age,\n              code_verifier,\n              nonce,\n              state,\n            };\n\n            let extras;\n            if (config.tokenEndpointParams) {\n              extras = { exchangeBody: config.tokenEndpointParams };\n            }\n\n            tokenSet = await client.callback(\n              redirectUri,\n              callbackParams,\n              checks,\n              extras\n            );\n          } catch (err) {\n            throw createError.BadRequest(err.message);\n          }\n\n          let session = Object.assign({}, tokenSet); // Remove non-enumerable methods from the TokenSet\n\n          if (config.afterCallback) {\n            session = await config.afterCallback(\n              req,\n              res,\n              session,\n              req.openidState\n            );\n          }\n\n          if (req.oidc.isAuthenticated()) {\n            if (req.oidc.user.sub === tokenSet.claims().sub) {\n              // If it's the same user logging in again, just update the existing session.\n              Object.assign(req[config.session.name], session);\n            } else {\n              // If it's a different user, replace the session to remove any custom user\n              // properties on the session\n              replaceSession(req, session, config);\n              // And regenerate the session id so the previous user wont know the new user's session id\n              regenerateSessionStoreId(req, config);\n            }\n          } else {\n            // If a new user is replacing an anonymous session, update the existing session to keep\n            // any anonymous session state (eg. checkout basket)\n            Object.assign(req[config.session.name], session);\n            // But update the session store id so a previous anonymous user wont know the new user's session id\n            regenerateSessionStoreId(req, config);\n          }\n          attemptSilentLogin.resumeSilentLogin(req, res);\n\n          next();\n        } catch (err) {\n          // Swallow errors if this is a silentLogin\n          if (req.openidState && req.openidState.attemptingSilentLogin) {\n            next();\n          } else {\n            next(err);\n          }\n        }\n      },\n      (req, res) => res.redirect(req.openidState.returnTo || config.baseURL),\n    ];\n\n    debug('adding GET %s route', path);\n    router.get(path, ...callbackStack);\n    debug('adding POST %s route', path);\n    router.post(\n      path,\n      express.urlencoded({ extended: false }),\n      ...callbackStack\n    );\n  }\n\n  if (config.authRequired) {\n    debug(\n      'authentication is required for all routes this middleware is applied to'\n    );\n    router.use(requiresAuth());\n  } else {\n    debug(\n      'authentication is not required for any of the routes this middleware is applied to ' +\n        'see and apply `requiresAuth` middlewares to your protected resources'\n    );\n  }\n  if (config.attemptSilentLogin) {\n    debug(\"silent login will be attempted on end-user's initial HTML request\");\n    router.use(attemptSilentLogin());\n  }\n\n  return router;\n};\n\n/**\n * Used for instantiating a custom session store. eg\n *\n * ```js\n * const { auth } = require('express-openid-connect');\n * const MemoryStore = require('memorystore')(auth);\n * ```\n *\n * @constructor\n */\nauth.Store = function () {};\n\nmodule.exports = auth;\n", "const { promisify } = require('util');\nconst express = require('express');\nconst { assert } = require('chai').use(require('chai-as-promised'));\nconst request = require('request-promise-native').defaults({\n  simple: false,\n  resolveWithFullResponse: true,\n});\n\nconst appSession = require('../lib/appSession');\nconst { get: getConfig } = require('../lib/config');\nconst { create: createServer } = require('./fixture/server');\nconst redis = require('redis-mock');\nconst RedisStore = require('connect-redis')({ Store: class Store {} });\n\nconst defaultConfig = {\n  clientID: '__test_client_id__',\n  clientSecret: '__test_client_secret__',\n  issuerBaseURL: 'https://op.example.com',\n  baseURL: 'http://example.org',\n  secret: '__test_secret__',\n  errorOnRequiredAuth: true,\n};\n\nconst sessionData = () => {\n  const epoch = () => (Date.now() / 1000) | 0;\n  const epochNow = epoch();\n  const weekInSeconds = 7 * 24 * 60 * 60;\n\n  return JSON.stringify({\n    header: {\n      uat: epochNow,\n      iat: epochNow,\n      exp: epochNow + weekInSeconds,\n    },\n    data: { sub: '__test_sub__' },\n  });\n};\n\nconst login = async (claims) => {\n  const jar = request.jar();\n  await request.post('/session', {\n    baseUrl,\n    jar,\n    json: claims,\n  });\n  return jar;\n};\n\nconst baseUrl = 'http://localhost:3000';\n\ndescribe('appSession custom store', () => {\n  let server;\n  let redisClient;\n\n  const setup = async (config) => {\n    redisClient = redis.createClient();\n    const store = new RedisStore({ client: redisClient, prefix: '' });\n    redisClient.asyncSet = promisify(redisClient.set).bind(redisClient);\n    redisClient.asyncGet = promisify(redisClient.get).bind(redisClient);\n    redisClient.asyncDbsize = promisify(redisClient.dbsize).bind(redisClient);\n\n    const conf = getConfig({\n      ...defaultConfig,\n      ...config,\n      session: { ...(config && config.session), store },\n    });\n\n    server = await createServer(appSession(conf));\n  };\n\n  afterEach(async () => {\n    if (server) {\n      await new Promise((resolve) => server.close(resolve));\n    }\n    if (redisClient) {\n      await new Promise((resolve) => redisClient.flushall(resolve));\n      await new Promise((resolve) => redisClient.quit(resolve));\n    }\n  });\n\n  it('should not create a session when there are no cookies', async () => {\n    await setup();\n    const res = await request.get('/session', { baseUrl, json: true });\n    assert.isEmpty(res.body);\n  });\n\n  it('should not error for non existent sessions', async () => {\n    await setup();\n    const res = await request.get('/session', {\n      baseUrl,\n      json: true,\n      headers: {\n        cookie: 'appSession=__invalid_identity__',\n      },\n    });\n    assert.equal(res.statusCode, 200);\n    assert.isEmpty(res.body);\n  });\n\n  it('should get an existing session', async () => {\n    await setup();\n    await redisClient.asyncSet('foo', sessionData());\n    const jar = request.jar();\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n      headers: {\n        cookie: `appSession=foo`,\n      },\n    });\n    assert.equal(res.statusCode, 200);\n    assert.deepEqual(res.body, { sub: '__test_sub__' });\n    const [cookie] = jar.getCookies(baseUrl);\n    assert.deepInclude(cookie, {\n      key: 'appSession',\n      value: 'foo',\n    });\n  });\n\n  it('should not populate the store when there is no session', async () => {\n    await setup();\n    await request.get('/session', {\n      baseUrl,\n      json: true,\n    });\n    assert.equal(await redisClient.asyncDbsize(), 0);\n  });\n\n  it('should get a new session', async () => {\n    await setup();\n    const jar = await login({ sub: '__foo_user__' });\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n    });\n    assert.equal(res.statusCode, 200);\n    assert.deepEqual(res.body, { sub: '__foo_user__' });\n    assert.equal(await redisClient.asyncDbsize(), 1);\n  });\n\n  it('should destroy an existing session', async () => {\n    await setup({ idpLogout: false });\n    await redisClient.asyncSet('foo', sessionData());\n    const jar = request.jar();\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n      headers: {\n        cookie: `appSession=foo`,\n      },\n    });\n    assert.deepEqual(res.body, { sub: '__test_sub__' });\n    await request.post('/session', {\n      baseUrl,\n      jar,\n      json: {},\n    });\n    const loggedOutRes = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n    });\n    assert.isEmpty(loggedOutRes.body);\n    assert.isEmpty(jar.getCookies(baseUrl));\n    assert.equal(await redisClient.asyncDbsize(), 0);\n  });\n\n  it('uses custom session id generator when provided', async () => {\n    const immId = 'apple';\n    await setup({\n      session: { genid: () => immId },\n    });\n    const jar = await login({\n      sub: '__foo_user__',\n      role: 'test',\n      userid: immId,\n    });\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n    });\n    assert.equal(res.statusCode, 200);\n    const storedSessionJson = await redisClient.asyncGet(immId);\n    const { data: sessionValues } = JSON.parse(storedSessionJson);\n    assert.deepEqual(sessionValues, {\n      sub: '__foo_user__',\n      role: 'test',\n      userid: immId,\n    });\n    assert.equal(await redisClient.asyncDbsize(), 1);\n  });\n\n  it('should handle storage errors', async () => {\n    const store = {\n      get(id, cb) {\n        process.nextTick(() => cb(null, JSON.parse(sessionData())));\n      },\n      async set(id, val, cb) {\n        process.nextTick(() => cb(new Error('storage error')));\n      },\n      async destroy(id, cb) {\n        process.nextTick(() => cb());\n      },\n    };\n\n    const conf = getConfig({\n      ...defaultConfig,\n      session: { store },\n    });\n\n    server = await createServer(appSession(conf));\n\n    const jar = request.jar();\n    const res = await request.get('/session', {\n      baseUrl,\n      jar,\n      json: true,\n      headers: {\n        cookie: `appSession=foo`,\n      },\n    });\n    assert.equal(res.statusCode, 500);\n    assert.equal(res.body.err.message, 'storage error');\n  });\n\n  it('should not throw if another mw writes the header', async () => {\n    const app = express();\n\n    redisClient = redis.createClient();\n    const store = new RedisStore({ client: redisClient, prefix: '' });\n    await promisify(redisClient.set).bind(redisClient)('foo', sessionData());\n\n    app.use(\n      appSession(\n        getConfig({\n          ...defaultConfig,\n          session: { store },\n        })\n      )\n    );\n\n    app.get('/', (req, res, next) => {\n      res.json(req.appSession);\n      next();\n    });\n\n    app.use((req, res, next) => {\n      if (!res.headersSent) {\n        res.writeHead(200);\n      }\n      next();\n    });\n\n    server = await new Promise((resolve) => {\n      const server = app.listen(3000, () => resolve(server));\n    });\n\n    await assert.becomes(\n      request.get('/', {\n        baseUrl,\n        json: true,\n        headers: {\n          cookie: `appSession=foo`,\n        },\n        resolveWithFullResponse: false,\n      }),\n      { sub: '__test_sub__' }\n    );\n  });\n});\n", "const assert = require('chai').assert;\nconst sinon = require('sinon');\nconst jose = require('jose');\nconst request = require('request-promise-native').defaults({\n  simple: false,\n  resolveWithFullResponse: true,\n});\n\nconst TransientCookieHandler = require('../lib/transientHandler');\nconst { encodeState } = require('../lib/hooks/getLoginState');\nconst { auth } = require('..');\nconst { create: createServer } = require('./fixture/server');\nconst { makeIdToken } = require('./fixture/cert');\nconst clientID = '__test_client_id__';\nconst expectedDefaultState = encodeState({ returnTo: 'https://example.org' });\nconst nock = require('nock');\nconst MemoryStore = require('memorystore')(auth);\n\nconst baseUrl = 'http://localhost:3000';\nconst defaultConfig = {\n  secret: '__test_session_secret__',\n  clientID: clientID,\n  baseURL: 'http://example.org',\n  issuerBaseURL: 'https://op.example.com',\n  authRequired: false,\n};\nlet server;\n\nconst generateCookies = (values) => ({\n  auth_verification: JSON.stringify(values),\n});\n\nconst setup = async (params) => {\n  const authOpts = Object.assign({}, defaultConfig, params.authOpts || {});\n  const router = params.router || auth(authOpts);\n  const transient = new TransientCookieHandler(authOpts);\n\n  const jar = params.jar || request.jar();\n  server = await createServer(router);\n  let tokenReqHeader;\n  let tokenReqBody;\n\n  Object.keys(params.cookies).forEach(function (cookieName) {\n    let value;\n\n    transient.store(\n      cookieName,\n      {},\n      {\n        cookie(key, ...args) {\n          if (key === cookieName) {\n            value = args[0];\n          }\n        },\n      },\n      { value: params.cookies[cookieName] }\n    );\n\n    jar.setCookie(\n      `${cookieName}=${value}; Max-Age=3600; Path=/; HttpOnly;`,\n      baseUrl + '/callback'\n    );\n  });\n\n  const {\n    interceptors: [interceptor],\n  } = nock('https://op.example.com', { allowUnmocked: true })\n    .post('/oauth/token')\n    .reply(200, function (uri, requestBody) {\n      tokenReqHeader = this.req.headers;\n      tokenReqBody = requestBody;\n      return {\n        access_token: '__test_access_token__',\n        refresh_token: '__test_refresh_token__',\n        id_token: params.body.id_token,\n        token_type: 'Bearer',\n        expires_in: 86400,\n      };\n    });\n\n  let existingSessionCookie;\n  if (params.existingSession) {\n    await request.post('/session', {\n      baseUrl,\n      jar,\n      json: params.existingSession,\n    });\n    const cookies = jar.getCookies(baseUrl);\n    existingSessionCookie = cookies.find(({ key }) => key === 'appSession');\n  }\n\n  const response = await request.post('/callback', {\n    baseUrl,\n    jar,\n    json: params.body,\n  });\n  const currentUser = await request\n    .get('/user', { baseUrl, jar, json: true })\n    .then((r) => r.body);\n  const currentSession = await request\n    .get('/session', { baseUrl, jar, json: true })\n    .then((r) => r.body);\n  const tokens = await request\n    .get('/tokens', { baseUrl, jar, json: true })\n    .then((r) => r.body);\n\n  nock.removeInterceptor(interceptor);\n\n  return {\n    baseUrl,\n    jar,\n    response,\n    currentUser,\n    currentSession,\n    tokenReqHeader,\n    tokenReqBody,\n    tokens,\n    existingSessionCookie,\n  };\n};\n\n// For the purpose of this test the fake SERVER returns the error message in the body directly\n// production application should have an error middleware.\n// http://expressjs.com/en/guide/error-handling.html\n\ndescribe('callback response_mode: form_post', () => {\n  afterEach(() => {\n    if (server) {\n      server.close();\n    }\n  });\n\n  it('should error when the body is empty', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: true,\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(err.message, 'state missing from the response');\n  });\n\n  it('should error when the state is missing', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: {},\n      body: {\n        state: '__test_state__',\n        id_token: '__invalid_token__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(err.message, 'checks.state argument is missing');\n  });\n\n  it(\"should error when state doesn't match\", async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__valid_state__',\n      }),\n      body: {\n        state: '__invalid_state__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /state mismatch/i);\n  });\n\n  it(\"should error when id_token can't be parsed\", async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: '__invalid_token__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(\n      err.message,\n      'failed to decode JWT (JWTMalformed: JWTs must have three components)'\n    );\n  });\n\n  it('should error when id_token has invalid alg', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: jose.JWT.sign({ sub: '__test_sub__' }, 'secret', {\n          algorithm: 'HS256',\n        }),\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /unexpected JWT alg received/i);\n  });\n\n  it('should error when id_token is missing issuer', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        nonce: '__test_nonce__',\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: makeIdToken({ iss: undefined }),\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /missing required JWT property iss/i);\n  });\n\n  it('should error when nonce is missing from cookies', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      cookies: generateCookies({\n        state: '__test_state__',\n      }),\n      body: {\n        state: '__test_state__',\n        id_token: makeIdToken(),\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.match(err.message, /nonce mismatch/i);\n  });\n\n  it('should error when legacy samesite fallback is off', async () => {\n    const {\n      response: {\n        statusCode,\n        body: { err },\n      },\n    } = await setup({\n      authOpts: {\n        // Do not check the fallback cookie value.\n        legacySameSiteCookie: false,\n      },\n      cookies: {\n        _auth_verification: JSON.stringify({ state: '__test_state__' }),\n      },\n      body: {\n        state: '__test_state__',\n        id_token: '__invalid_token__',\n      },\n    });\n    assert.equal(statusCode, 400);\n    assert.equal(err.message, 'checks.state argument is missing');\n  });\n\n  it('should use legacy samesite fallback', async () => {\n    const { currentUser } = await setup({\n      authOpts: {\n        identityClaimFilter: [],\n      },\n      cookies: {\n        _auth_verification: JSON.stringify({\n          state: expectedDefaultState,\n          nonce: '__test_nonce__',\n        }),\n      },\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken(),\n      },\n    });\n\n    assert.exists(currentUser);\n  });\n\n  it('should not strip claims when using custom claim filtering', async () => {\n    const { currentUser } = await setup({\n      authOpts: {\n        identityClaimFilter: [],\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken(),\n      },\n    });\n    assert.equal(currentUser.iss, 'https://op.example.com/');\n    assert.equal(currentUser.aud, clientID);\n    assert.equal(currentUser.nonce, '__test_nonce__');\n    assert.exists(currentUser.iat);\n    assert.exists(currentUser.exp);\n  });\n\n  it('should expose the id token when id_token is valid', async () => {\n    const idToken = makeIdToken();\n    const {\n      response: { statusCode, headers },\n      currentUser,\n      tokens,\n    } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n      },\n    });\n    assert.equal(statusCode, 302);\n    assert.equal(headers.location, 'https://example.org');\n    assert.ok(currentUser);\n    assert.equal(currentUser.sub, '__test_sub__');\n    assert.equal(currentUser.nickname, '__test_nickname__');\n    assert.notExists(currentUser.iat);\n    assert.notExists(currentUser.iss);\n    assert.notExists(currentUser.aud);\n    assert.notExists(currentUser.exp);\n    assert.notExists(currentUser.nonce);\n    assert.equal(tokens.isAuthenticated, true);\n    assert.equal(tokens.idToken, idToken);\n    assert.isUndefined(tokens.refreshToken);\n    assert.isUndefined(tokens.accessToken);\n    assert.include(tokens.idTokenClaims, {\n      sub: '__test_sub__',\n    });\n  });\n\n  it(\"should expose all tokens when id_token is valid and response_type is 'code id_token'\", async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const { tokens } = await setup({\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    assert.equal(tokens.isAuthenticated, true);\n    assert.equal(tokens.idToken, idToken);\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.include(tokens.accessToken, {\n      access_token: '__test_access_token__',\n      token_type: 'Bearer',\n    });\n    assert.include(tokens.idTokenClaims, {\n      sub: '__test_sub__',\n    });\n  });\n\n  it('should handle access token expiry', async () => {\n    const clock = sinon.useFakeTimers({ toFake: ['Date'] });\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n    const hrSecs = 60 * 60;\n    const hrMs = hrSecs * 1000;\n\n    const { tokens, jar } = await setup({\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n    assert.equal(tokens.accessToken.expires_in, 24 * hrSecs);\n    clock.tick(4 * hrMs);\n    const tokens2 = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    assert.equal(tokens2.accessToken.expires_in, 20 * hrSecs);\n    assert.isFalse(tokens2.accessTokenExpired);\n    clock.tick(21 * hrMs);\n    const tokens3 = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    assert.isTrue(tokens3.accessTokenExpired);\n    clock.restore();\n  });\n\n  it('should refresh an access token', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access',\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/refresh', async (req, res) => {\n      const accessToken = await req.oidc.accessToken.refresh();\n      res.json({\n        accessToken,\n        refreshToken: req.oidc.refreshToken,\n      });\n    });\n\n    const { tokens, jar } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const reply = sinon.spy(() => ({\n      access_token: '__new_access_token__',\n      refresh_token: '__new_refresh_token__',\n      id_token: tokens.idToken,\n      token_type: 'Bearer',\n      expires_in: 86400,\n    }));\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .post('/oauth/token')\n      .reply(200, reply);\n\n    const newTokens = await request\n      .get('/refresh', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    nock.removeInterceptor(interceptor);\n\n    sinon.assert.calledWith(\n      reply,\n      '/oauth/token',\n      'grant_type=refresh_token&refresh_token=__test_refresh_token__'\n    );\n\n    assert.equal(tokens.accessToken.access_token, '__test_access_token__');\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.equal(newTokens.accessToken.access_token, '__new_access_token__');\n    assert.equal(newTokens.refreshToken, '__new_refresh_token__');\n\n    const newerTokens = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n\n    assert.equal(\n      newerTokens.accessToken.access_token,\n      '__new_access_token__',\n      'the new access token should be persisted in the session'\n    );\n  });\n\n  it('should refresh an access token and keep original refresh token', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access',\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/refresh', async (req, res) => {\n      const accessToken = await req.oidc.accessToken.refresh();\n      res.json({\n        accessToken,\n        refreshToken: req.oidc.refreshToken,\n      });\n    });\n\n    const { tokens, jar } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const reply = sinon.spy(() => ({\n      access_token: '__new_access_token__',\n      id_token: tokens.id_token,\n      token_type: 'Bearer',\n      expires_in: 86400,\n    }));\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .post('/oauth/token')\n      .reply(200, reply);\n\n    const newTokens = await request\n      .get('/refresh', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    nock.removeInterceptor(interceptor);\n\n    sinon.assert.calledWith(\n      reply,\n      '/oauth/token',\n      'grant_type=refresh_token&refresh_token=__test_refresh_token__'\n    );\n\n    assert.equal(tokens.accessToken.access_token, '__test_access_token__');\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.equal(newTokens.accessToken.access_token, '__new_access_token__');\n    assert.equal(newTokens.refreshToken, '__test_refresh_token__');\n  });\n\n  it('should refresh an access token and pass tokenEndpointParams and refresh argument params to the request', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email read:reports offline_access',\n      },\n      tokenEndpointParams: {\n        longeLiveToken: true,\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/refresh', async (req, res) => {\n      const accessToken = await req.oidc.accessToken.refresh({\n        tokenEndpointParams: { force: true },\n      });\n      res.json({\n        accessToken,\n        refreshToken: req.oidc.refreshToken,\n      });\n    });\n\n    const { tokens, jar, tokenReqBody } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const reply = sinon.spy(() => ({\n      access_token: '__new_access_token__',\n      refresh_token: '__new_refresh_token__',\n      id_token: tokens.idToken,\n      token_type: 'Bearer',\n      expires_in: 86400,\n    }));\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .post('/oauth/token')\n      .reply(200, reply);\n\n    const newTokens = await request\n      .get('/refresh', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n    nock.removeInterceptor(interceptor);\n\n    sinon.assert.calledWith(\n      reply,\n      '/oauth/token',\n      'longeLiveToken=true&force=true&grant_type=refresh_token&refresh_token=__test_refresh_token__'\n    );\n\n    assert.equal(tokens.accessToken.access_token, '__test_access_token__');\n    assert.equal(tokens.refreshToken, '__test_refresh_token__');\n    assert.equal(newTokens.accessToken.access_token, '__new_access_token__');\n    assert.equal(newTokens.refreshToken, '__new_refresh_token__');\n    assert.match(tokenReqBody, /longeLiveToken=true/);\n\n    const newerTokens = await request\n      .get('/tokens', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n\n    assert.equal(\n      newerTokens.accessToken.access_token,\n      '__new_access_token__',\n      'the new access token should be persisted in the session'\n    );\n  });\n\n  it('should fetch userinfo', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const authOpts = {\n      ...defaultConfig,\n      clientSecret: '__test_client_secret__',\n      authorizationParams: {\n        response_type: 'code id_token',\n        audience: 'https://api.example.com/',\n        scope: 'openid profile email',\n      },\n    };\n    const router = auth(authOpts);\n    router.get('/user-info', async (req, res) => {\n      res.json(await req.oidc.fetchUserInfo());\n    });\n\n    const { jar } = await setup({\n      router,\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const {\n      interceptors: [interceptor],\n    } = nock('https://op.example.com', { allowUnmocked: true })\n      .get('/userinfo')\n      .reply(200, () => ({\n        userInfo: true,\n        sub: '__test_sub__',\n      }));\n\n    const userInfo = await request\n      .get('/user-info', { baseUrl, jar, json: true })\n      .then((r) => r.body);\n\n    nock.removeInterceptor(interceptor);\n\n    assert.deepEqual(userInfo, { userInfo: true, sub: '__test_sub__' });\n  });\n\n  it('should use basic auth on token endpoint when using code flow', async () => {\n    const idToken = makeIdToken({\n      c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n    });\n\n    const { tokenReqBody, tokenReqHeader } = await setup({\n      authOpts: {\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email read:reports offline_access',\n        },\n      },\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n        code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n      },\n    });\n\n    const credentials = Buffer.from(\n      tokenReqHeader.authorization.replace('Basic ', ''),\n      'base64'\n    );\n    assert.equal(credentials, '__test_client_id__:__test_client_secret__');\n    assert.match(\n      tokenReqBody,\n      /code=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y/\n    );\n  });\n\n  it('should resume silent logins when user successfully logs in', async () => {\n    const idToken = makeIdToken();\n    const jar = request.jar();\n    jar.setCookie('skipSilentLogin=true', baseUrl);\n    await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n        skipSilentLogin: '1',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: idToken,\n      },\n      jar,\n    });\n    const cookies = jar.getCookies(baseUrl);\n    assert.notOk(cookies.find(({ key }) => key === 'skipSilentLogin'));\n  });\n\n  context('when afterCallack is configured', async () => {\n    it('should allow modification of the session', async () => {\n      const idToken = makeIdToken({\n        c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n      });\n\n      const authOpts = {\n        ...defaultConfig,\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email',\n        },\n        afterCallback: async (req, res, session) => {\n          const userInfo = await req.oidc.fetchUserInfo();\n          return { ...session, ...userInfo };\n        },\n      };\n\n      // userinfo endpoint will be returned to req.oidc.fetchUserInfo\n      const {\n        interceptors: [interceptor],\n      } = nock('https://op.example.com', { allowUnmocked: true })\n        .get('/userinfo')\n        .reply(200, () => ({\n          org_id: 'auth_org_123',\n        }));\n\n      const router = auth(authOpts);\n      router.get('/session', async (req, res) => {\n        res.json({ session: req['appSession'] });\n      });\n\n      const { jar } = await setup({\n        router,\n        authOpts: {\n          clientSecret: '__test_client_secret__',\n          authorizationParams: {\n            response_type: 'code id_token',\n            audience: 'https://api.example.com/',\n            scope: 'openid profile email',\n          },\n        },\n        cookies: generateCookies({\n          state: expectedDefaultState,\n          nonce: '__test_nonce__',\n        }),\n        body: {\n          state: expectedDefaultState,\n          id_token: idToken,\n          code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n        },\n      });\n\n      nock.removeInterceptor(interceptor);\n\n      const body = await request\n        .get('/session', { baseUrl, jar, json: true })\n        .then((r) => r.body);\n\n      assert.deepEqual(body.session.org_id, 'auth_org_123');\n    });\n\n    it('should allow thrown error to fail the request', async () => {\n      const idToken = makeIdToken({\n        c_hash: '77QmUPtjPfzWtF2AnpK9RQ',\n      });\n\n      const authOpts = {\n        ...defaultConfig,\n        clientSecret: '__test_client_secret__',\n        authorizationParams: {\n          response_type: 'code id_token',\n          audience: 'https://api.example.com/',\n          scope: 'openid profile email',\n        },\n        afterCallback: async () => {\n          throw { status: 999 };\n        },\n      };\n      const {\n        response: { statusCode },\n      } = await setup({\n        router: auth(authOpts),\n        authOpts,\n        cookies: generateCookies({\n          state: expectedDefaultState,\n          nonce: '__test_nonce__',\n        }),\n        body: {\n          state: expectedDefaultState,\n          id_token: idToken,\n          code: 'jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y',\n        },\n      });\n\n      assert.equal(statusCode, 999);\n    });\n  });\n\n  it('should replace the cookie session when a new user is logging in over an existing different user', async () => {\n    const { currentSession, currentUser } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken({ sub: 'bar' }),\n      },\n      existingSession: {\n        shoppingCartId: 'bar',\n        id_token: makeIdToken({ sub: 'foo' }),\n      },\n    });\n\n    assert.equal(currentUser.sub, 'bar');\n    assert.isUndefined(currentSession.shoppingCartId);\n  });\n\n  it('should preserve the cookie session when a new user is logging in over an anonymous session', async () => {\n    const { currentSession, currentUser } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken({ sub: 'foo' }),\n      },\n      existingSession: {\n        shoppingCartId: 'bar',\n      },\n    });\n\n    assert.equal(currentUser.sub, 'foo');\n    assert.equal(currentSession.shoppingCartId, 'bar');\n  });\n\n  it('should preserve session but regenerate session id when a new user is logging in over an anonymous session', async () => {\n    const store = new MemoryStore({\n      checkPeriod: 24 * 60 * 1000,\n    });\n    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken({ sub: 'foo' }),\n      },\n      existingSession: {\n        shoppingCartId: 'bar',\n      },\n      authOpts: {\n        session: {\n          store,\n        },\n      },\n    });\n\n    const cookies = jar.getCookies(baseUrl);\n    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');\n    \n    assert.equal(currentUser.sub, 'foo');\n    assert.equal(currentSession.shoppingCartId, 'bar');\n    assert.equal(\n      store.store.length,\n      1,\n      'There should only be one session in the store'\n    );\n    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);\n  });\n\n  it('should preserve session when the same user is logging in over their existing session', async () => {\n    const store = new MemoryStore({\n      checkPeriod: 24 * 60 * 1000,\n    });\n    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken({ sub: 'foo' }),\n      },\n      existingSession: {\n        shoppingCartId: 'bar',\n        id_token: makeIdToken({ sub: 'foo' }),\n      },\n      authOpts: {\n        session: {\n          store,\n        },\n      },\n    });\n\n    const cookies = jar.getCookies(baseUrl);\n    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');\n    \n    assert.equal(currentUser.sub, 'foo');\n    assert.equal(currentSession.shoppingCartId, 'bar');\n    assert.equal(\n      store.store.length,\n      1,\n      'There should only be one session in the store'\n    );\n    assert.equal(existingSessionCookie.value, newSessionCookie.value);\n  });\n\n  it('should regenerate the session when a new user is logging in over an existing different user', async () => {\n    const store = new MemoryStore({\n      checkPeriod: 24 * 60 * 1000,\n    });\n    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({\n      cookies: generateCookies({\n        state: expectedDefaultState,\n        nonce: '__test_nonce__',\n      }),\n      body: {\n        state: expectedDefaultState,\n        id_token: makeIdToken({ sub: 'bar' }),\n      },\n      existingSession: {\n        shoppingCartId: 'bar',\n        id_token: makeIdToken({ sub: 'foo' }),\n      },\n      authOpts: {\n        session: {\n          store,\n        },\n      },\n    });\n\n    const cookies = jar.getCookies(baseUrl);\n    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');\n    \n    assert.equal(currentUser.sub, 'bar');\n    assert.isUndefined(currentSession.shoppingCartId);\n    assert.equal(\n      store.store.length,\n      1,\n      'There should only be one session in the store'\n    );\n    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);\n  });\n});\n"], "filenames": ["lib/appSession.js", "middleware/auth.js", "test/appSession.customStore.tests.js", "test/callback.tests.js"], "buggy_code_start_loc": [17, 12, 59, 16], "buggy_code_end_loc": [356, 133, 180, 889], "fixing_code_start_loc": [18, 13, 60, 17], "fixing_code_end_loc": [383, 153, 195, 1056], "type": "CWE-384", "message": "Express OpenID Connect is express JS middleware implementing sign on for Express web apps using OpenID Connect. Versions before and including `2.5.1` do not regenerate the session id and session cookie when user logs in. This behavior opens up the application to various session fixation vulnerabilities. Versions `2.5.2` contains a patch for this issue.", "other": {"cve": {"id": "CVE-2021-41246", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-09T16:15:08.383", "lastModified": "2021-12-14T00:40:06.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Express OpenID Connect is express JS middleware implementing sign on for Express web apps using OpenID Connect. Versions before and including `2.5.1` do not regenerate the session id and session cookie when user logs in. This behavior opens up the application to various session fixation vulnerabilities. Versions `2.5.2` contains a patch for this issue."}, {"lang": "es", "value": "Express OpenID Connect es un middleware JS que implementa el inicio de sesi\u00f3n para aplicaciones web Express usando OpenID Connect. Las versiones anteriores a \"2.5.1\" incluy\u00e9ndola, no regeneran el identificador y la cookie de sesi\u00f3n cuando el usuario inicia la sesi\u00f3n. Este comportamiento abre la aplicaci\u00f3n a varias vulnerabilidades de fijaci\u00f3n de sesi\u00f3n. Las versiones \"2.5.2\" contienen un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:express_openid_connect:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "AAACBB3A-45ED-42D7-97C9-7819E053581E"}]}]}], "references": [{"url": "https://github.com/auth0/express-openid-connect/commit/5ab67ff2bd84f76674066b5e129b43ab5f2f430f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/express-openid-connect/releases/tag/v2.5.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/auth0/express-openid-connect/security/advisories/GHSA-7rg2-qxmf-hhx9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/auth0/express-openid-connect/commit/5ab67ff2bd84f76674066b5e129b43ab5f2f430f"}}