{"buggy_code": ["package za.org.grassroot.integration.authentication;\n\nimport org.springframework.http.HttpHeaders;\nimport za.org.grassroot.integration.PublicCredentials;\n\nimport java.util.List;\n\n/**\n * Created by luke on 2017/05/22.\n */\npublic interface JwtService {\n\n    String USER_UID_KEY = \"USER_UID\";\n    String SYSTEM_ROLE_KEY = \"SYSTEM_ROLE_KEY\";\n    String PERMISSIONS_KEY = \"PERMISSIONS\";\n    String TYPE_KEY = \"TYPE\";\n\n    PublicCredentials getPublicCredentials();\n\n    String createJwt(CreateJwtTokenRequest request);\n\n    HttpHeaders createHeadersForLambdaCall();\n\n    /**\n     * Refresh token if old token is still valid or has expired but is still within the expiration grace period.\n     * @return new token if old token is still valid or has expired but is still within the expiration grace period.\n     * Otherwise, return <code></code>null.\n     */\n    String refreshToken(String oldToken, JwtType jwtType, Long shortExpiryMillis);\n\n    boolean isJwtTokenValid(String token);\n\n    boolean isJwtTokenExpired(String token);\n\n    String getUserIdFromJwtToken(String token);\n\n    List<String> getStandardRolesFromJwtToken(String token);\n\n    List<String> getPermissionsFromToken(String token);\n}\n", "package za.org.grassroot.integration.authentication;\n\nimport io.jsonwebtoken.*;\nimport io.jsonwebtoken.impl.TextCodec;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.core.env.Environment;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.StringUtils;\nimport za.org.grassroot.integration.PublicCredentials;\n\nimport javax.annotation.PostConstruct;\nimport java.security.PublicKey;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.*;\n\n/**\n * Created by luke on 2017/05/22.\n */\n@Service\npublic class JwtServiceImpl implements JwtService {\n\n    private static final Logger logger = LoggerFactory.getLogger(JwtServiceImpl.class);\n\n    private String keyIdentifier;\n\n    @Value(\"${grassroot.jwt.token-expiry-grace-period.inMilliseconds:1209600000}\")\n    private Long jwtTokenExpiryGracePeriodInMilliseconds;\n\n    @Value(\"${grassroot.jwt.api-key-expiry.inDays:180}\")\n    private Long jwtApiKeyExpiryDays;\n\n    private final Environment environment;\n    private final KeyPairProvider keyPairProvider;\n\n    @Autowired\n    public JwtServiceImpl(Environment environment, KeyPairProvider keyPairProvider) {\n        this.environment = environment;\n        this.keyPairProvider = keyPairProvider;\n    }\n\n    @PostConstruct\n    public void init() {\n        PublicCredentials credentials = refreshPublicCredentials();\n        logger.debug(\"Public credentials generated: {}\", credentials);\n    }\n\n    @Override\n    public PublicCredentials getPublicCredentials() {\n        return createCredentialEntity(keyIdentifier, keyPairProvider.getJWTKey().getPublic());\n    }\n\n    @Override\n    public String createJwt(CreateJwtTokenRequest request) {\n        Instant now = Instant.now();\n\n        long typeExpiryMillis = convertTypeToExpiryMillis(request.getJwtType());\n        long passedExpiryMillis = request.getShortExpiryMillis() == null ? typeExpiryMillis :\n                Math.min(typeExpiryMillis, request.getShortExpiryMillis());\n\n        Instant exp = now.plus(passedExpiryMillis, ChronoUnit.MILLIS);\n        request.getHeaderParameters().put(\"kid\", keyIdentifier);\n\n        return Jwts.builder()\n                .setHeaderParams(request.getHeaderParameters())\n                .setClaims(request.getClaims())\n                .setIssuedAt(Date.from(now))\n                .setExpiration(Date.from(exp))\n                .signWith(\n                        SignatureAlgorithm.RS256,\n                        keyPairProvider.getJWTKey().getPrivate()\n                )\n                .compact();\n    }\n\n    @Override\n    public HttpHeaders createHeadersForLambdaCall() {\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Authorization\", \"Bearer \" + createJwt(CreateJwtTokenRequest.makeSystemToken()));\n        return headers;\n    }\n\n    private long convertTypeToExpiryMillis(JwtType jwtType) {\n        switch (jwtType) {\n            case WEB_ANDROID_CLIENT:\n                return Duration.ofDays(7L).toMillis();\n            case GRASSROOT_MICROSERVICE:\n                return Duration.ofSeconds(3).toMillis(); // occasional glitches mean 3 secs is a better trade off here at present\n            case MSGING_CLIENT:\n                return Duration.ofMinutes(1).toMillis();\n            case API_CLIENT:\n                return Duration.ofDays(jwtApiKeyExpiryDays).toMillis(); // now long lived\n            default:\n                return 1L;\n        }\n    }\n\n    @Override\n    public boolean isJwtTokenValid(String token) {\n        try {\n            Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic()).parse(token);\n            return true;\n        }\n        catch (ExpiredJwtException e) {\n            logger.error(\"Token validation failed. The token is expired. Exception: {}\", e.getMessage());\n            return false;\n        }\n        catch (SignatureException e) {\n            logger.error(\"Token validation failed, wrong signature. Exception: {}\", e.getMessage());\n            return false;\n        }\n        catch (Exception e) {\n            logger.error(\"Unexpected token validation error.\", e);\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isJwtTokenExpired(String token) {\n        try {\n            Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic()).parse(token).getBody();\n            return false;\n        }\n        catch (ExpiredJwtException e) {\n            logger.error(\"The token is expired.\", e);\n            return true;\n        }\n        catch (Exception e) {\n            logger.error(\"Unexpected token validation error.\", e);\n            return false;\n        }\n    }\n\n    @Override\n    public String getUserIdFromJwtToken(String token) {\n        return extractFromToken(USER_UID_KEY, token);\n    }\n\n    @Override\n    public List<String> getPermissionsFromToken(String token) {\n        String permissionList = extractFromToken(PERMISSIONS_KEY, token);\n        return StringUtils.isEmpty(permissionList) ? new ArrayList<>() :\n                Arrays.asList(permissionList.split(\",\"));\n    }\n\n    private String extractFromToken(String key, String token) {\n        try {\n            Claims claims = Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic())\n                    .parseClaimsJws(token).getBody();\n            return claims.get(key, String.class);\n        } catch (Exception e) {\n            logger.error(\"Failed to get user id from jwt token: {}\", e.getMessage());\n            return null;\n        }\n    }\n\n    @Override\n    public List<String> getStandardRolesFromJwtToken(String token) {\n        String joinedRoles = extractClaims(token).get(SYSTEM_ROLE_KEY, String.class);\n        return StringUtils.isEmpty(joinedRoles) ? new ArrayList<>() : Arrays.asList(joinedRoles.split(\",\"));\n    }\n\n    private Claims extractClaims(String token) {\n        return Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic())\n                .parseClaimsJws(token).getBody();\n    }\n\n    @Override\n    public String refreshToken(String oldToken, JwtType jwtType, Long shortExpiryMillis) {\n        boolean isTokenStillValid = false;\n        Date expirationTime = null;\n        String newToken = null;\n        String userId = null;\n        String systemRoles = null;\n        try {\n            Jwt<Header, Claims> jwt = Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic()).parseClaimsJws(oldToken);\n            userId = jwt.getBody().get(USER_UID_KEY, String.class);\n            systemRoles = jwt.getBody().get(SYSTEM_ROLE_KEY, String.class);\n            isTokenStillValid = true;\n        }\n        catch (ExpiredJwtException e) {\n            logger.error(\"Token validation failed. The token is expired.\", e);\n            expirationTime = e.getClaims().getExpiration();\n        }\n        if (isTokenStillValid || expirationTime != null\n                && expirationTime.toInstant().plus(jwtTokenExpiryGracePeriodInMilliseconds, ChronoUnit.MILLIS).isAfter(new Date().toInstant())) {\n            CreateJwtTokenRequest cjtRequest = new CreateJwtTokenRequest(jwtType, shortExpiryMillis, userId, systemRoles);\n\n            newToken = createJwt(cjtRequest);\n        }\n\n        return newToken;\n    }\n\n    private PublicCredentials refreshPublicCredentials() {\n        keyIdentifier = environment.getProperty(\"grassroot.publickey.identifier\", UUID.randomUUID().toString());\n        logger.debug(\"created KUID for main platform: {}\", keyIdentifier);\n        return createCredentialEntity(keyIdentifier, keyPairProvider.getJWTKey().getPublic());\n    }\n\n    private PublicCredentials createCredentialEntity(String kuid, PublicKey key) {\n        return new PublicCredentials(kuid, TextCodec.BASE64.encode(key.getEncoded()));\n    }\n}\n", "package za.org.grassroot.webapp.controller.rest.authentication;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.validator.routines.EmailValidator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.env.Profiles;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.*;\nimport za.org.grassroot.core.GrassrootApplicationProfiles;\nimport za.org.grassroot.core.domain.User;\nimport za.org.grassroot.core.dto.UserDTO;\nimport za.org.grassroot.core.enums.UserInterfaceType;\nimport za.org.grassroot.core.enums.VerificationCodeType;\nimport za.org.grassroot.core.util.InvalidPhoneNumberException;\nimport za.org.grassroot.core.util.PhoneNumberUtil;\nimport za.org.grassroot.integration.authentication.CreateJwtTokenRequest;\nimport za.org.grassroot.integration.authentication.JwtService;\nimport za.org.grassroot.integration.authentication.JwtType;\nimport za.org.grassroot.services.async.AsyncUserLogger;\nimport za.org.grassroot.services.exception.InvalidOtpException;\nimport za.org.grassroot.services.exception.NoSuchUserException;\nimport za.org.grassroot.services.exception.UserExistsException;\nimport za.org.grassroot.services.exception.UsernamePasswordLoginFailedException;\nimport za.org.grassroot.services.user.PasswordTokenService;\nimport za.org.grassroot.services.user.UserManagementService;\nimport za.org.grassroot.services.user.UserRegPossibility;\nimport za.org.grassroot.webapp.controller.rest.Grassroot2RestController;\nimport za.org.grassroot.webapp.enums.RestMessage;\nimport za.org.grassroot.webapp.model.rest.AuthorizationResponseDTO;\nimport za.org.grassroot.webapp.model.rest.AuthorizedUserDTO;\nimport za.org.grassroot.webapp.model.rest.wrappers.ResponseWrapper;\nimport za.org.grassroot.webapp.util.RestUtil;\n\nimport java.util.Collections;\nimport java.util.List;\n\n@RestController @Grassroot2RestController @Slf4j\n@Api(\"/v2/api/auth\")\n@RequestMapping(\"/v2/api/auth\")\npublic class AuthenticationController {\n\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationController.class);\n\n    private static final List<UserInterfaceType> alphaInterfaces = Collections.singletonList(UserInterfaceType.ANDROID_2);\n\n    private final JwtService jwtService;\n    private final PasswordTokenService passwordTokenService;\n    private final UserManagementService userService;\n    private final AsyncUserLogger userLogger;\n    private final Environment environment;\n\n    @Autowired\n    public AuthenticationController(JwtService jwtService, PasswordTokenService passwordTokenService,\n                                    UserManagementService userService, AsyncUserLogger userLogger, Environment environment) {\n        this.jwtService = jwtService;\n        this.passwordTokenService = passwordTokenService;\n        this.userService = userService;\n        this.userLogger = userLogger;\n        this.environment = environment;\n    }\n\n    private User findExistingUser(String username) {\n        boolean isPhoneNumber = PhoneNumberUtil.testInputNumber(username);\n        if (!isPhoneNumber && !EmailValidator.getInstance().isValid(username)) {\n            logger.error(\"got a bad username, : {}\", username);\n            throw new NoSuchUserException(\"Invalid format, neither phone nor email: \" + username);\n        }\n        User user = userService.findByUsernameLoose(username);\n        if (user == null) {\n            throw new NoSuchUserException(\"No user with phone or email: \" + username);\n        }\n        return user;\n    }\n\n    @ExceptionHandler(NoSuchUserException.class)\n    public ResponseEntity noSuchUserResponse() {\n        return RestUtil.errorResponse(RestMessage.INVALID_MSISDN);\n    }\n\n    @RequestMapping(value = \"/register\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Start new user registration using username, phone number and password\", notes = \"Short lived token is returned as a string in the 'data' property\")\n    public ResponseEntity<ResponseWrapper> register(@RequestParam(\"phoneNumber\") String phoneNumber,\n                                                    @RequestParam(\"displayName\") String displayName,\n                                                    @RequestParam(\"password\") String password,\n                                                    @RequestParam(required = false) UserInterfaceType type) {\n        try {\n            if (!ifExists(phoneNumber)) {\n                phoneNumber = PhoneNumberUtil.convertPhoneNumber(phoneNumber);\n                logger.info(\"Creating a verifier for a new user with phoneNumber ={}\", phoneNumber);\n                String tokenCode = temporaryTokenSend(\n                        userService.generateAndroidUserVerifier(phoneNumber, displayName, password),\n                        phoneNumber);\n\n                return RestUtil.okayResponseWithData(RestMessage.VERIFICATION_TOKEN_SENT, tokenCode);\n            } else {\n                logger.info(\"Creating a verifier for user with phoneNumber ={}, user already exists.\", phoneNumber);\n                return RestUtil.errorResponse(HttpStatus.CONFLICT, RestMessage.USER_ALREADY_EXISTS);\n            }\n        } catch (InvalidPhoneNumberException e) {\n            return RestUtil.errorResponse(HttpStatus.BAD_REQUEST, RestMessage.INVALID_MSISDN);\n        }\n    }\n\n    @RequestMapping(value = \"/register/verify/{phoneNumber}/{code}\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Finish new user registration using otp password\", notes = \"User data and JWT token is returned as AuthorizedUserDTO object in the 'data' property\")\n    public ResponseEntity<ResponseWrapper> verifyRegistration(@PathVariable(\"phoneNumber\") String phoneNumber,\n                                                              @PathVariable(\"code\") String otpEntered,\n                                                              @RequestParam(required = false) UserInterfaceType type) {\n        final String msisdn = PhoneNumberUtil.convertPhoneNumber(phoneNumber);\n        if (passwordTokenService.isShortLivedOtpValid(msisdn, otpEntered)) {\n            logger.info(\"user dto and code verified, now creating user with phoneNumber={}\", phoneNumber);\n\n            UserDTO userDTO = userService.loadUserCreateRequest(msisdn);\n            User user = userService.createAndroidUserProfile(userDTO);\n            passwordTokenService.generateLongLivedAuthCode(user.getUid());\n            passwordTokenService.expireVerificationCode(user.getUid(), VerificationCodeType.SHORT_OTP);\n\n            CreateJwtTokenRequest tokenRequest = new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user);\n\n            String token = jwtService.createJwt(tokenRequest);\n\n            // Assemble response entity\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            // Return the token on the response\n            return RestUtil.okayResponseWithData(RestMessage.LOGIN_SUCCESS, response);\n        } else {\n            logger.info(\"Token verification for new user failed\");\n            return RestUtil.errorResponse(HttpStatus.UNAUTHORIZED, RestMessage.INVALID_OTP);\n        }\n    }\n\n    @RequestMapping(value = \"/web/register\", method = RequestMethod.POST)\n    public AuthorizationResponseDTO registerWebUser(@RequestParam String name,\n                                                    @RequestParam(required = false) String phone,\n                                                    @RequestParam(required = false) String email,\n                                                    @RequestParam(required = false) String otpEntered,\n                                                    @RequestParam String password) {\n        logger.info(\"registering, phone = {}, email = {}\", phone, email);\n        try {\n            // first check basic parameters are valid\n            if (StringUtils.isEmpty(name))\n                return new AuthorizationResponseDTO(RestMessage.INVALID_DISPLAYNAME);\n            else if (StringUtils.isEmpty(email) && StringUtils.isEmpty(phone))\n                return new AuthorizationResponseDTO(RestMessage.INVALID_MSISDN);\n            else if (StringUtils.isEmpty(password))\n                return new AuthorizationResponseDTO(RestMessage.INVALID_PASSWORD);\n\n            // note: once kill old web app, convert this (needed only because of Spring Security user profile needs on reg, it seems);\n            User newUser = User.makeEmpty();\n\n            // second, check if this phone/email can register\n            final UserRegPossibility regPossibility = userService.checkUserCanRegister(phone, email);\n            if (UserRegPossibility.USER_CANNOT_REGISTER.equals(regPossibility))\n                return new AuthorizationResponseDTO(RestMessage.USER_REGISTRATION_FAILED);\n\n            // third, if registration is possible but needs an otp, check the otp or tell client it's necessary\n            if (UserRegPossibility.USER_REQUIRES_OTP.equals(regPossibility)) {\n                if (StringUtils.isEmpty(otpEntered))\n                    return new AuthorizationResponseDTO(RestMessage.OTP_REQUIRED);\n            }\n\n            if(!StringUtils.isEmpty(otpEntered)){\n                String veriFyBy = StringUtils.isEmpty(phone) ? email : phone;\n                log.info(\"Verifying otp by={}\",veriFyBy);\n                if (!passwordTokenService.isShortLivedOtpValid(veriFyBy, otpEntered))\n                    return new AuthorizationResponseDTO(RestMessage.INVALID_OTP);\n            }\n\n            // at this point, all checks have necessarily passed, so continue\n            newUser.setDisplayName(name);\n\n            if (!StringUtils.isEmpty(phone)) {\n                newUser.setPhoneNumber(PhoneNumberUtil.convertPhoneNumber(phone));\n            }\n\n            if (!StringUtils.isEmpty(email)) {\n                newUser.setEmailAddress(email);\n            }\n\n            newUser.setPassword(password);\n\n            User user = userService.createUserWebProfile(newUser);\n            String token = jwtService.createJwt(new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user));\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            return new AuthorizationResponseDTO(response);\n\n        } catch (UserExistsException userException) {\n            return new AuthorizationResponseDTO(RestMessage.USER_ALREADY_EXISTS);\n        } catch (InvalidPhoneNumberException phoneNumberException) {\n            return new AuthorizationResponseDTO(RestMessage.INVALID_MSISDN);\n        }\n    }\n\n    @RequestMapping(value = \"/reset-password-request\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Reset user password request otp\", notes = \"Username can be either phone or email\")\n    public ResponseEntity resetPasswordRequest(@RequestParam(\"username\") String passedUsername) {\n        try {\n            User user = findExistingUser(passedUsername);\n            // note: user stored username may be different from that passed in req param (e.g., if user primarily\n            // uses phone but in this case gives us their email\n            String token = userService.regenerateUserVerifier(user.getUsername(), false);\n            temporaryTokenSend(token, user.getUsername());\n            return ResponseEntity.ok().build();\n        } catch (InvalidPhoneNumberException|NoSuchUserException e) {\n            logger.info(\"Invalid user of passed username: \", passedUsername);\n            return ResponseEntity.ok().build();\n        }\n    }\n\n    @RequestMapping(value = \"/reset-password-validate\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Validate an OTP generated in password reset\")\n    public ResponseEntity validateOtp(@RequestParam(\"username\") String passedUsername, @RequestParam String otp) {\n        User user = findExistingUser(passedUsername);\n        passwordTokenService.validateOtp(user.getUsername(), otp);\n        return ResponseEntity.ok().build();\n    }\n\n    @RequestMapping(value = \"/reset-password-complete\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Reset user password\", notes = \"New password is returned as a string in the 'data' property\")\n    public ResponseEntity resetPassword(@RequestParam(\"username\") String passedUsername,\n                                        @RequestParam(\"password\") String newPassword,\n                                        @RequestParam(\"otp\") String otpCode) {\n        // we return minimal information, for security purposes (i.e., to mask any possible sources of this being invalid)\n        User user = findExistingUser(passedUsername);\n        userService.resetUserPassword(user.getUsername(), newPassword, otpCode);\n        return ResponseEntity.ok().build();\n    }\n\n\n    @RequestMapping(value = \"/login\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Login using otp and retrieve a JWT token\", notes = \"The JWT token is returned as a string in the 'data' property\")\n    public ResponseEntity<ResponseWrapper> login(@RequestParam(\"phoneNumber\")String phoneNumber,\n                                                 @RequestParam(\"otp\") String otp,\n                                                 @RequestParam(value = \"durationMillis\", required = false) Long durationMillis,\n                                                 @RequestParam(required = false) UserInterfaceType interfaceType) {\n        try {\n            final String msisdn = PhoneNumberUtil.convertPhoneNumber(phoneNumber);\n            passwordTokenService.validateOtp(msisdn, otp);\n\n            // get the user object\n            User user = userService.findByInputNumber(msisdn);\n\n            // Generate a token for the user (for the moment assuming it is Android client)\n            CreateJwtTokenRequest tokenRequest = new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user);\n            if (durationMillis != null && durationMillis != 0) {\n                tokenRequest.setShortExpiryMillis(durationMillis);\n            }\n            String token = jwtService.createJwt(tokenRequest);\n\n            // Assemble response entity\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            // log that user was active\n            userLogger.logUserLogin(user.getUid(), interfaceType);\n\n            // Return the token on the response\n            return RestUtil.okayResponseWithData(RestMessage.LOGIN_SUCCESS, response);\n        } catch (InvalidOtpException e) {\n           logger.error(\"Failed to generate authentication token for:  \" + phoneNumber);\n            return RestUtil.errorResponse(HttpStatus.UNAUTHORIZED, RestMessage.INVALID_OTP);\n        }\n\n    }\n\n    @ApiOperation(value = \"Login using password and retrieve a JWT token\", notes = \"The JWT token is returned as a string in the 'data' property\")\n    @RequestMapping(value = \"/login-password\", method = RequestMethod.POST)\n    public AuthorizationResponseDTO webLogin(@RequestParam(\"username\") String username,\n                                             @RequestParam(\"password\") String password,\n                                             @RequestParam(required = false) UserInterfaceType interfaceType) {\n        try {\n            // get the user object, with no user throwing exception\n            User user = findExistingUser(username);\n            passwordTokenService.validatePwdPhoneOrEmail(username, password);\n\n            // Generate a token for the user (for the moment assuming it is Android client - Angular uses same params)\n            CreateJwtTokenRequest tokenRequest = new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user);\n\n            String token = jwtService.createJwt(tokenRequest);\n            logger.info(\"generate a jwt token, on server is: {}\", token);\n\n            // Assemble response entity\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            // log that user was active\n            userLogger.logUserLogin(user.getUid(), interfaceType);\n\n            // Return the token on the response\n            return new AuthorizationResponseDTO(response);\n        } catch (UsernamePasswordLoginFailedException e) {\n            logger.error(\"Failed to generate authentication token for:  \" + username);\n            return new AuthorizationResponseDTO(RestMessage.INVALID_PASSWORD);\n        }\n    }\n\n    @RequestMapping(value = \"/token/validate\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Validate whether a JWT token is available\", notes = \"Returns TOKEN_STILL_VALID in 'message', or \" +\n            \"else 'INVALID_TOKEN'\")\n    public ResponseEntity<ResponseWrapper> validateToken(@RequestParam String token,\n                                                         @RequestParam(required = false) String requiredRole) {\n        boolean isJwtTokenValid = jwtService.isJwtTokenValid(token);\n        final ResponseEntity<ResponseWrapper> validResponse = RestUtil.messageOkayResponse(RestMessage.TOKEN_STILL_VALID);\n        final ResponseEntity<ResponseWrapper> invalidResponse = RestUtil.errorResponse(HttpStatus.EXPECTATION_FAILED, RestMessage.INVALID_TOKEN);\n        if (isJwtTokenValid) {\n            List<String> userRoles = jwtService.getStandardRolesFromJwtToken(token);\n            return StringUtils.isEmpty(requiredRole) ? validResponse :\n                    userRoles.contains(requiredRole) ? validResponse : invalidResponse;\n        } else {\n            return invalidResponse;\n        }\n    }\n\n    @RequestMapping(value = \"/token/refresh\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Refresh JWT token\", notes = \"Try to refresh an old or expired token, responds with \" +\n            \"a new token as a string (in the 'data' property) if the old token is within the refresh window, or a bad request \" +\n            \"if the token is still old\")\n    public ResponseEntity<ResponseWrapper> refreshToken(@RequestParam(\"oldToken\")String oldToken,\n                                                        @RequestParam(value = \"durationMillis\", required = false) Long durationMillis) {\n        String newToken = jwtService.refreshToken(oldToken, JwtType.WEB_ANDROID_CLIENT, durationMillis);\n        if (newToken != null) {\n            return RestUtil.okayResponseWithData(RestMessage.LOGIN_SUCCESS, newToken);\n        } else {\n            return RestUtil.errorResponse(HttpStatus.BAD_REQUEST, RestMessage.TOKEN_EXPIRED);\n        }\n    }\n\n    private String temporaryTokenSend(String token, String numberOrEmail) {\n        if (environment.acceptsProfiles(Profiles.of(GrassrootApplicationProfiles.PRODUCTION))) {\n            passwordTokenService.triggerOtp(userService.findByUsernameLoose(numberOrEmail));\n            return \"\";\n        } else {\n            logger.info(\"returning token: {}\", token);\n            return token;\n        }\n    }\n\n    private boolean ifExists(String phoneNumber) {\n        return userService.userExist(PhoneNumberUtil.convertPhoneNumber(phoneNumber));\n    }\n}"], "fixing_code": ["package za.org.grassroot.integration.authentication;\n\nimport org.springframework.http.HttpHeaders;\nimport za.org.grassroot.integration.PublicCredentials;\n\nimport java.util.List;\n\n/**\n * Created by luke on 2017/05/22.\n */\npublic interface JwtService {\n\n    String USER_UID_KEY = \"USER_UID\";\n    String SYSTEM_ROLE_KEY = \"SYSTEM_ROLE_KEY\";\n    String PERMISSIONS_KEY = \"PERMISSIONS\";\n    String TYPE_KEY = \"TYPE\";\n\n    PublicCredentials getPublicCredentials();\n\n    String createJwt(CreateJwtTokenRequest request);\n\n    HttpHeaders createHeadersForLambdaCall();\n\n    boolean isJwtTokenValid(String token);\n\n    boolean isJwtTokenExpired(String token);\n\n    String getUserIdFromJwtToken(String token);\n\n    List<String> getStandardRolesFromJwtToken(String token);\n\n    List<String> getPermissionsFromToken(String token);\n}\n", "package za.org.grassroot.integration.authentication;\n\nimport io.jsonwebtoken.*;\nimport io.jsonwebtoken.impl.TextCodec;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.core.env.Environment;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.StringUtils;\nimport za.org.grassroot.integration.PublicCredentials;\n\nimport javax.annotation.PostConstruct;\nimport java.security.PublicKey;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.*;\n\n/**\n * Created by luke on 2017/05/22.\n */\n@Service\npublic class JwtServiceImpl implements JwtService {\n\n    private static final Logger logger = LoggerFactory.getLogger(JwtServiceImpl.class);\n\n    private String keyIdentifier;\n\n    @Value(\"${grassroot.jwt.token-expiry-grace-period.inMilliseconds:1209600000}\")\n    private Long jwtTokenExpiryGracePeriodInMilliseconds;\n\n    @Value(\"${grassroot.jwt.api-key-expiry.inDays:180}\")\n    private Long jwtApiKeyExpiryDays;\n\n    private final Environment environment;\n    private final KeyPairProvider keyPairProvider;\n\n    @Autowired\n    public JwtServiceImpl(Environment environment, KeyPairProvider keyPairProvider) {\n        this.environment = environment;\n        this.keyPairProvider = keyPairProvider;\n    }\n\n    @PostConstruct\n    public void init() {\n        PublicCredentials credentials = refreshPublicCredentials();\n        logger.debug(\"Public credentials generated: {}\", credentials);\n    }\n\n    @Override\n    public PublicCredentials getPublicCredentials() {\n        return createCredentialEntity(keyIdentifier, keyPairProvider.getJWTKey().getPublic());\n    }\n\n    @Override\n    public String createJwt(CreateJwtTokenRequest request) {\n        Instant now = Instant.now();\n\n        long typeExpiryMillis = convertTypeToExpiryMillis(request.getJwtType());\n        long passedExpiryMillis = request.getShortExpiryMillis() == null ? typeExpiryMillis :\n                Math.min(typeExpiryMillis, request.getShortExpiryMillis());\n\n        Instant exp = now.plus(passedExpiryMillis, ChronoUnit.MILLIS);\n        request.getHeaderParameters().put(\"kid\", keyIdentifier);\n\n        return Jwts.builder()\n                .setHeaderParams(request.getHeaderParameters())\n                .setClaims(request.getClaims())\n                .setIssuedAt(Date.from(now))\n                .setExpiration(Date.from(exp))\n                .signWith(\n                        SignatureAlgorithm.RS256,\n                        keyPairProvider.getJWTKey().getPrivate()\n                )\n                .compact();\n    }\n\n    @Override\n    public HttpHeaders createHeadersForLambdaCall() {\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Authorization\", \"Bearer \" + createJwt(CreateJwtTokenRequest.makeSystemToken()));\n        return headers;\n    }\n\n    private long convertTypeToExpiryMillis(JwtType jwtType) {\n        switch (jwtType) {\n            case WEB_ANDROID_CLIENT:\n                return Duration.ofDays(7L).toMillis();\n            case GRASSROOT_MICROSERVICE:\n                return Duration.ofSeconds(3).toMillis(); // occasional glitches mean 3 secs is a better trade off here at present\n            case MSGING_CLIENT:\n                return Duration.ofMinutes(1).toMillis();\n            case API_CLIENT:\n                return Duration.ofDays(jwtApiKeyExpiryDays).toMillis(); // now long lived\n            default:\n                return 1L;\n        }\n    }\n\n    @Override\n    public boolean isJwtTokenValid(String token) {\n        try {\n            Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic()).parse(token);\n            return true;\n        }\n        catch (ExpiredJwtException e) {\n            logger.error(\"Token validation failed. The token is expired. Exception: {}\", e.getMessage());\n            return false;\n        }\n        catch (SignatureException e) {\n            logger.error(\"Token validation failed, wrong signature. Exception: {}\", e.getMessage());\n            return false;\n        }\n        catch (Exception e) {\n            logger.error(\"Unexpected token validation error.\", e);\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isJwtTokenExpired(String token) {\n        try {\n            Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic()).parse(token).getBody();\n            return false;\n        }\n        catch (ExpiredJwtException e) {\n            logger.error(\"The token is expired.\", e);\n            return true;\n        }\n        catch (Exception e) {\n            logger.error(\"Unexpected token validation error.\", e);\n            return false;\n        }\n    }\n\n    @Override\n    public String getUserIdFromJwtToken(String token) {\n        return extractFromToken(USER_UID_KEY, token);\n    }\n\n    @Override\n    public List<String> getPermissionsFromToken(String token) {\n        String permissionList = extractFromToken(PERMISSIONS_KEY, token);\n        return StringUtils.isEmpty(permissionList) ? new ArrayList<>() :\n                Arrays.asList(permissionList.split(\",\"));\n    }\n\n    private String extractFromToken(String key, String token) {\n        try {\n            Claims claims = Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic())\n                    .parseClaimsJws(token).getBody();\n            return claims.get(key, String.class);\n        } catch (Exception e) {\n            logger.error(\"Failed to get user id from jwt token: {}\", e.getMessage());\n            return null;\n        }\n    }\n\n    @Override\n    public List<String> getStandardRolesFromJwtToken(String token) {\n        String joinedRoles = extractClaims(token).get(SYSTEM_ROLE_KEY, String.class);\n        return StringUtils.isEmpty(joinedRoles) ? new ArrayList<>() : Arrays.asList(joinedRoles.split(\",\"));\n    }\n\n    private Claims extractClaims(String token) {\n        return Jwts.parser().setSigningKey(keyPairProvider.getJWTKey().getPublic())\n                .parseClaimsJws(token).getBody();\n    }\n\n    private PublicCredentials refreshPublicCredentials() {\n        keyIdentifier = environment.getProperty(\"grassroot.publickey.identifier\", UUID.randomUUID().toString());\n        logger.debug(\"created KUID for main platform: {}\", keyIdentifier);\n        return createCredentialEntity(keyIdentifier, keyPairProvider.getJWTKey().getPublic());\n    }\n\n    private PublicCredentials createCredentialEntity(String kuid, PublicKey key) {\n        return new PublicCredentials(kuid, TextCodec.BASE64.encode(key.getEncoded()));\n    }\n}\n", "package za.org.grassroot.webapp.controller.rest.authentication;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.validator.routines.EmailValidator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.env.Profiles;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.*;\nimport za.org.grassroot.core.GrassrootApplicationProfiles;\nimport za.org.grassroot.core.domain.User;\nimport za.org.grassroot.core.dto.UserDTO;\nimport za.org.grassroot.core.enums.UserInterfaceType;\nimport za.org.grassroot.core.enums.VerificationCodeType;\nimport za.org.grassroot.core.util.InvalidPhoneNumberException;\nimport za.org.grassroot.core.util.PhoneNumberUtil;\nimport za.org.grassroot.integration.authentication.CreateJwtTokenRequest;\nimport za.org.grassroot.integration.authentication.JwtService;\nimport za.org.grassroot.integration.authentication.JwtType;\nimport za.org.grassroot.services.async.AsyncUserLogger;\nimport za.org.grassroot.services.exception.InvalidOtpException;\nimport za.org.grassroot.services.exception.NoSuchUserException;\nimport za.org.grassroot.services.exception.UserExistsException;\nimport za.org.grassroot.services.exception.UsernamePasswordLoginFailedException;\nimport za.org.grassroot.services.user.PasswordTokenService;\nimport za.org.grassroot.services.user.UserManagementService;\nimport za.org.grassroot.services.user.UserRegPossibility;\nimport za.org.grassroot.webapp.controller.rest.Grassroot2RestController;\nimport za.org.grassroot.webapp.enums.RestMessage;\nimport za.org.grassroot.webapp.model.rest.AuthorizationResponseDTO;\nimport za.org.grassroot.webapp.model.rest.AuthorizedUserDTO;\nimport za.org.grassroot.webapp.model.rest.wrappers.ResponseWrapper;\nimport za.org.grassroot.webapp.util.RestUtil;\n\nimport java.util.Collections;\nimport java.util.List;\n\n@RestController @Grassroot2RestController @Slf4j\n@Api(\"/v2/api/auth\")\n@RequestMapping(\"/v2/api/auth\")\npublic class AuthenticationController {\n\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationController.class);\n\n    private static final List<UserInterfaceType> alphaInterfaces = Collections.singletonList(UserInterfaceType.ANDROID_2);\n\n    private final JwtService jwtService;\n    private final PasswordTokenService passwordTokenService;\n    private final UserManagementService userService;\n    private final AsyncUserLogger userLogger;\n    private final Environment environment;\n\n    @Autowired\n    public AuthenticationController(JwtService jwtService, PasswordTokenService passwordTokenService,\n                                    UserManagementService userService, AsyncUserLogger userLogger, Environment environment) {\n        this.jwtService = jwtService;\n        this.passwordTokenService = passwordTokenService;\n        this.userService = userService;\n        this.userLogger = userLogger;\n        this.environment = environment;\n    }\n\n    private User findExistingUser(String username) {\n        boolean isPhoneNumber = PhoneNumberUtil.testInputNumber(username);\n        if (!isPhoneNumber && !EmailValidator.getInstance().isValid(username)) {\n            logger.error(\"got a bad username, : {}\", username);\n            throw new NoSuchUserException(\"Invalid format, neither phone nor email: \" + username);\n        }\n        User user = userService.findByUsernameLoose(username);\n        if (user == null) {\n            throw new NoSuchUserException(\"No user with phone or email: \" + username);\n        }\n        return user;\n    }\n\n    @ExceptionHandler(NoSuchUserException.class)\n    public ResponseEntity noSuchUserResponse() {\n        return RestUtil.errorResponse(RestMessage.INVALID_MSISDN);\n    }\n\n    @RequestMapping(value = \"/register\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Start new user registration using username, phone number and password\", notes = \"Short lived token is returned as a string in the 'data' property\")\n    public ResponseEntity<ResponseWrapper> register(@RequestParam(\"phoneNumber\") String phoneNumber,\n                                                    @RequestParam(\"displayName\") String displayName,\n                                                    @RequestParam(\"password\") String password,\n                                                    @RequestParam(required = false) UserInterfaceType type) {\n        try {\n            if (!ifExists(phoneNumber)) {\n                phoneNumber = PhoneNumberUtil.convertPhoneNumber(phoneNumber);\n                logger.info(\"Creating a verifier for a new user with phoneNumber ={}\", phoneNumber);\n                String tokenCode = temporaryTokenSend(\n                        userService.generateAndroidUserVerifier(phoneNumber, displayName, password),\n                        phoneNumber);\n\n                return RestUtil.okayResponseWithData(RestMessage.VERIFICATION_TOKEN_SENT, tokenCode);\n            } else {\n                logger.info(\"Creating a verifier for user with phoneNumber ={}, user already exists.\", phoneNumber);\n                return RestUtil.errorResponse(HttpStatus.CONFLICT, RestMessage.USER_ALREADY_EXISTS);\n            }\n        } catch (InvalidPhoneNumberException e) {\n            return RestUtil.errorResponse(HttpStatus.BAD_REQUEST, RestMessage.INVALID_MSISDN);\n        }\n    }\n\n    @RequestMapping(value = \"/register/verify/{phoneNumber}/{code}\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Finish new user registration using otp password\", notes = \"User data and JWT token is returned as AuthorizedUserDTO object in the 'data' property\")\n    public ResponseEntity<ResponseWrapper> verifyRegistration(@PathVariable(\"phoneNumber\") String phoneNumber,\n                                                              @PathVariable(\"code\") String otpEntered,\n                                                              @RequestParam(required = false) UserInterfaceType type) {\n        final String msisdn = PhoneNumberUtil.convertPhoneNumber(phoneNumber);\n        if (passwordTokenService.isShortLivedOtpValid(msisdn, otpEntered)) {\n            logger.info(\"user dto and code verified, now creating user with phoneNumber={}\", phoneNumber);\n\n            UserDTO userDTO = userService.loadUserCreateRequest(msisdn);\n            User user = userService.createAndroidUserProfile(userDTO);\n            passwordTokenService.generateLongLivedAuthCode(user.getUid());\n            passwordTokenService.expireVerificationCode(user.getUid(), VerificationCodeType.SHORT_OTP);\n\n            CreateJwtTokenRequest tokenRequest = new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user);\n\n            String token = jwtService.createJwt(tokenRequest);\n\n            // Assemble response entity\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            // Return the token on the response\n            return RestUtil.okayResponseWithData(RestMessage.LOGIN_SUCCESS, response);\n        } else {\n            logger.info(\"Token verification for new user failed\");\n            return RestUtil.errorResponse(HttpStatus.UNAUTHORIZED, RestMessage.INVALID_OTP);\n        }\n    }\n\n    @RequestMapping(value = \"/web/register\", method = RequestMethod.POST)\n    public AuthorizationResponseDTO registerWebUser(@RequestParam String name,\n                                                    @RequestParam(required = false) String phone,\n                                                    @RequestParam(required = false) String email,\n                                                    @RequestParam(required = false) String otpEntered,\n                                                    @RequestParam String password) {\n        logger.info(\"registering, phone = {}, email = {}\", phone, email);\n        try {\n            // first check basic parameters are valid\n            if (StringUtils.isEmpty(name))\n                return new AuthorizationResponseDTO(RestMessage.INVALID_DISPLAYNAME);\n            else if (StringUtils.isEmpty(email) && StringUtils.isEmpty(phone))\n                return new AuthorizationResponseDTO(RestMessage.INVALID_MSISDN);\n            else if (StringUtils.isEmpty(password))\n                return new AuthorizationResponseDTO(RestMessage.INVALID_PASSWORD);\n\n            // note: once kill old web app, convert this (needed only because of Spring Security user profile needs on reg, it seems);\n            User newUser = User.makeEmpty();\n\n            // second, check if this phone/email can register\n            final UserRegPossibility regPossibility = userService.checkUserCanRegister(phone, email);\n            if (UserRegPossibility.USER_CANNOT_REGISTER.equals(regPossibility))\n                return new AuthorizationResponseDTO(RestMessage.USER_REGISTRATION_FAILED);\n\n            // third, if registration is possible but needs an otp, check the otp or tell client it's necessary\n            if (UserRegPossibility.USER_REQUIRES_OTP.equals(regPossibility)) {\n                if (StringUtils.isEmpty(otpEntered))\n                    return new AuthorizationResponseDTO(RestMessage.OTP_REQUIRED);\n            }\n\n            if(!StringUtils.isEmpty(otpEntered)){\n                String veriFyBy = StringUtils.isEmpty(phone) ? email : phone;\n                log.info(\"Verifying otp by={}\",veriFyBy);\n                if (!passwordTokenService.isShortLivedOtpValid(veriFyBy, otpEntered))\n                    return new AuthorizationResponseDTO(RestMessage.INVALID_OTP);\n            }\n\n            // at this point, all checks have necessarily passed, so continue\n            newUser.setDisplayName(name);\n\n            if (!StringUtils.isEmpty(phone)) {\n                newUser.setPhoneNumber(PhoneNumberUtil.convertPhoneNumber(phone));\n            }\n\n            if (!StringUtils.isEmpty(email)) {\n                newUser.setEmailAddress(email);\n            }\n\n            newUser.setPassword(password);\n\n            User user = userService.createUserWebProfile(newUser);\n            String token = jwtService.createJwt(new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user));\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            return new AuthorizationResponseDTO(response);\n\n        } catch (UserExistsException userException) {\n            return new AuthorizationResponseDTO(RestMessage.USER_ALREADY_EXISTS);\n        } catch (InvalidPhoneNumberException phoneNumberException) {\n            return new AuthorizationResponseDTO(RestMessage.INVALID_MSISDN);\n        }\n    }\n\n    @RequestMapping(value = \"/reset-password-request\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Reset user password request otp\", notes = \"Username can be either phone or email\")\n    public ResponseEntity resetPasswordRequest(@RequestParam(\"username\") String passedUsername) {\n        try {\n            User user = findExistingUser(passedUsername);\n            // note: user stored username may be different from that passed in req param (e.g., if user primarily\n            // uses phone but in this case gives us their email\n            String token = userService.regenerateUserVerifier(user.getUsername(), false);\n            temporaryTokenSend(token, user.getUsername());\n            return ResponseEntity.ok().build();\n        } catch (InvalidPhoneNumberException|NoSuchUserException e) {\n            logger.info(\"Invalid user of passed username: \", passedUsername);\n            return ResponseEntity.ok().build();\n        }\n    }\n\n    @RequestMapping(value = \"/reset-password-validate\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Validate an OTP generated in password reset\")\n    public ResponseEntity validateOtp(@RequestParam(\"username\") String passedUsername, @RequestParam String otp) {\n        User user = findExistingUser(passedUsername);\n        passwordTokenService.validateOtp(user.getUsername(), otp);\n        return ResponseEntity.ok().build();\n    }\n\n    @RequestMapping(value = \"/reset-password-complete\", method = RequestMethod.POST)\n    @ApiOperation(value = \"Reset user password\", notes = \"New password is returned as a string in the 'data' property\")\n    public ResponseEntity resetPassword(@RequestParam(\"username\") String passedUsername,\n                                        @RequestParam(\"password\") String newPassword,\n                                        @RequestParam(\"otp\") String otpCode) {\n        // we return minimal information, for security purposes (i.e., to mask any possible sources of this being invalid)\n        User user = findExistingUser(passedUsername);\n        userService.resetUserPassword(user.getUsername(), newPassword, otpCode);\n        return ResponseEntity.ok().build();\n    }\n\n\n    @RequestMapping(value = \"/login\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Login using otp and retrieve a JWT token\", notes = \"The JWT token is returned as a string in the 'data' property\")\n    public ResponseEntity<ResponseWrapper> login(@RequestParam(\"phoneNumber\")String phoneNumber,\n                                                 @RequestParam(\"otp\") String otp,\n                                                 @RequestParam(value = \"durationMillis\", required = false) Long durationMillis,\n                                                 @RequestParam(required = false) UserInterfaceType interfaceType) {\n        try {\n            final String msisdn = PhoneNumberUtil.convertPhoneNumber(phoneNumber);\n            passwordTokenService.validateOtp(msisdn, otp);\n\n            // get the user object\n            User user = userService.findByInputNumber(msisdn);\n\n            // Generate a token for the user (for the moment assuming it is Android client)\n            CreateJwtTokenRequest tokenRequest = new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user);\n            if (durationMillis != null && durationMillis != 0) {\n                tokenRequest.setShortExpiryMillis(durationMillis);\n            }\n            String token = jwtService.createJwt(tokenRequest);\n\n            // Assemble response entity\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            // log that user was active\n            userLogger.logUserLogin(user.getUid(), interfaceType);\n\n            // Return the token on the response\n            return RestUtil.okayResponseWithData(RestMessage.LOGIN_SUCCESS, response);\n        } catch (InvalidOtpException e) {\n           logger.error(\"Failed to generate authentication token for:  \" + phoneNumber);\n            return RestUtil.errorResponse(HttpStatus.UNAUTHORIZED, RestMessage.INVALID_OTP);\n        }\n\n    }\n\n    @ApiOperation(value = \"Login using password and retrieve a JWT token\", notes = \"The JWT token is returned as a string in the 'data' property\")\n    @RequestMapping(value = \"/login-password\", method = RequestMethod.POST)\n    public AuthorizationResponseDTO webLogin(@RequestParam(\"username\") String username,\n                                             @RequestParam(\"password\") String password,\n                                             @RequestParam(required = false) UserInterfaceType interfaceType) {\n        try {\n            // get the user object, with no user throwing exception\n            User user = findExistingUser(username);\n            passwordTokenService.validatePwdPhoneOrEmail(username, password);\n\n            // Generate a token for the user (for the moment assuming it is Android client - Angular uses same params)\n            CreateJwtTokenRequest tokenRequest = new CreateJwtTokenRequest(JwtType.WEB_ANDROID_CLIENT, user);\n\n            String token = jwtService.createJwt(tokenRequest);\n            logger.info(\"generate a jwt token, on server is: {}\", token);\n\n            // Assemble response entity\n            AuthorizedUserDTO response = new AuthorizedUserDTO(user, token);\n\n            // log that user was active\n            userLogger.logUserLogin(user.getUid(), interfaceType);\n\n            // Return the token on the response\n            return new AuthorizationResponseDTO(response);\n        } catch (UsernamePasswordLoginFailedException e) {\n            logger.error(\"Failed to generate authentication token for:  \" + username);\n            return new AuthorizationResponseDTO(RestMessage.INVALID_PASSWORD);\n        }\n    }\n\n    @RequestMapping(value = \"/token/validate\", method = RequestMethod.GET)\n    @ApiOperation(value = \"Validate whether a JWT token is available\", notes = \"Returns TOKEN_STILL_VALID in 'message', or \" +\n            \"else 'INVALID_TOKEN'\")\n    public ResponseEntity<ResponseWrapper> validateToken(@RequestParam String token,\n                                                         @RequestParam(required = false) String requiredRole) {\n        boolean isJwtTokenValid = jwtService.isJwtTokenValid(token);\n        final ResponseEntity<ResponseWrapper> validResponse = RestUtil.messageOkayResponse(RestMessage.TOKEN_STILL_VALID);\n        final ResponseEntity<ResponseWrapper> invalidResponse = RestUtil.errorResponse(HttpStatus.EXPECTATION_FAILED, RestMessage.INVALID_TOKEN);\n        if (isJwtTokenValid) {\n            List<String> userRoles = jwtService.getStandardRolesFromJwtToken(token);\n            return StringUtils.isEmpty(requiredRole) ? validResponse :\n                    userRoles.contains(requiredRole) ? validResponse : invalidResponse;\n        } else {\n            return invalidResponse;\n        }\n    }\n\n    private String temporaryTokenSend(String token, String numberOrEmail) {\n        if (environment.acceptsProfiles(Profiles.of(GrassrootApplicationProfiles.PRODUCTION))) {\n            passwordTokenService.triggerOtp(userService.findByUsernameLoose(numberOrEmail));\n            return \"\";\n        } else {\n            logger.info(\"returning token: {}\", token);\n            return token;\n        }\n    }\n\n    private boolean ifExists(String phoneNumber) {\n        return userService.userExist(PhoneNumberUtil.convertPhoneNumber(phoneNumber));\n    }\n}"], "filenames": ["grassroot-integration/src/main/java/za/org/grassroot/integration/authentication/JwtService.java", "grassroot-integration/src/main/java/za/org/grassroot/integration/authentication/JwtServiceImpl.java", "grassroot-webapp/src/main/java/za/org/grassroot/webapp/controller/rest/authentication/AuthenticationController.java"], "buggy_code_start_loc": [24, 173, 321], "buggy_code_end_loc": [31, 200, 335], "fixing_code_start_loc": [23, 172, 320], "fixing_code_end_loc": [23, 172, 320], "type": "CWE-347", "message": "Grassroot Platform is an application to make it faster, cheaper and easier to persistently organize and mobilize people in low-income communities. Grassroot Platform before master deployment as of 2021-04-16 did not properly verify the signature of JSON Web Tokens when refreshing an existing JWT. This allows to forge a valid JWT. The problem has been patched in version 1.3.1 by deprecating the JWT refresh function, which was an overdue deprecation regardless (the \"refresh\" flow is no longer used).", "other": {"cve": {"id": "CVE-2021-29455", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-19T19:15:17.827", "lastModified": "2021-04-28T13:49:59.660", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grassroot Platform is an application to make it faster, cheaper and easier to persistently organize and mobilize people in low-income communities. Grassroot Platform before master deployment as of 2021-04-16 did not properly verify the signature of JSON Web Tokens when refreshing an existing JWT. This allows to forge a valid JWT. The problem has been patched in version 1.3.1 by deprecating the JWT refresh function, which was an overdue deprecation regardless (the \"refresh\" flow is no longer used)."}, {"lang": "es", "value": "Grassroot Platform es una aplicaci\u00f3n que hace que sea m\u00e1s r\u00e1pido, m\u00e1s barato y m\u00e1s f\u00e1cil organizar y movilizar persistentemente a las personas en comunidades de bajos ingresos.&#xa0;Grassroot Platform versiones anteriores a la implementaci\u00f3n maestra a partir del 16-04-2021, no comprobaba apropiadamente la firma de JSON Web Tokens al actualizar un JWT existente.&#xa0;Esto permite falsificar un JWT v\u00e1lido.&#xa0;El problema ha sido parcheado en versi\u00f3n 1.3.1, al desaprobar la funci\u00f3n de actualizaci\u00f3n de JWT, que era una desaprobaci\u00f3n vencida independientemente (el flujo de \"refresh\" ya no es usado)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grassroot:grassroot_platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.1", "matchCriteriaId": "945F532A-7668-4C8E-9599-240FCEC2862B"}]}]}], "references": [{"url": "https://github.com/grassrootza/grassroot-platform/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/grassrootza/grassroot-platform/commit/a2e6e885f8183a066d938cf909fd813a7af7d67f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grassrootza/grassroot-platform/security/advisories/GHSA-f65w-6xw8-6734", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grassrootza/grassroot-platform/commit/a2e6e885f8183a066d938cf909fd813a7af7d67f"}}