{"buggy_code": ["\n# Changelog\n\n## Version 0.5.0\n\n* feat: support object with null prototype\n\n## Version 0.4.0\n\n* compare: new function\n\n## Version 0.3.5\n\n* readme: fix examples\n\n## Version 0.3.3\n\n* package: update adaltas url\n\n## Version 0.3.2\n\n* package: use files instead of npmignore\n\n## Version 0.3.1\n\n* mutate: immutable deep copy of object in arrays\n\n## Version 0.3.0\n\n* project: csj, esm and umd generation\n* project: ignore lock files\n\n## Version 0.2.0\n\n* snake_case: clone object with converted properties\n* merge: fix array and object merge\n* is_object_literal: new function\n\n## Version 0.1.0\n\n* clone: new function\n* readme: add author company\n\n## Version 0.1.0\n\n* package: support node version above 6\n* readme: update sample\n\n## Version 0.0.1\n\n* package: original commit\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n// Generated by CoffeeScript 2.5.1\nvar _snake_case;\n\nexports.merge = function merge() {\n  return exports.mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));\n};\n\nexports.clone = function clone(target) {\n  if (Array.isArray(target)) {\n    return target.map(function (element) {\n      return exports.clone(element);\n    });\n  } else if (target && _typeof(target) === 'object') {\n    return exports.mutate({}, target);\n  } else {\n    return target;\n  }\n};\n\nexports.mutate = function mutate() {\n  var i, j, name, ref, source, target, v;\n  target = arguments[0];\n\n  for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n    source = arguments[i];\n\n    if (exports.is_object_literal(source)) {\n      if (!exports.is_object_literal(target)) {\n        target = {};\n      }\n\n      for (name in source) {\n        target[name] = exports.mutate(target[name], source[name]);\n      }\n    } else if (Array.isArray(source)) {\n      target = function () {\n        var k, len, results;\n        results = [];\n\n        for (k = 0, len = source.length; k < len; k++) {\n          v = source[k];\n          results.push(exports.mutate(void 0, v));\n        }\n\n        return results;\n      }();\n    } else if (source !== void 0) {\n      target = source;\n    }\n  }\n\n  return target;\n};\n\nexports.snake_case = function snake_case(source) {\n  var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var name, src, target, u;\n  target = {};\n\n  if (exports.is_object_literal(source)) {\n    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n\n    for (name in source) {\n      src = source[name];\n\n      if (convert) {\n        name = _snake_case(name);\n      }\n\n      target[name] = exports.snake_case(src, u);\n    }\n  } else {\n    target = source;\n  }\n\n  return target;\n};\n\nexports.compare = function compare(el1, el2) {\n  var i, j, k, key, keys1, keys2, len, ref;\n\n  if (exports.is_object_literal(el1)) {\n    if (!exports.is_object_literal(el2)) {\n      return false;\n    }\n\n    keys1 = Object.keys(el1).sort();\n    keys2 = Object.keys(el2).sort();\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n      key = keys1[i];\n\n      if (key !== keys2[i]) {\n        return false;\n      }\n\n      if (!exports.compare(el1[key], el2[key])) {\n        return false;\n      }\n    }\n  } else if (Array.isArray(el1)) {\n    if (!Array.isArray(el2)) {\n      return false;\n    }\n\n    if (el1.length !== el2.length) {\n      return false;\n    }\n\n    for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n      if (!exports.compare(el1[i], el2[i])) {\n        return false;\n      }\n    }\n  } else {\n    if (el1 !== el2) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n_snake_case = function _snake_case(str) {\n  return str.replace(/([A-Z])/g, function (_, match, index) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nexports.is_object = function is_object(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n};\n\nexports.is_object_literal = function is_object_literal(obj) {\n  var test;\n  test = obj;\n\n  if (_typeof(obj) !== 'object' || obj === null) {\n    return false;\n  } else {\n    if (Object.getPrototypeOf(test) === null) {\n      return true;\n    }\n\n    while (!false) {\n      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n        break;\n      }\n    }\n\n    return Object.getPrototypeOf(obj) === test;\n  }\n};\n", "function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n// Generated by CoffeeScript 2.5.1\nvar _snake_case, _clone, _compare, is_object, is_object_literal, merge, _mutate, _snake_case2;\n\nmerge = function merge() {\n  return _mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));\n};\n\n_clone = function clone(target) {\n  if (Array.isArray(target)) {\n    return target.map(function (element) {\n      return _clone(element);\n    });\n  } else if (target && _typeof(target) === 'object') {\n    return _mutate({}, target);\n  } else {\n    return target;\n  }\n};\n\n_mutate = function mutate() {\n  var i, j, name, ref, source, target, v;\n  target = arguments[0];\n\n  for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n    source = arguments[i];\n\n    if (is_object_literal(source)) {\n      if (!is_object_literal(target)) {\n        target = {};\n      }\n\n      for (name in source) {\n        target[name] = _mutate(target[name], source[name]);\n      }\n    } else if (Array.isArray(source)) {\n      target = function () {\n        var k, len, results;\n        results = [];\n\n        for (k = 0, len = source.length; k < len; k++) {\n          v = source[k];\n          results.push(_mutate(void 0, v));\n        }\n\n        return results;\n      }();\n    } else if (source !== void 0) {\n      target = source;\n    }\n  }\n\n  return target;\n};\n\n_snake_case2 = function snake_case(source) {\n  var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var name, src, target, u;\n  target = {};\n\n  if (is_object_literal(source)) {\n    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n\n    for (name in source) {\n      src = source[name];\n\n      if (convert) {\n        name = _snake_case(name);\n      }\n\n      target[name] = _snake_case2(src, u);\n    }\n  } else {\n    target = source;\n  }\n\n  return target;\n};\n\n_compare = function compare(el1, el2) {\n  var i, j, k, key, keys1, keys2, len, ref;\n\n  if (is_object_literal(el1)) {\n    if (!is_object_literal(el2)) {\n      return false;\n    }\n\n    keys1 = Object.keys(el1).sort();\n    keys2 = Object.keys(el2).sort();\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n      key = keys1[i];\n\n      if (key !== keys2[i]) {\n        return false;\n      }\n\n      if (!_compare(el1[key], el2[key])) {\n        return false;\n      }\n    }\n  } else if (Array.isArray(el1)) {\n    if (!Array.isArray(el2)) {\n      return false;\n    }\n\n    if (el1.length !== el2.length) {\n      return false;\n    }\n\n    for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n      if (!_compare(el1[i], el2[i])) {\n        return false;\n      }\n    }\n  } else {\n    if (el1 !== el2) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n_snake_case = function _snake_case(str) {\n  return str.replace(/([A-Z])/g, function (_, match, index) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nis_object = function is_object(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n};\n\nis_object_literal = function is_object_literal(obj) {\n  var test;\n  test = obj;\n\n  if (_typeof(obj) !== 'object' || obj === null) {\n    return false;\n  } else {\n    if (Object.getPrototypeOf(test) === null) {\n      return true;\n    }\n\n    while (!false) {\n      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n        break;\n      }\n    }\n\n    return Object.getPrototypeOf(obj) === test;\n  }\n};\n\nexport { _clone as clone, _compare as compare, is_object, is_object_literal, merge, _mutate as mutate, _snake_case2 as snake_case };\n", "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mixme = {}));\n}(this, (function (exports) { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  // Generated by CoffeeScript 2.5.1\n  var _snake_case;\n\n  exports.merge = function merge() {\n    return exports.mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));\n  };\n\n  exports.clone = function clone(target) {\n    if (Array.isArray(target)) {\n      return target.map(function (element) {\n        return exports.clone(element);\n      });\n    } else if (target && _typeof(target) === 'object') {\n      return exports.mutate({}, target);\n    } else {\n      return target;\n    }\n  };\n\n  exports.mutate = function mutate() {\n    var i, j, name, ref, source, target, v;\n    target = arguments[0];\n\n    for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n      source = arguments[i];\n\n      if (exports.is_object_literal(source)) {\n        if (!exports.is_object_literal(target)) {\n          target = {};\n        }\n\n        for (name in source) {\n          target[name] = exports.mutate(target[name], source[name]);\n        }\n      } else if (Array.isArray(source)) {\n        target = function () {\n          var k, len, results;\n          results = [];\n\n          for (k = 0, len = source.length; k < len; k++) {\n            v = source[k];\n            results.push(exports.mutate(void 0, v));\n          }\n\n          return results;\n        }();\n      } else if (source !== void 0) {\n        target = source;\n      }\n    }\n\n    return target;\n  };\n\n  exports.snake_case = function snake_case(source) {\n    var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var name, src, target, u;\n    target = {};\n\n    if (exports.is_object_literal(source)) {\n      u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n\n      for (name in source) {\n        src = source[name];\n\n        if (convert) {\n          name = _snake_case(name);\n        }\n\n        target[name] = exports.snake_case(src, u);\n      }\n    } else {\n      target = source;\n    }\n\n    return target;\n  };\n\n  exports.compare = function compare(el1, el2) {\n    var i, j, k, key, keys1, keys2, len, ref;\n\n    if (exports.is_object_literal(el1)) {\n      if (!exports.is_object_literal(el2)) {\n        return false;\n      }\n\n      keys1 = Object.keys(el1).sort();\n      keys2 = Object.keys(el2).sort();\n\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n\n      for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n        key = keys1[i];\n\n        if (key !== keys2[i]) {\n          return false;\n        }\n\n        if (!exports.compare(el1[key], el2[key])) {\n          return false;\n        }\n      }\n    } else if (Array.isArray(el1)) {\n      if (!Array.isArray(el2)) {\n        return false;\n      }\n\n      if (el1.length !== el2.length) {\n        return false;\n      }\n\n      for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        if (!exports.compare(el1[i], el2[i])) {\n          return false;\n        }\n      }\n    } else {\n      if (el1 !== el2) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _snake_case = function _snake_case(str) {\n    return str.replace(/([A-Z])/g, function (_, match, index) {\n      return '_' + match.toLowerCase();\n    });\n  };\n\n  exports.is_object = function is_object(obj) {\n    return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n  };\n\n  exports.is_object_literal = function is_object_literal(obj) {\n    var test;\n    test = obj;\n\n    if (_typeof(obj) !== 'object' || obj === null) {\n      return false;\n    } else {\n      if (Object.getPrototypeOf(test) === null) {\n        return true;\n      }\n\n      while (!false) {\n        if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n          break;\n        }\n      }\n\n      return Object.getPrototypeOf(obj) === test;\n    }\n  };\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n", "// Generated by CoffeeScript 2.5.1\nvar _snake_case, clone, compare, is_object, is_object_literal, merge, mutate, snake_case;\n\nmerge = function() {\n  return mutate({}, ...arguments);\n};\n\nclone = function(target) {\n  if (Array.isArray(target)) {\n    return target.map(function(element) {\n      return clone(element);\n    });\n  } else if (target && typeof target === 'object') {\n    return mutate({}, target);\n  } else {\n    return target;\n  }\n};\n\nmutate = function() {\n  var i, j, name, ref, source, target, v;\n  target = arguments[0];\n  for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {\n    source = arguments[i];\n    if (is_object_literal(source)) {\n      if (!is_object_literal(target)) {\n        target = {};\n      }\n      for (name in source) {\n        target[name] = mutate(target[name], source[name]);\n      }\n    } else if (Array.isArray(source)) {\n      target = (function() {\n        var k, len, results;\n        results = [];\n        for (k = 0, len = source.length; k < len; k++) {\n          v = source[k];\n          results.push(mutate(void 0, v));\n        }\n        return results;\n      })();\n    } else if (source !== void 0) {\n      target = source;\n    }\n  }\n  return target;\n};\n\nsnake_case = function(source, convert = true) {\n  var name, src, target, u;\n  target = {};\n  if (is_object_literal(source)) {\n    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n    for (name in source) {\n      src = source[name];\n      if (convert) {\n        name = _snake_case(name);\n      }\n      target[name] = snake_case(src, u);\n    }\n  } else {\n    target = source;\n  }\n  return target;\n};\n\ncompare = function(el1, el2) {\n  var i, j, k, key, keys1, keys2, len, ref;\n  if (is_object_literal(el1)) {\n    if (!is_object_literal(el2)) {\n      return false;\n    }\n    keys1 = Object.keys(el1).sort();\n    keys2 = Object.keys(el2).sort();\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n      key = keys1[i];\n      if (key !== keys2[i]) {\n        return false;\n      }\n      if (!compare(el1[key], el2[key])) {\n        return false;\n      }\n    }\n  } else if (Array.isArray(el1)) {\n    if (!Array.isArray(el2)) {\n      return false;\n    }\n    if (el1.length !== el2.length) {\n      return false;\n    }\n    for (i = k = 0, ref = el1.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {\n      if (!compare(el1[i], el2[i])) {\n        return false;\n      }\n    }\n  } else {\n    if (el1 !== el2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n_snake_case = function(str) {\n  return str.replace(/([A-Z])/g, function(_, match, index) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nis_object = function(obj) {\n  return obj && typeof obj === 'object' && !Array.isArray(obj);\n};\n\nis_object_literal = function(obj) {\n  var test;\n  test = obj;\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  } else {\n    if (Object.getPrototypeOf(test) === null) {\n      return true;\n    }\n    while (!false) {\n      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n        break;\n      }\n    }\n    return Object.getPrototypeOf(obj) === test;\n  }\n};\n\nexport {\n  clone,\n  compare,\n  is_object,\n  is_object_literal,\n  merge,\n  mutate,\n  snake_case\n};\n", "\n\nmerge = ->\n  mutate {}, arguments...\n\nclone = (target) ->\n  if Array.isArray target\n    target.map (element) ->\n      clone element\n  else if target and typeof target is 'object'\n    mutate {}, target\n  else\n    target\n\nmutate = ->\n  target = arguments[0]\n  for i in [1 ... arguments.length]\n    source = arguments[i]\n    if is_object_literal source\n      target = {} unless is_object_literal target\n      for name of source\n        target[name] = mutate target[name], source[name]\n    else if Array.isArray source\n      target = for v in source\n        mutate undefined, v\n    else unless source is undefined\n      target = source\n  target\n\nsnake_case = (source, convert=true) ->\n  target = {}\n  if is_object_literal source\n    u = if typeof convert is 'number' and convert > 0\n    then convert - 1 else convert\n    for name of source\n      src = source[name]\n      name = _snake_case(name) if convert\n      target[name] = snake_case src, u\n  else\n    target = source\n  target\n\ncompare = (el1, el2) ->\n  if is_object_literal el1\n    return false unless is_object_literal el2\n    keys1 = Object.keys(el1).sort()\n    keys2 = Object.keys(el2).sort()\n    return false unless keys1.length is keys2.length\n    for key, i in keys1\n      return false unless key is keys2[i]\n      return false unless compare el1[key], el2[key]\n  else if Array.isArray el1\n    return false unless Array.isArray el2\n    return false if el1.length isnt el2.length\n    for i in [0...el1.length]\n      return false unless compare el1[i], el2[i]\n  else\n    return false unless el1 is el2\n  true\n    \n\n_snake_case = (str) ->\n  str.replace /([A-Z])/g, (_, match, index) ->\n    '_' + match.toLowerCase()\n\nis_object = (obj) ->\n  obj and typeof obj is 'object' and not Array.isArray obj\n\nis_object_literal = (obj) ->\n  test = obj\n  if typeof obj isnt 'object' or obj is null then false else\n    return true if Object.getPrototypeOf(test) is null\n    while not false\n      break if Object.getPrototypeOf(test = Object.getPrototypeOf(test)) is null\n    return Object.getPrototypeOf(obj) is test\n\nexport {clone, compare, is_object, is_object_literal, merge, mutate, snake_case}\n", "\nimport {merge} from '../src'\n\ndescribe 'mixme.merge', ->\n\n  it 'does not alter arguments', ->\n    obj1 = a: 1, b: 2, c: 0\n    obj2 = a: 1, c: 3, d: 4\n    merge obj1, obj2\n    .should.eql a: 1, b: 2, c: 3, d: 4\n    obj1\n    .should.eql a: 1, b: 2, c: 0\n    obj2\n    .should.eql a: 1, c: 3, d: 4\n\n  it 'null prototype', ->\n    obj1 = Object.create null\n    obj1.a = 1\n    obj1.b = 2\n    obj1.c = 0\n    obj2 = a: 1, c: 3, d: 4\n    merge obj1, obj2\n    .should.eql a: 1, b: 2, c: 3, d: 4\n    {...obj1}\n    .should.eql a: 1, b: 2, c: 0\n    obj2\n    .should.eql a: 1, c: 3, d: 4\n", "\nshould = require 'should'\nimport {mutate} from '../src'\n\ndescribe 'mutate', ->\n  \n  describe 'mutation', ->\n\n    it 'enrich 1st object', ->\n      obj1 = { a: 'a value', b: 'b value', c: { d: 'd value', f: 'f value'}}\n      obj2 = { b: 'b new', c: d: 'd new'}\n      mutate obj1, obj2\n      .should.eql { a: 'a value', b: 'b new', c: { d: 'd new', f: 'f value'}}\n\n    it 'null prototype', ->\n      obj1 = Object.create null\n      obj1.a = 'a value'\n      obj1.b = 'b value'\n      obj1.c = d: 'd value', f: 'f value'\n      obj2 = b: 'b new', c: d: 'd new'\n      mutate obj1, obj2\n      should(Object.getPrototypeOf obj1).be.null()\n      {...obj1}\n      .should.eql { a: 'a value', b: 'b new', c: { d: 'd new', f: 'f value'}}\n\n  describe '2nd arg not object', ->\n    \n    it 'object with string', ->\n      obj1 = { a_key: 'a value', b_key: 'b value'}\n      obj2 = 'b'\n      result = mutate obj1, obj2\n      result.should.eql 'b'\n        \n    it 'object with undefined', ->\n      obj1 = a_key: 'a value', b_key: 'b value'\n      obj2 = undefined\n      mutate obj1, obj2\n      .should.eql a_key: 'a value', b_key: 'b value'\n        \n    it 'object with null', ->\n      obj1 = a_key: 'a value', b_key: 'b value'\n      obj2 = null\n      (mutate(obj1, obj2) is null)\n      .should.be.true()\n    \n  describe '2nd arg object', ->\n    \n    it 'is immutable', ->\n      source = a_key: 'a value', b_key: 'b value'\n      result = mutate null, source\n      source.a_key = 'new value'\n      result.a_key.should.eql 'a value'\n\n    it 'object with object', ->\n      obj1 = { a_key: 'a value', b_key: 'b value'}\n      obj2 = { b_key: 'new b value'}\n      result = mutate obj1, obj2\n      result.b_key.should.eql 'new b value'\n\n    it 'object with null', ->\n      obj1 = { a: { b: '1' } }\n      obj2 = { a: { b: null } }\n      result = mutate obj1, obj2\n      result.should.eql { a: { b: null } }\n\n    it 'object with undefined', ->\n      obj1 = { a: { b: '1' } }\n      obj2 = { a: { b: undefined } }\n      result = mutate obj1, obj2\n      result.should.eql { a: { b: '1' } }\n\n    it 'avoid infinite loop', ->\n      obj1 = { a_key: { b_key : 'b value' } }\n      obj2 = obj1\n      mutate obj1, obj2\n      obj1.a_key.b_key.should.eql 'b value'\n\n    it 'overwrite regexp value', ->\n      obj1 = { a: /.*/mg, b: { c : /.*/ } }\n      obj2 = { b: { c : /^.*$/ } }\n      res = mutate obj1, obj2\n      res.should.eql { a: /.*/mg, b: { c : /^.*$/ } }\n\n    it 'buffer with buffer', ->\n      obj1 = { a_key: Buffer.from 'abc' }\n      obj2 = { a_key: Buffer.from 'def' }\n      res = mutate obj1, obj2\n      res.a_key.toString().should.eql 'def'\n\n    it 'string with string', ->\n      obj1 = { a_key: 'abc' }\n      obj2 = { a_key: 'def' }\n      res = mutate obj1, obj2\n      res.a_key.should.eql 'def'\n\n    it 'array with object', ->\n      obj1 = ['a', 'b']\n      obj2 = {a: '1', b: '2'}\n      res = mutate obj1, obj2\n      res.should.eql {a: '1', b: '2'}\n    \n  describe 'array', ->\n    \n    it 'reference array in first argument', ->\n      obj1 = a: [1,2], b: [3,4]\n      obj2 = b: [5,6]\n      res = mutate obj1, obj2\n      res.should.eql a: [1,2], b: [5,6]\n      obj1.a.shift()\n      res.should.eql a: [2], b: [5,6]\n        \n    it 'copy array in following argument', ->\n      obj1 = a: [1,2], b: [3,4]\n      obj2 = b: [5,6]\n      obj3 = c: [7,8]\n      res = mutate obj1, obj2, obj3\n      res.should.eql a: [1,2], b: [5,6], c: [7,8]\n      obj2.b.shift()\n      obj3.c.shift()\n      res.should.eql a: [1,2], b: [5,6], c: [7,8]\n        \n    it 'array elements are cloned', ->\n      obj1 = a: null\n      obj2 = a: [b: {c: 3, d: 4}]\n      res = mutate obj1, obj2\n      obj2.a[0].b.c = 5\n      res.should.eql a: [b: {c: 3, d: 4}]\n"], "fixing_code": ["\n# Changelog\n\n## Trunk\n\n* fix: dont pollute object proto #1\n* chore: latest dependencies\n\n## Version 0.5.0\n\n* feat: support object with null prototype\n\n## Version 0.4.0\n\n* compare: new function\n\n## Version 0.3.5\n\n* readme: fix examples\n\n## Version 0.3.3\n\n* package: update adaltas url\n\n## Version 0.3.2\n\n* package: use files instead of npmignore\n\n## Version 0.3.1\n\n* mutate: immutable deep copy of object in arrays\n\n## Version 0.3.0\n\n* project: csj, esm and umd generation\n* project: ignore lock files\n\n## Version 0.2.0\n\n* snake_case: clone object with converted properties\n* merge: fix array and object merge\n* is_object_literal: new function\n\n## Version 0.1.0\n\n* clone: new function\n* readme: add author company\n\n## Version 0.1.0\n\n* package: support node version above 6\n* readme: update sample\n\n## Version 0.0.1\n\n* package: original commit\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n// Generated by CoffeeScript 2.5.1\nvar _snake_case; exports.clone = void 0; exports.compare = void 0; exports.is_object = void 0; exports.is_object_literal = void 0; exports.merge = void 0; exports.mutate = void 0; exports.snake_case = void 0;\n\nexports.merge = function merge() {\n  return exports.mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));\n};\n\nexports.clone = function clone(target) {\n  if (Array.isArray(target)) {\n    return target.map(function (element) {\n      return exports.clone(element);\n    });\n  } else if (target && _typeof(target) === 'object') {\n    return exports.mutate({}, target);\n  } else {\n    return target;\n  }\n};\n\nexports.mutate = function mutate() {\n  var i, j, name, ref, source, target, v;\n  target = arguments[0];\n\n  for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n    source = arguments[i];\n\n    if (exports.is_object_literal(source)) {\n      if (!exports.is_object_literal(target)) {\n        target = {};\n      }\n\n      for (name in source) {\n        if (name === '__proto__') {\n          continue;\n        }\n\n        target[name] = exports.mutate(target[name], source[name]);\n      }\n    } else if (Array.isArray(source)) {\n      target = function () {\n        var k, len, results;\n        results = [];\n\n        for (k = 0, len = source.length; k < len; k++) {\n          v = source[k];\n          results.push(exports.mutate(void 0, v));\n        }\n\n        return results;\n      }();\n    } else if (source !== void 0) {\n      target = source;\n    }\n  }\n\n  return target;\n};\n\nexports.snake_case = function snake_case(source) {\n  var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var name, src, target, u;\n  target = {};\n\n  if (exports.is_object_literal(source)) {\n    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n\n    for (name in source) {\n      src = source[name];\n\n      if (convert) {\n        name = _snake_case(name);\n      }\n\n      target[name] = exports.snake_case(src, u);\n    }\n  } else {\n    target = source;\n  }\n\n  return target;\n};\n\nexports.compare = function compare(el1, el2) {\n  var i, j, k, key, keys1, keys2, len, ref;\n\n  if (exports.is_object_literal(el1)) {\n    if (!exports.is_object_literal(el2)) {\n      return false;\n    }\n\n    keys1 = Object.keys(el1).sort();\n    keys2 = Object.keys(el2).sort();\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n      key = keys1[i];\n\n      if (key !== keys2[i]) {\n        return false;\n      }\n\n      if (!exports.compare(el1[key], el2[key])) {\n        return false;\n      }\n    }\n  } else if (Array.isArray(el1)) {\n    if (!Array.isArray(el2)) {\n      return false;\n    }\n\n    if (el1.length !== el2.length) {\n      return false;\n    }\n\n    for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n      if (!exports.compare(el1[i], el2[i])) {\n        return false;\n      }\n    }\n  } else {\n    if (el1 !== el2) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n_snake_case = function _snake_case(str) {\n  return str.replace(/([A-Z])/g, function (_, match, index) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nexports.is_object = function is_object(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n};\n\nexports.is_object_literal = function is_object_literal(obj) {\n  var test;\n  test = obj;\n\n  if (_typeof(obj) !== 'object' || obj === null) {\n    return false;\n  } else {\n    if (Object.getPrototypeOf(test) === null) {\n      return true;\n    }\n\n    while (!false) {\n      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n        break;\n      }\n    }\n\n    return Object.getPrototypeOf(obj) === test;\n  }\n};\n", "function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n// Generated by CoffeeScript 2.5.1\nvar _snake_case, _clone, _compare, is_object, is_object_literal, merge, _mutate, _snake_case2;\n\nmerge = function merge() {\n  return _mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));\n};\n\n_clone = function clone(target) {\n  if (Array.isArray(target)) {\n    return target.map(function (element) {\n      return _clone(element);\n    });\n  } else if (target && _typeof(target) === 'object') {\n    return _mutate({}, target);\n  } else {\n    return target;\n  }\n};\n\n_mutate = function mutate() {\n  var i, j, name, ref, source, target, v;\n  target = arguments[0];\n\n  for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n    source = arguments[i];\n\n    if (is_object_literal(source)) {\n      if (!is_object_literal(target)) {\n        target = {};\n      }\n\n      for (name in source) {\n        if (name === '__proto__') {\n          continue;\n        }\n\n        target[name] = _mutate(target[name], source[name]);\n      }\n    } else if (Array.isArray(source)) {\n      target = function () {\n        var k, len, results;\n        results = [];\n\n        for (k = 0, len = source.length; k < len; k++) {\n          v = source[k];\n          results.push(_mutate(void 0, v));\n        }\n\n        return results;\n      }();\n    } else if (source !== void 0) {\n      target = source;\n    }\n  }\n\n  return target;\n};\n\n_snake_case2 = function snake_case(source) {\n  var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var name, src, target, u;\n  target = {};\n\n  if (is_object_literal(source)) {\n    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n\n    for (name in source) {\n      src = source[name];\n\n      if (convert) {\n        name = _snake_case(name);\n      }\n\n      target[name] = _snake_case2(src, u);\n    }\n  } else {\n    target = source;\n  }\n\n  return target;\n};\n\n_compare = function compare(el1, el2) {\n  var i, j, k, key, keys1, keys2, len, ref;\n\n  if (is_object_literal(el1)) {\n    if (!is_object_literal(el2)) {\n      return false;\n    }\n\n    keys1 = Object.keys(el1).sort();\n    keys2 = Object.keys(el2).sort();\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n      key = keys1[i];\n\n      if (key !== keys2[i]) {\n        return false;\n      }\n\n      if (!_compare(el1[key], el2[key])) {\n        return false;\n      }\n    }\n  } else if (Array.isArray(el1)) {\n    if (!Array.isArray(el2)) {\n      return false;\n    }\n\n    if (el1.length !== el2.length) {\n      return false;\n    }\n\n    for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n      if (!_compare(el1[i], el2[i])) {\n        return false;\n      }\n    }\n  } else {\n    if (el1 !== el2) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n_snake_case = function _snake_case(str) {\n  return str.replace(/([A-Z])/g, function (_, match, index) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nis_object = function is_object(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n};\n\nis_object_literal = function is_object_literal(obj) {\n  var test;\n  test = obj;\n\n  if (_typeof(obj) !== 'object' || obj === null) {\n    return false;\n  } else {\n    if (Object.getPrototypeOf(test) === null) {\n      return true;\n    }\n\n    while (!false) {\n      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n        break;\n      }\n    }\n\n    return Object.getPrototypeOf(obj) === test;\n  }\n};\n\nexport { _clone as clone, _compare as compare, is_object, is_object_literal, merge, _mutate as mutate, _snake_case2 as snake_case };\n", "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mixme = {}));\n}(this, (function (exports) { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  // Generated by CoffeeScript 2.5.1\n  var _snake_case; exports.clone = void 0; exports.compare = void 0; exports.is_object = void 0; exports.is_object_literal = void 0; exports.merge = void 0; exports.mutate = void 0; exports.snake_case = void 0;\n\n  exports.merge = function merge() {\n    return exports.mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));\n  };\n\n  exports.clone = function clone(target) {\n    if (Array.isArray(target)) {\n      return target.map(function (element) {\n        return exports.clone(element);\n      });\n    } else if (target && _typeof(target) === 'object') {\n      return exports.mutate({}, target);\n    } else {\n      return target;\n    }\n  };\n\n  exports.mutate = function mutate() {\n    var i, j, name, ref, source, target, v;\n    target = arguments[0];\n\n    for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n      source = arguments[i];\n\n      if (exports.is_object_literal(source)) {\n        if (!exports.is_object_literal(target)) {\n          target = {};\n        }\n\n        for (name in source) {\n          if (name === '__proto__') {\n            continue;\n          }\n\n          target[name] = exports.mutate(target[name], source[name]);\n        }\n      } else if (Array.isArray(source)) {\n        target = function () {\n          var k, len, results;\n          results = [];\n\n          for (k = 0, len = source.length; k < len; k++) {\n            v = source[k];\n            results.push(exports.mutate(void 0, v));\n          }\n\n          return results;\n        }();\n      } else if (source !== void 0) {\n        target = source;\n      }\n    }\n\n    return target;\n  };\n\n  exports.snake_case = function snake_case(source) {\n    var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var name, src, target, u;\n    target = {};\n\n    if (exports.is_object_literal(source)) {\n      u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n\n      for (name in source) {\n        src = source[name];\n\n        if (convert) {\n          name = _snake_case(name);\n        }\n\n        target[name] = exports.snake_case(src, u);\n      }\n    } else {\n      target = source;\n    }\n\n    return target;\n  };\n\n  exports.compare = function compare(el1, el2) {\n    var i, j, k, key, keys1, keys2, len, ref;\n\n    if (exports.is_object_literal(el1)) {\n      if (!exports.is_object_literal(el2)) {\n        return false;\n      }\n\n      keys1 = Object.keys(el1).sort();\n      keys2 = Object.keys(el2).sort();\n\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n\n      for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n        key = keys1[i];\n\n        if (key !== keys2[i]) {\n          return false;\n        }\n\n        if (!exports.compare(el1[key], el2[key])) {\n          return false;\n        }\n      }\n    } else if (Array.isArray(el1)) {\n      if (!Array.isArray(el2)) {\n        return false;\n      }\n\n      if (el1.length !== el2.length) {\n        return false;\n      }\n\n      for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        if (!exports.compare(el1[i], el2[i])) {\n          return false;\n        }\n      }\n    } else {\n      if (el1 !== el2) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _snake_case = function _snake_case(str) {\n    return str.replace(/([A-Z])/g, function (_, match, index) {\n      return '_' + match.toLowerCase();\n    });\n  };\n\n  exports.is_object = function is_object(obj) {\n    return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n  };\n\n  exports.is_object_literal = function is_object_literal(obj) {\n    var test;\n    test = obj;\n\n    if (_typeof(obj) !== 'object' || obj === null) {\n      return false;\n    } else {\n      if (Object.getPrototypeOf(test) === null) {\n        return true;\n      }\n\n      while (!false) {\n        if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n          break;\n        }\n      }\n\n      return Object.getPrototypeOf(obj) === test;\n    }\n  };\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n", "// Generated by CoffeeScript 2.5.1\nvar _snake_case, clone, compare, is_object, is_object_literal, merge, mutate, snake_case;\n\nmerge = function() {\n  return mutate({}, ...arguments);\n};\n\nclone = function(target) {\n  if (Array.isArray(target)) {\n    return target.map(function(element) {\n      return clone(element);\n    });\n  } else if (target && typeof target === 'object') {\n    return mutate({}, target);\n  } else {\n    return target;\n  }\n};\n\nmutate = function() {\n  var i, j, name, ref, source, target, v;\n  target = arguments[0];\n  for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {\n    source = arguments[i];\n    if (is_object_literal(source)) {\n      if (!is_object_literal(target)) {\n        target = {};\n      }\n      for (name in source) {\n        if (name === '__proto__') {\n          continue;\n        }\n        target[name] = mutate(target[name], source[name]);\n      }\n    } else if (Array.isArray(source)) {\n      target = (function() {\n        var k, len, results;\n        results = [];\n        for (k = 0, len = source.length; k < len; k++) {\n          v = source[k];\n          results.push(mutate(void 0, v));\n        }\n        return results;\n      })();\n    } else if (source !== void 0) {\n      target = source;\n    }\n  }\n  return target;\n};\n\nsnake_case = function(source, convert = true) {\n  var name, src, target, u;\n  target = {};\n  if (is_object_literal(source)) {\n    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;\n    for (name in source) {\n      src = source[name];\n      if (convert) {\n        name = _snake_case(name);\n      }\n      target[name] = snake_case(src, u);\n    }\n  } else {\n    target = source;\n  }\n  return target;\n};\n\ncompare = function(el1, el2) {\n  var i, j, k, key, keys1, keys2, len, ref;\n  if (is_object_literal(el1)) {\n    if (!is_object_literal(el2)) {\n      return false;\n    }\n    keys1 = Object.keys(el1).sort();\n    keys2 = Object.keys(el2).sort();\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    for (i = j = 0, len = keys1.length; j < len; i = ++j) {\n      key = keys1[i];\n      if (key !== keys2[i]) {\n        return false;\n      }\n      if (!compare(el1[key], el2[key])) {\n        return false;\n      }\n    }\n  } else if (Array.isArray(el1)) {\n    if (!Array.isArray(el2)) {\n      return false;\n    }\n    if (el1.length !== el2.length) {\n      return false;\n    }\n    for (i = k = 0, ref = el1.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {\n      if (!compare(el1[i], el2[i])) {\n        return false;\n      }\n    }\n  } else {\n    if (el1 !== el2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n_snake_case = function(str) {\n  return str.replace(/([A-Z])/g, function(_, match, index) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nis_object = function(obj) {\n  return obj && typeof obj === 'object' && !Array.isArray(obj);\n};\n\nis_object_literal = function(obj) {\n  var test;\n  test = obj;\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  } else {\n    if (Object.getPrototypeOf(test) === null) {\n      return true;\n    }\n    while (!false) {\n      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {\n        break;\n      }\n    }\n    return Object.getPrototypeOf(obj) === test;\n  }\n};\n\nexport {\n  clone,\n  compare,\n  is_object,\n  is_object_literal,\n  merge,\n  mutate,\n  snake_case\n};\n", "\n\nmerge = ->\n  mutate {}, arguments...\n\nclone = (target) ->\n  if Array.isArray target\n    target.map (element) ->\n      clone element\n  else if target and typeof target is 'object'\n    mutate {}, target\n  else\n    target\n\nmutate = ->\n  target = arguments[0]\n  for i in [1 ... arguments.length]\n    source = arguments[i]\n    if is_object_literal source\n      target = {} unless is_object_literal target\n      for name of source\n        continue if name is '__proto__'\n        target[name] = mutate target[name], source[name]\n    else if Array.isArray source\n      target = for v in source\n        mutate undefined, v\n    else unless source is undefined\n      target = source\n  target\n\nsnake_case = (source, convert=true) ->\n  target = {}\n  if is_object_literal source\n    u = if typeof convert is 'number' and convert > 0\n    then convert - 1 else convert\n    for name of source\n      src = source[name]\n      name = _snake_case(name) if convert\n      target[name] = snake_case src, u\n  else\n    target = source\n  target\n\ncompare = (el1, el2) ->\n  if is_object_literal el1\n    return false unless is_object_literal el2\n    keys1 = Object.keys(el1).sort()\n    keys2 = Object.keys(el2).sort()\n    return false unless keys1.length is keys2.length\n    for key, i in keys1\n      return false unless key is keys2[i]\n      return false unless compare el1[key], el2[key]\n  else if Array.isArray el1\n    return false unless Array.isArray el2\n    return false if el1.length isnt el2.length\n    for i in [0...el1.length]\n      return false unless compare el1[i], el2[i]\n  else\n    return false unless el1 is el2\n  true\n    \n\n_snake_case = (str) ->\n  str.replace /([A-Z])/g, (_, match, index) ->\n    '_' + match.toLowerCase()\n\nis_object = (obj) ->\n  obj and typeof obj is 'object' and not Array.isArray obj\n\nis_object_literal = (obj) ->\n  test = obj\n  if typeof obj isnt 'object' or obj is null then false else\n    return true if Object.getPrototypeOf(test) is null\n    while not false\n      break if Object.getPrototypeOf(test = Object.getPrototypeOf(test)) is null\n    return Object.getPrototypeOf(obj) is test\n\nexport {clone, compare, is_object, is_object_literal, merge, mutate, snake_case}\n", "\nimport {merge} from '../src'\n\ndescribe 'mixme.merge', ->\n\n  it 'does not alter arguments', ->\n    obj1 = a: 1, b: 2, c: 0\n    obj2 = a: 1, c: 3, d: 4\n    merge obj1, obj2\n    .should.eql a: 1, b: 2, c: 3, d: 4\n    obj1\n    .should.eql a: 1, b: 2, c: 0\n    obj2\n    .should.eql a: 1, c: 3, d: 4\n\n  it 'null prototype', ->\n    obj1 = Object.create null\n    obj1.a = 1\n    obj1.b = 2\n    obj1.c = 0\n    obj2 = a: 1, c: 3, d: 4\n    merge obj1, obj2\n    .should.eql a: 1, b: 2, c: 3, d: 4\n    {...obj1}\n    .should.eql a: 1, b: 2, c: 0\n    obj2\n    .should.eql a: 1, c: 3, d: 4\n\n  it 'dont merge proto', ->\n    merge {}, JSON.parse '{\"__proto__\": {\"polluted\": \"ohno\"}}'\n    obj = Object.create {}\n    should(obj.polluted).be.Undefined()\n", "\nshould = require 'should'\nimport {mutate} from '../src'\n\ndescribe 'mutate', ->\n  \n  describe 'mutation', ->\n\n    it 'enrich 1st object', ->\n      obj1 = { a: 'a value', b: 'b value', c: { d: 'd value', f: 'f value'}}\n      obj2 = { b: 'b new', c: d: 'd new'}\n      mutate obj1, obj2\n      .should.eql { a: 'a value', b: 'b new', c: { d: 'd new', f: 'f value'}}\n\n    it 'null prototype', ->\n      obj1 = Object.create null\n      obj1.a = 'a value'\n      obj1.b = 'b value'\n      obj1.c = d: 'd value', f: 'f value'\n      obj2 = b: 'b new', c: d: 'd new'\n      mutate obj1, obj2\n      should(Object.getPrototypeOf obj1).be.null()\n      {...obj1}\n      .should.eql { a: 'a value', b: 'b new', c: { d: 'd new', f: 'f value'}}\n\n    it 'dont merge proto', ->\n      src = {}\n      mutate src, JSON.parse '{\"__proto__\": {\"polluted\": \"ohno\"}}'\n      obj = Object.create {}\n      should(obj.polluted).be.Undefined()\n\n  describe '2nd arg not object', ->\n    \n    it 'object with string', ->\n      obj1 = { a_key: 'a value', b_key: 'b value'}\n      obj2 = 'b'\n      result = mutate obj1, obj2\n      result.should.eql 'b'\n        \n    it 'object with undefined', ->\n      obj1 = a_key: 'a value', b_key: 'b value'\n      obj2 = undefined\n      mutate obj1, obj2\n      .should.eql a_key: 'a value', b_key: 'b value'\n        \n    it 'object with null', ->\n      obj1 = a_key: 'a value', b_key: 'b value'\n      obj2 = null\n      (mutate(obj1, obj2) is null)\n      .should.be.true()\n    \n  describe '2nd arg object', ->\n    \n    it 'is immutable', ->\n      source = a_key: 'a value', b_key: 'b value'\n      result = mutate null, source\n      source.a_key = 'new value'\n      result.a_key.should.eql 'a value'\n\n    it 'object with object', ->\n      obj1 = { a_key: 'a value', b_key: 'b value'}\n      obj2 = { b_key: 'new b value'}\n      result = mutate obj1, obj2\n      result.b_key.should.eql 'new b value'\n\n    it 'object with null', ->\n      obj1 = { a: { b: '1' } }\n      obj2 = { a: { b: null } }\n      result = mutate obj1, obj2\n      result.should.eql { a: { b: null } }\n\n    it 'object with undefined', ->\n      obj1 = { a: { b: '1' } }\n      obj2 = { a: { b: undefined } }\n      result = mutate obj1, obj2\n      result.should.eql { a: { b: '1' } }\n\n    it 'avoid infinite loop', ->\n      obj1 = { a_key: { b_key : 'b value' } }\n      obj2 = obj1\n      mutate obj1, obj2\n      obj1.a_key.b_key.should.eql 'b value'\n\n    it 'overwrite regexp value', ->\n      obj1 = { a: /.*/mg, b: { c : /.*/ } }\n      obj2 = { b: { c : /^.*$/ } }\n      res = mutate obj1, obj2\n      res.should.eql { a: /.*/mg, b: { c : /^.*$/ } }\n\n    it 'buffer with buffer', ->\n      obj1 = { a_key: Buffer.from 'abc' }\n      obj2 = { a_key: Buffer.from 'def' }\n      res = mutate obj1, obj2\n      res.a_key.toString().should.eql 'def'\n\n    it 'string with string', ->\n      obj1 = { a_key: 'abc' }\n      obj2 = { a_key: 'def' }\n      res = mutate obj1, obj2\n      res.a_key.should.eql 'def'\n\n    it 'array with object', ->\n      obj1 = ['a', 'b']\n      obj2 = {a: '1', b: '2'}\n      res = mutate obj1, obj2\n      res.should.eql {a: '1', b: '2'}\n    \n  describe 'array', ->\n    \n    it 'reference array in first argument', ->\n      obj1 = a: [1,2], b: [3,4]\n      obj2 = b: [5,6]\n      res = mutate obj1, obj2\n      res.should.eql a: [1,2], b: [5,6]\n      obj1.a.shift()\n      res.should.eql a: [2], b: [5,6]\n        \n    it 'copy array in following argument', ->\n      obj1 = a: [1,2], b: [3,4]\n      obj2 = b: [5,6]\n      obj3 = c: [7,8]\n      res = mutate obj1, obj2, obj3\n      res.should.eql a: [1,2], b: [5,6], c: [7,8]\n      obj2.b.shift()\n      obj3.c.shift()\n      res.should.eql a: [1,2], b: [5,6], c: [7,8]\n        \n    it 'array elements are cloned', ->\n      obj1 = a: null\n      obj2 = a: [b: {c: 3, d: 4}]\n      res = mutate obj1, obj2\n      obj2.a[0].b.c = 5\n      res.should.eql a: [b: {c: 3, d: 4}]\n"], "filenames": ["CHANGELOG.md", "dist/mixme.cjs.js", "dist/mixme.esm.js", "dist/mixme.umd.js", "lib/index.js", "src/index.coffee", "test/merge.coffee", "test/mutate.coffee"], "buggy_code_start_loc": [2, 22, 48, 24, 29, 21, 27, 24], "buggy_code_end_loc": [2, 52, 48, 54, 29, 21, 27, 24], "fixing_code_start_loc": [3, 22, 49, 24, 30, 22, 28, 25], "fixing_code_end_loc": [8, 57, 53, 59, 33, 23, 33, 31], "type": "CWE-1321", "message": "In Node.js mixme, prior to v0.5.1, an attacker can add or alter properties of an object via '__proto__' through the mutate() and merge() functions. The polluted attribute will be directly assigned to every object in the program. This will put the availability of the program at risk causing a potential denial of service (DoS).", "other": {"cve": {"id": "CVE-2021-28860", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-03T12:15:07.467", "lastModified": "2021-12-10T18:55:23.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Node.js mixme, prior to v0.5.1, an attacker can add or alter properties of an object via '__proto__' through the mutate() and merge() functions. The polluted attribute will be directly assigned to every object in the program. This will put the availability of the program at risk causing a potential denial of service (DoS)."}, {"lang": "es", "value": "En Node.js mixme, antes de la versi\u00f3n v0.5.1, un atacante puede agregar o alterar las propiedades de un objeto por medio de \"__proto__\" por medio de las funciones mutate() y merge(). El atributo contaminado se asignar\u00e1 directamente a cada objeto del programa. Esto pondr\u00e1 en riesgo la disponibilidad del programa y provocar\u00e1 una potencial denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:adaltas:mixme:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.5.1", "matchCriteriaId": "D3B742DF-38E8-406C-BA55-3238A57DC138"}]}]}], "references": [{"url": "http://nodejs.com", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/adaltas/node-mixme/commit/cfd5fbfc32368bcf7e06d1c5985ea60e34cd4028", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/adaltas/node-mixme/issues/1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/adaltas/node-mixme/security/advisories/GHSA-79jw-6wg7-r9g4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210618-0005/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/~david", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/adaltas/node-mixme/commit/cfd5fbfc32368bcf7e06d1c5985ea60e34cd4028"}}