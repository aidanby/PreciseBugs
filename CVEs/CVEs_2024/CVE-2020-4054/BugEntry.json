{"buggy_code": ["Sanitize\n========\n\nSanitize is an allowlist-based HTML and CSS sanitizer. It removes all HTML\nand/or CSS from a string except the elements, attributes, and properties you\nchoose to allow.\n\nUsing a simple configuration syntax, you can tell Sanitize to allow certain HTML\nelements, certain attributes within those elements, and even certain URL\nprotocols within attributes that contain URLs. You can also allow specific CSS\nproperties, @ rules, and URL protocols in elements or attributes containing CSS.\nAny HTML or CSS that you don't explicitly allow will be removed.\n\nSanitize is based on [Google's Gumbo HTML5 parser][gumbo], which parses HTML\nexactly the same way modern browsers do, and [Crass][crass], which parses CSS\nexactly the same way modern browsers do. As long as your allowlist config only\nallows safe markup and CSS, even the most malformed or malicious input will be\ntransformed into safe output.\n\n[![Build Status](https://travis-ci.org/rgrove/sanitize.svg?branch=master)](https://travis-ci.org/rgrove/sanitize)\n[![Gem Version](https://badge.fury.io/rb/sanitize.svg)](http://badge.fury.io/rb/sanitize)\n\n[crass]:https://github.com/rgrove/crass\n[gumbo]:https://github.com/google/gumbo-parser\n\nLinks\n-----\n\n* [Home](https://github.com/rgrove/sanitize/)\n* [API Docs](http://rubydoc.info/github/rgrove/sanitize/master)\n* [Issues](https://github.com/rgrove/sanitize/issues)\n* [Release History](https://github.com/rgrove/sanitize/blob/master/HISTORY.md#sanitize-history)\n* [Online Demo](https://sanitize.herokuapp.com/)\n* [Biased comparison of Ruby HTML sanitization libraries](https://github.com/rgrove/sanitize/blob/master/COMPARISON.md)\n\nInstallation\n-------------\n\n```\ngem install sanitize\n```\n\nQuick Start\n-----------\n\n```ruby\nrequire 'sanitize'\n\n# Clean up an HTML fragment using Sanitize's permissive but safe Relaxed config.\n# This also sanitizes any CSS in `<style>` elements or `style` attributes.\nSanitize.fragment(html, Sanitize::Config::RELAXED)\n\n# Clean up an HTML document using the Relaxed config.\nSanitize.document(html, Sanitize::Config::RELAXED)\n\n# Clean up a standalone CSS stylesheet using the Relaxed config.\nSanitize::CSS.stylesheet(css, Sanitize::Config::RELAXED)\n\n# Clean up some CSS properties using the Relaxed config.\nSanitize::CSS.properties(css, Sanitize::Config::RELAXED)\n```\n\nUsage\n-----\n\nSanitize can sanitize the following types of input:\n\n* HTML fragments\n* HTML documents\n* CSS stylesheets inside HTML `<style>` elements\n* CSS properties inside HTML `style` attributes\n* Standalone CSS stylesheets\n* Standalone CSS properties\n\n### HTML Fragments\n\nA fragment is a snippet of HTML that doesn't contain a root-level `<html>`\nelement.\n\nIf you don't specify any configuration options, Sanitize will use its strictest\nsettings by default, which means it will strip all HTML and leave only safe text\nbehind.\n\n```ruby\nhtml = '<b><a href=\"http://foo.com/\">foo</a></b><img src=\"bar.jpg\">'\nSanitize.fragment(html)\n# => 'foo'\n```\n\nTo keep certain elements, add them to the element allowlist.\n\n```ruby\nSanitize.fragment(html, :elements => ['b'])\n# => '<b>foo</b>'\n```\n\n### HTML Documents\n\nWhen sanitizing a document, the `<html>` element must be allowlisted. You can\nalso set `:allow_doctype` to `true` to allow well-formed document type\ndefinitions.\n\n```ruby\nhtml = %[\n  <!DOCTYPE html>\n  <html>\n    <b><a href=\"http://foo.com/\">foo</a></b><img src=\"bar.jpg\">\n  </html>\n]\n\nSanitize.document(html,\n  :allow_doctype => true,\n  :elements      => ['html']\n)\n# => %[\n#   <!DOCTYPE html>\n#   <html>foo\n#\n#   </html>\n# ]\n```\n\n### CSS in HTML\n\nTo sanitize CSS in an HTML fragment or document, first allowlist the `<style>`\nelement and/or the `style` attribute. Then allowlist the CSS properties,\n@ rules, and URL protocols you wish to allow. You can also choose whether to\nallow CSS comments or browser compatibility hacks.\n\n```ruby\nhtml = %[\n  <style>\n    div { color: green; width: 1024px; }\n  </style>\n\n  <div style=\"height: 100px; width: 100px;\"></div>\n  <p>hello!</p>\n]\n\nSanitize.fragment(html,\n  :elements   => ['div', 'style'],\n  :attributes => {'div' => ['style']},\n\n  :css => {\n    :properties => ['width']\n  }\n)\n#=> %[\n#   <style>\n#     div {  width: 1024px; }\n#   </style>\n#\n#   <div style=\" width: 100px;\"></div>\n#   hello!\n# ]\n```\n\n### Standalone CSS\n\nSanitize will happily clean up a standalone CSS stylesheet or property string\nwithout needing to invoke the HTML parser.\n\n```ruby\ncss = %[\n  @import url(evil.css);\n\n  a { text-decoration: none; }\n\n  a:hover {\n    left: expression(alert('xss!'));\n    text-decoration: underline;\n  }\n]\n\nSanitize::CSS.stylesheet(css, Sanitize::Config::RELAXED)\n# => %[\n#\n#\n#\n#   a { text-decoration: none; }\n#\n#   a:hover {\n#\n#     text-decoration: underline;\n#   }\n# ]\n\nSanitize::CSS.properties(%[\n  left: expression(alert('xss!'));\n  text-decoration: underline;\n], Sanitize::Config::RELAXED)\n# => %[\n#\n#   text-decoration: underline;\n# ]\n\n```\n\nConfiguration\n-------------\n\nIn addition to the ultra-safe default settings, Sanitize comes with three other\nbuilt-in configurations that you can use out of the box or adapt to meet your\nneeds.\n\n### Sanitize::Config::RESTRICTED\n\nAllows only very simple inline markup. No links, images, or block elements.\n\n```ruby\nSanitize.fragment(html, Sanitize::Config::RESTRICTED)\n# => '<b>foo</b>'\n```\n\n### Sanitize::Config::BASIC\n\nAllows a variety of markup including formatting elements, links, and lists.\n\nImages and tables are not allowed, links are limited to FTP, HTTP, HTTPS, and\nmailto protocols, and a `rel=\"nofollow\"` attribute is added to all links to\nmitigate SEO spam.\n\n```ruby\nSanitize.fragment(html, Sanitize::Config::BASIC)\n# => '<b><a href=\"http://foo.com/\" rel=\"nofollow\">foo</a></b>'\n```\n\n### Sanitize::Config::RELAXED\n\nAllows an even wider variety of markup, including images and tables, as well as\nsafe CSS. Links are still limited to FTP, HTTP, HTTPS, and mailto protocols,\nwhile images are limited to HTTP and HTTPS. In this mode, `rel=\"nofollow\"` is\nnot added to links.\n\n```ruby\nSanitize.fragment(html, Sanitize::Config::RELAXED)\n# => '<b><a href=\"http://foo.com/\">foo</a></b><img src=\"bar.jpg\">'\n```\n\n### Custom Configuration\n\nIf the built-in modes don't meet your needs, you can easily specify a custom\nconfiguration:\n\n```ruby\nSanitize.fragment(html,\n  :elements => ['a', 'span'],\n\n  :attributes => {\n    'a'    => ['href', 'title'],\n    'span' => ['class']\n  },\n\n  :protocols => {\n    'a' => {'href' => ['http', 'https', 'mailto']}\n  }\n)\n```\n\nYou can also start with one of Sanitize's built-in configurations and then\ncustomize it to meet your needs.\n\nThe built-in configs are deeply frozen to prevent people from modifying them\n(either accidentally or maliciously). To customize a built-in config, create a\nnew copy using `Sanitize::Config.merge()`, like so:\n\n```ruby\n# Create a customized copy of the Basic config, adding <div> and <table> to the\n# existing allowlisted elements.\nSanitize.fragment(html, Sanitize::Config.merge(Sanitize::Config::BASIC,\n  :elements        => Sanitize::Config::BASIC[:elements] + ['div', 'table'],\n  :remove_contents => true\n))\n```\n\nThe example above adds the `<div>` and `<table>` elements to a copy of the\nexisting list of elements in `Sanitize::Config::BASIC`. If you instead want to\ncompletely overwrite the elements array with your own, you can omit the `+`\noperation:\n\n```ruby\n# Overwrite :elements instead of creating a copy with new entries.\nSanitize.fragment(html, Sanitize::Config.merge(Sanitize::Config::BASIC,\n  :elements        => ['div', 'table'],\n  :remove_contents => true\n))\n```\n\n### Config Settings\n\n#### :add_attributes (Hash)\n\nAttributes to add to specific elements. If the attribute already exists, it will\nbe replaced with the value specified here. Specify all element names and\nattributes in lowercase.\n\n```ruby\n:add_attributes => {\n  'a' => {'rel' => 'nofollow'}\n}\n```\n\n#### :allow_comments (boolean)\n\nWhether or not to allow HTML comments. Allowing comments is strongly\ndiscouraged, since IE allows script execution within conditional comments. The\ndefault value is `false`.\n\n#### :allow_doctype (boolean)\n\nWhether or not to allow well-formed HTML doctype declarations such as \"<!DOCTYPE\nhtml>\" when sanitizing a document. This setting is ignored when sanitizing\nfragments. The default value is `false`.\n\n#### :attributes (Hash)\n\nAttributes to allow on specific elements. Specify all element names and\nattributes in lowercase.\n\n```ruby\n:attributes => {\n  'a'          => ['href', 'title'],\n  'blockquote' => ['cite'],\n  'img'        => ['alt', 'src', 'title']\n}\n```\n\nIf you'd like to allow certain attributes on all elements, use the symbol `:all`\ninstead of an element name.\n\n```ruby\n# Allow the class attribute on all elements.\n:attributes => {\n  :all => ['class'],\n  'a'  => ['href', 'title']\n}\n```\n\nTo allow arbitrary HTML5 `data-*` attributes, use the symbol `:data` in place of\nan attribute name.\n\n```ruby\n# Allow arbitrary HTML5 data-* attributes on <div> elements.\n:attributes => {\n  'div' => [:data]\n}\n```\n\n#### :css (Hash)\n\nHash of the following CSS config settings to be used when sanitizing CSS (either\nstandalone or embedded in HTML).\n\n##### :css => :allow_comments (boolean)\n\nWhether or not to allow CSS comments. The default value is `false`.\n\n##### :css => :allow_hacks (boolean)\n\nWhether or not to allow browser compatibility hacks such as the IE `*` and `_`\nhacks. These are generally harmless, but technically result in invalid CSS. The\ndefault is `false`.\n\n##### :css => :at_rules (Array or Set)\n\nNames of CSS [at-rules][at-rules] to allow that may not have associated blocks,\nsuch as `import` or `charset`. Names should be specified in lowercase.\n\n[at-rules]:https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n\n##### :css => :at_rules_with_properties (Array or Set)\n\nNames of CSS [at-rules][at-rules] to allow that may have associated blocks\ncontaining CSS properties. At-rules like `font-face` and `page` fall into this\ncategory. Names should be specified in lowercase.\n\n##### :css => :at_rules_with_styles (Array or Set)\n\nNames of CSS [at-rules][at-rules] to allow that may have associated blocks\ncontaining style rules. At-rules like `media` and `keyframes` fall into this\ncategory. Names should be specified in lowercase.\n\n##### :css => :import_url_validator\n\nThis is a `Proc` (or other callable object) that will be called and passed\nthe URL specified for any `@import` [at-rules][at-rules].\n\nYou can use this to limit what can be imported, for example something\nlike the following to limit `@import` to Google Fonts URLs:\n\n```ruby\nProc.new { |url| url.start_with?(\"https://fonts.googleapis.com\") }\n```\n\n##### :css => :properties (Array or Set)\n\nList of CSS property names to allow. Names should be specified in lowercase.\n\n##### :css => :protocols (Array or Set)\n\nURL protocols to allow in CSS URLs. Should be specified in lowercase.\n\nIf you'd like to allow the use of relative URLs which don't have a protocol,\ninclude the symbol `:relative` in the protocol array.\n\n#### :elements (Array or Set)\n\nArray of HTML element names to allow. Specify all names in lowercase. Any\nelements not in this array will be removed.\n\n```ruby\n:elements => %w[\n  a abbr b blockquote br cite code dd dfn dl dt em i kbd li mark ol p pre\n  q s samp small strike strong sub sup time u ul var\n]\n```\n\n#### :parser_options (Hash)\n\n[Parsing options](https://github.com/rubys/nokogumbo/tree/v2.0.1#parsing-options) supplied to `nokogumbo`.\n\n```ruby\n:parser_options => {\n  max_errors: -1,\n  max_tree_depth: -1\n}\n```\n\n#### :protocols (Hash)\n\nURL protocols to allow in specific attributes. If an attribute is listed here\nand contains a protocol other than those specified (or if it contains no\nprotocol at all), it will be removed.\n\n```ruby\n:protocols => {\n  'a'   => {'href' => ['ftp', 'http', 'https', 'mailto']},\n  'img' => {'src'  => ['http', 'https']}\n}\n```\n\nIf you'd like to allow the use of relative URLs which don't have a protocol,\ninclude the symbol `:relative` in the protocol array:\n\n```ruby\n:protocols => {\n  'a' => {'href' => ['http', 'https', :relative]}\n}\n```\n\n#### :remove_contents (boolean or Array or Set)\n\nIf this is `true`, Sanitize will remove the contents of any non-allowlisted\nelements in addition to the elements themselves. By default, Sanitize leaves the\nsafe parts of an element's contents behind when the element is removed.\n\nIf this is an Array or Set of element names, then only the contents of the\nspecified elements (when filtered) will be removed, and the contents of all\nother filtered elements will be left behind.\n\nThe default value is `false`.\n\n#### :transformers (Array or callable)\n\nCustom HTML transformer or array of custom transformers. See the Transformers\nsection below for details.\n\n#### :whitespace_elements (Hash)\n\nHash of element names which, when removed, should have their contents surrounded\nby whitespace to preserve readability.\n\nEach element name is a key pointing to another Hash, which provides the specific\nwhitespace that should be inserted `:before` and `:after` the removed element's\nposition. The `:after` value will only be inserted if the removed element has\nchildren, in which case it will be inserted after those children.\n\n```ruby\n:whitespace_elements => {\n  'br'  => { :before => \"\\n\", :after => \"\" },\n  'div' => { :before => \"\\n\", :after => \"\\n\" },\n  'p'   => { :before => \"\\n\", :after => \"\\n\" }\n}\n```\n\nThe default elements with whitespace added before and after are:\n\n```\naddress article aside blockquote br dd div dl dt\nfooter h1 h2 h3 h4 h5 h6 header hgroup hr li nav\nol p pre section ul\n\n```\n\n## Transformers\n\nTransformers allow you to filter and modify HTML nodes using your own custom\nlogic, on top of (or instead of) Sanitize's core filter. A transformer is any\nobject that responds to `call()` (such as a lambda or proc).\n\nTo use one or more transformers, pass them to the `:transformers` config\nsetting. You may pass a single transformer or an array of transformers.\n\n```ruby\nSanitize.fragment(html, :transformers => [\n  transformer_one,\n  transformer_two\n])\n```\n\n### Input\n\nEach transformer's `call()` method will be called once for each node in the HTML\n(including elements, text nodes, comments, etc.), and will receive as an\nargument a Hash that contains the following items:\n\n  * **:config** - The current Sanitize configuration Hash.\n\n  * **:is_allowlisted** - `true` if the current node has been allowlisted by a\n    previous transformer, `false` otherwise. It's generally bad form to remove\n    a node that a previous transformer has allowlisted.\n\n  * **:node** - A `Nokogiri::XML::Node` object representing an HTML node. The\n    node may be an element, a text node, a comment, a CDATA node, or a document\n    fragment. Use Nokogiri's inspection methods (`element?`, `text?`, etc.) to\n    selectively ignore node types you aren't interested in.\n\n  * **:node_allowlist** - Set of `Nokogiri::XML::Node` objects in the current\n    document that have been allowlisted by previous transformers, if any. It's\n    generally bad form to remove a node that a previous transformer has\n    allowlisted.\n\n  * **:node_name** - The name of the current HTML node, always lowercase (e.g.\n    \"div\" or \"span\"). For non-element nodes, the name will be something like\n    \"text\", \"comment\", \"#cdata-section\", \"#document-fragment\", etc.\n\n### Output\n\nA transformer doesn't have to return anything, but may optionally return a Hash,\nwhich may contain the following items:\n\n  * **:node_allowlist** -  Array or Set of specific `Nokogiri::XML::Node`\n    objects to add to the document's allowlist, bypassing the current Sanitize\n    config. These specific nodes and all their attributes will be allowlisted,\n    but their children will not be.\n\nIf a transformer returns anything other than a Hash, the return value will be\nignored.\n\n### Processing\n\nEach transformer has full access to the `Nokogiri::XML::Node` that's passed into\nit and to the rest of the document via the node's `document()` method. Any\nchanges made to the current node or to the document will be reflected instantly\nin the document and passed on to subsequently called transformers and to\nSanitize itself. A transformer may even call Sanitize internally to perform\ncustom sanitization if needed.\n\nNodes are passed into transformers in the order in which they're traversed.\nSanitize performs top-down traversal, meaning that nodes are traversed in the\nsame order you'd read them in the HTML, starting at the top node, then its first\nchild, and so on.\n\n```ruby\nhtml = %[\n  <header>\n    <span>\n      <strong>foo</strong>\n    </span>\n    <p>bar</p>\n  </header>\n\n  <footer></footer>\n]\n\ntransformer = lambda do |env|\n  puts env[:node_name] if env[:node].element?\nend\n\n# Prints \"header\", \"span\", \"strong\", \"p\", \"footer\".\nSanitize.fragment(html, :transformers => transformer)\n```\n\nTransformers have a tremendous amount of power, including the power to\ncompletely bypass Sanitize's built-in filtering. Be careful! Your safety is in\nyour own hands.\n\n### Example: Transformer to allow image URLs by domain\n\nThe following example demonstrates how to remove image elements unless they use\na relative URL or are hosted on a specific domain. It assumes that the `<img>`\nelement and its `src` attribute are already allowlisted.\n\n```ruby\nrequire 'uri'\n\nimage_allowlist_transformer = lambda do |env|\n  # Ignore everything except <img> elements.\n  return unless env[:node_name] == 'img'\n\n  node      = env[:node]\n  image_uri = URI.parse(node['src'])\n\n  # Only allow relative URLs or URLs with the example.com domain. The\n  # image_uri.host.nil? check ensures that protocol-relative URLs like\n  # \"//evil.com/foo.jpg\".\n  unless image_uri.host == 'example.com' || (image_uri.host.nil? && image_uri.relative?)\n    node.unlink # `Nokogiri::XML::Node#unlink` removes a node from the document\n  end\nend\n```\n\n### Example: Transformer to allow YouTube video embeds\n\nThe following example demonstrates how to create a transformer that will safely\nallow valid YouTube video embeds without having to allow other kinds of embedded\ncontent, which would be the case if you tried to do this by just allowing all\n`<iframe>` elements:\n\n```ruby\nyoutube_transformer = lambda do |env|\n  node      = env[:node]\n  node_name = env[:node_name]\n\n  # Don't continue if this node is already allowlisted or is not an element.\n  return if env[:is_allowlisted] || !node.element?\n\n  # Don't continue unless the node is an iframe.\n  return unless node_name == 'iframe'\n\n  # Verify that the video URL is actually a valid YouTube video URL.\n  return unless node['src'] =~ %r|\\A(?:https?:)?//(?:www\\.)?youtube(?:-nocookie)?\\.com/|\n\n  # We're now certain that this is a YouTube embed, but we still need to run\n  # it through a special Sanitize step to ensure that no unwanted elements or\n  # attributes that don't belong in a YouTube embed can sneak in.\n  Sanitize.node!(node, {\n    :elements => %w[iframe],\n\n    :attributes => {\n      'iframe'  => %w[allowfullscreen frameborder height src width]\n    }\n  })\n\n  # Now that we're sure that this is a valid YouTube embed and that there are\n  # no unwanted elements or attributes hidden inside it, we can tell Sanitize\n  # to allowlist the current node.\n  {:node_allowlist => [node]}\nend\n\nhtml = %[\n<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/dQw4w9WgXcQ\"\n    frameborder=\"0\" allowfullscreen></iframe>\n]\n\nSanitize.fragment(html, :transformers => youtube_transformer)\n# => '<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/dQw4w9WgXcQ\" frameborder=\"0\" allowfullscreen=\"\"></iframe>'\n```\n\nLicense\n-------\n\nCopyright (c) 2015 Ryan Grove (ryan@wonko.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the 'Software'), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "# encoding: utf-8\n\nclass Sanitize\n  module Config\n    DEFAULT = freeze_config(\n      # HTML attributes to add to specific elements. By default, no attributes\n      # are added.\n      :add_attributes => {},\n\n      # Whether or not to allow HTML comments. Allowing comments is strongly\n      # discouraged, since IE allows script execution within conditional\n      # comments.\n      :allow_comments => false,\n\n      # Whether or not to allow well-formed HTML doctype declarations such as\n      # \"<!DOCTYPE html>\" when sanitizing a document. This setting is ignored\n      # when sanitizing fragments.\n      :allow_doctype => false,\n\n      # HTML attributes to allow in specific elements. By default, no attributes\n      # are allowed. Use the symbol :data to indicate that arbitrary HTML5\n      # data-* attributes should be allowed.\n      :attributes => {},\n\n      # CSS sanitization settings.\n      :css => {\n        # Whether or not to allow CSS comments.\n        :allow_comments => false,\n\n        # Whether or not to allow browser compatibility hacks such as the IE *\n        # and _ hacks. These are generally harmless, but technically result in\n        # invalid CSS.\n        :allow_hacks => false,\n\n        # CSS at-rules to allow that may not have associated blocks (e.g.\n        # \"import\").\n        #\n        # https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n        :at_rules => [],\n\n        # CSS at-rules to allow whose blocks may contain properties (e.g.\n        # \"font-face\").\n        :at_rules_with_properties => [],\n\n        # CSS at-rules to allow whose blocks may contain styles (e.g. \"media\").\n        :at_rules_with_styles => [],\n\n        # CSS properties to allow.\n        :properties => [],\n\n        # URL protocols to allow in CSS URLs.\n        :protocols => []\n      },\n\n      # HTML elements to allow. By default, no elements are allowed (which means\n      # that all HTML will be stripped).\n      :elements => [],\n\n      # HTML parsing options to pass to Nokogumbo.\n      # https://github.com/rubys/nokogumbo/tree/v2.0.1#parsing-options\n      :parser_options => {},\n\n      # URL handling protocols to allow in specific attributes. By default, no\n      # protocols are allowed. Use :relative in place of a protocol if you want\n      # to allow relative URLs sans protocol.\n      :protocols => {},\n\n      # If this is true, Sanitize will remove the contents of any filtered\n      # elements in addition to the elements themselves. By default, Sanitize\n      # leaves the safe parts of an element's contents behind when the element\n      # is removed.\n      #\n      # If this is an Array or Set of element names, then only the contents of\n      # the specified elements (when filtered) will be removed, and the contents\n      # of all other filtered elements will be left behind.\n      :remove_contents => %w[\n        iframe noembed noframes noscript script style\n      ],\n\n      # Transformers allow you to filter or alter nodes using custom logic. See\n      # README.md for details and examples.\n      :transformers => [],\n\n      # Elements which, when removed, should have their contents surrounded by\n      # values specified with `before` and `after` keys to preserve readability.\n      # For example, `foo<div>bar</div>baz` will become 'foo bar baz' when the\n      # <div> is removed.\n      :whitespace_elements => {\n        'address'    => { :before => ' ', :after => ' ' },\n        'article'    => { :before => ' ', :after => ' ' },\n        'aside'      => { :before => ' ', :after => ' ' },\n        'blockquote' => { :before => ' ', :after => ' ' },\n        'br'         => { :before => ' ', :after => ' ' },\n        'dd'         => { :before => ' ', :after => ' ' },\n        'div'        => { :before => ' ', :after => ' ' },\n        'dl'         => { :before => ' ', :after => ' ' },\n        'dt'         => { :before => ' ', :after => ' ' },\n        'footer'     => { :before => ' ', :after => ' ' },\n        'h1'         => { :before => ' ', :after => ' ' },\n        'h2'         => { :before => ' ', :after => ' ' },\n        'h3'         => { :before => ' ', :after => ' ' },\n        'h4'         => { :before => ' ', :after => ' ' },\n        'h5'         => { :before => ' ', :after => ' ' },\n        'h6'         => { :before => ' ', :after => ' ' },\n        'header'     => { :before => ' ', :after => ' ' },\n        'hgroup'     => { :before => ' ', :after => ' ' },\n        'hr'         => { :before => ' ', :after => ' ' },\n        'li'         => { :before => ' ', :after => ' ' },\n        'nav'        => { :before => ' ', :after => ' ' },\n        'ol'         => { :before => ' ', :after => ' ' },\n        'p'          => { :before => ' ', :after => ' ' },\n        'pre'        => { :before => ' ', :after => ' ' },\n        'section'    => { :before => ' ', :after => ' ' },\n        'ul'         => { :before => ' ', :after => ' ' }\n      }\n    )\n  end\nend\n", "# encoding: utf-8\nrequire_relative 'common'\n\ndescribe 'Sanitize::Transformers::CleanElement' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  strings = {\n    :basic => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <style>.foo { color: #fff; }</style> <script>alert(\"hello world\");</script>',\n      :default    => 'Lorem ipsum dolor sit amet  ',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet  ',\n      :basic      => '<b>Lorem</b> <a href=\"pants\" rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet  ',\n      :relaxed    => '<b>Lorem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet <style>.foo { color: #fff; }</style> '\n    },\n\n    :malformed => {\n      :html       => 'Lo<!-- comment -->rem</b> <a href=pants title=\"foo>ipsum <a href=\"http://foo.com/\"><strong>dolor</a></strong> sit<br/>amet <script>alert(\"hello world\");',\n      :default    => 'Lorem dolor sit amet ',\n      :restricted => 'Lorem <strong>dolor</strong> sit amet ',\n      :basic      => 'Lorem <a href=\"pants\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet ',\n      :relaxed    => 'Lorem <a href=\"pants\" title=\"foo>ipsum <a href=\"><strong>dolor</strong></a> sit<br>amet ',\n    },\n\n    :unclosed => {\n      :html       => '<p>a</p><blockquote>b',\n      :default    => ' a  b ',\n      :restricted => ' a  b ',\n      :basic      => '<p>a</p><blockquote>b</blockquote>',\n      :relaxed    => '<p>a</p><blockquote>b</blockquote>'\n    },\n\n    :malicious => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"javascript:pants\" title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <<foo>script>alert(\"hello world\");</script>',\n      :default    => 'Lorem ipsum dolor sit amet &lt;script&gt;alert(\"hello world\");',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet &lt;script&gt;alert(\"hello world\");',\n      :basic      => '<b>Lorem</b> <a rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");',\n      :relaxed    => '<b>Lorem</b> <a title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");'\n    }\n  }\n\n  protocols = {\n    'protocol-based JS injection: simple, no spaces' => {\n      :html       => '<a href=\"javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before' => {\n      :html       => '<a href=\"javascript    :alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces after' => {\n      :html       => '<a href=\"javascript:    alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before and after' => {\n      :html       => '<a href=\"javascript    :   alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: preceding colon' => {\n      :html       => '<a href=\":javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#58;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#0058;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding without semicolons' => {\n      :html       => '<a href=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding' => {\n      :html       => '<a href=\"javascript&#x3A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long hex encoding' => {\n      :html       => '<a href=\"javascript&#x003A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding without semicolons' => {\n      :html       => '<a href=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: null char' => {\n      :html       => \"<img src=java\\0script:alert(\\\"XSS\\\")>\",\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: invalid URL char' => {\n      :html       => '<img src=java\\script:alert(\"XSS\")>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: spaces and entities' => {\n      :html       => '<img src=\" &#14;  javascript:alert(\\'XSS\\');\">',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol whitespace' => {\n      :html       => '<a href=\" http://example.com/\"></a>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '<a href=\"http://example.com/\" rel=\"nofollow\"></a>',\n      :relaxed    => '<a href=\"http://example.com/\"></a>'\n    }\n  }\n\n  describe 'Default config' do\n    it 'should remove non-allowlisted elements, leaving safe contents behind' do\n      Sanitize.fragment('foo <b>bar</b> <strong><a href=\"#a\">baz</a></strong> quux')\n        .must_equal 'foo bar baz quux'\n\n      Sanitize.fragment('<script>alert(\"<xss>\");</script>')\n        .must_equal ''\n\n      Sanitize.fragment('<<script>script>alert(\"<xss>\");</<script>>')\n        .must_equal '&lt;'\n\n      Sanitize.fragment('< script <>> alert(\"<xss>\");</script>')\n        .must_equal '&lt; script &lt;&gt;&gt; alert(\"\");'\n    end\n\n    it 'should surround the contents of :whitespace_elements with space characters when removing the element' do\n      Sanitize.fragment('foo<div>bar</div>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<br>bar<br>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<hr>bar<hr>baz')\n        .must_equal 'foo bar baz'\n    end\n\n    it 'should not choke on several instances of the same element in a row' do\n      Sanitize.fragment('<img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\">')\n        .must_equal ''\n    end\n\n    it 'should escape the content of removed `plaintext` elements' do\n      Sanitize.fragment('<plaintext>hello! <script>alert(0)</script>')\n        .must_equal 'hello! &lt;script&gt;alert(0)&lt;/script&gt;'\n    end\n\n    it 'should escape the content of removed `xmp` elements' do\n      Sanitize.fragment('<xmp>hello! <script>alert(0)</script></xmp>')\n        .must_equal 'hello! &lt;script&gt;alert(0)&lt;/script&gt;'\n    end\n\n    it 'should not preserve the content of removed `iframe` elements' do\n      Sanitize.fragment('<iframe>hello! <script>alert(0)</script></iframe>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `noembed` elements' do\n      Sanitize.fragment('<noembed>hello! <script>alert(0)</script></noembed>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `noframes` elements' do\n      Sanitize.fragment('<noframes>hello! <script>alert(0)</script></noframes>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `noscript` elements' do\n      Sanitize.fragment('<noscript>hello! <script>alert(0)</script></noscript>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `script` elements' do\n      Sanitize.fragment('<script>hello! <script>alert(0)</script></script>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `style` elements' do\n      Sanitize.fragment('<style>hello! <script>alert(0)</script></style>')\n        .must_equal ''\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n  end\n\n  describe 'Restricted config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RESTRICTED)\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n  end\n\n  describe 'Basic config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::BASIC)\n    end\n\n    it 'should not choke on valueless attributes' do\n      @s.fragment('foo <a href>foo</a> bar')\n        .must_equal 'foo <a href=\"\" rel=\"nofollow\">foo</a> bar'\n    end\n\n    it 'should downcase attribute names' do\n      @s.fragment('<a HREF=\"javascript:alert(\\'foo\\')\">bar</a>')\n        .must_equal '<a rel=\"nofollow\">bar</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n  end\n\n  describe 'Relaxed config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RELAXED)\n    end\n\n    it 'should encode special chars in attribute values' do\n      @s.fragment('<a href=\"http://example.com\" title=\"<b>&eacute;xamples</b> & things\">foo</a>')\n        .must_equal '<a href=\"http://example.com\" title=\"<b>\u00e9xamples</b> &amp; things\">foo</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n  end\n\n  describe 'Custom configs' do\n    it 'should allow attributes on all elements if allowlisted under :all' do\n      input = '<p class=\"foo\">bar</p>'\n\n      Sanitize.fragment(input).must_equal ' bar '\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {:all => ['class']}\n      }).must_equal input\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'div' => ['class']}\n      }).must_equal '<p>bar</p>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'p' => ['title'], :all => ['class']}\n      }).must_equal input\n    end\n\n    it \"should not allow relative URLs when relative URLs aren't allowlisted\" do\n      input = '<a href=\"/foo/bar\">Link</a>'\n\n      Sanitize.fragment(input,\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['http']}}\n      ).must_equal '<a>Link</a>'\n    end\n\n    it 'should allow relative URLs containing colons when the colon is not in the first path segment' do\n      input = '<a href=\"/wiki/Special:Random\">Random Page</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should allow relative URLs containing colons when the colon is part of an anchor' do\n      input = '<a href=\"#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n\n      input = '<a href=\"somepage#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should remove the contents of filtered nodes when :remove_contents is true' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span></div>',\n        :remove_contents => true\n      ).must_equal 'foo bar   '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array or Set of element names as strings' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => ['script', 'span']\n      ).must_equal 'foo bar  baz hi '\n\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => Set.new(['script', 'span'])\n      ).must_equal 'foo bar  baz hi '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array or Set of element names as symbols' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => [:script, :span]\n      ).must_equal 'foo bar  baz hi '\n\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => Set.new([:script, :span])\n      ).must_equal 'foo bar  baz hi '\n    end\n\n    it 'should remove the contents of allowlisted iframes' do\n      Sanitize.fragment('<iframe>hi <script>hello</script></iframe>',\n        :elements => ['iframe']\n      ).must_equal '<iframe></iframe>'\n    end\n\n    it 'should not allow arbitrary HTML5 data attributes by default' do\n      Sanitize.fragment('<b data-foo=\"bar\"></b>',\n        :elements => ['b']\n      ).must_equal '<b></b>'\n\n      Sanitize.fragment('<b class=\"foo\" data-foo=\"bar\"></b>',\n        :attributes => {'b' => ['class']},\n        :elements   => ['b']\n      ).must_equal '<b class=\"foo\"></b>'\n    end\n\n    it 'should allow arbitrary HTML5 data attributes when the :attributes config includes :data' do\n      s = Sanitize.new(\n        :attributes => {'b' => [:data]},\n        :elements   => ['b']\n      )\n\n      s.fragment('<b data-foo=\"valid\" data-bar=\"valid\"></b>')\n        .must_equal '<b data-foo=\"valid\" data-bar=\"valid\"></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xml=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xmlfoo=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f:oo=\"valid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f/oo=\"partial\"></b>')\n        .must_equal '<b data-f=\"\"></b>' # Nokogiri quirk; not ideal, but harmless\n\n      s.fragment('<b data-\u00e9foo=\"valid\"></b>')\n        .must_equal '<b></b>' # Another annoying Nokogiri quirk.\n    end\n\n    it 'should replace whitespace_elements with configured :before and :after values' do\n      s = Sanitize.new(\n        :whitespace_elements => {\n          'p'   => { :before => \"\\n\", :after => \"\\n\" },\n          'div' => { :before => \"\\n\", :after => \"\\n\" },\n          'br'  => { :before => \"\\n\", :after => \"\\n\" },\n        }\n      )\n\n      s.fragment('<p>foo</p>').must_equal \"\\nfoo\\n\"\n      s.fragment('<p>foo</p><p>bar</p>').must_equal \"\\nfoo\\n\\nbar\\n\"\n      s.fragment('foo<div>bar</div>baz').must_equal \"foo\\nbar\\nbaz\"\n      s.fragment('foo<br>bar<br>baz').must_equal \"foo\\nbar\\nbaz\"\n    end\n\n    it 'should handle protocols correctly regardless of case' do\n      input = '<a href=\"hTTpS://foo.com/\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal input\n\n      input = '<a href=\"mailto:someone@example.com?Subject=Hello\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal \"<a>Text</a>\"\n    end\n\n    it 'should prevent `<meta>` tags from being used to set a non-UTF-8 charset' do\n      Sanitize.document('<html><head><meta charset=\"utf-8\"></head><body>Howdy!</body></html>',\n        :elements   => %w[html head meta body],\n        :attributes => {'meta' => ['charset']}\n      ).must_equal \"<html><head><meta charset=\\\"utf-8\\\"></head><body>Howdy!</body></html>\"\n\n      Sanitize.document('<html><meta charset=\"utf-8\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => ['charset']}\n      ).must_equal \"<html><meta charset=\\\"utf-8\\\">Howdy!</html>\"\n\n      Sanitize.document('<html><meta charset=\"us-ascii\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => ['charset']}\n      ).must_equal \"<html><meta charset=\\\"utf-8\\\">Howdy!</html>\"\n\n      Sanitize.document('<html><meta http-equiv=\"content-type\" content=\" text/html; charset=us-ascii\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => %w[content http-equiv]}\n      ).must_equal \"<html><meta http-equiv=\\\"content-type\\\" content=\\\" text/html;charset=utf-8\\\">Howdy!</html>\"\n\n      Sanitize.document('<html><meta http-equiv=\"Content-Type\" content=\"text/plain;charset = us-ascii\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => %w[content http-equiv]}\n      ).must_equal \"<html><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/plain;charset=utf-8\\\">Howdy!</html>\"\n    end\n\n    it 'should not modify `<meta>` tags that already set a UTF-8 charset' do\n      Sanitize.document('<html><head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"></head><body>Howdy!</body></html>',\n        :elements   => %w[html head meta body],\n        :attributes => {'meta' => %w[content http-equiv]}\n      ).must_equal \"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=utf-8\\\"></head><body>Howdy!</body></html>\"\n    end\n\n  end\nend\n", "# encoding: utf-8\nrequire_relative 'common'\n\n# Miscellaneous attempts to sneak maliciously crafted HTML past Sanitize. Many\n# of these are courtesy of (or inspired by) the OWASP XSS Filter Evasion Cheat\n# Sheet.\n#\n# https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n\ndescribe 'Malicious HTML' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  before do\n    @s = Sanitize.new(Sanitize::Config::RELAXED)\n  end\n\n  describe 'comments' do\n    it 'should not allow script injection via conditional comments' do\n      @s.fragment(%[<!--[if gte IE 4]>\\n<script>alert('XSS');</script>\\n<![endif]-->]).\n        must_equal ''\n    end\n  end\n\n  describe 'interpolation (ERB, PHP, etc.)' do\n    it 'should escape ERB-style tags' do\n      @s.fragment('<% naughty_ruby_code %>').\n        must_equal '&lt;% naughty_ruby_code %&gt;'\n\n      @s.fragment('<%= naughty_ruby_code %>').\n        must_equal '&lt;%= naughty_ruby_code %&gt;'\n    end\n\n    it 'should remove PHP-style tags' do\n      @s.fragment('<? naughtyPHPCode(); ?>').\n        must_equal ''\n\n      @s.fragment('<?= naughtyPHPCode(); ?>').\n        must_equal ''\n    end\n  end\n\n  describe '<body>' do\n    it 'should not be possible to inject JS via a malformed event attribute' do\n      @s.document('<html><head></head><body onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\"XSS\")></body></html>').\n        must_equal \"<html><head></head><body></body></html>\"\n    end\n  end\n\n  describe '<iframe>' do\n    it 'should not be possible to inject an iframe using an improperly closed tag' do\n      @s.fragment(%[<iframe src=http://ha.ckers.org/scriptlet.html <]).\n        must_equal ''\n    end\n  end\n\n  describe '<img>' do\n    it 'should not be possible to inject JS via an unquoted <img> src attribute' do\n      @s.fragment(\"<img src=javascript:alert('XSS')>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using grave accents as <img> src delimiters' do\n      @s.fragment(\"<img src=`javascript:alert('XSS')`>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject <script> via a malformed <img> tag' do\n      @s.fragment('<img \"\"\"><script>alert(\"XSS\")</script>\">').\n        must_equal '<img>\"&gt;'\n    end\n\n    it 'should not be possible to inject protocol-based JS' do\n      @s.fragment('<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>').\n        must_equal '<img>'\n\n      # Encoded tab character.\n      @s.fragment(%[<img src=\"jav&#x09;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded newline.\n      @s.fragment(%[<img src=\"jav&#x0A;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded carriage return.\n      @s.fragment(%[<img src=\"jav&#x0D;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Null byte.\n      @s.fragment(%[<img src=java\\0script:alert(\"XSS\")>]).\n        must_equal '<img>'\n\n      # Spaces plus meta char.\n      @s.fragment(%[<img src=\" &#14;  javascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Mixed spaces and tabs.\n      @s.fragment(%[<img src=\"j\\na v\\tascript://alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject protocol-based JS via whitespace' do\n      @s.fragment(%[<img src=\"jav\\tascript:alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using a half-open <img> tag' do\n      @s.fragment(%[<img src=\"javascript:alert('XSS')\"]).\n        must_equal ''\n    end\n  end\n\n  describe '<script>' do\n    it 'should not be possible to inject <script> using a malformed non-alphanumeric tag name' do\n      @s.fragment(%[<script/xss src=\"http://ha.ckers.org/xss.js\">alert(1)</script>]).\n        must_equal ''\n    end\n\n    it 'should not be possible to inject <script> via extraneous open brackets' do\n      @s.fragment(%[<<script>alert(\"XSS\");//<</script>]).\n        must_equal '&lt;'\n    end\n  end\n\n  # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an\n  # attempt to preserve server-side includes. This can result in XSS since an\n  # unescaped double quote can allow an attacker to inject a non-allowlisted\n  # attribute. Sanitize works around this by implementing its own escaping for\n  # affected attributes.\n  #\n  # The relevant libxml2 code is here:\n  # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588>\n  describe 'unsafe libxml2 server-side includes in attributes' do\n    using_unpatched_libxml2 = Nokogiri::VersionInfo.instance.libxml2_using_system?\n\n    tag_configs = [\n      {\n        tag_name: 'a',\n        escaped_attrs: %w[ action href src name ],\n        unescaped_attrs: []\n      },\n\n      {\n        tag_name: 'div',\n        escaped_attrs: %w[ action href src ],\n        unescaped_attrs: %w[ name ]\n      }\n    ]\n\n    before do\n      @s = Sanitize.new({\n        elements: %w[ a div ],\n\n        attributes: {\n          all: %w[ action href src name ]\n        }\n      })\n    end\n\n    tag_configs.each do |tag_config|\n      tag_name = tag_config[:tag_name]\n\n      tag_config[:escaped_attrs].each do |attr_name|\n        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n\n        it 'should escape unsafe characters in attributes' do\n          skip \"behavior should only exist in nokogiri's patched libxml\" if using_unpatched_libxml2\n\n          # This uses Nokogumbo's HTML-compliant serializer rather than\n          # libxml2's.\n          @s.fragment(input).\n            must_equal(%[<#{tag_name} #{attr_name}=\"examp<!--%22%20onmouseover=alert(1)>-->le.com\">foo</#{tag_name}>])\n\n          # This uses the not-quite-standards-compliant libxml2 serializer via\n          # Nokogiri, so the output may be a little different as of Nokogiri\n          # 1.10.2 when using Nokogiri's vendored libxml2 due to this patch:\n          # https://github.com/sparklemotion/nokogiri/commit/4852e43cb6039e26d8c51af78621e539cbf46c5d\n          fragment = Nokogiri::HTML.fragment(input)\n          @s.node!(fragment)\n          fragment.to_html.\n            must_equal(%[<#{tag_name} #{attr_name}=\"examp&lt;!--%22%20onmouseover=alert(1)&gt;--&gt;le.com\">foo</#{tag_name}>])\n        end\n\n        it 'should round-trip to the same output' do\n          output = @s.fragment(input)\n          @s.fragment(output).must_equal(output)\n        end\n      end\n\n      tag_config[:unescaped_attrs].each do |attr_name|\n        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n\n        it 'should not escape characters unnecessarily' do\n          skip \"behavior should only exist in nokogiri's patched libxml\" if using_unpatched_libxml2\n\n          # This uses Nokogumbo's HTML-compliant serializer rather than\n          # libxml2's.\n          @s.fragment(input).\n            must_equal(%[<#{tag_name} #{attr_name}=\"examp<!--&quot; onmouseover=alert(1)>-->le.com\">foo</#{tag_name}>])\n\n          # This uses the not-quite-standards-compliant libxml2 serializer via\n          # Nokogiri, so the output may be a little different as of Nokogiri\n          # 1.10.2 when using Nokogiri's vendored libxml2 due to this patch:\n          # https://github.com/sparklemotion/nokogiri/commit/4852e43cb6039e26d8c51af78621e539cbf46c5d\n          fragment = Nokogiri::HTML.fragment(input)\n          @s.node!(fragment)\n          fragment.to_html.\n            must_equal(%[<#{tag_name} #{attr_name}='examp&lt;!--\" onmouseover=alert(1)&gt;--&gt;le.com'>foo</#{tag_name}>])\n        end\n\n        it 'should round-trip to the same output' do\n          output = @s.fragment(input)\n          @s.fragment(output).must_equal(output)\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["Sanitize\n========\n\nSanitize is an allowlist-based HTML and CSS sanitizer. It removes all HTML\nand/or CSS from a string except the elements, attributes, and properties you\nchoose to allow.\n\nUsing a simple configuration syntax, you can tell Sanitize to allow certain HTML\nelements, certain attributes within those elements, and even certain URL\nprotocols within attributes that contain URLs. You can also allow specific CSS\nproperties, @ rules, and URL protocols in elements or attributes containing CSS.\nAny HTML or CSS that you don't explicitly allow will be removed.\n\nSanitize is based on [Google's Gumbo HTML5 parser][gumbo], which parses HTML\nexactly the same way modern browsers do, and [Crass][crass], which parses CSS\nexactly the same way modern browsers do. As long as your allowlist config only\nallows safe markup and CSS, even the most malformed or malicious input will be\ntransformed into safe output.\n\n[![Build Status](https://travis-ci.org/rgrove/sanitize.svg?branch=master)](https://travis-ci.org/rgrove/sanitize)\n[![Gem Version](https://badge.fury.io/rb/sanitize.svg)](http://badge.fury.io/rb/sanitize)\n\n[crass]:https://github.com/rgrove/crass\n[gumbo]:https://github.com/google/gumbo-parser\n\nLinks\n-----\n\n* [Home](https://github.com/rgrove/sanitize/)\n* [API Docs](http://rubydoc.info/github/rgrove/sanitize/master)\n* [Issues](https://github.com/rgrove/sanitize/issues)\n* [Release History](https://github.com/rgrove/sanitize/blob/master/HISTORY.md#sanitize-history)\n* [Online Demo](https://sanitize.herokuapp.com/)\n* [Biased comparison of Ruby HTML sanitization libraries](https://github.com/rgrove/sanitize/blob/master/COMPARISON.md)\n\nInstallation\n-------------\n\n```\ngem install sanitize\n```\n\nQuick Start\n-----------\n\n```ruby\nrequire 'sanitize'\n\n# Clean up an HTML fragment using Sanitize's permissive but safe Relaxed config.\n# This also sanitizes any CSS in `<style>` elements or `style` attributes.\nSanitize.fragment(html, Sanitize::Config::RELAXED)\n\n# Clean up an HTML document using the Relaxed config.\nSanitize.document(html, Sanitize::Config::RELAXED)\n\n# Clean up a standalone CSS stylesheet using the Relaxed config.\nSanitize::CSS.stylesheet(css, Sanitize::Config::RELAXED)\n\n# Clean up some CSS properties using the Relaxed config.\nSanitize::CSS.properties(css, Sanitize::Config::RELAXED)\n```\n\nUsage\n-----\n\nSanitize can sanitize the following types of input:\n\n* HTML fragments\n* HTML documents\n* CSS stylesheets inside HTML `<style>` elements\n* CSS properties inside HTML `style` attributes\n* Standalone CSS stylesheets\n* Standalone CSS properties\n\nHowever, please note that Sanitize _cannot_ fully sanitize the contents of\n`<math>` or `<svg>` elements, since these elements don't follow the same parsing\nrules as the rest of HTML. If this is something you need, you may want to look\nfor another solution.\n\n### HTML Fragments\n\nA fragment is a snippet of HTML that doesn't contain a root-level `<html>`\nelement.\n\nIf you don't specify any configuration options, Sanitize will use its strictest\nsettings by default, which means it will strip all HTML and leave only safe text\nbehind.\n\n```ruby\nhtml = '<b><a href=\"http://foo.com/\">foo</a></b><img src=\"bar.jpg\">'\nSanitize.fragment(html)\n# => 'foo'\n```\n\nTo keep certain elements, add them to the element allowlist.\n\n```ruby\nSanitize.fragment(html, :elements => ['b'])\n# => '<b>foo</b>'\n```\n\n### HTML Documents\n\nWhen sanitizing a document, the `<html>` element must be allowlisted. You can\nalso set `:allow_doctype` to `true` to allow well-formed document type\ndefinitions.\n\n```ruby\nhtml = %[\n  <!DOCTYPE html>\n  <html>\n    <b><a href=\"http://foo.com/\">foo</a></b><img src=\"bar.jpg\">\n  </html>\n]\n\nSanitize.document(html,\n  :allow_doctype => true,\n  :elements      => ['html']\n)\n# => %[\n#   <!DOCTYPE html>\n#   <html>foo\n#\n#   </html>\n# ]\n```\n\n### CSS in HTML\n\nTo sanitize CSS in an HTML fragment or document, first allowlist the `<style>`\nelement and/or the `style` attribute. Then allowlist the CSS properties,\n@ rules, and URL protocols you wish to allow. You can also choose whether to\nallow CSS comments or browser compatibility hacks.\n\n```ruby\nhtml = %[\n  <style>\n    div { color: green; width: 1024px; }\n  </style>\n\n  <div style=\"height: 100px; width: 100px;\"></div>\n  <p>hello!</p>\n]\n\nSanitize.fragment(html,\n  :elements   => ['div', 'style'],\n  :attributes => {'div' => ['style']},\n\n  :css => {\n    :properties => ['width']\n  }\n)\n#=> %[\n#   <style>\n#     div {  width: 1024px; }\n#   </style>\n#\n#   <div style=\" width: 100px;\"></div>\n#   hello!\n# ]\n```\n\n### Standalone CSS\n\nSanitize will happily clean up a standalone CSS stylesheet or property string\nwithout needing to invoke the HTML parser.\n\n```ruby\ncss = %[\n  @import url(evil.css);\n\n  a { text-decoration: none; }\n\n  a:hover {\n    left: expression(alert('xss!'));\n    text-decoration: underline;\n  }\n]\n\nSanitize::CSS.stylesheet(css, Sanitize::Config::RELAXED)\n# => %[\n#\n#\n#\n#   a { text-decoration: none; }\n#\n#   a:hover {\n#\n#     text-decoration: underline;\n#   }\n# ]\n\nSanitize::CSS.properties(%[\n  left: expression(alert('xss!'));\n  text-decoration: underline;\n], Sanitize::Config::RELAXED)\n# => %[\n#\n#   text-decoration: underline;\n# ]\n\n```\n\nConfiguration\n-------------\n\nIn addition to the ultra-safe default settings, Sanitize comes with three other\nbuilt-in configurations that you can use out of the box or adapt to meet your\nneeds.\n\n### Sanitize::Config::RESTRICTED\n\nAllows only very simple inline markup. No links, images, or block elements.\n\n```ruby\nSanitize.fragment(html, Sanitize::Config::RESTRICTED)\n# => '<b>foo</b>'\n```\n\n### Sanitize::Config::BASIC\n\nAllows a variety of markup including formatting elements, links, and lists.\n\nImages and tables are not allowed, links are limited to FTP, HTTP, HTTPS, and\nmailto protocols, and a `rel=\"nofollow\"` attribute is added to all links to\nmitigate SEO spam.\n\n```ruby\nSanitize.fragment(html, Sanitize::Config::BASIC)\n# => '<b><a href=\"http://foo.com/\" rel=\"nofollow\">foo</a></b>'\n```\n\n### Sanitize::Config::RELAXED\n\nAllows an even wider variety of markup, including images and tables, as well as\nsafe CSS. Links are still limited to FTP, HTTP, HTTPS, and mailto protocols,\nwhile images are limited to HTTP and HTTPS. In this mode, `rel=\"nofollow\"` is\nnot added to links.\n\n```ruby\nSanitize.fragment(html, Sanitize::Config::RELAXED)\n# => '<b><a href=\"http://foo.com/\">foo</a></b><img src=\"bar.jpg\">'\n```\n\n### Custom Configuration\n\nIf the built-in modes don't meet your needs, you can easily specify a custom\nconfiguration:\n\n```ruby\nSanitize.fragment(html,\n  :elements => ['a', 'span'],\n\n  :attributes => {\n    'a'    => ['href', 'title'],\n    'span' => ['class']\n  },\n\n  :protocols => {\n    'a' => {'href' => ['http', 'https', 'mailto']}\n  }\n)\n```\n\nYou can also start with one of Sanitize's built-in configurations and then\ncustomize it to meet your needs.\n\nThe built-in configs are deeply frozen to prevent people from modifying them\n(either accidentally or maliciously). To customize a built-in config, create a\nnew copy using `Sanitize::Config.merge()`, like so:\n\n```ruby\n# Create a customized copy of the Basic config, adding <div> and <table> to the\n# existing allowlisted elements.\nSanitize.fragment(html, Sanitize::Config.merge(Sanitize::Config::BASIC,\n  :elements        => Sanitize::Config::BASIC[:elements] + ['div', 'table'],\n  :remove_contents => true\n))\n```\n\nThe example above adds the `<div>` and `<table>` elements to a copy of the\nexisting list of elements in `Sanitize::Config::BASIC`. If you instead want to\ncompletely overwrite the elements array with your own, you can omit the `+`\noperation:\n\n```ruby\n# Overwrite :elements instead of creating a copy with new entries.\nSanitize.fragment(html, Sanitize::Config.merge(Sanitize::Config::BASIC,\n  :elements        => ['div', 'table'],\n  :remove_contents => true\n))\n```\n\n### Config Settings\n\n#### :add_attributes (Hash)\n\nAttributes to add to specific elements. If the attribute already exists, it will\nbe replaced with the value specified here. Specify all element names and\nattributes in lowercase.\n\n```ruby\n:add_attributes => {\n  'a' => {'rel' => 'nofollow'}\n}\n```\n\n#### :allow_comments (boolean)\n\nWhether or not to allow HTML comments. Allowing comments is strongly\ndiscouraged, since IE allows script execution within conditional comments. The\ndefault value is `false`.\n\n#### :allow_doctype (boolean)\n\nWhether or not to allow well-formed HTML doctype declarations such as \"<!DOCTYPE\nhtml>\" when sanitizing a document. This setting is ignored when sanitizing\nfragments. The default value is `false`.\n\n#### :attributes (Hash)\n\nAttributes to allow on specific elements. Specify all element names and\nattributes in lowercase.\n\n```ruby\n:attributes => {\n  'a'          => ['href', 'title'],\n  'blockquote' => ['cite'],\n  'img'        => ['alt', 'src', 'title']\n}\n```\n\nIf you'd like to allow certain attributes on all elements, use the symbol `:all`\ninstead of an element name.\n\n```ruby\n# Allow the class attribute on all elements.\n:attributes => {\n  :all => ['class'],\n  'a'  => ['href', 'title']\n}\n```\n\nTo allow arbitrary HTML5 `data-*` attributes, use the symbol `:data` in place of\nan attribute name.\n\n```ruby\n# Allow arbitrary HTML5 data-* attributes on <div> elements.\n:attributes => {\n  'div' => [:data]\n}\n```\n\n#### :css (Hash)\n\nHash of the following CSS config settings to be used when sanitizing CSS (either\nstandalone or embedded in HTML).\n\n##### :css => :allow_comments (boolean)\n\nWhether or not to allow CSS comments. The default value is `false`.\n\n##### :css => :allow_hacks (boolean)\n\nWhether or not to allow browser compatibility hacks such as the IE `*` and `_`\nhacks. These are generally harmless, but technically result in invalid CSS. The\ndefault is `false`.\n\n##### :css => :at_rules (Array or Set)\n\nNames of CSS [at-rules][at-rules] to allow that may not have associated blocks,\nsuch as `import` or `charset`. Names should be specified in lowercase.\n\n[at-rules]:https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n\n##### :css => :at_rules_with_properties (Array or Set)\n\nNames of CSS [at-rules][at-rules] to allow that may have associated blocks\ncontaining CSS properties. At-rules like `font-face` and `page` fall into this\ncategory. Names should be specified in lowercase.\n\n##### :css => :at_rules_with_styles (Array or Set)\n\nNames of CSS [at-rules][at-rules] to allow that may have associated blocks\ncontaining style rules. At-rules like `media` and `keyframes` fall into this\ncategory. Names should be specified in lowercase.\n\n##### :css => :import_url_validator\n\nThis is a `Proc` (or other callable object) that will be called and passed\nthe URL specified for any `@import` [at-rules][at-rules].\n\nYou can use this to limit what can be imported, for example something\nlike the following to limit `@import` to Google Fonts URLs:\n\n```ruby\nProc.new { |url| url.start_with?(\"https://fonts.googleapis.com\") }\n```\n\n##### :css => :properties (Array or Set)\n\nList of CSS property names to allow. Names should be specified in lowercase.\n\n##### :css => :protocols (Array or Set)\n\nURL protocols to allow in CSS URLs. Should be specified in lowercase.\n\nIf you'd like to allow the use of relative URLs which don't have a protocol,\ninclude the symbol `:relative` in the protocol array.\n\n#### :elements (Array or Set)\n\nArray of HTML element names to allow. Specify all names in lowercase. Any\nelements not in this array will be removed.\n\n```ruby\n:elements => %w[\n  a abbr b blockquote br cite code dd dfn dl dt em i kbd li mark ol p pre\n  q s samp small strike strong sub sup time u ul var\n]\n```\n\n**Warning:** Sanitize cannot fully sanitize the contents of `<math>` or `<svg>`\nelements, since these elements don't follow the same parsing rules as the rest\nof HTML. If you add `math` or `svg` to the allowlist, you must assume that any\ncontent inside them will be allowed, even if that content would otherwise be\nremoved by Sanitize.\n\n#### :parser_options (Hash)\n\n[Parsing options](https://github.com/rubys/nokogumbo/tree/v2.0.1#parsing-options) supplied to `nokogumbo`.\n\n```ruby\n:parser_options => {\n  max_errors: -1,\n  max_tree_depth: -1\n}\n```\n\n#### :protocols (Hash)\n\nURL protocols to allow in specific attributes. If an attribute is listed here\nand contains a protocol other than those specified (or if it contains no\nprotocol at all), it will be removed.\n\n```ruby\n:protocols => {\n  'a'   => {'href' => ['ftp', 'http', 'https', 'mailto']},\n  'img' => {'src'  => ['http', 'https']}\n}\n```\n\nIf you'd like to allow the use of relative URLs which don't have a protocol,\ninclude the symbol `:relative` in the protocol array:\n\n```ruby\n:protocols => {\n  'a' => {'href' => ['http', 'https', :relative]}\n}\n```\n\n#### :remove_contents (boolean or Array or Set)\n\nIf this is `true`, Sanitize will remove the contents of any non-allowlisted\nelements in addition to the elements themselves. By default, Sanitize leaves the\nsafe parts of an element's contents behind when the element is removed.\n\nIf this is an Array or Set of element names, then only the contents of the\nspecified elements (when filtered) will be removed, and the contents of all\nother filtered elements will be left behind.\n\nThe default value is `false`.\n\n#### :transformers (Array or callable)\n\nCustom HTML transformer or array of custom transformers. See the Transformers\nsection below for details.\n\n#### :whitespace_elements (Hash)\n\nHash of element names which, when removed, should have their contents surrounded\nby whitespace to preserve readability.\n\nEach element name is a key pointing to another Hash, which provides the specific\nwhitespace that should be inserted `:before` and `:after` the removed element's\nposition. The `:after` value will only be inserted if the removed element has\nchildren, in which case it will be inserted after those children.\n\n```ruby\n:whitespace_elements => {\n  'br'  => { :before => \"\\n\", :after => \"\" },\n  'div' => { :before => \"\\n\", :after => \"\\n\" },\n  'p'   => { :before => \"\\n\", :after => \"\\n\" }\n}\n```\n\nThe default elements with whitespace added before and after are:\n\n```\naddress article aside blockquote br dd div dl dt\nfooter h1 h2 h3 h4 h5 h6 header hgroup hr li nav\nol p pre section ul\n\n```\n\n## Transformers\n\nTransformers allow you to filter and modify HTML nodes using your own custom\nlogic, on top of (or instead of) Sanitize's core filter. A transformer is any\nobject that responds to `call()` (such as a lambda or proc).\n\nTo use one or more transformers, pass them to the `:transformers` config\nsetting. You may pass a single transformer or an array of transformers.\n\n```ruby\nSanitize.fragment(html, :transformers => [\n  transformer_one,\n  transformer_two\n])\n```\n\n### Input\n\nEach transformer's `call()` method will be called once for each node in the HTML\n(including elements, text nodes, comments, etc.), and will receive as an\nargument a Hash that contains the following items:\n\n  * **:config** - The current Sanitize configuration Hash.\n\n  * **:is_allowlisted** - `true` if the current node has been allowlisted by a\n    previous transformer, `false` otherwise. It's generally bad form to remove\n    a node that a previous transformer has allowlisted.\n\n  * **:node** - A `Nokogiri::XML::Node` object representing an HTML node. The\n    node may be an element, a text node, a comment, a CDATA node, or a document\n    fragment. Use Nokogiri's inspection methods (`element?`, `text?`, etc.) to\n    selectively ignore node types you aren't interested in.\n\n  * **:node_allowlist** - Set of `Nokogiri::XML::Node` objects in the current\n    document that have been allowlisted by previous transformers, if any. It's\n    generally bad form to remove a node that a previous transformer has\n    allowlisted.\n\n  * **:node_name** - The name of the current HTML node, always lowercase (e.g.\n    \"div\" or \"span\"). For non-element nodes, the name will be something like\n    \"text\", \"comment\", \"#cdata-section\", \"#document-fragment\", etc.\n\n### Output\n\nA transformer doesn't have to return anything, but may optionally return a Hash,\nwhich may contain the following items:\n\n  * **:node_allowlist** -  Array or Set of specific `Nokogiri::XML::Node`\n    objects to add to the document's allowlist, bypassing the current Sanitize\n    config. These specific nodes and all their attributes will be allowlisted,\n    but their children will not be.\n\nIf a transformer returns anything other than a Hash, the return value will be\nignored.\n\n### Processing\n\nEach transformer has full access to the `Nokogiri::XML::Node` that's passed into\nit and to the rest of the document via the node's `document()` method. Any\nchanges made to the current node or to the document will be reflected instantly\nin the document and passed on to subsequently called transformers and to\nSanitize itself. A transformer may even call Sanitize internally to perform\ncustom sanitization if needed.\n\nNodes are passed into transformers in the order in which they're traversed.\nSanitize performs top-down traversal, meaning that nodes are traversed in the\nsame order you'd read them in the HTML, starting at the top node, then its first\nchild, and so on.\n\n```ruby\nhtml = %[\n  <header>\n    <span>\n      <strong>foo</strong>\n    </span>\n    <p>bar</p>\n  </header>\n\n  <footer></footer>\n]\n\ntransformer = lambda do |env|\n  puts env[:node_name] if env[:node].element?\nend\n\n# Prints \"header\", \"span\", \"strong\", \"p\", \"footer\".\nSanitize.fragment(html, :transformers => transformer)\n```\n\nTransformers have a tremendous amount of power, including the power to\ncompletely bypass Sanitize's built-in filtering. Be careful! Your safety is in\nyour own hands.\n\n### Example: Transformer to allow image URLs by domain\n\nThe following example demonstrates how to remove image elements unless they use\na relative URL or are hosted on a specific domain. It assumes that the `<img>`\nelement and its `src` attribute are already allowlisted.\n\n```ruby\nrequire 'uri'\n\nimage_allowlist_transformer = lambda do |env|\n  # Ignore everything except <img> elements.\n  return unless env[:node_name] == 'img'\n\n  node      = env[:node]\n  image_uri = URI.parse(node['src'])\n\n  # Only allow relative URLs or URLs with the example.com domain. The\n  # image_uri.host.nil? check ensures that protocol-relative URLs like\n  # \"//evil.com/foo.jpg\".\n  unless image_uri.host == 'example.com' || (image_uri.host.nil? && image_uri.relative?)\n    node.unlink # `Nokogiri::XML::Node#unlink` removes a node from the document\n  end\nend\n```\n\n### Example: Transformer to allow YouTube video embeds\n\nThe following example demonstrates how to create a transformer that will safely\nallow valid YouTube video embeds without having to allow other kinds of embedded\ncontent, which would be the case if you tried to do this by just allowing all\n`<iframe>` elements:\n\n```ruby\nyoutube_transformer = lambda do |env|\n  node      = env[:node]\n  node_name = env[:node_name]\n\n  # Don't continue if this node is already allowlisted or is not an element.\n  return if env[:is_allowlisted] || !node.element?\n\n  # Don't continue unless the node is an iframe.\n  return unless node_name == 'iframe'\n\n  # Verify that the video URL is actually a valid YouTube video URL.\n  return unless node['src'] =~ %r|\\A(?:https?:)?//(?:www\\.)?youtube(?:-nocookie)?\\.com/|\n\n  # We're now certain that this is a YouTube embed, but we still need to run\n  # it through a special Sanitize step to ensure that no unwanted elements or\n  # attributes that don't belong in a YouTube embed can sneak in.\n  Sanitize.node!(node, {\n    :elements => %w[iframe],\n\n    :attributes => {\n      'iframe'  => %w[allowfullscreen frameborder height src width]\n    }\n  })\n\n  # Now that we're sure that this is a valid YouTube embed and that there are\n  # no unwanted elements or attributes hidden inside it, we can tell Sanitize\n  # to allowlist the current node.\n  {:node_allowlist => [node]}\nend\n\nhtml = %[\n<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/dQw4w9WgXcQ\"\n    frameborder=\"0\" allowfullscreen></iframe>\n]\n\nSanitize.fragment(html, :transformers => youtube_transformer)\n# => '<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/dQw4w9WgXcQ\" frameborder=\"0\" allowfullscreen=\"\"></iframe>'\n```\n\nLicense\n-------\n\nCopyright (c) 2015 Ryan Grove (ryan@wonko.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the 'Software'), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "# encoding: utf-8\n\nclass Sanitize\n  module Config\n    DEFAULT = freeze_config(\n      # HTML attributes to add to specific elements. By default, no attributes\n      # are added.\n      :add_attributes => {},\n\n      # Whether or not to allow HTML comments. Allowing comments is strongly\n      # discouraged, since IE allows script execution within conditional\n      # comments.\n      :allow_comments => false,\n\n      # Whether or not to allow well-formed HTML doctype declarations such as\n      # \"<!DOCTYPE html>\" when sanitizing a document. This setting is ignored\n      # when sanitizing fragments.\n      :allow_doctype => false,\n\n      # HTML attributes to allow in specific elements. By default, no attributes\n      # are allowed. Use the symbol :data to indicate that arbitrary HTML5\n      # data-* attributes should be allowed.\n      :attributes => {},\n\n      # CSS sanitization settings.\n      :css => {\n        # Whether or not to allow CSS comments.\n        :allow_comments => false,\n\n        # Whether or not to allow browser compatibility hacks such as the IE *\n        # and _ hacks. These are generally harmless, but technically result in\n        # invalid CSS.\n        :allow_hacks => false,\n\n        # CSS at-rules to allow that may not have associated blocks (e.g.\n        # \"import\").\n        #\n        # https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n        :at_rules => [],\n\n        # CSS at-rules to allow whose blocks may contain properties (e.g.\n        # \"font-face\").\n        :at_rules_with_properties => [],\n\n        # CSS at-rules to allow whose blocks may contain styles (e.g. \"media\").\n        :at_rules_with_styles => [],\n\n        # CSS properties to allow.\n        :properties => [],\n\n        # URL protocols to allow in CSS URLs.\n        :protocols => []\n      },\n\n      # HTML elements to allow. By default, no elements are allowed (which means\n      # that all HTML will be stripped).\n      :elements => [],\n\n      # HTML parsing options to pass to Nokogumbo.\n      # https://github.com/rubys/nokogumbo/tree/v2.0.1#parsing-options\n      :parser_options => {},\n\n      # URL handling protocols to allow in specific attributes. By default, no\n      # protocols are allowed. Use :relative in place of a protocol if you want\n      # to allow relative URLs sans protocol.\n      :protocols => {},\n\n      # If this is true, Sanitize will remove the contents of any filtered\n      # elements in addition to the elements themselves. By default, Sanitize\n      # leaves the safe parts of an element's contents behind when the element\n      # is removed.\n      #\n      # If this is an Array or Set of element names, then only the contents of\n      # the specified elements (when filtered) will be removed, and the contents\n      # of all other filtered elements will be left behind.\n      :remove_contents => %w[\n        iframe math noembed noframes noscript plaintext script style svg xmp\n      ],\n\n      # Transformers allow you to filter or alter nodes using custom logic. See\n      # README.md for details and examples.\n      :transformers => [],\n\n      # Elements which, when removed, should have their contents surrounded by\n      # values specified with `before` and `after` keys to preserve readability.\n      # For example, `foo<div>bar</div>baz` will become 'foo bar baz' when the\n      # <div> is removed.\n      :whitespace_elements => {\n        'address'    => { :before => ' ', :after => ' ' },\n        'article'    => { :before => ' ', :after => ' ' },\n        'aside'      => { :before => ' ', :after => ' ' },\n        'blockquote' => { :before => ' ', :after => ' ' },\n        'br'         => { :before => ' ', :after => ' ' },\n        'dd'         => { :before => ' ', :after => ' ' },\n        'div'        => { :before => ' ', :after => ' ' },\n        'dl'         => { :before => ' ', :after => ' ' },\n        'dt'         => { :before => ' ', :after => ' ' },\n        'footer'     => { :before => ' ', :after => ' ' },\n        'h1'         => { :before => ' ', :after => ' ' },\n        'h2'         => { :before => ' ', :after => ' ' },\n        'h3'         => { :before => ' ', :after => ' ' },\n        'h4'         => { :before => ' ', :after => ' ' },\n        'h5'         => { :before => ' ', :after => ' ' },\n        'h6'         => { :before => ' ', :after => ' ' },\n        'header'     => { :before => ' ', :after => ' ' },\n        'hgroup'     => { :before => ' ', :after => ' ' },\n        'hr'         => { :before => ' ', :after => ' ' },\n        'li'         => { :before => ' ', :after => ' ' },\n        'nav'        => { :before => ' ', :after => ' ' },\n        'ol'         => { :before => ' ', :after => ' ' },\n        'p'          => { :before => ' ', :after => ' ' },\n        'pre'        => { :before => ' ', :after => ' ' },\n        'section'    => { :before => ' ', :after => ' ' },\n        'ul'         => { :before => ' ', :after => ' ' }\n      }\n    )\n  end\nend\n", "# encoding: utf-8\nrequire_relative 'common'\n\ndescribe 'Sanitize::Transformers::CleanElement' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  strings = {\n    :basic => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <style>.foo { color: #fff; }</style> <script>alert(\"hello world\");</script>',\n      :default    => 'Lorem ipsum dolor sit amet  ',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet  ',\n      :basic      => '<b>Lorem</b> <a href=\"pants\" rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet  ',\n      :relaxed    => '<b>Lorem</b> <a href=\"pants\" title=\"foo\" style=\"text-decoration: underline;\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet <style>.foo { color: #fff; }</style> '\n    },\n\n    :malformed => {\n      :html       => 'Lo<!-- comment -->rem</b> <a href=pants title=\"foo>ipsum <a href=\"http://foo.com/\"><strong>dolor</a></strong> sit<br/>amet <script>alert(\"hello world\");',\n      :default    => 'Lorem dolor sit amet ',\n      :restricted => 'Lorem <strong>dolor</strong> sit amet ',\n      :basic      => 'Lorem <a href=\"pants\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet ',\n      :relaxed    => 'Lorem <a href=\"pants\" title=\"foo>ipsum <a href=\"><strong>dolor</strong></a> sit<br>amet ',\n    },\n\n    :unclosed => {\n      :html       => '<p>a</p><blockquote>b',\n      :default    => ' a  b ',\n      :restricted => ' a  b ',\n      :basic      => '<p>a</p><blockquote>b</blockquote>',\n      :relaxed    => '<p>a</p><blockquote>b</blockquote>'\n    },\n\n    :malicious => {\n      :html       => '<b>Lo<!-- comment -->rem</b> <a href=\"javascript:pants\" title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br/>amet <<foo>script>alert(\"hello world\");</script>',\n      :default    => 'Lorem ipsum dolor sit amet &lt;script&gt;alert(\"hello world\");',\n      :restricted => '<b>Lorem</b> ipsum <strong>dolor</strong> sit amet &lt;script&gt;alert(\"hello world\");',\n      :basic      => '<b>Lorem</b> <a rel=\"nofollow\">ipsum</a> <a href=\"http://foo.com/\" rel=\"nofollow\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");',\n      :relaxed    => '<b>Lorem</b> <a title=\"foo\">ipsum</a> <a href=\"http://foo.com/\"><strong>dolor</strong></a> sit<br>amet &lt;script&gt;alert(\"hello world\");'\n    }\n  }\n\n  protocols = {\n    'protocol-based JS injection: simple, no spaces' => {\n      :html       => '<a href=\"javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before' => {\n      :html       => '<a href=\"javascript    :alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces after' => {\n      :html       => '<a href=\"javascript:    alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: simple, spaces before and after' => {\n      :html       => '<a href=\"javascript    :   alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: preceding colon' => {\n      :html       => '<a href=\":javascript:alert(\\'XSS\\');\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#58;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding' => {\n      :html       => '<a href=\"javascript&#0058;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long UTF-8 encoding without semicolons' => {\n      :html       => '<a href=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding' => {\n      :html       => '<a href=\"javascript&#x3A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: long hex encoding' => {\n      :html       => '<a href=\"javascript&#x003A;\">foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: hex encoding without semicolons' => {\n      :html       => '<a href=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>foo</a>',\n      :default    => 'foo',\n      :restricted => 'foo',\n      :basic      => '<a rel=\"nofollow\">foo</a>',\n      :relaxed    => '<a>foo</a>'\n    },\n\n    'protocol-based JS injection: null char' => {\n      :html       => \"<img src=java\\0script:alert(\\\"XSS\\\")>\",\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: invalid URL char' => {\n      :html       => '<img src=java\\script:alert(\"XSS\")>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol-based JS injection: spaces and entities' => {\n      :html       => '<img src=\" &#14;  javascript:alert(\\'XSS\\');\">',\n      :default    => '',\n      :restricted => '',\n      :basic      => '',\n      :relaxed    => '<img>'\n    },\n\n    'protocol whitespace' => {\n      :html       => '<a href=\" http://example.com/\"></a>',\n      :default    => '',\n      :restricted => '',\n      :basic      => '<a href=\"http://example.com/\" rel=\"nofollow\"></a>',\n      :relaxed    => '<a href=\"http://example.com/\"></a>'\n    }\n  }\n\n  describe 'Default config' do\n    it 'should remove non-allowlisted elements, leaving safe contents behind' do\n      Sanitize.fragment('foo <b>bar</b> <strong><a href=\"#a\">baz</a></strong> quux')\n        .must_equal 'foo bar baz quux'\n\n      Sanitize.fragment('<script>alert(\"<xss>\");</script>')\n        .must_equal ''\n\n      Sanitize.fragment('<<script>script>alert(\"<xss>\");</<script>>')\n        .must_equal '&lt;'\n\n      Sanitize.fragment('< script <>> alert(\"<xss>\");</script>')\n        .must_equal '&lt; script &lt;&gt;&gt; alert(\"\");'\n    end\n\n    it 'should surround the contents of :whitespace_elements with space characters when removing the element' do\n      Sanitize.fragment('foo<div>bar</div>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<br>bar<br>baz')\n        .must_equal 'foo bar baz'\n\n      Sanitize.fragment('foo<hr>bar<hr>baz')\n        .must_equal 'foo bar baz'\n    end\n\n    it 'should not choke on several instances of the same element in a row' do\n      Sanitize.fragment('<img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\"><img src=\"http://www.google.com/intl/en_ALL/images/logo.gif\">')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `iframe` elements' do\n      Sanitize.fragment('<iframe>hello! <script>alert(0)</script></iframe>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `math` elements' do\n      Sanitize.fragment('<math>hello! <script>alert(0)</script></math>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `noembed` elements' do\n      Sanitize.fragment('<noembed>hello! <script>alert(0)</script></noembed>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `noframes` elements' do\n      Sanitize.fragment('<noframes>hello! <script>alert(0)</script></noframes>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `noscript` elements' do\n      Sanitize.fragment('<noscript>hello! <script>alert(0)</script></noscript>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `plaintext` elements' do\n      Sanitize.fragment('<plaintext>hello! <script>alert(0)</script>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `script` elements' do\n      Sanitize.fragment('<script>hello! <script>alert(0)</script></script>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `style` elements' do\n      Sanitize.fragment('<style>hello! <script>alert(0)</script></style>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `svg` elements' do\n      Sanitize.fragment('<svg>hello! <script>alert(0)</script></svg>')\n        .must_equal ''\n    end\n\n    it 'should not preserve the content of removed `xmp` elements' do\n      Sanitize.fragment('<xmp>hello! <script>alert(0)</script></xmp>')\n        .must_equal ''\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        Sanitize.fragment(data[:html]).must_equal(data[:default])\n      end\n    end\n  end\n\n  describe 'Restricted config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RESTRICTED)\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:restricted])\n      end\n    end\n  end\n\n  describe 'Basic config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::BASIC)\n    end\n\n    it 'should not choke on valueless attributes' do\n      @s.fragment('foo <a href>foo</a> bar')\n        .must_equal 'foo <a href=\"\" rel=\"nofollow\">foo</a> bar'\n    end\n\n    it 'should downcase attribute names' do\n      @s.fragment('<a HREF=\"javascript:alert(\\'foo\\')\">bar</a>')\n        .must_equal '<a rel=\"nofollow\">bar</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:basic])\n      end\n    end\n  end\n\n  describe 'Relaxed config' do\n    before do\n      @s = Sanitize.new(Sanitize::Config::RELAXED)\n    end\n\n    it 'should encode special chars in attribute values' do\n      @s.fragment('<a href=\"http://example.com\" title=\"<b>&eacute;xamples</b> & things\">foo</a>')\n        .must_equal '<a href=\"http://example.com\" title=\"<b>\u00e9xamples</b> &amp; things\">foo</a>'\n    end\n\n    strings.each do |name, data|\n      it \"should clean #{name} HTML\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n\n    protocols.each do |name, data|\n      it \"should not allow #{name}\" do\n        @s.fragment(data[:html]).must_equal(data[:relaxed])\n      end\n    end\n  end\n\n  describe 'Custom configs' do\n    it 'should allow attributes on all elements if allowlisted under :all' do\n      input = '<p class=\"foo\">bar</p>'\n\n      Sanitize.fragment(input).must_equal ' bar '\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {:all => ['class']}\n      }).must_equal input\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'div' => ['class']}\n      }).must_equal '<p>bar</p>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['p'],\n        :attributes => {'p' => ['title'], :all => ['class']}\n      }).must_equal input\n    end\n\n    it \"should not allow relative URLs when relative URLs aren't allowlisted\" do\n      input = '<a href=\"/foo/bar\">Link</a>'\n\n      Sanitize.fragment(input,\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['http']}}\n      ).must_equal '<a>Link</a>'\n    end\n\n    it 'should allow relative URLs containing colons when the colon is not in the first path segment' do\n      input = '<a href=\"/wiki/Special:Random\">Random Page</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should allow relative URLs containing colons when the colon is part of an anchor' do\n      input = '<a href=\"#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n\n      input = '<a href=\"somepage#fn:1\">Footnote 1</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => [:relative]}}\n      }).must_equal input\n    end\n\n    it 'should remove the contents of filtered nodes when :remove_contents is true' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span></div>',\n        :remove_contents => true\n      ).must_equal 'foo bar   '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array or Set of element names as strings' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => ['script', 'span']\n      ).must_equal 'foo bar  baz hi '\n\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => Set.new(['script', 'span'])\n      ).must_equal 'foo bar  baz hi '\n    end\n\n    it 'should remove the contents of specified nodes when :remove_contents is an Array or Set of element names as symbols' do\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => [:script, :span]\n      ).must_equal 'foo bar  baz hi '\n\n      Sanitize.fragment('foo bar <div>baz<span>quux</span> <b>hi</b><script>alert(\"hello!\");</script></div>',\n        :remove_contents => Set.new([:script, :span])\n      ).must_equal 'foo bar  baz hi '\n    end\n\n    it 'should remove the contents of allowlisted iframes' do\n      Sanitize.fragment('<iframe>hi <script>hello</script></iframe>',\n        :elements => ['iframe']\n      ).must_equal '<iframe></iframe>'\n    end\n\n    it 'should not allow arbitrary HTML5 data attributes by default' do\n      Sanitize.fragment('<b data-foo=\"bar\"></b>',\n        :elements => ['b']\n      ).must_equal '<b></b>'\n\n      Sanitize.fragment('<b class=\"foo\" data-foo=\"bar\"></b>',\n        :attributes => {'b' => ['class']},\n        :elements   => ['b']\n      ).must_equal '<b class=\"foo\"></b>'\n    end\n\n    it 'should allow arbitrary HTML5 data attributes when the :attributes config includes :data' do\n      s = Sanitize.new(\n        :attributes => {'b' => [:data]},\n        :elements   => ['b']\n      )\n\n      s.fragment('<b data-foo=\"valid\" data-bar=\"valid\"></b>')\n        .must_equal '<b data-foo=\"valid\" data-bar=\"valid\"></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xml=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-xmlfoo=\"invalid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f:oo=\"valid\"></b>')\n        .must_equal '<b></b>'\n\n      s.fragment('<b data-f/oo=\"partial\"></b>')\n        .must_equal '<b data-f=\"\"></b>' # Nokogiri quirk; not ideal, but harmless\n\n      s.fragment('<b data-\u00e9foo=\"valid\"></b>')\n        .must_equal '<b></b>' # Another annoying Nokogiri quirk.\n    end\n\n    it 'should replace whitespace_elements with configured :before and :after values' do\n      s = Sanitize.new(\n        :whitespace_elements => {\n          'p'   => { :before => \"\\n\", :after => \"\\n\" },\n          'div' => { :before => \"\\n\", :after => \"\\n\" },\n          'br'  => { :before => \"\\n\", :after => \"\\n\" },\n        }\n      )\n\n      s.fragment('<p>foo</p>').must_equal \"\\nfoo\\n\"\n      s.fragment('<p>foo</p><p>bar</p>').must_equal \"\\nfoo\\n\\nbar\\n\"\n      s.fragment('foo<div>bar</div>baz').must_equal \"foo\\nbar\\nbaz\"\n      s.fragment('foo<br>bar<br>baz').must_equal \"foo\\nbar\\nbaz\"\n    end\n\n    it 'should handle protocols correctly regardless of case' do\n      input = '<a href=\"hTTpS://foo.com/\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal input\n\n      input = '<a href=\"mailto:someone@example.com?Subject=Hello\">Text</a>'\n\n      Sanitize.fragment(input, {\n        :elements   => ['a'],\n        :attributes => {'a' => ['href']},\n        :protocols  => {'a' => {'href' => ['https']}}\n      }).must_equal \"<a>Text</a>\"\n    end\n\n    it 'should prevent `<meta>` tags from being used to set a non-UTF-8 charset' do\n      Sanitize.document('<html><head><meta charset=\"utf-8\"></head><body>Howdy!</body></html>',\n        :elements   => %w[html head meta body],\n        :attributes => {'meta' => ['charset']}\n      ).must_equal \"<html><head><meta charset=\\\"utf-8\\\"></head><body>Howdy!</body></html>\"\n\n      Sanitize.document('<html><meta charset=\"utf-8\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => ['charset']}\n      ).must_equal \"<html><meta charset=\\\"utf-8\\\">Howdy!</html>\"\n\n      Sanitize.document('<html><meta charset=\"us-ascii\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => ['charset']}\n      ).must_equal \"<html><meta charset=\\\"utf-8\\\">Howdy!</html>\"\n\n      Sanitize.document('<html><meta http-equiv=\"content-type\" content=\" text/html; charset=us-ascii\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => %w[content http-equiv]}\n      ).must_equal \"<html><meta http-equiv=\\\"content-type\\\" content=\\\" text/html;charset=utf-8\\\">Howdy!</html>\"\n\n      Sanitize.document('<html><meta http-equiv=\"Content-Type\" content=\"text/plain;charset = us-ascii\">Howdy!</html>',\n        :elements   => %w[html meta],\n        :attributes => {'meta' => %w[content http-equiv]}\n      ).must_equal \"<html><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/plain;charset=utf-8\\\">Howdy!</html>\"\n    end\n\n    it 'should not modify `<meta>` tags that already set a UTF-8 charset' do\n      Sanitize.document('<html><head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"></head><body>Howdy!</body></html>',\n        :elements   => %w[html head meta body],\n        :attributes => {'meta' => %w[content http-equiv]}\n      ).must_equal \"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=utf-8\\\"></head><body>Howdy!</body></html>\"\n    end\n\n  end\nend\n", "# encoding: utf-8\nrequire_relative 'common'\n\n# Miscellaneous attempts to sneak maliciously crafted HTML past Sanitize. Many\n# of these are courtesy of (or inspired by) the OWASP XSS Filter Evasion Cheat\n# Sheet.\n#\n# https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n\ndescribe 'Malicious HTML' do\n  make_my_diffs_pretty!\n  parallelize_me!\n\n  before do\n    @s = Sanitize.new(Sanitize::Config::RELAXED)\n  end\n\n  describe 'comments' do\n    it 'should not allow script injection via conditional comments' do\n      @s.fragment(%[<!--[if gte IE 4]>\\n<script>alert('XSS');</script>\\n<![endif]-->]).\n        must_equal ''\n    end\n  end\n\n  describe 'interpolation (ERB, PHP, etc.)' do\n    it 'should escape ERB-style tags' do\n      @s.fragment('<% naughty_ruby_code %>').\n        must_equal '&lt;% naughty_ruby_code %&gt;'\n\n      @s.fragment('<%= naughty_ruby_code %>').\n        must_equal '&lt;%= naughty_ruby_code %&gt;'\n    end\n\n    it 'should remove PHP-style tags' do\n      @s.fragment('<? naughtyPHPCode(); ?>').\n        must_equal ''\n\n      @s.fragment('<?= naughtyPHPCode(); ?>').\n        must_equal ''\n    end\n  end\n\n  describe '<body>' do\n    it 'should not be possible to inject JS via a malformed event attribute' do\n      @s.document('<html><head></head><body onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\"XSS\")></body></html>').\n        must_equal \"<html><head></head><body></body></html>\"\n    end\n  end\n\n  describe '<iframe>' do\n    it 'should not be possible to inject an iframe using an improperly closed tag' do\n      @s.fragment(%[<iframe src=http://ha.ckers.org/scriptlet.html <]).\n        must_equal ''\n    end\n  end\n\n  describe '<img>' do\n    it 'should not be possible to inject JS via an unquoted <img> src attribute' do\n      @s.fragment(\"<img src=javascript:alert('XSS')>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using grave accents as <img> src delimiters' do\n      @s.fragment(\"<img src=`javascript:alert('XSS')`>\").must_equal '<img>'\n    end\n\n    it 'should not be possible to inject <script> via a malformed <img> tag' do\n      @s.fragment('<img \"\"\"><script>alert(\"XSS\")</script>\">').\n        must_equal '<img>\"&gt;'\n    end\n\n    it 'should not be possible to inject protocol-based JS' do\n      @s.fragment('<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>').\n        must_equal '<img>'\n\n      @s.fragment('<img src=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>').\n        must_equal '<img>'\n\n      # Encoded tab character.\n      @s.fragment(%[<img src=\"jav&#x09;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded newline.\n      @s.fragment(%[<img src=\"jav&#x0A;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Encoded carriage return.\n      @s.fragment(%[<img src=\"jav&#x0D;ascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Null byte.\n      @s.fragment(%[<img src=java\\0script:alert(\"XSS\")>]).\n        must_equal '<img>'\n\n      # Spaces plus meta char.\n      @s.fragment(%[<img src=\" &#14;  javascript:alert('XSS');\">]).\n        must_equal '<img>'\n\n      # Mixed spaces and tabs.\n      @s.fragment(%[<img src=\"j\\na v\\tascript://alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject protocol-based JS via whitespace' do\n      @s.fragment(%[<img src=\"jav\\tascript:alert('XSS');\">]).\n        must_equal '<img>'\n    end\n\n    it 'should not be possible to inject JS using a half-open <img> tag' do\n      @s.fragment(%[<img src=\"javascript:alert('XSS')\"]).\n        must_equal ''\n    end\n  end\n\n  describe '<script>' do\n    it 'should not be possible to inject <script> using a malformed non-alphanumeric tag name' do\n      @s.fragment(%[<script/xss src=\"http://ha.ckers.org/xss.js\">alert(1)</script>]).\n        must_equal ''\n    end\n\n    it 'should not be possible to inject <script> via extraneous open brackets' do\n      @s.fragment(%[<<script>alert(\"XSS\");//<</script>]).\n        must_equal '&lt;'\n    end\n  end\n\n  # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an\n  # attempt to preserve server-side includes. This can result in XSS since an\n  # unescaped double quote can allow an attacker to inject a non-allowlisted\n  # attribute. Sanitize works around this by implementing its own escaping for\n  # affected attributes.\n  #\n  # The relevant libxml2 code is here:\n  # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588>\n  describe 'unsafe libxml2 server-side includes in attributes' do\n    using_unpatched_libxml2 = Nokogiri::VersionInfo.instance.libxml2_using_system?\n\n    tag_configs = [\n      {\n        tag_name: 'a',\n        escaped_attrs: %w[ action href src name ],\n        unescaped_attrs: []\n      },\n\n      {\n        tag_name: 'div',\n        escaped_attrs: %w[ action href src ],\n        unescaped_attrs: %w[ name ]\n      }\n    ]\n\n    before do\n      @s = Sanitize.new({\n        elements: %w[ a div ],\n\n        attributes: {\n          all: %w[ action href src name ]\n        }\n      })\n    end\n\n    tag_configs.each do |tag_config|\n      tag_name = tag_config[:tag_name]\n\n      tag_config[:escaped_attrs].each do |attr_name|\n        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n\n        it 'should escape unsafe characters in attributes' do\n          skip \"behavior should only exist in nokogiri's patched libxml\" if using_unpatched_libxml2\n\n          # This uses Nokogumbo's HTML-compliant serializer rather than\n          # libxml2's.\n          @s.fragment(input).\n            must_equal(%[<#{tag_name} #{attr_name}=\"examp<!--%22%20onmouseover=alert(1)>-->le.com\">foo</#{tag_name}>])\n\n          # This uses the not-quite-standards-compliant libxml2 serializer via\n          # Nokogiri, so the output may be a little different as of Nokogiri\n          # 1.10.2 when using Nokogiri's vendored libxml2 due to this patch:\n          # https://github.com/sparklemotion/nokogiri/commit/4852e43cb6039e26d8c51af78621e539cbf46c5d\n          fragment = Nokogiri::HTML.fragment(input)\n          @s.node!(fragment)\n          fragment.to_html.\n            must_equal(%[<#{tag_name} #{attr_name}=\"examp&lt;!--%22%20onmouseover=alert(1)&gt;--&gt;le.com\">foo</#{tag_name}>])\n        end\n\n        it 'should round-trip to the same output' do\n          output = @s.fragment(input)\n          @s.fragment(output).must_equal(output)\n        end\n      end\n\n      tag_config[:unescaped_attrs].each do |attr_name|\n        input = %[<#{tag_name} #{attr_name}='examp<!--\" onmouseover=alert(1)>-->le.com'>foo</#{tag_name}>]\n\n        it 'should not escape characters unnecessarily' do\n          skip \"behavior should only exist in nokogiri's patched libxml\" if using_unpatched_libxml2\n\n          # This uses Nokogumbo's HTML-compliant serializer rather than\n          # libxml2's.\n          @s.fragment(input).\n            must_equal(%[<#{tag_name} #{attr_name}=\"examp<!--&quot; onmouseover=alert(1)>-->le.com\">foo</#{tag_name}>])\n\n          # This uses the not-quite-standards-compliant libxml2 serializer via\n          # Nokogiri, so the output may be a little different as of Nokogiri\n          # 1.10.2 when using Nokogiri's vendored libxml2 due to this patch:\n          # https://github.com/sparklemotion/nokogiri/commit/4852e43cb6039e26d8c51af78621e539cbf46c5d\n          fragment = Nokogiri::HTML.fragment(input)\n          @s.node!(fragment)\n          fragment.to_html.\n            must_equal(%[<#{tag_name} #{attr_name}='examp&lt;!--\" onmouseover=alert(1)&gt;--&gt;le.com'>foo</#{tag_name}>])\n        end\n\n        it 'should round-trip to the same output' do\n          output = @s.fragment(input)\n          @s.fragment(output).must_equal(output)\n        end\n      end\n    end\n  end\n\n  # https://github.com/rgrove/sanitize/security/advisories/GHSA-p4x4-rw2p-8j8m\n  describe 'foreign content bypass in relaxed config' do\n    it 'prevents a sanitization bypass via carefully crafted foreign content' do\n      %w[iframe noembed noframes noscript plaintext script style xmp].each do |tag_name|\n        @s.fragment(%[<math><#{tag_name}>/*&lt;/#{tag_name}&gt;&lt;img src onerror=alert(1)>*/]).\n          must_equal ''\n\n        @s.fragment(%[<svg><#{tag_name}>/*&lt;/#{tag_name}&gt;&lt;img src onerror=alert(1)>*/]).\n          must_equal ''\n      end\n    end\n  end\nend\n"], "filenames": ["README.md", "lib/sanitize/config/default.rb", "test/test_clean_element.rb", "test/test_malicious_html.rb"], "buggy_code_start_loc": [73, 77, 195, 221], "buggy_code_end_loc": [417, 78, 231, 221], "fixing_code_start_loc": [74, 77, 194, 222], "fixing_code_end_loc": [429, 78, 242, 235], "type": "CWE-79", "message": "In Sanitize (RubyGem sanitize) greater than or equal to 3.0.0 and less than 5.2.1, there is a cross-site scripting vulnerability. When HTML is sanitized using Sanitize's \"relaxed\" config, or a custom config that allows certain elements, some content in a math or svg element may not be sanitized correctly even if math and svg are not in the allowlist. You are likely to be vulnerable to this issue if you use Sanitize's relaxed config or a custom config that allows one or more of the following HTML elements: iframe, math, noembed, noframes, noscript, plaintext, script, style, svg, xmp. Using carefully crafted input, an attacker may be able to sneak arbitrary HTML through Sanitize, potentially resulting in XSS (cross-site scripting) or other undesired behavior when that HTML is rendered in a browser. This has been fixed in 5.2.1.", "other": {"cve": {"id": "CVE-2020-4054", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-16T22:15:10.693", "lastModified": "2020-09-28T20:15:13.373", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Sanitize (RubyGem sanitize) greater than or equal to 3.0.0 and less than 5.2.1, there is a cross-site scripting vulnerability. When HTML is sanitized using Sanitize's \"relaxed\" config, or a custom config that allows certain elements, some content in a math or svg element may not be sanitized correctly even if math and svg are not in the allowlist. You are likely to be vulnerable to this issue if you use Sanitize's relaxed config or a custom config that allows one or more of the following HTML elements: iframe, math, noembed, noframes, noscript, plaintext, script, style, svg, xmp. Using carefully crafted input, an attacker may be able to sneak arbitrary HTML through Sanitize, potentially resulting in XSS (cross-site scripting) or other undesired behavior when that HTML is rendered in a browser. This has been fixed in 5.2.1."}, {"lang": "es", "value": "En Sanitize (RubyGem sanitize) versiones mayor o igual a 3.0.0 y menor a 5.2.1, se presenta una vulnerabilidad de tipo cross-site scripting. Cuando se sanea HTML usando la configuraci\u00f3n \"relaxed\" de Sanitize, o una configuraci\u00f3n personalizada que permite determinados elementos, alg\u00fan contenido en un elemento math o svg puede no ser saneado correctamente incluso si math y svg no est\u00e1n en la lista de permitidos. Es probable que sea vulnerable a este problema si usa la configuraci\u00f3n relaxed de Sanitize o una configuraci\u00f3n personalizada que permite uno o m\u00e1s de los siguientes elementos HTML: iframe, math, noembed, noframes, noscript, plaintext, script, style, svg, xmp. Usando entradas cuidadosamente dise\u00f1ada, un atacante puede infiltrar HTML arbitrario por medio de Sanitize, resultando potencialmente en un ataque de tipo XSS (cross-site scripting) u otro comportamiento no deseado cuando ese HTML es renderizado en un navegador. Esto se ha corregido en la versi\u00f3n 5.2.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sanitize_project:sanitize:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "5.2.1", "matchCriteriaId": "74D82176-DC06-4206-8B6A-EFD1D3D54694"}]}]}], "references": [{"url": "https://github.com/rgrove/sanitize/commit/a11498de9e283cd457b35ee252983662f7452aa9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rgrove/sanitize/releases/tag/v5.2.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/rgrove/sanitize/security/advisories/GHSA-p4x4-rw2p-8j8m", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4543-1/", "source": "security-advisories@github.com"}, {"url": "https://www.debian.org/security/2020/dsa-4730", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/rgrove/sanitize/commit/a11498de9e283cd457b35ee252983662f7452aa9"}}