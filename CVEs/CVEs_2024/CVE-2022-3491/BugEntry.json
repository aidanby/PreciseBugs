{"buggy_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error', 'D')\n  var buf = g:RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xcompdir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      vim9script\n      export def OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xcompdir'\n  writefile(lines, 'XTest_compile_error', 'D')\n\n  var buf = g:RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_comment_error()\n  v9.CheckDefFailure(['#{ comment'], 'E1170:')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  v9.CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      function Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      def Object.Method()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      g:Object = {}\n      function g:Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        function s:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        def Object.Method()\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let g:Object = {}\n      def Define()\n        function g:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xnamedir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      vim9script\n      export def NoFunction()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xnamedir'\n  lines =<< trim END\n      call script#Function()\n  END\n  v9.CheckScriptFailure(lines, 'E117:', 1)\n\n  &rtp = save_rtp\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xandir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xandir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xaedir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xaedir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    v9.CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  v9.CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\nenddef\n\ndef s:CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef s:CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  v9.CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  v9.CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  g:ReturnString()->assert_equal('string')\n  g:ReturnNumber()->assert_equal(123)\n  assert_fails('g:ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\n\n  var lines =<< trim END\n      vim9script\n\n      def Msg()\n          echomsg 'in Msg()...'\n      enddef\n\n      def Func()\n        return Msg()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1096:')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif',\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif',\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif',\n                   '  return 3',\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  g:ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  v9.CheckScriptFailure(lines, 'E1010:')\n  v9.CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  # This used to fail but now the actual list type is checked, and since it has\n  # an item of type string it can be used as list<string>.\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_return_any_two_types()\n  var lines =<< trim END\n      vim9script\n\n      def G(Fn: func(string): any)\n        g:result = Fn(\"hello\")\n      enddef\n\n      def F(a: number, b: string): any\n        echo b\n        if a > 0\n          return 1\n        else\n          return []\n        endif\n      enddef\n\n      G(function(F, [1]))\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result)\n  unlet g:result\nenddef\n\nfunc s:Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef Test_call_ufunc_failure()\n  var lines =<< trim END\n      vim9script\n      def Tryit()\n        g:Global(1, 2, 3)\n      enddef\n\n      func g:Global(a, b, c)\n        echo a:a a:b a:c\n      endfunc\n\n      defcompile\n\n      func! g:Global(a, b)\n        echo a:a a:b \n      endfunc\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E118: Too many arguments for function: Global')\n  delfunc g:Global\n\n  lines =<< trim END\n      vim9script\n\n      g:Ref = function('len')\n      def Tryit()\n        g:Ref('x')\n      enddef\n\n      defcompile\n\n      g:Ref = function('add')\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E119: Not enough arguments for function: add')\n  unlet g:Ref\nenddef\n\ndef s:MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  v9.CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef s:MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  g:MyDefaultArgs()->assert_equal('string')\n  g:MyDefaultArgs(v:none)->assert_equal('string')\n  g:MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('g:MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  v9.CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  v9.CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  v9.CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  v9.CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  v9.CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  v9.CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  v9.CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  v9.CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def _Inner()\n          echo 'bad'\n        enddef\n        _Inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:inner()\n          echo 'bad'\n        enddef\n        g:inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def g:_Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # nested function with recursive call\n  lines =<< trim END\n      vim9script\n\n      def MyFunc(): number\n        def Fib(n: number): number\n          if n < 2\n            return 1\n          endif\n          return Fib(n - 2) + Fib(n - 1)\n        enddef\n\n        return Fib(5)\n      enddef\n\n      assert_equal(8, MyFunc())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_nested_function_fails()\n  var lines =<< trim END\n      def T()\n        def Func(g: string):string\n        enddef\n        Func()\n      enddef\n      silent! defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  v9.CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_function_not_found()\n  var lines =<< trim END\n      g:Ref = 123\n      call g:Ref()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E117:', 'E1085:'], 2)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      Funcy()\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  v9.CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is not found with g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\n  delfunc g:Func\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', g:Func())\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # This does not shadow \"i\" which is visible only inside the for loop\n  lines =<< trim END\n      vim9script\n\n      def Foo(i: number)\n        echo i\n      enddef\n\n      for i in range(3)\n        # Foo() is compiled here\n        Foo(i)\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  v9.CheckDefFailure(['g:TakesOneArg()'], 'E119:')\n  v9.CheckDefFailure(['g:TakesOneArg(11, 22)'], 'E118:')\n  v9.CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  v9.CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  # argument name declared earlier is found when declaring a function\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # same, inside the same block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # variable in other block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n    endif\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # with another variable in another block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      var name = 'peter'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # only variable in another block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # argument name declared later is only found when compiling\n  lines =<< trim END\n    vim9script\n    def FuncOne(name: string)\n      echo nr\n    enddef\n    var name = 'piet'\n  END\n  v9.CheckScriptSuccess(lines)\n  v9.CheckScriptFailure(lines + ['defcompile'], 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript', 'D')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  v9.CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  v9.CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  v9.CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo g:FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo g:FilterWithCond('foo', (v) => v .. '^b')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  v9.CheckDefSuccess([\n        'var x: any = \"aaa\"',\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_lambda_invalid_block()\n  var lines =<< trim END\n      timer_start(0, (_) => { # echo\n          echo 'yes'\n        })\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      timer_start(0, (_) => { \" echo\n          echo 'yes'\n        })\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E488: Trailing characters: \" echo')\n\n  lines =<< trim END\n      timer_start(0, (_) => { | echo\n          echo 'yes'\n        })\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E488: Trailing characters: | echo')\nenddef\n\ndef Test_lambda_with_following_cmd()\n  var lines =<< trim END\n      set ts=2\n      var Lambda = () => {\n          set ts=4\n        } | set ts=3\n      assert_equal(3, &ts)\n      Lambda()\n      assert_equal(4, &ts)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  set ts=8\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(F: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(F: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func g:Getit()\n        return 'it'\n      endfunc\n      var Fn = g:Getit\n      assert_equal('it', Fn())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_define_lambda_in_execute()\n  var lines =<< trim [CODE]\n      vim9script\n\n      def BuildFuncMultiLine(): func\n          var x =<< trim END\n              g:SomeRandomFunc = (d: dict<any>) => {\n                  return d.k1 + d.k2\n              }\n          END\n          execute(x)\n          return g:SomeRandomFunc\n      enddef\n      var ResultPlus = BuildFuncMultiLine()\n      assert_equal(7, ResultPlus({k1: 3, k2: 4}))\n  [CODE]\n  v9.CheckScriptSuccess(lines)\n  unlet g:SomeRandomFunc\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('g:MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  g:MyDefVarargs('one')->assert_equal('one,foo')\n  g:MyDefVarargs('one', 'two')->assert_equal('one,two')\n  g:MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = g:FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = g:FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  v9.CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  v9.CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = g:FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  g:MyVarargsOnly()->assert_equal('')\n  g:MyVarargsOnly('one')->assert_equal('one')\n  g:MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  v9.CheckDefFailure(['g:MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  var lines =<< trim END\n      def Func(x: number)\n        var x = 234\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1006:')\n\n  lines =<< trim END\n      def Func(Ref: number)\n        def Ref()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\nenddef\n\ndef s:DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef s:ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  v9.CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef s:WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function('s:func')\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function(s:func)\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = s:func\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('g:FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\n\n  lines =<< trim END\n      vim9script\n      def FirstFunction()\n        func SecondFunction()\n        endfunc|BBBB\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\nenddef\n\ndef Test_error_in_function_args()\n  var lines =<< trim END\n      def FirstFunction()\n        def SecondFunction(J  =\n        # Nois\n        # one\n         \n         enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_return_type_wrong()\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008: Missing <type> after list')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008: Missing <type> after dict')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  v9.CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type> after list')\n  v9.CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  v9.CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  v9.CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  v9.CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  v9.CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim', 'D')\n  source Xcall.vim\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim', 'D')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  v9.CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      g:GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc', 'D')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  v9.CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func', 'D')\n  so XVim9Func\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef s:FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef s:FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = g:FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in repeat(0z01, 3)->blob2list()\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = g:FuncNoArgNoRet\n  RefVoid = g:FuncOneArgNoRet\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = g:FuncNoArgRetNumber\n  RefAny = g:FuncNoArgRetString\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = g:FuncNoArgRetNumber\n  RefNr = g:FuncOneArgRetNumber\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = g:FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  v9.CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  v9.CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  v9.CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  v9.CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  v9.CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  v9.CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = g:FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  v9.CheckDefFailure(['var str: string', 'str = g:FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef s:MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call s:MultiLine('text')->assert_equal('text1234')\n  call s:MultiLine('text', 777)->assert_equal('text777')\n  call s:MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call s:MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef', 'D')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\nenddef\n\ndef Test_deleted_function()\n  v9.CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  v9.CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef s:RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef s:MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef s:MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef s:ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef s:MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc s:GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  v9.CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Run_Test_closure_in_for_loop_fails()\n  var lines =<< trim END\n    vim9script\n    redraw\n    for n in [0]\n        # time should be enough for startup to finish\n        timer_start(200, (_) => {\n            echo n\n        })\n    endfor\n  END\n  writefile(lines, 'XTest_closure_fails', 'D')\n\n  # Check that an error shows\n  var buf = g:RunVimInTerminal('-S XTest_closure_fails', {rows: 6, wait_for_ruler: 0})\n  g:VerifyScreenDump(buf, 'Test_vim9_closure_fails', {wait: 3000})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\nfunc Test_closure_in_for_loop_fails()\n  CheckScreendump\n  call Run_Test_closure_in_for_loop_fails()\nendfunc\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  v9.CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def Func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], g:Shadowed())\nenddef\n\ndef Test_compiling_referenced_func_no_shadow()\n  var lines =<< trim END\n      vim9script\n\n      def InitializeReply(lspserver: dict<any>)\n      enddef\n\n      def ProcessReply(lspserver: dict<any>)\n        var lsp_reply_handlers: dict<func> =\n          { 'initialize': InitializeReply }\n        lsp_reply_handlers['initialize'](lspserver)\n      enddef\n\n      call ProcessReply({})\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    v9.CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo', 'D')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = g:RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  g:VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc s:UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef s:TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'pR')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  v9.CheckScriptFailure(lines, 'E1031:')\nenddef\n\ndef Test_partial_double_nested()\n  var idx = 123\n  var Get = () => idx\n  var Ref = function(Get, [])\n  var RefRef = function(Ref, [])\n  assert_equal(123, RefRef())\nenddef\n\ndef Test_partial_null_function()\n  var lines =<< trim END\n      var d: dict<func> = {f: null_function}\n      var Ref = d.f\n      assert_equal('func(...): unknown', typename(Ref))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  v9.CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  g:StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    g:StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset', 'D')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname, 'D')\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=g:Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error', 'D')\n\n  var buf = g:RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  g:WaitForAssert(() => assert_match('E684: List index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !g:RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_nested_closure_funcref()\n  var lines =<< trim END\n      vim9script\n      def Func()\n          var n: number\n          def Nested()\n              ++n\n          enddef\n          Nested()\n          g:result_one = n\n          var Ref = function(Nested)\n          Ref()\n          g:result_two = n\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result_one)\n  assert_equal(2, g:result_two)\n  unlet g:result_one g:result_two\nenddef\n\ndef Test_nested_closure_in_dict()\n  var lines =<< trim END\n      vim9script\n      def Func(): dict<any>\n        var n: number\n        def Inc(): number\n          ++n\n          return n\n        enddef\n        return {inc: function(Inc)}\n      enddef\n      disas Func\n      var d = Func()\n      assert_equal(1, d.inc())\n      assert_equal(2, d.inc())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_script_local_other_script()\n  var lines =<< trim END\n      function LegacyJob()\n        let FuncRef = function('s:close_cb')\n      endfunction\n      function s:close_cb(...)\n      endfunction\n  END\n  lines->writefile('Xlegacy.vim', 'D')\n  source Xlegacy.vim\n  g:LegacyJob()\n  g:LegacyJob()\n  g:LegacyJob()\n\n  delfunc g:LegacyJob\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(Fg: func): dict<func>\n        return {f: Fg}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  v9.CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  v9.CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\n\n  v9.CheckScriptFailure(lines + ['def SomeFunc(ff: func)', 'enddef'], 'E704:')\nenddef\n\ndef Test_call_func_with_null()\n  var lines =<< trim END\n      def Fstring(v: string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring(null_string)\n      def Fblob(v: blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob(null_blob)\n      def Flist(v: list<number>)\n        assert_equal(null_list, v)\n      enddef\n      Flist(null_list)\n      def Fdict(v: dict<number>)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict(null_dict)\n      def Ffunc(Fv: func(number): number)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc(null_function)\n      if has('channel')\n        def Fchannel(v: channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel(null_channel)\n        def Fjob(v: job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob(null_job)\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_default_argument()\n  var lines =<< trim END\n      def Fstring(v: string = null_string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring()\n      def Fblob(v: blob = null_blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob()\n      def Flist(v: list<number> = null_list)\n        assert_equal(null_list, v)\n      enddef\n      Flist()\n      def Fdict(v: dict<number> = null_dict)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict()\n      def Ffunc(Fv: func(number): number = null_function)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc()\n      if has('channel')\n        def Fchannel(v: channel = null_channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel()\n        def Fjob(v: job = null_job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob()\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_return()\n  var lines =<< trim END\n      def Fstring(): string\n        return null_string\n      enddef\n      assert_equal(null_string, Fstring())\n      def Fblob(): blob\n        return null_blob\n      enddef\n      assert_equal(null_blob, Fblob())\n      def Flist(): list<number>\n        return null_list\n      enddef\n      assert_equal(null_list, Flist())\n      def Fdict(): dict<number>\n        return null_dict\n      enddef\n      assert_equal(null_dict, Fdict())\n      def Ffunc(): func(number): number\n        return null_function\n      enddef\n      assert_equal(null_function, Ffunc())\n      if has('channel')\n        def Fchannel(): channel\n          return null_channel\n        enddef\n        assert_equal(null_channel, Fchannel())\n        def Fjob(): job\n          return null_job\n        enddef\n        assert_equal(null_job, Fjob())\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  # \"any\" could be \"dict<any>\", thus OK\n  lines[2] = 'var l: list<any>'\n  v9.CheckScriptSuccess(lines)\n  lines[2] = 'var l: list<any> = []'\n  v9.CheckScriptSuccess(lines)\n\n  lines[2] = 'var l: list<any> = [11]'\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  v9.CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176:', 'E1106: 2 arguments too many'], 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176', 'E1106: One argument too many'], 1)\n\n  lines =<< trim END\n      vim9script\n      def OneArgument(arg: string)\n        echo arg\n      enddef\n      var Ref = OneArgument\n      Ref('a', 'b')\n  END\n  v9.CheckScriptFailure(lines, 'E118:')\nenddef\n\ndef Test_funcref_with_base()\n  var lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      Ref('a', 12)\n      'b'->Ref(34)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      'a'->Ref('b')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string', 6)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref(456)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(nr: number, str: string)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref('b')\n      def AndNowCompiled()\n        456->Ref('x')\n      enddef\n      AndNowCompiled()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc s:CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\ndef Test_numbered_function_call()\n  var lines =<< trim END\n      let s:legacyscript = {}\n      func s:legacyscript.Helper() abort\n        return \"Success\"\n      endfunc\n      let g:legacyscript = deepcopy(s:legacyscript)\n\n      let g:legacy_result = eval(\"g:legacyscript.Helper()\")\n      vim9cmd g:vim9_result = eval(\"g:legacyscript.Helper()\")\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('Success', g:legacy_result)\n  assert_equal('Success', g:vim9_result)\n\n  unlet g:legacy_result\n  unlet g:vim9_result\nenddef\n\ndef Test_go_beyond_end_of_cmd()\n  # this was reading the byte after the end of the line\n  var lines =<< trim END\n    def F()\n      cal\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:')\nenddef\n\n\" Test for memory allocation failure when defining a new lambda\nfunc Test_lambda_allocation_failure()\n  new\n  let lines =<< trim END\n    vim9script\n    g:Xlambda = (x): number => {\n        return x + 1\n      }\n  END\n  call setline(1, lines)\n  call test_alloc_fail(GetAllocId('get_func'), 0, 0)\n  call assert_fails('source', 'E342:')\n  call assert_false(exists('g:Xlambda'))\n  bw!\nendfunc\n\ndef Test_multiple_funcref()\n  # This was using a NULL pointer\n  var lines =<< trim END\n      vim9script\n      def A(F: func, ...args: list<any>): func\n          return funcref(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # slightly different case\n  lines =<< trim END\n      vim9script\n\n      def A(F: func, ...args: list<any>): any\n          return call(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cexpr_errmsg_line_number()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var qfl = {}\n        cexpr qfl\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E777', 2)\nenddef\n\ndef AddDefer(s: string)\n  g:deferred->extend([s])\nenddef\n\ndef DeferTwo()\n  g:deferred->extend(['in Two'])\n  for n in range(3)\n    defer g:AddDefer('two' .. n)\n  endfor\n  g:deferred->extend(['end Two'])\nenddef\n\ndef DeferOne()\n  g:deferred->extend(['in One'])\n  defer g:AddDefer('one')\n  g:DeferTwo()\n  g:deferred->extend(['end One'])\n\n  writefile(['text'], 'XdeferFile')\n  defer delete('XdeferFile')\nenddef\n\ndef Test_defer()\n  g:deferred = []\n  g:DeferOne()\n  assert_equal(['in One', 'in Two', 'end Two', 'two2', 'two1', 'two0', 'end One', 'one'], g:deferred)\n  unlet g:deferred\n  assert_equal('', glob('XdeferFile'))\nenddef\n\n\" The following messes up syntax highlight, keep near the end.\nif has('python3')\n  def Test_python3_command()\n    py3 import vim\n    py3 vim.command(\"g:done = 'yes'\")\n    assert_equal('yes', g:done)\n    unlet g:done\n  enddef\n\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\n\n  def Test_lua_heredoc_fails()\n    var lines = [\n      'vim9script',\n      'def ExeLua()',\n        'lua << trim EOLUA',\n            \"x = vim.eval('g:nodict')\",\n        'EOLUA',\n      'enddef',\n      'ExeLua()',\n      ]\n    v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:nodict')\n  enddef\nendif\n\nif has('perl')\n  def Test_perl_heredoc_nested()\n    var lines =<< trim END\n        vim9script\n        def F(): string\n            def G(): string\n                perl << EOF\n        EOF\n                return 'done'\n            enddef\n            return G()\n        enddef\n        assert_equal('done', F())\n    END\n    v9.CheckScriptSuccess(lines)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\nsource shared.vim\n\ndef Test_vim9script_feature()\n  # example from the help, here the feature is always present\n  var lines =<< trim END\n      \" old style comment\n      if !has('vim9script')\n        \" legacy commands would go here\n        finish\n      endif\n      vim9script\n      # Vim9 script commands go here\n      g:didit = true\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(true, g:didit)\n  unlet g:didit\nenddef\n\ndef Test_range_only()\n  new\n  setline(1, ['blah', 'Blah'])\n  :/Blah/\n  assert_equal(2, getcurpos()[1])\n  bwipe!\n\n  # without range commands use current line\n  new\n  setline(1, ['one', 'two', 'three'])\n  :2\n  print\n  assert_equal('two', g:Screenline(&lines))\n  :3\n  list\n  assert_equal('three$', g:Screenline(&lines))\n\n  # missing command does not print the line\n  var lines =<< trim END\n    vim9script\n    :1|\n    assert_equal('three$', g:Screenline(&lines))\n    :|\n    assert_equal('three$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  bwipe!\n\n  lines =<< trim END\n      set cpo+=-\n      :1,999\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E16:', 2)\n  set cpo&vim\n\n  v9.CheckDefExecAndScriptFailure([\":'x\"], 'E20:', 1)\n\n  # won't generate anything\n  if false\n    :123\n  endif\nenddef\n\ndef Test_invalid_range()\n  var lines =<< trim END\n      :123 eval 1 + 2\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 if true\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 echo 'yes'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 cd there\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\nenddef\n\nlet g:alist = [7]\nlet g:astring = 'text'\nlet g:anumber = 123\n\ndef Test_delfunction()\n  # Check function is defined in script namespace\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func CheckMe()',\n      '  return 123',\n      'endfunc',\n      'func DoTest()',\n      '  call assert_equal(123, s:CheckMe())',\n      'endfunc',\n      'DoTest()',\n      ])\n\n  # Check function in script namespace cannot be deleted\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe1()',\n      'endfunc',\n      'delfunction DeleteMe1',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe2()',\n      'endfunc',\n      'def DoThat()',\n      '  delfunction DeleteMe2',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe3()',\n      'enddef',\n      'delfunction DeleteMe3',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe4()',\n      'enddef',\n      'def DoThat()',\n      '  delfunction DeleteMe4',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n\n  # Check that global :def function can be replaced and deleted\n  var lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global function can be replaced by a :def function and deleted\n  lines =<< trim END\n      vim9script\n      func g:Global()\n        return \"yes\"\n      endfunc\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global :def function can be replaced by a function and deleted\n  lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      func! g:Global()\n        return \"no\"\n      endfunc\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_wrong_type()\n  v9.CheckDefFailure(['var name: list<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: list<list<nothing>>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<dict<nothing>>'], 'E1010:')\n\n  v9.CheckDefFailure(['var name: dict<number'], 'E1009:')\n  v9.CheckDefFailure(['var name: dict<list<number>'], 'E1009:')\n\n  v9.CheckDefFailure(['var name: ally'], 'E1010:')\n  v9.CheckDefFailure(['var name: bram'], 'E1010:')\n  v9.CheckDefFailure(['var name: cathy'], 'E1010:')\n  v9.CheckDefFailure(['var name: dom'], 'E1010:')\n  v9.CheckDefFailure(['var name: freddy'], 'E1010:')\n  v9.CheckDefFailure(['var name: john'], 'E1010:')\n  v9.CheckDefFailure(['var name: larry'], 'E1010:')\n  v9.CheckDefFailure(['var name: ned'], 'E1010:')\n  v9.CheckDefFailure(['var name: pam'], 'E1010:')\n  v9.CheckDefFailure(['var name: sam'], 'E1010:')\n  v9.CheckDefFailure(['var name: vim'], 'E1010:')\n\n  v9.CheckDefFailure(['var Ref: number', 'Ref()'], 'E1085:')\n  v9.CheckDefFailure(['var Ref: string', 'var res = Ref()'], 'E1085:')\nenddef\n\ndef Test_script_namespace()\n  # defining a function or variable with s: is not allowed\n  var lines =<< trim END\n      vim9script\n      def s:Function()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  for decl in ['var', 'const', 'final']\n    lines =<< trim END\n        vim9script\n        var s:var = 'var'\n    END\n    v9.CheckScriptFailure([\n        'vim9script',\n        decl .. ' s:var = \"var\"',\n        ], 'E1268:')\n  endfor\n\n  # Calling a function or using a variable with s: is not allowed at script\n  # level\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      call s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      var var = 'var'\n      echo s:var\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\nenddef\n\ndef Test_script_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var dict: dict<string>\n      dict['a'] = ['x']\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got list<string>', 3)\nenddef\n\ndef Test_const()\n  v9.CheckDefFailure(['final name = 234', 'name = 99'], 'E1018:')\n  v9.CheckDefFailure(['final one = 234', 'var one = 99'], 'E1017:')\n  v9.CheckDefFailure(['final list = [1, 2]', 'var list = [3, 4]'], 'E1017:')\n  v9.CheckDefFailure(['final two'], 'E1125:')\n  v9.CheckDefFailure(['final &option'], 'E996:')\n\n  var lines =<< trim END\n    final list = [1, 2, 3]\n    list[0] = 4\n    list->assert_equal([4, 2, 3])\n    const other = [5, 6, 7]\n    other->assert_equal([5, 6, 7])\n\n    var varlist = [7, 8]\n    const constlist = [1, varlist, 3]\n    varlist[0] = 77\n    constlist[1][1] = 88\n    var cl = constlist[1]\n    cl[1] = 88\n    constlist->assert_equal([1, [77, 88], 3])\n\n    var vardict = {five: 5, six: 6}\n    const constdict = {one: 1, two: vardict, three: 3}\n    vardict['five'] = 55\n    constdict['two']['six'] = 66\n    var cd = constdict['two']\n    cd['six'] = 66\n    constdict->assert_equal({one: 1, two: {five: 55, six: 66}, three: 3})\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # \"any\" type with const flag is recognized as \"any\"\n  lines =<< trim END\n      const dict: dict<any> = {foo: {bar: 42}}\n      const foo = dict.foo\n      assert_equal(v:t_number, type(foo.bar))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also when used as a builtin function argument\n  lines =<< trim END\n      vim9script\n\n      def SorterFunc(lhs: dict<string>, rhs: dict<string>): number\n        return lhs.name <# rhs.name ? -1 : 1\n      enddef\n\n      def Run(): void\n        var list =  [{name: \"3\"}, {name: \"2\"}]\n        const Sorter = get({}, \"unknown\", SorterFunc)\n        sort(list, Sorter)\n        assert_equal([{name: \"2\"}, {name: \"3\"}], list)\n      enddef\n\n      Run()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_const_bang()\n  var lines =<< trim END\n      const var = 234\n      var = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1018:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E46:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[0] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1119:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[3] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1118:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E684:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"one\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1121:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"three\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1120:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\nenddef\n\ndef Test_range_no_colon()\n  v9.CheckDefFailure(['%s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['+ s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['- s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['. s/a/b/'], 'E1050:')\nenddef\n\n\ndef Test_block()\n  var outer = 1\n  {\n    var inner = 2\n    assert_equal(1, outer)\n    assert_equal(2, inner)\n  }\n  assert_equal(1, outer)\n\n  {|echo 'yes'|}\nenddef\n\ndef Test_block_failure()\n  v9.CheckDefFailure(['{', 'var inner = 1', '}', 'echo inner'], 'E1001:')\n  v9.CheckDefFailure(['}'], 'E1025:')\n  v9.CheckDefFailure(['{', 'echo 1'], 'E1026:')\nenddef\n\ndef Test_block_local_vars()\n  var lines =<< trim END\n      vim9script\n      v:testing = 1\n      if true\n        var text = ['hello']\n        def SayHello(): list<string>\n          return text\n        enddef\n        def SetText(v: string)\n          text = [v]\n        enddef\n      endif\n\n      if true\n        var text = ['again']\n        def SayAgain(): list<string>\n          return text\n        enddef\n      endif\n\n      # test that the \"text\" variables are not cleaned up\n      test_garbagecollect_now()\n\n      defcompile\n\n      assert_equal(['hello'], SayHello())\n      assert_equal(['again'], SayAgain())\n\n      SetText('foobar')\n      assert_equal(['foobar'], SayHello())\n\n      call writefile(['ok'], 'Xdidit')\n      qall!\n  END\n\n  # need to execute this with a separate Vim instance to avoid the current\n  # context gets garbage collected.\n  writefile(lines, 'Xscript', 'D')\n  g:RunVim([], [], '-S Xscript')\n  assert_equal(['ok'], readfile('Xdidit'))\n\n  delete('Xdidit')\nenddef\n\ndef Test_block_local_vars_with_func()\n  var lines =<< trim END\n      vim9script\n      if true\n        var foo = 'foo'\n        if true\n          var bar = 'bar'\n          def Func(): list<string>\n            return [foo, bar]\n          enddef\n        endif\n      endif\n      # function is compiled here, after blocks have finished, can still access\n      # \"foo\" and \"bar\"\n      assert_equal(['foo', 'bar'], Func())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\n\" legacy func for command that's defined later\nfunc s:InvokeSomeCommand()\n  SomeCommand\nendfunc\n\ndef Test_autocommand_block()\n  com SomeCommand {\n      g:someVar = 'some'\n    }\n  InvokeSomeCommand()\n  assert_equal('some', g:someVar)\n\n  delcommand SomeCommand\n  unlet g:someVar\nenddef\n\ndef Test_command_block()\n  au BufNew *.xml {\n      g:otherVar = 'other'\n    }\n  split other.xml\n  assert_equal('other', g:otherVar)\n\n  bwipe!\n  au! BufNew *.xml\n  unlet g:otherVar\nenddef\n\nfunc g:NoSuchFunc()\n  echo 'none'\nendfunc\n\ndef Test_try_catch_throw()\n  var l = []\n  try # comment\n    add(l, '1')\n    throw 'wrong'\n    add(l, '2')\n  catch # comment\n    add(l, v:exception)\n  finally # comment\n    add(l, '3')\n  endtry # comment\n  assert_equal(['1', 'wrong', '3'], l)\n\n  l = []\n  try\n    try\n      add(l, '1')\n      throw 'wrong'\n      add(l, '2')\n    catch /right/\n      add(l, v:exception)\n    endtry\n  catch /wrong/\n    add(l, 'caught')\n  finally\n    add(l, 'finally')\n  endtry\n  assert_equal(['1', 'caught', 'finally'], l)\n\n  var n: number\n  try\n    n = l[3]\n  catch /E684:/\n    n = 99\n  endtry\n  assert_equal(99, n)\n\n  var done = 'no'\n  if 0\n    try | catch | endtry\n  else\n    done = 'yes'\n  endif\n  assert_equal('yes', done)\n\n  done = 'no'\n  if 1\n    done = 'yes'\n  else\n    try | catch | endtry\n    done = 'never'\n  endif\n  assert_equal('yes', done)\n\n  if 1\n  else\n    try | catch /pat/ | endtry\n    try | catch /pat/ \n    endtry\n    try \n    catch /pat/ | endtry\n    try \n    catch /pat/ \n    endtry\n  endif\n\n  try\n    # string slice returns a string, not a number\n    n = g:astring[3]\n  catch /E1012:/\n    n = 77\n  endtry\n  assert_equal(77, n)\n\n  try\n    n = l[g:astring]\n  catch /E1012:/\n    n = 88\n  endtry\n  assert_equal(88, n)\n\n  try\n    n = s:does_not_exist\n  catch /E121:/\n    n = 111\n  endtry\n  assert_equal(111, n)\n\n  try\n    n = g:does_not_exist\n  catch /E121:/\n    n = 121\n  endtry\n  assert_equal(121, n)\n\n  var d = {one: 1}\n  try\n    n = d[g:astring]\n  catch /E716:/\n    n = 222\n  endtry\n  assert_equal(222, n)\n\n  try\n    n = -g:astring\n  catch /E1012:/\n    n = 233\n  endtry\n  assert_equal(233, n)\n\n  try\n    n = +g:astring\n  catch /E1012:/\n    n = 244\n  endtry\n  assert_equal(244, n)\n\n  try\n    n = +g:alist\n  catch /E1012:/\n    n = 255\n  endtry\n  assert_equal(255, n)\n\n  var nd: dict<any>\n  try\n    nd = {[g:alist]: 1}\n  catch /E1105:/\n    n = 266\n  endtry\n  assert_equal(266, n)\n\n  l = [1, 2, 3] \n  try\n    [n] = l\n  catch /E1093:/\n    n = 277\n  endtry\n  assert_equal(277, n)\n\n  try\n    &ts = g:astring\n  catch /E1012:/\n    n = 288\n  endtry\n  assert_equal(288, n)\n\n  try\n    &backspace = 'asdf'\n  catch /E474:/\n    n = 299\n  endtry\n  assert_equal(299, n)\n\n  l = [1]\n  try\n    l[3] = 3\n  catch /E684:/\n    n = 300\n  endtry\n  assert_equal(300, n)\n\n  try\n    unlet g:does_not_exist\n  catch /E108:/\n    n = 322\n  endtry\n  assert_equal(322, n)\n\n  try\n    d = {text: 1, [g:astring]: 2}\n  catch /E721:/\n    n = 333\n  endtry\n  assert_equal(333, n)\n\n  try\n    l = g:DeletedFunc()\n  catch /E933:/\n    n = 344\n  endtry\n  assert_equal(344, n)\n\n  try\n    echo range(1, 2, 0)\n  catch /E726:/\n    n = 355\n  endtry\n  assert_equal(355, n)\n\n  var P = function('g:NoSuchFunc')\n  delfunc g:NoSuchFunc\n  try\n    echo P()\n  catch /E117:/\n    n = 366\n  endtry\n  assert_equal(366, n)\n\n  try\n    echo g:NoSuchFunc()\n  catch /E117:/\n    n = 377\n  endtry\n  assert_equal(377, n)\n\n  try\n    echo g:alist + 4\n  catch /E745:/\n    n = 388\n  endtry\n  assert_equal(388, n)\n\n  try\n    echo 4 + g:alist\n  catch /E745:/\n    n = 399\n  endtry\n  assert_equal(399, n)\n\n  try\n    echo g:alist.member\n  catch /E715:/\n    n = 400\n  endtry\n  assert_equal(400, n)\n\n  try\n    echo d.member\n  catch /E716:/\n    n = 411\n  endtry\n  assert_equal(411, n)\n\n  var counter = 0\n  for i in range(4)\n    try\n      eval [][0]\n    catch\n    endtry\n    counter += 1\n  endfor\n  assert_equal(4, counter)\n\n  # no requirement for spaces before |\n  try|echo 0|catch|endtry\n\n  # return in try with finally\n  def ReturnInTry(): number\n    var ret = 4\n    try\n      return ret\n    catch /this/\n      return -1\n    catch /that/\n      return -1\n    finally\n      # changing ret has no effect\n      ret = 7\n    endtry\n    return -2\n  enddef\n  assert_equal(4, ReturnInTry())\n\n  # return in catch with finally\n  def ReturnInCatch(): number\n    var ret = 5\n    try\n      throw 'getout'\n      return -1\n    catch /getout/\n      # ret is evaluated here\n      return ret\n    finally\n      # changing ret later has no effect\n      ret = -3\n    endtry\n    return -2\n  enddef\n  assert_equal(5, ReturnInCatch())\n\n  # return in finally after empty catch\n  def ReturnInFinally(): number\n    try\n    finally\n      return 6\n    endtry\n  enddef\n  assert_equal(6, ReturnInFinally())\n\n  var lines =<< trim END\n      vim9script\n      try\n        acos('0.5')\n          ->setline(1)\n      catch\n        g:caught = v:exception\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_match('E1219: Float or Number required for argument 1', g:caught)\n  unlet g:caught\n\n  # missing catch and/or finally\n  lines =<< trim END\n      vim9script\n      try\n        echo 'something'\n      endtry\n  END\n  v9.CheckScriptFailure(lines, 'E1032:')\n\n  # skipping try-finally-endtry when try-finally-endtry is used in another block\n  lines =<< trim END\n      if v:true\n        try\n        finally\n        endtry\n      else\n        try\n        finally\n        endtry\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_try_var_decl()\n  var lines =<< trim END\n      vim9script\n      try\n        var in_try = 1\n        assert_equal(1, get(s:, 'in_try', -1))\n        throw \"getout\"\n      catch\n        var in_catch = 2\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(2, get(s:, 'in_catch', -1))\n      finally\n        var in_finally = 3\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(-1, get(s:, 'in_catch', -1))\n        assert_equal(3, get(s:, 'in_finally', -1))\n      endtry\n      assert_equal(-1, get(s:, 'in_try', -1))\n      assert_equal(-1, get(s:, 'in_catch', -1))\n      assert_equal(-1, get(s:, 'in_finally', -1))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_try_ends_in_return()\n  var lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n        echo 'notreached'\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1095:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch /x/\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1027:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          echo 'foo'\n        catch\n          echo 'caught'\n        finally\n          return 'done'\n        endtry\n      enddef\n      assert_equal('done', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\nenddef\n\ndef Test_try_in_catch()\n  var lines =<< trim END\n      vim9script\n      var seq = []\n      def DoIt()\n        try\n          seq->add('throw 1')\n          eval [][0]\n          seq->add('notreached')\n        catch\n          seq->add('catch')\n          try\n            seq->add('throw 2')\n            eval [][0]\n            seq->add('notreached')\n          catch /nothing/\n            seq->add('notreached')\n          endtry\n          seq->add('done')\n        endtry\n      enddef\n      DoIt()\n      assert_equal(['throw 1', 'catch', 'throw 2', 'done'], seq)\n  END\nenddef\n\ndef Test_error_in_catch()\n  var lines =<< trim END\n      try\n        eval [][0]\n      catch /E684:/\n        eval [][0]\n      endtry\n  END\n  v9.CheckDefExecFailure(lines, 'E684:', 4)\nenddef\n\n\" :while at the very start of a function that :continue jumps to\ndef s:TryContinueFunc()\n while g:Count < 2\n   g:sequence ..= 't'\n    try\n      echoerr 'Test'\n    catch\n      g:Count += 1\n      g:sequence ..= 'c'\n      continue\n    endtry\n    g:sequence ..= 'e'\n    g:Count += 1\n  endwhile\nenddef\n\ndef Test_continue_in_try_in_while()\n  g:Count = 0\n  g:sequence = ''\n  TryContinueFunc()\n  assert_equal('tctc', g:sequence)\n  unlet g:Count\n  unlet g:sequence\nenddef\n\ndef Test_break_in_try_in_for()\n  var lines =<< trim END\n      vim9script\n      def Ls(): list<string>\n        var ls: list<string>\n        for s in ['abc', 'def']\n          for _ in [123, 456]\n            try\n              eval [][0]\n            catch\n              break\n            endtry\n          endfor\n          ls += [s]\n        endfor\n        return ls\n      enddef\n      assert_equal(['abc', 'def'], Ls())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nocatch_return_in_try()\n  # return in try block returns normally\n  def ReturnInTry(): string\n    try\n      return '\"some message\"'\n    catch\n    endtry\n    return 'not reached'\n  enddef\n  exe 'echoerr ' .. ReturnInTry()\nenddef\n\ndef Test_cnext_works_in_catch()\n  var lines =<< trim END\n      vim9script\n      au BufEnter * eval 1 + 2\n      writefile(['text'], 'Xcncfile1')\n      writefile(['text'], 'Xcncfile2')\n      var items = [\n          {lnum: 1, filename: 'Xcncfile1', valid: true},\n          {lnum: 1, filename: 'Xcncfile2', valid: true}\n        ]\n      setqflist([], ' ', {items: items})\n      cwindow\n\n      def CnextOrCfirst()\n        # if cnext fails, cfirst is used\n        try\n          cnext\n        catch\n          cfirst\n        endtry\n      enddef\n\n      CnextOrCfirst()\n      CnextOrCfirst()\n      writefile([getqflist({idx: 0}).idx], 'Xcncresult')\n      qall\n  END\n  writefile(lines, 'XCatchCnext', 'D')\n  g:RunVim([], [], '--clean -S XCatchCnext')\n  assert_equal(['1'], readfile('Xcncresult'))\n\n  delete('Xcncfile1')\n  delete('Xcncfile2')\n  delete('Xcncresult')\nenddef\n\ndef Test_throw_skipped()\n  if 0\n    throw dontgethere\n  endif\nenddef\n\ndef Test_nocatch_throw_silenced()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      throw 'error'\n    enddef\n    silent! Func()\n  END\n  writefile(lines, 'XthrowSilenced', 'D')\n  source XthrowSilenced\nenddef\n\ndef DeletedFunc(): list<any>\n  return ['delete me']\nenddef\ndefcompile\ndelfunc DeletedFunc\n\ndef s:ThrowFromDef()\n  throw \"getout\" # comment\nenddef\n\nfunc s:CatchInFunc()\n  try\n    call s:ThrowFromDef()\n  catch\n    let g:thrown_func = v:exception\n  endtry\nendfunc\n\ndef s:CatchInDef()\n  try\n    ThrowFromDef()\n  catch\n    g:thrown_def = v:exception\n  endtry\nenddef\n\ndef s:ReturnFinally(): string\n  try\n    return 'intry'\n  finally\n    g:in_finally = 'finally'\n  endtry\n  return 'end'\nenddef\n\ndef Test_try_catch_nested()\n  CatchInFunc()\n  assert_equal('getout', g:thrown_func)\n\n  CatchInDef()\n  assert_equal('getout', g:thrown_def)\n\n  assert_equal('intry', ReturnFinally())\n  assert_equal('finally', g:in_finally)\n\n  var l = []\n  try\n    l->add('1')\n    throw 'bad'\n    l->add('x')\n  catch /bad/\n    l->add('2')\n    try\n      l->add('3')\n      throw 'one'\n      l->add('x')\n    catch /one/\n      l->add('4')\n      try\n        l->add('5')\n        throw 'more'\n        l->add('x')\n      catch /more/\n        l->add('6')\n      endtry\n    endtry\n  endtry\n  assert_equal(['1', '2', '3', '4', '5', '6'], l)\n\n  l = []\n  try\n    try\n      l->add('1')\n      throw 'foo'\n      l->add('x')\n    catch\n      l->add('2')\n      throw 'bar'\n      l->add('x')\n    finally\n      l->add('3')\n    endtry\n    l->add('x')\n  catch /bar/\n    l->add('4')\n  endtry\n  assert_equal(['1', '2', '3', '4'], l)\nenddef\n\ndef s:TryOne(): number\n  try\n    return 0\n  catch\n  endtry\n  return 0\nenddef\n\ndef s:TryTwo(n: number): string\n  try\n    var x = {}\n  catch\n  endtry\n  return 'text'\nenddef\n\ndef Test_try_catch_twice()\n  assert_equal('text', TryOne()->TryTwo())\nenddef\n\ndef Test_try_catch_match()\n  var seq = 'a'\n  try\n    throw 'something'\n  catch /nothing/\n    seq ..= 'x'\n  catch /some/\n    seq ..= 'b'\n  catch /asdf/\n    seq ..= 'x'\n  catch ?a\\?sdf?\n    seq ..= 'y'\n  finally\n    seq ..= 'c'\n  endtry\n  assert_equal('abc', seq)\nenddef\n\ndef Test_try_catch_fails()\n  v9.CheckDefFailure(['catch'], 'E603:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch', 'catch'], 'E1033:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch /pat'], 'E1067:')\n  v9.CheckDefFailure(['finally'], 'E606:')\n  v9.CheckDefFailure(['try', 'echo 0', 'finally', 'echo 1', 'finally'], 'E607:')\n  v9.CheckDefFailure(['endtry'], 'E602:')\n  v9.CheckDefFailure(['while 1', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['for i in range(5)', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['if 1', 'endtry'], 'E171:')\n  v9.CheckDefFailure(['try', 'echo 1', 'endtry'], 'E1032:')\n\n  v9.CheckDefFailure(['throw'], 'E1143:')\n  v9.CheckDefFailure(['throw xxx'], 'E1001:')\nenddef\n\ndef Try_catch_skipped()\n  var l = []\n  try\n  finally\n  endtry\n\n  if 1\n  else\n    try\n    endtry\n  endif\nenddef\n\n\" The skipped try/endtry was updating the wrong instruction.\ndef Test_try_catch_skipped()\n  var instr = execute('disassemble Try_catch_skipped')\n  assert_match(\"NEWLIST size 0\\n\", instr)\nenddef\n\ndef Test_throw_line_number()\n  def Func()\n    eval 1 + 1\n    eval 2 + 2\n    throw 'exception'\n  enddef\n  try\n    Func()\n  catch /exception/\n    assert_match('line 3', v:throwpoint)\n  endtry\nenddef\n\n\ndef Test_throw_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        throw 'one'\n              .. 'two'\n      catch\n        assert_equal('onetwo', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    @r = ''\n    def Func()\n      throw @r\n    enddef\n    var result = ''\n    try\n      Func()\n    catch /E1129:/\n      result = 'caught'\n    endtry\n    assert_equal('caught', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_nested_function()\n  # an error in a nested :function aborts executing in the calling :def function\n  var lines =<< trim END\n      vim9script\n      def Func()\n        Error()\n        g:test_var = 1\n      enddef\n      func Error() abort\n        eval [][0]\n      endfunc\n      Func()\n  END\n  g:test_var = 0\n  v9.CheckScriptFailure(lines, 'E684:')\n  assert_equal(0, g:test_var)\nenddef\n\ndef Test_abort_after_error()\n  var lines =<< trim END\n      vim9script\n      while true\n        echo notfound\n      endwhile\n      g:gotthere = true\n  END\n  g:gotthere = false\n  v9.CheckScriptFailure(lines, 'E121:')\n  assert_false(g:gotthere)\n  unlet g:gotthere\nenddef\n\ndef Test_cexpr_vimscript()\n  # only checks line continuation\n  set errorformat=File\\ %f\\ line\\ %l\n  var lines =<< trim END\n      vim9script\n      cexpr 'File'\n                .. ' someFile' ..\n                   ' line 19'\n      assert_equal(19, getqflist()[0].lnum)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        au QuickfixCmdPre * echo g:doesnotexist\n        cexpr 'File otherFile line 99'\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:doesnotexist')\n  assert_equal('no', g:didContinue)\n  au! QuickfixCmdPre\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        cexpr g:aNumber\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:aNumber = 123\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E777: String or List expected')\n  assert_equal('no', g:didContinue)\n  unlet g:didContinue\n\n  set errorformat&\nenddef\n\ndef Test_statusline_syntax()\n  # legacy syntax is used for 'statusline'\n  var lines =<< trim END\n      vim9script\n      func g:Status()\n        return '%{\"x\" is# \"x\"}'\n      endfunc\n      set laststatus=2 statusline=%!Status()\n      redrawstatus\n      set laststatus statusline= \n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_vimscript()\n  # checks line continuation and comments\n  var lines =<< trim END\n      vim9script\n      var mylist = [\n            'one',\n            # comment\n            'two', # empty line follows\n\n            'three',\n            ]\n      assert_equal(['one', 'two', 'three'], mylist)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check all lines from heredoc are kept\n  lines =<< trim END\n      # comment 1\n      two\n      # comment 3\n\n      five\n      # comment 6\n  END\n  assert_equal(['# comment 1', 'two', '# comment 3', '', 'five', '# comment 6'], lines)\n\n  lines =<< trim END\n    [{\n      a: 0}]->string()->assert_equal(\"[{'a': 0}]\")\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nif has('channel')\n  let someJob = test_null_job()\n\n  def FuncWithError()\n    echomsg g:someJob\n  enddef\n\n  func Test_convert_emsg_to_exception()\n    try\n      call FuncWithError()\n    catch\n      call assert_match('Vim:E908:', v:exception)\n    endtry\n  endfunc\nendif\n\ndef Test_vim9script_mix()\n  var lines =<< trim END\n    if has(g:feature)\n      \" legacy script\n      let g:legacy = 1\n      finish\n    endif\n    vim9script\n    g:legacy = 0\n  END\n  g:feature = 'eval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:legacy)\n\n  g:feature = 'noteval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(0, g:legacy)\nenddef\n\ndef Test_vim9script_fails()\n  v9.CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')\n  v9.CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')\n\n  v9.CheckScriptFailure(['vim9script', 'var str: string', 'str = 1234'], 'E1012:')\n  v9.CheckScriptFailure(['vim9script', 'const str = \"asdf\"', 'str = \"xxx\"'], 'E46:')\n\n  assert_fails('vim9script', 'E1038:')\n  v9.CheckDefFailure(['vim9script'], 'E1038:')\n\n  # no error when skipping\n  if has('nothing')\n    vim9script\n  endif\nenddef\n\ndef Test_script_var_shadows_function()\n  var lines =<< trim END\n      vim9script\n      def Func(): number\n        return 123\n      enddef\n      var Func = 1\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 5)\nenddef\n\ndef Test_function_shadows_script_var()\n  var lines =<< trim END\n      vim9script\n      var Func = 1\n      def Func(): number\n        return 123\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 3)\nenddef\n\ndef Test_script_var_shadows_command()\n  var lines =<< trim END\n      var undo = 1\n      undo = 2\n      assert_equal(2, undo)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var undo = 1\n      undo\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\nenddef\n\ndef Test_vim9script_call_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var Time = 'localtime'\n      Time()\n  END\n  v9.CheckScriptFailure(lines, 'E1085:')\nenddef\n\ndef Test_vim9script_reload_delfunc()\n  var first_lines =<< trim END\n    vim9script\n    def FuncYes(): string\n      return 'yes'\n    enddef\n  END\n  var withno_lines =<< trim END\n    def FuncNo(): string\n      return 'no'\n    enddef\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_equal('no', FuncNo())\n    enddef\n  END\n  var nono_lines =<< trim END\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_fails('FuncNo()', 'E117:', '', 2, 'DoCheck')\n    enddef\n  END\n\n  # FuncNo() is defined\n  writefile(first_lines + withno_lines, 'Xreloaded.vim', 'D')\n  source Xreloaded.vim\n  g:DoCheck(true)\n\n  # FuncNo() is not redefined\n  writefile(first_lines + nono_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  # FuncNo() is back\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\nenddef\n\ndef Test_vim9script_reload_delvar()\n  # write the script with a script-local variable\n  var lines =<< trim END\n    vim9script\n    var name = 'string'\n  END\n  writefile(lines, 'XreloadVar.vim', 'D')\n  source XreloadVar.vim\n\n  # now write the script using the same variable locally - works\n  lines =<< trim END\n    vim9script\n    def Func()\n      var name = 'string'\n    enddef\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\nenddef\n\ndef Test_func_redefine_error()\n  var lines = [\n        'vim9script',\n        'def Func()',\n        '  eval [][0]',\n        'enddef',\n        'Func()',\n        ]\n  writefile(lines, 'Xtestscript.vim', 'D')\n\n  for count in range(3)\n    try\n      source Xtestscript.vim\n    catch /E684/\n      # function name should contain <SNR> every time\n      assert_match('E684: List index out of range', v:exception)\n      assert_match('function <SNR>\\d\\+_Func, line 1', v:throwpoint)\n    endtry\n  endfor\nenddef\n\ndef Test_func_redefine_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      echo 'one'\n    enddef\n    def Func()\n      echo 'two'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\n\n  lines =<< trim END\n    vim9script\n    def Foo(): string\n      return 'foo'\n    enddef\n    def Func()\n      var  Foo = {-> 'lambda'}\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\nenddef\n\ndef Test_lambda_split()\n  # this was using freed memory, because of the split expression\n  var lines =<< trim END\n      vim9script\n      try\n      0\n      0->(0\n        ->a.0(\n        ->u\n  END\n  v9.CheckScriptFailure(lines, 'E1050:')\nenddef\n\ndef Test_fixed_size_list()\n  # will be allocated as one piece of memory, check that changes work\n  var l = [1, 2, 3, 4]\n  l->remove(0)\n  l->add(5)\n  l->insert(99, 1)\n  assert_equal([2, 99, 3, 4, 5], l)\nenddef\n\ndef Test_no_insert_xit()\n  v9.CheckDefExecFailure(['a = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['c = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['i = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['t = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['x = 1'], 'E1100:')\n\n  v9.CheckScriptFailure(['vim9script', 'a = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'a'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'c = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'c'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'i = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'i'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'x = 1'], 'E1100:')\nenddef\n\ndef s:IfElse(what: number): string\n  var res = ''\n  if what == 1\n    res = \"one\"\n  elseif what == 2\n    res = \"two\"\n  else\n    res = \"three\"\n  endif\n  return res\nenddef\n\ndef Test_if_elseif_else()\n  assert_equal('one', IfElse(1))\n  assert_equal('two', IfElse(2))\n  assert_equal('three', IfElse(3))\nenddef\n\ndef Test_if_elseif_else_fails()\n  v9.CheckDefFailure(['elseif true'], 'E582:')\n  v9.CheckDefFailure(['else'], 'E581:')\n  v9.CheckDefFailure(['endif'], 'E580:')\n  v9.CheckDefFailure(['if g:abool', 'elseif xxx'], 'E1001:')\n  v9.CheckDefFailure(['if true', 'echo 1'], 'E171:')\n\n  var lines =<< trim END\n      var s = ''\n      if s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var s = ''\n      if s == ''\n      elseif s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var cond = true\n      if cond\n        echo 'true'\n      elseif\n        echo 'false'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1143:', 'E15:'], 4)\nenddef\n\ndef Test_if_else_func_using_var()\n  var lines =<< trim END\n      vim9script\n\n      const debug = true\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('in true', g:where)\n  unlet g:where\n\n  lines =<< trim END\n      vim9script\n\n      const debug = false\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: mode_chars')\nenddef\n\nlet g:bool_true = v:true\nlet g:bool_false = v:false\n\ndef Test_if_const_expr()\n  var res = false\n  if true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  g:glob = 2\n  if false\n    execute('g:glob = 3')\n  endif\n  assert_equal(2, g:glob)\n  if true\n    execute('g:glob = 3')\n  endif\n  assert_equal(3, g:glob)\n\n  res = false\n  if g:bool_true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? g:bool_true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? true : g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? false : true\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false ? false : true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if has('xyz') ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if g:bool_true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && g:bool_false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if g:bool_true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true || g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false || false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  # with constant \"false\" expression may be invalid so long as the syntax is OK\n  if false | eval 1 + 2 | endif\n  if false | eval burp + 234 | endif\n  if false | echo burp 234 'asd' | endif\n  if false\n    burp\n  endif\n\n  if 0\n    if 1\n      echo nothing\n    elseif 1\n      echo still nothing\n    endif\n  endif\n\n  # expression with line breaks skipped\n  if false\n      ('aaa'\n      .. 'bbb'\n      .. 'ccc'\n      )->setline(1)\n  endif\nenddef\n\ndef Test_if_const_expr_fails()\n  v9.CheckDefFailure(['if \"aaa\" == \"bbb'], 'E114:')\n  v9.CheckDefFailure([\"if 'aaa' == 'bbb\"], 'E115:')\n  v9.CheckDefFailure([\"if has('aaa'\"], 'E110:')\n  v9.CheckDefFailure([\"if has('aaa') ? true false\"], 'E109:')\nenddef\n\ndef s:RunNested(i: number): number\n  var x: number = 0\n  if i % 2\n    if 1\n      # comment\n    else\n      # comment\n    endif\n    x += 1\n  else\n    x += 1000\n  endif\n  return x\nenddef\n\ndef Test_nested_if()\n  assert_equal(1, RunNested(1))\n  assert_equal(1000, RunNested(2))\nenddef\n\ndef Test_execute_cmd()\n  # missing argument is ignored\n  execute\n  execute # comment\n\n  new\n  setline(1, 'default')\n  execute 'setline(1, \"execute-string\")'\n  assert_equal('execute-string', getline(1))\n\n  execute \"setline(1, 'execute-string')\"\n  assert_equal('execute-string', getline(1))\n\n  var cmd1 = 'setline(1,'\n  var cmd2 = '\"execute-var\")'\n  execute cmd1 cmd2 # comment\n  assert_equal('execute-var', getline(1))\n\n  execute cmd1 cmd2 '|setline(1, \"execute-var-string\")'\n  assert_equal('execute-var-string', getline(1))\n\n  var cmd_first = 'call '\n  var cmd_last = 'setline(1, \"execute-var-var\")'\n  execute cmd_first .. cmd_last\n  assert_equal('execute-var-var', getline(1))\n  bwipe!\n\n  var n = true\n  execute 'echomsg' (n ? '\"true\"' : '\"no\"')\n  assert_match('^true$', g:Screenline(&lines))\n\n  echomsg [1, 2, 3] {a: 1, b: 2}\n  assert_match('^\\[1, 2, 3\\] {''a'': 1, ''b'': 2}$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['execute xxx'], 'E1001:', 1)\n  v9.CheckDefExecFailure(['execute \"tabnext \" .. 8'], 'E475:', 1)\n  v9.CheckDefFailure(['execute \"cmd\"# comment'], 'E488:', 1)\n  if has('channel')\n    v9.CheckDefExecFailure(['execute test_null_channel()'], 'E908:', 1)\n  endif\nenddef\n\ndef Test_execute_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      execute 'g:someVar'\n                .. ' = ' ..\n                   '28'\n      assert_equal(28, g:someVar)\n      unlet g:someVar\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_execute_finish()\n  # the empty lines are relevant here\n  var lines =<< trim END\n      vim9script\n\n      var vname = \"g:hello\"\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_equal('world', g:hello)\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_report('should not be reached')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echo_cmd()\n  echo 'some' # comment\n  echon 'thing'\n  assert_match('^something$', g:Screenline(&lines))\n\n  echo \"some\" # comment\n  echon \"thing\"\n  assert_match('^something$', g:Screenline(&lines))\n\n  var str1 = 'some'\n  var str2 = 'more'\n  echo str1 str2\n  assert_match('^some more$', g:Screenline(&lines))\n\n  echo \"one\\ntwo\"\n  assert_match('^one$', g:Screenline(&lines - 1))\n  assert_match('^two$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echo \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd()\n  echomsg 'some' 'more' # comment\n  assert_match('^some more$', g:Screenline(&lines))\n  echo 'clear'\n  :1messages\n  assert_match('^some more$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echomsg \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      echomsg 'here'\n                .. ' is ' ..\n                   'a message'\n      assert_match('^here is a message$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoerr_cmd()\n  var local = 'local'\n  try\n    echoerr 'something' local 'wrong' # comment\n  catch\n    assert_match('something local wrong', v:exception)\n  endtry\nenddef\n\ndef Test_echoerr_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        echoerr 'this'\n                .. ' is ' ..\n                   'wrong'\n      catch\n        assert_match('this is wrong', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoconsole_cmd()\n  var local = 'local'\n  echoconsole 'something' local # comment\n  # output goes anywhere\nenddef\n\ndef Test_echowindow_cmd()\n  var local = 'local'\n  echowindow 'something' local # comment\n  # output goes in message window\n  popup_clear()\nenddef\n\ndef Test_for_outside_of_function()\n  var lines =<< trim END\n    vim9script\n    new\n    for var in range(0, 3)\n      append(line('$'), var)\n    endfor\n    assert_equal(['', '0', '1', '2', '3'], getline(1, '$'))\n    bwipe!\n\n    var result = ''\n    for i in [1, 2, 3]\n      var loop = ' loop ' .. i\n      result ..= loop\n    endfor\n    assert_equal(' loop 1 loop 2 loop 3', result)\n  END\n  writefile(lines, 'Xvim9for.vim', 'D')\n  source Xvim9for.vim\nenddef\n\ndef Test_for_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    if true\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      if true\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      if false\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n\n    def BuildDiagrams()\n      var diagrams: list<any>\n      if false\n        var max = 0\n        for v in diagrams\n          var l = 3\n          if max < l | max = l | endif\n          v->add(l)\n        endfor\n      endif\n    enddef\n    BuildDiagrams()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_redir()\n  var lines =<< trim END\n      def T()\n        if 0\n          redir =>l[0]\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_for_loop()\n  var lines =<< trim END\n      var result = ''\n      for cnt in range(7)\n        if cnt == 4\n          break\n        endif\n        if cnt == 2\n          continue\n        endif\n        result ..= cnt .. '_'\n      endfor\n      assert_equal('0_1_3_', result)\n\n      var concat = ''\n      for str in eval('[\"one\", \"two\"]')\n        concat ..= str\n      endfor\n      assert_equal('onetwo', concat)\n\n      var total = 0\n      for nr in\n          [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in\n        [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      # with type\n      total = 0\n      for n: number in [1, 2, 3]\n        total += n\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for b in 0z010203\n        total += b\n      endfor\n      assert_equal(6, total)\n\n      var chars = ''\n      for s: string in 'foobar'\n        chars ..= s\n      endfor\n      assert_equal('foobar', chars)\n\n      chars = ''\n      for x: string in {a: 'a', b: 'b'}->values()\n        chars ..= x\n      endfor\n      assert_equal('ab', chars)\n\n      # unpack with type\n      var res = ''\n      for [n: number, s: string] in [[1, 'a'], [2, 'b']]\n        res ..= n .. s\n      endfor\n      assert_equal('1a2b', res)\n\n      # unpack with one var\n      var reslist = []\n      for [x] in [['aaa'], ['bbb']]\n        reslist->add(x)\n      endfor\n      assert_equal(['aaa', 'bbb'], reslist)\n\n      # loop over string\n      res = ''\n      for c in 'a\u00e9c\u0300d'\n        res ..= c .. '-'\n      endfor\n      assert_equal('a-\u00e9-c\u0300-d-', res)\n\n      res = ''\n      for c in ''\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      res = ''\n      for c in test_null_string()\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      total = 0\n      for c in null_list\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      for c in null_blob\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      var foo: list<dict<any>> = [\n              {a: 'Cat'}\n            ]\n      for dd in foo\n        dd.counter = 12\n      endfor\n      assert_equal([{a: 'Cat', counter: 12}], foo)\n\n      reslist = []\n      for _ in range(3)\n        reslist->add('x')\n      endfor\n      assert_equal(['x', 'x', 'x'], reslist)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_list_of_lists()\n  # loop variable is final, not const\n  var lines =<< trim END\n      # Filter out all odd numbers in each sublist\n      var list: list<list<number>> = [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]\n      for i in list\n          filter(i, (_, n: number): bool => n % 2 == 0)\n      endfor\n\n      assert_equal([[], [2], [2], [2, 4]], list)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_with_closure()\n  # using the loop variable in a closure results in the last used value\n  var lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        flist[i] = () => i\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also works when the loop variable is used only once halfway the loops\n  lines =<< trim END\n      var Clo: func\n      for i in range(5)\n        if i == 3\n          Clo = () => i\n        endif\n      endfor\n      assert_equal(4, Clo())\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # using a local variable set to the loop variable in a closure results in the\n  # value at that moment\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => inloop\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also with an extra block level\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        {\n          var inloop = i\n          flist[i] = () => inloop\n        }\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # and declaration in higher block\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        {\n          flist[i] = () => inloop\n        }\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => {\n              return inloop\n            }\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # Also works for a nested loop\n  lines =<< trim END\n      var flist: list<func>\n      var n = 0\n      for i in range(3)\n        var ii = i\n        for a in ['a', 'b', 'c']\n          var aa = a\n          flist[n] = () => ii .. aa\n          ++n\n        endfor\n      endfor\n\n      n = 0\n      for i in range(3)\n        for a in ['a', 'b', 'c']\n          assert_equal(i .. a, flist[n]())\n          ++n\n        endfor\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # using two loop variables\n  lines =<< trim END\n      var lv_list: list<func>\n      var copy_list: list<func>\n      for [idx, c] in items('word')\n        var lidx = idx\n        var lc = c\n        lv_list[idx] = () => {\n              return idx .. c\n            }\n        copy_list[idx] = () => {\n              return lidx .. lc\n            }\n      endfor\n      for [i, c] in items('word')\n        assert_equal(3 .. 'd', lv_list[i]())\n        assert_equal(i .. c, copy_list[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_define_global_closure_in_loops()\n  var lines =<< trim END\n      vim9script\n\n      def Func()\n        for i in range(3)\n          var ii = i\n          for a in ['a', 'b', 'c']\n            var aa = a\n            if ii == 0 && aa == 'a'\n              def g:Global_0a(): string\n                return ii .. aa\n              enddef\n            endif\n            if ii == 1 && aa == 'b'\n              def g:Global_1b(): string\n                return ii .. aa\n              enddef\n            endif\n            if ii == 2 && aa == 'c'\n              def g:Global_2c(): string\n                return ii .. aa\n              enddef\n            endif\n          endfor\n        endfor\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(\"0a\", g:Global_0a())\n  assert_equal(\"1b\", g:Global_1b())\n  assert_equal(\"2c\", g:Global_2c())\n\n  delfunc g:Global_0a\n  delfunc g:Global_1b\n  delfunc g:Global_2c\nenddef\n\ndef Test_for_loop_fails()\n  v9.CheckDefAndScriptFailure(['for '], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x'], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x in'], ['E1097:', 'E15:'])\n  v9.CheckDefAndScriptFailure(['for # in range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['for i In range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['var x = 5', 'for x in range(5)', 'endfor'], ['E1017:', 'E1041:'])\n  v9.CheckScriptFailure(['vim9script', 'var x = 5', 'for x in range(5)', '# comment', 'endfor'], 'E1041:', 3)\n  v9.CheckScriptFailure(['def Func(arg: any)', 'for arg in range(5)', 'enddef', 'defcompile'], 'E1006:')\n  delfunc! g:Func\n  v9.CheckDefFailure(['for i in xxx'], 'E1001:')\n  v9.CheckDefFailure(['endfor'], 'E588:')\n  v9.CheckDefFailure(['for i in range(3)', 'echo 3'], 'E170:')\n\n  # wrong type detected at compile time\n  v9.CheckDefFailure(['for i in {a: 1}', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n\n  # wrong type detected at runtime\n  g:adict = {a: 1}\n  v9.CheckDefExecFailure(['for i in g:adict', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n  unlet g:adict\n\n  var lines =<< trim END\n      var d: list<dict<any>> = [{a: 0}]\n      for e in d\n        e = {a: 0, b: ''}\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1018:', 'E46:'], 3)\n\n  lines =<< trim END\n      for nr: number in ['foo']\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012: Type mismatch; expected number but got string', 1)\n\n  lines =<< trim END\n      for n : number in [1, 2]\n        echo n\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1059:', 1)\n\n  lines =<< trim END\n      var d: dict<number> = {a: 1, b: 2}\n      for [k: job, v: job] in d->items()\n        echo k v\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1163: Variable 1: type mismatch, expected job but got string', 'E1012: Type mismatch; expected job but got string'], 2)\n\n  lines =<< trim END\n      var i = 0\n      for i in [1, 2, 3]\n        echo i\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1017:', 'E1041:'])\n\n  lines =<< trim END\n      var l = [0]\n      for l[0] in [1, 2, 3]\n        echo l[0]\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var d = {x: 0}\n      for d.x in [1, 2, 3]\n        echo d.x\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{a: 1, b: 'x'}]\n      for item: dict<number> in l\n        echo item\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012: Type mismatch; expected dict<number> but got dict<any>')\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{n: 1}]\n      for item: dict<number> in l\n        var d = {s: ''}\n        d->extend(item)\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected dict<string> but got dict<number>')\n\n  lines =<< trim END\n      for a in range(3)\n        while a > 3\n          for b in range(2)\n            while b < 0\n              for c in range(5)\n                while c > 6\n                  while c < 0\n                    for d in range(1)\n                      for e in range(3)\n                        while e > 3\n                        endwhile\n                      endfor\n                    endfor\n                  endwhile\n                endwhile\n              endfor\n            endwhile\n          endfor\n        endwhile\n      endfor\n  END\n  v9.CheckDefSuccess(lines)\n\n  v9.CheckDefFailure(['for x in range(3)'] + lines + ['endfor'], 'E1306:')\nenddef\n\ndef Test_for_loop_script_var()\n  # cannot use s:var in a :def function\n  v9.CheckDefFailure(['for s:var in range(3)', 'echo 3'], 'E1254:')\n\n  # can use s:var in Vim9 script, with or without s:\n  var lines =<< trim END\n    vim9script\n    var total = 0\n    for s:var in [1, 2, 3]\n      total += s:var\n    endfor\n    assert_equal(6, total)\n\n    total = 0\n    for var in [1, 2, 3]\n      total += var\n    endfor\n    assert_equal(6, total)\n  END\nenddef\n\ndef Test_for_loop_unpack()\n  var lines =<< trim END\n      var result = []\n      for [v1, v2] in [[1, 2], [3, 4]]\n        result->add(v1)\n        result->add(v2)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      result = []\n      for [v1, v2; v3] in [[1, 2], [3, 4, 5, 6]]\n        result->add(v1)\n        result->add(v2)\n        result->add(v3)\n      endfor\n      assert_equal([1, 2, [], 3, 4, [5, 6]], result)\n\n      result = []\n      for [&ts, &sw] in [[1, 2], [3, 4]]\n        result->add(&ts)\n        result->add(&sw)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      var slist: list<string>\n      for [$LOOPVAR, @r, v:errmsg] in [['a', 'b', 'c'], ['d', 'e', 'f']]\n        slist->add($LOOPVAR)\n        slist->add(@r)\n        slist->add(v:errmsg)\n      endfor\n      assert_equal(['a', 'b', 'c', 'd', 'e', 'f'], slist)\n\n      slist = []\n      for [g:globalvar, b:bufvar, w:winvar, t:tabvar] in [['global', 'buf', 'win', 'tab'], ['1', '2', '3', '4']]\n        slist->add(g:globalvar)\n        slist->add(b:bufvar)\n        slist->add(w:winvar)\n        slist->add(t:tabvar)\n      endfor\n      assert_equal(['global', 'buf', 'win', 'tab', '1', '2', '3', '4'], slist)\n      unlet! g:globalvar b:bufvar w:winvar t:tabvar\n\n      var res = []\n      for [_, n, _] in [[1, 2, 3], [4, 5, 6]]\n        res->add(n)\n      endfor\n      assert_equal([2, 5], res)\n\n      var text: list<string> = [\"hello there\", \"goodbye now\"]\n      var splitted = ''\n      for [first; next] in mapnew(text, (i, v) => split(v))\n          splitted ..= string(first) .. string(next) .. '/'\n      endfor\n      assert_equal(\"'hello'['there']/'goodbye'['now']/\", splitted)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      for [v1, v2] in [[1, 2, 3], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E710:', 1)\n\n  lines =<< trim END\n      for [v1, v2] in [[1], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E711:', 1)\n\n  lines =<< trim END\n      for [v1, v1] in [[1, 2], [3, 4]]\n        echo v1\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E1017:', 1)\n\n  lines =<< trim END\n      for [a, b] in g:listlist\n        echo a\n      endfor\n  END\n  g:listlist = [1, 2, 3]\n  v9.CheckDefExecFailure(lines, 'E1140:', 1)\nenddef\n\ndef Test_for_loop_with_try_continue()\n  var lines =<< trim END\n      var looped = 0\n      var cleanup = 0\n      for i in range(3)\n        looped += 1\n        try\n          eval [][0]\n        catch\n          continue\n        finally\n          cleanup += 1\n        endtry\n      endfor\n      assert_equal(3, looped)\n      assert_equal(3, cleanup)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    var n = 0\n    if true\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      var n = 0\n      if true\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      var n = 0\n      if false\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_loop()\n  var result = ''\n  var cnt = 0\n  while cnt < 555\n    if cnt == 3\n      break\n    endif\n    cnt += 1\n    if cnt == 2\n      continue\n    endif\n    result ..= cnt .. '_'\n  endwhile\n  assert_equal('1_3_', result)\n\n  var s = ''\n  while s == 'x' # {comment}\n  endwhile\nenddef\n\ndef Test_while_loop_in_script()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n      var cnt = 0\n      while cnt < 3\n        var s = 'v' .. cnt\n        result ..= s\n        cnt += 1\n      endwhile\n      assert_equal('v0v1v2', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_while_loop_fails()\n  v9.CheckDefFailure(['while xxx'], 'E1001:')\n  v9.CheckDefFailure(['endwhile'], 'E588:')\n  v9.CheckDefFailure(['continue'], 'E586:')\n  v9.CheckDefFailure(['if true', 'continue'], 'E586:')\n  v9.CheckDefFailure(['break'], 'E587:')\n  v9.CheckDefFailure(['if true', 'break'], 'E587:')\n  v9.CheckDefFailure(['while 1', 'echo 3'], 'E170:')\n\n  var lines =<< trim END\n      var s = ''\n      while s = ''\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E488:')\nenddef\n\ndef Test_interrupt_loop()\n  var caught = false\n  var x = 0\n  try\n    while 1\n      x += 1\n      if x == 100\n        feedkeys(\"\\<C-C>\", 'Lt')\n      endif\n    endwhile\n  catch\n    caught = true\n    assert_equal(100, x)\n  endtry\n  assert_true(caught, 'should have caught an exception')\n  # consume the CTRL-C\n  getchar(0)\nenddef\n\ndef Test_automatic_line_continuation()\n  var mylist = [\n      'one',\n      'two',\n      'three',\n      ] # comment\n  assert_equal(['one', 'two', 'three'], mylist)\n\n  var mydict = {\n      ['one']: 1,\n      ['two']: 2,\n      ['three']:\n          3,\n      } # comment\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1,  # comment\n      two:     # comment\n           2,  # comment\n      three: 3 # comment\n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1, \n      two: \n           2, \n      three: 3 \n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n\n  assert_equal(\n        ['one', 'two', 'three'],\n        split('one two three')\n        )\nenddef\n\ndef Test_vim9_comment()\n  v9.CheckScriptSuccess([\n      'vim9script',\n      '# something',\n      '#something',\n      '#{{something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      '#{something',\n      ], 'E1170:')\n\n  split Xv9cfile\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #something',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #{something',\n      ])\n  close\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      ':# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      '# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      ':# something',\n      ], 'E488:')\n\n  { # block start\n  } # block end\n  v9.CheckDefFailure([\n      '{# comment',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      '{',\n      '}# comment',\n      ], 'E488:')\n\n  echo \"yes\" # comment\n  v9.CheckDefFailure([\n      'echo \"yes\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'echo \"yes\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo \"yes\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'echo \"yes\" # something',\n      ], 'E121:')\n\n  exe \"echo\" # comment\n  v9.CheckDefFailure([\n      'exe \"echo\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'exe \"echo\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe \"echo\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'exe \"echo\" # something',\n      ], 'E121:')\n\n  v9.CheckDefFailure([\n      'try# comment',\n      '  echo \"yes\"',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try# comment',\n      'echo \"yes\"',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw#comment',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw \"yes\"#comment',\n      'catch',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch /pat/# comment',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      'echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Search# comment',\n      ], 'E416:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi link This Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi link This That# comment',\n      ], 'E413:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi clear This # comment',\n      'hi clear # comment',\n      ])\n  # not tested, because it doesn't give an error but a warning:\n  # hi clear This# comment',\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi clear# comment',\n      ], 'E416:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match none # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match none# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'menutrans clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'menutrans clear# comment text',\n      ], 'E474:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax clear# comment text',\n      ], 'E28:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax list # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax list# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ oneline # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ oneline# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word word # comm[ent',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word word# comm[ent',\n      ], 'E789:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something# comment',\n      ], 'E475:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains= # comment',\n      ], 'E406:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync# comment',\n      ], 'E404:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync ccomment # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync ccomment# comment',\n      ], 'E404:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax cluster Some contains=Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax cluster Some contains=Word# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo echo # comment',\n      'command Echo # comment',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo# comment',\n      'Echo',\n      ], 'E1144:')\n  delcommand Echo\n\n  var curdir = getcwd()\n  v9.CheckScriptSuccess([\n      'command Echo cd \" comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo cd # comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo cd \" comment',\n      'Echo',\n      ], 'E344:')\n  delcommand Echo\n  chdir(curdir)\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo# comment',\n      ], 'E182:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo',\n      'command Echo# comment',\n      ], 'E182:')\n  delcommand Echo\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'function # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function \" comment',\n      ], 'E129:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess# comment',\n      ], 'E1048: Item not found in script: CheckScriptSuccess#')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func g:DeleteMeA()',\n      'endfunc',\n      'delfunction g:DeleteMeA # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func g:DeleteMeB()',\n      'endfunc',\n      'delfunction g:DeleteMeB# comment',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'call execute(\"ls\") # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'call execute(\"ls\")# comment',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'func Test() \" comment',\n      'endfunc',\n      'delfunc Test',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func Test() \" comment',\n      'endfunc',\n      ])\n\n  v9.CheckScriptSuccess([\n      'def Test() # comment',\n      'enddef',\n      ])\n  v9.CheckScriptFailure([\n      'func Test() # comment',\n      'endfunc',\n      ], 'E488:')\n\n  var lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      #\\ comment\n      \\ end='bar'\n      syn region Text start='foo'\n      #\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      \"\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptFailure(lines, 'E399:')\nenddef\n\ndef Test_vim9_comment_gui()\n  CheckCanRunGui\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui#comment'\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui -f#comment'\n      ], 'E194:')\nenddef\n\ndef Test_vim9_comment_not_compiled()\n  au TabEnter *.vim g:entered = 1\n  au TabEnter *.x g:entered = 2\n\n  edit test.vim\n  doautocmd TabEnter #comment\n  assert_equal(1, g:entered)\n\n  doautocmd TabEnter f.x\n  assert_equal(2, g:entered)\n\n  g:entered = 0\n  doautocmd TabEnter f.x #comment\n  assert_equal(2, g:entered)\n\n  assert_fails('doautocmd Syntax#comment', 'E216:')\n\n  au! TabEnter\n  unlet g:entered\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'g:var = 123',\n      'b:var = 456',\n      'w:var = 777',\n      't:var = 888',\n      'unlet g:var w:var # something',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'let var = 123',\n      ], 'E1126: Cannot use :let in Vim9 script')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var g:var = 123',\n      ], 'E1016: Cannot declare a global variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var b:var = 123',\n      ], 'E1016: Cannot declare a buffer variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var w:var = 123',\n      ], 'E1016: Cannot declare a window variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var t:var = 123',\n      ], 'E1016: Cannot declare a tab variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v:version = 123',\n      ], 'E1016: Cannot declare a v: variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var $VARIABLE = \"text\"',\n      ], 'E1016: Cannot declare an environment variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'g:var = 123',\n      'unlet g:var# comment1',\n      ], 'E108:')\n\n  v9.CheckScriptFailure([\n      'let g:var = 123',\n      'unlet g:var # something',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'if 1 # comment2',\n      '  echo \"yes\"',\n      'elseif 2 #comment',\n      '  echo \"no\"',\n      'endif',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 1# comment3',\n      '  echo \"yes\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 0 # comment4',\n      '  echo \"yes\"',\n      'elseif 2#comment',\n      '  echo \"no\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'var v = 1 # comment5',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v = 1# comment6',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'new',\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/ #comment',\n      'bwipe!',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'new',\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/#comment',\n      'bwipe!',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func! SomeFunc()',\n      ], 'E477:')\nenddef\n\ndef Test_finish()\n  var lines =<< trim END\n    vim9script\n    g:res = 'one'\n    if v:false | finish | endif\n    g:res = 'two'\n    finish\n    g:res = 'three'\n  END\n  writefile(lines, 'Xfinished', 'D')\n  source Xfinished\n  assert_equal('two', g:res)\n\n  unlet g:res\nenddef\n\ndef Test_forward_declaration()\n  var lines =<< trim END\n    vim9script\n    def GetValue(): string\n      return theVal\n    enddef\n    var theVal = 'something'\n    g:initVal = GetValue()\n    theVal = 'else'\n    g:laterVal = GetValue()\n  END\n  writefile(lines, 'Xforward', 'D')\n  source Xforward\n  assert_equal('something', g:initVal)\n  assert_equal('else', g:laterVal)\n\n  unlet g:initVal\n  unlet g:laterVal\nenddef\n\ndef Test_declare_script_var_in_func()\n  var lines =<< trim END\n      vim9script\n      func Declare()\n        let s:local = 123\n      endfunc\n      Declare()\n  END\n  v9.CheckScriptFailure(lines, 'E1269:')\nenddef\n        \ndef Test_lock_script_var()\n  var lines =<< trim END\n      vim9script\n      var local = 123\n      assert_equal(123, local)\n\n      var error: string\n      try\n        local = 'asdf'\n      catch\n        error = v:exception\n      endtry\n      assert_match('E1012: Type mismatch; expected number but got string', error)\n\n      lockvar local\n      try\n        local = 999\n      catch\n        error = v:exception\n      endtry\n      assert_match('E741: Value is locked: local', error)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n        \n\nfunc Test_vim9script_not_global()\n  \" check that items defined in Vim9 script are script-local, not global\n  let vim9lines =<< trim END\n    vim9script\n    var name = 'local'\n    func TheFunc()\n      echo 'local'\n    endfunc\n    def DefFunc()\n      echo 'local'\n    enddef\n  END\n  call writefile(vim9lines, 'Xvim9script.vim', 'D')\n  source Xvim9script.vim\n  try\n    echo g:var\n    assert_report('did not fail')\n  catch /E121:/\n    \" caught\n  endtry\n  try\n    call TheFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n  try\n    call DefFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\nendfunc\n\ndef Test_vim9_copen()\n  # this was giving an error for setting w:quickfix_title\n  copen\n  quit\nenddef\n\ndef Test_script_var_in_autocmd()\n  # using a script variable from an autocommand, defined in a :def function in a\n  # legacy Vim script, cannot check the variable type.\n  var lines =<< trim END\n    let s:counter = 1\n    def s:Func()\n      au! CursorHold\n      au CursorHold * s:counter += 1\n    enddef\n    call s:Func()\n    doau CursorHold\n    call assert_equal(2, s:counter)\n    au! CursorHold\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_autoload_script()\n  var save_rtp = &rtp\n  var dir = getcwd() .. '/Xruntime'\n  &rtp = dir\n  mkdir(dir .. '/autoload', 'pR')\n\n  var lines =<< trim END\n      vim9script noclear\n      export def Autoloaded()\n      enddef\n      def Broken()\n        var x: any = ''\n        eval x != 0\n      enddef\n      Broken()\n  END\n  writefile(lines, dir .. '/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      def CallAutoloaded()\n        script#Autoloaded()\n      enddef\n\n      function Legacy()\n        try\n          call s:CallAutoloaded()\n        catch\n          call assert_match('E1030: Using a String as a Number', v:exception)\n        endtry\n      endfunction\n\n      Legacy()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  &rtp = save_rtp\nenddef\n\ndef Test_error_in_autoload_script_foldexpr()\n  var save_rtp = &rtp\n  mkdir('Xvim/autoload', 'pR')\n  &runtimepath = 'Xvim'\n\n  var lines =<< trim END\n      vim9script\n      eval [][0]\n      echomsg 'no error'\n  END\n  lines->writefile('Xvim/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      &foldmethod = 'expr'\n      &foldexpr = 'script.Func()'\n      redraw\n  END\n  v9.CheckScriptFailure(lines, 'E684: List index out of range: 0')\nenddef\n\ndef Test_invalid_sid()\n  assert_fails('func <SNR>1234_func', 'E123:')\n\n  if g:RunVim([], ['wq! Xdidit'], '+\"func <SNR>1_func\"')\n    assert_equal([], readfile('Xdidit'))\n  endif\n  delete('Xdidit')\nenddef\n\ndef Test_restoring_cpo()\n  writefile(['vim9script', 'set nocp'], 'Xsourced', 'D')\n  writefile(['call writefile([\"done\"], \"Xdone\")', 'quit!'], 'Xclose', 'D')\n  if g:RunVim([], [], '-u NONE +\"set cpo+=a\" -S Xsourced -S Xclose')\n    assert_equal(['done'], readfile('Xdone'))\n  endif\n  delete('Xdone')\n\n  writefile(['vim9script', 'g:cpoval = &cpo'], 'XanotherScript', 'D')\n  set cpo=aABceFsMny>\n  edit XanotherScript\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFs', g:cpoval)\n  :1del\n  setline(1, 'let g:cpoval = &cpo')\n  w\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFsMny>', g:cpoval)\n\n  set cpo&vim\n  unlet g:cpoval\n\n  if has('unix')\n    # 'cpo' is not restored in main vimrc\n    var save_HOME = $HOME\n    $HOME = getcwd() .. '/Xhome'\n    mkdir('Xhome', 'R')\n    var lines =<< trim END\n        vim9script\n        writefile(['before: ' .. &cpo], 'Xrporesult')\n        set cpo+=M\n        writefile(['after: ' .. &cpo], 'Xrporesult', 'a')\n    END\n    writefile(lines, 'Xhome/.vimrc')\n\n    lines =<< trim END\n        call writefile(['later: ' .. &cpo], 'Xrporesult', 'a')\n    END\n    writefile(lines, 'Xlegacy', 'D')\n\n    lines =<< trim END\n        vim9script\n        call writefile(['vim9: ' .. &cpo], 'Xrporesult', 'a')\n        qa\n    END\n    writefile(lines, 'Xvim9', 'D')\n\n    var cmd = g:GetVimCommand() .. \" -S Xlegacy -S Xvim9\"\n    cmd = substitute(cmd, '-u NONE', '', '')\n    exe \"silent !\" .. cmd\n\n    assert_equal([\n        'before: aABceFs',\n        'after: aABceFsM',\n        'later: aABceFsM',\n        'vim9: aABceFs'], readfile('Xrporesult'))\n\n    $HOME = save_HOME\n    delete('Xrporesult')\n  endif\nenddef\n\n\" Use :function so we can use Check commands\nfunc Test_no_redraw_when_restoring_cpo()\n  CheckScreendump\n  CheckFeature timers\n  call Run_test_no_redraw_when_restoring_cpo()\nendfunc\n\ndef Run_test_no_redraw_when_restoring_cpo()\n  var lines =<< trim END\n    vim9script\n    export def Func()\n    enddef\n  END\n  mkdir('Xnordir/autoload', 'pR')\n  writefile(lines, 'Xnordir/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      set cpo+=M\n      exe 'set rtp^=' .. getcwd() .. '/Xnordir'\n      au CmdlineEnter : ++once timer_start(0, (_) => script#Func())\n      setline(1, 'some text')\n  END\n  writefile(lines, 'XTest_redraw_cpo', 'D')\n  var buf = g:RunVimInTerminal('-S XTest_redraw_cpo', {'rows': 6})\n  term_sendkeys(buf, \"V:\")\n  g:VerifyScreenDump(buf, 'Test_vim9_no_redraw', {})\n\n  # clean up\n  term_sendkeys(buf, \"\\<Esc>u\")\n  g:StopVimInTerminal(buf)\nenddef\n\nfunc Test_reject_declaration()\n  CheckScreendump\n  call Run_test_reject_declaration()\nendfunc\n\ndef Run_test_reject_declaration()\n  var buf = g:RunVimInTerminal('', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd var x: number\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_1', {})\n  term_sendkeys(buf, \":\\<CR>\")\n  term_sendkeys(buf, \":vim9cmd g:foo = 123 | echo g:foo\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_2', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_minimal_command_name_length()\n  var names = [\n       'cons',\n       'brea',\n       'cat',\n       'catc',\n       'con',\n       'cont',\n       'conti',\n       'contin',\n       'continu',\n       'el',\n       'els',\n       'elsei',\n       'endfo',\n       'en',\n       'end',\n       'endi',\n       'endw',\n       'endt',\n       'endtr',\n       'exp',\n       'expo',\n       'expor',\n       'fina',\n       'finall',\n       'fini',\n       'finis',\n       'imp',\n       'impo',\n       'impor',\n       'retu',\n       'retur',\n       'th',\n       'thr',\n       'thro',\n       'wh',\n       'whi',\n       'whil',\n      ]\n  for name in names\n    v9.CheckDefAndScriptFailure([name .. ' '], 'E1065:')\n  endfor\n\n  var lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endd\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n  lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endde\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\nenddef\n\ndef Test_unset_any_variable()\n  var lines =<< trim END\n    var name: any\n    assert_equal(0, name)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_define_func_at_command_line()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_define_func_at_command_line()\nendfunc\n\ndef Run_Test_define_func_at_command_line()\n  # run in a separate Vim instance to avoid the script context\n  var lines =<< trim END\n    func CheckAndQuit()\n      call assert_fails('call Afunc()', 'E117: Unknown function: Bfunc')\n      call writefile(['errors: ' .. string(v:errors)], 'Xdidcmd')\n    endfunc\n  END\n  writefile([''], 'Xdidcmd', 'D')\n  writefile(lines, 'XcallFunc', 'D')\n  var buf = g:RunVimInTerminal('-S XcallFunc', {rows: 6})\n  # define Afunc() on the command line\n  term_sendkeys(buf, \":def Afunc()\\<CR>Bfunc()\\<CR>enddef\\<CR>\")\n  term_sendkeys(buf, \":call CheckAndQuit()\\<CR>\")\n  g:WaitForAssert(() => assert_equal(['errors: []'], readfile('Xdidcmd')))\n\n  call g:StopVimInTerminal(buf)\nenddef\n\ndef Test_script_var_scope()\n  var lines =<< trim END\n      vim9script\n      if true\n        if true\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      if true\n        if false\n          var one = 'one'\n          echo one\n        else\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 10)\n\n  lines =<< trim END\n      vim9script\n      while true\n        var one = 'one'\n        echo one\n        break\n      endwhile\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      for i in range(1)\n        var one = 'one'\n        echo one\n      endfor\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        assert_equal('one', one)\n      }\n      assert_false(exists('one'))\n      assert_false(exists('s:one'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        echo one\n      }\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\nenddef\n\ndef Test_catch_exception_in_callback()\n  var lines =<< trim END\n    vim9script\n    def Callback(...l: list<any>)\n      try\n        var x: string\n        var y: string\n        # this error should be caught with CHECKLEN\n        var sl = ['']\n        [x, y] = sl\n      catch\n        g:caught = 'yes'\n      endtry\n    enddef\n    popup_menu('popup', {callback: Callback})\n    feedkeys(\"\\r\", 'xt')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  unlet g:caught\nenddef\n\ndef Test_no_unknown_error_after_error()\n  if !has('unix') || !has('job')\n    throw 'Skipped: not unix of missing +job feature'\n  endif\n  # FIXME: this check should not be needed\n  if has('win32')\n    throw 'Skipped: does not work on MS-Windows'\n  endif\n  var lines =<< trim END\n      vim9script\n      var source: list<number>\n      def Out_cb(...l: list<any>)\n          eval [][0]\n      enddef\n      def Exit_cb(...l: list<any>)\n          sleep 1m\n          g:did_call_exit_cb = true\n          source += l\n      enddef\n      var myjob = job_start('echo burp', {out_cb: Out_cb, exit_cb: Exit_cb, mode: 'raw'})\n      while job_status(myjob) == 'run'\n        sleep 10m\n      endwhile\n      # wait for Exit_cb() to be called\n      for x in range(100)\n        if exists('g:did_call_exit_cb')\n          unlet g:did_call_exit_cb\n          break\n        endif\n        sleep 10m\n      endfor\n  END\n  writefile(lines, 'Xdef', 'D')\n  assert_fails('so Xdef', ['E684:', 'E1012:'])\nenddef\n\ndef InvokeNormal()\n  exe \"norm! :m+1\\r\"\nenddef\n\ndef Test_invoke_normal_in_visual_mode()\n  xnoremap <F3> <Cmd>call <SID>InvokeNormal()<CR>\n  new\n  setline(1, ['aaa', 'bbb'])\n  feedkeys(\"V\\<F3>\", 'xt')\n  assert_equal(['bbb', 'aaa'], getline(1, 2))\n  xunmap <F3>\nenddef\n\ndef Test_white_space_after_command()\n  var lines =<< trim END\n    exit_cb: Func})\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\n\n  lines =<< trim END\n    e#\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\nenddef\n\ndef Test_script_var_gone_when_sourced_twice()\n  var lines =<< trim END\n      vim9script\n      if exists('g:guard')\n        finish\n      endif\n      g:guard = 1\n      var name = 'thename'\n      def g:GetName(): string\n        return name\n      enddef\n      def g:SetName(arg: string)\n        name = arg\n      enddef\n  END\n  writefile(lines, 'XscriptTwice.vim', 'D')\n  so XscriptTwice.vim\n  assert_equal('thename', g:GetName())\n  g:SetName('newname')\n  assert_equal('newname', g:GetName())\n  so XscriptTwice.vim\n  assert_fails('call g:GetName()', 'E1149:')\n  assert_fails('call g:SetName(\"x\")', 'E1149:')\n\n  delfunc g:GetName\n  delfunc g:SetName\n  unlet g:guard\nenddef\n\ndef Test_unsupported_commands()\n  var lines =<< trim END\n      ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :1ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n      :1k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:')\n\n  lines =<< trim END\n    t\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    x\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    xit\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    Print\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: Print', 'E492: Not an editor command: Print'])\n\n  lines =<< trim END\n    mode 4\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: mode 4', 'E492: Not an editor command: mode 4'])\nenddef\n\ndef Test_mapping_line_number()\n  var lines =<< trim END\n      vim9script\n      def g:FuncA()\n          # Some comment\n          FuncB(0)\n      enddef\n          # Some comment\n      def FuncB(\n          # Some comment\n          n: number\n      )\n          exe 'nno '\n              # Some comment\n              .. '<F3> a'\n              .. 'b'\n              .. 'c'\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n  var res = execute('verbose nmap <F3>')\n  assert_match('No mapping found', res)\n\n  g:FuncA()\n  res = execute('verbose nmap <F3>')\n  assert_match(' <F3> .* abc.*Last set from .*XScriptSuccess\\d\\+ line 11', res)\n\n  nunmap <F3>\n  delfunc g:FuncA\nenddef\n\ndef Test_option_set()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set foldlevel  =11\n      call assert_equal(11, &foldlevel)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set foldlevel\n  set foldlevel=12\n  assert_equal(12, &foldlevel)\n  set foldlevel+=2\n  assert_equal(14, &foldlevel)\n  set foldlevel-=3\n  assert_equal(11, &foldlevel)\n\n  lines =<< trim END\n      set foldlevel =1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: =1')\n\n  lines =<< trim END\n      set foldlevel +=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: +=1')\n\n  lines =<< trim END\n      set foldlevel ^=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: ^=1')\n\n  lines =<< trim END\n      set foldlevel -=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: -=1')\n\n  set foldlevel&\nenddef\n\ndef Test_option_modifier()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set hlsearch &  hlsearch  !\n      call assert_equal(1, &hlsearch)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set hlsearch\n  set hlsearch!\n  assert_equal(false, &hlsearch)\n\n  set hlsearch\n  set hlsearch&\n  assert_equal(false, &hlsearch)\n\n  lines =<< trim END\n      set hlsearch &\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: &')\n\n  lines =<< trim END\n      set hlsearch   !\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: !')\n\n  set hlsearch&\nenddef\n\n\" This must be called last, it may cause following :def functions to fail\ndef Test_xxx_echoerr_line_number()\n  var lines =<< trim END\n      echoerr 'some'\n         .. ' error'\n         .. ' continued'\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'some error continued', 1)\nenddef\n\nfunc Test_debug_with_lambda()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_with_lambda()\nendfunc\n\ndef Run_Test_debug_with_lambda()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var n = 0\n        echo [0]->filter((_, v) => v == n)\n      enddef\n      breakadd func Func\n      Func()\n  END\n  writefile(lines, 'XdebugFunc', 'D')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:WaitForAssert(() => assert_match('\\[0\\]', term_getline(buf, 5)))\n\n  g:StopVimInTerminal(buf)\nenddef\n\nfunc Test_debug_running_out_of_lines()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_running_out_of_lines()\nendfunc\n\ndef Run_Test_debug_running_out_of_lines()\n  var lines =<< trim END\n      vim9script\n      def Crash()\n          #\n          #\n          #\n          #\n          #\n          #\n          #\n          if true\n              #\n          endif\n      enddef\n      breakadd func Crash\n      Crash()\n  END\n  writefile(lines, 'XdebugFunc', 'D')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"next\\<CR>\")\n  g:TermWait(buf)\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:TermWait(buf)\n\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_ambigous_command_error()\n  var lines =<< trim END\n      vim9script\n      command CmdA echomsg 'CmdA'\n      command CmdB echomsg 'CmdB'\n      Cmd\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 4)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        Cmd\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 1)\n\n  lines =<< trim END\n      vim9script\n      nnoremap <F3> <ScriptCmd>Cmd<CR>\n      feedkeys(\"\\<F3>\", 'xt')\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 3)\n\n  delcommand CmdA\n  delcommand CmdB\n  nunmap <F3>\nenddef\n\n\" Execute this near the end, profiling doesn't stop until Vim exits.\n\" This only tests that it works, not the profiling output.\ndef Test_profile_with_lambda()\n  CheckFeature profile\n\n  var lines =<< trim END\n      vim9script\n\n      def ProfiledWithLambda()\n        var n = 3\n        echo [[1, 2], [3, 4]]->filter((_, l) => l[0] == n)\n      enddef\n\n      def ProfiledNested()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def g:ProfiledNestedProfiled()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def Profile()\n        ProfiledWithLambda()\n        ProfiledNested()\n\n        # Also profile the nested function.  Use a different function, although\n        # the contents is the same, to make sure it was not already compiled.\n        profile func *\n        g:ProfiledNestedProfiled()\n\n        profdel func *\n        profile pause\n      enddef\n\n      var result = 'done'\n      try\n        # mark functions for profiling now to avoid E1271\n        profile start Xprofile.log\n        profile func ProfiledWithLambda\n        profile func ProfiledNested\n\n        Profile()\n      catch\n        result = 'failed: ' .. v:exception\n      finally\n        writefile([result], 'Xdidprofile')\n      endtry\n  END\n  writefile(lines, 'Xprofile.vim', 'D')\n  call system(g:GetVimCommand()\n        .. ' --clean'\n        .. ' -c \"so Xprofile.vim\"'\n        .. ' -c \"qall!\"')\n  call assert_equal(0, v:shell_error)\n\n  assert_equal(['done'], readfile('Xdidprofile'))\n  assert_true(filereadable('Xprofile.log'))\n  delete('Xdidprofile')\n  delete('Xprofile.log')\nenddef\n\nfunc Test_misplaced_type()\n  CheckRunVimInTerminal\n  call Run_Test_misplaced_type()\nendfunc\n\ndef Run_Test_misplaced_type()\n  writefile(['let g:somevar = \"asdf\"'], 'XTest_misplaced_type', 'D')\n  var buf = g:RunVimInTerminal('-S XTest_misplaced_type', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd echo islocked('somevar: string')\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_misplaced_type', {})\n\n  g:StopVimInTerminal(buf)\nenddef\n\n\" Ensure echo doesn't crash when stringifying empty variables.\ndef Test_echo_uninit_variables()\n  var res: string\n\n  var var_bool: bool\n  var var_num: number\n  var var_float: float\n  var Var_func: func\n  var var_string: string\n  var var_blob: blob\n  var var_list: list<any>\n  var var_dict: dict<any>\n\n  redir => res\n  echo var_bool\n  echo var_num\n  echo var_float\n  echo Var_func\n  echo var_string\n  echo var_blob\n  echo var_list\n  echo var_dict\n  redir END\n\n  assert_equal(['false', '0', '0.0', 'function()', '', '0z', '[]', '{}'], res->split('\\n'))\n\n  if has('job')\n    var var_job: job\n    var var_channel: channel\n\n    redir => res\n    echo var_job\n    echo var_channel\n    redir END\n\n    assert_equal(['no process', 'channel fail'], res->split('\\n'))\n  endif\nenddef\n\n\" Keep this last, it messes up highlighting.\ndef Test_substitute_cmd()\n  new\n  setline(1, 'something')\n  :substitute(some(other(\n  assert_equal('otherthing', getline(1))\n  bwipe!\n\n  # also when the context is Vim9 script\n  var lines =<< trim END\n    vim9script\n    new\n    setline(1, 'something')\n    :substitute(some(other(\n    assert_equal('otherthing', getline(1))\n    bwipe!\n  END\n  writefile(lines, 'Xvim9lines', 'D')\n  source Xvim9lines\nenddef\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9cmds.c: Dealing with commands of a compiled function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Get the index of the current instruction.\n * This compensates for a preceding ISN_CMDMOD and ISN_PROF_START.\n */\n    static int\ncurrent_instr_idx(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tidx = instr->ga_len;\n\n    while (idx > 0)\n    {\n\tif (cctx->ctx_has_cmdmod && ((isn_T *)instr->ga_data)[idx - 1]\n\t\t\t\t\t\t       .isn_type == ISN_CMDMOD)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#ifdef FEAT_PROFILE\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_PROF_START)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#endif\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_DEBUG)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n\tbreak;\n    }\n    return idx;\n}\n/*\n * Remove local variables above \"new_top\".\n * Do this by clearing the name.  If \"keep\" is TRUE do not reset the length, a\n * closure may still need location of the variable.\n */\n    static void\nunwind_locals(cctx_T *cctx, int new_top, int keep)\n{\n    if (cctx->ctx_locals.ga_len > new_top)\n\tfor (int idx = new_top; idx < cctx->ctx_locals.ga_len; ++idx)\n\t{\n\t    lvar_T *lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\t    VIM_CLEAR(lvar->lv_name);\n\t}\n    if (!keep)\n\tcctx->ctx_locals.ga_len = new_top;\n}\n\n/*\n * Free all local variables.\n */\n    void\nfree_locals(cctx_T *cctx)\n{\n    unwind_locals(cctx, 0, FALSE);\n    ga_clear(&cctx->ctx_locals);\n}\n\n\n/*\n * Check if \"name\" can be \"unlet\".\n */\n    int\ncheck_vim9_unlet(char_u *name)\n{\n    if (*name == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), \"unlet\");\n\treturn FAIL;\n    }\n\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\t// \"unlet s:var\" is allowed in legacy script.\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_unlet(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep UNUSED,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    char_u\t*p = lvp->ll_name;\n    int\t\tcc = *name_end;\n    int\t\tret = OK;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    *name_end = NUL;\n    if (*p == '$')\n    {\n\t// :unlet $ENV_VAR\n\tret = generate_UNLET(cctx, ISN_UNLETENV, p + 1, eap->forceit);\n    }\n    else if (vim_strchr(p, '.') != NULL || vim_strchr(p, '[') != NULL)\n    {\n\tlhs_T\t    lhs;\n\n\t// This is similar to assigning: lookup the list/dict, compile the\n\t// idx/key.  Then instead of storing the value unlet the item.\n\t// unlet {list}[idx]\n\t// unlet {dict}[key]  dict.key\n\t//\n\t// Figure out the LHS type and other properties.\n\t//\n\tret = compile_lhs(p, &lhs, CMD_unlet, FALSE, FALSE, 0, cctx);\n\n\t// Use the info in \"lhs\" to unlet the item at the index in the\n\t// list or dict.\n\tif (ret == OK)\n\t{\n\t    if (!lhs.lhs_has_index)\n\t    {\n\t\tsemsg(_(e_cannot_unlet_imported_item_str), p);\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = compile_assign_unlet(p, &lhs, FALSE, &t_void, cctx);\n\t}\n\n\tvim_free(lhs.lhs_name);\n    }\n    else if (check_vim9_unlet(p) == FAIL)\n    {\n\tret = FAIL;\n    }\n    else\n    {\n\t// Normal name.  Only supports g:, w:, t: and b: namespaces.\n\tret = generate_UNLET(cctx, ISN_UNLET, p, eap->forceit);\n    }\n\n    *name_end = cc;\n    return ret;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\n\t    // For \"d.member\" put the local variable on the stack, it will be\n\t    // passed to ex_lockvar() indirectly.\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}\n\n/*\n * compile \"unlet var\", \"lock var\" and \"unlock var\"\n * \"arg\" points to \"var\".\n */\n    char_u *\ncompile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    int\t    deep = 0;\n    char_u  *p = arg;\n\n    if (eap->cmdidx != CMD_unlet)\n    {\n\tif (eap->forceit)\n\t    deep = -1;\n\telse if (vim_isdigit(*p))\n\t{\n\t    deep = getdigits(&p);\n\t    p = skipwhite(p);\n\t}\n\telse\n\t    deep = 2;\n    }\n\n    ex_unletlock(eap, p, deep, GLV_NO_AUTOLOAD | GLV_COMPILING,\n\t    eap->cmdidx == CMD_unlet ? compile_unlet : compile_lock_unlock,\n\t    cctx);\n    return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n}\n\n/*\n * Generate a jump to the \":endif\"/\":endfor\"/\":endwhile\"/\":finally\"/\":endtry\".\n * \"funcref_idx\" is used for JUMP_WHILE_FALSE\n */\n    static int\ncompile_jump_to_end(\n\tendlabel_T  **el,\n\tjumpwhen_T  when,\n\tint\t    funcref_idx,\n\tcctx_T\t    *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);\n\n    if (endlabel == NULL)\n\treturn FAIL;\n    endlabel->el_next = *el;\n    *el = endlabel;\n    endlabel->el_end_label = instr->ga_len;\n\n    if (when == JUMP_WHILE_FALSE)\n\tgenerate_WHILE(cctx, funcref_idx);\n    else\n\tgenerate_JUMP(cctx, when, 0);\n    return OK;\n}\n\n    static void\ncompile_fill_jump_to_end(endlabel_T **el, int jump_where, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\tisn_T\t    *isn;\n\n\tisn = ((isn_T *)instr->ga_data) + cur->el_end_label;\n\tisn->isn_arg.jump.jump_where = jump_where;\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n    static void\ncompile_free_jump_to_end(endlabel_T **el)\n{\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n/*\n * Create a new scope and set up the generic items.\n */\n    static scope_T *\nnew_scope(cctx_T *cctx, scopetype_T type)\n{\n    scope_T *scope = ALLOC_CLEAR_ONE(scope_T);\n\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_outer = cctx->ctx_scope;\n    cctx->ctx_scope = scope;\n    scope->se_type = type;\n    scope->se_local_count = cctx->ctx_locals.ga_len;\n    if (scope->se_outer != NULL)\n\tscope->se_loop_depth = scope->se_outer->se_loop_depth;\n    return scope;\n}\n\n/*\n * Free the current scope and go back to the outer scope.\n */\n    void\ndrop_scope(cctx_T *cctx)\n{\n    scope_T *scope = cctx->ctx_scope;\n\n    if (scope == NULL)\n    {\n\tiemsg(\"calling drop_scope() without a scope\");\n\treturn;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    switch (scope->se_type)\n    {\n\tcase IF_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_if.is_end_label); break;\n\tcase FOR_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_for.fs_end_label); break;\n\tcase WHILE_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_while.ws_end_label); break;\n\tcase TRY_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_try.ts_end_label); break;\n\tcase NO_SCOPE:\n\tcase BLOCK_SCOPE:\n\t    break;\n    }\n    vim_free(scope);\n}\n\n    static int\nmisplaced_cmdmod(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (cctx->ctx_has_cmdmod\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type\n\t\t\t\t\t\t\t\t == ISN_CMDMOD)\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * compile \"if expr\"\n *\n * \"if expr\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE end\n *\t... body ...\n * end:\n *\n * \"if expr | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n *\n * \"if expr1 | elseif expr2 | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE elseif\n *\t... body ...\n *\tJUMP_ALWAYS end\n * elseif:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n */\n    char_u *\ncompile_if(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count = instr->ga_len;\n    scope_T\t*scope;\n    skip_T\tskip_save = cctx->ctx_skip;\n    ppconst_T\tppconst;\n\n    CLEAR_FIELD(ppconst);\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression results in a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tclear_ppconst(&ppconst);\n\tif (error)\n\t    return NULL;\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n    }\n\n    // CMDMOD_REV must come before the jump\n    generate_undo_cmdmods(cctx);\n\n    scope = new_scope(cctx, IF_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_skip_save = skip_save;\n    // \"is_had_return\" will be reset if any block does not end in :return\n    scope->se_u.se_if.is_had_return = TRUE;\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n    else\n\tscope->se_u.se_if.is_if_label = -1;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t\t      && skip_save != SKIP_YES)\n    {\n\t// generated a profile start, need to generate a profile end, since it\n\t// won't be done after returning\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_END);\n\tcctx->ctx_skip = SKIP_YES;\n    }\n#endif\n\n    return p;\n}\n\n    char_u *\ncompile_elseif(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n    ppconst_T\tppconst;\n    skip_T\tsave_skip = cctx->ctx_skip;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_elseif_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n\n    if (cctx->ctx_skip == SKIP_NOT)\n    {\n\t// previous block was executed, this one and following will not\n\tcctx->ctx_skip = SKIP_YES;\n\tscope->se_u.se_if.is_seen_skip_not = TRUE;\n    }\n    if (scope->se_u.se_if.is_seen_skip_not)\n    {\n\t// A previous block was executed, skip over expression and bail out.\n\t// Do not count the \"elseif\" for profiling and cmdmod\n\tinstr->ga_len = current_instr_idx(cctx);\n\n\tskip_expr_cctx(&p, cctx);\n\treturn p;\n    }\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\tint\t    moved_cmdmod = FALSE;\n\tint\t    saved_debug = FALSE;\n\tisn_T\t    debug_isn;\n\n\t// Move any CMDMOD instruction to after the jump\n\tif (((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type == ISN_CMDMOD)\n\t{\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] =\n\t\t\t\t  ((isn_T *)instr->ga_data)[instr->ga_len - 1];\n\t    --instr->ga_len;\n\t    moved_cmdmod = TRUE;\n\t}\n\n\t// Remove the already generated ISN_DEBUG, it is written below the\n\t// ISN_FOR instruction.\n\tif (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n\t{\n\t    --instr->ga_len;\n\t    debug_isn = ((isn_T *)instr->ga_data)[instr->ga_len];\n\t    saved_debug = TRUE;\n\t}\n\n\tif (compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t JUMP_ALWAYS, 0, cctx) == FAIL)\n\t    return NULL;\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\n\tif (moved_cmdmod)\n\t    ++instr->ga_len;\n\n\tif (saved_debug)\n\t{\n\t    // move the debug instruction here\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] = debug_isn;\n\t    ++instr->ga_len;\n\t}\n    }\n\n    // compile \"expr\"; if we know it evaluates to FALSE skip the block\n    CLEAR_FIELD(ppconst);\n    if (cctx->ctx_skip == SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    // the previous block was skipped, need to profile this line\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    // the previous block was skipped, may want to debug this line\n\t    generate_instr_debug(cctx);\n    }\n\n    instr_count = instr->ga_len;\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    cctx->ctx_skip = save_skip;\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tclear_ppconst(&ppconst);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (scope->se_skip_save == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression result is a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tif (error)\n\t{\n\t    clear_ppconst(&ppconst);\n\t    return NULL;\n\t}\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n\tclear_ppconst(&ppconst);\n\tscope->se_u.se_if.is_if_label = -1;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_else(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_else_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n    scope->se_u.se_if.is_seen_else = TRUE;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE)\n    {\n\tif (cctx->ctx_skip == SKIP_NOT\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    // the previous block was executed, do not count \"else\" for\n\t    // profiling\n\t    --instr->ga_len;\n\tif (cctx->ctx_skip == SKIP_YES && !scope->se_u.se_if.is_seen_skip_not)\n\t{\n\t    // the previous block was not executed, this one will, do count the\n\t    // \"else\" for profiling\n\t    cctx->ctx_skip = SKIP_NOT;\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    generate_instr(cctx, ISN_PROF_START);\n\t    cctx->ctx_skip = SKIP_YES;\n\t}\n    }\n#endif\n\n    if (!scope->se_u.se_if.is_seen_skip_not && scope->se_skip_save != SKIP_YES)\n    {\n\t// jump from previous block to the end, unless the else block is empty\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (!cctx->ctx_had_return\n\t\t    && compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t JUMP_ALWAYS, 0, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (scope->se_u.se_if.is_if_label >= 0)\n\t    {\n\t\t// previous \"if\" or \"elseif\" jumps here\n\t\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t\tscope->se_u.se_if.is_if_label = -1;\n\t    }\n\t}\n\n\tif (cctx->ctx_skip != SKIP_UNKNOWN)\n\t    cctx->ctx_skip = cctx->ctx_skip == SKIP_YES ? SKIP_NOT : SKIP_YES;\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_endif(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    ifscope_T\t*ifscope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_endif_without_if));\n\treturn NULL;\n    }\n    ifscope = &scope->se_u.se_if;\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    if (!cctx->ctx_had_return)\n\tifscope->is_had_return = FALSE;\n\n    if (scope->se_u.se_if.is_if_label >= 0)\n    {\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n    }\n    // Fill in the \"end\" label in jumps at the end of the blocks.\n    compile_fill_jump_to_end(&ifscope->is_end_label, instr->ga_len, cctx);\n\n#ifdef FEAT_PROFILE\n    // even when skipping we count the endif as executed, unless the block it's\n    // in is skipped\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t    && scope->se_skip_save != SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_START);\n    }\n#endif\n    cctx->ctx_skip = scope->se_skip_save;\n\n    // If all the blocks end in :return and there is an :else then the\n    // had_return flag is set.\n    cctx->ctx_had_return = ifscope->is_had_return && ifscope->is_seen_else;\n\n    drop_scope(cctx);\n    return arg;\n}\n\n/*\n * Save the info needed for ENDLOOP.  Used by :for and :while.\n */\n    static void\ncompile_fill_loop_info(loop_info_T *loop_info, int funcref_idx, cctx_T *cctx)\n{\n    loop_info->li_funcref_idx = funcref_idx;\n    loop_info->li_local_count = cctx->ctx_locals.ga_len;\n    loop_info->li_closure_count = cctx->ctx_closure_count;\n}\n\n/*\n * Compile \"for var in expr\":\n *\n * Produces instructions:\n *       STORE -1 in loop-idx\tSet index to -1\n *       EVAL expr\t\tResult of \"expr\" on top of stack\n * top:  FOR loop-idx, end\tIncrement index, use list on bottom of stack\n *\t\t\t\t- if beyond end, jump to \"end\"\n *\t\t\t\t- otherwise get item from list and push it\n *\t\t\t\t- store ec_funcrefs in var \"loop-idx\" + 1\n *       STORE var\t\tStore item in \"var\"\n *       ... body ...\n *       ENDLOOP funcref-idx off count\tOnly if closure uses local var\n *       JUMP top\t\t\tJump back to repeat\n * end:\t DROP\t\t\t\tDrop the result of \"expr\"\n *\n * Compile \"for [var1, var2] in expr\" - as above, but instead of \"STORE var\":\n *\t UNPACK 2\t\tSplit item in 2\n *       STORE var1\t\tStore item in \"var1\"\n *       STORE var2\t\tStore item in \"var2\"\n */\n    char_u *\ncompile_for(char_u *arg_start, cctx_T *cctx)\n{\n    char_u\t*arg;\n    char_u\t*arg_end;\n    char_u\t*name = NULL;\n    char_u\t*p;\n    char_u\t*wp;\n    int\t\tvar_count = 0;\n    int\t\tvar_list = FALSE;\n    int\t\tsemicolon = FALSE;\n    size_t\tvarlen;\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope;\n    forscope_T\t*forscope;\n    lvar_T\t*loop_lvar;\t// loop iteration variable\n    int\t\tloop_lvar_idx;\n    lvar_T\t*funcref_lvar;\n    int\t\tfuncref_lvar_idx;\n    lvar_T\t*var_lvar;\t// variable for \"var\"\n    type_T\t*vartype;\n    type_T\t*item_type = &t_any;\n    int\t\tidx;\n    int\t\tprev_lnum = cctx->ctx_prev_lnum;\n\n    p = skip_var_list(arg_start, TRUE, &var_count, &semicolon, FALSE);\n    if (p == NULL)\n\treturn NULL;\n    if (var_count == 0)\n\tvar_count = 1;\n    else\n\tvar_list = TRUE;  // can also be a list of one variable\n\n    // consume \"in\"\n    wp = p;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n    if (STRNCMP(p, \"in\", 2) != 0 || !IS_WHITE_OR_NUL(p[2]))\n    {\n\tif (*p == ':' && wp != p)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), p);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn NULL;\n    }\n    wp = p + 2;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n\n    // Find the already generated ISN_DEBUG to get the line number for the\n    // instruction written below the ISN_FOR instruction.\n    if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n    {\n\tprev_lnum = ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t .isn_arg.debug.dbg_break_lnum;\n    }\n\n    scope = new_scope(cctx, FOR_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    if (scope->se_loop_depth == MAX_LOOP_DEPTH)\n    {\n\temsg(_(e_loop_nesting_too_deep));\n\treturn NULL;\n    }\n    ++scope->se_loop_depth;\n    forscope = &scope->se_u.se_for;\n\n    // Reserve a variable to store the loop iteration counter and initialize it\n    // to -1.\n    loop_lvar = reserve_local(cctx, (char_u *)\"\", 0, ASSIGN_VAR, &t_number);\n    if (loop_lvar == NULL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;  // out of memory\n    }\n    // get the index before a following reserve_local() makes the lval invalid\n    loop_lvar_idx = loop_lvar->lv_idx;\n    generate_STORENR(cctx, loop_lvar_idx, -1);\n\n    // Reserve a variable to store ec_funcrefs.ga_len, used in ISN_ENDLOOP.\n    // The variable index is always the loop var index plus one.\n    // It is not used when no closures are encountered, we don't know yet.\n    funcref_lvar = reserve_local(cctx, (char_u *)\"\", 0, ASSIGN_VAR, &t_number);\n    if (funcref_lvar == NULL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;  // out of memory\n    }\n    // get the index before a following reserve_local() makes the lval invalid\n    funcref_lvar_idx = funcref_lvar->lv_idx;\n\n    // compile \"expr\", it remains on the stack until \"endfor\"\n    arg = p;\n    if (compile_expr0(&arg, cctx) == FAIL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;\n    }\n    arg_end = arg;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// If we know the type of \"var\" and it is not a supported type we can\n\t// give an error now.\n\tvartype = get_type_on_stack(cctx, 0);\n\tif (vartype->tt_type != VAR_LIST\n\t\t&& vartype->tt_type != VAR_STRING\n\t\t&& vartype->tt_type != VAR_BLOB\n\t\t&& vartype->tt_type != VAR_ANY\n\t\t&& vartype->tt_type != VAR_UNKNOWN)\n\t{\n\t    semsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t       vartype_name(vartype->tt_type));\n\t    drop_scope(cctx);\n\t    return NULL;\n\t}\n\n\tif (vartype->tt_type == VAR_STRING)\n\t    item_type = &t_string;\n\telse if (vartype->tt_type == VAR_BLOB)\n\t    item_type = &t_number;\n\telse if (vartype->tt_type == VAR_LIST\n\t\t\t\t     && vartype->tt_member->tt_type != VAR_ANY)\n\t{\n\t    if (!var_list)\n\t\titem_type = vartype->tt_member;\n\t    else if (vartype->tt_member->tt_type == VAR_LIST\n\t\t\t  && vartype->tt_member->tt_member->tt_type != VAR_ANY)\n\t\titem_type = vartype->tt_member->tt_member;\n\t}\n\n\t// CMDMOD_REV must come before the FOR instruction.\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"for_end\" is set when \":endfor\" is found\n\tforscope->fs_top_label = current_instr_idx(cctx);\n\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t{\n\t    int\t\tsave_prev_lnum = cctx->ctx_prev_lnum;\n\t    isn_T\t*isn;\n\n\t    // Add ISN_DEBUG here, before deciding to end the loop.  There will\n\t    // be another ISN_DEBUG before the next instruction.\n\t    // Use the prev_lnum from the ISN_DEBUG instruction removed above.\n\t    // Increment the variable count so that the loop variable can be\n\t    // inspected.\n\t    cctx->ctx_prev_lnum = prev_lnum;\n\t    isn = generate_instr_debug(cctx);\n\t    ++isn->isn_arg.debug.dbg_var_names_len;\n\t    cctx->ctx_prev_lnum = save_prev_lnum;\n\t}\n\n\tgenerate_FOR(cctx, loop_lvar_idx);\n\n\targ = arg_start;\n\tif (var_list)\n\t{\n\t    generate_UNPACK(cctx, var_count, semicolon);\n\t    arg = skipwhite(arg + 1);\t// skip white after '['\n\n\t    // drop the list item\n\t    --cctx->ctx_type_stack.ga_len;\n\n\t    // add type of the items\n\t    for (idx = 0; idx < var_count; ++idx)\n\t    {\n\t\ttype_T *type = (semicolon && idx == 0) ? vartype : item_type;\n\n\t\tif (push_type_stack(cctx, type) == FAIL)\n\t\t{\n\t\t    drop_scope(cctx);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\n\tfor (idx = 0; idx < var_count; ++idx)\n\t{\n\t    assign_dest_T\tdest = dest_local;\n\t    int\t\t\topt_flags = 0;\n\t    int\t\t\tvimvaridx = -1;\n\t    type_T\t\t*type = &t_any;\n\t    type_T\t\t*lhs_type = &t_any;\n\t    where_T\t\twhere = WHERE_INIT;\n\n\t    p = skip_var_one(arg, FALSE);\n\t    varlen = p - arg;\n\t    name = vim_strnsave(arg, varlen);\n\t    if (name == NULL)\n\t\tgoto failed;\n\t    if (*p == ':')\n\t    {\n\t\tp = skipwhite(p + 1);\n\t\tlhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    }\n\n\t    if (get_var_dest(name, &dest, CMD_for, &opt_flags,\n\t\t\t\t\t      &vimvaridx, &type, cctx) == FAIL)\n\t\tgoto failed;\n\t    if (dest != dest_local)\n\t    {\n\t\tif (generate_store_var(cctx, dest, opt_flags, vimvaridx,\n\t\t\t\t\t\t     0, 0, type, name) == FAIL)\n\t\t    goto failed;\n\t    }\n\t    else if (varlen == 1 && *arg == '_')\n\t    {\n\t\t// Assigning to \"_\": drop the value.\n\t\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t\t    goto failed;\n\t    }\n\t    else\n\t    {\n\t\t// Script var is not supported.\n\t\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t\t{\n\t\t    emsg(_(e_cannot_use_script_variable_in_for_loop));\n\t\t    goto failed;\n\t\t}\n\n\t\tif (!valid_varname(arg, (int)varlen, FALSE))\n\t\t    goto failed;\n\t\tif (lookup_local(arg, varlen, NULL, cctx) == OK)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), arg);\n\t\t    goto failed;\n\t\t}\n\n\t\t// Reserve a variable to store \"var\".\n\t\twhere.wt_index = var_list ? idx + 1 : 0;\n\t\twhere.wt_variable = TRUE;\n\t\tif (lhs_type == &t_any)\n\t\t    lhs_type = item_type;\n\t\telse if (item_type != &t_unknown\n\t\t\t&& need_type_where(item_type, lhs_type, -1,\n\t\t\t\t\t    where, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto failed;\n\t\tvar_lvar = reserve_local(cctx, arg, varlen, ASSIGN_FINAL,\n\t\t\t\t\t\t\t\t     lhs_type);\n\t\tif (var_lvar == NULL)\n\t\t    // out of memory or used as an argument\n\t\t    goto failed;\n\n\t\tif (semicolon && idx == var_count - 1)\n\t\t    var_lvar->lv_type = vartype;\n\t\tgenerate_STORE(cctx, ISN_STORE, var_lvar->lv_idx, NULL);\n\t    }\n\n\t    if (*p == ',' || *p == ';')\n\t\t++p;\n\t    arg = skipwhite(p);\n\t    vim_free(name);\n\t}\n\n\t// remember the number of variables and closures, used for ENDLOOP\n\tcompile_fill_loop_info(&forscope->fs_loop_info, funcref_lvar_idx, cctx);\n\tforscope->fs_loop_info.li_depth = scope->se_loop_depth - 1;\n    }\n\n    return arg_end;\n\nfailed:\n    vim_free(name);\n    drop_scope(cctx);\n    return NULL;\n}\n\n/*\n * Used when ending a loop of :for and :while: Generate an ISN_ENDLOOP\n * instruction if any variable was declared that could be used by a new\n * closure.\n */\n    static int\ncompile_loop_end(loop_info_T *loop_info, cctx_T *cctx)\n{\n    if (cctx->ctx_locals.ga_len > loop_info->li_local_count\n\t    && cctx->ctx_closure_count > loop_info->li_closure_count)\n\treturn generate_ENDLOOP(cctx, loop_info);\n    return OK;\n}\n\n/*\n * compile \"endfor\"\n */\n    char_u *\ncompile_endfor(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope = cctx->ctx_scope;\n    forscope_T\t*forscope;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != FOR_SCOPE)\n    {\n\temsg(_(e_endfor_without_for));\n\treturn NULL;\n    }\n    forscope = &scope->se_u.se_for;\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// Handle the case that any local variables were declared that might be\n\t// used in a closure.\n\tif (compile_loop_end(&forscope->fs_loop_info, cctx) == FAIL)\n\t    return NULL;\n\n\tunwind_locals(cctx, scope->se_local_count, FALSE);\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, forscope->fs_top_label);\n\n\t// Fill in the \"end\" label in the FOR statement so it can jump here.\n\t// In debug mode an ISN_DEBUG was inserted.\n\tisn = ((isn_T *)instr->ga_data) + forscope->fs_top_label\n\t\t\t\t+ (cctx->ctx_compile_type == CT_DEBUG ? 1 : 0);\n\tisn->isn_arg.forloop.for_end = instr->ga_len;\n\n\t// Fill in the \"end\" label any BREAK statements\n\tcompile_fill_jump_to_end(&forscope->fs_end_label, instr->ga_len, cctx);\n\n\t// Below the \":for\" scope drop the \"expr\" list from the stack.\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    return NULL;\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * compile \"while expr\"\n *\n * Produces instructions:\n * top:  EVAL expr\t\t\tPush result of \"expr\"\n *\t WHILE funcref-idx  end\t\tJump if false\n *\t ... body ...\n *       ENDLOOP funcref-idx off count\tonly if closure uses local var\n *\t JUMP top\t\t\tJump back to repeat\n * end:\n *\n */\n    char_u *\ncompile_while(char_u *arg, cctx_T *cctx)\n{\n    char_u\t    *p = arg;\n    scope_T\t    *scope;\n    whilescope_T    *whilescope;\n    lvar_T\t    *funcref_lvar;\n    int\t\t    funcref_lvar_idx;\n\n    scope = new_scope(cctx, WHILE_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    if (scope->se_loop_depth == MAX_LOOP_DEPTH)\n    {\n\temsg(_(e_loop_nesting_too_deep));\n\treturn NULL;\n    }\n    ++scope->se_loop_depth;\n    whilescope = &scope->se_u.se_while;\n\n    // \"endwhile\" jumps back here, one before when profiling or using cmdmods\n    whilescope->ws_top_label = current_instr_idx(cctx);\n\n    // Reserve a variable to store ec_funcrefs.ga_len, used in ISN_ENDLOOP.\n    // It is not used when no closures are encountered, we don't know yet.\n    funcref_lvar = reserve_local(cctx, (char_u *)\"\", 0, ASSIGN_VAR, &t_number);\n    if (funcref_lvar == NULL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;  // out of memory\n    }\n    // get the index before a following reserve_local() makes the lval invalid\n    funcref_lvar_idx = funcref_lvar->lv_idx;\n\n    // remember the number of variables and closures, used for ENDLOOP\n    compile_fill_loop_info(&whilescope->ws_loop_info, funcref_lvar_idx, cctx);\n    whilescope->ws_loop_info.li_depth = scope->se_loop_depth - 1;\n\n    // compile \"expr\"\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return FAIL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"while_end\" is set when \":endwhile\" is found\n\tif (compile_jump_to_end(&whilescope->ws_end_label,\n\t\t\t     JUMP_WHILE_FALSE, funcref_lvar_idx, cctx) == FAIL)\n\t    return FAIL;\n    }\n\n    return p;\n}\n\n/*\n * compile \"endwhile\"\n */\n    char_u *\ncompile_endwhile(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n    if (scope == NULL || scope->se_type != WHILE_SCOPE)\n    {\n\temsg(_(e_endwhile_without_while));\n\treturn NULL;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\twhilescope_T\t*whilescope = &scope->se_u.se_while;\n\n\t// Handle the case that any local variables were declared that might be\n\t// used in a closure.\n\tif (compile_loop_end(&whilescope->ws_loop_info, cctx) == FAIL)\n\t    return NULL;\n\n\tunwind_locals(cctx, scope->se_local_count, FALSE);\n\n#ifdef FEAT_PROFILE\n\t// count the endwhile before jumping\n\tmay_generate_prof_end(cctx, cctx->ctx_lnum);\n#endif\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, scope->se_u.se_while.ws_top_label);\n\n\t// Fill in the \"end\" label in the WHILE statement so it can jump here.\n\t// And in any jumps for \":break\"\n\tcompile_fill_jump_to_end(&scope->se_u.se_while.ws_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * Get the current information about variables declared inside a loop.\n * Returns TRUE if there are any and fills \"lvi\".\n */\n    int\nget_loop_var_info(cctx_T *cctx, loopvarinfo_T *lvi)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    int\t\tprev_local_count = 0;\n\n    CLEAR_POINTER(lvi);\n    for (;;)\n    {\n\tloop_info_T\t*loopinfo;\n\tint\t\tcur_local_last;\n\tint\t\tstart_local_count;\n\n\twhile (scope != NULL && scope->se_type != WHILE_SCOPE\n\t\t\t\t\t\t&& scope->se_type != FOR_SCOPE)\n\t    scope = scope->se_outer;\n\tif (scope == NULL)\n\t    break;\n\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    loopinfo = &scope->se_u.se_while.ws_loop_info;\n\t    // :while reserves one variable for funcref count\n\t    cur_local_last = loopinfo->li_local_count - 1;\n\t}\n\telse\n\t{\n\t    loopinfo = &scope->se_u.se_for.fs_loop_info;\n\t    // :for reserves three variable: loop count, funcref count and loop\n\t    // var\n\t    cur_local_last = loopinfo->li_local_count - 3;\n\t}\n\n\tstart_local_count = loopinfo->li_local_count;\n\tif (cctx->ctx_locals.ga_len > start_local_count)\n\t{\n\t    lvi->lvi_loop[loopinfo->li_depth].var_idx =\n\t\t\t\t\t\t      (short)start_local_count;\n\t    lvi->lvi_loop[loopinfo->li_depth].var_count =\n\t\t\t  (short)(cctx->ctx_locals.ga_len - start_local_count\n\t\t\t\t\t\t\t   - prev_local_count);\n\t    if (lvi->lvi_depth == 0)\n\t\tlvi->lvi_depth = loopinfo->li_depth + 1;\n\t}\n\n\tscope = scope->se_outer;\n\tprev_local_count = cctx->ctx_locals.ga_len - cur_local_last;\n    }\n    return lvi->lvi_depth > 0;\n}\n\n/*\n * Get the index of the variable \"idx\" in a loop, if any.\n */\n    void\nget_loop_var_idx(cctx_T *cctx, int idx, lvar_T *lvar)\n{\n    loopvarinfo_T lvi;\n\n    lvar->lv_loop_depth = -1;\n    lvar->lv_loop_idx = -1;\n    if (get_loop_var_info(cctx, &lvi))\n    {\n\tint depth;\n\n\tfor (depth = lvi.lvi_depth - 1; depth >= 0; --depth)\n\t    if (idx >= lvi.lvi_loop[depth].var_idx\n\t\t    && idx < lvi.lvi_loop[depth].var_idx\n\t\t\t\t\t       + lvi.lvi_loop[depth].var_count)\n\t    {\n\t\tlvar->lv_loop_depth = depth;\n\t\tlvar->lv_loop_idx = lvi.lvi_loop[depth].var_idx;\n\t\treturn;\n\t    }\n    }\n}\n\n/*\n * Common for :break, :continue and :return\n */\n    static int\ncompile_find_scope(\n\tint\t    *loop_label,    // where to jump to or NULL\n\tendlabel_T  ***el,\t    // end label or NULL\n\tint\t    *try_scopes,    // :try scopes encountered or NULL\n\tchar\t    *error,\t    // error to use when no scope found\n\tcctx_T\t    *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n\n    for (;;)\n    {\n\tif (scope == NULL)\n\t{\n\t    if (error != NULL)\n\t\temsg(_(error));\n\t    return FAIL;\n\t}\n\tif (scope->se_type == FOR_SCOPE)\n\t{\n\t    if (compile_loop_end(&scope->se_u.se_for.fs_loop_info, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t    if (loop_label != NULL)\n\t\t*loop_label = scope->se_u.se_for.fs_top_label;\n\t    if (el != NULL)\n\t\t*el = &scope->se_u.se_for.fs_end_label;\n\t    break;\n\t}\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    if (compile_loop_end(&scope->se_u.se_while.ws_loop_info, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t    if (loop_label != NULL)\n\t\t*loop_label = scope->se_u.se_while.ws_top_label;\n\t    if (el != NULL)\n\t\t*el = &scope->se_u.se_while.ws_end_label;\n\t    break;\n\t}\n\tif (try_scopes != NULL && scope->se_type == TRY_SCOPE)\n\t    ++*try_scopes;\n\tscope = scope->se_outer;\n    }\n    return OK;\n}\n\n/*\n * compile \"continue\"\n */\n    char_u *\ncompile_continue(char_u *arg, cctx_T *cctx)\n{\n    int\t\ttry_scopes = 0;\n    int\t\tloop_label;\n\n    if (compile_find_scope(&loop_label, NULL, &try_scopes,\n\t\t\t\te_continue_without_while_or_for, cctx) == FAIL)\n\treturn NULL;\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.\n\tgenerate_TRYCONT(cctx, try_scopes, loop_label);\n    else\n\t// Jump back to the FOR or WHILE instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, loop_label);\n\n    return arg;\n}\n\n/*\n * compile \"break\"\n */\n    char_u *\ncompile_break(char_u *arg, cctx_T *cctx)\n{\n    int\t\ttry_scopes = 0;\n    endlabel_T\t**el;\n\n    if (compile_find_scope(NULL, &el, &try_scopes,\n\t\t\t\t   e_break_without_while_or_for, cctx) == FAIL)\n\treturn NULL;\n\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.  Then come to the next JUMP\n\t// intruction, which we don't know the index of yet.\n\tgenerate_TRYCONT(cctx, try_scopes, cctx->ctx_instr.ga_len + 1);\n\n    // Jump to the end of the FOR or WHILE loop.  The instruction index will be\n    // filled in later.\n    if (compile_jump_to_end(el, JUMP_ALWAYS, 0, cctx) == FAIL)\n\treturn FAIL;\n\n    return arg;\n}\n\n/*\n * compile \"{\" start of block\n */\n    char_u *\ncompile_block(char_u *arg, cctx_T *cctx)\n{\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return skipwhite(arg + 1);\n}\n\n/*\n * compile end of block: drop one scope\n */\n    void\ncompile_endblock(cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n\n    cctx->ctx_scope = scope->se_outer;\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    vim_free(scope);\n}\n\n/*\n * Compile \"try\".\n * Creates a new scope for the try-endtry, pointing to the first catch and\n * finally.\n * Creates another scope for the \"try\" block itself.\n * TRY instruction sets up exception handling at runtime.\n *\n *\t\"try\"\n *\t    TRY -> catch1, -> finally  push trystack entry\n *\t    ... try block\n *\t\"throw {exception}\"\n *\t    EVAL {exception}\n *\t    THROW\t\tcreate exception\n *\t    ... try block\n *\t\" catch {expr}\"\n *\t    JUMP -> finally\n * catch1:  PUSH exception\n *\t    EVAL {expr}\n *\t    MATCH\n *\t    JUMP nomatch -> catch2\n *\t    CATCH   remove exception\n *\t    ... catch block\n *\t\" catch\"\n *\t    JUMP -> finally\n * catch2:  CATCH   remove exception\n *\t    ... catch block\n *\t\" finally\"\n * finally:\n *\t    ... finally block\n *\t\" endtry\"\n *\t    ENDTRY  pop trystack entry, may rethrow\n */\n    char_u *\ncompile_try(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*try_scope;\n    scope_T\t*scope;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // scope that holds the jumps that go to catch/finally/endtry\n    try_scope = new_scope(cctx, TRY_SCOPE);\n    if (try_scope == NULL)\n\treturn NULL;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\t// \"try_catch\" is set when the first \":catch\" is found or when no catch\n\t// is found and \":finally\" is found.\n\t// \"try_finally\" is set when \":finally\" is found\n\t// \"try_endtry\" is set when \":endtry\" is found\n\ttry_scope->se_u.se_try.ts_try_label = instr->ga_len;\n\tif ((isn = generate_instr(cctx, ISN_TRY)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.tryref.try_ref = ALLOC_CLEAR_ONE(tryref_T);\n\tif (isn->isn_arg.tryref.try_ref == NULL)\n\t    return NULL;\n    }\n\n    // scope for the try block itself\n    scope = new_scope(cctx, BLOCK_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    return arg;\n}\n\n/*\n * Compile \"catch {expr}\".\n */\n    char_u *\ncompile_catch(char_u *arg, cctx_T *cctx UNUSED)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*p;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_catch_without_try));\n\treturn NULL;\n    }\n\n    if (scope->se_u.se_try.ts_caught_all)\n    {\n\temsg(_(e_catch_unreachable_after_catch_all));\n\treturn NULL;\n    }\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_try.ts_no_return = TRUE;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n#ifdef FEAT_PROFILE\n\t// the profile-start should be after the jump\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    --instr->ga_len;\n#endif\n\t// Jump from end of previous block to :finally or :endtry\n\tif (compile_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t JUMP_ALWAYS, 0, cctx) == FAIL)\n\t    return NULL;\n\n\t// End :try or :catch scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = instr->ga_len;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t{\n\t    // a \"throw\" that jumps here needs to be counted\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    // the \"catch\" is also counted\n\t    generate_instr(cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    generate_instr_debug(cctx);\n    }\n\n    p = skipwhite(arg);\n    if (ends_excmd2(arg, p))\n    {\n\tscope->se_u.se_try.ts_caught_all = TRUE;\n\tscope->se_u.se_try.ts_catch_label = 0;\n    }\n    else\n    {\n\tchar_u *end;\n\tchar_u *pat;\n\tchar_u *tofree = NULL;\n\tint\tdropped = 0;\n\tint\tlen;\n\n\t// Push v:exception, push {expr} and MATCH\n\tgenerate_instr_type(cctx, ISN_PUSHEXC, &t_string);\n\n\tend = skip_regexp_ex(p + 1, *p, TRUE, &tofree, &dropped, NULL);\n\tif (*end != *p)\n\t{\n\t    semsg(_(e_separator_mismatch_str), p);\n\t    vim_free(tofree);\n\t    return NULL;\n\t}\n\tif (tofree == NULL)\n\t    len = (int)(end - (p + 1));\n\telse\n\t    len = (int)(end - tofree);\n\tpat = vim_strnsave(tofree == NULL ? p + 1 : tofree, len);\n\tvim_free(tofree);\n\tp += len + 2 + dropped;\n\tif (pat == NULL)\n\t    return NULL;\n\tif (generate_PUSHS(cctx, &pat) == FAIL)\n\t    return NULL;\n\n\tif (generate_COMPARE(cctx, EXPR_MATCH, FALSE) == FAIL)\n\t    return NULL;\n\n\tscope->se_u.se_try.ts_catch_label = instr->ga_len;\n\tif (generate_JUMP(cctx, JUMP_IF_FALSE, 0) == FAIL)\n\t    return NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_CATCH) == NULL)\n\treturn NULL;\n\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return p;\n}\n\n    char_u *\ncompile_finally(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    int\t\tthis_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_finally_without_try));\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_finally != 0)\n\t{\n\t    emsg(_(e_multiple_finally));\n\t    return NULL;\n\t}\n\n\tthis_instr = instr->ga_len;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t{\n\t    // jump to the profile start of the \"finally\"\n\t    --this_instr;\n\n\t    // jump to the profile end above it\n\t    if (this_instr > 0 && ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t     .isn_type == ISN_PROF_END)\n\t\t--this_instr;\n\t}\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks.\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t     this_instr, cctx);\n\n\t// If there is no :catch then an exception jumps to :finally.\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = this_instr;\n\tisn->isn_arg.tryref.try_ref->try_finally = this_instr;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = this_instr;\n\t    scope->se_u.se_try.ts_catch_label = 0;\n\t}\n\tscope->se_u.se_try.ts_has_finally = TRUE;\n\tif (generate_instr(cctx, ISN_FINALLY) == NULL)\n\t    return NULL;\n    }\n\n    return arg;\n}\n\n    char_u *\ncompile_endtry(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*try_isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :catch or :finally\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\tif (scope == NULL)\n\t    emsg(_(e_endtry_without_try));\n\telse if (scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_endif));\n\treturn NULL;\n    }\n\n    try_isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (try_isn->isn_arg.tryref.try_ref->try_catch == 0\n\t\t\t  && try_isn->isn_arg.tryref.try_ref->try_finally == 0)\n\t{\n\t    emsg(_(e_missing_catch_or_finally));\n\t    return NULL;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t.isn_type == ISN_PROF_START)\n\t    // move the profile start after \"endtry\" so that it's not counted when\n\t    // the exception is rethrown.\n\t    --instr->ga_len;\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks, if not\n\t// done by \":finally\".\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Last catch without match jumps here\n\t    isn_T *isn = ((isn_T *)instr->ga_data)\n\t\t\t\t\t   + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n    }\n\n    // If there is a finally clause that ends in return then we will return.\n    // If one of the blocks didn't end in \"return\" or we did not catch all\n    // exceptions reset the had_return flag.\n    if (!(scope->se_u.se_try.ts_has_finally && cctx->ctx_had_return)\n\t    && (scope->se_u.se_try.ts_no_return\n\t\t|| !scope->se_u.se_try.ts_caught_all))\n\tcctx->ctx_had_return = FALSE;\n\n    compile_endblock(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set instruction index in ISN_TRY\n\t// instruction\n\ttry_isn->isn_arg.tryref.try_ref->try_endtry = instr->ga_len;\n\tif (generate_instr(cctx, ISN_ENDTRY) == NULL)\n\t    return NULL;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n    }\n    return arg;\n}\n\n/*\n * compile \"throw {expr}\"\n */\n    char_u *\ncompile_throw(char_u *arg, cctx_T *cctx UNUSED)\n{\n    char_u *p = skipwhite(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn p;\n    if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\treturn NULL;\n    if (generate_instr_drop(cctx, ISN_THROW, 1) == NULL)\n\treturn NULL;\n\n    return p;\n}\n\n/*\n * Compile an expression or function call.\n */\n    char_u *\ncompile_eval(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    int\t\tname_only;\n    long\tlnum = SOURCING_LNUM;\n\n    // find_ex_command() will consider a variable name an expression, assuming\n    // that something follows on the next line.  Check that something actually\n    // follows, otherwise it's probably a misplaced command.\n    name_only = cmd_is_name_only(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (name_only && lnum == SOURCING_LNUM)\n    {\n\tsemsg(_(e_expression_without_effect_str), arg);\n\treturn NULL;\n    }\n\n    // drop the result\n    generate_instr_drop(cctx, ISN_DROP, 1);\n\n    return skipwhite(p);\n}\n\n/*\n * Get the local variable index for deferred function calls.\n * Reserve it when not done already.\n * Returns zero for failure.\n */\n    int\nget_defer_var_idx(cctx_T *cctx)\n{\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + cctx->ctx_ufunc->uf_dfunc_idx;\n    if (dfunc->df_defer_var_idx == 0)\n    {\n\tlvar_T *lvar = reserve_local(cctx, (char_u *)\"@defer@\", 7,\n\t\t\t\t\t\t\t    TRUE, &t_list_any);\n\tif (lvar == NULL)\n\t    return 0;\n\tdfunc->df_defer_var_idx = lvar->lv_idx + 1;\n    }\n    return dfunc->df_defer_var_idx;\n}\n\n/*\n * Compile \"defer func(arg)\".\n */\n    char_u *\ncompile_defer(char_u *arg_start, cctx_T *cctx)\n{\n    char_u\t*paren;\n    char_u\t*arg = arg_start;\n    int\t\targcount = 0;\n    int\t\tdefer_var_idx;\n    type_T\t*type;\n    int\t\tfunc_idx;\n\n    // Get a funcref for the function name.\n    // TODO: better way to find the \"(\".\n    paren = vim_strchr(arg, '(');\n    if (paren == NULL)\n    {\n\tsemsg(_(e_missing_parenthesis_str), arg);\n\treturn NULL;\n    }\n    *paren = NUL;\n    func_idx = find_internal_func(arg);\n    if (func_idx >= 0)\n\t// TODO: better type\n\tgenerate_PUSHFUNC(cctx, (char_u *)internal_func_name(func_idx),\n\t\t\t\t\t\t\t   &t_func_any, FALSE);\n    else if (compile_expr0(&arg, cctx) == FAIL)\n\treturn NULL;\n    *paren = '(';\n\n    // check for function type\n    type = get_type_on_stack(cctx, 0);\n    if (type->tt_type != VAR_FUNC)\n    {\n\temsg(_(e_function_name_required));\n\treturn NULL;\n    }\n\n    // compile the arguments\n    arg = skipwhite(paren + 1);\n    if (compile_arguments(&arg, cctx, &argcount, CA_NOT_SPECIAL) == FAIL)\n\treturn NULL;\n\n    if (func_idx >= 0)\n    {\n\ttype2_T\t*argtypes = NULL;\n\ttype2_T\tshuffled_argtypes[MAX_FUNC_ARGS];\n\n\tif (check_internal_func_args(cctx, func_idx, argcount, FALSE,\n\t\t\t\t\t &argtypes, shuffled_argtypes) == FAIL)\n\t    return NULL;\n    }\n    else if (check_func_args_from_type(cctx, type, argcount, TRUE,\n\t\t\t\t\t\t\t    arg_start) == FAIL)\n\treturn NULL;\n\n    defer_var_idx = get_defer_var_idx(cctx);\n    if (defer_var_idx == 0)\n\treturn NULL;\n    if (generate_DEFER(cctx, defer_var_idx - 1, argcount) == FAIL)\n\treturn NULL;\n\n    return skipwhite(arg);\n}\n\n/*\n * compile \"echo expr\"\n * compile \"echomsg expr\"\n * compile \"echoerr expr\"\n * compile \"echoconsole expr\"\n * compile \"echowindow expr\" - may have cmd_count set\n * compile \"execute expr\"\n */\n    char_u *\ncompile_mult_expr(char_u *arg, int cmdidx, long cmd_count, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    char_u\t*prev = arg;\n    char_u\t*expr_start;\n    int\t\tcount = 0;\n    int\t\tstart_ctx_lnum = cctx->ctx_lnum;\n    type_T\t*type;\n    int\t\tr = OK;\n\n    for (;;)\n    {\n\tif (ends_excmd2(prev, p))\n\t    break;\n\texpr_start = p;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // check for non-void type\n\t    type = get_type_on_stack(cctx, 0);\n\t    if (type->tt_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), expr_start);\n\t\treturn NULL;\n\t    }\n\t}\n\n\t++count;\n\tprev = p;\n\tp = skipwhite(p);\n    }\n\n    if (count > 0)\n    {\n\tlong save_lnum = cctx->ctx_lnum;\n\n\t// Use the line number where the command started.\n\tcctx->ctx_lnum = start_ctx_lnum;\n\n\tif (cmdidx == CMD_echo || cmdidx == CMD_echon)\n\t    r = generate_ECHO(cctx, cmdidx == CMD_echo, count);\n\telse if (cmdidx == CMD_execute)\n\t    r = generate_MULT_EXPR(cctx, ISN_EXECUTE, count);\n\telse if (cmdidx == CMD_echomsg)\n\t    r = generate_MULT_EXPR(cctx, ISN_ECHOMSG, count);\n#ifdef HAS_MESSAGE_WINDOW\n\telse if (cmdidx == CMD_echowindow)\n\t    r = generate_ECHOWINDOW(cctx, count, cmd_count);\n#endif\n\telse if (cmdidx == CMD_echoconsole)\n\t    r = generate_MULT_EXPR(cctx, ISN_ECHOCONSOLE, count);\n\telse\n\t    r = generate_MULT_EXPR(cctx, ISN_ECHOERR, count);\n\n\tcctx->ctx_lnum = save_lnum;\n    }\n    return r == OK ? p : NULL;\n}\n\n/*\n * If \"eap\" has a range that is not a constant generate an ISN_RANGE\n * instruction to compute it and return OK.\n * Otherwise return FAIL, the caller must deal with any range.\n */\n    static int\ncompile_variable_range(exarg_T *eap, cctx_T *cctx)\n{\n    char_u *range_end = skip_range(eap->cmd, TRUE, NULL);\n    char_u *p = skipdigits(eap->cmd);\n\n    if (p == range_end)\n\treturn FAIL;\n    return generate_RANGE(cctx, vim_strnsave(eap->cmd, range_end - eap->cmd));\n}\n\n/*\n * :put r\n * :put ={expr}\n */\n    char_u *\ncompile_put(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = arg;\n    linenr_T\tlnum;\n    char\t*errormsg;\n    int\t\tabove = eap->forceit;\n\n    eap->regname = *line;\n\n    if (eap->regname == '=')\n    {\n\tchar_u *p = skipwhite(line + 1);\n\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tline = p;\n    }\n    else if (eap->regname != NUL)\n\t++line;\n\n    if (compile_variable_range(eap, cctx) == OK)\n    {\n\tlnum = above ? LNUM_VARIABLE_RANGE_ABOVE : LNUM_VARIABLE_RANGE;\n    }\n    else\n    {\n\t// Either no range or a number.\n\t// \"errormsg\" will not be set because the range is ADDR_LINES.\n\tif (parse_cmd_address(eap, &errormsg, FALSE) == FAIL)\n\t    // cannot happen\n\t    return NULL;\n\tif (eap->addr_count == 0)\n\t    lnum = -1;\n\telse\n\t    lnum = eap->line2;\n\tif (above)\n\t    --lnum;\n    }\n\n    generate_PUT(cctx, eap->regname, lnum);\n    return line;\n}\n\n/*\n * A command that is not compiled, execute with legacy code.\n */\n    char_u *\ncompile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = line_arg;\n    char_u\t*p;\n    int\t\thas_expr = FALSE;\n    char_u\t*nextcmd = (char_u *)\"\";\n    char_u\t*tofree = NULL;\n    char_u\t*cmd_arg = NULL;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\tgoto theend;\n\n    // If there was a prececing command modifier, drop it and include it in the\n    // EXEC command.\n    if (cctx->ctx_has_cmdmod)\n    {\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tisn_T\t\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\tif (isn->isn_type == ISN_CMDMOD)\n\t{\n\t    vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod\n\t\t\t\t\t       ->cmod_filter_regmatch.regprog);\n\t    vim_free(isn->isn_arg.cmdmod.cf_cmdmod);\n\t    --instr->ga_len;\n\t    cctx->ctx_has_cmdmod = FALSE;\n\t}\n    }\n\n    if (eap->cmdidx >= 0 && eap->cmdidx < CMD_SIZE)\n    {\n\tlong\targt = eap->argt;\n\tint\tusefilter = FALSE;\n\n\thas_expr = argt & (EX_XFILE | EX_EXPAND);\n\n\t// If the command can be followed by a bar, find the bar and truncate\n\t// it, so that the following command can be compiled.\n\t// The '|' is overwritten with a NUL, it is put back below.\n\tif ((eap->cmdidx == CMD_write || eap->cmdidx == CMD_read)\n\t\t\t\t\t\t\t   && *eap->arg == '!')\n\t    // :w !filter or :r !filter or :r! filter\n\t    usefilter = TRUE;\n\tif ((argt & EX_TRLBAR) && !usefilter)\n\t{\n\t    eap->argt = argt;\n\t    separate_nextcmd(eap, TRUE);\n\t    if (eap->nextcmd != NULL)\n\t\tnextcmd = eap->nextcmd;\n\t}\n\telse if (eap->cmdidx == CMD_wincmd)\n\t{\n\t    p = eap->arg;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == 'g' || *p == Ctrl_G)\n\t\t++p;\n\t    p = skipwhite(p);\n\t    if (*p == '|')\n\t    {\n\t\t*p = NUL;\n\t\tnextcmd = p + 1;\n\t    }\n\t}\n\telse if (eap->cmdidx == CMD_command || eap->cmdidx == CMD_autocmd)\n\t{\n\t    // If there is a trailing '{' read lines until the '}'\n\t    p = eap->arg + STRLEN(eap->arg) - 1;\n\t    while (p > eap->arg && VIM_ISWHITE(*p))\n\t\t--p;\n\t    if (*p == '{')\n\t    {\n\t\texarg_T ea;\n\t\tint\tflags = 0;  // unused\n\t\tint\tstart_lnum = SOURCING_LNUM;\n\n\t\tCLEAR_FIELD(ea);\n\t\tea.arg = eap->arg;\n\t\tfill_exarg_from_cctx(&ea, cctx);\n\t\t(void)may_get_cmd_block(&ea, p, &tofree, &flags);\n\t\tif (tofree != NULL)\n\t\t{\n\t\t    *p = NUL;\n\t\t    line = concat_str(line, tofree);\n\t\t    if (line == NULL)\n\t\t\tgoto theend;\n\t\t    vim_free(tofree);\n\t\t    tofree = line;\n\t\t    SOURCING_LNUM = start_lnum;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (eap->cmdidx == CMD_syntax && STRNCMP(eap->arg, \"include \", 8) == 0)\n    {\n\t// expand filename in \"syntax include [@group] filename\"\n\thas_expr = TRUE;\n\teap->arg = skipwhite(eap->arg + 7);\n\tif (*eap->arg == '@')\n\t    eap->arg = skiptowhite(eap->arg);\n    }\n\n    if ((eap->cmdidx == CMD_global || eap->cmdidx == CMD_vglobal)\n\t\t\t\t\t\t       && STRLEN(eap->arg) > 4)\n    {\n\tint delim = *eap->arg;\n\n\tp = skip_regexp_ex(eap->arg + 1, delim, TRUE, NULL, NULL, NULL);\n\tif (*p == delim)\n\t    cmd_arg = p + 1;\n    }\n\n    if (eap->cmdidx == CMD_folddoopen || eap->cmdidx == CMD_folddoclosed)\n\tcmd_arg = eap->arg;\n\n    if (cmd_arg != NULL)\n    {\n\texarg_T nea;\n\n\tCLEAR_FIELD(nea);\n\tnea.cmd = cmd_arg;\n\tp = find_ex_command(&nea, NULL, lookup_scriptitem, NULL);\n\tif (nea.cmdidx < CMD_SIZE)\n\t{\n\t    has_expr = excmd_get_argt(nea.cmdidx) & (EX_XFILE | EX_EXPAND);\n\t    if (has_expr)\n\t\teap->arg = skiptowhite(eap->arg);\n\t}\n    }\n\n    if (has_expr && (p = (char_u *)strstr((char *)eap->arg, \"`=\")) != NULL)\n    {\n\tint\tcount = 0;\n\tchar_u\t*start = skipwhite(line);\n\n\t// :cmd xxx`=expr1`yyy`=expr2`zzz\n\t// PUSHS \":cmd xxx\"\n\t// eval expr1\n\t// PUSHS \"yyy\"\n\t// eval expr2\n\t// PUSHS \"zzz\"\n\t// EXECCONCAT 5\n\tfor (;;)\n\t{\n\t    if (p > start)\n\t    {\n\t\tchar_u *val = vim_strnsave(start, p - start);\n\n\t\tgenerate_PUSHS(cctx, &val);\n\t\t++count;\n\t    }\n\t    p += 2;\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t    may_generate_2STRING(-1, TRUE, cctx);\n\t    ++count;\n\t    p = skipwhite(p);\n\t    if (*p != '`')\n\t    {\n\t\temsg(_(e_missing_backtick));\n\t\treturn NULL;\n\t    }\n\t    start = p + 1;\n\n\t    p = (char_u *)strstr((char *)start, \"`=\");\n\t    if (p == NULL)\n\t    {\n\t\tif (*skipwhite(start) != NUL)\n\t\t{\n\t\t    char_u *val = vim_strsave(start);\n\n\t\t    generate_PUSHS(cctx, &val);\n\t\t    ++count;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tgenerate_EXECCONCAT(cctx, count);\n    }\n    else\n\tgenerate_EXEC_copy(cctx, ISN_EXEC, line);\n\ntheend:\n    if (*nextcmd != NUL)\n    {\n\t// the parser expects a pointer to the bar, put it back\n\t--nextcmd;\n\t*nextcmd = '|';\n    }\n    vim_free(tofree);\n\n    return nextcmd;\n}\n\n/*\n * A script command with heredoc, e.g.\n *\truby << EOF\n *\t   command\n *\tEOF\n * Has been turned into one long line with NL characters by\n * get_function_body():\n *\truby << EOF<NL>   command<NL>EOF\n */\n    char_u *\ncompile_script(char_u *line, cctx_T *cctx)\n{\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\tif ((isn = generate_instr(cctx, ISN_EXEC_SPLIT)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.string = vim_strsave(line);\n    }\n    return (char_u *)\"\";\n}\n\n\n/*\n * :s/pat/repl/\n */\n    char_u *\ncompile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *cmd = eap->arg;\n    char_u  *expr = (char_u *)strstr((char *)cmd, \"\\\\=\");\n\n    if (expr != NULL)\n    {\n\tint delimiter = *cmd++;\n\n\t// There is a \\=expr, find it in the substitute part.\n\tcmd = skip_regexp_ex(cmd, delimiter, magic_isset(), NULL, NULL, NULL);\n\tif (cmd[0] == delimiter && cmd[1] == '\\\\' && cmd[2] == '=')\n\t{\n\t    garray_T\tsave_ga = cctx->ctx_instr;\n\t    char_u\t*end;\n\t    int\t\texpr_res;\n\t    int\t\ttrailing_error;\n\t    int\t\tinstr_count;\n\t    isn_T\t*instr;\n\t    isn_T\t*isn;\n\n\t    cmd += 3;\n\t    end = skip_substitute(cmd, delimiter);\n\n\t    // Temporarily reset the list of instructions so that the jump\n\t    // labels are correct.\n\t    cctx->ctx_instr.ga_len = 0;\n\t    cctx->ctx_instr.ga_maxlen = 0;\n\t    cctx->ctx_instr.ga_data = NULL;\n\t    expr_res = compile_expr0(&cmd, cctx);\n\t    if (end[-1] == NUL)\n\t\tend[-1] = delimiter;\n\t    cmd = skipwhite(cmd);\n\t    trailing_error = *cmd != delimiter && *cmd != NUL;\n\n\t    if (expr_res == FAIL || trailing_error\n\t\t\t\t       || GA_GROW_FAILS(&cctx->ctx_instr, 1))\n\t    {\n\t\tif (trailing_error)\n\t\t    semsg(_(e_trailing_characters_str), cmd);\n\t\tclear_instr_ga(&cctx->ctx_instr);\n\t\tcctx->ctx_instr = save_ga;\n\t\treturn NULL;\n\t    }\n\n\t    // Move the generated instructions into the ISN_SUBSTITUTE\n\t    // instructions, then restore the list of instructions before\n\t    // adding the ISN_SUBSTITUTE instruction.\n\t    instr_count = cctx->ctx_instr.ga_len;\n\t    instr = cctx->ctx_instr.ga_data;\n\t    instr[instr_count].isn_type = ISN_FINISH;\n\n\t    cctx->ctx_instr = save_ga;\n\t    if ((isn = generate_instr(cctx, ISN_SUBSTITUTE)) == NULL)\n\t    {\n\t\tint idx;\n\n\t\tfor (idx = 0; idx < instr_count; ++idx)\n\t\t    delete_instr(instr + idx);\n\t\tvim_free(instr);\n\t\treturn NULL;\n\t    }\n\t    isn->isn_arg.subs.subs_cmd = vim_strsave(arg);\n\t    isn->isn_arg.subs.subs_instr = instr;\n\n\t    // skip over flags\n\t    if (*end == '&')\n\t\t++end;\n\t    while (ASCII_ISALPHA(*end) || *end == '#')\n\t\t++end;\n\t    return end;\n\t}\n    }\n\n    return compile_exec(arg, eap, cctx);\n}\n\n    char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (lhs->lhs_append)\n\t    {\n\t\t// First load the current variable value.\n\t\tif (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    // Gets the redirected text and put it on the stack, then store it\n\t    // in the variable.\n\t    generate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t    if (lhs->lhs_append)\n\t\tgenerate_CONCAT(cctx, 2);\n\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\t// Use the info in \"lhs\" to store the value at the index in the\n\t\t// list or dict.\n\t\tif (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\t    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\treturn NULL;\n\n\t    VIM_CLEAR(lhs->lhs_name);\n\t    VIM_CLEAR(lhs->lhs_whole);\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tgenerate_instr(cctx, ISN_REDIRSTART);\n\tlhs->lhs_append = append;\n\tif (lhs->lhs_has_index)\n\t{\n\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t    if (lhs->lhs_whole == NULL)\n\t\treturn NULL;\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    char_u *\ncompile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    isn_T\t*isn;\n    char_u\t*p;\n\n    isn = generate_instr(cctx, ISN_CEXPR_AUCMD);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.number = eap->cmdidx;\n\n    p = eap->arg;\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    isn = generate_instr(cctx, ISN_CEXPR_CORE);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref = ALLOC_ONE(cexprref_T);\n    if (isn->isn_arg.cexpr.cexpr_ref == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdidx = eap->cmdidx;\n    isn->isn_arg.cexpr.cexpr_ref->cer_forceit = eap->forceit;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdline = vim_strsave(skipwhite(line));\n\n    return p;\n}\n#endif\n\n/*\n * Compile \"return [expr]\".\n * When \"legacy\" is TRUE evaluate [expr] with legacy syntax\n */\n    char_u *\ncompile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    type_T\t*stack_type;\n\n    if (*p != NUL && *p != '|' && *p != '\\n')\n    {\n\t// For a lambda, \"return expr\" is always used, also when \"expr\" results\n\t// in a void.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type == VAR_VOID\n\t\t&& (cctx->ctx_ufunc->uf_flags & FC_LAMBDA) == 0)\n\t{\n\t    emsg(_(e_returning_value_in_function_without_return_type));\n\t    return NULL;\n\t}\n\tif (legacy)\n\t{\n\t    int save_flags = cmdmod.cmod_flags;\n\n\t    generate_LEGACY_EVAL(cctx, p);\n\t    if (need_type(&t_any, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn NULL;\n\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t    (void)skip_expr(&p, NULL);\n\t    cmdmod.cmod_flags = save_flags;\n\t}\n\telse\n\t{\n\t    // compile return argument into instructions\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // \"check_return_type\" with uf_ret_type set to &t_unknown is used\n\t    // for an inline function without a specified return type.  Set the\n\t    // return type here.\n\t    stack_type = get_type_on_stack(cctx, 0);\n\t    if ((check_return_type && (cctx->ctx_ufunc->uf_ret_type == NULL\n\t\t\t\t|| cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t\t    || (!check_return_type\n\t\t\t\t&& cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t    {\n\t\tcctx->ctx_ufunc->uf_ret_type = stack_type;\n\t    }\n\t    else\n\t    {\n\t\tif (need_type(stack_type, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// \"check_return_type\" cannot be TRUE, only used for a lambda which\n\t// always has an argument.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_VOID\n\t\t&& cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_UNKNOWN)\n\t{\n\t    emsg(_(e_missing_return_value));\n\t    return NULL;\n\t}\n\n\t// No argument, return zero.\n\tgenerate_PUSHNR(cctx, 0);\n    }\n\n    // may need ENDLOOP when inside a :for or :while loop\n    if (compile_find_scope(NULL, NULL, NULL, NULL, cctx) == FAIL)\n\n    // Undo any command modifiers.\n    generate_undo_cmdmods(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_RETURN) == NULL)\n\treturn NULL;\n\n    // \"return val | endif\" is possible\n    return skipwhite(p);\n}\n\n/*\n * Check if the separator for a :global or :substitute command is OK.\n */\n    int\ncheck_global_and_subst(char_u *cmd, char_u *arg)\n{\n    if (arg == cmd + 1 && vim_strchr((char_u *)\":-.\", *arg) != NULL)\n    {\n\tsemsg(_(e_separator_not_supported_str), arg);\n\treturn FAIL;\n    }\n    if (VIM_ISWHITE(cmd[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_separator_str), cmd);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#endif  // defined(FEAT_EVAL)\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (lvp->lv_name != NULL\n\t\t&& STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t\t// If the variable was declared inside a loop set\n\t\t// lvar->lv_loop_idx and lvar->lv_loop_depth.\n\t\tget_loop_var_idx(cctx, idx, lvar);\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\tif (cstack == NULL)\n\t    return NULL;\n\n\t// Not in a function scope, find variable with block ID equal to or\n\t// smaller than the current block id.  Use \"cstack\" to go up the block\n\t// scopes.\n\twhile (sav != NULL)\n\t{\n\t    int idx;\n\n\t    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\t\tif (cstack->cs_block_id[idx] == sav->sav_block_id)\n\t\t    break;\n\t    if (idx >= 0)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * If \"name\" can be found in the current script set it's \"block_id\".\n */\n    void\nupdate_script_var_block_id(char_u *name, int block_id)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    sallvar_T\t    *sav;\n\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (HASHITEM_EMPTY(hi))\n\treturn;\n    sav = HI2SAV(hi);\n    sav->sav_block_id = block_id;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx, cstack) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx, NULL) == OK\n\t    || find_imported(name, len, FALSE) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.  Or commands are being skipped, a declaration may have\n * been skipped then.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    return variable_exists(name, len, cctx);\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(\n\tchar_u\t    *p,\n\tsize_t\t    len,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack,\n\tint\t    is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx, cstack) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, FALSE) != NULL\n\t    || (ufunc = find_func_even_dead(p, 0)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If actual a constant a runtime check makes no sense.  If it's\n    // null_function it is OK.\n    if (actual_is_const && ret == MAYBE && actual == &t_func_unknown)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset,\n\t\t\t\t\t    where.wt_variable, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Set type of variable \"lvar\" to \"type\".  If the variable is a constant then\n * the type gets TTFLAG_CONST.\n */\n    static void\nset_var_type(lvar_T *lvar, type_T *type_arg, cctx_T *cctx)\n{\n    type_T\t*type = type_arg;\n\n    if (lvar->lv_const == ASSIGN_CONST && (type->tt_flags & TTFLAG_CONST) == 0)\n    {\n\tif (type->tt_flags & TTFLAG_STATIC)\n\t    // entry in static_types[] is followed by const type\n\t    type = type + 1;\n\telse\n\t{\n\t    type = copy_type(type, cctx->ctx_type_list);\n\t    type->tt_flags |= TTFLAG_CONST;\n\t}\n    }\n    lvar->lv_type = type;\n}\n\n/*\n * Reserve space for a local variable.\n * \"assign\" can be ASSIGN_VAR for :var, ASSIGN_CONST for :const and\n * ASSIGN_FINAL for :final.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tassign,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = assign;\n    if (type == &t_unknown || type == &t_any)\n\t// type not known yet, may be inferred from RHS\n\tlvar->lv_type = type;\n    else\n\t// may use TTFLAG_CONST\n\tset_var_type(lvar, type, cctx);\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(\n\tint\t    sid,\n\tchar_u\t    *name,\n\tint\t    check_writable,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx, cstack);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n    {\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    hashitem_T *hi;\n\n\t    // A variable exported from an autoload script is in the global\n\t    // variables, we can find it in the all_vars table.\n\t    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2SAV(hi)->sav_var_vals_idx;\n\t}\n\treturn -2;\n    }\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n    static imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Find \"name\" in imported items of the current script.\n * If \"len\" is 0 use any length that works.\n * If \"load\" is TRUE and the script was not loaded yet, load it now.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, int load)\n{\n    imported_T\t    *ret;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n\n    ret = find_imported_in_script(name, len, current_sctx.sc_sid);\n    if (ret != NULL && load && (ret->imp_flags & IMP_FLAGS_AUTOLOAD))\n    {\n\tscid_T\tactual_sid = 0;\n\tint\tsave_emsg_off = emsg_off;\n\n\t// \"emsg_off\" will be set when evaluating an expression silently, but\n\t// we do want to know about errors in a script.  Also because it then\n\t// aborts when an error is encountered.\n\temsg_off = FALSE;\n\n\t// script found before but not loaded yet\n\tret->imp_flags &= ~IMP_FLAGS_AUTOLOAD;\n\t(void)do_source(SCRIPT_ITEM(ret->imp_sid)->sn_name, FALSE,\n\t\t\t\t\t\t       DOSO_NONE, &actual_sid);\n\t// If the script is a symlink it may be sourced with another name, may\n\t// need to adjust the script ID for that.\n\tif (actual_sid != 0)\n\t    ret->imp_sid = actual_sid;\n\n\temsg_off = save_emsg_off;\n    }\n    return ret;\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n    eap->skip = cctx->ctx_skip == SKIP_YES;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t    ASSIGN_CONST, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    // Now the local variable can't be used.\n\t    *lvar->lv_name = '/';  // impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Compile one Vim expression {expr} in string \"p\".\n * \"p\" points to the opening \"{\".\n * Return a pointer to the character after \"}\", NULL for an error.\n */\n    char_u *\ncompile_one_expr_in_str(char_u *p, cctx_T *cctx)\n{\n    char_u\t*block_start;\n    char_u\t*block_end;\n\n    // Skip the opening {.\n    block_start = skipwhite(p + 1);\n    block_end = block_start;\n    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)\n\treturn NULL;\n    block_end = skipwhite(block_end);\n    // The block must be closed by a }.\n    if (*block_end != '}')\n    {\n\tsemsg(_(e_missing_close_curly_str), p);\n\treturn NULL;\n    }\n    if (compile_expr0(&block_start, cctx) == FAIL)\n\treturn NULL;\n    may_generate_2STRING(-1, TRUE, cctx);\n\n    return block_end + 1;\n}\n\n/*\n * Compile a string \"str\" (either containing a literal string or a mix of\n * literal strings and Vim expressions of the form `{expr}`).  This is used\n * when compiling a heredoc assignment to a variable or an interpolated string\n * in a Vim9 def function.  Vim9 instructions are generated to push strings,\n * evaluate expressions, concatenate them and create a list of lines.  When\n * \"evalstr\" is TRUE, Vim expressions in \"str\" are evaluated.\n */\n    int\ncompile_all_expr_in_str(char_u *str, int evalstr, cctx_T *cctx)\n{\n    char_u\t*p = str;\n    char_u\t*val;\n    int\t\tcount = 0;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (!evalstr || *str == NUL)\n    {\n\t// Literal string, possibly empty.\n\tval = *str != NUL ? vim_strsave(str) : NULL;\n\treturn generate_PUSHS(cctx, &val);\n    }\n\n    // Push all the string pieces to the stack, followed by a ISN_CONCAT.\n    while (*p != NUL)\n    {\n\tchar_u\t*lit_start;\n\tint\tescaped_brace = FALSE;\n\n\t// Look for a block start.\n\tlit_start = p;\n\twhile (*p != '{' && *p != '}' && *p != NUL)\n\t    ++p;\n\n\tif (*p != NUL && *p == p[1])\n\t{\n\t    // Escaped brace, unescape and continue.\n\t    // Include the brace in the literal string.\n\t    ++p;\n\t    escaped_brace = TRUE;\n\t}\n\telse if (*p == '}')\n\t{\n\t    semsg(_(e_stray_closing_curly_str), str);\n\t    return FAIL;\n\t}\n\n\t// Append the literal part.\n\tif (p != lit_start)\n\t{\n\t    val = vim_strnsave(lit_start, (size_t)(p - lit_start));\n\t    if (generate_PUSHS(cctx, &val) == FAIL)\n\t\treturn FAIL;\n\t    ++count;\n\t}\n\n\tif (*p == NUL)\n\t    break;\n\n\tif (escaped_brace)\n\t{\n\t    // Skip the second brace.\n\t    ++p;\n\t    continue;\n\t}\n\n\tp = compile_one_expr_in_str(p, cctx);\n\tif (p == NULL)\n\t    return FAIL;\n\t++count;\n    }\n\n    // Small optimization, if there's only a single piece skip the ISN_CONCAT.\n    if (count > 1)\n\treturn generate_CONCAT(cctx, count);\n\n    return OK;\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lvar->lv_from_outer > 0)\n\t\t    generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t lvar->lv_loop_depth, lvar->lv_loop_idx, type);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    }\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(cmdidx_T cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tint assign = cmdidx == CMD_final ? ASSIGN_FINAL\n\t\t\t     : cmdidx == CMD_const ? ASSIGN_CONST : ASSIGN_VAR;\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\tassign, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    is_decl,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, has_cmd, oplen, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const != ASSIGN_VAR\n\t\t\t   && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"varname\" or \"[varname, varname]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n    else\n    {\n\tsp = p;\n\tp = skipwhite(p);\n\top = p;\n\toplen = assignment_len(p, &heredoc);\n\n\tif (var_count > 0 && oplen == 0)\n\t    // can be something like \"[1, 2]->func()\"\n\t    return arg;\n\n\tif (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n\t{\n\t    error_white_both(op, oplen);\n\t    return NULL;\n\t}\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE, TRUE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t    needed_list_len, (int)isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\ttype_T\t*inferred_type = NULL;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\tis_decl, heredoc, var_start > eap->cmd,\n\t\t\t\toplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t    }\n\t\t    if (r == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    type_T *type;\n\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\ttype = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\ttype = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\ttype = &t_any;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ttype = rhs_type;\n\t\t\t\tinferred_type = rhs_type;\n\t\t\t    }\n\t\t\t    set_var_type(lhs.lhs_lvar, type, cctx);\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t\t\tcctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tint r = OK;\n\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tr = generate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n\t\t\tr = generate_PUSHF(cctx, 0.0);\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tr = generate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tr = generate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tr = generate_PUSHFUNC(cctx, NULL, &t_func_void, TRUE);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tr = generate_NEWLIST(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tr = generate_NEWDICT(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tr = generate_PUSHJOB(cctx);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tr = generate_PUSHCHANNEL(cctx);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are always\n\t\t\t// initialized to zero.  But in a \"for\" or \"while\" loop\n\t\t\t// the value may have been changed.\n\t\t\tif (lhs.lhs_dest == dest_local\n\t\t\t\t\t\t   && !inside_loop_scope(cctx))\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    instr_count = instr->ga_len;\n\t\t\t    r = generate_PUSHNR(cctx, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (r == FAIL)\n\t\t    goto theend;\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_CONCAT(cctx, 2) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_any\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\t    else if (inferred_type != NULL\n\t\t    && (inferred_type->tt_type == VAR_DICT\n\t\t\t\t\t|| inferred_type->tt_type == VAR_LIST)\n\t\t    && inferred_type->tt_member != NULL\n\t\t    && inferred_type->tt_member != &t_unknown\n\t\t    && inferred_type->tt_member != &t_any)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, inferred_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    // \"g:var = expr\"\n\t    // \"g:[key] = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// might be \"[var, var] = expr\"\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, NULL, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n#ifdef HAS_MESSAGE_WINDOW\n/*\n * Get a count before a command.  Can only be a number.\n * Returns zero if there is no count.\n * Returns -1 if there is something wrong.\n */\n    static long\nget_cmd_count(char_u *line, exarg_T *eap)\n{\n    char_u *p;\n\n    // skip over colons and white space\n    for (p = line; *p == ':' || VIM_ISWHITE(*p); ++p)\n\t;\n    if (!isdigit(*p))\n    {\n\t// the command must be following\n\tif (p < eap->cmd)\n\t{\n\t    emsg(_(e_invalid_range));\n\t    return -1;\n\t}\n\treturn 0;\n    }\n    return atol((char *)p);\n}\n#endif\n\n/*\n * Get the compilation type that should be used for \"ufunc\".\n * Keep in sync with INSTRUCTIONS().\n */\n    compiletype_T\nget_compile_type(ufunc_T *ufunc)\n{\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (debug_break_level > 0 || may_break_in_function(ufunc))\n\treturn CT_DEBUG;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (!ufunc->uf_profiling && has_profiling(FALSE, ufunc->uf_name, NULL))\n\t    func_do_profile(ufunc);\n\tif (ufunc->uf_profiling)\n\t    return CT_PROFILE;\n    }\n#endif\n    return CT_NONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n\tdfunc->df_defer_var_idx = 0;\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    if ((ufunc->uf_flags & FC_CLOSURE) && outer_cctx == NULL)\n    {\n\tsemsg(_(e_compiling_closure_without_context_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\tea.skip = cctx.ctx_skip == SKIP_YES;\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment, but \"#{\" is an error\n\t    if (vim9_bad_comment(ea.cmd))\n\t\tgoto erret;\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    goto erret;\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * 0z1234->func() should not be confused with a zero line number\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t * \"123->func()\" is a method call\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon\n\t\t    || !(*cmd == '\\''\n\t\t\t|| (cmd[0] == '0' && cmd[1] == 'z')\n\t\t\t|| (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-'))\n\t\t\t|| number_method(cmd))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\tsemsg(_(e_ambiguous_use_of_user_defined_command_str), ea.cmd);\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    // \"eval\" is used for \"val->func()\" and \"var\" for \"var = val\", then\n\t    // \"p\" is equal to \"ea.cmd\" for a valid command.\n\t    if (ea.cmdidx == CMD_eval || ea.cmdidx == CMD_var)\n\t\t;\n\t    else if (cctx.ctx_skip == SKIP_YES)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t    if ((ea.argt & EX_RANGE) == 0 && ea.addr_count > 0)\n\t    {\n\t\temsg(_(e_no_range_allowed));\n\t\tgoto erret;\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t    {\n\t\t\temsg(_(e_invalid_assignment));\n\t\t\tline = NULL;\n\t\t    }\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_defer:\n\t\t    line = compile_defer(p, &cctx);\n\t\t    break;\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    case CMD_echowindow:\n\t\t    {\n\t\t\tlong cmd_count = get_cmd_count(line, &ea);\n\t\t\tif (cmd_count < 0)\n\t\t\t    line = NULL;\n\t\t\telse\n\t\t\t    line = compile_mult_expr(p, ea.cmdidx,\n\t\t\t\t\t\t\t     cmd_count, &cctx);\n\t\t    }\n\t\t    break;\n#endif\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_echoconsole:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_execute:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, 0, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_vim9script:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\temsg(_(e_vim9script_can_only_be_used_in_script));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\n\tif (cctx.ctx_outer_used)\n\t{\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\t    if (outer_cctx != NULL)\n\t\t++outer_cctx->ctx_closure_count;\n\t}\n\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n"], "fixing_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error', 'D')\n  var buf = g:RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xcompdir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      vim9script\n      export def OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xcompdir'\n  writefile(lines, 'XTest_compile_error', 'D')\n\n  var buf = g:RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     g:Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_comment_error()\n  v9.CheckDefFailure(['#{ comment'], 'E1170:')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  v9.CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      function Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      var Object = {}\n      def Object.Method()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      vim9script\n      g:Object = {}\n      function g:Object.Method()\n      endfunction\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        function s:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let s:Object = {}\n      def Define()\n        def Object.Method()\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\n\n  lines =<< trim END\n      let g:Object = {}\n      def Define()\n        function g:Object.Method()\n        endfunction\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1182:')\n  delfunc g:Define\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xnamedir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      vim9script\n      export def NoFunction()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xnamedir'\n  lines =<< trim END\n      call script#Function()\n  END\n  v9.CheckScriptFailure(lines, 'E117:', 1)\n\n  &rtp = save_rtp\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xandir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xandir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xaedir/autoload'\n  mkdir(dir, 'pR')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xaedir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    v9.CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  v9.CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\nenddef\n\ndef s:CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef s:CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  v9.CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  v9.CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  g:ReturnString()->assert_equal('string')\n  g:ReturnNumber()->assert_equal(123)\n  assert_fails('g:ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\n\n  var lines =<< trim END\n      vim9script\n\n      def Msg()\n          echomsg 'in Msg()...'\n      enddef\n\n      def Func()\n        return Msg()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1096:')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif',\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif',\n                   'enddef'], 'E1027:')\n  v9.CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif',\n                   '  return 3',\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  g:ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  v9.CheckScriptFailure(lines, 'E1010:')\n  v9.CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  # This used to fail but now the actual list type is checked, and since it has\n  # an item of type string it can be used as list<string>.\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_return_any_two_types()\n  var lines =<< trim END\n      vim9script\n\n      def G(Fn: func(string): any)\n        g:result = Fn(\"hello\")\n      enddef\n\n      def F(a: number, b: string): any\n        echo b\n        if a > 0\n          return 1\n        else\n          return []\n        endif\n      enddef\n\n      G(function(F, [1]))\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result)\n  unlet g:result\nenddef\n\nfunc s:Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef Test_call_ufunc_failure()\n  var lines =<< trim END\n      vim9script\n      def Tryit()\n        g:Global(1, 2, 3)\n      enddef\n\n      func g:Global(a, b, c)\n        echo a:a a:b a:c\n      endfunc\n\n      defcompile\n\n      func! g:Global(a, b)\n        echo a:a a:b \n      endfunc\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E118: Too many arguments for function: Global')\n  delfunc g:Global\n\n  lines =<< trim END\n      vim9script\n\n      g:Ref = function('len')\n      def Tryit()\n        g:Ref('x')\n      enddef\n\n      defcompile\n\n      g:Ref = function('add')\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E119: Not enough arguments for function: add')\n  unlet g:Ref\nenddef\n\ndef s:MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  v9.CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef s:MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  g:MyDefaultArgs()->assert_equal('string')\n  g:MyDefaultArgs(v:none)->assert_equal('string')\n  g:MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('g:MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  v9.CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  v9.CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  v9.CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  v9.CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  v9.CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  v9.CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  v9.CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  v9.CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def _Inner()\n          echo 'bad'\n        enddef\n        _Inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:inner()\n          echo 'bad'\n        enddef\n        g:inner()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def g:_Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  lines =<< trim END\n      vim9script\n      def _Func()\n        echo 'bad'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1267:')\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # nested function with recursive call\n  lines =<< trim END\n      vim9script\n\n      def MyFunc(): number\n        def Fib(n: number): number\n          if n < 2\n            return 1\n          endif\n          return Fib(n - 2) + Fib(n - 1)\n        enddef\n\n        return Fib(5)\n      enddef\n\n      assert_equal(8, MyFunc())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_nested_function_fails()\n  var lines =<< trim END\n      def T()\n        def Func(g: string):string\n        enddef\n        Func()\n      enddef\n      silent! defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  v9.CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  v9.CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_function_not_found()\n  var lines =<< trim END\n      g:Ref = 123\n      call g:Ref()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E117:', 'E1085:'], 2)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      Funcy()\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  v9.CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is not found with g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n  END\n  v9.CheckScriptFailure(lines, 'E117:')\n  delfunc g:Func\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', g:Func())\n      delfunc g:Func\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # This does not shadow \"i\" which is visible only inside the for loop\n  lines =<< trim END\n      vim9script\n\n      def Foo(i: number)\n        echo i\n      enddef\n\n      for i in range(3)\n        # Foo() is compiled here\n        Foo(i)\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  v9.CheckDefFailure(['g:TakesOneArg()'], 'E119:')\n  v9.CheckDefFailure(['g:TakesOneArg(11, 22)'], 'E118:')\n  v9.CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  v9.CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  # argument name declared earlier is found when declaring a function\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # same, inside the same block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # variable in other block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n    endif\n    def FuncOne(name: string)\n      echo name\n    enddef\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # with another variable in another block\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      var name = 'peter'\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptFailure(lines, 'E1168:')\n\n  # only variable in another block is OK\n  lines =<< trim END\n    vim9script\n    if true\n      var name = 'piet'\n      # define a function so that the variable isn't cleared\n      def GetItem(): string\n        return item\n      enddef\n    endif\n    if true\n      def FuncOne(name: string)\n        echo name\n      enddef\n    endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # argument name declared later is only found when compiling\n  lines =<< trim END\n    vim9script\n    def FuncOne(name: string)\n      echo nr\n    enddef\n    var name = 'piet'\n  END\n  v9.CheckScriptSuccess(lines)\n  v9.CheckScriptFailure(lines + ['defcompile'], 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript', 'D')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  v9.CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  v9.CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  v9.CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  v9.CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  v9.CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo g:FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo g:FilterWithCond('foo', (v) => v .. '^b')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  v9.CheckDefSuccess([\n        'var x: any = \"aaa\"',\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_lambda_invalid_block()\n  var lines =<< trim END\n      timer_start(0, (_) => { # echo\n          echo 'yes'\n        })\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      timer_start(0, (_) => { \" echo\n          echo 'yes'\n        })\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E488: Trailing characters: \" echo')\n\n  lines =<< trim END\n      timer_start(0, (_) => { | echo\n          echo 'yes'\n        })\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E488: Trailing characters: | echo')\nenddef\n\ndef Test_lambda_with_following_cmd()\n  var lines =<< trim END\n      set ts=2\n      var Lambda = () => {\n          set ts=4\n        } | set ts=3\n      assert_equal(3, &ts)\n      Lambda()\n      assert_equal(4, &ts)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  set ts=8\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(F: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(F: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func g:Getit()\n        return 'it'\n      endfunc\n      var Fn = g:Getit\n      assert_equal('it', Fn())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_define_lambda_in_execute()\n  var lines =<< trim [CODE]\n      vim9script\n\n      def BuildFuncMultiLine(): func\n          var x =<< trim END\n              g:SomeRandomFunc = (d: dict<any>) => {\n                  return d.k1 + d.k2\n              }\n          END\n          execute(x)\n          return g:SomeRandomFunc\n      enddef\n      var ResultPlus = BuildFuncMultiLine()\n      assert_equal(7, ResultPlus({k1: 3, k2: 4}))\n  [CODE]\n  v9.CheckScriptSuccess(lines)\n  unlet g:SomeRandomFunc\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('g:MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  g:MyDefVarargs('one')->assert_equal('one,foo')\n  g:MyDefVarargs('one', 'two')->assert_equal('one,two')\n  g:MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  v9.CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = g:FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = g:FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  v9.CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  v9.CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = g:FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  v9.CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  g:MyVarargsOnly()->assert_equal('')\n  g:MyVarargsOnly('one')->assert_equal('one')\n  g:MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  v9.CheckDefFailure(['g:MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  v9.CheckDefFailure(['g:MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  var lines =<< trim END\n      def Func(x: number)\n        var x = 234\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1006:')\n\n  lines =<< trim END\n      def Func(Ref: number)\n        def Ref()\n        enddef\n      enddef\n  END\n  v9.CheckDefFailure(lines, 'E1073:')\nenddef\n\ndef s:DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef s:ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  v9.CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef s:WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function('s:func')\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = function(s:func)\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    function s:func(num)\n      return a:num * 2\n    endfunction\n\n    def s:CallFuncref()\n      var Funcref = s:func\n      Funcref(3)->assert_equal(6)\n    enddef\n    call s:CallFuncref()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('g:FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\n\n  lines =<< trim END\n      vim9script\n      def FirstFunction()\n        func SecondFunction()\n        endfunc|BBBB\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\nenddef\n\ndef Test_error_in_function_args()\n  var lines =<< trim END\n      def FirstFunction()\n        def SecondFunction(J  =\n        # Nois\n        # one\n         \n         enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_return_type_wrong()\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  v9.CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008: Missing <type> after list')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008: Missing <type> after dict')\n  delfunc! g:Func\n  v9.CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  v9.CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  v9.CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type> after list')\n  v9.CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  v9.CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  v9.CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  v9.CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  v9.CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim', 'D')\n  source Xcall.vim\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim', 'D')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  v9.CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      g:GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc', 'D')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  v9.CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func', 'D')\n  so XVim9Func\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef s:FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef s:FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = g:FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = g:FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = g:FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in repeat(0z01, 3)->blob2list()\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = g:FuncNoArgNoRet\n  RefVoid = g:FuncOneArgNoRet\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  v9.CheckDefFailure(['var RefVoid: func: void', 'RefVoid = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = g:FuncNoArgRetNumber\n  RefAny = g:FuncNoArgRetString\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  v9.CheckDefFailure(['var RefAny: func(): any', 'RefAny = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = g:FuncNoArgRetNumber\n  RefNr = g:FuncOneArgRetNumber\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  v9.CheckDefFailure(['var RefNr: func: number', 'RefNr = g:FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = g:FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  v9.CheckDefFailure(['var RefStr: func: string', 'RefStr = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  v9.CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  v9.CheckDefFailure(['var Ref1: func()', 'Ref1 = g:FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  v9.CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  v9.CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = g:FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  v9.CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  v9.CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  v9.CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  v9.CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = g:FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  v9.CheckDefFailure(['var str: string', 'str = g:FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef s:MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call s:MultiLine('text')->assert_equal('text1234')\n  call s:MultiLine('text', 777)->assert_equal('text777')\n  call s:MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call s:MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef', 'D')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\nenddef\n\ndef Test_deleted_function()\n  v9.CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  v9.CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef s:RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef s:MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef s:MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef s:ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef s:MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef s:MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc s:GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  v9.CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Run_Test_closure_in_for_loop_fails()\n  var lines =<< trim END\n    vim9script\n    redraw\n    for n in [0]\n        # time should be enough for startup to finish\n        timer_start(200, (_) => {\n            echo n\n        })\n    endfor\n  END\n  writefile(lines, 'XTest_closure_fails', 'D')\n\n  # Check that an error shows\n  var buf = g:RunVimInTerminal('-S XTest_closure_fails', {rows: 6, wait_for_ruler: 0})\n  g:VerifyScreenDump(buf, 'Test_vim9_closure_fails', {wait: 3000})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\nfunc Test_closure_in_for_loop_fails()\n  CheckScreendump\n  call Run_Test_closure_in_for_loop_fails()\nendfunc\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  v9.CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def Func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], g:Shadowed())\nenddef\n\ndef Test_compiling_referenced_func_no_shadow()\n  var lines =<< trim END\n      vim9script\n\n      def InitializeReply(lspserver: dict<any>)\n      enddef\n\n      def ProcessReply(lspserver: dict<any>)\n        var lsp_reply_handlers: dict<func> =\n          { 'initialize': InitializeReply }\n        lsp_reply_handlers['initialize'](lspserver)\n      enddef\n\n      call ProcessReply({})\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    v9.CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo', 'D')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = g:RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  g:VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc s:UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef s:TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'pR')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  v9.CheckScriptFailure(lines, 'E1031:')\nenddef\n\ndef Test_partial_double_nested()\n  var idx = 123\n  var Get = () => idx\n  var Ref = function(Get, [])\n  var RefRef = function(Ref, [])\n  assert_equal(123, RefRef())\nenddef\n\ndef Test_partial_null_function()\n  var lines =<< trim END\n      var d: dict<func> = {f: null_function}\n      var Ref = d.f\n      assert_equal('func(...): unknown', typename(Ref))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  v9.CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  g:StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    g:StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset', 'D')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname, 'D')\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=g:Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error', 'D')\n\n  var buf = g:RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  g:WaitForAssert(() => assert_match('E684: List index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !g:RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_nested_closure_funcref()\n  var lines =<< trim END\n      vim9script\n      def Func()\n          var n: number\n          def Nested()\n              ++n\n          enddef\n          Nested()\n          g:result_one = n\n          var Ref = function(Nested)\n          Ref()\n          g:result_two = n\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:result_one)\n  assert_equal(2, g:result_two)\n  unlet g:result_one g:result_two\nenddef\n\ndef Test_nested_closure_in_dict()\n  var lines =<< trim END\n      vim9script\n      def Func(): dict<any>\n        var n: number\n        def Inc(): number\n          ++n\n          return n\n        enddef\n        return {inc: function(Inc)}\n      enddef\n      disas Func\n      var d = Func()\n      assert_equal(1, d.inc())\n      assert_equal(2, d.inc())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_script_local_other_script()\n  var lines =<< trim END\n      function LegacyJob()\n        let FuncRef = function('s:close_cb')\n      endfunction\n      function s:close_cb(...)\n      endfunction\n  END\n  lines->writefile('Xlegacy.vim', 'D')\n  source Xlegacy.vim\n  g:LegacyJob()\n  g:LegacyJob()\n  g:LegacyJob()\n\n  delfunc g:LegacyJob\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(Fg: func): dict<func>\n        return {f: Fg}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  v9.CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  v9.CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\n\n  v9.CheckScriptFailure(lines + ['def SomeFunc(ff: func)', 'enddef'], 'E704:')\nenddef\n\ndef Test_call_func_with_null()\n  var lines =<< trim END\n      def Fstring(v: string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring(null_string)\n      def Fblob(v: blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob(null_blob)\n      def Flist(v: list<number>)\n        assert_equal(null_list, v)\n      enddef\n      Flist(null_list)\n      def Fdict(v: dict<number>)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict(null_dict)\n      def Ffunc(Fv: func(number): number)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc(null_function)\n      if has('channel')\n        def Fchannel(v: channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel(null_channel)\n        def Fjob(v: job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob(null_job)\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_default_argument()\n  var lines =<< trim END\n      def Fstring(v: string = null_string)\n        assert_equal(null_string, v)\n      enddef\n      Fstring()\n      def Fblob(v: blob = null_blob)\n        assert_equal(null_blob, v)\n      enddef\n      Fblob()\n      def Flist(v: list<number> = null_list)\n        assert_equal(null_list, v)\n      enddef\n      Flist()\n      def Fdict(v: dict<number> = null_dict)\n        assert_equal(null_dict, v)\n      enddef\n      Fdict()\n      def Ffunc(Fv: func(number): number = null_function)\n        assert_equal(null_function, Fv)\n      enddef\n      Ffunc()\n      if has('channel')\n        def Fchannel(v: channel = null_channel)\n          assert_equal(null_channel, v)\n        enddef\n        Fchannel()\n        def Fjob(v: job = null_job)\n          assert_equal(null_job, v)\n        enddef\n        Fjob()\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_null_return()\n  var lines =<< trim END\n      def Fstring(): string\n        return null_string\n      enddef\n      assert_equal(null_string, Fstring())\n      def Fblob(): blob\n        return null_blob\n      enddef\n      assert_equal(null_blob, Fblob())\n      def Flist(): list<number>\n        return null_list\n      enddef\n      assert_equal(null_list, Flist())\n      def Fdict(): dict<number>\n        return null_dict\n      enddef\n      assert_equal(null_dict, Fdict())\n      def Ffunc(): func(number): number\n        return null_function\n      enddef\n      assert_equal(null_function, Ffunc())\n      if has('channel')\n        def Fchannel(): channel\n          return null_channel\n        enddef\n        assert_equal(null_channel, Fchannel())\n        def Fjob(): job\n          return null_job\n        enddef\n        assert_equal(null_job, Fjob())\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  # \"any\" could be \"dict<any>\", thus OK\n  lines[2] = 'var l: list<any>'\n  v9.CheckScriptSuccess(lines)\n  lines[2] = 'var l: list<any> = []'\n  v9.CheckScriptSuccess(lines)\n\n  lines[2] = 'var l: list<any> = [11]'\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  v9.CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176:', 'E1106: 2 arguments too many'], 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E176', 'E1106: One argument too many'], 1)\n\n  lines =<< trim END\n      vim9script\n      def OneArgument(arg: string)\n        echo arg\n      enddef\n      var Ref = OneArgument\n      Ref('a', 'b')\n  END\n  v9.CheckScriptFailure(lines, 'E118:')\nenddef\n\ndef Test_funcref_with_base()\n  var lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      Ref('a', 12)\n      'b'->Ref(34)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      'a'->Ref('b')\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string', 6)\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(str: string, nr: number)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref(456)\n  END\n  v9.CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  lines =<< trim END\n      vim9script\n      def TwoArguments(nr: number, str: string)\n        echo str nr\n      enddef\n      var Ref = TwoArguments\n      123->Ref('b')\n      def AndNowCompiled()\n        456->Ref('x')\n      enddef\n      AndNowCompiled()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc s:CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\ndef Test_numbered_function_call()\n  var lines =<< trim END\n      let s:legacyscript = {}\n      func s:legacyscript.Helper() abort\n        return \"Success\"\n      endfunc\n      let g:legacyscript = deepcopy(s:legacyscript)\n\n      let g:legacy_result = eval(\"g:legacyscript.Helper()\")\n      vim9cmd g:vim9_result = eval(\"g:legacyscript.Helper()\")\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('Success', g:legacy_result)\n  assert_equal('Success', g:vim9_result)\n\n  unlet g:legacy_result\n  unlet g:vim9_result\nenddef\n\ndef Test_go_beyond_end_of_cmd()\n  # this was reading the byte after the end of the line\n  var lines =<< trim END\n    def F()\n      cal\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E476:')\nenddef\n\n\" Test for memory allocation failure when defining a new lambda\nfunc Test_lambda_allocation_failure()\n  new\n  let lines =<< trim END\n    vim9script\n    g:Xlambda = (x): number => {\n        return x + 1\n      }\n  END\n  call setline(1, lines)\n  call test_alloc_fail(GetAllocId('get_func'), 0, 0)\n  call assert_fails('source', 'E342:')\n  call assert_false(exists('g:Xlambda'))\n  bw!\nendfunc\n\ndef Test_multiple_funcref()\n  # This was using a NULL pointer\n  var lines =<< trim END\n      vim9script\n      def A(F: func, ...args: list<any>): func\n          return funcref(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # slightly different case\n  lines =<< trim END\n      vim9script\n\n      def A(F: func, ...args: list<any>): any\n          return call(F, args)\n      enddef\n\n      def B(F: func): func\n          return funcref(A, [F])\n      enddef\n\n      def Test(n: number)\n      enddef\n\n      const X = B(Test)\n      X(1)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cexpr_errmsg_line_number()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var qfl = {}\n        cexpr qfl\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E777', 2)\nenddef\n\ndef AddDefer(s: string)\n  g:deferred->extend([s])\nenddef\n\ndef DeferTwo()\n  g:deferred->extend(['in Two'])\n  for n in range(3)\n    defer g:AddDefer('two' .. n)\n  endfor\n  g:deferred->extend(['end Two'])\nenddef\n\ndef DeferOne()\n  g:deferred->extend(['in One'])\n  defer g:AddDefer('one')\n  g:DeferTwo()\n  g:deferred->extend(['end One'])\n\n  writefile(['text'], 'XdeferFile')\n  defer delete('XdeferFile')\nenddef\n\ndef Test_defer()\n  g:deferred = []\n  g:DeferOne()\n  assert_equal(['in One', 'in Two', 'end Two', 'two2', 'two1', 'two0', 'end One', 'one'], g:deferred)\n  unlet g:deferred\n  assert_equal('', glob('XdeferFile'))\nenddef\n\ndef Test_invalid_redir()\n  var lines =<< trim END\n      def Tone()\n        if 1\n          redi =>@\u00000\n          redi END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E354:')\n  delfunc g:Tone\n\n  # this was reading past the end of the line\n  lines =<< trim END\n      def Ttwo()\n        if 0\n          redi =>@\u00000\n          redi END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E354:')\n  delfunc g:Ttwo\nenddef\n\n\" The following messes up syntax highlight, keep near the end.\nif has('python3')\n  def Test_python3_command()\n    py3 import vim\n    py3 vim.command(\"g:done = 'yes'\")\n    assert_equal('yes', g:done)\n    unlet g:done\n  enddef\n\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\n\n  def Test_lua_heredoc_fails()\n    var lines = [\n      'vim9script',\n      'def ExeLua()',\n        'lua << trim EOLUA',\n            \"x = vim.eval('g:nodict')\",\n        'EOLUA',\n      'enddef',\n      'ExeLua()',\n      ]\n    v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:nodict')\n  enddef\nendif\n\nif has('perl')\n  def Test_perl_heredoc_nested()\n    var lines =<< trim END\n        vim9script\n        def F(): string\n            def G(): string\n                perl << EOF\n        EOF\n                return 'done'\n            enddef\n            return G()\n        enddef\n        assert_equal('done', F())\n    END\n    v9.CheckScriptSuccess(lines)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\nsource shared.vim\n\ndef Test_vim9script_feature()\n  # example from the help, here the feature is always present\n  var lines =<< trim END\n      \" old style comment\n      if !has('vim9script')\n        \" legacy commands would go here\n        finish\n      endif\n      vim9script\n      # Vim9 script commands go here\n      g:didit = true\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(true, g:didit)\n  unlet g:didit\nenddef\n\ndef Test_range_only()\n  new\n  setline(1, ['blah', 'Blah'])\n  :/Blah/\n  assert_equal(2, getcurpos()[1])\n  bwipe!\n\n  # without range commands use current line\n  new\n  setline(1, ['one', 'two', 'three'])\n  :2\n  print\n  assert_equal('two', g:Screenline(&lines))\n  :3\n  list\n  assert_equal('three$', g:Screenline(&lines))\n\n  # missing command does not print the line\n  var lines =<< trim END\n    vim9script\n    :1|\n    assert_equal('three$', g:Screenline(&lines))\n    :|\n    assert_equal('three$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  bwipe!\n\n  lines =<< trim END\n      set cpo+=-\n      :1,999\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E16:', 2)\n  set cpo&vim\n\n  v9.CheckDefExecAndScriptFailure([\":'x\"], 'E20:', 1)\n\n  # won't generate anything\n  if false\n    :123\n  endif\nenddef\n\ndef Test_invalid_range()\n  var lines =<< trim END\n      :123 eval 1 + 2\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 if true\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 echo 'yes'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 cd there\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\nenddef\n\nlet g:alist = [7]\nlet g:astring = 'text'\nlet g:anumber = 123\n\ndef Test_delfunction()\n  # Check function is defined in script namespace\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func CheckMe()',\n      '  return 123',\n      'endfunc',\n      'func DoTest()',\n      '  call assert_equal(123, s:CheckMe())',\n      'endfunc',\n      'DoTest()',\n      ])\n\n  # Check function in script namespace cannot be deleted\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe1()',\n      'endfunc',\n      'delfunction DeleteMe1',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe2()',\n      'endfunc',\n      'def DoThat()',\n      '  delfunction DeleteMe2',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe3()',\n      'enddef',\n      'delfunction DeleteMe3',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe4()',\n      'enddef',\n      'def DoThat()',\n      '  delfunction DeleteMe4',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n\n  # Check that global :def function can be replaced and deleted\n  var lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global function can be replaced by a :def function and deleted\n  lines =<< trim END\n      vim9script\n      func g:Global()\n        return \"yes\"\n      endfunc\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global :def function can be replaced by a function and deleted\n  lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      func! g:Global()\n        return \"no\"\n      endfunc\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_wrong_type()\n  v9.CheckDefFailure(['var name: list<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: list<list<nothing>>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<dict<nothing>>'], 'E1010:')\n\n  v9.CheckDefFailure(['var name: dict<number'], 'E1009:')\n  v9.CheckDefFailure(['var name: dict<list<number>'], 'E1009:')\n\n  v9.CheckDefFailure(['var name: ally'], 'E1010:')\n  v9.CheckDefFailure(['var name: bram'], 'E1010:')\n  v9.CheckDefFailure(['var name: cathy'], 'E1010:')\n  v9.CheckDefFailure(['var name: dom'], 'E1010:')\n  v9.CheckDefFailure(['var name: freddy'], 'E1010:')\n  v9.CheckDefFailure(['var name: john'], 'E1010:')\n  v9.CheckDefFailure(['var name: larry'], 'E1010:')\n  v9.CheckDefFailure(['var name: ned'], 'E1010:')\n  v9.CheckDefFailure(['var name: pam'], 'E1010:')\n  v9.CheckDefFailure(['var name: sam'], 'E1010:')\n  v9.CheckDefFailure(['var name: vim'], 'E1010:')\n\n  v9.CheckDefFailure(['var Ref: number', 'Ref()'], 'E1085:')\n  v9.CheckDefFailure(['var Ref: string', 'var res = Ref()'], 'E1085:')\nenddef\n\ndef Test_script_namespace()\n  # defining a function or variable with s: is not allowed\n  var lines =<< trim END\n      vim9script\n      def s:Function()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  for decl in ['var', 'const', 'final']\n    lines =<< trim END\n        vim9script\n        var s:var = 'var'\n    END\n    v9.CheckScriptFailure([\n        'vim9script',\n        decl .. ' s:var = \"var\"',\n        ], 'E1268:')\n  endfor\n\n  # Calling a function or using a variable with s: is not allowed at script\n  # level\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      call s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      var var = 'var'\n      echo s:var\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\nenddef\n\ndef Test_script_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var dict: dict<string>\n      dict['a'] = ['x']\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got list<string>', 3)\nenddef\n\ndef Test_const()\n  v9.CheckDefFailure(['final name = 234', 'name = 99'], 'E1018:')\n  v9.CheckDefFailure(['final one = 234', 'var one = 99'], 'E1017:')\n  v9.CheckDefFailure(['final list = [1, 2]', 'var list = [3, 4]'], 'E1017:')\n  v9.CheckDefFailure(['final two'], 'E1125:')\n  v9.CheckDefFailure(['final &option'], 'E996:')\n\n  var lines =<< trim END\n    final list = [1, 2, 3]\n    list[0] = 4\n    list->assert_equal([4, 2, 3])\n    const other = [5, 6, 7]\n    other->assert_equal([5, 6, 7])\n\n    var varlist = [7, 8]\n    const constlist = [1, varlist, 3]\n    varlist[0] = 77\n    constlist[1][1] = 88\n    var cl = constlist[1]\n    cl[1] = 88\n    constlist->assert_equal([1, [77, 88], 3])\n\n    var vardict = {five: 5, six: 6}\n    const constdict = {one: 1, two: vardict, three: 3}\n    vardict['five'] = 55\n    constdict['two']['six'] = 66\n    var cd = constdict['two']\n    cd['six'] = 66\n    constdict->assert_equal({one: 1, two: {five: 55, six: 66}, three: 3})\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # \"any\" type with const flag is recognized as \"any\"\n  lines =<< trim END\n      const dict: dict<any> = {foo: {bar: 42}}\n      const foo = dict.foo\n      assert_equal(v:t_number, type(foo.bar))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also when used as a builtin function argument\n  lines =<< trim END\n      vim9script\n\n      def SorterFunc(lhs: dict<string>, rhs: dict<string>): number\n        return lhs.name <# rhs.name ? -1 : 1\n      enddef\n\n      def Run(): void\n        var list =  [{name: \"3\"}, {name: \"2\"}]\n        const Sorter = get({}, \"unknown\", SorterFunc)\n        sort(list, Sorter)\n        assert_equal([{name: \"2\"}, {name: \"3\"}], list)\n      enddef\n\n      Run()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_const_bang()\n  var lines =<< trim END\n      const var = 234\n      var = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1018:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E46:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[0] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1119:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[3] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1118:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E684:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"one\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1121:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"three\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1120:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\nenddef\n\ndef Test_range_no_colon()\n  v9.CheckDefFailure(['%s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['+ s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['- s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['. s/a/b/'], 'E1050:')\nenddef\n\n\ndef Test_block()\n  var outer = 1\n  {\n    var inner = 2\n    assert_equal(1, outer)\n    assert_equal(2, inner)\n  }\n  assert_equal(1, outer)\n\n  {|echo 'yes'|}\nenddef\n\ndef Test_block_failure()\n  v9.CheckDefFailure(['{', 'var inner = 1', '}', 'echo inner'], 'E1001:')\n  v9.CheckDefFailure(['}'], 'E1025:')\n  v9.CheckDefFailure(['{', 'echo 1'], 'E1026:')\nenddef\n\ndef Test_block_local_vars()\n  var lines =<< trim END\n      vim9script\n      v:testing = 1\n      if true\n        var text = ['hello']\n        def SayHello(): list<string>\n          return text\n        enddef\n        def SetText(v: string)\n          text = [v]\n        enddef\n      endif\n\n      if true\n        var text = ['again']\n        def SayAgain(): list<string>\n          return text\n        enddef\n      endif\n\n      # test that the \"text\" variables are not cleaned up\n      test_garbagecollect_now()\n\n      defcompile\n\n      assert_equal(['hello'], SayHello())\n      assert_equal(['again'], SayAgain())\n\n      SetText('foobar')\n      assert_equal(['foobar'], SayHello())\n\n      call writefile(['ok'], 'Xdidit')\n      qall!\n  END\n\n  # need to execute this with a separate Vim instance to avoid the current\n  # context gets garbage collected.\n  writefile(lines, 'Xscript', 'D')\n  g:RunVim([], [], '-S Xscript')\n  assert_equal(['ok'], readfile('Xdidit'))\n\n  delete('Xdidit')\nenddef\n\ndef Test_block_local_vars_with_func()\n  var lines =<< trim END\n      vim9script\n      if true\n        var foo = 'foo'\n        if true\n          var bar = 'bar'\n          def Func(): list<string>\n            return [foo, bar]\n          enddef\n        endif\n      endif\n      # function is compiled here, after blocks have finished, can still access\n      # \"foo\" and \"bar\"\n      assert_equal(['foo', 'bar'], Func())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\n\" legacy func for command that's defined later\nfunc s:InvokeSomeCommand()\n  SomeCommand\nendfunc\n\ndef Test_autocommand_block()\n  com SomeCommand {\n      g:someVar = 'some'\n    }\n  InvokeSomeCommand()\n  assert_equal('some', g:someVar)\n\n  delcommand SomeCommand\n  unlet g:someVar\nenddef\n\ndef Test_command_block()\n  au BufNew *.xml {\n      g:otherVar = 'other'\n    }\n  split other.xml\n  assert_equal('other', g:otherVar)\n\n  bwipe!\n  au! BufNew *.xml\n  unlet g:otherVar\nenddef\n\nfunc g:NoSuchFunc()\n  echo 'none'\nendfunc\n\ndef Test_try_catch_throw()\n  var l = []\n  try # comment\n    add(l, '1')\n    throw 'wrong'\n    add(l, '2')\n  catch # comment\n    add(l, v:exception)\n  finally # comment\n    add(l, '3')\n  endtry # comment\n  assert_equal(['1', 'wrong', '3'], l)\n\n  l = []\n  try\n    try\n      add(l, '1')\n      throw 'wrong'\n      add(l, '2')\n    catch /right/\n      add(l, v:exception)\n    endtry\n  catch /wrong/\n    add(l, 'caught')\n  finally\n    add(l, 'finally')\n  endtry\n  assert_equal(['1', 'caught', 'finally'], l)\n\n  var n: number\n  try\n    n = l[3]\n  catch /E684:/\n    n = 99\n  endtry\n  assert_equal(99, n)\n\n  var done = 'no'\n  if 0\n    try | catch | endtry\n  else\n    done = 'yes'\n  endif\n  assert_equal('yes', done)\n\n  done = 'no'\n  if 1\n    done = 'yes'\n  else\n    try | catch | endtry\n    done = 'never'\n  endif\n  assert_equal('yes', done)\n\n  if 1\n  else\n    try | catch /pat/ | endtry\n    try | catch /pat/ \n    endtry\n    try \n    catch /pat/ | endtry\n    try \n    catch /pat/ \n    endtry\n  endif\n\n  try\n    # string slice returns a string, not a number\n    n = g:astring[3]\n  catch /E1012:/\n    n = 77\n  endtry\n  assert_equal(77, n)\n\n  try\n    n = l[g:astring]\n  catch /E1012:/\n    n = 88\n  endtry\n  assert_equal(88, n)\n\n  try\n    n = s:does_not_exist\n  catch /E121:/\n    n = 111\n  endtry\n  assert_equal(111, n)\n\n  try\n    n = g:does_not_exist\n  catch /E121:/\n    n = 121\n  endtry\n  assert_equal(121, n)\n\n  var d = {one: 1}\n  try\n    n = d[g:astring]\n  catch /E716:/\n    n = 222\n  endtry\n  assert_equal(222, n)\n\n  try\n    n = -g:astring\n  catch /E1012:/\n    n = 233\n  endtry\n  assert_equal(233, n)\n\n  try\n    n = +g:astring\n  catch /E1012:/\n    n = 244\n  endtry\n  assert_equal(244, n)\n\n  try\n    n = +g:alist\n  catch /E1012:/\n    n = 255\n  endtry\n  assert_equal(255, n)\n\n  var nd: dict<any>\n  try\n    nd = {[g:alist]: 1}\n  catch /E1105:/\n    n = 266\n  endtry\n  assert_equal(266, n)\n\n  l = [1, 2, 3] \n  try\n    [n] = l\n  catch /E1093:/\n    n = 277\n  endtry\n  assert_equal(277, n)\n\n  try\n    &ts = g:astring\n  catch /E1012:/\n    n = 288\n  endtry\n  assert_equal(288, n)\n\n  try\n    &backspace = 'asdf'\n  catch /E474:/\n    n = 299\n  endtry\n  assert_equal(299, n)\n\n  l = [1]\n  try\n    l[3] = 3\n  catch /E684:/\n    n = 300\n  endtry\n  assert_equal(300, n)\n\n  try\n    unlet g:does_not_exist\n  catch /E108:/\n    n = 322\n  endtry\n  assert_equal(322, n)\n\n  try\n    d = {text: 1, [g:astring]: 2}\n  catch /E721:/\n    n = 333\n  endtry\n  assert_equal(333, n)\n\n  try\n    l = g:DeletedFunc()\n  catch /E933:/\n    n = 344\n  endtry\n  assert_equal(344, n)\n\n  try\n    echo range(1, 2, 0)\n  catch /E726:/\n    n = 355\n  endtry\n  assert_equal(355, n)\n\n  var P = function('g:NoSuchFunc')\n  delfunc g:NoSuchFunc\n  try\n    echo P()\n  catch /E117:/\n    n = 366\n  endtry\n  assert_equal(366, n)\n\n  try\n    echo g:NoSuchFunc()\n  catch /E117:/\n    n = 377\n  endtry\n  assert_equal(377, n)\n\n  try\n    echo g:alist + 4\n  catch /E745:/\n    n = 388\n  endtry\n  assert_equal(388, n)\n\n  try\n    echo 4 + g:alist\n  catch /E745:/\n    n = 399\n  endtry\n  assert_equal(399, n)\n\n  try\n    echo g:alist.member\n  catch /E715:/\n    n = 400\n  endtry\n  assert_equal(400, n)\n\n  try\n    echo d.member\n  catch /E716:/\n    n = 411\n  endtry\n  assert_equal(411, n)\n\n  var counter = 0\n  for i in range(4)\n    try\n      eval [][0]\n    catch\n    endtry\n    counter += 1\n  endfor\n  assert_equal(4, counter)\n\n  # no requirement for spaces before |\n  try|echo 0|catch|endtry\n\n  # return in try with finally\n  def ReturnInTry(): number\n    var ret = 4\n    try\n      return ret\n    catch /this/\n      return -1\n    catch /that/\n      return -1\n    finally\n      # changing ret has no effect\n      ret = 7\n    endtry\n    return -2\n  enddef\n  assert_equal(4, ReturnInTry())\n\n  # return in catch with finally\n  def ReturnInCatch(): number\n    var ret = 5\n    try\n      throw 'getout'\n      return -1\n    catch /getout/\n      # ret is evaluated here\n      return ret\n    finally\n      # changing ret later has no effect\n      ret = -3\n    endtry\n    return -2\n  enddef\n  assert_equal(5, ReturnInCatch())\n\n  # return in finally after empty catch\n  def ReturnInFinally(): number\n    try\n    finally\n      return 6\n    endtry\n  enddef\n  assert_equal(6, ReturnInFinally())\n\n  var lines =<< trim END\n      vim9script\n      try\n        acos('0.5')\n          ->setline(1)\n      catch\n        g:caught = v:exception\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_match('E1219: Float or Number required for argument 1', g:caught)\n  unlet g:caught\n\n  # missing catch and/or finally\n  lines =<< trim END\n      vim9script\n      try\n        echo 'something'\n      endtry\n  END\n  v9.CheckScriptFailure(lines, 'E1032:')\n\n  # skipping try-finally-endtry when try-finally-endtry is used in another block\n  lines =<< trim END\n      if v:true\n        try\n        finally\n        endtry\n      else\n        try\n        finally\n        endtry\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_try_var_decl()\n  var lines =<< trim END\n      vim9script\n      try\n        var in_try = 1\n        assert_equal(1, get(s:, 'in_try', -1))\n        throw \"getout\"\n      catch\n        var in_catch = 2\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(2, get(s:, 'in_catch', -1))\n      finally\n        var in_finally = 3\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(-1, get(s:, 'in_catch', -1))\n        assert_equal(3, get(s:, 'in_finally', -1))\n      endtry\n      assert_equal(-1, get(s:, 'in_try', -1))\n      assert_equal(-1, get(s:, 'in_catch', -1))\n      assert_equal(-1, get(s:, 'in_finally', -1))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_try_ends_in_return()\n  var lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n        echo 'notreached'\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1095:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch /x/\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1027:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          echo 'foo'\n        catch\n          echo 'caught'\n        finally\n          return 'done'\n        endtry\n      enddef\n      assert_equal('done', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\nenddef\n\ndef Test_try_in_catch()\n  var lines =<< trim END\n      vim9script\n      var seq = []\n      def DoIt()\n        try\n          seq->add('throw 1')\n          eval [][0]\n          seq->add('notreached')\n        catch\n          seq->add('catch')\n          try\n            seq->add('throw 2')\n            eval [][0]\n            seq->add('notreached')\n          catch /nothing/\n            seq->add('notreached')\n          endtry\n          seq->add('done')\n        endtry\n      enddef\n      DoIt()\n      assert_equal(['throw 1', 'catch', 'throw 2', 'done'], seq)\n  END\nenddef\n\ndef Test_error_in_catch()\n  var lines =<< trim END\n      try\n        eval [][0]\n      catch /E684:/\n        eval [][0]\n      endtry\n  END\n  v9.CheckDefExecFailure(lines, 'E684:', 4)\nenddef\n\n\" :while at the very start of a function that :continue jumps to\ndef s:TryContinueFunc()\n while g:Count < 2\n   g:sequence ..= 't'\n    try\n      echoerr 'Test'\n    catch\n      g:Count += 1\n      g:sequence ..= 'c'\n      continue\n    endtry\n    g:sequence ..= 'e'\n    g:Count += 1\n  endwhile\nenddef\n\ndef Test_continue_in_try_in_while()\n  g:Count = 0\n  g:sequence = ''\n  TryContinueFunc()\n  assert_equal('tctc', g:sequence)\n  unlet g:Count\n  unlet g:sequence\nenddef\n\ndef Test_break_in_try_in_for()\n  var lines =<< trim END\n      vim9script\n      def Ls(): list<string>\n        var ls: list<string>\n        for s in ['abc', 'def']\n          for _ in [123, 456]\n            try\n              eval [][0]\n            catch\n              break\n            endtry\n          endfor\n          ls += [s]\n        endfor\n        return ls\n      enddef\n      assert_equal(['abc', 'def'], Ls())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nocatch_return_in_try()\n  # return in try block returns normally\n  def ReturnInTry(): string\n    try\n      return '\"some message\"'\n    catch\n    endtry\n    return 'not reached'\n  enddef\n  exe 'echoerr ' .. ReturnInTry()\nenddef\n\ndef Test_cnext_works_in_catch()\n  var lines =<< trim END\n      vim9script\n      au BufEnter * eval 1 + 2\n      writefile(['text'], 'Xcncfile1')\n      writefile(['text'], 'Xcncfile2')\n      var items = [\n          {lnum: 1, filename: 'Xcncfile1', valid: true},\n          {lnum: 1, filename: 'Xcncfile2', valid: true}\n        ]\n      setqflist([], ' ', {items: items})\n      cwindow\n\n      def CnextOrCfirst()\n        # if cnext fails, cfirst is used\n        try\n          cnext\n        catch\n          cfirst\n        endtry\n      enddef\n\n      CnextOrCfirst()\n      CnextOrCfirst()\n      writefile([getqflist({idx: 0}).idx], 'Xcncresult')\n      qall\n  END\n  writefile(lines, 'XCatchCnext', 'D')\n  g:RunVim([], [], '--clean -S XCatchCnext')\n  assert_equal(['1'], readfile('Xcncresult'))\n\n  delete('Xcncfile1')\n  delete('Xcncfile2')\n  delete('Xcncresult')\nenddef\n\ndef Test_throw_skipped()\n  if 0\n    throw dontgethere\n  endif\nenddef\n\ndef Test_nocatch_throw_silenced()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      throw 'error'\n    enddef\n    silent! Func()\n  END\n  writefile(lines, 'XthrowSilenced', 'D')\n  source XthrowSilenced\nenddef\n\ndef DeletedFunc(): list<any>\n  return ['delete me']\nenddef\ndefcompile\ndelfunc DeletedFunc\n\ndef s:ThrowFromDef()\n  throw \"getout\" # comment\nenddef\n\nfunc s:CatchInFunc()\n  try\n    call s:ThrowFromDef()\n  catch\n    let g:thrown_func = v:exception\n  endtry\nendfunc\n\ndef s:CatchInDef()\n  try\n    ThrowFromDef()\n  catch\n    g:thrown_def = v:exception\n  endtry\nenddef\n\ndef s:ReturnFinally(): string\n  try\n    return 'intry'\n  finally\n    g:in_finally = 'finally'\n  endtry\n  return 'end'\nenddef\n\ndef Test_try_catch_nested()\n  CatchInFunc()\n  assert_equal('getout', g:thrown_func)\n\n  CatchInDef()\n  assert_equal('getout', g:thrown_def)\n\n  assert_equal('intry', ReturnFinally())\n  assert_equal('finally', g:in_finally)\n\n  var l = []\n  try\n    l->add('1')\n    throw 'bad'\n    l->add('x')\n  catch /bad/\n    l->add('2')\n    try\n      l->add('3')\n      throw 'one'\n      l->add('x')\n    catch /one/\n      l->add('4')\n      try\n        l->add('5')\n        throw 'more'\n        l->add('x')\n      catch /more/\n        l->add('6')\n      endtry\n    endtry\n  endtry\n  assert_equal(['1', '2', '3', '4', '5', '6'], l)\n\n  l = []\n  try\n    try\n      l->add('1')\n      throw 'foo'\n      l->add('x')\n    catch\n      l->add('2')\n      throw 'bar'\n      l->add('x')\n    finally\n      l->add('3')\n    endtry\n    l->add('x')\n  catch /bar/\n    l->add('4')\n  endtry\n  assert_equal(['1', '2', '3', '4'], l)\nenddef\n\ndef s:TryOne(): number\n  try\n    return 0\n  catch\n  endtry\n  return 0\nenddef\n\ndef s:TryTwo(n: number): string\n  try\n    var x = {}\n  catch\n  endtry\n  return 'text'\nenddef\n\ndef Test_try_catch_twice()\n  assert_equal('text', TryOne()->TryTwo())\nenddef\n\ndef Test_try_catch_match()\n  var seq = 'a'\n  try\n    throw 'something'\n  catch /nothing/\n    seq ..= 'x'\n  catch /some/\n    seq ..= 'b'\n  catch /asdf/\n    seq ..= 'x'\n  catch ?a\\?sdf?\n    seq ..= 'y'\n  finally\n    seq ..= 'c'\n  endtry\n  assert_equal('abc', seq)\nenddef\n\ndef Test_try_catch_fails()\n  v9.CheckDefFailure(['catch'], 'E603:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch', 'catch'], 'E1033:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch /pat'], 'E1067:')\n  v9.CheckDefFailure(['finally'], 'E606:')\n  v9.CheckDefFailure(['try', 'echo 0', 'finally', 'echo 1', 'finally'], 'E607:')\n  v9.CheckDefFailure(['endtry'], 'E602:')\n  v9.CheckDefFailure(['while 1', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['for i in range(5)', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['if 1', 'endtry'], 'E171:')\n  v9.CheckDefFailure(['try', 'echo 1', 'endtry'], 'E1032:')\n\n  v9.CheckDefFailure(['throw'], 'E1143:')\n  v9.CheckDefFailure(['throw xxx'], 'E1001:')\nenddef\n\ndef Try_catch_skipped()\n  var l = []\n  try\n  finally\n  endtry\n\n  if 1\n  else\n    try\n    endtry\n  endif\nenddef\n\n\" The skipped try/endtry was updating the wrong instruction.\ndef Test_try_catch_skipped()\n  var instr = execute('disassemble Try_catch_skipped')\n  assert_match(\"NEWLIST size 0\\n\", instr)\nenddef\n\ndef Test_throw_line_number()\n  def Func()\n    eval 1 + 1\n    eval 2 + 2\n    throw 'exception'\n  enddef\n  try\n    Func()\n  catch /exception/\n    assert_match('line 3', v:throwpoint)\n  endtry\nenddef\n\n\ndef Test_throw_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        throw 'one'\n              .. 'two'\n      catch\n        assert_equal('onetwo', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    @r = ''\n    def Func()\n      throw @r\n    enddef\n    var result = ''\n    try\n      Func()\n    catch /E1129:/\n      result = 'caught'\n    endtry\n    assert_equal('caught', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_nested_function()\n  # an error in a nested :function aborts executing in the calling :def function\n  var lines =<< trim END\n      vim9script\n      def Func()\n        Error()\n        g:test_var = 1\n      enddef\n      func Error() abort\n        eval [][0]\n      endfunc\n      Func()\n  END\n  g:test_var = 0\n  v9.CheckScriptFailure(lines, 'E684:')\n  assert_equal(0, g:test_var)\nenddef\n\ndef Test_abort_after_error()\n  var lines =<< trim END\n      vim9script\n      while true\n        echo notfound\n      endwhile\n      g:gotthere = true\n  END\n  g:gotthere = false\n  v9.CheckScriptFailure(lines, 'E121:')\n  assert_false(g:gotthere)\n  unlet g:gotthere\nenddef\n\ndef Test_cexpr_vimscript()\n  # only checks line continuation\n  set errorformat=File\\ %f\\ line\\ %l\n  var lines =<< trim END\n      vim9script\n      cexpr 'File'\n                .. ' someFile' ..\n                   ' line 19'\n      assert_equal(19, getqflist()[0].lnum)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        au QuickfixCmdPre * echo g:doesnotexist\n        cexpr 'File otherFile line 99'\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:doesnotexist')\n  assert_equal('no', g:didContinue)\n  au! QuickfixCmdPre\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        cexpr g:aNumber\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:aNumber = 123\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E777: String or List expected')\n  assert_equal('no', g:didContinue)\n  unlet g:didContinue\n\n  set errorformat&\nenddef\n\ndef Test_statusline_syntax()\n  # legacy syntax is used for 'statusline'\n  var lines =<< trim END\n      vim9script\n      func g:Status()\n        return '%{\"x\" is# \"x\"}'\n      endfunc\n      set laststatus=2 statusline=%!Status()\n      redrawstatus\n      set laststatus statusline= \n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_vimscript()\n  # checks line continuation and comments\n  var lines =<< trim END\n      vim9script\n      var mylist = [\n            'one',\n            # comment\n            'two', # empty line follows\n\n            'three',\n            ]\n      assert_equal(['one', 'two', 'three'], mylist)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check all lines from heredoc are kept\n  lines =<< trim END\n      # comment 1\n      two\n      # comment 3\n\n      five\n      # comment 6\n  END\n  assert_equal(['# comment 1', 'two', '# comment 3', '', 'five', '# comment 6'], lines)\n\n  lines =<< trim END\n    [{\n      a: 0}]->string()->assert_equal(\"[{'a': 0}]\")\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nif has('channel')\n  let someJob = test_null_job()\n\n  def FuncWithError()\n    echomsg g:someJob\n  enddef\n\n  func Test_convert_emsg_to_exception()\n    try\n      call FuncWithError()\n    catch\n      call assert_match('Vim:E908:', v:exception)\n    endtry\n  endfunc\nendif\n\ndef Test_vim9script_mix()\n  var lines =<< trim END\n    if has(g:feature)\n      \" legacy script\n      let g:legacy = 1\n      finish\n    endif\n    vim9script\n    g:legacy = 0\n  END\n  g:feature = 'eval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:legacy)\n\n  g:feature = 'noteval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(0, g:legacy)\nenddef\n\ndef Test_vim9script_fails()\n  v9.CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')\n  v9.CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')\n\n  v9.CheckScriptFailure(['vim9script', 'var str: string', 'str = 1234'], 'E1012:')\n  v9.CheckScriptFailure(['vim9script', 'const str = \"asdf\"', 'str = \"xxx\"'], 'E46:')\n\n  assert_fails('vim9script', 'E1038:')\n  v9.CheckDefFailure(['vim9script'], 'E1038:')\n\n  # no error when skipping\n  if has('nothing')\n    vim9script\n  endif\nenddef\n\ndef Test_script_var_shadows_function()\n  var lines =<< trim END\n      vim9script\n      def Func(): number\n        return 123\n      enddef\n      var Func = 1\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 5)\nenddef\n\ndef Test_function_shadows_script_var()\n  var lines =<< trim END\n      vim9script\n      var Func = 1\n      def Func(): number\n        return 123\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 3)\nenddef\n\ndef Test_script_var_shadows_command()\n  var lines =<< trim END\n      var undo = 1\n      undo = 2\n      assert_equal(2, undo)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var undo = 1\n      undo\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\nenddef\n\ndef Test_vim9script_call_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var Time = 'localtime'\n      Time()\n  END\n  v9.CheckScriptFailure(lines, 'E1085:')\nenddef\n\ndef Test_vim9script_reload_delfunc()\n  var first_lines =<< trim END\n    vim9script\n    def FuncYes(): string\n      return 'yes'\n    enddef\n  END\n  var withno_lines =<< trim END\n    def FuncNo(): string\n      return 'no'\n    enddef\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_equal('no', FuncNo())\n    enddef\n  END\n  var nono_lines =<< trim END\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_fails('FuncNo()', 'E117:', '', 2, 'DoCheck')\n    enddef\n  END\n\n  # FuncNo() is defined\n  writefile(first_lines + withno_lines, 'Xreloaded.vim', 'D')\n  source Xreloaded.vim\n  g:DoCheck(true)\n\n  # FuncNo() is not redefined\n  writefile(first_lines + nono_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  # FuncNo() is back\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\nenddef\n\ndef Test_vim9script_reload_delvar()\n  # write the script with a script-local variable\n  var lines =<< trim END\n    vim9script\n    var name = 'string'\n  END\n  writefile(lines, 'XreloadVar.vim', 'D')\n  source XreloadVar.vim\n\n  # now write the script using the same variable locally - works\n  lines =<< trim END\n    vim9script\n    def Func()\n      var name = 'string'\n    enddef\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\nenddef\n\ndef Test_func_redefine_error()\n  var lines = [\n        'vim9script',\n        'def Func()',\n        '  eval [][0]',\n        'enddef',\n        'Func()',\n        ]\n  writefile(lines, 'Xtestscript.vim', 'D')\n\n  for count in range(3)\n    try\n      source Xtestscript.vim\n    catch /E684/\n      # function name should contain <SNR> every time\n      assert_match('E684: List index out of range', v:exception)\n      assert_match('function <SNR>\\d\\+_Func, line 1', v:throwpoint)\n    endtry\n  endfor\nenddef\n\ndef Test_func_redefine_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      echo 'one'\n    enddef\n    def Func()\n      echo 'two'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\n\n  lines =<< trim END\n    vim9script\n    def Foo(): string\n      return 'foo'\n    enddef\n    def Func()\n      var  Foo = {-> 'lambda'}\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\nenddef\n\ndef Test_lambda_split()\n  # this was using freed memory, because of the split expression\n  var lines =<< trim END\n      vim9script\n      try\n      0\n      0->(0\n        ->a.0(\n        ->u\n  END\n  v9.CheckScriptFailure(lines, 'E1050:')\nenddef\n\ndef Test_fixed_size_list()\n  # will be allocated as one piece of memory, check that changes work\n  var l = [1, 2, 3, 4]\n  l->remove(0)\n  l->add(5)\n  l->insert(99, 1)\n  assert_equal([2, 99, 3, 4, 5], l)\nenddef\n\ndef Test_no_insert_xit()\n  v9.CheckDefExecFailure(['a = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['c = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['i = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['t = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['x = 1'], 'E1100:')\n\n  v9.CheckScriptFailure(['vim9script', 'a = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'a'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'c = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'c'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'i = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'i'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'x = 1'], 'E1100:')\nenddef\n\ndef s:IfElse(what: number): string\n  var res = ''\n  if what == 1\n    res = \"one\"\n  elseif what == 2\n    res = \"two\"\n  else\n    res = \"three\"\n  endif\n  return res\nenddef\n\ndef Test_if_elseif_else()\n  assert_equal('one', IfElse(1))\n  assert_equal('two', IfElse(2))\n  assert_equal('three', IfElse(3))\nenddef\n\ndef Test_if_elseif_else_fails()\n  v9.CheckDefFailure(['elseif true'], 'E582:')\n  v9.CheckDefFailure(['else'], 'E581:')\n  v9.CheckDefFailure(['endif'], 'E580:')\n  v9.CheckDefFailure(['if g:abool', 'elseif xxx'], 'E1001:')\n  v9.CheckDefFailure(['if true', 'echo 1'], 'E171:')\n\n  var lines =<< trim END\n      var s = ''\n      if s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var s = ''\n      if s == ''\n      elseif s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var cond = true\n      if cond\n        echo 'true'\n      elseif\n        echo 'false'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1143:', 'E15:'], 4)\nenddef\n\ndef Test_if_else_func_using_var()\n  var lines =<< trim END\n      vim9script\n\n      const debug = true\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('in true', g:where)\n  unlet g:where\n\n  lines =<< trim END\n      vim9script\n\n      const debug = false\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: mode_chars')\nenddef\n\nlet g:bool_true = v:true\nlet g:bool_false = v:false\n\ndef Test_if_const_expr()\n  var res = false\n  if true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  g:glob = 2\n  if false\n    execute('g:glob = 3')\n  endif\n  assert_equal(2, g:glob)\n  if true\n    execute('g:glob = 3')\n  endif\n  assert_equal(3, g:glob)\n\n  res = false\n  if g:bool_true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? g:bool_true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? true : g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? false : true\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false ? false : true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if has('xyz') ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if g:bool_true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && g:bool_false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if g:bool_true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true || g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false || false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  # with constant \"false\" expression may be invalid so long as the syntax is OK\n  if false | eval 1 + 2 | endif\n  if false | eval burp + 234 | endif\n  if false | echo burp 234 'asd' | endif\n  if false\n    burp\n  endif\n\n  if 0\n    if 1\n      echo nothing\n    elseif 1\n      echo still nothing\n    endif\n  endif\n\n  # expression with line breaks skipped\n  if false\n      ('aaa'\n      .. 'bbb'\n      .. 'ccc'\n      )->setline(1)\n  endif\nenddef\n\ndef Test_if_const_expr_fails()\n  v9.CheckDefFailure(['if \"aaa\" == \"bbb'], 'E114:')\n  v9.CheckDefFailure([\"if 'aaa' == 'bbb\"], 'E115:')\n  v9.CheckDefFailure([\"if has('aaa'\"], 'E110:')\n  v9.CheckDefFailure([\"if has('aaa') ? true false\"], 'E109:')\nenddef\n\ndef s:RunNested(i: number): number\n  var x: number = 0\n  if i % 2\n    if 1\n      # comment\n    else\n      # comment\n    endif\n    x += 1\n  else\n    x += 1000\n  endif\n  return x\nenddef\n\ndef Test_nested_if()\n  assert_equal(1, RunNested(1))\n  assert_equal(1000, RunNested(2))\nenddef\n\ndef Test_execute_cmd()\n  # missing argument is ignored\n  execute\n  execute # comment\n\n  new\n  setline(1, 'default')\n  execute 'setline(1, \"execute-string\")'\n  assert_equal('execute-string', getline(1))\n\n  execute \"setline(1, 'execute-string')\"\n  assert_equal('execute-string', getline(1))\n\n  var cmd1 = 'setline(1,'\n  var cmd2 = '\"execute-var\")'\n  execute cmd1 cmd2 # comment\n  assert_equal('execute-var', getline(1))\n\n  execute cmd1 cmd2 '|setline(1, \"execute-var-string\")'\n  assert_equal('execute-var-string', getline(1))\n\n  var cmd_first = 'call '\n  var cmd_last = 'setline(1, \"execute-var-var\")'\n  execute cmd_first .. cmd_last\n  assert_equal('execute-var-var', getline(1))\n  bwipe!\n\n  var n = true\n  execute 'echomsg' (n ? '\"true\"' : '\"no\"')\n  assert_match('^true$', g:Screenline(&lines))\n\n  echomsg [1, 2, 3] {a: 1, b: 2}\n  assert_match('^\\[1, 2, 3\\] {''a'': 1, ''b'': 2}$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['execute xxx'], 'E1001:', 1)\n  v9.CheckDefExecFailure(['execute \"tabnext \" .. 8'], 'E475:', 1)\n  v9.CheckDefFailure(['execute \"cmd\"# comment'], 'E488:', 1)\n  if has('channel')\n    v9.CheckDefExecFailure(['execute test_null_channel()'], 'E908:', 1)\n  endif\nenddef\n\ndef Test_execute_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      execute 'g:someVar'\n                .. ' = ' ..\n                   '28'\n      assert_equal(28, g:someVar)\n      unlet g:someVar\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_execute_finish()\n  # the empty lines are relevant here\n  var lines =<< trim END\n      vim9script\n\n      var vname = \"g:hello\"\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_equal('world', g:hello)\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_report('should not be reached')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echo_cmd()\n  echo 'some' # comment\n  echon 'thing'\n  assert_match('^something$', g:Screenline(&lines))\n\n  echo \"some\" # comment\n  echon \"thing\"\n  assert_match('^something$', g:Screenline(&lines))\n\n  var str1 = 'some'\n  var str2 = 'more'\n  echo str1 str2\n  assert_match('^some more$', g:Screenline(&lines))\n\n  echo \"one\\ntwo\"\n  assert_match('^one$', g:Screenline(&lines - 1))\n  assert_match('^two$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echo \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd()\n  echomsg 'some' 'more' # comment\n  assert_match('^some more$', g:Screenline(&lines))\n  echo 'clear'\n  :1messages\n  assert_match('^some more$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echomsg \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      echomsg 'here'\n                .. ' is ' ..\n                   'a message'\n      assert_match('^here is a message$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoerr_cmd()\n  var local = 'local'\n  try\n    echoerr 'something' local 'wrong' # comment\n  catch\n    assert_match('something local wrong', v:exception)\n  endtry\nenddef\n\ndef Test_echoerr_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        echoerr 'this'\n                .. ' is ' ..\n                   'wrong'\n      catch\n        assert_match('this is wrong', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoconsole_cmd()\n  var local = 'local'\n  echoconsole 'something' local # comment\n  # output goes anywhere\nenddef\n\ndef Test_echowindow_cmd()\n  var local = 'local'\n  echowindow 'something' local # comment\n  # output goes in message window\n  popup_clear()\nenddef\n\ndef Test_for_outside_of_function()\n  var lines =<< trim END\n    vim9script\n    new\n    for var in range(0, 3)\n      append(line('$'), var)\n    endfor\n    assert_equal(['', '0', '1', '2', '3'], getline(1, '$'))\n    bwipe!\n\n    var result = ''\n    for i in [1, 2, 3]\n      var loop = ' loop ' .. i\n      result ..= loop\n    endfor\n    assert_equal(' loop 1 loop 2 loop 3', result)\n  END\n  writefile(lines, 'Xvim9for.vim', 'D')\n  source Xvim9for.vim\nenddef\n\ndef Test_for_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    if true\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      if true\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      if false\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n\n    def BuildDiagrams()\n      var diagrams: list<any>\n      if false\n        var max = 0\n        for v in diagrams\n          var l = 3\n          if max < l | max = l | endif\n          v->add(l)\n        endfor\n      endif\n    enddef\n    BuildDiagrams()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_redir()\n  var lines =<< trim END\n      def Tredir()\n        if 0\n          redir => l[0]\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Tredir\n\n  lines =<< trim END\n      def Tredir()\n        if 0\n          redir => l[0]\n        endif\n        echo 'executed'\n        if 0\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Tredir\n\n  lines =<< trim END\n      def Tredir()\n        var l = ['']\n        if 1\n          redir => l[0]\n        endif\n        echo 'executed'\n        if 0\n          redir END\n        else\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Tredir\n\n  lines =<< trim END\n      let doit = 1\n      def Tredir()\n        var l = ['']\n        if g:doit\n          redir => l[0]\n        endif\n        echo 'executed'\n        if g:doit\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:Tredir\nenddef\n\ndef Test_for_loop()\n  var lines =<< trim END\n      var result = ''\n      for cnt in range(7)\n        if cnt == 4\n          break\n        endif\n        if cnt == 2\n          continue\n        endif\n        result ..= cnt .. '_'\n      endfor\n      assert_equal('0_1_3_', result)\n\n      var concat = ''\n      for str in eval('[\"one\", \"two\"]')\n        concat ..= str\n      endfor\n      assert_equal('onetwo', concat)\n\n      var total = 0\n      for nr in\n          [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in\n        [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      # with type\n      total = 0\n      for n: number in [1, 2, 3]\n        total += n\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for b in 0z010203\n        total += b\n      endfor\n      assert_equal(6, total)\n\n      var chars = ''\n      for s: string in 'foobar'\n        chars ..= s\n      endfor\n      assert_equal('foobar', chars)\n\n      chars = ''\n      for x: string in {a: 'a', b: 'b'}->values()\n        chars ..= x\n      endfor\n      assert_equal('ab', chars)\n\n      # unpack with type\n      var res = ''\n      for [n: number, s: string] in [[1, 'a'], [2, 'b']]\n        res ..= n .. s\n      endfor\n      assert_equal('1a2b', res)\n\n      # unpack with one var\n      var reslist = []\n      for [x] in [['aaa'], ['bbb']]\n        reslist->add(x)\n      endfor\n      assert_equal(['aaa', 'bbb'], reslist)\n\n      # loop over string\n      res = ''\n      for c in 'a\u00e9c\u0300d'\n        res ..= c .. '-'\n      endfor\n      assert_equal('a-\u00e9-c\u0300-d-', res)\n\n      res = ''\n      for c in ''\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      res = ''\n      for c in test_null_string()\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      total = 0\n      for c in null_list\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      for c in null_blob\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      var foo: list<dict<any>> = [\n              {a: 'Cat'}\n            ]\n      for dd in foo\n        dd.counter = 12\n      endfor\n      assert_equal([{a: 'Cat', counter: 12}], foo)\n\n      reslist = []\n      for _ in range(3)\n        reslist->add('x')\n      endfor\n      assert_equal(['x', 'x', 'x'], reslist)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_list_of_lists()\n  # loop variable is final, not const\n  var lines =<< trim END\n      # Filter out all odd numbers in each sublist\n      var list: list<list<number>> = [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]\n      for i in list\n          filter(i, (_, n: number): bool => n % 2 == 0)\n      endfor\n\n      assert_equal([[], [2], [2], [2, 4]], list)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_with_closure()\n  # using the loop variable in a closure results in the last used value\n  var lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        flist[i] = () => i\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also works when the loop variable is used only once halfway the loops\n  lines =<< trim END\n      var Clo: func\n      for i in range(5)\n        if i == 3\n          Clo = () => i\n        endif\n      endfor\n      assert_equal(4, Clo())\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # using a local variable set to the loop variable in a closure results in the\n  # value at that moment\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => inloop\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also with an extra block level\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        {\n          var inloop = i\n          flist[i] = () => inloop\n        }\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # and declaration in higher block\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        {\n          flist[i] = () => inloop\n        }\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => {\n              return inloop\n            }\n      endfor\n      for i in range(5)\n        assert_equal(i, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # Also works for a nested loop\n  lines =<< trim END\n      var flist: list<func>\n      var n = 0\n      for i in range(3)\n        var ii = i\n        for a in ['a', 'b', 'c']\n          var aa = a\n          flist[n] = () => ii .. aa\n          ++n\n        endfor\n      endfor\n\n      n = 0\n      for i in range(3)\n        for a in ['a', 'b', 'c']\n          assert_equal(i .. a, flist[n]())\n          ++n\n        endfor\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # using two loop variables\n  lines =<< trim END\n      var lv_list: list<func>\n      var copy_list: list<func>\n      for [idx, c] in items('word')\n        var lidx = idx\n        var lc = c\n        lv_list[idx] = () => {\n              return idx .. c\n            }\n        copy_list[idx] = () => {\n              return lidx .. lc\n            }\n      endfor\n      for [i, c] in items('word')\n        assert_equal(3 .. 'd', lv_list[i]())\n        assert_equal(i .. c, copy_list[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_define_global_closure_in_loops()\n  var lines =<< trim END\n      vim9script\n\n      def Func()\n        for i in range(3)\n          var ii = i\n          for a in ['a', 'b', 'c']\n            var aa = a\n            if ii == 0 && aa == 'a'\n              def g:Global_0a(): string\n                return ii .. aa\n              enddef\n            endif\n            if ii == 1 && aa == 'b'\n              def g:Global_1b(): string\n                return ii .. aa\n              enddef\n            endif\n            if ii == 2 && aa == 'c'\n              def g:Global_2c(): string\n                return ii .. aa\n              enddef\n            endif\n          endfor\n        endfor\n      enddef\n      Func()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(\"0a\", g:Global_0a())\n  assert_equal(\"1b\", g:Global_1b())\n  assert_equal(\"2c\", g:Global_2c())\n\n  delfunc g:Global_0a\n  delfunc g:Global_1b\n  delfunc g:Global_2c\nenddef\n\ndef Test_for_loop_fails()\n  v9.CheckDefAndScriptFailure(['for '], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x'], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x in'], ['E1097:', 'E15:'])\n  v9.CheckDefAndScriptFailure(['for # in range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['for i In range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['var x = 5', 'for x in range(5)', 'endfor'], ['E1017:', 'E1041:'])\n  v9.CheckScriptFailure(['vim9script', 'var x = 5', 'for x in range(5)', '# comment', 'endfor'], 'E1041:', 3)\n  v9.CheckScriptFailure(['def Func(arg: any)', 'for arg in range(5)', 'enddef', 'defcompile'], 'E1006:')\n  delfunc! g:Func\n  v9.CheckDefFailure(['for i in xxx'], 'E1001:')\n  v9.CheckDefFailure(['endfor'], 'E588:')\n  v9.CheckDefFailure(['for i in range(3)', 'echo 3'], 'E170:')\n\n  # wrong type detected at compile time\n  v9.CheckDefFailure(['for i in {a: 1}', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n\n  # wrong type detected at runtime\n  g:adict = {a: 1}\n  v9.CheckDefExecFailure(['for i in g:adict', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n  unlet g:adict\n\n  var lines =<< trim END\n      var d: list<dict<any>> = [{a: 0}]\n      for e in d\n        e = {a: 0, b: ''}\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1018:', 'E46:'], 3)\n\n  lines =<< trim END\n      for nr: number in ['foo']\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012: Type mismatch; expected number but got string', 1)\n\n  lines =<< trim END\n      for n : number in [1, 2]\n        echo n\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1059:', 1)\n\n  lines =<< trim END\n      var d: dict<number> = {a: 1, b: 2}\n      for [k: job, v: job] in d->items()\n        echo k v\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1163: Variable 1: type mismatch, expected job but got string', 'E1012: Type mismatch; expected job but got string'], 2)\n\n  lines =<< trim END\n      var i = 0\n      for i in [1, 2, 3]\n        echo i\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1017:', 'E1041:'])\n\n  lines =<< trim END\n      var l = [0]\n      for l[0] in [1, 2, 3]\n        echo l[0]\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var d = {x: 0}\n      for d.x in [1, 2, 3]\n        echo d.x\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{a: 1, b: 'x'}]\n      for item: dict<number> in l\n        echo item\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012: Type mismatch; expected dict<number> but got dict<any>')\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{n: 1}]\n      for item: dict<number> in l\n        var d = {s: ''}\n        d->extend(item)\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected dict<string> but got dict<number>')\n\n  lines =<< trim END\n      for a in range(3)\n        while a > 3\n          for b in range(2)\n            while b < 0\n              for c in range(5)\n                while c > 6\n                  while c < 0\n                    for d in range(1)\n                      for e in range(3)\n                        while e > 3\n                        endwhile\n                      endfor\n                    endfor\n                  endwhile\n                endwhile\n              endfor\n            endwhile\n          endfor\n        endwhile\n      endfor\n  END\n  v9.CheckDefSuccess(lines)\n\n  v9.CheckDefFailure(['for x in range(3)'] + lines + ['endfor'], 'E1306:')\nenddef\n\ndef Test_for_loop_script_var()\n  # cannot use s:var in a :def function\n  v9.CheckDefFailure(['for s:var in range(3)', 'echo 3'], 'E1254:')\n\n  # can use s:var in Vim9 script, with or without s:\n  var lines =<< trim END\n    vim9script\n    var total = 0\n    for s:var in [1, 2, 3]\n      total += s:var\n    endfor\n    assert_equal(6, total)\n\n    total = 0\n    for var in [1, 2, 3]\n      total += var\n    endfor\n    assert_equal(6, total)\n  END\nenddef\n\ndef Test_for_loop_unpack()\n  var lines =<< trim END\n      var result = []\n      for [v1, v2] in [[1, 2], [3, 4]]\n        result->add(v1)\n        result->add(v2)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      result = []\n      for [v1, v2; v3] in [[1, 2], [3, 4, 5, 6]]\n        result->add(v1)\n        result->add(v2)\n        result->add(v3)\n      endfor\n      assert_equal([1, 2, [], 3, 4, [5, 6]], result)\n\n      result = []\n      for [&ts, &sw] in [[1, 2], [3, 4]]\n        result->add(&ts)\n        result->add(&sw)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      var slist: list<string>\n      for [$LOOPVAR, @r, v:errmsg] in [['a', 'b', 'c'], ['d', 'e', 'f']]\n        slist->add($LOOPVAR)\n        slist->add(@r)\n        slist->add(v:errmsg)\n      endfor\n      assert_equal(['a', 'b', 'c', 'd', 'e', 'f'], slist)\n\n      slist = []\n      for [g:globalvar, b:bufvar, w:winvar, t:tabvar] in [['global', 'buf', 'win', 'tab'], ['1', '2', '3', '4']]\n        slist->add(g:globalvar)\n        slist->add(b:bufvar)\n        slist->add(w:winvar)\n        slist->add(t:tabvar)\n      endfor\n      assert_equal(['global', 'buf', 'win', 'tab', '1', '2', '3', '4'], slist)\n      unlet! g:globalvar b:bufvar w:winvar t:tabvar\n\n      var res = []\n      for [_, n, _] in [[1, 2, 3], [4, 5, 6]]\n        res->add(n)\n      endfor\n      assert_equal([2, 5], res)\n\n      var text: list<string> = [\"hello there\", \"goodbye now\"]\n      var splitted = ''\n      for [first; next] in mapnew(text, (i, v) => split(v))\n          splitted ..= string(first) .. string(next) .. '/'\n      endfor\n      assert_equal(\"'hello'['there']/'goodbye'['now']/\", splitted)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      for [v1, v2] in [[1, 2, 3], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E710:', 1)\n\n  lines =<< trim END\n      for [v1, v2] in [[1], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E711:', 1)\n\n  lines =<< trim END\n      for [v1, v1] in [[1, 2], [3, 4]]\n        echo v1\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E1017:', 1)\n\n  lines =<< trim END\n      for [a, b] in g:listlist\n        echo a\n      endfor\n  END\n  g:listlist = [1, 2, 3]\n  v9.CheckDefExecFailure(lines, 'E1140:', 1)\nenddef\n\ndef Test_for_loop_with_try_continue()\n  var lines =<< trim END\n      var looped = 0\n      var cleanup = 0\n      for i in range(3)\n        looped += 1\n        try\n          eval [][0]\n        catch\n          continue\n        finally\n          cleanup += 1\n        endtry\n      endfor\n      assert_equal(3, looped)\n      assert_equal(3, cleanup)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    var n = 0\n    if true\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      var n = 0\n      if true\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      var n = 0\n      if false\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_loop()\n  var result = ''\n  var cnt = 0\n  while cnt < 555\n    if cnt == 3\n      break\n    endif\n    cnt += 1\n    if cnt == 2\n      continue\n    endif\n    result ..= cnt .. '_'\n  endwhile\n  assert_equal('1_3_', result)\n\n  var s = ''\n  while s == 'x' # {comment}\n  endwhile\nenddef\n\ndef Test_while_loop_in_script()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n      var cnt = 0\n      while cnt < 3\n        var s = 'v' .. cnt\n        result ..= s\n        cnt += 1\n      endwhile\n      assert_equal('v0v1v2', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_while_loop_fails()\n  v9.CheckDefFailure(['while xxx'], 'E1001:')\n  v9.CheckDefFailure(['endwhile'], 'E588:')\n  v9.CheckDefFailure(['continue'], 'E586:')\n  v9.CheckDefFailure(['if true', 'continue'], 'E586:')\n  v9.CheckDefFailure(['break'], 'E587:')\n  v9.CheckDefFailure(['if true', 'break'], 'E587:')\n  v9.CheckDefFailure(['while 1', 'echo 3'], 'E170:')\n\n  var lines =<< trim END\n      var s = ''\n      while s = ''\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E488:')\nenddef\n\ndef Test_interrupt_loop()\n  var caught = false\n  var x = 0\n  try\n    while 1\n      x += 1\n      if x == 100\n        feedkeys(\"\\<C-C>\", 'Lt')\n      endif\n    endwhile\n  catch\n    caught = true\n    assert_equal(100, x)\n  endtry\n  assert_true(caught, 'should have caught an exception')\n  # consume the CTRL-C\n  getchar(0)\nenddef\n\ndef Test_automatic_line_continuation()\n  var mylist = [\n      'one',\n      'two',\n      'three',\n      ] # comment\n  assert_equal(['one', 'two', 'three'], mylist)\n\n  var mydict = {\n      ['one']: 1,\n      ['two']: 2,\n      ['three']:\n          3,\n      } # comment\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1,  # comment\n      two:     # comment\n           2,  # comment\n      three: 3 # comment\n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1, \n      two: \n           2, \n      three: 3 \n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n\n  assert_equal(\n        ['one', 'two', 'three'],\n        split('one two three')\n        )\nenddef\n\ndef Test_vim9_comment()\n  v9.CheckScriptSuccess([\n      'vim9script',\n      '# something',\n      '#something',\n      '#{{something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      '#{something',\n      ], 'E1170:')\n\n  split Xv9cfile\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #something',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #{something',\n      ])\n  close\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      ':# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      '# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      ':# something',\n      ], 'E488:')\n\n  { # block start\n  } # block end\n  v9.CheckDefFailure([\n      '{# comment',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      '{',\n      '}# comment',\n      ], 'E488:')\n\n  echo \"yes\" # comment\n  v9.CheckDefFailure([\n      'echo \"yes\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'echo \"yes\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo \"yes\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'echo \"yes\" # something',\n      ], 'E121:')\n\n  exe \"echo\" # comment\n  v9.CheckDefFailure([\n      'exe \"echo\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'exe \"echo\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe \"echo\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'exe \"echo\" # something',\n      ], 'E121:')\n\n  v9.CheckDefFailure([\n      'try# comment',\n      '  echo \"yes\"',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try# comment',\n      'echo \"yes\"',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw#comment',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw \"yes\"#comment',\n      'catch',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch /pat/# comment',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      'echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Search# comment',\n      ], 'E416:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi link This Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi link This That# comment',\n      ], 'E413:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi clear This # comment',\n      'hi clear # comment',\n      ])\n  # not tested, because it doesn't give an error but a warning:\n  # hi clear This# comment',\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi clear# comment',\n      ], 'E416:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match none # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match none# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'menutrans clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'menutrans clear# comment text',\n      ], 'E474:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax clear# comment text',\n      ], 'E28:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax list # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax list# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ oneline # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ oneline# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word word # comm[ent',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word word# comm[ent',\n      ], 'E789:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something# comment',\n      ], 'E475:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains= # comment',\n      ], 'E406:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync# comment',\n      ], 'E404:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync ccomment # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync ccomment# comment',\n      ], 'E404:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax cluster Some contains=Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax cluster Some contains=Word# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo echo # comment',\n      'command Echo # comment',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo# comment',\n      'Echo',\n      ], 'E1144:')\n  delcommand Echo\n\n  var curdir = getcwd()\n  v9.CheckScriptSuccess([\n      'command Echo cd \" comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo cd # comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo cd \" comment',\n      'Echo',\n      ], 'E344:')\n  delcommand Echo\n  chdir(curdir)\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo# comment',\n      ], 'E182:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo',\n      'command Echo# comment',\n      ], 'E182:')\n  delcommand Echo\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'function # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function \" comment',\n      ], 'E129:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess# comment',\n      ], 'E1048: Item not found in script: CheckScriptSuccess#')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func g:DeleteMeA()',\n      'endfunc',\n      'delfunction g:DeleteMeA # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func g:DeleteMeB()',\n      'endfunc',\n      'delfunction g:DeleteMeB# comment',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'call execute(\"ls\") # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'call execute(\"ls\")# comment',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'func Test() \" comment',\n      'endfunc',\n      'delfunc Test',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func Test() \" comment',\n      'endfunc',\n      ])\n\n  v9.CheckScriptSuccess([\n      'def Test() # comment',\n      'enddef',\n      ])\n  v9.CheckScriptFailure([\n      'func Test() # comment',\n      'endfunc',\n      ], 'E488:')\n\n  var lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      #\\ comment\n      \\ end='bar'\n      syn region Text start='foo'\n      #\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      \"\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptFailure(lines, 'E399:')\nenddef\n\ndef Test_vim9_comment_gui()\n  CheckCanRunGui\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui#comment'\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui -f#comment'\n      ], 'E194:')\nenddef\n\ndef Test_vim9_comment_not_compiled()\n  au TabEnter *.vim g:entered = 1\n  au TabEnter *.x g:entered = 2\n\n  edit test.vim\n  doautocmd TabEnter #comment\n  assert_equal(1, g:entered)\n\n  doautocmd TabEnter f.x\n  assert_equal(2, g:entered)\n\n  g:entered = 0\n  doautocmd TabEnter f.x #comment\n  assert_equal(2, g:entered)\n\n  assert_fails('doautocmd Syntax#comment', 'E216:')\n\n  au! TabEnter\n  unlet g:entered\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'g:var = 123',\n      'b:var = 456',\n      'w:var = 777',\n      't:var = 888',\n      'unlet g:var w:var # something',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'let var = 123',\n      ], 'E1126: Cannot use :let in Vim9 script')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var g:var = 123',\n      ], 'E1016: Cannot declare a global variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var b:var = 123',\n      ], 'E1016: Cannot declare a buffer variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var w:var = 123',\n      ], 'E1016: Cannot declare a window variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var t:var = 123',\n      ], 'E1016: Cannot declare a tab variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v:version = 123',\n      ], 'E1016: Cannot declare a v: variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var $VARIABLE = \"text\"',\n      ], 'E1016: Cannot declare an environment variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'g:var = 123',\n      'unlet g:var# comment1',\n      ], 'E108:')\n\n  v9.CheckScriptFailure([\n      'let g:var = 123',\n      'unlet g:var # something',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'if 1 # comment2',\n      '  echo \"yes\"',\n      'elseif 2 #comment',\n      '  echo \"no\"',\n      'endif',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 1# comment3',\n      '  echo \"yes\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 0 # comment4',\n      '  echo \"yes\"',\n      'elseif 2#comment',\n      '  echo \"no\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'var v = 1 # comment5',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v = 1# comment6',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'new',\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/ #comment',\n      'bwipe!',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'new',\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/#comment',\n      'bwipe!',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func! SomeFunc()',\n      ], 'E477:')\nenddef\n\ndef Test_finish()\n  var lines =<< trim END\n    vim9script\n    g:res = 'one'\n    if v:false | finish | endif\n    g:res = 'two'\n    finish\n    g:res = 'three'\n  END\n  writefile(lines, 'Xfinished', 'D')\n  source Xfinished\n  assert_equal('two', g:res)\n\n  unlet g:res\nenddef\n\ndef Test_forward_declaration()\n  var lines =<< trim END\n    vim9script\n    def GetValue(): string\n      return theVal\n    enddef\n    var theVal = 'something'\n    g:initVal = GetValue()\n    theVal = 'else'\n    g:laterVal = GetValue()\n  END\n  writefile(lines, 'Xforward', 'D')\n  source Xforward\n  assert_equal('something', g:initVal)\n  assert_equal('else', g:laterVal)\n\n  unlet g:initVal\n  unlet g:laterVal\nenddef\n\ndef Test_declare_script_var_in_func()\n  var lines =<< trim END\n      vim9script\n      func Declare()\n        let s:local = 123\n      endfunc\n      Declare()\n  END\n  v9.CheckScriptFailure(lines, 'E1269:')\nenddef\n        \ndef Test_lock_script_var()\n  var lines =<< trim END\n      vim9script\n      var local = 123\n      assert_equal(123, local)\n\n      var error: string\n      try\n        local = 'asdf'\n      catch\n        error = v:exception\n      endtry\n      assert_match('E1012: Type mismatch; expected number but got string', error)\n\n      lockvar local\n      try\n        local = 999\n      catch\n        error = v:exception\n      endtry\n      assert_match('E741: Value is locked: local', error)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n        \n\nfunc Test_vim9script_not_global()\n  \" check that items defined in Vim9 script are script-local, not global\n  let vim9lines =<< trim END\n    vim9script\n    var name = 'local'\n    func TheFunc()\n      echo 'local'\n    endfunc\n    def DefFunc()\n      echo 'local'\n    enddef\n  END\n  call writefile(vim9lines, 'Xvim9script.vim', 'D')\n  source Xvim9script.vim\n  try\n    echo g:var\n    assert_report('did not fail')\n  catch /E121:/\n    \" caught\n  endtry\n  try\n    call TheFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n  try\n    call DefFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\nendfunc\n\ndef Test_vim9_copen()\n  # this was giving an error for setting w:quickfix_title\n  copen\n  quit\nenddef\n\ndef Test_script_var_in_autocmd()\n  # using a script variable from an autocommand, defined in a :def function in a\n  # legacy Vim script, cannot check the variable type.\n  var lines =<< trim END\n    let s:counter = 1\n    def s:Func()\n      au! CursorHold\n      au CursorHold * s:counter += 1\n    enddef\n    call s:Func()\n    doau CursorHold\n    call assert_equal(2, s:counter)\n    au! CursorHold\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_autoload_script()\n  var save_rtp = &rtp\n  var dir = getcwd() .. '/Xruntime'\n  &rtp = dir\n  mkdir(dir .. '/autoload', 'pR')\n\n  var lines =<< trim END\n      vim9script noclear\n      export def Autoloaded()\n      enddef\n      def Broken()\n        var x: any = ''\n        eval x != 0\n      enddef\n      Broken()\n  END\n  writefile(lines, dir .. '/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      def CallAutoloaded()\n        script#Autoloaded()\n      enddef\n\n      function Legacy()\n        try\n          call s:CallAutoloaded()\n        catch\n          call assert_match('E1030: Using a String as a Number', v:exception)\n        endtry\n      endfunction\n\n      Legacy()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  &rtp = save_rtp\nenddef\n\ndef Test_error_in_autoload_script_foldexpr()\n  var save_rtp = &rtp\n  mkdir('Xvim/autoload', 'pR')\n  &runtimepath = 'Xvim'\n\n  var lines =<< trim END\n      vim9script\n      eval [][0]\n      echomsg 'no error'\n  END\n  lines->writefile('Xvim/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      &foldmethod = 'expr'\n      &foldexpr = 'script.Func()'\n      redraw\n  END\n  v9.CheckScriptFailure(lines, 'E684: List index out of range: 0')\nenddef\n\ndef Test_invalid_sid()\n  assert_fails('func <SNR>1234_func', 'E123:')\n\n  if g:RunVim([], ['wq! Xdidit'], '+\"func <SNR>1_func\"')\n    assert_equal([], readfile('Xdidit'))\n  endif\n  delete('Xdidit')\nenddef\n\ndef Test_restoring_cpo()\n  writefile(['vim9script', 'set nocp'], 'Xsourced', 'D')\n  writefile(['call writefile([\"done\"], \"Xdone\")', 'quit!'], 'Xclose', 'D')\n  if g:RunVim([], [], '-u NONE +\"set cpo+=a\" -S Xsourced -S Xclose')\n    assert_equal(['done'], readfile('Xdone'))\n  endif\n  delete('Xdone')\n\n  writefile(['vim9script', 'g:cpoval = &cpo'], 'XanotherScript', 'D')\n  set cpo=aABceFsMny>\n  edit XanotherScript\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFs', g:cpoval)\n  :1del\n  setline(1, 'let g:cpoval = &cpo')\n  w\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFsMny>', g:cpoval)\n\n  set cpo&vim\n  unlet g:cpoval\n\n  if has('unix')\n    # 'cpo' is not restored in main vimrc\n    var save_HOME = $HOME\n    $HOME = getcwd() .. '/Xhome'\n    mkdir('Xhome', 'R')\n    var lines =<< trim END\n        vim9script\n        writefile(['before: ' .. &cpo], 'Xrporesult')\n        set cpo+=M\n        writefile(['after: ' .. &cpo], 'Xrporesult', 'a')\n    END\n    writefile(lines, 'Xhome/.vimrc')\n\n    lines =<< trim END\n        call writefile(['later: ' .. &cpo], 'Xrporesult', 'a')\n    END\n    writefile(lines, 'Xlegacy', 'D')\n\n    lines =<< trim END\n        vim9script\n        call writefile(['vim9: ' .. &cpo], 'Xrporesult', 'a')\n        qa\n    END\n    writefile(lines, 'Xvim9', 'D')\n\n    var cmd = g:GetVimCommand() .. \" -S Xlegacy -S Xvim9\"\n    cmd = substitute(cmd, '-u NONE', '', '')\n    exe \"silent !\" .. cmd\n\n    assert_equal([\n        'before: aABceFs',\n        'after: aABceFsM',\n        'later: aABceFsM',\n        'vim9: aABceFs'], readfile('Xrporesult'))\n\n    $HOME = save_HOME\n    delete('Xrporesult')\n  endif\nenddef\n\n\" Use :function so we can use Check commands\nfunc Test_no_redraw_when_restoring_cpo()\n  CheckScreendump\n  CheckFeature timers\n  call Run_test_no_redraw_when_restoring_cpo()\nendfunc\n\ndef Run_test_no_redraw_when_restoring_cpo()\n  var lines =<< trim END\n    vim9script\n    export def Func()\n    enddef\n  END\n  mkdir('Xnordir/autoload', 'pR')\n  writefile(lines, 'Xnordir/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      set cpo+=M\n      exe 'set rtp^=' .. getcwd() .. '/Xnordir'\n      au CmdlineEnter : ++once timer_start(0, (_) => script#Func())\n      setline(1, 'some text')\n  END\n  writefile(lines, 'XTest_redraw_cpo', 'D')\n  var buf = g:RunVimInTerminal('-S XTest_redraw_cpo', {'rows': 6})\n  term_sendkeys(buf, \"V:\")\n  g:VerifyScreenDump(buf, 'Test_vim9_no_redraw', {})\n\n  # clean up\n  term_sendkeys(buf, \"\\<Esc>u\")\n  g:StopVimInTerminal(buf)\nenddef\n\nfunc Test_reject_declaration()\n  CheckScreendump\n  call Run_test_reject_declaration()\nendfunc\n\ndef Run_test_reject_declaration()\n  var buf = g:RunVimInTerminal('', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd var x: number\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_1', {})\n  term_sendkeys(buf, \":\\<CR>\")\n  term_sendkeys(buf, \":vim9cmd g:foo = 123 | echo g:foo\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_2', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_minimal_command_name_length()\n  var names = [\n       'cons',\n       'brea',\n       'cat',\n       'catc',\n       'con',\n       'cont',\n       'conti',\n       'contin',\n       'continu',\n       'el',\n       'els',\n       'elsei',\n       'endfo',\n       'en',\n       'end',\n       'endi',\n       'endw',\n       'endt',\n       'endtr',\n       'exp',\n       'expo',\n       'expor',\n       'fina',\n       'finall',\n       'fini',\n       'finis',\n       'imp',\n       'impo',\n       'impor',\n       'retu',\n       'retur',\n       'th',\n       'thr',\n       'thro',\n       'wh',\n       'whi',\n       'whil',\n      ]\n  for name in names\n    v9.CheckDefAndScriptFailure([name .. ' '], 'E1065:')\n  endfor\n\n  var lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endd\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n  lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endde\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\nenddef\n\ndef Test_unset_any_variable()\n  var lines =<< trim END\n    var name: any\n    assert_equal(0, name)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_define_func_at_command_line()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_define_func_at_command_line()\nendfunc\n\ndef Run_Test_define_func_at_command_line()\n  # run in a separate Vim instance to avoid the script context\n  var lines =<< trim END\n    func CheckAndQuit()\n      call assert_fails('call Afunc()', 'E117: Unknown function: Bfunc')\n      call writefile(['errors: ' .. string(v:errors)], 'Xdidcmd')\n    endfunc\n  END\n  writefile([''], 'Xdidcmd', 'D')\n  writefile(lines, 'XcallFunc', 'D')\n  var buf = g:RunVimInTerminal('-S XcallFunc', {rows: 6})\n  # define Afunc() on the command line\n  term_sendkeys(buf, \":def Afunc()\\<CR>Bfunc()\\<CR>enddef\\<CR>\")\n  term_sendkeys(buf, \":call CheckAndQuit()\\<CR>\")\n  g:WaitForAssert(() => assert_equal(['errors: []'], readfile('Xdidcmd')))\n\n  call g:StopVimInTerminal(buf)\nenddef\n\ndef Test_script_var_scope()\n  var lines =<< trim END\n      vim9script\n      if true\n        if true\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      if true\n        if false\n          var one = 'one'\n          echo one\n        else\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 10)\n\n  lines =<< trim END\n      vim9script\n      while true\n        var one = 'one'\n        echo one\n        break\n      endwhile\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      for i in range(1)\n        var one = 'one'\n        echo one\n      endfor\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        assert_equal('one', one)\n      }\n      assert_false(exists('one'))\n      assert_false(exists('s:one'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        echo one\n      }\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\nenddef\n\ndef Test_catch_exception_in_callback()\n  var lines =<< trim END\n    vim9script\n    def Callback(...l: list<any>)\n      try\n        var x: string\n        var y: string\n        # this error should be caught with CHECKLEN\n        var sl = ['']\n        [x, y] = sl\n      catch\n        g:caught = 'yes'\n      endtry\n    enddef\n    popup_menu('popup', {callback: Callback})\n    feedkeys(\"\\r\", 'xt')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  unlet g:caught\nenddef\n\ndef Test_no_unknown_error_after_error()\n  if !has('unix') || !has('job')\n    throw 'Skipped: not unix of missing +job feature'\n  endif\n  # FIXME: this check should not be needed\n  if has('win32')\n    throw 'Skipped: does not work on MS-Windows'\n  endif\n  var lines =<< trim END\n      vim9script\n      var source: list<number>\n      def Out_cb(...l: list<any>)\n          eval [][0]\n      enddef\n      def Exit_cb(...l: list<any>)\n          sleep 1m\n          g:did_call_exit_cb = true\n          source += l\n      enddef\n      var myjob = job_start('echo burp', {out_cb: Out_cb, exit_cb: Exit_cb, mode: 'raw'})\n      while job_status(myjob) == 'run'\n        sleep 10m\n      endwhile\n      # wait for Exit_cb() to be called\n      for x in range(100)\n        if exists('g:did_call_exit_cb')\n          unlet g:did_call_exit_cb\n          break\n        endif\n        sleep 10m\n      endfor\n  END\n  writefile(lines, 'Xdef', 'D')\n  assert_fails('so Xdef', ['E684:', 'E1012:'])\nenddef\n\ndef InvokeNormal()\n  exe \"norm! :m+1\\r\"\nenddef\n\ndef Test_invoke_normal_in_visual_mode()\n  xnoremap <F3> <Cmd>call <SID>InvokeNormal()<CR>\n  new\n  setline(1, ['aaa', 'bbb'])\n  feedkeys(\"V\\<F3>\", 'xt')\n  assert_equal(['bbb', 'aaa'], getline(1, 2))\n  xunmap <F3>\nenddef\n\ndef Test_white_space_after_command()\n  var lines =<< trim END\n    exit_cb: Func})\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\n\n  lines =<< trim END\n    e#\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\nenddef\n\ndef Test_script_var_gone_when_sourced_twice()\n  var lines =<< trim END\n      vim9script\n      if exists('g:guard')\n        finish\n      endif\n      g:guard = 1\n      var name = 'thename'\n      def g:GetName(): string\n        return name\n      enddef\n      def g:SetName(arg: string)\n        name = arg\n      enddef\n  END\n  writefile(lines, 'XscriptTwice.vim', 'D')\n  so XscriptTwice.vim\n  assert_equal('thename', g:GetName())\n  g:SetName('newname')\n  assert_equal('newname', g:GetName())\n  so XscriptTwice.vim\n  assert_fails('call g:GetName()', 'E1149:')\n  assert_fails('call g:SetName(\"x\")', 'E1149:')\n\n  delfunc g:GetName\n  delfunc g:SetName\n  unlet g:guard\nenddef\n\ndef Test_unsupported_commands()\n  var lines =<< trim END\n      ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :1ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n      :1k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:')\n\n  lines =<< trim END\n    t\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    x\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    xit\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    Print\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: Print', 'E492: Not an editor command: Print'])\n\n  lines =<< trim END\n    mode 4\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: mode 4', 'E492: Not an editor command: mode 4'])\nenddef\n\ndef Test_mapping_line_number()\n  var lines =<< trim END\n      vim9script\n      def g:FuncA()\n          # Some comment\n          FuncB(0)\n      enddef\n          # Some comment\n      def FuncB(\n          # Some comment\n          n: number\n      )\n          exe 'nno '\n              # Some comment\n              .. '<F3> a'\n              .. 'b'\n              .. 'c'\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n  var res = execute('verbose nmap <F3>')\n  assert_match('No mapping found', res)\n\n  g:FuncA()\n  res = execute('verbose nmap <F3>')\n  assert_match(' <F3> .* abc.*Last set from .*XScriptSuccess\\d\\+ line 11', res)\n\n  nunmap <F3>\n  delfunc g:FuncA\nenddef\n\ndef Test_option_set()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set foldlevel  =11\n      call assert_equal(11, &foldlevel)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set foldlevel\n  set foldlevel=12\n  assert_equal(12, &foldlevel)\n  set foldlevel+=2\n  assert_equal(14, &foldlevel)\n  set foldlevel-=3\n  assert_equal(11, &foldlevel)\n\n  lines =<< trim END\n      set foldlevel =1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: =1')\n\n  lines =<< trim END\n      set foldlevel +=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: +=1')\n\n  lines =<< trim END\n      set foldlevel ^=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: ^=1')\n\n  lines =<< trim END\n      set foldlevel -=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: -=1')\n\n  set foldlevel&\nenddef\n\ndef Test_option_modifier()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set hlsearch &  hlsearch  !\n      call assert_equal(1, &hlsearch)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set hlsearch\n  set hlsearch!\n  assert_equal(false, &hlsearch)\n\n  set hlsearch\n  set hlsearch&\n  assert_equal(false, &hlsearch)\n\n  lines =<< trim END\n      set hlsearch &\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: &')\n\n  lines =<< trim END\n      set hlsearch   !\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: !')\n\n  set hlsearch&\nenddef\n\n\" This must be called last, it may cause following :def functions to fail\ndef Test_xxx_echoerr_line_number()\n  var lines =<< trim END\n      echoerr 'some'\n         .. ' error'\n         .. ' continued'\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'some error continued', 1)\nenddef\n\nfunc Test_debug_with_lambda()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_with_lambda()\nendfunc\n\ndef Run_Test_debug_with_lambda()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var n = 0\n        echo [0]->filter((_, v) => v == n)\n      enddef\n      breakadd func Func\n      Func()\n  END\n  writefile(lines, 'XdebugFunc', 'D')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:WaitForAssert(() => assert_match('\\[0\\]', term_getline(buf, 5)))\n\n  g:StopVimInTerminal(buf)\nenddef\n\nfunc Test_debug_running_out_of_lines()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_running_out_of_lines()\nendfunc\n\ndef Run_Test_debug_running_out_of_lines()\n  var lines =<< trim END\n      vim9script\n      def Crash()\n          #\n          #\n          #\n          #\n          #\n          #\n          #\n          if true\n              #\n          endif\n      enddef\n      breakadd func Crash\n      Crash()\n  END\n  writefile(lines, 'XdebugFunc', 'D')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"next\\<CR>\")\n  g:TermWait(buf)\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:TermWait(buf)\n\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_ambigous_command_error()\n  var lines =<< trim END\n      vim9script\n      command CmdA echomsg 'CmdA'\n      command CmdB echomsg 'CmdB'\n      Cmd\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 4)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        Cmd\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 1)\n\n  lines =<< trim END\n      vim9script\n      nnoremap <F3> <ScriptCmd>Cmd<CR>\n      feedkeys(\"\\<F3>\", 'xt')\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 3)\n\n  delcommand CmdA\n  delcommand CmdB\n  nunmap <F3>\nenddef\n\n\" Execute this near the end, profiling doesn't stop until Vim exits.\n\" This only tests that it works, not the profiling output.\ndef Test_profile_with_lambda()\n  CheckFeature profile\n\n  var lines =<< trim END\n      vim9script\n\n      def ProfiledWithLambda()\n        var n = 3\n        echo [[1, 2], [3, 4]]->filter((_, l) => l[0] == n)\n      enddef\n\n      def ProfiledNested()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def g:ProfiledNestedProfiled()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def Profile()\n        ProfiledWithLambda()\n        ProfiledNested()\n\n        # Also profile the nested function.  Use a different function, although\n        # the contents is the same, to make sure it was not already compiled.\n        profile func *\n        g:ProfiledNestedProfiled()\n\n        profdel func *\n        profile pause\n      enddef\n\n      var result = 'done'\n      try\n        # mark functions for profiling now to avoid E1271\n        profile start Xprofile.log\n        profile func ProfiledWithLambda\n        profile func ProfiledNested\n\n        Profile()\n      catch\n        result = 'failed: ' .. v:exception\n      finally\n        writefile([result], 'Xdidprofile')\n      endtry\n  END\n  writefile(lines, 'Xprofile.vim', 'D')\n  call system(g:GetVimCommand()\n        .. ' --clean'\n        .. ' -c \"so Xprofile.vim\"'\n        .. ' -c \"qall!\"')\n  call assert_equal(0, v:shell_error)\n\n  assert_equal(['done'], readfile('Xdidprofile'))\n  assert_true(filereadable('Xprofile.log'))\n  delete('Xdidprofile')\n  delete('Xprofile.log')\nenddef\n\nfunc Test_misplaced_type()\n  CheckRunVimInTerminal\n  call Run_Test_misplaced_type()\nendfunc\n\ndef Run_Test_misplaced_type()\n  writefile(['let g:somevar = \"asdf\"'], 'XTest_misplaced_type', 'D')\n  var buf = g:RunVimInTerminal('-S XTest_misplaced_type', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd echo islocked('somevar: string')\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_misplaced_type', {})\n\n  g:StopVimInTerminal(buf)\nenddef\n\n\" Ensure echo doesn't crash when stringifying empty variables.\ndef Test_echo_uninit_variables()\n  var res: string\n\n  var var_bool: bool\n  var var_num: number\n  var var_float: float\n  var Var_func: func\n  var var_string: string\n  var var_blob: blob\n  var var_list: list<any>\n  var var_dict: dict<any>\n\n  redir => res\n  echo var_bool\n  echo var_num\n  echo var_float\n  echo Var_func\n  echo var_string\n  echo var_blob\n  echo var_list\n  echo var_dict\n  redir END\n\n  assert_equal(['false', '0', '0.0', 'function()', '', '0z', '[]', '{}'], res->split('\\n'))\n\n  if has('job')\n    var var_job: job\n    var var_channel: channel\n\n    redir => res\n    echo var_job\n    echo var_channel\n    redir END\n\n    assert_equal(['no process', 'channel fail'], res->split('\\n'))\n  endif\nenddef\n\n\" Keep this last, it messes up highlighting.\ndef Test_substitute_cmd()\n  new\n  setline(1, 'something')\n  :substitute(some(other(\n  assert_equal('otherthing', getline(1))\n  bwipe!\n\n  # also when the context is Vim9 script\n  var lines =<< trim END\n    vim9script\n    new\n    setline(1, 'something')\n    :substitute(some(other(\n    assert_equal('otherthing', getline(1))\n    bwipe!\n  END\n  writefile(lines, 'Xvim9lines', 'D')\n  source Xvim9lines\nenddef\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9cmds.c: Dealing with commands of a compiled function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Get the index of the current instruction.\n * This compensates for a preceding ISN_CMDMOD and ISN_PROF_START.\n */\n    static int\ncurrent_instr_idx(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tidx = instr->ga_len;\n\n    while (idx > 0)\n    {\n\tif (cctx->ctx_has_cmdmod && ((isn_T *)instr->ga_data)[idx - 1]\n\t\t\t\t\t\t       .isn_type == ISN_CMDMOD)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#ifdef FEAT_PROFILE\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_PROF_START)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#endif\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_DEBUG)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n\tbreak;\n    }\n    return idx;\n}\n/*\n * Remove local variables above \"new_top\".\n * Do this by clearing the name.  If \"keep\" is TRUE do not reset the length, a\n * closure may still need location of the variable.\n */\n    static void\nunwind_locals(cctx_T *cctx, int new_top, int keep)\n{\n    if (cctx->ctx_locals.ga_len > new_top)\n\tfor (int idx = new_top; idx < cctx->ctx_locals.ga_len; ++idx)\n\t{\n\t    lvar_T *lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\t    VIM_CLEAR(lvar->lv_name);\n\t}\n    if (!keep)\n\tcctx->ctx_locals.ga_len = new_top;\n}\n\n/*\n * Free all local variables.\n */\n    void\nfree_locals(cctx_T *cctx)\n{\n    unwind_locals(cctx, 0, FALSE);\n    ga_clear(&cctx->ctx_locals);\n}\n\n\n/*\n * Check if \"name\" can be \"unlet\".\n */\n    int\ncheck_vim9_unlet(char_u *name)\n{\n    if (*name == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), \"unlet\");\n\treturn FAIL;\n    }\n\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\t// \"unlet s:var\" is allowed in legacy script.\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_unlet(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep UNUSED,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    char_u\t*p = lvp->ll_name;\n    int\t\tcc = *name_end;\n    int\t\tret = OK;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    *name_end = NUL;\n    if (*p == '$')\n    {\n\t// :unlet $ENV_VAR\n\tret = generate_UNLET(cctx, ISN_UNLETENV, p + 1, eap->forceit);\n    }\n    else if (vim_strchr(p, '.') != NULL || vim_strchr(p, '[') != NULL)\n    {\n\tlhs_T\t    lhs;\n\n\t// This is similar to assigning: lookup the list/dict, compile the\n\t// idx/key.  Then instead of storing the value unlet the item.\n\t// unlet {list}[idx]\n\t// unlet {dict}[key]  dict.key\n\t//\n\t// Figure out the LHS type and other properties.\n\t//\n\tret = compile_lhs(p, &lhs, CMD_unlet, FALSE, FALSE, 0, cctx);\n\n\t// Use the info in \"lhs\" to unlet the item at the index in the\n\t// list or dict.\n\tif (ret == OK)\n\t{\n\t    if (!lhs.lhs_has_index)\n\t    {\n\t\tsemsg(_(e_cannot_unlet_imported_item_str), p);\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = compile_assign_unlet(p, &lhs, FALSE, &t_void, cctx);\n\t}\n\n\tvim_free(lhs.lhs_name);\n    }\n    else if (check_vim9_unlet(p) == FAIL)\n    {\n\tret = FAIL;\n    }\n    else\n    {\n\t// Normal name.  Only supports g:, w:, t: and b: namespaces.\n\tret = generate_UNLET(cctx, ISN_UNLET, p, eap->forceit);\n    }\n\n    *name_end = cc;\n    return ret;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\n\t    // For \"d.member\" put the local variable on the stack, it will be\n\t    // passed to ex_lockvar() indirectly.\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}\n\n/*\n * compile \"unlet var\", \"lock var\" and \"unlock var\"\n * \"arg\" points to \"var\".\n */\n    char_u *\ncompile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    int\t    deep = 0;\n    char_u  *p = arg;\n\n    if (eap->cmdidx != CMD_unlet)\n    {\n\tif (eap->forceit)\n\t    deep = -1;\n\telse if (vim_isdigit(*p))\n\t{\n\t    deep = getdigits(&p);\n\t    p = skipwhite(p);\n\t}\n\telse\n\t    deep = 2;\n    }\n\n    ex_unletlock(eap, p, deep, GLV_NO_AUTOLOAD | GLV_COMPILING,\n\t    eap->cmdidx == CMD_unlet ? compile_unlet : compile_lock_unlock,\n\t    cctx);\n    return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n}\n\n/*\n * Generate a jump to the \":endif\"/\":endfor\"/\":endwhile\"/\":finally\"/\":endtry\".\n * \"funcref_idx\" is used for JUMP_WHILE_FALSE\n */\n    static int\ncompile_jump_to_end(\n\tendlabel_T  **el,\n\tjumpwhen_T  when,\n\tint\t    funcref_idx,\n\tcctx_T\t    *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);\n\n    if (endlabel == NULL)\n\treturn FAIL;\n    endlabel->el_next = *el;\n    *el = endlabel;\n    endlabel->el_end_label = instr->ga_len;\n\n    if (when == JUMP_WHILE_FALSE)\n\tgenerate_WHILE(cctx, funcref_idx);\n    else\n\tgenerate_JUMP(cctx, when, 0);\n    return OK;\n}\n\n    static void\ncompile_fill_jump_to_end(endlabel_T **el, int jump_where, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\tisn_T\t    *isn;\n\n\tisn = ((isn_T *)instr->ga_data) + cur->el_end_label;\n\tisn->isn_arg.jump.jump_where = jump_where;\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n    static void\ncompile_free_jump_to_end(endlabel_T **el)\n{\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n/*\n * Create a new scope and set up the generic items.\n */\n    static scope_T *\nnew_scope(cctx_T *cctx, scopetype_T type)\n{\n    scope_T *scope = ALLOC_CLEAR_ONE(scope_T);\n\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_outer = cctx->ctx_scope;\n    cctx->ctx_scope = scope;\n    scope->se_type = type;\n    scope->se_local_count = cctx->ctx_locals.ga_len;\n    if (scope->se_outer != NULL)\n\tscope->se_loop_depth = scope->se_outer->se_loop_depth;\n    return scope;\n}\n\n/*\n * Free the current scope and go back to the outer scope.\n */\n    void\ndrop_scope(cctx_T *cctx)\n{\n    scope_T *scope = cctx->ctx_scope;\n\n    if (scope == NULL)\n    {\n\tiemsg(\"calling drop_scope() without a scope\");\n\treturn;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    switch (scope->se_type)\n    {\n\tcase IF_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_if.is_end_label); break;\n\tcase FOR_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_for.fs_end_label); break;\n\tcase WHILE_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_while.ws_end_label); break;\n\tcase TRY_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_try.ts_end_label); break;\n\tcase NO_SCOPE:\n\tcase BLOCK_SCOPE:\n\t    break;\n    }\n    vim_free(scope);\n}\n\n    static int\nmisplaced_cmdmod(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (cctx->ctx_has_cmdmod\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type\n\t\t\t\t\t\t\t\t == ISN_CMDMOD)\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * compile \"if expr\"\n *\n * \"if expr\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE end\n *\t... body ...\n * end:\n *\n * \"if expr | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n *\n * \"if expr1 | elseif expr2 | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE elseif\n *\t... body ...\n *\tJUMP_ALWAYS end\n * elseif:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n */\n    char_u *\ncompile_if(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count = instr->ga_len;\n    scope_T\t*scope;\n    skip_T\tskip_save = cctx->ctx_skip;\n    ppconst_T\tppconst;\n\n    CLEAR_FIELD(ppconst);\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression results in a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tclear_ppconst(&ppconst);\n\tif (error)\n\t    return NULL;\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n    }\n\n    // CMDMOD_REV must come before the jump\n    generate_undo_cmdmods(cctx);\n\n    scope = new_scope(cctx, IF_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_skip_save = skip_save;\n    // \"is_had_return\" will be reset if any block does not end in :return\n    scope->se_u.se_if.is_had_return = TRUE;\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n    else\n\tscope->se_u.se_if.is_if_label = -1;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t\t      && skip_save != SKIP_YES)\n    {\n\t// generated a profile start, need to generate a profile end, since it\n\t// won't be done after returning\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_END);\n\tcctx->ctx_skip = SKIP_YES;\n    }\n#endif\n\n    return p;\n}\n\n    char_u *\ncompile_elseif(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n    ppconst_T\tppconst;\n    skip_T\tsave_skip = cctx->ctx_skip;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_elseif_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n\n    if (cctx->ctx_skip == SKIP_NOT)\n    {\n\t// previous block was executed, this one and following will not\n\tcctx->ctx_skip = SKIP_YES;\n\tscope->se_u.se_if.is_seen_skip_not = TRUE;\n    }\n    if (scope->se_u.se_if.is_seen_skip_not)\n    {\n\t// A previous block was executed, skip over expression and bail out.\n\t// Do not count the \"elseif\" for profiling and cmdmod\n\tinstr->ga_len = current_instr_idx(cctx);\n\n\tskip_expr_cctx(&p, cctx);\n\treturn p;\n    }\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\tint\t    moved_cmdmod = FALSE;\n\tint\t    saved_debug = FALSE;\n\tisn_T\t    debug_isn;\n\n\t// Move any CMDMOD instruction to after the jump\n\tif (((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type == ISN_CMDMOD)\n\t{\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] =\n\t\t\t\t  ((isn_T *)instr->ga_data)[instr->ga_len - 1];\n\t    --instr->ga_len;\n\t    moved_cmdmod = TRUE;\n\t}\n\n\t// Remove the already generated ISN_DEBUG, it is written below the\n\t// ISN_FOR instruction.\n\tif (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n\t{\n\t    --instr->ga_len;\n\t    debug_isn = ((isn_T *)instr->ga_data)[instr->ga_len];\n\t    saved_debug = TRUE;\n\t}\n\n\tif (compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t JUMP_ALWAYS, 0, cctx) == FAIL)\n\t    return NULL;\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\n\tif (moved_cmdmod)\n\t    ++instr->ga_len;\n\n\tif (saved_debug)\n\t{\n\t    // move the debug instruction here\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] = debug_isn;\n\t    ++instr->ga_len;\n\t}\n    }\n\n    // compile \"expr\"; if we know it evaluates to FALSE skip the block\n    CLEAR_FIELD(ppconst);\n    if (cctx->ctx_skip == SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    // the previous block was skipped, need to profile this line\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    // the previous block was skipped, may want to debug this line\n\t    generate_instr_debug(cctx);\n    }\n\n    instr_count = instr->ga_len;\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    cctx->ctx_skip = save_skip;\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tclear_ppconst(&ppconst);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (scope->se_skip_save == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression result is a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tif (error)\n\t{\n\t    clear_ppconst(&ppconst);\n\t    return NULL;\n\t}\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n\tclear_ppconst(&ppconst);\n\tscope->se_u.se_if.is_if_label = -1;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_else(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_else_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n    scope->se_u.se_if.is_seen_else = TRUE;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE)\n    {\n\tif (cctx->ctx_skip == SKIP_NOT\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    // the previous block was executed, do not count \"else\" for\n\t    // profiling\n\t    --instr->ga_len;\n\tif (cctx->ctx_skip == SKIP_YES && !scope->se_u.se_if.is_seen_skip_not)\n\t{\n\t    // the previous block was not executed, this one will, do count the\n\t    // \"else\" for profiling\n\t    cctx->ctx_skip = SKIP_NOT;\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    generate_instr(cctx, ISN_PROF_START);\n\t    cctx->ctx_skip = SKIP_YES;\n\t}\n    }\n#endif\n\n    if (!scope->se_u.se_if.is_seen_skip_not && scope->se_skip_save != SKIP_YES)\n    {\n\t// jump from previous block to the end, unless the else block is empty\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (!cctx->ctx_had_return\n\t\t    && compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t JUMP_ALWAYS, 0, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (scope->se_u.se_if.is_if_label >= 0)\n\t    {\n\t\t// previous \"if\" or \"elseif\" jumps here\n\t\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t\tscope->se_u.se_if.is_if_label = -1;\n\t    }\n\t}\n\n\tif (cctx->ctx_skip != SKIP_UNKNOWN)\n\t    cctx->ctx_skip = cctx->ctx_skip == SKIP_YES ? SKIP_NOT : SKIP_YES;\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_endif(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    ifscope_T\t*ifscope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_endif_without_if));\n\treturn NULL;\n    }\n    ifscope = &scope->se_u.se_if;\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    if (!cctx->ctx_had_return)\n\tifscope->is_had_return = FALSE;\n\n    if (scope->se_u.se_if.is_if_label >= 0)\n    {\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n    }\n    // Fill in the \"end\" label in jumps at the end of the blocks.\n    compile_fill_jump_to_end(&ifscope->is_end_label, instr->ga_len, cctx);\n\n#ifdef FEAT_PROFILE\n    // even when skipping we count the endif as executed, unless the block it's\n    // in is skipped\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t    && scope->se_skip_save != SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_START);\n    }\n#endif\n    cctx->ctx_skip = scope->se_skip_save;\n\n    // If all the blocks end in :return and there is an :else then the\n    // had_return flag is set.\n    cctx->ctx_had_return = ifscope->is_had_return && ifscope->is_seen_else;\n\n    drop_scope(cctx);\n    return arg;\n}\n\n/*\n * Save the info needed for ENDLOOP.  Used by :for and :while.\n */\n    static void\ncompile_fill_loop_info(loop_info_T *loop_info, int funcref_idx, cctx_T *cctx)\n{\n    loop_info->li_funcref_idx = funcref_idx;\n    loop_info->li_local_count = cctx->ctx_locals.ga_len;\n    loop_info->li_closure_count = cctx->ctx_closure_count;\n}\n\n/*\n * Compile \"for var in expr\":\n *\n * Produces instructions:\n *       STORE -1 in loop-idx\tSet index to -1\n *       EVAL expr\t\tResult of \"expr\" on top of stack\n * top:  FOR loop-idx, end\tIncrement index, use list on bottom of stack\n *\t\t\t\t- if beyond end, jump to \"end\"\n *\t\t\t\t- otherwise get item from list and push it\n *\t\t\t\t- store ec_funcrefs in var \"loop-idx\" + 1\n *       STORE var\t\tStore item in \"var\"\n *       ... body ...\n *       ENDLOOP funcref-idx off count\tOnly if closure uses local var\n *       JUMP top\t\t\tJump back to repeat\n * end:\t DROP\t\t\t\tDrop the result of \"expr\"\n *\n * Compile \"for [var1, var2] in expr\" - as above, but instead of \"STORE var\":\n *\t UNPACK 2\t\tSplit item in 2\n *       STORE var1\t\tStore item in \"var1\"\n *       STORE var2\t\tStore item in \"var2\"\n */\n    char_u *\ncompile_for(char_u *arg_start, cctx_T *cctx)\n{\n    char_u\t*arg;\n    char_u\t*arg_end;\n    char_u\t*name = NULL;\n    char_u\t*p;\n    char_u\t*wp;\n    int\t\tvar_count = 0;\n    int\t\tvar_list = FALSE;\n    int\t\tsemicolon = FALSE;\n    size_t\tvarlen;\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope;\n    forscope_T\t*forscope;\n    lvar_T\t*loop_lvar;\t// loop iteration variable\n    int\t\tloop_lvar_idx;\n    lvar_T\t*funcref_lvar;\n    int\t\tfuncref_lvar_idx;\n    lvar_T\t*var_lvar;\t// variable for \"var\"\n    type_T\t*vartype;\n    type_T\t*item_type = &t_any;\n    int\t\tidx;\n    int\t\tprev_lnum = cctx->ctx_prev_lnum;\n\n    p = skip_var_list(arg_start, TRUE, &var_count, &semicolon, FALSE);\n    if (p == NULL)\n\treturn NULL;\n    if (var_count == 0)\n\tvar_count = 1;\n    else\n\tvar_list = TRUE;  // can also be a list of one variable\n\n    // consume \"in\"\n    wp = p;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n    if (STRNCMP(p, \"in\", 2) != 0 || !IS_WHITE_OR_NUL(p[2]))\n    {\n\tif (*p == ':' && wp != p)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), p);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn NULL;\n    }\n    wp = p + 2;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n\n    // Find the already generated ISN_DEBUG to get the line number for the\n    // instruction written below the ISN_FOR instruction.\n    if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n    {\n\tprev_lnum = ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t .isn_arg.debug.dbg_break_lnum;\n    }\n\n    scope = new_scope(cctx, FOR_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    if (scope->se_loop_depth == MAX_LOOP_DEPTH)\n    {\n\temsg(_(e_loop_nesting_too_deep));\n\treturn NULL;\n    }\n    ++scope->se_loop_depth;\n    forscope = &scope->se_u.se_for;\n\n    // Reserve a variable to store the loop iteration counter and initialize it\n    // to -1.\n    loop_lvar = reserve_local(cctx, (char_u *)\"\", 0, ASSIGN_VAR, &t_number);\n    if (loop_lvar == NULL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;  // out of memory\n    }\n    // get the index before a following reserve_local() makes the lval invalid\n    loop_lvar_idx = loop_lvar->lv_idx;\n    generate_STORENR(cctx, loop_lvar_idx, -1);\n\n    // Reserve a variable to store ec_funcrefs.ga_len, used in ISN_ENDLOOP.\n    // The variable index is always the loop var index plus one.\n    // It is not used when no closures are encountered, we don't know yet.\n    funcref_lvar = reserve_local(cctx, (char_u *)\"\", 0, ASSIGN_VAR, &t_number);\n    if (funcref_lvar == NULL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;  // out of memory\n    }\n    // get the index before a following reserve_local() makes the lval invalid\n    funcref_lvar_idx = funcref_lvar->lv_idx;\n\n    // compile \"expr\", it remains on the stack until \"endfor\"\n    arg = p;\n    if (compile_expr0(&arg, cctx) == FAIL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;\n    }\n    arg_end = arg;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// If we know the type of \"var\" and it is not a supported type we can\n\t// give an error now.\n\tvartype = get_type_on_stack(cctx, 0);\n\tif (vartype->tt_type != VAR_LIST\n\t\t&& vartype->tt_type != VAR_STRING\n\t\t&& vartype->tt_type != VAR_BLOB\n\t\t&& vartype->tt_type != VAR_ANY\n\t\t&& vartype->tt_type != VAR_UNKNOWN)\n\t{\n\t    semsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t       vartype_name(vartype->tt_type));\n\t    drop_scope(cctx);\n\t    return NULL;\n\t}\n\n\tif (vartype->tt_type == VAR_STRING)\n\t    item_type = &t_string;\n\telse if (vartype->tt_type == VAR_BLOB)\n\t    item_type = &t_number;\n\telse if (vartype->tt_type == VAR_LIST\n\t\t\t\t     && vartype->tt_member->tt_type != VAR_ANY)\n\t{\n\t    if (!var_list)\n\t\titem_type = vartype->tt_member;\n\t    else if (vartype->tt_member->tt_type == VAR_LIST\n\t\t\t  && vartype->tt_member->tt_member->tt_type != VAR_ANY)\n\t\titem_type = vartype->tt_member->tt_member;\n\t}\n\n\t// CMDMOD_REV must come before the FOR instruction.\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"for_end\" is set when \":endfor\" is found\n\tforscope->fs_top_label = current_instr_idx(cctx);\n\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t{\n\t    int\t\tsave_prev_lnum = cctx->ctx_prev_lnum;\n\t    isn_T\t*isn;\n\n\t    // Add ISN_DEBUG here, before deciding to end the loop.  There will\n\t    // be another ISN_DEBUG before the next instruction.\n\t    // Use the prev_lnum from the ISN_DEBUG instruction removed above.\n\t    // Increment the variable count so that the loop variable can be\n\t    // inspected.\n\t    cctx->ctx_prev_lnum = prev_lnum;\n\t    isn = generate_instr_debug(cctx);\n\t    ++isn->isn_arg.debug.dbg_var_names_len;\n\t    cctx->ctx_prev_lnum = save_prev_lnum;\n\t}\n\n\tgenerate_FOR(cctx, loop_lvar_idx);\n\n\targ = arg_start;\n\tif (var_list)\n\t{\n\t    generate_UNPACK(cctx, var_count, semicolon);\n\t    arg = skipwhite(arg + 1);\t// skip white after '['\n\n\t    // drop the list item\n\t    --cctx->ctx_type_stack.ga_len;\n\n\t    // add type of the items\n\t    for (idx = 0; idx < var_count; ++idx)\n\t    {\n\t\ttype_T *type = (semicolon && idx == 0) ? vartype : item_type;\n\n\t\tif (push_type_stack(cctx, type) == FAIL)\n\t\t{\n\t\t    drop_scope(cctx);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\n\tfor (idx = 0; idx < var_count; ++idx)\n\t{\n\t    assign_dest_T\tdest = dest_local;\n\t    int\t\t\topt_flags = 0;\n\t    int\t\t\tvimvaridx = -1;\n\t    type_T\t\t*type = &t_any;\n\t    type_T\t\t*lhs_type = &t_any;\n\t    where_T\t\twhere = WHERE_INIT;\n\n\t    p = skip_var_one(arg, FALSE);\n\t    varlen = p - arg;\n\t    name = vim_strnsave(arg, varlen);\n\t    if (name == NULL)\n\t\tgoto failed;\n\t    if (*p == ':')\n\t    {\n\t\tp = skipwhite(p + 1);\n\t\tlhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    }\n\n\t    if (get_var_dest(name, &dest, CMD_for, &opt_flags,\n\t\t\t\t\t      &vimvaridx, &type, cctx) == FAIL)\n\t\tgoto failed;\n\t    if (dest != dest_local)\n\t    {\n\t\tif (generate_store_var(cctx, dest, opt_flags, vimvaridx,\n\t\t\t\t\t\t     0, 0, type, name) == FAIL)\n\t\t    goto failed;\n\t    }\n\t    else if (varlen == 1 && *arg == '_')\n\t    {\n\t\t// Assigning to \"_\": drop the value.\n\t\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t\t    goto failed;\n\t    }\n\t    else\n\t    {\n\t\t// Script var is not supported.\n\t\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t\t{\n\t\t    emsg(_(e_cannot_use_script_variable_in_for_loop));\n\t\t    goto failed;\n\t\t}\n\n\t\tif (!valid_varname(arg, (int)varlen, FALSE))\n\t\t    goto failed;\n\t\tif (lookup_local(arg, varlen, NULL, cctx) == OK)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), arg);\n\t\t    goto failed;\n\t\t}\n\n\t\t// Reserve a variable to store \"var\".\n\t\twhere.wt_index = var_list ? idx + 1 : 0;\n\t\twhere.wt_variable = TRUE;\n\t\tif (lhs_type == &t_any)\n\t\t    lhs_type = item_type;\n\t\telse if (item_type != &t_unknown\n\t\t\t&& need_type_where(item_type, lhs_type, -1,\n\t\t\t\t\t    where, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto failed;\n\t\tvar_lvar = reserve_local(cctx, arg, varlen, ASSIGN_FINAL,\n\t\t\t\t\t\t\t\t     lhs_type);\n\t\tif (var_lvar == NULL)\n\t\t    // out of memory or used as an argument\n\t\t    goto failed;\n\n\t\tif (semicolon && idx == var_count - 1)\n\t\t    var_lvar->lv_type = vartype;\n\t\tgenerate_STORE(cctx, ISN_STORE, var_lvar->lv_idx, NULL);\n\t    }\n\n\t    if (*p == ',' || *p == ';')\n\t\t++p;\n\t    arg = skipwhite(p);\n\t    vim_free(name);\n\t}\n\n\t// remember the number of variables and closures, used for ENDLOOP\n\tcompile_fill_loop_info(&forscope->fs_loop_info, funcref_lvar_idx, cctx);\n\tforscope->fs_loop_info.li_depth = scope->se_loop_depth - 1;\n    }\n\n    return arg_end;\n\nfailed:\n    vim_free(name);\n    drop_scope(cctx);\n    return NULL;\n}\n\n/*\n * Used when ending a loop of :for and :while: Generate an ISN_ENDLOOP\n * instruction if any variable was declared that could be used by a new\n * closure.\n */\n    static int\ncompile_loop_end(loop_info_T *loop_info, cctx_T *cctx)\n{\n    if (cctx->ctx_locals.ga_len > loop_info->li_local_count\n\t    && cctx->ctx_closure_count > loop_info->li_closure_count)\n\treturn generate_ENDLOOP(cctx, loop_info);\n    return OK;\n}\n\n/*\n * compile \"endfor\"\n */\n    char_u *\ncompile_endfor(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope = cctx->ctx_scope;\n    forscope_T\t*forscope;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != FOR_SCOPE)\n    {\n\temsg(_(e_endfor_without_for));\n\treturn NULL;\n    }\n    forscope = &scope->se_u.se_for;\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// Handle the case that any local variables were declared that might be\n\t// used in a closure.\n\tif (compile_loop_end(&forscope->fs_loop_info, cctx) == FAIL)\n\t    return NULL;\n\n\tunwind_locals(cctx, scope->se_local_count, FALSE);\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, forscope->fs_top_label);\n\n\t// Fill in the \"end\" label in the FOR statement so it can jump here.\n\t// In debug mode an ISN_DEBUG was inserted.\n\tisn = ((isn_T *)instr->ga_data) + forscope->fs_top_label\n\t\t\t\t+ (cctx->ctx_compile_type == CT_DEBUG ? 1 : 0);\n\tisn->isn_arg.forloop.for_end = instr->ga_len;\n\n\t// Fill in the \"end\" label any BREAK statements\n\tcompile_fill_jump_to_end(&forscope->fs_end_label, instr->ga_len, cctx);\n\n\t// Below the \":for\" scope drop the \"expr\" list from the stack.\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    return NULL;\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * compile \"while expr\"\n *\n * Produces instructions:\n * top:  EVAL expr\t\t\tPush result of \"expr\"\n *\t WHILE funcref-idx  end\t\tJump if false\n *\t ... body ...\n *       ENDLOOP funcref-idx off count\tonly if closure uses local var\n *\t JUMP top\t\t\tJump back to repeat\n * end:\n *\n */\n    char_u *\ncompile_while(char_u *arg, cctx_T *cctx)\n{\n    char_u\t    *p = arg;\n    scope_T\t    *scope;\n    whilescope_T    *whilescope;\n    lvar_T\t    *funcref_lvar;\n    int\t\t    funcref_lvar_idx;\n\n    scope = new_scope(cctx, WHILE_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    if (scope->se_loop_depth == MAX_LOOP_DEPTH)\n    {\n\temsg(_(e_loop_nesting_too_deep));\n\treturn NULL;\n    }\n    ++scope->se_loop_depth;\n    whilescope = &scope->se_u.se_while;\n\n    // \"endwhile\" jumps back here, one before when profiling or using cmdmods\n    whilescope->ws_top_label = current_instr_idx(cctx);\n\n    // Reserve a variable to store ec_funcrefs.ga_len, used in ISN_ENDLOOP.\n    // It is not used when no closures are encountered, we don't know yet.\n    funcref_lvar = reserve_local(cctx, (char_u *)\"\", 0, ASSIGN_VAR, &t_number);\n    if (funcref_lvar == NULL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;  // out of memory\n    }\n    // get the index before a following reserve_local() makes the lval invalid\n    funcref_lvar_idx = funcref_lvar->lv_idx;\n\n    // remember the number of variables and closures, used for ENDLOOP\n    compile_fill_loop_info(&whilescope->ws_loop_info, funcref_lvar_idx, cctx);\n    whilescope->ws_loop_info.li_depth = scope->se_loop_depth - 1;\n\n    // compile \"expr\"\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return FAIL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"while_end\" is set when \":endwhile\" is found\n\tif (compile_jump_to_end(&whilescope->ws_end_label,\n\t\t\t     JUMP_WHILE_FALSE, funcref_lvar_idx, cctx) == FAIL)\n\t    return FAIL;\n    }\n\n    return p;\n}\n\n/*\n * compile \"endwhile\"\n */\n    char_u *\ncompile_endwhile(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n    if (scope == NULL || scope->se_type != WHILE_SCOPE)\n    {\n\temsg(_(e_endwhile_without_while));\n\treturn NULL;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\twhilescope_T\t*whilescope = &scope->se_u.se_while;\n\n\t// Handle the case that any local variables were declared that might be\n\t// used in a closure.\n\tif (compile_loop_end(&whilescope->ws_loop_info, cctx) == FAIL)\n\t    return NULL;\n\n\tunwind_locals(cctx, scope->se_local_count, FALSE);\n\n#ifdef FEAT_PROFILE\n\t// count the endwhile before jumping\n\tmay_generate_prof_end(cctx, cctx->ctx_lnum);\n#endif\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, scope->se_u.se_while.ws_top_label);\n\n\t// Fill in the \"end\" label in the WHILE statement so it can jump here.\n\t// And in any jumps for \":break\"\n\tcompile_fill_jump_to_end(&scope->se_u.se_while.ws_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * Get the current information about variables declared inside a loop.\n * Returns TRUE if there are any and fills \"lvi\".\n */\n    int\nget_loop_var_info(cctx_T *cctx, loopvarinfo_T *lvi)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    int\t\tprev_local_count = 0;\n\n    CLEAR_POINTER(lvi);\n    for (;;)\n    {\n\tloop_info_T\t*loopinfo;\n\tint\t\tcur_local_last;\n\tint\t\tstart_local_count;\n\n\twhile (scope != NULL && scope->se_type != WHILE_SCOPE\n\t\t\t\t\t\t&& scope->se_type != FOR_SCOPE)\n\t    scope = scope->se_outer;\n\tif (scope == NULL)\n\t    break;\n\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    loopinfo = &scope->se_u.se_while.ws_loop_info;\n\t    // :while reserves one variable for funcref count\n\t    cur_local_last = loopinfo->li_local_count - 1;\n\t}\n\telse\n\t{\n\t    loopinfo = &scope->se_u.se_for.fs_loop_info;\n\t    // :for reserves three variable: loop count, funcref count and loop\n\t    // var\n\t    cur_local_last = loopinfo->li_local_count - 3;\n\t}\n\n\tstart_local_count = loopinfo->li_local_count;\n\tif (cctx->ctx_locals.ga_len > start_local_count)\n\t{\n\t    lvi->lvi_loop[loopinfo->li_depth].var_idx =\n\t\t\t\t\t\t      (short)start_local_count;\n\t    lvi->lvi_loop[loopinfo->li_depth].var_count =\n\t\t\t  (short)(cctx->ctx_locals.ga_len - start_local_count\n\t\t\t\t\t\t\t   - prev_local_count);\n\t    if (lvi->lvi_depth == 0)\n\t\tlvi->lvi_depth = loopinfo->li_depth + 1;\n\t}\n\n\tscope = scope->se_outer;\n\tprev_local_count = cctx->ctx_locals.ga_len - cur_local_last;\n    }\n    return lvi->lvi_depth > 0;\n}\n\n/*\n * Get the index of the variable \"idx\" in a loop, if any.\n */\n    void\nget_loop_var_idx(cctx_T *cctx, int idx, lvar_T *lvar)\n{\n    loopvarinfo_T lvi;\n\n    lvar->lv_loop_depth = -1;\n    lvar->lv_loop_idx = -1;\n    if (get_loop_var_info(cctx, &lvi))\n    {\n\tint depth;\n\n\tfor (depth = lvi.lvi_depth - 1; depth >= 0; --depth)\n\t    if (idx >= lvi.lvi_loop[depth].var_idx\n\t\t    && idx < lvi.lvi_loop[depth].var_idx\n\t\t\t\t\t       + lvi.lvi_loop[depth].var_count)\n\t    {\n\t\tlvar->lv_loop_depth = depth;\n\t\tlvar->lv_loop_idx = lvi.lvi_loop[depth].var_idx;\n\t\treturn;\n\t    }\n    }\n}\n\n/*\n * Common for :break, :continue and :return\n */\n    static int\ncompile_find_scope(\n\tint\t    *loop_label,    // where to jump to or NULL\n\tendlabel_T  ***el,\t    // end label or NULL\n\tint\t    *try_scopes,    // :try scopes encountered or NULL\n\tchar\t    *error,\t    // error to use when no scope found\n\tcctx_T\t    *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n\n    for (;;)\n    {\n\tif (scope == NULL)\n\t{\n\t    if (error != NULL)\n\t\temsg(_(error));\n\t    return FAIL;\n\t}\n\tif (scope->se_type == FOR_SCOPE)\n\t{\n\t    if (compile_loop_end(&scope->se_u.se_for.fs_loop_info, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t    if (loop_label != NULL)\n\t\t*loop_label = scope->se_u.se_for.fs_top_label;\n\t    if (el != NULL)\n\t\t*el = &scope->se_u.se_for.fs_end_label;\n\t    break;\n\t}\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    if (compile_loop_end(&scope->se_u.se_while.ws_loop_info, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t    if (loop_label != NULL)\n\t\t*loop_label = scope->se_u.se_while.ws_top_label;\n\t    if (el != NULL)\n\t\t*el = &scope->se_u.se_while.ws_end_label;\n\t    break;\n\t}\n\tif (try_scopes != NULL && scope->se_type == TRY_SCOPE)\n\t    ++*try_scopes;\n\tscope = scope->se_outer;\n    }\n    return OK;\n}\n\n/*\n * compile \"continue\"\n */\n    char_u *\ncompile_continue(char_u *arg, cctx_T *cctx)\n{\n    int\t\ttry_scopes = 0;\n    int\t\tloop_label;\n\n    if (compile_find_scope(&loop_label, NULL, &try_scopes,\n\t\t\t\te_continue_without_while_or_for, cctx) == FAIL)\n\treturn NULL;\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.\n\tgenerate_TRYCONT(cctx, try_scopes, loop_label);\n    else\n\t// Jump back to the FOR or WHILE instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, loop_label);\n\n    return arg;\n}\n\n/*\n * compile \"break\"\n */\n    char_u *\ncompile_break(char_u *arg, cctx_T *cctx)\n{\n    int\t\ttry_scopes = 0;\n    endlabel_T\t**el;\n\n    if (compile_find_scope(NULL, &el, &try_scopes,\n\t\t\t\t   e_break_without_while_or_for, cctx) == FAIL)\n\treturn NULL;\n\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.  Then come to the next JUMP\n\t// intruction, which we don't know the index of yet.\n\tgenerate_TRYCONT(cctx, try_scopes, cctx->ctx_instr.ga_len + 1);\n\n    // Jump to the end of the FOR or WHILE loop.  The instruction index will be\n    // filled in later.\n    if (compile_jump_to_end(el, JUMP_ALWAYS, 0, cctx) == FAIL)\n\treturn FAIL;\n\n    return arg;\n}\n\n/*\n * compile \"{\" start of block\n */\n    char_u *\ncompile_block(char_u *arg, cctx_T *cctx)\n{\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return skipwhite(arg + 1);\n}\n\n/*\n * compile end of block: drop one scope\n */\n    void\ncompile_endblock(cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n\n    cctx->ctx_scope = scope->se_outer;\n    unwind_locals(cctx, scope->se_local_count, TRUE);\n    vim_free(scope);\n}\n\n/*\n * Compile \"try\".\n * Creates a new scope for the try-endtry, pointing to the first catch and\n * finally.\n * Creates another scope for the \"try\" block itself.\n * TRY instruction sets up exception handling at runtime.\n *\n *\t\"try\"\n *\t    TRY -> catch1, -> finally  push trystack entry\n *\t    ... try block\n *\t\"throw {exception}\"\n *\t    EVAL {exception}\n *\t    THROW\t\tcreate exception\n *\t    ... try block\n *\t\" catch {expr}\"\n *\t    JUMP -> finally\n * catch1:  PUSH exception\n *\t    EVAL {expr}\n *\t    MATCH\n *\t    JUMP nomatch -> catch2\n *\t    CATCH   remove exception\n *\t    ... catch block\n *\t\" catch\"\n *\t    JUMP -> finally\n * catch2:  CATCH   remove exception\n *\t    ... catch block\n *\t\" finally\"\n * finally:\n *\t    ... finally block\n *\t\" endtry\"\n *\t    ENDTRY  pop trystack entry, may rethrow\n */\n    char_u *\ncompile_try(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*try_scope;\n    scope_T\t*scope;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // scope that holds the jumps that go to catch/finally/endtry\n    try_scope = new_scope(cctx, TRY_SCOPE);\n    if (try_scope == NULL)\n\treturn NULL;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\t// \"try_catch\" is set when the first \":catch\" is found or when no catch\n\t// is found and \":finally\" is found.\n\t// \"try_finally\" is set when \":finally\" is found\n\t// \"try_endtry\" is set when \":endtry\" is found\n\ttry_scope->se_u.se_try.ts_try_label = instr->ga_len;\n\tif ((isn = generate_instr(cctx, ISN_TRY)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.tryref.try_ref = ALLOC_CLEAR_ONE(tryref_T);\n\tif (isn->isn_arg.tryref.try_ref == NULL)\n\t    return NULL;\n    }\n\n    // scope for the try block itself\n    scope = new_scope(cctx, BLOCK_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    return arg;\n}\n\n/*\n * Compile \"catch {expr}\".\n */\n    char_u *\ncompile_catch(char_u *arg, cctx_T *cctx UNUSED)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*p;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_catch_without_try));\n\treturn NULL;\n    }\n\n    if (scope->se_u.se_try.ts_caught_all)\n    {\n\temsg(_(e_catch_unreachable_after_catch_all));\n\treturn NULL;\n    }\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_try.ts_no_return = TRUE;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n#ifdef FEAT_PROFILE\n\t// the profile-start should be after the jump\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    --instr->ga_len;\n#endif\n\t// Jump from end of previous block to :finally or :endtry\n\tif (compile_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t JUMP_ALWAYS, 0, cctx) == FAIL)\n\t    return NULL;\n\n\t// End :try or :catch scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = instr->ga_len;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t{\n\t    // a \"throw\" that jumps here needs to be counted\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    // the \"catch\" is also counted\n\t    generate_instr(cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    generate_instr_debug(cctx);\n    }\n\n    p = skipwhite(arg);\n    if (ends_excmd2(arg, p))\n    {\n\tscope->se_u.se_try.ts_caught_all = TRUE;\n\tscope->se_u.se_try.ts_catch_label = 0;\n    }\n    else\n    {\n\tchar_u *end;\n\tchar_u *pat;\n\tchar_u *tofree = NULL;\n\tint\tdropped = 0;\n\tint\tlen;\n\n\t// Push v:exception, push {expr} and MATCH\n\tgenerate_instr_type(cctx, ISN_PUSHEXC, &t_string);\n\n\tend = skip_regexp_ex(p + 1, *p, TRUE, &tofree, &dropped, NULL);\n\tif (*end != *p)\n\t{\n\t    semsg(_(e_separator_mismatch_str), p);\n\t    vim_free(tofree);\n\t    return NULL;\n\t}\n\tif (tofree == NULL)\n\t    len = (int)(end - (p + 1));\n\telse\n\t    len = (int)(end - tofree);\n\tpat = vim_strnsave(tofree == NULL ? p + 1 : tofree, len);\n\tvim_free(tofree);\n\tp += len + 2 + dropped;\n\tif (pat == NULL)\n\t    return NULL;\n\tif (generate_PUSHS(cctx, &pat) == FAIL)\n\t    return NULL;\n\n\tif (generate_COMPARE(cctx, EXPR_MATCH, FALSE) == FAIL)\n\t    return NULL;\n\n\tscope->se_u.se_try.ts_catch_label = instr->ga_len;\n\tif (generate_JUMP(cctx, JUMP_IF_FALSE, 0) == FAIL)\n\t    return NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_CATCH) == NULL)\n\treturn NULL;\n\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return p;\n}\n\n    char_u *\ncompile_finally(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    int\t\tthis_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_finally_without_try));\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_finally != 0)\n\t{\n\t    emsg(_(e_multiple_finally));\n\t    return NULL;\n\t}\n\n\tthis_instr = instr->ga_len;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t{\n\t    // jump to the profile start of the \"finally\"\n\t    --this_instr;\n\n\t    // jump to the profile end above it\n\t    if (this_instr > 0 && ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t     .isn_type == ISN_PROF_END)\n\t\t--this_instr;\n\t}\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks.\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t     this_instr, cctx);\n\n\t// If there is no :catch then an exception jumps to :finally.\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = this_instr;\n\tisn->isn_arg.tryref.try_ref->try_finally = this_instr;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = this_instr;\n\t    scope->se_u.se_try.ts_catch_label = 0;\n\t}\n\tscope->se_u.se_try.ts_has_finally = TRUE;\n\tif (generate_instr(cctx, ISN_FINALLY) == NULL)\n\t    return NULL;\n    }\n\n    return arg;\n}\n\n    char_u *\ncompile_endtry(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*try_isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :catch or :finally\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\tif (scope == NULL)\n\t    emsg(_(e_endtry_without_try));\n\telse if (scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_endif));\n\treturn NULL;\n    }\n\n    try_isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (try_isn->isn_arg.tryref.try_ref->try_catch == 0\n\t\t\t  && try_isn->isn_arg.tryref.try_ref->try_finally == 0)\n\t{\n\t    emsg(_(e_missing_catch_or_finally));\n\t    return NULL;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t.isn_type == ISN_PROF_START)\n\t    // move the profile start after \"endtry\" so that it's not counted when\n\t    // the exception is rethrown.\n\t    --instr->ga_len;\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks, if not\n\t// done by \":finally\".\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Last catch without match jumps here\n\t    isn_T *isn = ((isn_T *)instr->ga_data)\n\t\t\t\t\t   + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n    }\n\n    // If there is a finally clause that ends in return then we will return.\n    // If one of the blocks didn't end in \"return\" or we did not catch all\n    // exceptions reset the had_return flag.\n    if (!(scope->se_u.se_try.ts_has_finally && cctx->ctx_had_return)\n\t    && (scope->se_u.se_try.ts_no_return\n\t\t|| !scope->se_u.se_try.ts_caught_all))\n\tcctx->ctx_had_return = FALSE;\n\n    compile_endblock(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set instruction index in ISN_TRY\n\t// instruction\n\ttry_isn->isn_arg.tryref.try_ref->try_endtry = instr->ga_len;\n\tif (generate_instr(cctx, ISN_ENDTRY) == NULL)\n\t    return NULL;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n    }\n    return arg;\n}\n\n/*\n * compile \"throw {expr}\"\n */\n    char_u *\ncompile_throw(char_u *arg, cctx_T *cctx UNUSED)\n{\n    char_u *p = skipwhite(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn p;\n    if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\treturn NULL;\n    if (generate_instr_drop(cctx, ISN_THROW, 1) == NULL)\n\treturn NULL;\n\n    return p;\n}\n\n/*\n * Compile an expression or function call.\n */\n    char_u *\ncompile_eval(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    int\t\tname_only;\n    long\tlnum = SOURCING_LNUM;\n\n    // find_ex_command() will consider a variable name an expression, assuming\n    // that something follows on the next line.  Check that something actually\n    // follows, otherwise it's probably a misplaced command.\n    name_only = cmd_is_name_only(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (name_only && lnum == SOURCING_LNUM)\n    {\n\tsemsg(_(e_expression_without_effect_str), arg);\n\treturn NULL;\n    }\n\n    // drop the result\n    generate_instr_drop(cctx, ISN_DROP, 1);\n\n    return skipwhite(p);\n}\n\n/*\n * Get the local variable index for deferred function calls.\n * Reserve it when not done already.\n * Returns zero for failure.\n */\n    int\nget_defer_var_idx(cctx_T *cctx)\n{\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + cctx->ctx_ufunc->uf_dfunc_idx;\n    if (dfunc->df_defer_var_idx == 0)\n    {\n\tlvar_T *lvar = reserve_local(cctx, (char_u *)\"@defer@\", 7,\n\t\t\t\t\t\t\t    TRUE, &t_list_any);\n\tif (lvar == NULL)\n\t    return 0;\n\tdfunc->df_defer_var_idx = lvar->lv_idx + 1;\n    }\n    return dfunc->df_defer_var_idx;\n}\n\n/*\n * Compile \"defer func(arg)\".\n */\n    char_u *\ncompile_defer(char_u *arg_start, cctx_T *cctx)\n{\n    char_u\t*paren;\n    char_u\t*arg = arg_start;\n    int\t\targcount = 0;\n    int\t\tdefer_var_idx;\n    type_T\t*type;\n    int\t\tfunc_idx;\n\n    // Get a funcref for the function name.\n    // TODO: better way to find the \"(\".\n    paren = vim_strchr(arg, '(');\n    if (paren == NULL)\n    {\n\tsemsg(_(e_missing_parenthesis_str), arg);\n\treturn NULL;\n    }\n    *paren = NUL;\n    func_idx = find_internal_func(arg);\n    if (func_idx >= 0)\n\t// TODO: better type\n\tgenerate_PUSHFUNC(cctx, (char_u *)internal_func_name(func_idx),\n\t\t\t\t\t\t\t   &t_func_any, FALSE);\n    else if (compile_expr0(&arg, cctx) == FAIL)\n\treturn NULL;\n    *paren = '(';\n\n    // check for function type\n    type = get_type_on_stack(cctx, 0);\n    if (type->tt_type != VAR_FUNC)\n    {\n\temsg(_(e_function_name_required));\n\treturn NULL;\n    }\n\n    // compile the arguments\n    arg = skipwhite(paren + 1);\n    if (compile_arguments(&arg, cctx, &argcount, CA_NOT_SPECIAL) == FAIL)\n\treturn NULL;\n\n    if (func_idx >= 0)\n    {\n\ttype2_T\t*argtypes = NULL;\n\ttype2_T\tshuffled_argtypes[MAX_FUNC_ARGS];\n\n\tif (check_internal_func_args(cctx, func_idx, argcount, FALSE,\n\t\t\t\t\t &argtypes, shuffled_argtypes) == FAIL)\n\t    return NULL;\n    }\n    else if (check_func_args_from_type(cctx, type, argcount, TRUE,\n\t\t\t\t\t\t\t    arg_start) == FAIL)\n\treturn NULL;\n\n    defer_var_idx = get_defer_var_idx(cctx);\n    if (defer_var_idx == 0)\n\treturn NULL;\n    if (generate_DEFER(cctx, defer_var_idx - 1, argcount) == FAIL)\n\treturn NULL;\n\n    return skipwhite(arg);\n}\n\n/*\n * compile \"echo expr\"\n * compile \"echomsg expr\"\n * compile \"echoerr expr\"\n * compile \"echoconsole expr\"\n * compile \"echowindow expr\" - may have cmd_count set\n * compile \"execute expr\"\n */\n    char_u *\ncompile_mult_expr(char_u *arg, int cmdidx, long cmd_count, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    char_u\t*prev = arg;\n    char_u\t*expr_start;\n    int\t\tcount = 0;\n    int\t\tstart_ctx_lnum = cctx->ctx_lnum;\n    type_T\t*type;\n    int\t\tr = OK;\n\n    for (;;)\n    {\n\tif (ends_excmd2(prev, p))\n\t    break;\n\texpr_start = p;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // check for non-void type\n\t    type = get_type_on_stack(cctx, 0);\n\t    if (type->tt_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), expr_start);\n\t\treturn NULL;\n\t    }\n\t}\n\n\t++count;\n\tprev = p;\n\tp = skipwhite(p);\n    }\n\n    if (count > 0)\n    {\n\tlong save_lnum = cctx->ctx_lnum;\n\n\t// Use the line number where the command started.\n\tcctx->ctx_lnum = start_ctx_lnum;\n\n\tif (cmdidx == CMD_echo || cmdidx == CMD_echon)\n\t    r = generate_ECHO(cctx, cmdidx == CMD_echo, count);\n\telse if (cmdidx == CMD_execute)\n\t    r = generate_MULT_EXPR(cctx, ISN_EXECUTE, count);\n\telse if (cmdidx == CMD_echomsg)\n\t    r = generate_MULT_EXPR(cctx, ISN_ECHOMSG, count);\n#ifdef HAS_MESSAGE_WINDOW\n\telse if (cmdidx == CMD_echowindow)\n\t    r = generate_ECHOWINDOW(cctx, count, cmd_count);\n#endif\n\telse if (cmdidx == CMD_echoconsole)\n\t    r = generate_MULT_EXPR(cctx, ISN_ECHOCONSOLE, count);\n\telse\n\t    r = generate_MULT_EXPR(cctx, ISN_ECHOERR, count);\n\n\tcctx->ctx_lnum = save_lnum;\n    }\n    return r == OK ? p : NULL;\n}\n\n/*\n * If \"eap\" has a range that is not a constant generate an ISN_RANGE\n * instruction to compute it and return OK.\n * Otherwise return FAIL, the caller must deal with any range.\n */\n    static int\ncompile_variable_range(exarg_T *eap, cctx_T *cctx)\n{\n    char_u *range_end = skip_range(eap->cmd, TRUE, NULL);\n    char_u *p = skipdigits(eap->cmd);\n\n    if (p == range_end)\n\treturn FAIL;\n    return generate_RANGE(cctx, vim_strnsave(eap->cmd, range_end - eap->cmd));\n}\n\n/*\n * :put r\n * :put ={expr}\n */\n    char_u *\ncompile_put(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = arg;\n    linenr_T\tlnum;\n    char\t*errormsg;\n    int\t\tabove = eap->forceit;\n\n    eap->regname = *line;\n\n    if (eap->regname == '=')\n    {\n\tchar_u *p = skipwhite(line + 1);\n\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tline = p;\n    }\n    else if (eap->regname != NUL)\n\t++line;\n\n    if (compile_variable_range(eap, cctx) == OK)\n    {\n\tlnum = above ? LNUM_VARIABLE_RANGE_ABOVE : LNUM_VARIABLE_RANGE;\n    }\n    else\n    {\n\t// Either no range or a number.\n\t// \"errormsg\" will not be set because the range is ADDR_LINES.\n\tif (parse_cmd_address(eap, &errormsg, FALSE) == FAIL)\n\t    // cannot happen\n\t    return NULL;\n\tif (eap->addr_count == 0)\n\t    lnum = -1;\n\telse\n\t    lnum = eap->line2;\n\tif (above)\n\t    --lnum;\n    }\n\n    generate_PUT(cctx, eap->regname, lnum);\n    return line;\n}\n\n/*\n * A command that is not compiled, execute with legacy code.\n */\n    char_u *\ncompile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = line_arg;\n    char_u\t*p;\n    int\t\thas_expr = FALSE;\n    char_u\t*nextcmd = (char_u *)\"\";\n    char_u\t*tofree = NULL;\n    char_u\t*cmd_arg = NULL;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\tgoto theend;\n\n    // If there was a prececing command modifier, drop it and include it in the\n    // EXEC command.\n    if (cctx->ctx_has_cmdmod)\n    {\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tisn_T\t\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\tif (isn->isn_type == ISN_CMDMOD)\n\t{\n\t    vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod\n\t\t\t\t\t       ->cmod_filter_regmatch.regprog);\n\t    vim_free(isn->isn_arg.cmdmod.cf_cmdmod);\n\t    --instr->ga_len;\n\t    cctx->ctx_has_cmdmod = FALSE;\n\t}\n    }\n\n    if (eap->cmdidx >= 0 && eap->cmdidx < CMD_SIZE)\n    {\n\tlong\targt = eap->argt;\n\tint\tusefilter = FALSE;\n\n\thas_expr = argt & (EX_XFILE | EX_EXPAND);\n\n\t// If the command can be followed by a bar, find the bar and truncate\n\t// it, so that the following command can be compiled.\n\t// The '|' is overwritten with a NUL, it is put back below.\n\tif ((eap->cmdidx == CMD_write || eap->cmdidx == CMD_read)\n\t\t\t\t\t\t\t   && *eap->arg == '!')\n\t    // :w !filter or :r !filter or :r! filter\n\t    usefilter = TRUE;\n\tif ((argt & EX_TRLBAR) && !usefilter)\n\t{\n\t    eap->argt = argt;\n\t    separate_nextcmd(eap, TRUE);\n\t    if (eap->nextcmd != NULL)\n\t\tnextcmd = eap->nextcmd;\n\t}\n\telse if (eap->cmdidx == CMD_wincmd)\n\t{\n\t    p = eap->arg;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == 'g' || *p == Ctrl_G)\n\t\t++p;\n\t    p = skipwhite(p);\n\t    if (*p == '|')\n\t    {\n\t\t*p = NUL;\n\t\tnextcmd = p + 1;\n\t    }\n\t}\n\telse if (eap->cmdidx == CMD_command || eap->cmdidx == CMD_autocmd)\n\t{\n\t    // If there is a trailing '{' read lines until the '}'\n\t    p = eap->arg + STRLEN(eap->arg) - 1;\n\t    while (p > eap->arg && VIM_ISWHITE(*p))\n\t\t--p;\n\t    if (*p == '{')\n\t    {\n\t\texarg_T ea;\n\t\tint\tflags = 0;  // unused\n\t\tint\tstart_lnum = SOURCING_LNUM;\n\n\t\tCLEAR_FIELD(ea);\n\t\tea.arg = eap->arg;\n\t\tfill_exarg_from_cctx(&ea, cctx);\n\t\t(void)may_get_cmd_block(&ea, p, &tofree, &flags);\n\t\tif (tofree != NULL)\n\t\t{\n\t\t    *p = NUL;\n\t\t    line = concat_str(line, tofree);\n\t\t    if (line == NULL)\n\t\t\tgoto theend;\n\t\t    vim_free(tofree);\n\t\t    tofree = line;\n\t\t    SOURCING_LNUM = start_lnum;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (eap->cmdidx == CMD_syntax && STRNCMP(eap->arg, \"include \", 8) == 0)\n    {\n\t// expand filename in \"syntax include [@group] filename\"\n\thas_expr = TRUE;\n\teap->arg = skipwhite(eap->arg + 7);\n\tif (*eap->arg == '@')\n\t    eap->arg = skiptowhite(eap->arg);\n    }\n\n    if ((eap->cmdidx == CMD_global || eap->cmdidx == CMD_vglobal)\n\t\t\t\t\t\t       && STRLEN(eap->arg) > 4)\n    {\n\tint delim = *eap->arg;\n\n\tp = skip_regexp_ex(eap->arg + 1, delim, TRUE, NULL, NULL, NULL);\n\tif (*p == delim)\n\t    cmd_arg = p + 1;\n    }\n\n    if (eap->cmdidx == CMD_folddoopen || eap->cmdidx == CMD_folddoclosed)\n\tcmd_arg = eap->arg;\n\n    if (cmd_arg != NULL)\n    {\n\texarg_T nea;\n\n\tCLEAR_FIELD(nea);\n\tnea.cmd = cmd_arg;\n\tp = find_ex_command(&nea, NULL, lookup_scriptitem, NULL);\n\tif (nea.cmdidx < CMD_SIZE)\n\t{\n\t    has_expr = excmd_get_argt(nea.cmdidx) & (EX_XFILE | EX_EXPAND);\n\t    if (has_expr)\n\t\teap->arg = skiptowhite(eap->arg);\n\t}\n    }\n\n    if (has_expr && (p = (char_u *)strstr((char *)eap->arg, \"`=\")) != NULL)\n    {\n\tint\tcount = 0;\n\tchar_u\t*start = skipwhite(line);\n\n\t// :cmd xxx`=expr1`yyy`=expr2`zzz\n\t// PUSHS \":cmd xxx\"\n\t// eval expr1\n\t// PUSHS \"yyy\"\n\t// eval expr2\n\t// PUSHS \"zzz\"\n\t// EXECCONCAT 5\n\tfor (;;)\n\t{\n\t    if (p > start)\n\t    {\n\t\tchar_u *val = vim_strnsave(start, p - start);\n\n\t\tgenerate_PUSHS(cctx, &val);\n\t\t++count;\n\t    }\n\t    p += 2;\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t    may_generate_2STRING(-1, TRUE, cctx);\n\t    ++count;\n\t    p = skipwhite(p);\n\t    if (*p != '`')\n\t    {\n\t\temsg(_(e_missing_backtick));\n\t\treturn NULL;\n\t    }\n\t    start = p + 1;\n\n\t    p = (char_u *)strstr((char *)start, \"`=\");\n\t    if (p == NULL)\n\t    {\n\t\tif (*skipwhite(start) != NUL)\n\t\t{\n\t\t    char_u *val = vim_strsave(start);\n\n\t\t    generate_PUSHS(cctx, &val);\n\t\t    ++count;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tgenerate_EXECCONCAT(cctx, count);\n    }\n    else\n\tgenerate_EXEC_copy(cctx, ISN_EXEC, line);\n\ntheend:\n    if (*nextcmd != NUL)\n    {\n\t// the parser expects a pointer to the bar, put it back\n\t--nextcmd;\n\t*nextcmd = '|';\n    }\n    vim_free(tofree);\n\n    return nextcmd;\n}\n\n/*\n * A script command with heredoc, e.g.\n *\truby << EOF\n *\t   command\n *\tEOF\n * Has been turned into one long line with NL characters by\n * get_function_body():\n *\truby << EOF<NL>   command<NL>EOF\n */\n    char_u *\ncompile_script(char_u *line, cctx_T *cctx)\n{\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\tif ((isn = generate_instr(cctx, ISN_EXEC_SPLIT)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.string = vim_strsave(line);\n    }\n    return (char_u *)\"\";\n}\n\n\n/*\n * :s/pat/repl/\n */\n    char_u *\ncompile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *cmd = eap->arg;\n    char_u  *expr = (char_u *)strstr((char *)cmd, \"\\\\=\");\n\n    if (expr != NULL)\n    {\n\tint delimiter = *cmd++;\n\n\t// There is a \\=expr, find it in the substitute part.\n\tcmd = skip_regexp_ex(cmd, delimiter, magic_isset(), NULL, NULL, NULL);\n\tif (cmd[0] == delimiter && cmd[1] == '\\\\' && cmd[2] == '=')\n\t{\n\t    garray_T\tsave_ga = cctx->ctx_instr;\n\t    char_u\t*end;\n\t    int\t\texpr_res;\n\t    int\t\ttrailing_error;\n\t    int\t\tinstr_count;\n\t    isn_T\t*instr;\n\t    isn_T\t*isn;\n\n\t    cmd += 3;\n\t    end = skip_substitute(cmd, delimiter);\n\n\t    // Temporarily reset the list of instructions so that the jump\n\t    // labels are correct.\n\t    cctx->ctx_instr.ga_len = 0;\n\t    cctx->ctx_instr.ga_maxlen = 0;\n\t    cctx->ctx_instr.ga_data = NULL;\n\t    expr_res = compile_expr0(&cmd, cctx);\n\t    if (end[-1] == NUL)\n\t\tend[-1] = delimiter;\n\t    cmd = skipwhite(cmd);\n\t    trailing_error = *cmd != delimiter && *cmd != NUL;\n\n\t    if (expr_res == FAIL || trailing_error\n\t\t\t\t       || GA_GROW_FAILS(&cctx->ctx_instr, 1))\n\t    {\n\t\tif (trailing_error)\n\t\t    semsg(_(e_trailing_characters_str), cmd);\n\t\tclear_instr_ga(&cctx->ctx_instr);\n\t\tcctx->ctx_instr = save_ga;\n\t\treturn NULL;\n\t    }\n\n\t    // Move the generated instructions into the ISN_SUBSTITUTE\n\t    // instructions, then restore the list of instructions before\n\t    // adding the ISN_SUBSTITUTE instruction.\n\t    instr_count = cctx->ctx_instr.ga_len;\n\t    instr = cctx->ctx_instr.ga_data;\n\t    instr[instr_count].isn_type = ISN_FINISH;\n\n\t    cctx->ctx_instr = save_ga;\n\t    if ((isn = generate_instr(cctx, ISN_SUBSTITUTE)) == NULL)\n\t    {\n\t\tint idx;\n\n\t\tfor (idx = 0; idx < instr_count; ++idx)\n\t\t    delete_instr(instr + idx);\n\t\tvim_free(instr);\n\t\treturn NULL;\n\t    }\n\t    isn->isn_arg.subs.subs_cmd = vim_strsave(arg);\n\t    isn->isn_arg.subs.subs_instr = instr;\n\n\t    // skip over flags\n\t    if (*end == '&')\n\t\t++end;\n\t    while (ASCII_ISALPHA(*end) || *end == '#')\n\t\t++end;\n\t    return end;\n\t}\n    }\n\n    return compile_exec(arg, eap, cctx);\n}\n\n    char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lhs->lhs_append)\n\t\t{\n\t\t    // First load the current variable value.\n\t\t    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t\treturn NULL;\n\t\t}\n\n\t\t// Gets the redirected text and put it on the stack, then store\n\t\t// it in the variable.\n\t\tgenerate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t\tif (lhs->lhs_append)\n\t\t    generate_CONCAT(cctx, 2);\n\n\t\tif (lhs->lhs_has_index)\n\t\t{\n\t\t    // Use the info in \"lhs\" to store the value at the index in\n\t\t    // the list or dict.\n\t\t    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\t    return NULL;\n\n\t\tVIM_CLEAR(lhs->lhs_name);\n\t\tVIM_CLEAR(lhs->lhs_whole);\n\t    }\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tif (cctx->ctx_skip == SKIP_YES)\n\t{\n\t    VIM_CLEAR(lhs->lhs_name);\n\t}\n\telse\n\t{\n\t    generate_instr(cctx, ISN_REDIRSTART);\n\t    lhs->lhs_append = append;\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\tlhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t\tif (lhs->lhs_whole == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    char_u *\ncompile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    isn_T\t*isn;\n    char_u\t*p;\n\n    isn = generate_instr(cctx, ISN_CEXPR_AUCMD);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.number = eap->cmdidx;\n\n    p = eap->arg;\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    isn = generate_instr(cctx, ISN_CEXPR_CORE);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref = ALLOC_ONE(cexprref_T);\n    if (isn->isn_arg.cexpr.cexpr_ref == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdidx = eap->cmdidx;\n    isn->isn_arg.cexpr.cexpr_ref->cer_forceit = eap->forceit;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdline = vim_strsave(skipwhite(line));\n\n    return p;\n}\n#endif\n\n/*\n * Compile \"return [expr]\".\n * When \"legacy\" is TRUE evaluate [expr] with legacy syntax\n */\n    char_u *\ncompile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    type_T\t*stack_type;\n\n    if (*p != NUL && *p != '|' && *p != '\\n')\n    {\n\t// For a lambda, \"return expr\" is always used, also when \"expr\" results\n\t// in a void.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type == VAR_VOID\n\t\t&& (cctx->ctx_ufunc->uf_flags & FC_LAMBDA) == 0)\n\t{\n\t    emsg(_(e_returning_value_in_function_without_return_type));\n\t    return NULL;\n\t}\n\tif (legacy)\n\t{\n\t    int save_flags = cmdmod.cmod_flags;\n\n\t    generate_LEGACY_EVAL(cctx, p);\n\t    if (need_type(&t_any, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn NULL;\n\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t    (void)skip_expr(&p, NULL);\n\t    cmdmod.cmod_flags = save_flags;\n\t}\n\telse\n\t{\n\t    // compile return argument into instructions\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // \"check_return_type\" with uf_ret_type set to &t_unknown is used\n\t    // for an inline function without a specified return type.  Set the\n\t    // return type here.\n\t    stack_type = get_type_on_stack(cctx, 0);\n\t    if ((check_return_type && (cctx->ctx_ufunc->uf_ret_type == NULL\n\t\t\t\t|| cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t\t    || (!check_return_type\n\t\t\t\t&& cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t    {\n\t\tcctx->ctx_ufunc->uf_ret_type = stack_type;\n\t    }\n\t    else\n\t    {\n\t\tif (need_type(stack_type, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// \"check_return_type\" cannot be TRUE, only used for a lambda which\n\t// always has an argument.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_VOID\n\t\t&& cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_UNKNOWN)\n\t{\n\t    emsg(_(e_missing_return_value));\n\t    return NULL;\n\t}\n\n\t// No argument, return zero.\n\tgenerate_PUSHNR(cctx, 0);\n    }\n\n    // may need ENDLOOP when inside a :for or :while loop\n    if (compile_find_scope(NULL, NULL, NULL, NULL, cctx) == FAIL)\n\n    // Undo any command modifiers.\n    generate_undo_cmdmods(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_RETURN) == NULL)\n\treturn NULL;\n\n    // \"return val | endif\" is possible\n    return skipwhite(p);\n}\n\n/*\n * Check if the separator for a :global or :substitute command is OK.\n */\n    int\ncheck_global_and_subst(char_u *cmd, char_u *arg)\n{\n    if (arg == cmd + 1 && vim_strchr((char_u *)\":-.\", *arg) != NULL)\n    {\n\tsemsg(_(e_separator_not_supported_str), arg);\n\treturn FAIL;\n    }\n    if (VIM_ISWHITE(cmd[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_separator_str), cmd);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#endif  // defined(FEAT_EVAL)\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (lvp->lv_name != NULL\n\t\t&& STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t\t// If the variable was declared inside a loop set\n\t\t// lvar->lv_loop_idx and lvar->lv_loop_depth.\n\t\tget_loop_var_idx(cctx, idx, lvar);\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\tif (cstack == NULL)\n\t    return NULL;\n\n\t// Not in a function scope, find variable with block ID equal to or\n\t// smaller than the current block id.  Use \"cstack\" to go up the block\n\t// scopes.\n\twhile (sav != NULL)\n\t{\n\t    int idx;\n\n\t    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\t\tif (cstack->cs_block_id[idx] == sav->sav_block_id)\n\t\t    break;\n\t    if (idx >= 0)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * If \"name\" can be found in the current script set it's \"block_id\".\n */\n    void\nupdate_script_var_block_id(char_u *name, int block_id)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    sallvar_T\t    *sav;\n\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (HASHITEM_EMPTY(hi))\n\treturn;\n    sav = HI2SAV(hi);\n    sav->sav_block_id = block_id;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx, cstack) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx, NULL) == OK\n\t    || find_imported(name, len, FALSE) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.  Or commands are being skipped, a declaration may have\n * been skipped then.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    return variable_exists(name, len, cctx);\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(\n\tchar_u\t    *p,\n\tsize_t\t    len,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack,\n\tint\t    is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx, cstack) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, FALSE) != NULL\n\t    || (ufunc = find_func_even_dead(p, 0)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If actual a constant a runtime check makes no sense.  If it's\n    // null_function it is OK.\n    if (actual_is_const && ret == MAYBE && actual == &t_func_unknown)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset,\n\t\t\t\t\t    where.wt_variable, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Set type of variable \"lvar\" to \"type\".  If the variable is a constant then\n * the type gets TTFLAG_CONST.\n */\n    static void\nset_var_type(lvar_T *lvar, type_T *type_arg, cctx_T *cctx)\n{\n    type_T\t*type = type_arg;\n\n    if (lvar->lv_const == ASSIGN_CONST && (type->tt_flags & TTFLAG_CONST) == 0)\n    {\n\tif (type->tt_flags & TTFLAG_STATIC)\n\t    // entry in static_types[] is followed by const type\n\t    type = type + 1;\n\telse\n\t{\n\t    type = copy_type(type, cctx->ctx_type_list);\n\t    type->tt_flags |= TTFLAG_CONST;\n\t}\n    }\n    lvar->lv_type = type;\n}\n\n/*\n * Reserve space for a local variable.\n * \"assign\" can be ASSIGN_VAR for :var, ASSIGN_CONST for :const and\n * ASSIGN_FINAL for :final.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tassign,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = assign;\n    if (type == &t_unknown || type == &t_any)\n\t// type not known yet, may be inferred from RHS\n\tlvar->lv_type = type;\n    else\n\t// may use TTFLAG_CONST\n\tset_var_type(lvar, type, cctx);\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(\n\tint\t    sid,\n\tchar_u\t    *name,\n\tint\t    check_writable,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx, cstack);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n    {\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    hashitem_T *hi;\n\n\t    // A variable exported from an autoload script is in the global\n\t    // variables, we can find it in the all_vars table.\n\t    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2SAV(hi)->sav_var_vals_idx;\n\t}\n\treturn -2;\n    }\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n    static imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Find \"name\" in imported items of the current script.\n * If \"len\" is 0 use any length that works.\n * If \"load\" is TRUE and the script was not loaded yet, load it now.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, int load)\n{\n    imported_T\t    *ret;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n\n    ret = find_imported_in_script(name, len, current_sctx.sc_sid);\n    if (ret != NULL && load && (ret->imp_flags & IMP_FLAGS_AUTOLOAD))\n    {\n\tscid_T\tactual_sid = 0;\n\tint\tsave_emsg_off = emsg_off;\n\n\t// \"emsg_off\" will be set when evaluating an expression silently, but\n\t// we do want to know about errors in a script.  Also because it then\n\t// aborts when an error is encountered.\n\temsg_off = FALSE;\n\n\t// script found before but not loaded yet\n\tret->imp_flags &= ~IMP_FLAGS_AUTOLOAD;\n\t(void)do_source(SCRIPT_ITEM(ret->imp_sid)->sn_name, FALSE,\n\t\t\t\t\t\t       DOSO_NONE, &actual_sid);\n\t// If the script is a symlink it may be sourced with another name, may\n\t// need to adjust the script ID for that.\n\tif (actual_sid != 0)\n\t    ret->imp_sid = actual_sid;\n\n\temsg_off = save_emsg_off;\n    }\n    return ret;\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n    eap->skip = cctx->ctx_skip == SKIP_YES;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t    ASSIGN_CONST, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    // Now the local variable can't be used.\n\t    *lvar->lv_name = '/';  // impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Compile one Vim expression {expr} in string \"p\".\n * \"p\" points to the opening \"{\".\n * Return a pointer to the character after \"}\", NULL for an error.\n */\n    char_u *\ncompile_one_expr_in_str(char_u *p, cctx_T *cctx)\n{\n    char_u\t*block_start;\n    char_u\t*block_end;\n\n    // Skip the opening {.\n    block_start = skipwhite(p + 1);\n    block_end = block_start;\n    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)\n\treturn NULL;\n    block_end = skipwhite(block_end);\n    // The block must be closed by a }.\n    if (*block_end != '}')\n    {\n\tsemsg(_(e_missing_close_curly_str), p);\n\treturn NULL;\n    }\n    if (compile_expr0(&block_start, cctx) == FAIL)\n\treturn NULL;\n    may_generate_2STRING(-1, TRUE, cctx);\n\n    return block_end + 1;\n}\n\n/*\n * Compile a string \"str\" (either containing a literal string or a mix of\n * literal strings and Vim expressions of the form `{expr}`).  This is used\n * when compiling a heredoc assignment to a variable or an interpolated string\n * in a Vim9 def function.  Vim9 instructions are generated to push strings,\n * evaluate expressions, concatenate them and create a list of lines.  When\n * \"evalstr\" is TRUE, Vim expressions in \"str\" are evaluated.\n */\n    int\ncompile_all_expr_in_str(char_u *str, int evalstr, cctx_T *cctx)\n{\n    char_u\t*p = str;\n    char_u\t*val;\n    int\t\tcount = 0;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (!evalstr || *str == NUL)\n    {\n\t// Literal string, possibly empty.\n\tval = *str != NUL ? vim_strsave(str) : NULL;\n\treturn generate_PUSHS(cctx, &val);\n    }\n\n    // Push all the string pieces to the stack, followed by a ISN_CONCAT.\n    while (*p != NUL)\n    {\n\tchar_u\t*lit_start;\n\tint\tescaped_brace = FALSE;\n\n\t// Look for a block start.\n\tlit_start = p;\n\twhile (*p != '{' && *p != '}' && *p != NUL)\n\t    ++p;\n\n\tif (*p != NUL && *p == p[1])\n\t{\n\t    // Escaped brace, unescape and continue.\n\t    // Include the brace in the literal string.\n\t    ++p;\n\t    escaped_brace = TRUE;\n\t}\n\telse if (*p == '}')\n\t{\n\t    semsg(_(e_stray_closing_curly_str), str);\n\t    return FAIL;\n\t}\n\n\t// Append the literal part.\n\tif (p != lit_start)\n\t{\n\t    val = vim_strnsave(lit_start, (size_t)(p - lit_start));\n\t    if (generate_PUSHS(cctx, &val) == FAIL)\n\t\treturn FAIL;\n\t    ++count;\n\t}\n\n\tif (*p == NUL)\n\t    break;\n\n\tif (escaped_brace)\n\t{\n\t    // Skip the second brace.\n\t    ++p;\n\t    continue;\n\t}\n\n\tp = compile_one_expr_in_str(p, cctx);\n\tif (p == NULL)\n\t    return FAIL;\n\t++count;\n    }\n\n    // Small optimization, if there's only a single piece skip the ISN_CONCAT.\n    if (count > 1)\n\treturn generate_CONCAT(cctx, count);\n\n    return OK;\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lvar->lv_from_outer > 0)\n\t\t    generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t lvar->lv_loop_depth, lvar->lv_loop_idx, type);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    }\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * Return TRUE if \"name\" is a valid register to use.\n * Return FALSE and give an error message if not.\n */\n    static int\nvalid_dest_reg(int name)\n{\n    if ((name == '@' || valid_yank_reg(name, FALSE)) && name != '.')\n\treturn TRUE;\n    emsg_invreg(name);\n    return FAIL;\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (!valid_dest_reg(name[1]))\n\t    return FAIL;\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(cmdidx_T cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n    {\n\tif (!valid_dest_reg(var_start[1]))\n\t    return FAIL;\n\tvar_end = var_start + 2;\n    }\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tint assign = cmdidx == CMD_final ? ASSIGN_FINAL\n\t\t\t     : cmdidx == CMD_const ? ASSIGN_CONST : ASSIGN_VAR;\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\tassign, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    is_decl,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, has_cmd, oplen, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const != ASSIGN_VAR\n\t\t\t   && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"varname\" or \"[varname, varname]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n    else\n    {\n\tsp = p;\n\tp = skipwhite(p);\n\top = p;\n\toplen = assignment_len(p, &heredoc);\n\n\tif (var_count > 0 && oplen == 0)\n\t    // can be something like \"[1, 2]->func()\"\n\t    return arg;\n\n\tif (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n\t{\n\t    error_white_both(op, oplen);\n\t    return NULL;\n\t}\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE, TRUE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t    needed_list_len, (int)isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\ttype_T\t*inferred_type = NULL;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\tis_decl, heredoc, var_start > eap->cmd,\n\t\t\t\toplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t    }\n\t\t    if (r == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    type_T *type;\n\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\ttype = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\ttype = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\ttype = &t_any;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ttype = rhs_type;\n\t\t\t\tinferred_type = rhs_type;\n\t\t\t    }\n\t\t\t    set_var_type(lhs.lhs_lvar, type, cctx);\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t\t\tcctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tint r = OK;\n\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tr = generate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n\t\t\tr = generate_PUSHF(cctx, 0.0);\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tr = generate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tr = generate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tr = generate_PUSHFUNC(cctx, NULL, &t_func_void, TRUE);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tr = generate_NEWLIST(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tr = generate_NEWDICT(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tr = generate_PUSHJOB(cctx);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tr = generate_PUSHCHANNEL(cctx);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are always\n\t\t\t// initialized to zero.  But in a \"for\" or \"while\" loop\n\t\t\t// the value may have been changed.\n\t\t\tif (lhs.lhs_dest == dest_local\n\t\t\t\t\t\t   && !inside_loop_scope(cctx))\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    instr_count = instr->ga_len;\n\t\t\t    r = generate_PUSHNR(cctx, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (r == FAIL)\n\t\t    goto theend;\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_CONCAT(cctx, 2) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_any\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\t    else if (inferred_type != NULL\n\t\t    && (inferred_type->tt_type == VAR_DICT\n\t\t\t\t\t|| inferred_type->tt_type == VAR_LIST)\n\t\t    && inferred_type->tt_member != NULL\n\t\t    && inferred_type->tt_member != &t_unknown\n\t\t    && inferred_type->tt_member != &t_any)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, inferred_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    // \"g:var = expr\"\n\t    // \"g:[key] = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// might be \"[var, var] = expr\"\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, NULL, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n#ifdef HAS_MESSAGE_WINDOW\n/*\n * Get a count before a command.  Can only be a number.\n * Returns zero if there is no count.\n * Returns -1 if there is something wrong.\n */\n    static long\nget_cmd_count(char_u *line, exarg_T *eap)\n{\n    char_u *p;\n\n    // skip over colons and white space\n    for (p = line; *p == ':' || VIM_ISWHITE(*p); ++p)\n\t;\n    if (!isdigit(*p))\n    {\n\t// the command must be following\n\tif (p < eap->cmd)\n\t{\n\t    emsg(_(e_invalid_range));\n\t    return -1;\n\t}\n\treturn 0;\n    }\n    return atol((char *)p);\n}\n#endif\n\n/*\n * Get the compilation type that should be used for \"ufunc\".\n * Keep in sync with INSTRUCTIONS().\n */\n    compiletype_T\nget_compile_type(ufunc_T *ufunc)\n{\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (debug_break_level > 0 || may_break_in_function(ufunc))\n\treturn CT_DEBUG;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (!ufunc->uf_profiling && has_profiling(FALSE, ufunc->uf_name, NULL))\n\t    func_do_profile(ufunc);\n\tif (ufunc->uf_profiling)\n\t    return CT_PROFILE;\n    }\n#endif\n    return CT_NONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n\tdfunc->df_defer_var_idx = 0;\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    if ((ufunc->uf_flags & FC_CLOSURE) && outer_cctx == NULL)\n    {\n\tsemsg(_(e_compiling_closure_without_context_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\tea.skip = cctx.ctx_skip == SKIP_YES;\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment, but \"#{\" is an error\n\t    if (vim9_bad_comment(ea.cmd))\n\t\tgoto erret;\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    goto erret;\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * 0z1234->func() should not be confused with a zero line number\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t * \"123->func()\" is a method call\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon\n\t\t    || !(*cmd == '\\''\n\t\t\t|| (cmd[0] == '0' && cmd[1] == 'z')\n\t\t\t|| (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-'))\n\t\t\t|| number_method(cmd))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\tsemsg(_(e_ambiguous_use_of_user_defined_command_str), ea.cmd);\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    // \"eval\" is used for \"val->func()\" and \"var\" for \"var = val\", then\n\t    // \"p\" is equal to \"ea.cmd\" for a valid command.\n\t    if (ea.cmdidx == CMD_eval || ea.cmdidx == CMD_var)\n\t\t;\n\t    else if (cctx.ctx_skip == SKIP_YES)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t    if ((ea.argt & EX_RANGE) == 0 && ea.addr_count > 0)\n\t    {\n\t\temsg(_(e_no_range_allowed));\n\t\tgoto erret;\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t    {\n\t\t\temsg(_(e_invalid_assignment));\n\t\t\tline = NULL;\n\t\t    }\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_defer:\n\t\t    line = compile_defer(p, &cctx);\n\t\t    break;\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    case CMD_echowindow:\n\t\t    {\n\t\t\tlong cmd_count = get_cmd_count(line, &ea);\n\t\t\tif (cmd_count < 0)\n\t\t\t    line = NULL;\n\t\t\telse\n\t\t\t    line = compile_mult_expr(p, ea.cmdidx,\n\t\t\t\t\t\t\t     cmd_count, &cctx);\n\t\t    }\n\t\t    break;\n#endif\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_echoconsole:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_execute:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, 0, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_vim9script:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\temsg(_(e_vim9script_can_only_be_used_in_script));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\n\tif (cctx.ctx_outer_used)\n\t{\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\t    if (outer_cctx != NULL)\n\t\t++outer_cctx->ctx_closure_count;\n\t}\n\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n"], "filenames": ["src/testdir/test_vim9_func.vim", "src/testdir/test_vim9_script.vim", "src/version.c", "src/vim9cmds.c", "src/vim9compile.c"], "buggy_code_start_loc": [4341, 2139, 701, 2415, 1286], "buggy_code_end_loc": [4341, 2147, 701, 2475, 1448], "fixing_code_start_loc": [4342, 2139, 702, 2415, 1287], "fixing_code_end_loc": [4369, 2199, 704, 2485, 1462], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.", "other": {"cve": {"id": "CVE-2022-3491", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-03T13:15:09.713", "lastModified": "2023-05-03T12:16:25.437", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0742", "matchCriteriaId": "91F39B67-4878-4632-82A9-B9B676383EE6"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/3558afe9e9e904cabb8475392d859f2d2fc21041", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6e6e05c2-2cf7-4aa5-a817-a62007bf92cb", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/3558afe9e9e904cabb8475392d859f2d2fc21041"}}