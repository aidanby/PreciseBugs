{"buggy_code": ["# frozen_string_literal: true\n#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems/command'\nrequire 'rubygems/exceptions'\nrequire 'rubygems/package'\nrequire 'rubygems/ext'\nrequire 'rubygems/user_interaction'\nrequire 'fileutils'\n\n##\n# The installer installs the files contained in the .gem into the Gem.home.\n#\n# Gem::Installer does the work of putting files in all the right places on the\n# filesystem including unpacking the gem into its gem dir, installing the\n# gemspec in the specifications dir, storing the cached gem in the cache dir,\n# and installing either wrappers or symlinks for executables.\n#\n# The installer invokes pre and post install hooks.  Hooks can be added either\n# through a rubygems_plugin.rb file in an installed gem or via a\n# rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb\n# file.  See Gem.pre_install and Gem.post_install for details.\n\nclass Gem::Installer\n\n  ##\n  # Paths where env(1) might live.  Some systems are broken and have it in\n  # /bin\n\n  ENV_PATHS = %w[/usr/bin/env /bin/env]\n\n  ##\n  # Deprecated in favor of Gem::Ext::BuildError\n\n  ExtensionBuildError = Gem::Ext::BuildError # :nodoc:\n\n  include Gem::UserInteraction\n\n  ##\n  # Filename of the gem being installed.\n\n  attr_reader :gem\n\n  ##\n  # The directory a gem's executables will be installed into\n\n  attr_reader :bin_dir\n\n  attr_reader :build_root # :nodoc:\n\n  ##\n  # The gem repository the gem will be installed into\n\n  attr_reader :gem_home\n\n  ##\n  # The options passed when the Gem::Installer was instantiated.\n\n  attr_reader :options\n\n  @path_warning = false\n\n  @install_lock = Mutex.new\n\n  class << self\n\n    ##\n    # True if we've warned about PATH not including Gem.bindir\n\n    attr_accessor :path_warning\n\n    ##\n    # Certain aspects of the install process are not thread-safe. This lock is\n    # used to allow multiple threads to install Gems at the same time.\n\n    attr_reader :install_lock\n\n    ##\n    # Overrides the executable format.\n    #\n    # This is a sprintf format with a \"%s\" which will be replaced with the\n    # executable name.  It is based off the ruby executable name's difference\n    # from \"ruby\".\n\n    attr_writer :exec_format\n\n    # Defaults to use Ruby's program prefix and suffix.\n    def exec_format\n      @exec_format ||= Gem.default_exec_format\n    end\n\n  end\n\n  ##\n  # Construct an installer object for the gem file located at +path+\n\n  def self.at path, options = {}\n    security_policy = options[:security_policy]\n    package = Gem::Package.new path, security_policy\n    new package, options\n  end\n\n  class FakePackage\n    attr_accessor :spec\n\n    def initialize(spec)\n      @spec = spec\n    end\n\n    def extract_files destination_dir, pattern = '*'\n      FileUtils.mkdir_p destination_dir\n\n      spec.files.each do |file|\n        file = File.join destination_dir, file\n        next if File.exist? file\n        FileUtils.mkdir_p File.dirname(file)\n        File.open file, 'w' do |fp| fp.puts \"# #{file}\" end\n      end\n    end\n\n    def copy_to path\n    end\n  end\n\n  ##\n  # Construct an installer object for an ephemeral gem (one where we don't\n  # actually have a .gem file, just a spec)\n\n  def self.for_spec spec, options = {}\n    # FIXME: we should have a real Package class for this\n    new FakePackage.new(spec), options\n  end\n\n  ##\n  # Constructs an Installer instance that will install the gem located at\n  # +gem+.  +options+ is a Hash with the following keys:\n  #\n  # :bin_dir:: Where to put a bin wrapper if needed.\n  # :development:: Whether or not development dependencies should be installed.\n  # :env_shebang:: Use /usr/bin/env in bin wrappers.\n  # :force:: Overrides all version checks and security policy checks, except\n  #          for a signed-gems-only policy.\n  # :format_executable:: Format the executable the same as the Ruby executable.\n  #                      If your Ruby is ruby18, foo_exec will be installed as\n  #                      foo_exec18.\n  # :ignore_dependencies:: Don't raise if a dependency is missing.\n  # :install_dir:: The directory to install the gem into.\n  # :security_policy:: Use the specified security policy.  See Gem::Security\n  # :user_install:: Indicate that the gem should be unpacked into the users\n  #                 personal gem directory.\n  # :only_install_dir:: Only validate dependencies against what is in the\n  #                     install_dir\n  # :wrappers:: Install wrappers if true, symlinks if false.\n  # :build_args:: An Array of arguments to pass to the extension builder\n  #               process. If not set, then Gem::Command.build_args is used\n\n  def initialize(package, options={})\n    require 'fileutils'\n\n    @options = options\n    if package.is_a? String\n      security_policy = options[:security_policy]\n      @package = Gem::Package.new package, security_policy\n      if $VERBOSE\n        warn \"constructing an Installer object with a string is deprecated. Please use Gem::Installer.at (called from: #{caller.first})\"\n      end\n    else\n      @package = package\n    end\n\n    process_options\n\n    if options[:user_install] and not options[:unpack] then\n      @gem_home = Gem.user_dir\n      @bin_dir = Gem.bindir gem_home unless options[:bin_dir]\n      check_that_user_bin_dir_is_in_path\n    end\n  end\n\n  ##\n  # Checks if +filename+ exists in +@bin_dir+.\n  #\n  # If +@force+ is set +filename+ is overwritten.\n  #\n  # If +filename+ exists and is a RubyGems wrapper for different gem the user\n  # is consulted.\n  #\n  # If +filename+ exists and +@bin_dir+ is Gem.default_bindir (/usr/local) the\n  # user is consulted.\n  #\n  # Otherwise +filename+ is overwritten.\n\n  def check_executable_overwrite filename # :nodoc:\n    return if @force\n\n    generated_bin = File.join @bin_dir, formatted_program_filename(filename)\n\n    return unless File.exist? generated_bin\n\n    ruby_executable = false\n    existing = nil\n\n    open generated_bin, 'rb' do |io|\n      next unless io.gets =~ /^#!/ # shebang\n      io.gets # blankline\n\n      # TODO detect a specially formatted comment instead of trying\n      # to run a regexp against Ruby code.\n      next unless io.gets =~ /This file was generated by RubyGems/\n\n      ruby_executable = true\n      existing = io.read.slice(%r{\n          ^\\s*(\n            gem \\s |\n            load \\s Gem\\.bin_path\\( |\n            load \\s Gem\\.activate_bin_path\\(\n          )\n          (['\"])(.*?)(\\2),\n        }x, 3)\n    end\n\n    return if spec.name == existing\n\n    # somebody has written to RubyGems' directory, overwrite, too bad\n    return if Gem.default_bindir != @bin_dir and not ruby_executable\n\n    question = \"#{spec.name}'s executable \\\"#{filename}\\\" conflicts with \".dup\n\n    if ruby_executable then\n      question << (existing || 'an unknown executable')\n\n      return if ask_yes_no \"#{question}\\nOverwrite the executable?\", false\n\n      conflict = \"installed executable from #{existing}\"\n    else\n      question << generated_bin\n\n      return if ask_yes_no \"#{question}\\nOverwrite the executable?\", false\n\n      conflict = generated_bin\n    end\n\n    raise Gem::InstallError,\n      \"\\\"#{filename}\\\" from #{spec.name} conflicts with #{conflict}\"\n  end\n\n  ##\n  # Lazy accessor for the spec's gem directory.\n\n  def gem_dir\n    @gem_dir ||= File.join(gem_home, \"gems\", spec.full_name)\n  end\n\n  ##\n  # Lazy accessor for the installer's spec.\n\n  def spec\n    @package.spec\n  rescue Gem::Package::Error => e\n    raise Gem::InstallError, \"invalid gem: #{e.message}\"\n  end\n\n  ##\n  # Installs the gem and returns a loaded Gem::Specification for the installed\n  # gem.\n  #\n  # The gem will be installed with the following structure:\n  #\n  #   @gem_home/\n  #     cache/<gem-version>.gem #=> a cached copy of the installed gem\n  #     gems/<gem-version>/... #=> extracted files\n  #     specifications/<gem-version>.gemspec #=> the Gem::Specification\n\n  def install\n    pre_install_checks\n\n    FileUtils.rm_f File.join gem_home, 'specifications', spec.spec_name\n\n    run_pre_install_hooks\n\n    # Set loaded_from to ensure extension_dir is correct\n    if @options[:install_as_default] then\n      spec.loaded_from = default_spec_file\n    else\n      spec.loaded_from = spec_file\n    end\n\n    # Completely remove any previous gem files\n    FileUtils.rm_rf gem_dir\n    FileUtils.rm_rf spec.extension_dir\n\n    FileUtils.mkdir_p gem_dir\n\n    if @options[:install_as_default] then\n      extract_bin\n      write_default_spec\n    else\n      extract_files\n\n      build_extensions\n      write_build_info_file\n      run_post_build_hooks\n\n      generate_bin\n      write_spec\n      write_cache_file\n    end\n\n    say spec.post_install_message if options[:post_install_message] && !spec.post_install_message.nil?\n\n    Gem::Installer.install_lock.synchronize { Gem::Specification.reset }\n\n    run_post_install_hooks\n\n    spec\n\n  # TODO This rescue is in the wrong place. What is raising this exception?\n  # move this rescue to around the code that actually might raise it.\n  rescue Zlib::GzipFile::Error\n    raise Gem::InstallError, \"gzip error installing #{gem}\"\n  end\n\n  def run_pre_install_hooks # :nodoc:\n    Gem.pre_install_hooks.each do |hook|\n      if hook.call(self) == false then\n        location = \" at #{$1}\" if hook.inspect =~ /@(.*:\\d+)/\n\n        message = \"pre-install hook#{location} failed for #{spec.full_name}\"\n        raise Gem::InstallError, message\n      end\n    end\n  end\n\n  def run_post_build_hooks # :nodoc:\n    Gem.post_build_hooks.each do |hook|\n      if hook.call(self) == false then\n        FileUtils.rm_rf gem_dir\n\n        location = \" at #{$1}\" if hook.inspect =~ /@(.*:\\d+)/\n\n        message = \"post-build hook#{location} failed for #{spec.full_name}\"\n        raise Gem::InstallError, message\n      end\n    end\n  end\n\n  def run_post_install_hooks # :nodoc:\n    Gem.post_install_hooks.each do |hook|\n      hook.call self\n    end\n  end\n\n  ##\n  #\n  # Return an Array of Specifications contained within the gem_home\n  # we'll be installing into.\n\n  def installed_specs\n    @specs ||= begin\n      specs = []\n\n      Dir[File.join(gem_home, \"specifications\", \"*.gemspec\")].each do |path|\n        spec = Gem::Specification.load path.untaint\n        specs << spec if spec\n      end\n\n      specs\n    end\n  end\n\n  ##\n  # Ensure that the dependency is satisfied by the current installation of\n  # gem.  If it is not an exception is raised.\n  #\n  # spec       :: Gem::Specification\n  # dependency :: Gem::Dependency\n\n  def ensure_dependency(spec, dependency)\n    unless installation_satisfies_dependency? dependency then\n      raise Gem::InstallError, \"#{spec.name} requires #{dependency}\"\n    end\n    true\n  end\n\n  ##\n  # True if the gems in the system satisfy +dependency+.\n\n  def installation_satisfies_dependency?(dependency)\n    return true if @options[:development] and dependency.type == :development\n    return true if installed_specs.detect { |s| dependency.matches_spec? s }\n    return false if @only_install_dir\n    not dependency.matching_specs.empty?\n  end\n\n  ##\n  # Unpacks the gem into the given directory.\n\n  def unpack(directory)\n    @gem_dir = directory\n    extract_files\n  end\n\n  ##\n  # The location of the spec file that is installed.\n  #\n\n  def spec_file\n    File.join gem_home, \"specifications\", \"#{spec.full_name}.gemspec\"\n  end\n\n  ##\n  # The location of the default spec file for default gems.\n  #\n\n  def default_spec_file\n    File.join Gem::Specification.default_specifications_dir, \"#{spec.full_name}.gemspec\"\n  end\n\n  ##\n  # Writes the .gemspec specification (in Ruby) to the gem home's\n  # specifications directory.\n\n  def write_spec\n    open spec_file, 'w' do |file|\n      spec.installed_by_version = Gem.rubygems_version\n\n      file.puts spec.to_ruby_for_cache\n\n      file.fsync rescue nil # for filesystems without fsync(2)\n    end\n  end\n\n  ##\n  # Writes the full .gemspec specification (in Ruby) to the gem home's\n  # specifications/default directory.\n\n  def write_default_spec\n    File.open(default_spec_file, \"w\") do |file|\n      file.puts spec.to_ruby\n    end\n  end\n\n  ##\n  # Creates windows .bat files for easy running of commands\n\n  def generate_windows_script(filename, bindir)\n    if Gem.win_platform? then\n      script_name = filename + \".bat\"\n      script_path = File.join bindir, File.basename(script_name)\n      File.open script_path, 'w' do |file|\n        file.puts windows_stub_script(bindir, filename)\n      end\n\n      verbose script_path\n    end\n  end\n\n  def generate_bin # :nodoc:\n    return if spec.executables.nil? or spec.executables.empty?\n\n    Dir.mkdir @bin_dir unless File.exist? @bin_dir\n    raise Gem::FilePermissionError.new(@bin_dir) unless File.writable? @bin_dir\n\n    spec.executables.each do |filename|\n      filename.untaint\n      bin_path = File.join gem_dir, spec.bindir, filename\n\n      unless File.exist? bin_path then\n        # TODO change this to a more useful warning\n        warn \"#{bin_path} maybe `gem pristine #{spec.name}` will fix it?\"\n        next\n      end\n\n      mode = File.stat(bin_path).mode\n      FileUtils.chmod mode | 0111, bin_path unless (mode | 0111) == mode\n\n      check_executable_overwrite filename\n\n      if @wrappers then\n        generate_bin_script filename, @bin_dir\n      else\n        generate_bin_symlink filename, @bin_dir\n      end\n\n    end\n  end\n\n  ##\n  # Creates the scripts to run the applications in the gem.\n  #--\n  # The Windows script is generated in addition to the regular one due to a\n  # bug or misfeature in the Windows shell's pipe.  See\n  # http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193379\n\n  def generate_bin_script(filename, bindir)\n    bin_script_path = File.join bindir, formatted_program_filename(filename)\n\n    FileUtils.rm_f bin_script_path # prior install may have been --no-wrappers\n\n    File.open bin_script_path, 'wb', 0755 do |file|\n      file.print app_script_text(filename)\n    end\n\n    verbose bin_script_path\n\n    generate_windows_script filename, bindir\n  end\n\n  ##\n  # Creates the symlinks to run the applications in the gem.  Moves\n  # the symlink if the gem being installed has a newer version.\n\n  def generate_bin_symlink(filename, bindir)\n    src = File.join gem_dir, spec.bindir, filename\n    dst = File.join bindir, formatted_program_filename(filename)\n\n    if File.exist? dst then\n      if File.symlink? dst then\n        link = File.readlink(dst).split File::SEPARATOR\n        cur_version = Gem::Version.create(link[-3].sub(/^.*-/, ''))\n        return if spec.version < cur_version\n      end\n      File.unlink dst\n    end\n\n    FileUtils.symlink src, dst, :verbose => Gem.configuration.really_verbose\n  rescue NotImplementedError, SystemCallError\n    alert_warning \"Unable to use symlinks, installing wrapper\"\n    generate_bin_script filename, bindir\n  end\n\n  ##\n  # Generates a #! line for +bin_file_name+'s wrapper copying arguments if\n  # necessary.\n  #\n  # If the :custom_shebang config is set, then it is used as a template\n  # for how to create the shebang used for to run a gem's executables.\n  #\n  # The template supports 4 expansions:\n  #\n  #  $env    the path to the unix env utility\n  #  $ruby   the path to the currently running ruby interpreter\n  #  $exec   the path to the gem's executable\n  #  $name   the name of the gem the executable is for\n  #\n\n  def shebang(bin_file_name)\n    ruby_name = RbConfig::CONFIG['ruby_install_name'] if @env_shebang\n    path = File.join gem_dir, spec.bindir, bin_file_name\n    first_line = File.open(path, \"rb\") {|file| file.gets}\n\n    if /\\A#!/ =~ first_line then\n      # Preserve extra words on shebang line, like \"-w\".  Thanks RPA.\n      shebang = first_line.sub(/\\A\\#!.*?ruby\\S*((\\s+\\S+)+)/, \"#!#{Gem.ruby}\")\n      opts = $1\n      shebang.strip! # Avoid nasty ^M issues.\n    end\n\n    if which = Gem.configuration[:custom_shebang]\n      # replace bin_file_name with \"ruby\" to avoid endless loops\n      which = which.gsub(/ #{bin_file_name}$/,\" #{RbConfig::CONFIG['ruby_install_name']}\")\n\n      which = which.gsub(/\\$(\\w+)/) do\n        case $1\n        when \"env\"\n          @env_path ||= ENV_PATHS.find {|env_path| File.executable? env_path }\n        when \"ruby\"\n          \"#{Gem.ruby}#{opts}\"\n        when \"exec\"\n          bin_file_name\n        when \"name\"\n          spec.name\n        end\n      end\n\n      \"#!#{which}\"\n    elsif not ruby_name then\n      \"#!#{Gem.ruby}#{opts}\"\n    elsif opts then\n      \"#!/bin/sh\\n'exec' #{ruby_name.dump} '-x' \\\"$0\\\" \\\"$@\\\"\\n#{shebang}\"\n    else\n      # Create a plain shebang line.\n      @env_path ||= ENV_PATHS.find {|env_path| File.executable? env_path }\n      \"#!#{@env_path} #{ruby_name}\"\n    end\n  end\n\n  ##\n  # Ensures the Gem::Specification written out for this gem is loadable upon\n  # installation.\n\n  def ensure_loadable_spec\n    ruby = spec.to_ruby_for_cache\n    ruby.untaint\n\n    begin\n      eval ruby\n    rescue StandardError, SyntaxError => e\n      raise Gem::InstallError,\n            \"The specification for #{spec.full_name} is corrupt (#{e.class})\"\n    end\n  end\n\n  def ensure_required_ruby_version_met # :nodoc:\n    if rrv = spec.required_ruby_version then\n      unless rrv.satisfied_by? Gem.ruby_version then\n        raise Gem::InstallError, \"#{spec.name} requires Ruby version #{rrv}.\"\n      end\n    end\n  end\n\n  def ensure_required_rubygems_version_met # :nodoc:\n    if rrgv = spec.required_rubygems_version then\n      unless rrgv.satisfied_by? Gem.rubygems_version then\n        raise Gem::InstallError,\n          \"#{spec.name} requires RubyGems version #{rrgv}. \" +\n          \"Try 'gem update --system' to update RubyGems itself.\"\n      end\n    end\n  end\n\n  def ensure_dependencies_met # :nodoc:\n    deps = spec.runtime_dependencies\n    deps |= spec.development_dependencies if @development\n\n    deps.each do |dep_gem|\n      ensure_dependency spec, dep_gem\n    end\n  end\n\n  def process_options # :nodoc:\n    @options = {\n      :bin_dir      => nil,\n      :env_shebang  => false,\n      :force        => false,\n      :only_install_dir => false,\n      :post_install_message => true\n    }.merge options\n\n    @env_shebang         = options[:env_shebang]\n    @force               = options[:force]\n    @install_dir         = options[:install_dir]\n    @gem_home            = options[:install_dir] || Gem.dir\n    @ignore_dependencies = options[:ignore_dependencies]\n    @format_executable   = options[:format_executable]\n    @wrappers            = options[:wrappers]\n    @only_install_dir    = options[:only_install_dir]\n\n    # If the user has asked for the gem to be installed in a directory that is\n    # the system gem directory, then use the system bin directory, else create\n    # (or use) a new bin dir under the gem_home.\n    @bin_dir             = options[:bin_dir] || Gem.bindir(gem_home)\n    @development         = options[:development]\n    @build_root          = options[:build_root]\n\n    @build_args          = options[:build_args] || Gem::Command.build_args\n\n    unless @build_root.nil?\n      require 'pathname'\n      @build_root = Pathname.new(@build_root).expand_path\n      @bin_dir = File.join(@build_root, options[:bin_dir] || Gem.bindir(@gem_home))\n      @gem_home = File.join(@build_root, @gem_home)\n      alert_warning \"You build with buildroot.\\n  Build root: #{@build_root}\\n  Bin dir: #{@bin_dir}\\n  Gem home: #{@gem_home}\"\n    end\n  end\n\n  def check_that_user_bin_dir_is_in_path # :nodoc:\n    user_bin_dir = @bin_dir || Gem.bindir(gem_home)\n    user_bin_dir = user_bin_dir.gsub(File::SEPARATOR, File::ALT_SEPARATOR) if\n      File::ALT_SEPARATOR\n\n    path = ENV['PATH']\n    if Gem.win_platform? then\n      path = path.downcase\n      user_bin_dir = user_bin_dir.downcase\n    end\n\n    path = path.split(File::PATH_SEPARATOR)\n\n    unless path.include? user_bin_dir then\n      unless !Gem.win_platform? && (path.include? user_bin_dir.sub(ENV['HOME'], '~'))\n        unless self.class.path_warning then\n          alert_warning \"You don't have #{user_bin_dir} in your PATH,\\n\\t  gem executables will not run.\"\n          self.class.path_warning = true\n        end\n      end\n    end\n  end\n\n  def verify_gem_home(unpack = false) # :nodoc:\n    FileUtils.mkdir_p gem_home\n    raise Gem::FilePermissionError, gem_home unless\n      unpack or File.writable?(gem_home)\n  end\n\n  ##\n  # Return the text for an application file.\n\n  def app_script_text(bin_file_name)\n    # note that the `load` lines cannot be indented, as old RG versions match\n    # against the beginning of the line\n    return <<-TEXT\n#{shebang bin_file_name}\n#\n# This file was generated by RubyGems.\n#\n# The application '#{spec.name}' is installed as part of a gem, and\n# this file is here to facilitate running it.\n#\n\nrequire 'rubygems'\n\nversion = \"#{Gem::Requirement.default}.a\"\n\nif ARGV.first\n  str = ARGV.first\n  str = str.dup.force_encoding(\"BINARY\") if str.respond_to? :force_encoding\n  if str =~ /\\\\A_(.*)_\\\\z/ and Gem::Version.correct?($1) then\n    version = $1\n    ARGV.shift\n  end\nend\n\nif Gem.respond_to?(:activate_bin_path)\nload Gem.activate_bin_path('#{spec.name}', '#{bin_file_name}', version)\nelse\ngem #{spec.name.dump}, version\nload Gem.bin_path(#{spec.name.dump}, #{bin_file_name.dump}, version)\nend\nTEXT\n  end\n\n  ##\n  # return the stub script text used to launch the true Ruby script\n\n  def windows_stub_script(bindir, bin_file_name)\n    ruby = Gem.ruby.gsub(/^\\\"|\\\"$/, \"\").tr(File::SEPARATOR, \"\\\\\")\n    return <<-TEXT\n@ECHO OFF\nIF NOT \"%~f0\" == \"~f0\" GOTO :WinNT\n@\"#{ruby}\" \"#{File.join(bindir, bin_file_name)}\" %1 %2 %3 %4 %5 %6 %7 %8 %9\nGOTO :EOF\n:WinNT\n@\"#{ruby}\" \"%~dpn0\" %*\nTEXT\n  end\n\n  ##\n  # Builds extensions.  Valid types of extensions are extconf.rb files,\n  # configure scripts and rakefiles or mkrf_conf files.\n\n  def build_extensions\n    builder = Gem::Ext::Builder.new spec, @build_args\n\n    builder.build_extensions\n  end\n\n  ##\n  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.\n  #\n  # TODO:  Delete this for RubyGems 3.  It remains for API compatibility\n\n  def extension_build_error(build_dir, output, backtrace = nil) # :nodoc:\n    builder = Gem::Ext::Builder.new spec, @build_args\n\n    builder.build_error build_dir, output, backtrace\n  end\n\n  ##\n  # Reads the file index and extracts each file into the gem directory.\n  #\n  # Ensures that files can't be installed outside the gem directory.\n\n  def extract_files\n    @package.extract_files gem_dir\n  end\n\n  ##\n  # Extracts only the bin/ files from the gem into the gem directory.\n  # This is used by default gems to allow a gem-aware stub to function\n  # without the full gem installed.\n\n  def extract_bin\n    @package.extract_files gem_dir, \"bin/*\"\n  end\n\n  ##\n  # Prefix and suffix the program filename the same as ruby.\n\n  def formatted_program_filename(filename)\n    if @format_executable then\n      self.class.exec_format % File.basename(filename)\n    else\n      filename\n    end\n  end\n\n  ##\n  #\n  # Return the target directory where the gem is to be installed. This\n  # directory is not guaranteed to be populated.\n  #\n\n  def dir\n    gem_dir.to_s\n  end\n\n  ##\n  # Performs various checks before installing the gem such as the install\n  # repository is writable and its directories exist, required Ruby and\n  # rubygems versions are met and that dependencies are installed.\n  #\n  # Version and dependency checks are skipped if this install is forced.\n  #\n  # The dependent check will be skipped this install is ignoring dependencies.\n\n  def pre_install_checks\n    verify_gem_home options[:unpack]\n\n    ensure_loadable_spec\n\n    if options[:install_as_default]\n      Gem.ensure_default_gem_subdirectories gem_home\n    else\n      Gem.ensure_gem_subdirectories gem_home\n    end\n\n    return true if @force\n\n    ensure_required_ruby_version_met\n    ensure_required_rubygems_version_met\n    ensure_dependencies_met unless @ignore_dependencies\n\n    true\n  end\n\n  ##\n  # Writes the file containing the arguments for building this gem's\n  # extensions.\n\n  def write_build_info_file\n    return if @build_args.empty?\n\n    build_info_dir = File.join gem_home, 'build_info'\n\n    FileUtils.mkdir_p build_info_dir\n\n    build_info_file = File.join build_info_dir, \"#{spec.full_name}.info\"\n\n    open build_info_file, 'w' do |io|\n      @build_args.each do |arg|\n        io.puts arg\n      end\n    end\n  end\n\n  ##\n  # Writes the .gem file to the cache directory\n\n  def write_cache_file\n    cache_file = File.join gem_home, 'cache', spec.file_name\n    @package.copy_to cache_file\n  end\n\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/installer_test_case'\n\nclass TestGemInstaller < Gem::InstallerTestCase\n  @@symlink_supported = nil\n\n  def symlink_supported?\n    if @@symlink_supported.nil?\n      begin\n        File.symlink(\"\", \"\")\n      rescue Errno::ENOENT, Errno::EEXIST\n        @@symlink_supported = true\n      rescue NotImplementedError, SystemCallError\n        @@symlink_supported = false\n      end\n    end\n    @@symlink_supported\n  end\n\n  def setup\n    super\n    common_installer_setup\n\n    if __name__ =~ /^test_install(_|$)/ then\n      FileUtils.rm_r @spec.gem_dir\n      FileUtils.rm_r @user_spec.gem_dir\n    end\n\n    @config = Gem.configuration\n  end\n\n  def teardown\n    common_installer_teardown\n\n    super\n\n    Gem.configuration = @config\n  end\n\n  def test_app_script_text\n    util_make_exec @spec, ''\n\n    expected = <<-EOF\n#!#{Gem.ruby}\n#\n# This file was generated by RubyGems.\n#\n# The application 'a' is installed as part of a gem, and\n# this file is here to facilitate running it.\n#\n\nrequire 'rubygems'\n\nversion = \\\">= 0.a\\\"\n\nif ARGV.first\n  str = ARGV.first\n  str = str.dup.force_encoding(\"BINARY\") if str.respond_to? :force_encoding\n  if str =~ /\\\\A_(.*)_\\\\z/ and Gem::Version.correct?($1) then\n    version = $1\n    ARGV.shift\n  end\nend\n\nif Gem.respond_to?(:activate_bin_path)\nload Gem.activate_bin_path('a', 'executable', version)\nelse\ngem \"a\", version\nload Gem.bin_path(\"a\", \"executable\", version)\nend\n    EOF\n\n    wrapper = @installer.app_script_text 'executable'\n    assert_equal expected, wrapper\n  end\n\n  def test_check_executable_overwrite\n    @installer.generate_bin\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    util_make_exec\n    @installer.gem_dir = util_gem_dir @spec\n    @installer.wrappers = true\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_check_executable_overwrite_default_bin_dir\n    if defined?(RUBY_FRAMEWORK_VERSION)\n      orig_RUBY_FRAMEWORK_VERSION = RUBY_FRAMEWORK_VERSION\n      Object.send :remove_const, :RUBY_FRAMEWORK_VERSION\n    end\n    orig_bindir = RbConfig::CONFIG['bindir']\n    RbConfig::CONFIG['bindir'] = Gem.bindir\n\n    util_conflict_executable false\n\n    ui = Gem::MockGemUi.new \"n\\n\"\n    use_ui ui do\n      e = assert_raises Gem::InstallError do\n        @installer.generate_bin\n      end\n\n      conflicted = File.join @gemhome, 'bin', 'executable'\n      assert_match %r%\\A\"executable\" from a conflicts with (?:#{Regexp.quote(conflicted)}|installed executable from conflict)\\z%,\n                   e.message\n    end\n  ensure\n    Object.const_set :RUBY_FRAMEWORK_VERSION, orig_RUBY_FRAMEWORK_VERSION if\n      orig_RUBY_FRAMEWORK_VERSION\n    if orig_bindir then\n      RbConfig::CONFIG['bindir'] = orig_bindir\n    else\n      RbConfig::CONFIG.delete 'bindir'\n    end\n  end\n\n  def test_check_executable_overwrite_format_executable\n    @installer.generate_bin\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    open File.join(util_inst_bindir, 'executable'), 'w' do |io|\n     io.write <<-EXEC\n#!/usr/local/bin/ruby\n#\n# This file was generated by RubyGems\n\ngem 'other', version\n     EXEC\n    end\n\n    util_make_exec\n    Gem::Installer.exec_format = 'foo-%s-bar'\n    @installer.gem_dir = @spec.gem_dir\n    @installer.wrappers = true\n    @installer.format_executable = true\n\n    @installer.generate_bin # should not raise\n\n    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_check_executable_overwrite_other_gem\n    util_conflict_executable true\n\n    ui = Gem::MockGemUi.new \"n\\n\"\n\n    use_ui ui do\n      e = assert_raises Gem::InstallError do\n        @installer.generate_bin\n      end\n\n      assert_equal '\"executable\" from a conflicts with installed executable from conflict',\n                   e.message\n    end\n  end\n\n  def test_check_executable_overwrite_other_gem_force\n    util_conflict_executable true\n    @installer.wrappers = true\n    @installer.force = true\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_check_executable_overwrite_other_non_gem\n    util_conflict_executable false\n    @installer.wrappers = true\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end unless Gem.win_platform?\n\n  def test_check_that_user_bin_dir_is_in_path\n    bin_dir = @installer.bin_dir\n\n    if Gem.win_platform?\n      bin_dir = bin_dir.downcase.gsub(File::SEPARATOR, File::ALT_SEPARATOR)\n    end\n\n    orig_PATH, ENV['PATH'] =\n      ENV['PATH'], [ENV['PATH'], bin_dir].join(File::PATH_SEPARATOR)\n\n    use_ui @ui do\n      @installer.check_that_user_bin_dir_is_in_path\n    end\n\n    assert_empty @ui.error\n  ensure\n    ENV['PATH'] = orig_PATH\n  end\n\n  def test_check_that_user_bin_dir_is_in_path_tilde\n    skip \"Tilde is PATH is not supported under MS Windows\" if win_platform?\n\n    orig_PATH, ENV['PATH'] =\n      ENV['PATH'], [ENV['PATH'], '~/bin'].join(File::PATH_SEPARATOR)\n\n    @installer.bin_dir.replace File.join @userhome, 'bin'\n\n    use_ui @ui do\n      @installer.check_that_user_bin_dir_is_in_path\n    end\n\n    assert_empty @ui.error\n  ensure\n    ENV['PATH'] = orig_PATH unless win_platform?\n  end\n\n  def test_check_that_user_bin_dir_is_in_path_not_in_path\n    use_ui @ui do\n      @installer.check_that_user_bin_dir_is_in_path\n    end\n\n    expected = @installer.bin_dir\n\n    if Gem.win_platform? then\n      expected = expected.downcase.gsub(File::SEPARATOR, File::ALT_SEPARATOR)\n    end\n\n    assert_match expected, @ui.error\n  end\n\n  def test_ensure_dependency\n    util_spec 'a'\n\n    dep = Gem::Dependency.new 'a', '>= 2'\n    assert @installer.ensure_dependency(@spec, dep)\n\n    dep = Gem::Dependency.new 'b', '> 2'\n    e = assert_raises Gem::InstallError do\n      @installer.ensure_dependency @spec, dep\n    end\n\n    assert_equal 'a requires b (> 2)', e.message\n  end\n\n  def test_ensure_loadable_spec\n    a, a_gem = util_gem 'a', 2 do |s|\n      s.add_dependency 'garbage ~> 5'\n    end\n\n    installer = Gem::Installer.at a_gem\n\n    e = assert_raises Gem::InstallError do\n      installer.ensure_loadable_spec\n    end\n\n    assert_equal \"The specification for #{a.full_name} is corrupt \" +\n                 \"(SyntaxError)\", e.message\n  end\n\n  def test_ensure_loadable_spec_security_policy\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    _, a_gem = util_gem 'a', 2 do |s|\n      s.add_dependency 'garbage ~> 5'\n    end\n\n    policy = Gem::Security::HighSecurity\n    installer = Gem::Installer.at a_gem, :security_policy => policy\n\n    assert_raises Gem::Security::Exception do\n      installer.ensure_loadable_spec\n    end\n  end\n\n  def test_extract_files\n    @installer.extract_files\n\n    assert_path_exists File.join util_gem_dir, 'bin/executable'\n  end\n\n  def test_generate_bin_bindir\n    @installer.wrappers = true\n\n    @spec.executables = %w[executable]\n    @spec.bindir = '.'\n\n    exec_file = @installer.formatted_program_filename 'executable'\n    exec_path = File.join util_gem_dir(@spec), exec_file\n    File.open exec_path, 'w' do |f|\n      f.puts '#!/usr/bin/ruby'\n    end\n\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_bindir_with_user_install_warning\n    bin_dir = Gem.win_platform? ? File.expand_path(ENV[\"WINDIR\"]).upcase :\n                                  \"/usr/bin\"\n\n    options = {\n      :bin_dir => bin_dir,\n      :install_dir => \"/non/existent\"\n    }\n\n    inst = Gem::Installer.at '', options\n\n    Gem::Installer.path_warning = false\n\n    use_ui @ui do\n      inst.check_that_user_bin_dir_is_in_path\n    end\n\n    assert_equal \"\", @ui.error\n  end\n\n  def test_generate_bin_script\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    assert File.directory? util_inst_bindir\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_script_format\n    @installer.format_executable = true\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    Gem::Installer.exec_format = 'foo-%s-bar'\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'\n    assert_path_exists installed_exec\n  ensure\n    Gem::Installer.exec_format = nil\n  end\n\n  def test_generate_bin_script_format_disabled\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    Gem::Installer.exec_format = 'foo-%s-bar'\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n  ensure\n    Gem::Installer.exec_format = nil\n  end\n\n  def test_generate_bin_script_install_dir\n    @installer.wrappers = true\n\n    gem_dir = File.join(\"#{@gemhome}2\", \"gems\", @spec.full_name)\n    gem_bindir = File.join gem_dir, 'bin'\n    FileUtils.mkdir_p gem_bindir\n    File.open File.join(gem_bindir, 'executable'), 'w' do |f|\n      f.puts \"#!/bin/ruby\"\n    end\n\n    @installer.gem_home = \"#{@gemhome}2\"\n    @installer.gem_dir = gem_dir\n    @installer.bin_dir = File.join \"#{@gemhome}2\", 'bin'\n\n    @installer.generate_bin\n\n    installed_exec = File.join(\"#{@gemhome}2\", \"bin\", 'executable')\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_script_no_execs\n    util_execless\n\n    @installer.wrappers = true\n    @installer.generate_bin\n\n    refute_path_exists util_inst_bindir, 'bin dir was created when not needed'\n  end\n\n  def test_generate_bin_script_no_perms\n    @installer.wrappers = true\n    util_make_exec\n\n    Dir.mkdir util_inst_bindir\n\n    if win_platform?\n      skip('test_generate_bin_script_no_perms skipped on MS Windows')\n    else\n      FileUtils.chmod 0000, util_inst_bindir\n\n      assert_raises Gem::FilePermissionError do\n        @installer.generate_bin\n      end\n    end\n  ensure\n    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG or win_platform?)\n  end\n\n  def test_generate_bin_script_no_shebang\n    @installer.wrappers = true\n    @spec.executables = %w[executable]\n\n    gem_dir = File.join @gemhome, 'gems', @spec.full_name\n    gem_bindir = File.join gem_dir, 'bin'\n    FileUtils.mkdir_p gem_bindir\n    File.open File.join(gem_bindir, 'executable'), 'w' do |f|\n      f.puts \"blah blah blah\"\n    end\n\n    @installer.generate_bin\n\n    installed_exec = File.join @gemhome, 'bin', 'executable'\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n    # HACK some gems don't have #! in their executables, restore 2008/06\n    #assert_no_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_script_wrappers\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n    installed_exec = File.join(util_inst_bindir, 'executable')\n\n    real_exec = File.join util_gem_dir, 'bin', 'executable'\n\n    # fake --no-wrappers for previous install\n    unless Gem.win_platform? then\n      FileUtils.mkdir_p File.dirname(installed_exec)\n      FileUtils.ln_s real_exec, installed_exec\n    end\n\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    assert_match %r|generated by RubyGems|, File.read(installed_exec)\n\n    refute_match %r|generated by RubyGems|, File.read(real_exec),\n                 'real executable overwritten'\n  end\n\n  def test_generate_bin_symlink\n    return if win_platform? #Windows FS do not support symlinks\n\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_equal true, File.symlink?(installed_exec)\n    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),\n                 File.readlink(installed_exec))\n  end\n\n  def test_generate_bin_symlink_no_execs\n    util_execless\n\n    @installer.wrappers = false\n    @installer.generate_bin\n\n    refute_path_exists util_inst_bindir\n  end\n\n  def test_generate_bin_symlink_no_perms\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    Dir.mkdir util_inst_bindir\n\n    if win_platform?\n      skip('test_generate_bin_symlink_no_perms skipped on MS Windows')\n    else\n      FileUtils.chmod 0000, util_inst_bindir\n\n      assert_raises Gem::FilePermissionError do\n        @installer.generate_bin\n      end\n    end\n  ensure\n    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG or win_platform?)\n  end\n\n  def test_generate_bin_symlink_update_newer\n    return if win_platform? #Windows FS do not support symlinks\n\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),\n                 File.readlink(installed_exec))\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    util_make_exec\n    @installer.gem_dir = util_gem_dir @spec\n    @installer.generate_bin\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_equal(@spec.bin_file('executable'),\n                 File.readlink(installed_exec),\n                 \"Ensure symlink moved to latest version\")\n  end\n\n  def test_generate_bin_symlink_update_older\n    return if !symlink_supported?\n\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),\n                 File.readlink(installed_exec))\n\n    spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"1\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    util_make_exec\n    one = @spec.dup\n    one.version = 1\n    @installer = Gem::Installer.for_spec spec\n    @installer.gem_dir = util_gem_dir one\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    expected = File.join util_gem_dir, 'bin', 'executable'\n    assert_equal(expected,\n                 File.readlink(installed_exec),\n                 \"Ensure symlink not moved\")\n  end\n\n  def test_generate_bin_symlink_update_remove_wrapper\n    return if !symlink_supported?\n\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n    util_make_exec\n\n    util_installer @spec, @gemhome\n    @installer.wrappers = false\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_equal(@spec.bin_file('executable'),\n                 File.readlink(installed_exec),\n                 \"Ensure symlink moved to latest version\")\n  end\n\n  def test_generate_bin_symlink_win32\n    old_win_platform = Gem.win_platform?\n    Gem.win_platform = true\n    old_alt_separator = File::ALT_SEPARATOR\n    File.__send__(:remove_const, :ALT_SEPARATOR)\n    File.const_set(:ALT_SEPARATOR, '\\\\')\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    use_ui @ui do\n      @installer.generate_bin\n    end\n\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_path_exists installed_exec\n\n    if symlink_supported?\n      assert_send([File, :symlink?, installed_exec])\n      return\n    end\n\n    assert_match(/Unable to use symlinks, installing wrapper/i,\n                 @ui.error)\n\n    wrapper = File.read installed_exec\n    assert_match(/generated by RubyGems/, wrapper)\n  ensure\n    File.__send__(:remove_const, :ALT_SEPARATOR)\n    File.const_set(:ALT_SEPARATOR, old_alt_separator)\n    Gem.win_platform = old_win_platform\n  end\n\n  def test_generate_bin_uses_default_shebang\n    return if !symlink_supported?\n\n    @installer.wrappers = true\n    util_make_exec\n\n    @installer.generate_bin\n\n    default_shebang = Gem.ruby\n    shebang_line = open(\"#{@gemhome}/bin/executable\") { |f| f.readlines.first }\n    assert_match(/\\A#!/, shebang_line)\n    assert_match(/#{default_shebang}/, shebang_line)\n  end\n\n  def test_initialize\n    spec = util_spec 'a' do |s| s.platform = Gem::Platform.new 'mswin32' end\n    gem = File.join @tempdir, spec.file_name\n\n    Dir.mkdir util_inst_bindir\n    util_build_gem spec\n    FileUtils.mv spec.cache_file, @tempdir\n\n    installer = Gem::Installer.at gem\n\n    assert_equal File.join(@gemhome, 'gems', spec.full_name), installer.gem_dir\n    assert_equal File.join(@gemhome, 'bin'), installer.bin_dir\n  end\n\n  def test_initialize_user_install\n    installer = Gem::Installer.at @gem, :user_install => true\n\n    assert_equal File.join(Gem.user_dir, 'gems', @spec.full_name),\n                 installer.gem_dir\n    assert_equal Gem.bindir(Gem.user_dir), installer.bin_dir\n  end\n\n  def test_initialize_user_install_bin_dir\n    installer =\n      Gem::Installer.at @gem, :user_install => true, :bin_dir => @tempdir\n\n    assert_equal File.join(Gem.user_dir, 'gems', @spec.full_name),\n                 installer.gem_dir\n    assert_equal @tempdir, installer.bin_dir\n  end\n\n  def test_install\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    gemdir     = File.join @gemhome, 'gems', @spec.full_name\n    cache_file = File.join @gemhome, 'cache', @spec.file_name\n    stub_exe   = File.join @gemhome, 'bin', 'executable'\n    rakefile   = File.join gemdir, 'ext', 'a', 'Rakefile'\n    spec_file  = File.join @gemhome, 'specifications', @spec.spec_name\n\n    Gem.pre_install do |installer|\n      refute_path_exists cache_file, 'cache file must not exist yet'\n      refute_path_exists spec_file,  'spec file must not exist yet'\n      true\n    end\n\n    Gem.post_build do |installer|\n      assert_path_exists gemdir, 'gem install dir must exist'\n      assert_path_exists rakefile, 'gem executable must exist'\n      refute_path_exists stub_exe, 'gem executable must not exist'\n      refute_path_exists spec_file, 'spec file must not exist yet'\n      true\n    end\n\n    Gem.post_install do |installer|\n      assert_path_exists cache_file, 'cache file must exist'\n      assert_path_exists spec_file,  'spec file must exist'\n    end\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    assert_equal @spec, @newspec\n    assert_path_exists gemdir\n    assert_path_exists stub_exe, 'gem executable must exist'\n\n    exe = File.join gemdir, 'bin', 'executable'\n    assert_path_exists exe\n\n    exe_mode = File.stat(exe).mode & 0111\n    assert_equal 0111, exe_mode, \"0%o\" % exe_mode unless win_platform?\n\n    assert_path_exists File.join gemdir, 'lib', 'code.rb'\n\n    assert_path_exists rakefile\n\n    spec_file = File.join(@gemhome, 'specifications', @spec.spec_name)\n\n    assert_equal spec_file, @newspec.loaded_from\n    assert_path_exists spec_file\n\n    assert_same @installer, @post_build_hook_arg\n    assert_same @installer, @post_install_hook_arg\n    assert_same @installer, @pre_install_hook_arg\n  end\n\n  def test_install_creates_working_binstub\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    @installer.wrappers = true\n\n    gemdir = File.join @gemhome, 'gems', @spec.full_name\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    exe = File.join gemdir, 'bin', 'executable'\n\n    e = assert_raises RuntimeError do\n      instance_eval File.read(exe)\n    end\n\n    assert_match(/ran executable/, e.message)\n  end\n\n  def test_conflicting_binstubs\n    Dir.mkdir util_inst_bindir\n    util_clear_gems\n\n    # build old version that has a bin file\n    util_setup_gem do |spec|\n      File.open File.join('bin', 'executable'), 'w' do |f|\n        f.puts \"require 'code'\"\n      end\n      File.open File.join('lib', 'code.rb'), 'w' do |f|\n        f.puts 'raise \"I have an executable\"'\n      end\n    end\n\n    @installer.wrappers = true\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    old_bin_file = File.join @installer.bin_dir, 'executable'\n\n    # build new version that doesn't have a bin file\n    util_setup_gem do |spec|\n      FileUtils.rm File.join('bin', 'executable')\n      spec.files.delete File.join('bin', 'executable')\n      spec.executables.delete 'executable'\n      spec.version = @spec.version.bump\n      File.open File.join('lib', 'code.rb'), 'w' do |f|\n        f.puts 'raise \"I do not have an executable\"'\n      end\n    end\n\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    e = assert_raises RuntimeError do\n      instance_eval File.read(old_bin_file)\n    end\n\n    # We expect the bin stub to activate the version that actually contains\n    # the binstub.\n    assert_match('I have an executable', e.message)\n  end\n\n  def test_install_creates_binstub_that_understand_version\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    @installer.wrappers = true\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    exe = File.join @gemhome, 'bin', 'executable'\n\n    ARGV.unshift \"_3.0_\"\n\n    begin\n      Gem::Specification.reset\n\n      e = assert_raises Gem::GemNotFoundException do\n        instance_eval File.read(exe)\n      end\n    ensure\n      ARGV.shift if ARGV.first == \"_3.0_\"\n    end\n\n    assert_includes(e.message, \"can't find gem a (= 3.0)\")\n  end\n\n  def test_install_creates_binstub_that_dont_trust_encoding\n    skip unless \"\".respond_to?(:force_encoding)\n\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    @installer.wrappers = true\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    exe = File.join @gemhome, 'bin', 'executable'\n\n    extra_arg = \"\\xE4pfel\".dup.force_encoding(\"UTF-8\")\n    ARGV.unshift extra_arg\n\n    begin\n      Gem::Specification.reset\n\n      e = assert_raises RuntimeError do\n        instance_eval File.read(exe)\n      end\n    ensure\n      ARGV.shift if ARGV.first == extra_arg\n    end\n\n    assert_match(/ran executable/, e.message)\n  end\n\n  def test_install_with_no_prior_files\n    Dir.mkdir util_inst_bindir\n    util_clear_gems\n\n    util_setup_gem\n    build_rake_in do\n      use_ui @ui do\n        assert_equal @spec, @installer.install\n      end\n    end\n\n    gemdir = File.join(@gemhome, 'gems', @spec.full_name)\n    assert_path_exists File.join gemdir, 'lib', 'code.rb'\n\n    util_setup_gem\n    # Morph spec to have lib/other.rb instead of code.rb and recreate\n    @spec.files = File.join('lib', 'other.rb')\n    Dir.chdir @tempdir do\n      File.open File.join('lib', 'other.rb'), 'w' do |f| f.puts '1' end\n      use_ui ui do\n        FileUtils.rm @gem\n        Gem::Package.build @spec\n      end\n    end\n    @installer = Gem::Installer.at @gem\n    build_rake_in do\n      use_ui @ui do\n        assert_equal @spec, @installer.install\n      end\n    end\n\n    assert_path_exists File.join gemdir, 'lib', 'other.rb'\n    refute_path_exists File.join gemdir, 'lib', 'code.rb',\n           \"code.rb from prior install of same gem shouldn't remain here\"\n  end\n\n  def test_install_force\n    use_ui @ui do\n      installer = Gem::Installer.at old_ruby_required, :force => true\n      installer.install\n    end\n\n    gem_dir = File.join(@gemhome, 'gems', 'old_ruby_required-1')\n    assert_path_exists gem_dir\n  end\n\n  def test_install_missing_dirs\n    FileUtils.rm_f File.join(Gem.dir, 'cache')\n    FileUtils.rm_f File.join(Gem.dir, 'docs')\n    FileUtils.rm_f File.join(Gem.dir, 'specifications')\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    File.directory? File.join(Gem.dir, 'cache')\n    File.directory? File.join(Gem.dir, 'docs')\n    File.directory? File.join(Gem.dir, 'specifications')\n\n    assert_path_exists File.join @gemhome, 'cache', @spec.file_name\n    assert_path_exists File.join @gemhome, 'specifications', @spec.spec_name\n  end\n\n  def test_install_post_build_false\n    util_clear_gems\n\n    Gem.post_build do\n      false\n    end\n\n    use_ui @ui do\n      e = assert_raises Gem::InstallError do\n        @installer.install\n      end\n\n      location = \"#{__FILE__}:#{__LINE__ - 9}\"\n\n      assert_equal \"post-build hook at #{location} failed for a-2\", e.message\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    refute_path_exists spec_file\n\n    gem_dir = File.join @gemhome, 'gems', @spec.full_name\n    refute_path_exists gem_dir\n  end\n\n  def test_install_post_build_nil\n    util_clear_gems\n\n    Gem.post_build do\n      nil\n    end\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    assert_path_exists spec_file\n\n    gem_dir = File.join @gemhome, 'gems', @spec.full_name\n    assert_path_exists gem_dir\n  end\n\n  def test_install_pre_install_false\n    util_clear_gems\n\n    Gem.pre_install do\n      false\n    end\n\n    use_ui @ui do\n      e = assert_raises Gem::InstallError do\n        @installer.install\n      end\n\n      location = \"#{__FILE__}:#{__LINE__ - 9}\"\n\n      assert_equal \"pre-install hook at #{location} failed for a-2\", e.message\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    refute_path_exists spec_file\n  end\n\n  def test_install_pre_install_nil\n    util_clear_gems\n\n    Gem.pre_install do\n      nil\n    end\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    assert_path_exists spec_file\n  end\n\n  def test_install_with_message\n    @spec.post_install_message = 'I am a shiny gem!'\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path\n      @installer.install\n    end\n\n    assert_match %r|I am a shiny gem!|, @ui.output\n  end\n\n  def test_install_with_skipped_message\n    @spec.post_install_message = 'I am a shiny gem!'\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path, :post_install_message => false\n      @installer.install\n    end\n\n    refute_match %r|I am a shiny gem!|, @ui.output\n  end\n\n  def test_install_extension_dir\n    gemhome2 = \"#{@gemhome}2\"\n\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    @spec.files += %w[extconf.rb]\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      installer = Gem::Installer.at path, :install_dir => gemhome2\n      installer.install\n    end\n\n    expected_makefile = File.join gemhome2, 'gems', @spec.full_name, 'Makefile'\n\n    assert_path_exists expected_makefile\n  end\n\n  def test_install_extension_dir_is_removed_on_reinstall\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    @spec.files += %w[extconf.rb]\n\n    path = Gem::Package.build @spec\n\n    # Install a gem with an extension\n    use_ui @ui do\n      installer = Gem::Installer.at path\n      installer.install\n    end\n\n    # pretend that a binary file was created as part of the build\n    should_be_removed = File.join(@spec.extension_dir, \"#{@spec.name}.so\")\n    write_file should_be_removed do |io|\n      io.write \"DELETE ME ON REINSTALL\"\n    end\n    assert_path_exists should_be_removed\n\n    # reinstall the gem, this is also the same as pristine\n    use_ui @ui do\n      installer = Gem::Installer.at path\n      installer.install\n    end\n\n    refute_path_exists should_be_removed\n  end\n\n  def test_install_user_extension_dir\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    @spec.files += %w[extconf.rb]\n\n    # Create the non-user ext dir\n    expected_extension_dir = @spec.extension_dir.dup\n    FileUtils.mkdir_p expected_extension_dir\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      installer = Gem::Installer.at path, :user_install => true\n      installer.install\n    end\n\n    expected_makefile = File.join Gem.user_dir, 'gems', @spec.full_name, 'Makefile'\n\n    assert_path_exists expected_makefile\n    assert_path_exists expected_extension_dir\n    refute_path_exists File.join expected_extension_dir, 'gem_make.out'\n  end\n\n  # ruby core repository needs to `depend` file for extension build.\n  # but 1.9.2 and earlier mkmf.rb does not create TOUCH file like depend.\n  if RUBY_VERSION < '1.9.3'\n    def test_find_lib_file_after_install\n\n      @spec.extensions << \"extconf.rb\"\n      write_file File.join(@tempdir, \"extconf.rb\") do |io|\n        io.write <<-RUBY\n          require \"mkmf\"\n          create_makefile(\"#{@spec.name}\")\n        RUBY\n      end\n\n      write_file File.join(@tempdir, \"a.c\") do |io|\n        io.write <<-C\n          #include <ruby.h>\n          void Init_a() { }\n        C\n      end\n\n      Dir.mkdir File.join(@tempdir, \"lib\")\n      write_file File.join(@tempdir, 'lib', \"b.rb\") do |io|\n        io.write \"# b.rb\"\n      end\n\n      @spec.files += %w[extconf.rb lib/b.rb a.c]\n\n      use_ui @ui do\n        path = Gem::Package.build @spec\n\n        installer = Gem::Installer.at path\n        installer.install\n      end\n\n      expected = File.join @spec.full_require_paths.find { |path|\n        File.exist? File.join path, 'b.rb'\n      }, 'b.rb'\n      assert_equal expected, @spec.matches_for_glob('b.rb').first\n    end\n  else\n    def test_find_lib_file_after_install\n      @spec.extensions << \"extconf.rb\"\n      write_file File.join(@tempdir, \"extconf.rb\") do |io|\n        io.write <<-RUBY\n          require \"mkmf\"\n\n          CONFIG['CC'] = '$(TOUCH) $@ ||'\n          CONFIG['LDSHARED'] = '$(TOUCH) $@ ||'\n          $ruby = '#{Gem.ruby}'\n\n          create_makefile(\"#{@spec.name}\")\n        RUBY\n      end\n\n      write_file File.join(@tempdir, \"depend\")\n\n      write_file File.join(@tempdir, \"a.c\") do |io|\n        io.write <<-C\n          #include <ruby.h>\n          void Init_a() { }\n        C\n      end\n\n      Dir.mkdir File.join(@tempdir, \"lib\")\n      write_file File.join(@tempdir, 'lib', \"b.rb\") do |io|\n        io.write \"# b.rb\"\n      end\n\n      @spec.files += %w[extconf.rb lib/b.rb depend a.c]\n\n      use_ui @ui do\n        path = Gem::Package.build @spec\n\n        installer = Gem::Installer.at path\n        installer.install\n      end\n\n      expected = File.join @spec.full_require_paths.find { |path|\n        File.exist? File.join path, 'b.rb'\n      }, 'b.rb'\n      assert_equal expected, @spec.matches_for_glob('b.rb').first\n    end\n  end\n\n  def test_install_extension_and_script\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    rb = File.join(\"lib\", \"#{@spec.name}.rb\")\n    @spec.files += [rb]\n    write_file File.join(@tempdir, rb) do |io|\n      io.write <<-RUBY\n        # #{@spec.name}.rb\n      RUBY\n    end\n\n    Dir.mkdir(File.join(\"lib\", @spec.name))\n    rb2 = File.join(\"lib\", @spec.name, \"#{@spec.name}.rb\")\n    @spec.files << rb2\n    write_file File.join(@tempdir, rb2) do |io|\n      io.write <<-RUBY\n        # #{@spec.name}/#{@spec.name}.rb\n      RUBY\n    end\n\n    refute_path_exists File.join @spec.gem_dir, rb\n    refute_path_exists File.join @spec.gem_dir, rb2\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path\n      @installer.install\n    end\n    assert_path_exists File.join @spec.gem_dir, rb\n    assert_path_exists File.join @spec.gem_dir, rb2\n  end\n\n  def test_install_extension_flat\n    skip '1.9.2 and earlier mkmf.rb does not create TOUCH' if\n      RUBY_VERSION < '1.9.3'\n\n    if RUBY_VERSION == \"1.9.3\" and RUBY_PATCHLEVEL <= 194\n      skip \"TOUCH was introduced into 1.9.3 after p194\"\n    end\n\n    @spec.require_paths = [\".\"]\n\n    @spec.extensions << \"extconf.rb\"\n\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n\n        CONFIG['CC'] = '$(TOUCH) $@ ||'\n        CONFIG['LDSHARED'] = '$(TOUCH) $@ ||'\n        $ruby = '#{Gem.ruby}'\n\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    # empty depend file for no auto dependencies\n    @spec.files += %W\"depend #{@spec.name}.c\".each {|file|\n      write_file File.join(@tempdir, file)\n    }\n\n    so = File.join(@spec.gem_dir, \"#{@spec.name}.#{RbConfig::CONFIG[\"DLEXT\"]}\")\n    refute_path_exists so\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path\n      @installer.install\n    end\n    assert_path_exists so\n  rescue\n    puts '-' * 78\n    puts File.read File.join(@gemhome, 'gems', 'a-2', 'Makefile')\n    puts '-' * 78\n\n    path = File.join(@gemhome, 'gems', 'a-2', 'gem_make.out')\n\n    if File.exist?(path)\n      puts File.read(path)\n      puts '-' * 78\n    end\n\n    raise\n  end\n\n  def test_installation_satisfies_dependency_eh\n    util_spec 'a'\n\n    dep = Gem::Dependency.new 'a', '>= 2'\n    assert @installer.installation_satisfies_dependency?(dep)\n\n    dep = Gem::Dependency.new 'a', '> 2'\n    refute @installer.installation_satisfies_dependency?(dep)\n  end\n\n  def test_installation_satisfies_dependency_eh_development\n    @installer.options[:development] = true\n    @installer.options[:dev_shallow] = true\n\n    util_spec 'a'\n\n    dep = Gem::Dependency.new 'a', :development\n    assert @installer.installation_satisfies_dependency?(dep)\n  end\n\n  def test_pre_install_checks_dependencies\n    @spec.add_dependency 'b', '> 5'\n    util_setup_gem\n\n    use_ui @ui do\n      assert_raises Gem::InstallError do\n        @installer.install\n      end\n    end\n  end\n\n  def test_pre_install_checks_dependencies_ignore\n    @spec.add_dependency 'b', '> 5'\n    @installer.ignore_dependencies = true\n\n    build_rake_in do\n      use_ui @ui do\n        assert @installer.pre_install_checks\n      end\n    end\n  end\n\n  def test_pre_install_checks_dependencies_install_dir\n    gemhome2 = \"#{@gemhome}2\"\n    @spec.add_dependency 'd'\n\n    quick_gem 'd', 2\n\n    gem = File.join @gemhome, @spec.file_name\n\n    FileUtils.mv @gemhome, gemhome2\n    FileUtils.mkdir @gemhome\n\n    FileUtils.mv File.join(gemhome2, 'cache', @spec.file_name), gem\n\n    # Don't leak any already activated gems into the installer, require\n    # that it work everything out on it's own.\n    Gem::Specification.reset\n\n    installer = Gem::Installer.at gem, :install_dir => gemhome2\n\n    build_rake_in do\n      use_ui @ui do\n        assert installer.pre_install_checks\n      end\n    end\n  end\n\n  def test_pre_install_checks_ruby_version\n    use_ui @ui do\n      installer = Gem::Installer.at old_ruby_required\n      e = assert_raises Gem::InstallError do\n        installer.pre_install_checks\n      end\n      assert_equal 'old_ruby_required requires Ruby version = 1.4.6.',\n                   e.message\n    end\n  end\n\n  def test_pre_install_checks_wrong_rubygems_version\n    spec = util_spec 'old_rubygems_required', '1' do |s|\n      s.required_rubygems_version = '< 0'\n    end\n\n    util_build_gem spec\n\n    gem = File.join(@gemhome, 'cache', spec.file_name)\n\n    use_ui @ui do\n      @installer = Gem::Installer.at gem\n      e = assert_raises Gem::InstallError do\n        @installer.pre_install_checks\n      end\n      assert_equal 'old_rubygems_required requires RubyGems version < 0. ' +\n        \"Try 'gem update --system' to update RubyGems itself.\", e.message\n    end\n  end\n\n  def test_shebang\n    util_make_exec @spec, \"#!/usr/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_process_options\n    assert_nil @installer.build_root\n    assert_equal File.join(@gemhome, 'bin'), @installer.bin_dir\n    assert_equal @gemhome, @installer.gem_home\n  end\n\n  def test_process_options_build_root\n    build_root = File.join @tempdir, 'build_root'\n\n    @installer = Gem::Installer.at @gem, :build_root => build_root\n\n    assert_equal Pathname(build_root), @installer.build_root\n    assert_equal File.join(build_root, @gemhome, 'bin'), @installer.bin_dir\n    assert_equal File.join(build_root, @gemhome), @installer.gem_home\n  end\n\n  def test_shebang_arguments\n    util_make_exec @spec, \"#!/usr/bin/ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_empty\n    util_make_exec @spec, ''\n\n    shebang = @installer.shebang 'executable'\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_env\n    util_make_exec @spec, \"#!/usr/bin/env ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_env_arguments\n    util_make_exec @spec, \"#!/usr/bin/env ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_env_shebang\n    util_make_exec @spec, ''\n    @installer.env_shebang = true\n\n    shebang = @installer.shebang 'executable'\n\n    env_shebang = \"/usr/bin/env\" unless Gem.win_platform?\n\n    assert_equal(\"#!#{env_shebang} #{RbConfig::CONFIG['ruby_install_name']}\",\n                 shebang)\n  end\n\n  def test_shebang_nested\n    util_make_exec @spec, \"#!/opt/local/ruby/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_nested_arguments\n    util_make_exec @spec, \"#!/opt/local/ruby/bin/ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_version\n    util_make_exec @spec, \"#!/usr/bin/ruby18\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_version_arguments\n    util_make_exec @spec, \"#!/usr/bin/ruby18 -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_version_env\n    util_make_exec @spec, \"#!/usr/bin/env ruby18\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_version_env_arguments\n    util_make_exec @spec, \"#!/usr/bin/env ruby18 -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_custom\n    conf = Gem::ConfigFile.new []\n    conf[:custom_shebang] = 'test'\n\n    Gem.configuration = conf\n\n    util_make_exec @spec, \"#!/usr/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!test\", shebang\n  end\n\n  def test_shebang_custom_with_expands\n    bin_env = win_platform? ? '' : '/usr/bin/env'\n    conf = Gem::ConfigFile.new []\n    conf[:custom_shebang] = '1 $env 2 $ruby 3 $exec 4 $name'\n\n    Gem.configuration = conf\n\n    util_make_exec @spec, \"#!/usr/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!1 #{bin_env} 2 #{Gem.ruby} 3 executable 4 a\", shebang\n  end\n\n  def test_shebang_custom_with_expands_and_arguments\n    bin_env = win_platform? ? '' : '/usr/bin/env'\n    conf = Gem::ConfigFile.new []\n    conf[:custom_shebang] = '1 $env 2 $ruby 3 $exec'\n\n    Gem.configuration = conf\n\n    util_make_exec @spec, \"#!/usr/bin/ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!1 #{bin_env} 2 #{Gem.ruby} -ws 3 executable\", shebang\n  end\n\n  def test_unpack\n    util_setup_gem\n\n    dest = File.join @gemhome, 'gems', @spec.full_name\n\n    @installer.unpack dest\n\n    assert_path_exists File.join dest, 'lib', 'code.rb'\n    assert_path_exists File.join dest, 'bin', 'executable'\n  end\n\n  def test_write_build_info_file\n    refute_path_exists @spec.build_info_file\n\n    @installer.build_args = %w[\n      --with-libyaml-dir /usr/local/Cellar/libyaml/0.1.4\n    ]\n\n    @installer.write_build_info_file\n\n    assert_path_exists @spec.build_info_file\n\n    expected = \"--with-libyaml-dir\\n/usr/local/Cellar/libyaml/0.1.4\\n\"\n\n    assert_equal expected, File.read(@spec.build_info_file)\n  end\n\n  def test_write_build_info_file_empty\n    refute_path_exists @spec.build_info_file\n\n    @installer.write_build_info_file\n\n    refute_path_exists @spec.build_info_file\n  end\n\n  def test_write_build_info_file_install_dir\n    installer = Gem::Installer.at @gem, :install_dir => \"#{@gemhome}2\"\n\n    installer.build_args = %w[\n      --with-libyaml-dir /usr/local/Cellar/libyaml/0.1.4\n    ]\n\n    installer.write_build_info_file\n\n    refute_path_exists @spec.build_info_file\n    assert_path_exists \\\n      File.join(\"#{@gemhome}2\", 'build_info', \"#{@spec.full_name}.info\")\n  end\n\n  def test_write_cache_file\n    cache_file = File.join @gemhome, 'cache', @spec.file_name\n    gem = File.join @gemhome, @spec.file_name\n\n    FileUtils.mv cache_file, gem\n    refute_path_exists cache_file\n\n    installer = Gem::Installer.at gem\n    installer.gem_home = @gemhome\n\n    installer.write_cache_file\n\n    assert_path_exists cache_file\n  end\n\n  def test_write_spec\n    FileUtils.rm @spec.spec_file\n    refute_path_exists @spec.spec_file\n\n    @installer = Gem::Installer.for_spec @spec\n    @installer.gem_home = @gemhome\n\n    @installer.write_spec\n\n    assert_path_exists @spec.spec_file\n\n    loaded = Gem::Specification.load @spec.spec_file\n\n    assert_equal @spec, loaded\n\n    assert_equal Gem.rubygems_version, @spec.installed_by_version\n  end\n\n  def test_write_spec_writes_cached_spec\n    FileUtils.rm @spec.spec_file\n    refute_path_exists @spec.spec_file\n\n    @spec.files = %w[a.rb b.rb c.rb]\n\n    @installer = Gem::Installer.for_spec @spec\n    @installer.gem_home = @gemhome\n\n    @installer.write_spec\n\n    # cached specs have no file manifest:\n    @spec.files = []\n\n    assert_equal @spec, eval(File.read(@spec.spec_file))\n  end\n\n  def test_dir\n    assert_match %r!/gemhome/gems/a-2$!, @installer.dir\n  end\n\n  def test_default_gem_loaded_from\n    spec = util_spec 'a'\n    installer = Gem::Installer.for_spec spec, :install_as_default => true\n    installer.install\n    assert_predicate spec, :default_gem?\n  end\n\n  def test_default_gem\n    FileUtils.rm_f File.join(Gem.dir, 'specifications')\n\n    @installer.wrappers = true\n    @installer.options[:install_as_default] = true\n    @installer.gem_dir = util_gem_dir @spec\n    @installer.generate_bin\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    assert File.directory? util_inst_bindir\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    assert File.directory? File.join(Gem.default_dir, 'specifications')\n    assert File.directory? File.join(Gem.default_dir, 'specifications', 'default')\n\n    default_spec = eval File.read File.join(Gem.default_dir, 'specifications', 'default', 'a-2.gemspec')\n    assert_equal Gem::Version.new(\"2\"), default_spec.version\n    assert_equal ['bin/executable'], default_spec.files\n  end\n\n  def old_ruby_required\n    spec = util_spec 'old_ruby_required', '1' do |s|\n      s.required_ruby_version = '= 1.4.6'\n    end\n\n    util_build_gem spec\n\n    spec.cache_file\n  end\n\n  def util_execless\n    @spec = util_spec 'z'\n    util_build_gem @spec\n\n    @installer = util_installer @spec, @gemhome\n  end\n\n  def util_conflict_executable wrappers\n    conflict = quick_gem 'conflict' do |spec|\n      util_make_exec spec\n    end\n\n    util_build_gem conflict\n\n    installer = util_installer conflict, @gemhome\n    installer.wrappers = wrappers\n    installer.generate_bin\n  end\n\n  def mask\n    0100755 & (~File.umask)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems/command'\nrequire 'rubygems/exceptions'\nrequire 'rubygems/package'\nrequire 'rubygems/ext'\nrequire 'rubygems/user_interaction'\nrequire 'fileutils'\n\n##\n# The installer installs the files contained in the .gem into the Gem.home.\n#\n# Gem::Installer does the work of putting files in all the right places on the\n# filesystem including unpacking the gem into its gem dir, installing the\n# gemspec in the specifications dir, storing the cached gem in the cache dir,\n# and installing either wrappers or symlinks for executables.\n#\n# The installer invokes pre and post install hooks.  Hooks can be added either\n# through a rubygems_plugin.rb file in an installed gem or via a\n# rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb\n# file.  See Gem.pre_install and Gem.post_install for details.\n\nclass Gem::Installer\n\n  ##\n  # Paths where env(1) might live.  Some systems are broken and have it in\n  # /bin\n\n  ENV_PATHS = %w[/usr/bin/env /bin/env]\n\n  ##\n  # Deprecated in favor of Gem::Ext::BuildError\n\n  ExtensionBuildError = Gem::Ext::BuildError # :nodoc:\n\n  include Gem::UserInteraction\n\n  ##\n  # Filename of the gem being installed.\n\n  attr_reader :gem\n\n  ##\n  # The directory a gem's executables will be installed into\n\n  attr_reader :bin_dir\n\n  attr_reader :build_root # :nodoc:\n\n  ##\n  # The gem repository the gem will be installed into\n\n  attr_reader :gem_home\n\n  ##\n  # The options passed when the Gem::Installer was instantiated.\n\n  attr_reader :options\n\n  @path_warning = false\n\n  @install_lock = Mutex.new\n\n  class << self\n\n    ##\n    # True if we've warned about PATH not including Gem.bindir\n\n    attr_accessor :path_warning\n\n    ##\n    # Certain aspects of the install process are not thread-safe. This lock is\n    # used to allow multiple threads to install Gems at the same time.\n\n    attr_reader :install_lock\n\n    ##\n    # Overrides the executable format.\n    #\n    # This is a sprintf format with a \"%s\" which will be replaced with the\n    # executable name.  It is based off the ruby executable name's difference\n    # from \"ruby\".\n\n    attr_writer :exec_format\n\n    # Defaults to use Ruby's program prefix and suffix.\n    def exec_format\n      @exec_format ||= Gem.default_exec_format\n    end\n\n  end\n\n  ##\n  # Construct an installer object for the gem file located at +path+\n\n  def self.at path, options = {}\n    security_policy = options[:security_policy]\n    package = Gem::Package.new path, security_policy\n    new package, options\n  end\n\n  class FakePackage\n    attr_accessor :spec\n\n    def initialize(spec)\n      @spec = spec\n    end\n\n    def extract_files destination_dir, pattern = '*'\n      FileUtils.mkdir_p destination_dir\n\n      spec.files.each do |file|\n        file = File.join destination_dir, file\n        next if File.exist? file\n        FileUtils.mkdir_p File.dirname(file)\n        File.open file, 'w' do |fp| fp.puts \"# #{file}\" end\n      end\n    end\n\n    def copy_to path\n    end\n  end\n\n  ##\n  # Construct an installer object for an ephemeral gem (one where we don't\n  # actually have a .gem file, just a spec)\n\n  def self.for_spec spec, options = {}\n    # FIXME: we should have a real Package class for this\n    new FakePackage.new(spec), options\n  end\n\n  ##\n  # Constructs an Installer instance that will install the gem located at\n  # +gem+.  +options+ is a Hash with the following keys:\n  #\n  # :bin_dir:: Where to put a bin wrapper if needed.\n  # :development:: Whether or not development dependencies should be installed.\n  # :env_shebang:: Use /usr/bin/env in bin wrappers.\n  # :force:: Overrides all version checks and security policy checks, except\n  #          for a signed-gems-only policy.\n  # :format_executable:: Format the executable the same as the Ruby executable.\n  #                      If your Ruby is ruby18, foo_exec will be installed as\n  #                      foo_exec18.\n  # :ignore_dependencies:: Don't raise if a dependency is missing.\n  # :install_dir:: The directory to install the gem into.\n  # :security_policy:: Use the specified security policy.  See Gem::Security\n  # :user_install:: Indicate that the gem should be unpacked into the users\n  #                 personal gem directory.\n  # :only_install_dir:: Only validate dependencies against what is in the\n  #                     install_dir\n  # :wrappers:: Install wrappers if true, symlinks if false.\n  # :build_args:: An Array of arguments to pass to the extension builder\n  #               process. If not set, then Gem::Command.build_args is used\n\n  def initialize(package, options={})\n    require 'fileutils'\n\n    @options = options\n    if package.is_a? String\n      security_policy = options[:security_policy]\n      @package = Gem::Package.new package, security_policy\n      if $VERBOSE\n        warn \"constructing an Installer object with a string is deprecated. Please use Gem::Installer.at (called from: #{caller.first})\"\n      end\n    else\n      @package = package\n    end\n\n    process_options\n\n    if options[:user_install] and not options[:unpack] then\n      @gem_home = Gem.user_dir\n      @bin_dir = Gem.bindir gem_home unless options[:bin_dir]\n      check_that_user_bin_dir_is_in_path\n    end\n  end\n\n  ##\n  # Checks if +filename+ exists in +@bin_dir+.\n  #\n  # If +@force+ is set +filename+ is overwritten.\n  #\n  # If +filename+ exists and is a RubyGems wrapper for different gem the user\n  # is consulted.\n  #\n  # If +filename+ exists and +@bin_dir+ is Gem.default_bindir (/usr/local) the\n  # user is consulted.\n  #\n  # Otherwise +filename+ is overwritten.\n\n  def check_executable_overwrite filename # :nodoc:\n    return if @force\n\n    generated_bin = File.join @bin_dir, formatted_program_filename(filename)\n\n    return unless File.exist? generated_bin\n\n    ruby_executable = false\n    existing = nil\n\n    open generated_bin, 'rb' do |io|\n      next unless io.gets =~ /^#!/ # shebang\n      io.gets # blankline\n\n      # TODO detect a specially formatted comment instead of trying\n      # to run a regexp against Ruby code.\n      next unless io.gets =~ /This file was generated by RubyGems/\n\n      ruby_executable = true\n      existing = io.read.slice(%r{\n          ^\\s*(\n            gem \\s |\n            load \\s Gem\\.bin_path\\( |\n            load \\s Gem\\.activate_bin_path\\(\n          )\n          (['\"])(.*?)(\\2),\n        }x, 3)\n    end\n\n    return if spec.name == existing\n\n    # somebody has written to RubyGems' directory, overwrite, too bad\n    return if Gem.default_bindir != @bin_dir and not ruby_executable\n\n    question = \"#{spec.name}'s executable \\\"#{filename}\\\" conflicts with \".dup\n\n    if ruby_executable then\n      question << (existing || 'an unknown executable')\n\n      return if ask_yes_no \"#{question}\\nOverwrite the executable?\", false\n\n      conflict = \"installed executable from #{existing}\"\n    else\n      question << generated_bin\n\n      return if ask_yes_no \"#{question}\\nOverwrite the executable?\", false\n\n      conflict = generated_bin\n    end\n\n    raise Gem::InstallError,\n      \"\\\"#{filename}\\\" from #{spec.name} conflicts with #{conflict}\"\n  end\n\n  ##\n  # Lazy accessor for the spec's gem directory.\n\n  def gem_dir\n    @gem_dir ||= File.join(gem_home, \"gems\", spec.full_name)\n  end\n\n  ##\n  # Lazy accessor for the installer's spec.\n\n  def spec\n    @package.spec\n  rescue Gem::Package::Error => e\n    raise Gem::InstallError, \"invalid gem: #{e.message}\"\n  end\n\n  ##\n  # Installs the gem and returns a loaded Gem::Specification for the installed\n  # gem.\n  #\n  # The gem will be installed with the following structure:\n  #\n  #   @gem_home/\n  #     cache/<gem-version>.gem #=> a cached copy of the installed gem\n  #     gems/<gem-version>/... #=> extracted files\n  #     specifications/<gem-version>.gemspec #=> the Gem::Specification\n\n  def install\n    pre_install_checks\n\n    FileUtils.rm_f File.join gem_home, 'specifications', spec.spec_name\n\n    run_pre_install_hooks\n\n    # Set loaded_from to ensure extension_dir is correct\n    if @options[:install_as_default] then\n      spec.loaded_from = default_spec_file\n    else\n      spec.loaded_from = spec_file\n    end\n\n    # Completely remove any previous gem files\n    FileUtils.rm_rf gem_dir\n    FileUtils.rm_rf spec.extension_dir\n\n    FileUtils.mkdir_p gem_dir\n\n    if @options[:install_as_default] then\n      extract_bin\n      write_default_spec\n    else\n      extract_files\n\n      build_extensions\n      write_build_info_file\n      run_post_build_hooks\n\n      generate_bin\n      write_spec\n      write_cache_file\n    end\n\n    say spec.post_install_message if options[:post_install_message] && !spec.post_install_message.nil?\n\n    Gem::Installer.install_lock.synchronize { Gem::Specification.reset }\n\n    run_post_install_hooks\n\n    spec\n\n  # TODO This rescue is in the wrong place. What is raising this exception?\n  # move this rescue to around the code that actually might raise it.\n  rescue Zlib::GzipFile::Error\n    raise Gem::InstallError, \"gzip error installing #{gem}\"\n  end\n\n  def run_pre_install_hooks # :nodoc:\n    Gem.pre_install_hooks.each do |hook|\n      if hook.call(self) == false then\n        location = \" at #{$1}\" if hook.inspect =~ /@(.*:\\d+)/\n\n        message = \"pre-install hook#{location} failed for #{spec.full_name}\"\n        raise Gem::InstallError, message\n      end\n    end\n  end\n\n  def run_post_build_hooks # :nodoc:\n    Gem.post_build_hooks.each do |hook|\n      if hook.call(self) == false then\n        FileUtils.rm_rf gem_dir\n\n        location = \" at #{$1}\" if hook.inspect =~ /@(.*:\\d+)/\n\n        message = \"post-build hook#{location} failed for #{spec.full_name}\"\n        raise Gem::InstallError, message\n      end\n    end\n  end\n\n  def run_post_install_hooks # :nodoc:\n    Gem.post_install_hooks.each do |hook|\n      hook.call self\n    end\n  end\n\n  ##\n  #\n  # Return an Array of Specifications contained within the gem_home\n  # we'll be installing into.\n\n  def installed_specs\n    @specs ||= begin\n      specs = []\n\n      Dir[File.join(gem_home, \"specifications\", \"*.gemspec\")].each do |path|\n        spec = Gem::Specification.load path.untaint\n        specs << spec if spec\n      end\n\n      specs\n    end\n  end\n\n  ##\n  # Ensure that the dependency is satisfied by the current installation of\n  # gem.  If it is not an exception is raised.\n  #\n  # spec       :: Gem::Specification\n  # dependency :: Gem::Dependency\n\n  def ensure_dependency(spec, dependency)\n    unless installation_satisfies_dependency? dependency then\n      raise Gem::InstallError, \"#{spec.name} requires #{dependency}\"\n    end\n    true\n  end\n\n  ##\n  # True if the gems in the system satisfy +dependency+.\n\n  def installation_satisfies_dependency?(dependency)\n    return true if @options[:development] and dependency.type == :development\n    return true if installed_specs.detect { |s| dependency.matches_spec? s }\n    return false if @only_install_dir\n    not dependency.matching_specs.empty?\n  end\n\n  ##\n  # Unpacks the gem into the given directory.\n\n  def unpack(directory)\n    @gem_dir = directory\n    extract_files\n  end\n\n  ##\n  # The location of the spec file that is installed.\n  #\n\n  def spec_file\n    File.join gem_home, \"specifications\", \"#{spec.full_name}.gemspec\"\n  end\n\n  ##\n  # The location of the default spec file for default gems.\n  #\n\n  def default_spec_file\n    File.join Gem::Specification.default_specifications_dir, \"#{spec.full_name}.gemspec\"\n  end\n\n  ##\n  # Writes the .gemspec specification (in Ruby) to the gem home's\n  # specifications directory.\n\n  def write_spec\n    open spec_file, 'w' do |file|\n      spec.installed_by_version = Gem.rubygems_version\n\n      file.puts spec.to_ruby_for_cache\n\n      file.fsync rescue nil # for filesystems without fsync(2)\n    end\n  end\n\n  ##\n  # Writes the full .gemspec specification (in Ruby) to the gem home's\n  # specifications/default directory.\n\n  def write_default_spec\n    File.open(default_spec_file, \"w\") do |file|\n      file.puts spec.to_ruby\n    end\n  end\n\n  ##\n  # Creates windows .bat files for easy running of commands\n\n  def generate_windows_script(filename, bindir)\n    if Gem.win_platform? then\n      script_name = filename + \".bat\"\n      script_path = File.join bindir, File.basename(script_name)\n      File.open script_path, 'w' do |file|\n        file.puts windows_stub_script(bindir, filename)\n      end\n\n      verbose script_path\n    end\n  end\n\n  def generate_bin # :nodoc:\n    return if spec.executables.nil? or spec.executables.empty?\n\n    Dir.mkdir @bin_dir unless File.exist? @bin_dir\n    raise Gem::FilePermissionError.new(@bin_dir) unless File.writable? @bin_dir\n\n    spec.executables.each do |filename|\n      filename.untaint\n      bin_path = File.join gem_dir, spec.bindir, filename\n\n      unless File.exist? bin_path then\n        # TODO change this to a more useful warning\n        warn \"#{bin_path} maybe `gem pristine #{spec.name}` will fix it?\"\n        next\n      end\n\n      mode = File.stat(bin_path).mode\n      FileUtils.chmod mode | 0111, bin_path unless (mode | 0111) == mode\n\n      check_executable_overwrite filename\n\n      if @wrappers then\n        generate_bin_script filename, @bin_dir\n      else\n        generate_bin_symlink filename, @bin_dir\n      end\n\n    end\n  end\n\n  ##\n  # Creates the scripts to run the applications in the gem.\n  #--\n  # The Windows script is generated in addition to the regular one due to a\n  # bug or misfeature in the Windows shell's pipe.  See\n  # http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/193379\n\n  def generate_bin_script(filename, bindir)\n    bin_script_path = File.join bindir, formatted_program_filename(filename)\n\n    FileUtils.rm_f bin_script_path # prior install may have been --no-wrappers\n\n    File.open bin_script_path, 'wb', 0755 do |file|\n      file.print app_script_text(filename)\n    end\n\n    verbose bin_script_path\n\n    generate_windows_script filename, bindir\n  end\n\n  ##\n  # Creates the symlinks to run the applications in the gem.  Moves\n  # the symlink if the gem being installed has a newer version.\n\n  def generate_bin_symlink(filename, bindir)\n    src = File.join gem_dir, spec.bindir, filename\n    dst = File.join bindir, formatted_program_filename(filename)\n\n    if File.exist? dst then\n      if File.symlink? dst then\n        link = File.readlink(dst).split File::SEPARATOR\n        cur_version = Gem::Version.create(link[-3].sub(/^.*-/, ''))\n        return if spec.version < cur_version\n      end\n      File.unlink dst\n    end\n\n    FileUtils.symlink src, dst, :verbose => Gem.configuration.really_verbose\n  rescue NotImplementedError, SystemCallError\n    alert_warning \"Unable to use symlinks, installing wrapper\"\n    generate_bin_script filename, bindir\n  end\n\n  ##\n  # Generates a #! line for +bin_file_name+'s wrapper copying arguments if\n  # necessary.\n  #\n  # If the :custom_shebang config is set, then it is used as a template\n  # for how to create the shebang used for to run a gem's executables.\n  #\n  # The template supports 4 expansions:\n  #\n  #  $env    the path to the unix env utility\n  #  $ruby   the path to the currently running ruby interpreter\n  #  $exec   the path to the gem's executable\n  #  $name   the name of the gem the executable is for\n  #\n\n  def shebang(bin_file_name)\n    ruby_name = RbConfig::CONFIG['ruby_install_name'] if @env_shebang\n    path = File.join gem_dir, spec.bindir, bin_file_name\n    first_line = File.open(path, \"rb\") {|file| file.gets}\n\n    if /\\A#!/ =~ first_line then\n      # Preserve extra words on shebang line, like \"-w\".  Thanks RPA.\n      shebang = first_line.sub(/\\A\\#!.*?ruby\\S*((\\s+\\S+)+)/, \"#!#{Gem.ruby}\")\n      opts = $1\n      shebang.strip! # Avoid nasty ^M issues.\n    end\n\n    if which = Gem.configuration[:custom_shebang]\n      # replace bin_file_name with \"ruby\" to avoid endless loops\n      which = which.gsub(/ #{bin_file_name}$/,\" #{RbConfig::CONFIG['ruby_install_name']}\")\n\n      which = which.gsub(/\\$(\\w+)/) do\n        case $1\n        when \"env\"\n          @env_path ||= ENV_PATHS.find {|env_path| File.executable? env_path }\n        when \"ruby\"\n          \"#{Gem.ruby}#{opts}\"\n        when \"exec\"\n          bin_file_name\n        when \"name\"\n          spec.name\n        end\n      end\n\n      \"#!#{which}\"\n    elsif not ruby_name then\n      \"#!#{Gem.ruby}#{opts}\"\n    elsif opts then\n      \"#!/bin/sh\\n'exec' #{ruby_name.dump} '-x' \\\"$0\\\" \\\"$@\\\"\\n#{shebang}\"\n    else\n      # Create a plain shebang line.\n      @env_path ||= ENV_PATHS.find {|env_path| File.executable? env_path }\n      \"#!#{@env_path} #{ruby_name}\"\n    end\n  end\n\n  ##\n  # Ensures the Gem::Specification written out for this gem is loadable upon\n  # installation.\n\n  def ensure_loadable_spec\n    ruby = spec.to_ruby_for_cache\n    ruby.untaint\n\n    begin\n      eval ruby\n    rescue StandardError, SyntaxError => e\n      raise Gem::InstallError,\n            \"The specification for #{spec.full_name} is corrupt (#{e.class})\"\n    end\n  end\n\n  def ensure_required_ruby_version_met # :nodoc:\n    if rrv = spec.required_ruby_version then\n      unless rrv.satisfied_by? Gem.ruby_version then\n        raise Gem::InstallError, \"#{spec.name} requires Ruby version #{rrv}.\"\n      end\n    end\n  end\n\n  def ensure_required_rubygems_version_met # :nodoc:\n    if rrgv = spec.required_rubygems_version then\n      unless rrgv.satisfied_by? Gem.rubygems_version then\n        raise Gem::InstallError,\n          \"#{spec.name} requires RubyGems version #{rrgv}. \" +\n          \"Try 'gem update --system' to update RubyGems itself.\"\n      end\n    end\n  end\n\n  def ensure_dependencies_met # :nodoc:\n    deps = spec.runtime_dependencies\n    deps |= spec.development_dependencies if @development\n\n    deps.each do |dep_gem|\n      ensure_dependency spec, dep_gem\n    end\n  end\n\n  def process_options # :nodoc:\n    @options = {\n      :bin_dir      => nil,\n      :env_shebang  => false,\n      :force        => false,\n      :only_install_dir => false,\n      :post_install_message => true\n    }.merge options\n\n    @env_shebang         = options[:env_shebang]\n    @force               = options[:force]\n    @install_dir         = options[:install_dir]\n    @gem_home            = options[:install_dir] || Gem.dir\n    @ignore_dependencies = options[:ignore_dependencies]\n    @format_executable   = options[:format_executable]\n    @wrappers            = options[:wrappers]\n    @only_install_dir    = options[:only_install_dir]\n\n    # If the user has asked for the gem to be installed in a directory that is\n    # the system gem directory, then use the system bin directory, else create\n    # (or use) a new bin dir under the gem_home.\n    @bin_dir             = options[:bin_dir] || Gem.bindir(gem_home)\n    @development         = options[:development]\n    @build_root          = options[:build_root]\n\n    @build_args          = options[:build_args] || Gem::Command.build_args\n\n    unless @build_root.nil?\n      require 'pathname'\n      @build_root = Pathname.new(@build_root).expand_path\n      @bin_dir = File.join(@build_root, options[:bin_dir] || Gem.bindir(@gem_home))\n      @gem_home = File.join(@build_root, @gem_home)\n      alert_warning \"You build with buildroot.\\n  Build root: #{@build_root}\\n  Bin dir: #{@bin_dir}\\n  Gem home: #{@gem_home}\"\n    end\n  end\n\n  def check_that_user_bin_dir_is_in_path # :nodoc:\n    user_bin_dir = @bin_dir || Gem.bindir(gem_home)\n    user_bin_dir = user_bin_dir.gsub(File::SEPARATOR, File::ALT_SEPARATOR) if\n      File::ALT_SEPARATOR\n\n    path = ENV['PATH']\n    if Gem.win_platform? then\n      path = path.downcase\n      user_bin_dir = user_bin_dir.downcase\n    end\n\n    path = path.split(File::PATH_SEPARATOR)\n\n    unless path.include? user_bin_dir then\n      unless !Gem.win_platform? && (path.include? user_bin_dir.sub(ENV['HOME'], '~'))\n        unless self.class.path_warning then\n          alert_warning \"You don't have #{user_bin_dir} in your PATH,\\n\\t  gem executables will not run.\"\n          self.class.path_warning = true\n        end\n      end\n    end\n  end\n\n  def verify_gem_home(unpack = false) # :nodoc:\n    FileUtils.mkdir_p gem_home\n    raise Gem::FilePermissionError, gem_home unless\n      unpack or File.writable?(gem_home)\n  end\n\n  def verify_spec_name\n    return if spec.name =~ Gem::Specification::VALID_NAME_PATTERN\n    raise Gem::InstallError, \"#{spec} has an invalid name\"\n  end\n\n  ##\n  # Return the text for an application file.\n\n  def app_script_text(bin_file_name)\n    # note that the `load` lines cannot be indented, as old RG versions match\n    # against the beginning of the line\n    return <<-TEXT\n#{shebang bin_file_name}\n#\n# This file was generated by RubyGems.\n#\n# The application '#{spec.name}' is installed as part of a gem, and\n# this file is here to facilitate running it.\n#\n\nrequire 'rubygems'\n\nversion = \"#{Gem::Requirement.default}.a\"\n\nif ARGV.first\n  str = ARGV.first\n  str = str.dup.force_encoding(\"BINARY\") if str.respond_to? :force_encoding\n  if str =~ /\\\\A_(.*)_\\\\z/ and Gem::Version.correct?($1) then\n    version = $1\n    ARGV.shift\n  end\nend\n\nif Gem.respond_to?(:activate_bin_path)\nload Gem.activate_bin_path('#{spec.name}', '#{bin_file_name}', version)\nelse\ngem #{spec.name.dump}, version\nload Gem.bin_path(#{spec.name.dump}, #{bin_file_name.dump}, version)\nend\nTEXT\n  end\n\n  ##\n  # return the stub script text used to launch the true Ruby script\n\n  def windows_stub_script(bindir, bin_file_name)\n    ruby = Gem.ruby.gsub(/^\\\"|\\\"$/, \"\").tr(File::SEPARATOR, \"\\\\\")\n    return <<-TEXT\n@ECHO OFF\nIF NOT \"%~f0\" == \"~f0\" GOTO :WinNT\n@\"#{ruby}\" \"#{File.join(bindir, bin_file_name)}\" %1 %2 %3 %4 %5 %6 %7 %8 %9\nGOTO :EOF\n:WinNT\n@\"#{ruby}\" \"%~dpn0\" %*\nTEXT\n  end\n\n  ##\n  # Builds extensions.  Valid types of extensions are extconf.rb files,\n  # configure scripts and rakefiles or mkrf_conf files.\n\n  def build_extensions\n    builder = Gem::Ext::Builder.new spec, @build_args\n\n    builder.build_extensions\n  end\n\n  ##\n  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.\n  #\n  # TODO:  Delete this for RubyGems 3.  It remains for API compatibility\n\n  def extension_build_error(build_dir, output, backtrace = nil) # :nodoc:\n    builder = Gem::Ext::Builder.new spec, @build_args\n\n    builder.build_error build_dir, output, backtrace\n  end\n\n  ##\n  # Reads the file index and extracts each file into the gem directory.\n  #\n  # Ensures that files can't be installed outside the gem directory.\n\n  def extract_files\n    @package.extract_files gem_dir\n  end\n\n  ##\n  # Extracts only the bin/ files from the gem into the gem directory.\n  # This is used by default gems to allow a gem-aware stub to function\n  # without the full gem installed.\n\n  def extract_bin\n    @package.extract_files gem_dir, \"bin/*\"\n  end\n\n  ##\n  # Prefix and suffix the program filename the same as ruby.\n\n  def formatted_program_filename(filename)\n    if @format_executable then\n      self.class.exec_format % File.basename(filename)\n    else\n      filename\n    end\n  end\n\n  ##\n  #\n  # Return the target directory where the gem is to be installed. This\n  # directory is not guaranteed to be populated.\n  #\n\n  def dir\n    gem_dir.to_s\n  end\n\n  ##\n  # Performs various checks before installing the gem such as the install\n  # repository is writable and its directories exist, required Ruby and\n  # rubygems versions are met and that dependencies are installed.\n  #\n  # Version and dependency checks are skipped if this install is forced.\n  #\n  # The dependent check will be skipped this install is ignoring dependencies.\n\n  def pre_install_checks\n    verify_gem_home options[:unpack]\n\n    ensure_loadable_spec\n\n    verify_spec_name\n\n    if options[:install_as_default]\n      Gem.ensure_default_gem_subdirectories gem_home\n    else\n      Gem.ensure_gem_subdirectories gem_home\n    end\n\n    return true if @force\n\n    ensure_required_ruby_version_met\n    ensure_required_rubygems_version_met\n    ensure_dependencies_met unless @ignore_dependencies\n\n    true\n  end\n\n  ##\n  # Writes the file containing the arguments for building this gem's\n  # extensions.\n\n  def write_build_info_file\n    return if @build_args.empty?\n\n    build_info_dir = File.join gem_home, 'build_info'\n\n    FileUtils.mkdir_p build_info_dir\n\n    build_info_file = File.join build_info_dir, \"#{spec.full_name}.info\"\n\n    open build_info_file, 'w' do |io|\n      @build_args.each do |arg|\n        io.puts arg\n      end\n    end\n  end\n\n  ##\n  # Writes the .gem file to the cache directory\n\n  def write_cache_file\n    cache_file = File.join gem_home, 'cache', spec.file_name\n    @package.copy_to cache_file\n  end\n\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/installer_test_case'\n\nclass TestGemInstaller < Gem::InstallerTestCase\n  @@symlink_supported = nil\n\n  def symlink_supported?\n    if @@symlink_supported.nil?\n      begin\n        File.symlink(\"\", \"\")\n      rescue Errno::ENOENT, Errno::EEXIST\n        @@symlink_supported = true\n      rescue NotImplementedError, SystemCallError\n        @@symlink_supported = false\n      end\n    end\n    @@symlink_supported\n  end\n\n  def setup\n    super\n    common_installer_setup\n\n    if __name__ =~ /^test_install(_|$)/ then\n      FileUtils.rm_r @spec.gem_dir\n      FileUtils.rm_r @user_spec.gem_dir\n    end\n\n    @config = Gem.configuration\n  end\n\n  def teardown\n    common_installer_teardown\n\n    super\n\n    Gem.configuration = @config\n  end\n\n  def test_app_script_text\n    util_make_exec @spec, ''\n\n    expected = <<-EOF\n#!#{Gem.ruby}\n#\n# This file was generated by RubyGems.\n#\n# The application 'a' is installed as part of a gem, and\n# this file is here to facilitate running it.\n#\n\nrequire 'rubygems'\n\nversion = \\\">= 0.a\\\"\n\nif ARGV.first\n  str = ARGV.first\n  str = str.dup.force_encoding(\"BINARY\") if str.respond_to? :force_encoding\n  if str =~ /\\\\A_(.*)_\\\\z/ and Gem::Version.correct?($1) then\n    version = $1\n    ARGV.shift\n  end\nend\n\nif Gem.respond_to?(:activate_bin_path)\nload Gem.activate_bin_path('a', 'executable', version)\nelse\ngem \"a\", version\nload Gem.bin_path(\"a\", \"executable\", version)\nend\n    EOF\n\n    wrapper = @installer.app_script_text 'executable'\n    assert_equal expected, wrapper\n  end\n\n  def test_check_executable_overwrite\n    @installer.generate_bin\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    util_make_exec\n    @installer.gem_dir = util_gem_dir @spec\n    @installer.wrappers = true\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_check_executable_overwrite_default_bin_dir\n    if defined?(RUBY_FRAMEWORK_VERSION)\n      orig_RUBY_FRAMEWORK_VERSION = RUBY_FRAMEWORK_VERSION\n      Object.send :remove_const, :RUBY_FRAMEWORK_VERSION\n    end\n    orig_bindir = RbConfig::CONFIG['bindir']\n    RbConfig::CONFIG['bindir'] = Gem.bindir\n\n    util_conflict_executable false\n\n    ui = Gem::MockGemUi.new \"n\\n\"\n    use_ui ui do\n      e = assert_raises Gem::InstallError do\n        @installer.generate_bin\n      end\n\n      conflicted = File.join @gemhome, 'bin', 'executable'\n      assert_match %r%\\A\"executable\" from a conflicts with (?:#{Regexp.quote(conflicted)}|installed executable from conflict)\\z%,\n                   e.message\n    end\n  ensure\n    Object.const_set :RUBY_FRAMEWORK_VERSION, orig_RUBY_FRAMEWORK_VERSION if\n      orig_RUBY_FRAMEWORK_VERSION\n    if orig_bindir then\n      RbConfig::CONFIG['bindir'] = orig_bindir\n    else\n      RbConfig::CONFIG.delete 'bindir'\n    end\n  end\n\n  def test_check_executable_overwrite_format_executable\n    @installer.generate_bin\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    open File.join(util_inst_bindir, 'executable'), 'w' do |io|\n     io.write <<-EXEC\n#!/usr/local/bin/ruby\n#\n# This file was generated by RubyGems\n\ngem 'other', version\n     EXEC\n    end\n\n    util_make_exec\n    Gem::Installer.exec_format = 'foo-%s-bar'\n    @installer.gem_dir = @spec.gem_dir\n    @installer.wrappers = true\n    @installer.format_executable = true\n\n    @installer.generate_bin # should not raise\n\n    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_check_executable_overwrite_other_gem\n    util_conflict_executable true\n\n    ui = Gem::MockGemUi.new \"n\\n\"\n\n    use_ui ui do\n      e = assert_raises Gem::InstallError do\n        @installer.generate_bin\n      end\n\n      assert_equal '\"executable\" from a conflicts with installed executable from conflict',\n                   e.message\n    end\n  end\n\n  def test_check_executable_overwrite_other_gem_force\n    util_conflict_executable true\n    @installer.wrappers = true\n    @installer.force = true\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_check_executable_overwrite_other_non_gem\n    util_conflict_executable false\n    @installer.wrappers = true\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end unless Gem.win_platform?\n\n  def test_check_that_user_bin_dir_is_in_path\n    bin_dir = @installer.bin_dir\n\n    if Gem.win_platform?\n      bin_dir = bin_dir.downcase.gsub(File::SEPARATOR, File::ALT_SEPARATOR)\n    end\n\n    orig_PATH, ENV['PATH'] =\n      ENV['PATH'], [ENV['PATH'], bin_dir].join(File::PATH_SEPARATOR)\n\n    use_ui @ui do\n      @installer.check_that_user_bin_dir_is_in_path\n    end\n\n    assert_empty @ui.error\n  ensure\n    ENV['PATH'] = orig_PATH\n  end\n\n  def test_check_that_user_bin_dir_is_in_path_tilde\n    skip \"Tilde is PATH is not supported under MS Windows\" if win_platform?\n\n    orig_PATH, ENV['PATH'] =\n      ENV['PATH'], [ENV['PATH'], '~/bin'].join(File::PATH_SEPARATOR)\n\n    @installer.bin_dir.replace File.join @userhome, 'bin'\n\n    use_ui @ui do\n      @installer.check_that_user_bin_dir_is_in_path\n    end\n\n    assert_empty @ui.error\n  ensure\n    ENV['PATH'] = orig_PATH unless win_platform?\n  end\n\n  def test_check_that_user_bin_dir_is_in_path_not_in_path\n    use_ui @ui do\n      @installer.check_that_user_bin_dir_is_in_path\n    end\n\n    expected = @installer.bin_dir\n\n    if Gem.win_platform? then\n      expected = expected.downcase.gsub(File::SEPARATOR, File::ALT_SEPARATOR)\n    end\n\n    assert_match expected, @ui.error\n  end\n\n  def test_ensure_dependency\n    util_spec 'a'\n\n    dep = Gem::Dependency.new 'a', '>= 2'\n    assert @installer.ensure_dependency(@spec, dep)\n\n    dep = Gem::Dependency.new 'b', '> 2'\n    e = assert_raises Gem::InstallError do\n      @installer.ensure_dependency @spec, dep\n    end\n\n    assert_equal 'a requires b (> 2)', e.message\n  end\n\n  def test_ensure_loadable_spec\n    a, a_gem = util_gem 'a', 2 do |s|\n      s.add_dependency 'garbage ~> 5'\n    end\n\n    installer = Gem::Installer.at a_gem\n\n    e = assert_raises Gem::InstallError do\n      installer.ensure_loadable_spec\n    end\n\n    assert_equal \"The specification for #{a.full_name} is corrupt \" +\n                 \"(SyntaxError)\", e.message\n  end\n\n  def test_ensure_loadable_spec_security_policy\n    skip 'openssl is missing' unless defined?(OpenSSL::SSL)\n\n    _, a_gem = util_gem 'a', 2 do |s|\n      s.add_dependency 'garbage ~> 5'\n    end\n\n    policy = Gem::Security::HighSecurity\n    installer = Gem::Installer.at a_gem, :security_policy => policy\n\n    assert_raises Gem::Security::Exception do\n      installer.ensure_loadable_spec\n    end\n  end\n\n  def test_extract_files\n    @installer.extract_files\n\n    assert_path_exists File.join util_gem_dir, 'bin/executable'\n  end\n\n  def test_generate_bin_bindir\n    @installer.wrappers = true\n\n    @spec.executables = %w[executable]\n    @spec.bindir = '.'\n\n    exec_file = @installer.formatted_program_filename 'executable'\n    exec_path = File.join util_gem_dir(@spec), exec_file\n    File.open exec_path, 'w' do |f|\n      f.puts '#!/usr/bin/ruby'\n    end\n\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_bindir_with_user_install_warning\n    bin_dir = Gem.win_platform? ? File.expand_path(ENV[\"WINDIR\"]).upcase :\n                                  \"/usr/bin\"\n\n    options = {\n      :bin_dir => bin_dir,\n      :install_dir => \"/non/existent\"\n    }\n\n    inst = Gem::Installer.at '', options\n\n    Gem::Installer.path_warning = false\n\n    use_ui @ui do\n      inst.check_that_user_bin_dir_is_in_path\n    end\n\n    assert_equal \"\", @ui.error\n  end\n\n  def test_generate_bin_script\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    assert File.directory? util_inst_bindir\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_script_format\n    @installer.format_executable = true\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    Gem::Installer.exec_format = 'foo-%s-bar'\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'\n    assert_path_exists installed_exec\n  ensure\n    Gem::Installer.exec_format = nil\n  end\n\n  def test_generate_bin_script_format_disabled\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    Gem::Installer.exec_format = 'foo-%s-bar'\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n  ensure\n    Gem::Installer.exec_format = nil\n  end\n\n  def test_generate_bin_script_install_dir\n    @installer.wrappers = true\n\n    gem_dir = File.join(\"#{@gemhome}2\", \"gems\", @spec.full_name)\n    gem_bindir = File.join gem_dir, 'bin'\n    FileUtils.mkdir_p gem_bindir\n    File.open File.join(gem_bindir, 'executable'), 'w' do |f|\n      f.puts \"#!/bin/ruby\"\n    end\n\n    @installer.gem_home = \"#{@gemhome}2\"\n    @installer.gem_dir = gem_dir\n    @installer.bin_dir = File.join \"#{@gemhome}2\", 'bin'\n\n    @installer.generate_bin\n\n    installed_exec = File.join(\"#{@gemhome}2\", \"bin\", 'executable')\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_script_no_execs\n    util_execless\n\n    @installer.wrappers = true\n    @installer.generate_bin\n\n    refute_path_exists util_inst_bindir, 'bin dir was created when not needed'\n  end\n\n  def test_generate_bin_script_no_perms\n    @installer.wrappers = true\n    util_make_exec\n\n    Dir.mkdir util_inst_bindir\n\n    if win_platform?\n      skip('test_generate_bin_script_no_perms skipped on MS Windows')\n    else\n      FileUtils.chmod 0000, util_inst_bindir\n\n      assert_raises Gem::FilePermissionError do\n        @installer.generate_bin\n      end\n    end\n  ensure\n    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG or win_platform?)\n  end\n\n  def test_generate_bin_script_no_shebang\n    @installer.wrappers = true\n    @spec.executables = %w[executable]\n\n    gem_dir = File.join @gemhome, 'gems', @spec.full_name\n    gem_bindir = File.join gem_dir, 'bin'\n    FileUtils.mkdir_p gem_bindir\n    File.open File.join(gem_bindir, 'executable'), 'w' do |f|\n      f.puts \"blah blah blah\"\n    end\n\n    @installer.generate_bin\n\n    installed_exec = File.join @gemhome, 'bin', 'executable'\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    wrapper = File.read installed_exec\n    assert_match %r|generated by RubyGems|, wrapper\n    # HACK some gems don't have #! in their executables, restore 2008/06\n    #assert_no_match %r|generated by RubyGems|, wrapper\n  end\n\n  def test_generate_bin_script_wrappers\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n    installed_exec = File.join(util_inst_bindir, 'executable')\n\n    real_exec = File.join util_gem_dir, 'bin', 'executable'\n\n    # fake --no-wrappers for previous install\n    unless Gem.win_platform? then\n      FileUtils.mkdir_p File.dirname(installed_exec)\n      FileUtils.ln_s real_exec, installed_exec\n    end\n\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    assert_path_exists installed_exec\n    assert_equal mask, File.stat(installed_exec).mode unless win_platform?\n\n    assert_match %r|generated by RubyGems|, File.read(installed_exec)\n\n    refute_match %r|generated by RubyGems|, File.read(real_exec),\n                 'real executable overwritten'\n  end\n\n  def test_generate_bin_symlink\n    return if win_platform? #Windows FS do not support symlinks\n\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_equal true, File.symlink?(installed_exec)\n    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),\n                 File.readlink(installed_exec))\n  end\n\n  def test_generate_bin_symlink_no_execs\n    util_execless\n\n    @installer.wrappers = false\n    @installer.generate_bin\n\n    refute_path_exists util_inst_bindir\n  end\n\n  def test_generate_bin_symlink_no_perms\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    Dir.mkdir util_inst_bindir\n\n    if win_platform?\n      skip('test_generate_bin_symlink_no_perms skipped on MS Windows')\n    else\n      FileUtils.chmod 0000, util_inst_bindir\n\n      assert_raises Gem::FilePermissionError do\n        @installer.generate_bin\n      end\n    end\n  ensure\n    FileUtils.chmod 0755, util_inst_bindir unless ($DEBUG or win_platform?)\n  end\n\n  def test_generate_bin_symlink_update_newer\n    return if win_platform? #Windows FS do not support symlinks\n\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),\n                 File.readlink(installed_exec))\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    util_make_exec\n    @installer.gem_dir = util_gem_dir @spec\n    @installer.generate_bin\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_equal(@spec.bin_file('executable'),\n                 File.readlink(installed_exec),\n                 \"Ensure symlink moved to latest version\")\n  end\n\n  def test_generate_bin_symlink_update_older\n    return if !symlink_supported?\n\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),\n                 File.readlink(installed_exec))\n\n    spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"1\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n\n    util_make_exec\n    one = @spec.dup\n    one.version = 1\n    @installer = Gem::Installer.for_spec spec\n    @installer.gem_dir = util_gem_dir one\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    expected = File.join util_gem_dir, 'bin', 'executable'\n    assert_equal(expected,\n                 File.readlink(installed_exec),\n                 \"Ensure symlink not moved\")\n  end\n\n  def test_generate_bin_symlink_update_remove_wrapper\n    return if !symlink_supported?\n\n    @installer.wrappers = true\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    @spec = Gem::Specification.new do |s|\n      s.files = ['lib/code.rb']\n      s.name = \"a\"\n      s.version = \"3\"\n      s.summary = \"summary\"\n      s.description = \"desc\"\n      s.require_path = 'lib'\n    end\n    util_make_exec\n\n    util_installer @spec, @gemhome\n    @installer.wrappers = false\n    @installer.gem_dir = util_gem_dir\n\n    @installer.generate_bin\n\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_equal(@spec.bin_file('executable'),\n                 File.readlink(installed_exec),\n                 \"Ensure symlink moved to latest version\")\n  end\n\n  def test_generate_bin_symlink_win32\n    old_win_platform = Gem.win_platform?\n    Gem.win_platform = true\n    old_alt_separator = File::ALT_SEPARATOR\n    File.__send__(:remove_const, :ALT_SEPARATOR)\n    File.const_set(:ALT_SEPARATOR, '\\\\')\n    @installer.wrappers = false\n    util_make_exec\n    @installer.gem_dir = util_gem_dir\n\n    use_ui @ui do\n      @installer.generate_bin\n    end\n\n    assert_equal true, File.directory?(util_inst_bindir)\n    installed_exec = File.join(util_inst_bindir, 'executable')\n    assert_path_exists installed_exec\n\n    if symlink_supported?\n      assert_send([File, :symlink?, installed_exec])\n      return\n    end\n\n    assert_match(/Unable to use symlinks, installing wrapper/i,\n                 @ui.error)\n\n    wrapper = File.read installed_exec\n    assert_match(/generated by RubyGems/, wrapper)\n  ensure\n    File.__send__(:remove_const, :ALT_SEPARATOR)\n    File.const_set(:ALT_SEPARATOR, old_alt_separator)\n    Gem.win_platform = old_win_platform\n  end\n\n  def test_generate_bin_uses_default_shebang\n    return if !symlink_supported?\n\n    @installer.wrappers = true\n    util_make_exec\n\n    @installer.generate_bin\n\n    default_shebang = Gem.ruby\n    shebang_line = open(\"#{@gemhome}/bin/executable\") { |f| f.readlines.first }\n    assert_match(/\\A#!/, shebang_line)\n    assert_match(/#{default_shebang}/, shebang_line)\n  end\n\n  def test_initialize\n    spec = util_spec 'a' do |s| s.platform = Gem::Platform.new 'mswin32' end\n    gem = File.join @tempdir, spec.file_name\n\n    Dir.mkdir util_inst_bindir\n    util_build_gem spec\n    FileUtils.mv spec.cache_file, @tempdir\n\n    installer = Gem::Installer.at gem\n\n    assert_equal File.join(@gemhome, 'gems', spec.full_name), installer.gem_dir\n    assert_equal File.join(@gemhome, 'bin'), installer.bin_dir\n  end\n\n  def test_initialize_user_install\n    installer = Gem::Installer.at @gem, :user_install => true\n\n    assert_equal File.join(Gem.user_dir, 'gems', @spec.full_name),\n                 installer.gem_dir\n    assert_equal Gem.bindir(Gem.user_dir), installer.bin_dir\n  end\n\n  def test_initialize_user_install_bin_dir\n    installer =\n      Gem::Installer.at @gem, :user_install => true, :bin_dir => @tempdir\n\n    assert_equal File.join(Gem.user_dir, 'gems', @spec.full_name),\n                 installer.gem_dir\n    assert_equal @tempdir, installer.bin_dir\n  end\n\n  def test_install\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    gemdir     = File.join @gemhome, 'gems', @spec.full_name\n    cache_file = File.join @gemhome, 'cache', @spec.file_name\n    stub_exe   = File.join @gemhome, 'bin', 'executable'\n    rakefile   = File.join gemdir, 'ext', 'a', 'Rakefile'\n    spec_file  = File.join @gemhome, 'specifications', @spec.spec_name\n\n    Gem.pre_install do |installer|\n      refute_path_exists cache_file, 'cache file must not exist yet'\n      refute_path_exists spec_file,  'spec file must not exist yet'\n      true\n    end\n\n    Gem.post_build do |installer|\n      assert_path_exists gemdir, 'gem install dir must exist'\n      assert_path_exists rakefile, 'gem executable must exist'\n      refute_path_exists stub_exe, 'gem executable must not exist'\n      refute_path_exists spec_file, 'spec file must not exist yet'\n      true\n    end\n\n    Gem.post_install do |installer|\n      assert_path_exists cache_file, 'cache file must exist'\n      assert_path_exists spec_file,  'spec file must exist'\n    end\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    assert_equal @spec, @newspec\n    assert_path_exists gemdir\n    assert_path_exists stub_exe, 'gem executable must exist'\n\n    exe = File.join gemdir, 'bin', 'executable'\n    assert_path_exists exe\n\n    exe_mode = File.stat(exe).mode & 0111\n    assert_equal 0111, exe_mode, \"0%o\" % exe_mode unless win_platform?\n\n    assert_path_exists File.join gemdir, 'lib', 'code.rb'\n\n    assert_path_exists rakefile\n\n    spec_file = File.join(@gemhome, 'specifications', @spec.spec_name)\n\n    assert_equal spec_file, @newspec.loaded_from\n    assert_path_exists spec_file\n\n    assert_same @installer, @post_build_hook_arg\n    assert_same @installer, @post_install_hook_arg\n    assert_same @installer, @pre_install_hook_arg\n  end\n\n  def test_install_creates_working_binstub\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    @installer.wrappers = true\n\n    gemdir = File.join @gemhome, 'gems', @spec.full_name\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    exe = File.join gemdir, 'bin', 'executable'\n\n    e = assert_raises RuntimeError do\n      instance_eval File.read(exe)\n    end\n\n    assert_match(/ran executable/, e.message)\n  end\n\n  def test_conflicting_binstubs\n    Dir.mkdir util_inst_bindir\n    util_clear_gems\n\n    # build old version that has a bin file\n    util_setup_gem do |spec|\n      File.open File.join('bin', 'executable'), 'w' do |f|\n        f.puts \"require 'code'\"\n      end\n      File.open File.join('lib', 'code.rb'), 'w' do |f|\n        f.puts 'raise \"I have an executable\"'\n      end\n    end\n\n    @installer.wrappers = true\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    old_bin_file = File.join @installer.bin_dir, 'executable'\n\n    # build new version that doesn't have a bin file\n    util_setup_gem do |spec|\n      FileUtils.rm File.join('bin', 'executable')\n      spec.files.delete File.join('bin', 'executable')\n      spec.executables.delete 'executable'\n      spec.version = @spec.version.bump\n      File.open File.join('lib', 'code.rb'), 'w' do |f|\n        f.puts 'raise \"I do not have an executable\"'\n      end\n    end\n\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    e = assert_raises RuntimeError do\n      instance_eval File.read(old_bin_file)\n    end\n\n    # We expect the bin stub to activate the version that actually contains\n    # the binstub.\n    assert_match('I have an executable', e.message)\n  end\n\n  def test_install_creates_binstub_that_understand_version\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    @installer.wrappers = true\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    exe = File.join @gemhome, 'bin', 'executable'\n\n    ARGV.unshift \"_3.0_\"\n\n    begin\n      Gem::Specification.reset\n\n      e = assert_raises Gem::GemNotFoundException do\n        instance_eval File.read(exe)\n      end\n    ensure\n      ARGV.shift if ARGV.first == \"_3.0_\"\n    end\n\n    assert_includes(e.message, \"can't find gem a (= 3.0)\")\n  end\n\n  def test_install_creates_binstub_that_dont_trust_encoding\n    skip unless \"\".respond_to?(:force_encoding)\n\n    Dir.mkdir util_inst_bindir\n    util_setup_gem\n    util_clear_gems\n\n    @installer.wrappers = true\n\n    @newspec = nil\n    build_rake_in do\n      use_ui @ui do\n        @newspec = @installer.install\n      end\n    end\n\n    exe = File.join @gemhome, 'bin', 'executable'\n\n    extra_arg = \"\\xE4pfel\".dup.force_encoding(\"UTF-8\")\n    ARGV.unshift extra_arg\n\n    begin\n      Gem::Specification.reset\n\n      e = assert_raises RuntimeError do\n        instance_eval File.read(exe)\n      end\n    ensure\n      ARGV.shift if ARGV.first == extra_arg\n    end\n\n    assert_match(/ran executable/, e.message)\n  end\n\n  def test_install_with_no_prior_files\n    Dir.mkdir util_inst_bindir\n    util_clear_gems\n\n    util_setup_gem\n    build_rake_in do\n      use_ui @ui do\n        assert_equal @spec, @installer.install\n      end\n    end\n\n    gemdir = File.join(@gemhome, 'gems', @spec.full_name)\n    assert_path_exists File.join gemdir, 'lib', 'code.rb'\n\n    util_setup_gem\n    # Morph spec to have lib/other.rb instead of code.rb and recreate\n    @spec.files = File.join('lib', 'other.rb')\n    Dir.chdir @tempdir do\n      File.open File.join('lib', 'other.rb'), 'w' do |f| f.puts '1' end\n      use_ui ui do\n        FileUtils.rm @gem\n        Gem::Package.build @spec\n      end\n    end\n    @installer = Gem::Installer.at @gem\n    build_rake_in do\n      use_ui @ui do\n        assert_equal @spec, @installer.install\n      end\n    end\n\n    assert_path_exists File.join gemdir, 'lib', 'other.rb'\n    refute_path_exists File.join gemdir, 'lib', 'code.rb',\n           \"code.rb from prior install of same gem shouldn't remain here\"\n  end\n\n  def test_install_force\n    use_ui @ui do\n      installer = Gem::Installer.at old_ruby_required, :force => true\n      installer.install\n    end\n\n    gem_dir = File.join(@gemhome, 'gems', 'old_ruby_required-1')\n    assert_path_exists gem_dir\n  end\n\n  def test_install_missing_dirs\n    FileUtils.rm_f File.join(Gem.dir, 'cache')\n    FileUtils.rm_f File.join(Gem.dir, 'docs')\n    FileUtils.rm_f File.join(Gem.dir, 'specifications')\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    File.directory? File.join(Gem.dir, 'cache')\n    File.directory? File.join(Gem.dir, 'docs')\n    File.directory? File.join(Gem.dir, 'specifications')\n\n    assert_path_exists File.join @gemhome, 'cache', @spec.file_name\n    assert_path_exists File.join @gemhome, 'specifications', @spec.spec_name\n  end\n\n  def test_install_post_build_false\n    util_clear_gems\n\n    Gem.post_build do\n      false\n    end\n\n    use_ui @ui do\n      e = assert_raises Gem::InstallError do\n        @installer.install\n      end\n\n      location = \"#{__FILE__}:#{__LINE__ - 9}\"\n\n      assert_equal \"post-build hook at #{location} failed for a-2\", e.message\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    refute_path_exists spec_file\n\n    gem_dir = File.join @gemhome, 'gems', @spec.full_name\n    refute_path_exists gem_dir\n  end\n\n  def test_install_post_build_nil\n    util_clear_gems\n\n    Gem.post_build do\n      nil\n    end\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    assert_path_exists spec_file\n\n    gem_dir = File.join @gemhome, 'gems', @spec.full_name\n    assert_path_exists gem_dir\n  end\n\n  def test_install_pre_install_false\n    util_clear_gems\n\n    Gem.pre_install do\n      false\n    end\n\n    use_ui @ui do\n      e = assert_raises Gem::InstallError do\n        @installer.install\n      end\n\n      location = \"#{__FILE__}:#{__LINE__ - 9}\"\n\n      assert_equal \"pre-install hook at #{location} failed for a-2\", e.message\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    refute_path_exists spec_file\n  end\n\n  def test_install_pre_install_nil\n    util_clear_gems\n\n    Gem.pre_install do\n      nil\n    end\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    spec_file = File.join @gemhome, 'specifications', @spec.spec_name\n    assert_path_exists spec_file\n  end\n\n  def test_install_with_message\n    @spec.post_install_message = 'I am a shiny gem!'\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path\n      @installer.install\n    end\n\n    assert_match %r|I am a shiny gem!|, @ui.output\n  end\n\n  def test_install_with_skipped_message\n    @spec.post_install_message = 'I am a shiny gem!'\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path, :post_install_message => false\n      @installer.install\n    end\n\n    refute_match %r|I am a shiny gem!|, @ui.output\n  end\n\n  def test_install_extension_dir\n    gemhome2 = \"#{@gemhome}2\"\n\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    @spec.files += %w[extconf.rb]\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      installer = Gem::Installer.at path, :install_dir => gemhome2\n      installer.install\n    end\n\n    expected_makefile = File.join gemhome2, 'gems', @spec.full_name, 'Makefile'\n\n    assert_path_exists expected_makefile\n  end\n\n  def test_install_extension_dir_is_removed_on_reinstall\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    @spec.files += %w[extconf.rb]\n\n    path = Gem::Package.build @spec\n\n    # Install a gem with an extension\n    use_ui @ui do\n      installer = Gem::Installer.at path\n      installer.install\n    end\n\n    # pretend that a binary file was created as part of the build\n    should_be_removed = File.join(@spec.extension_dir, \"#{@spec.name}.so\")\n    write_file should_be_removed do |io|\n      io.write \"DELETE ME ON REINSTALL\"\n    end\n    assert_path_exists should_be_removed\n\n    # reinstall the gem, this is also the same as pristine\n    use_ui @ui do\n      installer = Gem::Installer.at path\n      installer.install\n    end\n\n    refute_path_exists should_be_removed\n  end\n\n  def test_install_user_extension_dir\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    @spec.files += %w[extconf.rb]\n\n    # Create the non-user ext dir\n    expected_extension_dir = @spec.extension_dir.dup\n    FileUtils.mkdir_p expected_extension_dir\n\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      installer = Gem::Installer.at path, :user_install => true\n      installer.install\n    end\n\n    expected_makefile = File.join Gem.user_dir, 'gems', @spec.full_name, 'Makefile'\n\n    assert_path_exists expected_makefile\n    assert_path_exists expected_extension_dir\n    refute_path_exists File.join expected_extension_dir, 'gem_make.out'\n  end\n\n  # ruby core repository needs to `depend` file for extension build.\n  # but 1.9.2 and earlier mkmf.rb does not create TOUCH file like depend.\n  if RUBY_VERSION < '1.9.3'\n    def test_find_lib_file_after_install\n\n      @spec.extensions << \"extconf.rb\"\n      write_file File.join(@tempdir, \"extconf.rb\") do |io|\n        io.write <<-RUBY\n          require \"mkmf\"\n          create_makefile(\"#{@spec.name}\")\n        RUBY\n      end\n\n      write_file File.join(@tempdir, \"a.c\") do |io|\n        io.write <<-C\n          #include <ruby.h>\n          void Init_a() { }\n        C\n      end\n\n      Dir.mkdir File.join(@tempdir, \"lib\")\n      write_file File.join(@tempdir, 'lib', \"b.rb\") do |io|\n        io.write \"# b.rb\"\n      end\n\n      @spec.files += %w[extconf.rb lib/b.rb a.c]\n\n      use_ui @ui do\n        path = Gem::Package.build @spec\n\n        installer = Gem::Installer.at path\n        installer.install\n      end\n\n      expected = File.join @spec.full_require_paths.find { |path|\n        File.exist? File.join path, 'b.rb'\n      }, 'b.rb'\n      assert_equal expected, @spec.matches_for_glob('b.rb').first\n    end\n  else\n    def test_find_lib_file_after_install\n      @spec.extensions << \"extconf.rb\"\n      write_file File.join(@tempdir, \"extconf.rb\") do |io|\n        io.write <<-RUBY\n          require \"mkmf\"\n\n          CONFIG['CC'] = '$(TOUCH) $@ ||'\n          CONFIG['LDSHARED'] = '$(TOUCH) $@ ||'\n          $ruby = '#{Gem.ruby}'\n\n          create_makefile(\"#{@spec.name}\")\n        RUBY\n      end\n\n      write_file File.join(@tempdir, \"depend\")\n\n      write_file File.join(@tempdir, \"a.c\") do |io|\n        io.write <<-C\n          #include <ruby.h>\n          void Init_a() { }\n        C\n      end\n\n      Dir.mkdir File.join(@tempdir, \"lib\")\n      write_file File.join(@tempdir, 'lib', \"b.rb\") do |io|\n        io.write \"# b.rb\"\n      end\n\n      @spec.files += %w[extconf.rb lib/b.rb depend a.c]\n\n      use_ui @ui do\n        path = Gem::Package.build @spec\n\n        installer = Gem::Installer.at path\n        installer.install\n      end\n\n      expected = File.join @spec.full_require_paths.find { |path|\n        File.exist? File.join path, 'b.rb'\n      }, 'b.rb'\n      assert_equal expected, @spec.matches_for_glob('b.rb').first\n    end\n  end\n\n  def test_install_extension_and_script\n    @spec.extensions << \"extconf.rb\"\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    rb = File.join(\"lib\", \"#{@spec.name}.rb\")\n    @spec.files += [rb]\n    write_file File.join(@tempdir, rb) do |io|\n      io.write <<-RUBY\n        # #{@spec.name}.rb\n      RUBY\n    end\n\n    Dir.mkdir(File.join(\"lib\", @spec.name))\n    rb2 = File.join(\"lib\", @spec.name, \"#{@spec.name}.rb\")\n    @spec.files << rb2\n    write_file File.join(@tempdir, rb2) do |io|\n      io.write <<-RUBY\n        # #{@spec.name}/#{@spec.name}.rb\n      RUBY\n    end\n\n    refute_path_exists File.join @spec.gem_dir, rb\n    refute_path_exists File.join @spec.gem_dir, rb2\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path\n      @installer.install\n    end\n    assert_path_exists File.join @spec.gem_dir, rb\n    assert_path_exists File.join @spec.gem_dir, rb2\n  end\n\n  def test_install_extension_flat\n    skip '1.9.2 and earlier mkmf.rb does not create TOUCH' if\n      RUBY_VERSION < '1.9.3'\n\n    if RUBY_VERSION == \"1.9.3\" and RUBY_PATCHLEVEL <= 194\n      skip \"TOUCH was introduced into 1.9.3 after p194\"\n    end\n\n    @spec.require_paths = [\".\"]\n\n    @spec.extensions << \"extconf.rb\"\n\n    write_file File.join(@tempdir, \"extconf.rb\") do |io|\n      io.write <<-RUBY\n        require \"mkmf\"\n\n        CONFIG['CC'] = '$(TOUCH) $@ ||'\n        CONFIG['LDSHARED'] = '$(TOUCH) $@ ||'\n        $ruby = '#{Gem.ruby}'\n\n        create_makefile(\"#{@spec.name}\")\n      RUBY\n    end\n\n    # empty depend file for no auto dependencies\n    @spec.files += %W\"depend #{@spec.name}.c\".each {|file|\n      write_file File.join(@tempdir, file)\n    }\n\n    so = File.join(@spec.gem_dir, \"#{@spec.name}.#{RbConfig::CONFIG[\"DLEXT\"]}\")\n    refute_path_exists so\n    use_ui @ui do\n      path = Gem::Package.build @spec\n\n      @installer = Gem::Installer.at path\n      @installer.install\n    end\n    assert_path_exists so\n  rescue\n    puts '-' * 78\n    puts File.read File.join(@gemhome, 'gems', 'a-2', 'Makefile')\n    puts '-' * 78\n\n    path = File.join(@gemhome, 'gems', 'a-2', 'gem_make.out')\n\n    if File.exist?(path)\n      puts File.read(path)\n      puts '-' * 78\n    end\n\n    raise\n  end\n\n  def test_installation_satisfies_dependency_eh\n    util_spec 'a'\n\n    dep = Gem::Dependency.new 'a', '>= 2'\n    assert @installer.installation_satisfies_dependency?(dep)\n\n    dep = Gem::Dependency.new 'a', '> 2'\n    refute @installer.installation_satisfies_dependency?(dep)\n  end\n\n  def test_installation_satisfies_dependency_eh_development\n    @installer.options[:development] = true\n    @installer.options[:dev_shallow] = true\n\n    util_spec 'a'\n\n    dep = Gem::Dependency.new 'a', :development\n    assert @installer.installation_satisfies_dependency?(dep)\n  end\n\n  def test_pre_install_checks_dependencies\n    @spec.add_dependency 'b', '> 5'\n    util_setup_gem\n\n    use_ui @ui do\n      assert_raises Gem::InstallError do\n        @installer.install\n      end\n    end\n  end\n\n  def test_pre_install_checks_dependencies_ignore\n    @spec.add_dependency 'b', '> 5'\n    @installer.ignore_dependencies = true\n\n    build_rake_in do\n      use_ui @ui do\n        assert @installer.pre_install_checks\n      end\n    end\n  end\n\n  def test_pre_install_checks_dependencies_install_dir\n    gemhome2 = \"#{@gemhome}2\"\n    @spec.add_dependency 'd'\n\n    quick_gem 'd', 2\n\n    gem = File.join @gemhome, @spec.file_name\n\n    FileUtils.mv @gemhome, gemhome2\n    FileUtils.mkdir @gemhome\n\n    FileUtils.mv File.join(gemhome2, 'cache', @spec.file_name), gem\n\n    # Don't leak any already activated gems into the installer, require\n    # that it work everything out on it's own.\n    Gem::Specification.reset\n\n    installer = Gem::Installer.at gem, :install_dir => gemhome2\n\n    build_rake_in do\n      use_ui @ui do\n        assert installer.pre_install_checks\n      end\n    end\n  end\n\n  def test_pre_install_checks_ruby_version\n    use_ui @ui do\n      installer = Gem::Installer.at old_ruby_required\n      e = assert_raises Gem::InstallError do\n        installer.pre_install_checks\n      end\n      assert_equal 'old_ruby_required requires Ruby version = 1.4.6.',\n                   e.message\n    end\n  end\n\n  def test_pre_install_checks_wrong_rubygems_version\n    spec = util_spec 'old_rubygems_required', '1' do |s|\n      s.required_rubygems_version = '< 0'\n    end\n\n    util_build_gem spec\n\n    gem = File.join(@gemhome, 'cache', spec.file_name)\n\n    use_ui @ui do\n      @installer = Gem::Installer.at gem\n      e = assert_raises Gem::InstallError do\n        @installer.pre_install_checks\n      end\n      assert_equal 'old_rubygems_required requires RubyGems version < 0. ' +\n        \"Try 'gem update --system' to update RubyGems itself.\", e.message\n    end\n  end\n\n  def test_pre_install_checks_malicious_name\n    spec = util_spec '../malicious', '1'\n    def spec.full_name # so the spec is buildable\n      \"malicious-1\"\n    end\n    def spec.validate; end\n\n    util_build_gem spec\n\n    gem = File.join(@gemhome, 'cache', spec.file_name)\n\n    use_ui @ui do\n      @installer = Gem::Installer.at gem\n      e = assert_raises Gem::InstallError do\n        @installer.pre_install_checks\n      end\n      assert_equal '#<Gem::Specification name=../malicious version=1> has an invalid name', e.message\n    end\n  end\n\n  def test_shebang\n    util_make_exec @spec, \"#!/usr/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_process_options\n    assert_nil @installer.build_root\n    assert_equal File.join(@gemhome, 'bin'), @installer.bin_dir\n    assert_equal @gemhome, @installer.gem_home\n  end\n\n  def test_process_options_build_root\n    build_root = File.join @tempdir, 'build_root'\n\n    @installer = Gem::Installer.at @gem, :build_root => build_root\n\n    assert_equal Pathname(build_root), @installer.build_root\n    assert_equal File.join(build_root, @gemhome, 'bin'), @installer.bin_dir\n    assert_equal File.join(build_root, @gemhome), @installer.gem_home\n  end\n\n  def test_shebang_arguments\n    util_make_exec @spec, \"#!/usr/bin/ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_empty\n    util_make_exec @spec, ''\n\n    shebang = @installer.shebang 'executable'\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_env\n    util_make_exec @spec, \"#!/usr/bin/env ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_env_arguments\n    util_make_exec @spec, \"#!/usr/bin/env ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_env_shebang\n    util_make_exec @spec, ''\n    @installer.env_shebang = true\n\n    shebang = @installer.shebang 'executable'\n\n    env_shebang = \"/usr/bin/env\" unless Gem.win_platform?\n\n    assert_equal(\"#!#{env_shebang} #{RbConfig::CONFIG['ruby_install_name']}\",\n                 shebang)\n  end\n\n  def test_shebang_nested\n    util_make_exec @spec, \"#!/opt/local/ruby/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_nested_arguments\n    util_make_exec @spec, \"#!/opt/local/ruby/bin/ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_version\n    util_make_exec @spec, \"#!/usr/bin/ruby18\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_version_arguments\n    util_make_exec @spec, \"#!/usr/bin/ruby18 -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_version_env\n    util_make_exec @spec, \"#!/usr/bin/env ruby18\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby}\", shebang\n  end\n\n  def test_shebang_version_env_arguments\n    util_make_exec @spec, \"#!/usr/bin/env ruby18 -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!#{Gem.ruby} -ws\", shebang\n  end\n\n  def test_shebang_custom\n    conf = Gem::ConfigFile.new []\n    conf[:custom_shebang] = 'test'\n\n    Gem.configuration = conf\n\n    util_make_exec @spec, \"#!/usr/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!test\", shebang\n  end\n\n  def test_shebang_custom_with_expands\n    bin_env = win_platform? ? '' : '/usr/bin/env'\n    conf = Gem::ConfigFile.new []\n    conf[:custom_shebang] = '1 $env 2 $ruby 3 $exec 4 $name'\n\n    Gem.configuration = conf\n\n    util_make_exec @spec, \"#!/usr/bin/ruby\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!1 #{bin_env} 2 #{Gem.ruby} 3 executable 4 a\", shebang\n  end\n\n  def test_shebang_custom_with_expands_and_arguments\n    bin_env = win_platform? ? '' : '/usr/bin/env'\n    conf = Gem::ConfigFile.new []\n    conf[:custom_shebang] = '1 $env 2 $ruby 3 $exec'\n\n    Gem.configuration = conf\n\n    util_make_exec @spec, \"#!/usr/bin/ruby -ws\"\n\n    shebang = @installer.shebang 'executable'\n\n    assert_equal \"#!1 #{bin_env} 2 #{Gem.ruby} -ws 3 executable\", shebang\n  end\n\n  def test_unpack\n    util_setup_gem\n\n    dest = File.join @gemhome, 'gems', @spec.full_name\n\n    @installer.unpack dest\n\n    assert_path_exists File.join dest, 'lib', 'code.rb'\n    assert_path_exists File.join dest, 'bin', 'executable'\n  end\n\n  def test_write_build_info_file\n    refute_path_exists @spec.build_info_file\n\n    @installer.build_args = %w[\n      --with-libyaml-dir /usr/local/Cellar/libyaml/0.1.4\n    ]\n\n    @installer.write_build_info_file\n\n    assert_path_exists @spec.build_info_file\n\n    expected = \"--with-libyaml-dir\\n/usr/local/Cellar/libyaml/0.1.4\\n\"\n\n    assert_equal expected, File.read(@spec.build_info_file)\n  end\n\n  def test_write_build_info_file_empty\n    refute_path_exists @spec.build_info_file\n\n    @installer.write_build_info_file\n\n    refute_path_exists @spec.build_info_file\n  end\n\n  def test_write_build_info_file_install_dir\n    installer = Gem::Installer.at @gem, :install_dir => \"#{@gemhome}2\"\n\n    installer.build_args = %w[\n      --with-libyaml-dir /usr/local/Cellar/libyaml/0.1.4\n    ]\n\n    installer.write_build_info_file\n\n    refute_path_exists @spec.build_info_file\n    assert_path_exists \\\n      File.join(\"#{@gemhome}2\", 'build_info', \"#{@spec.full_name}.info\")\n  end\n\n  def test_write_cache_file\n    cache_file = File.join @gemhome, 'cache', @spec.file_name\n    gem = File.join @gemhome, @spec.file_name\n\n    FileUtils.mv cache_file, gem\n    refute_path_exists cache_file\n\n    installer = Gem::Installer.at gem\n    installer.gem_home = @gemhome\n\n    installer.write_cache_file\n\n    assert_path_exists cache_file\n  end\n\n  def test_write_spec\n    FileUtils.rm @spec.spec_file\n    refute_path_exists @spec.spec_file\n\n    @installer = Gem::Installer.for_spec @spec\n    @installer.gem_home = @gemhome\n\n    @installer.write_spec\n\n    assert_path_exists @spec.spec_file\n\n    loaded = Gem::Specification.load @spec.spec_file\n\n    assert_equal @spec, loaded\n\n    assert_equal Gem.rubygems_version, @spec.installed_by_version\n  end\n\n  def test_write_spec_writes_cached_spec\n    FileUtils.rm @spec.spec_file\n    refute_path_exists @spec.spec_file\n\n    @spec.files = %w[a.rb b.rb c.rb]\n\n    @installer = Gem::Installer.for_spec @spec\n    @installer.gem_home = @gemhome\n\n    @installer.write_spec\n\n    # cached specs have no file manifest:\n    @spec.files = []\n\n    assert_equal @spec, eval(File.read(@spec.spec_file))\n  end\n\n  def test_dir\n    assert_match %r!/gemhome/gems/a-2$!, @installer.dir\n  end\n\n  def test_default_gem_loaded_from\n    spec = util_spec 'a'\n    installer = Gem::Installer.for_spec spec, :install_as_default => true\n    installer.install\n    assert_predicate spec, :default_gem?\n  end\n\n  def test_default_gem\n    FileUtils.rm_f File.join(Gem.dir, 'specifications')\n\n    @installer.wrappers = true\n    @installer.options[:install_as_default] = true\n    @installer.gem_dir = util_gem_dir @spec\n    @installer.generate_bin\n\n    use_ui @ui do\n      @installer.install\n    end\n\n    assert File.directory? util_inst_bindir\n    installed_exec = File.join util_inst_bindir, 'executable'\n    assert_path_exists installed_exec\n\n    assert File.directory? File.join(Gem.default_dir, 'specifications')\n    assert File.directory? File.join(Gem.default_dir, 'specifications', 'default')\n\n    default_spec = eval File.read File.join(Gem.default_dir, 'specifications', 'default', 'a-2.gemspec')\n    assert_equal Gem::Version.new(\"2\"), default_spec.version\n    assert_equal ['bin/executable'], default_spec.files\n  end\n\n  def old_ruby_required\n    spec = util_spec 'old_ruby_required', '1' do |s|\n      s.required_ruby_version = '= 1.4.6'\n    end\n\n    util_build_gem spec\n\n    spec.cache_file\n  end\n\n  def util_execless\n    @spec = util_spec 'z'\n    util_build_gem @spec\n\n    @installer = util_installer @spec, @gemhome\n  end\n\n  def util_conflict_executable wrappers\n    conflict = quick_gem 'conflict' do |spec|\n      util_make_exec spec\n    end\n\n    util_build_gem conflict\n\n    installer = util_installer conflict, @gemhome\n    installer.wrappers = wrappers\n    installer.generate_bin\n  end\n\n  def mask\n    0100755 & (~File.umask)\n  end\nend\n"], "filenames": ["lib/rubygems/installer.rb", "test/rubygems/test_gem_installer.rb"], "buggy_code_start_loc": [699, 1450], "buggy_code_end_loc": [825, 1450], "fixing_code_start_loc": [700, 1451], "fixing_code_end_loc": [833, 1471], "type": "CWE-20", "message": "RubyGems version 2.6.12 and earlier fails to validate specification names, allowing a maliciously crafted gem to potentially overwrite any file on the filesystem.", "other": {"cve": {"id": "CVE-2017-0901", "sourceIdentifier": "support@hackerone.com", "published": "2017-08-31T20:29:00.557", "lastModified": "2019-10-09T23:21:09.963", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RubyGems version 2.6.12 and earlier fails to validate specification names, allowing a maliciously crafted gem to potentially overwrite any file on the filesystem."}, {"lang": "es", "value": "RubyGems 2.6.12 y anteriores no valida con \u00e9xito los nombres de las especificaciones, permitiendo que una gema manipulada maliciosamente sobrescriba cualquier archivo en el sistema de archivos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.12", "matchCriteriaId": "1161B0D8-43B3-4123-BD4F-87F260AB8947"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://blog.rubygems.org/2017/08/27/2.6.13-released.html", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/100580", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039249", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3485", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0378", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0583", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0585", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rubygems/rubygems/commit/ad5c0a53a86ca5b218c7976765c0365b91d22cb2", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/243156", "source": "support@hackerone.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-01", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3553-1/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3685-1/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3966", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/42611/", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/ad5c0a53a86ca5b218c7976765c0365b91d22cb2"}}