{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.\n * Copyright (c) 2014- QLogic Corporation.\n * All rights reserved\n * www.qlogic.com\n *\n * Linux driver for QLogic BR-series Fibre Channel Host Bus Adapter.\n */\n\n/*\n *  bfa_attr.c Linux driver configuration interface module.\n */\n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n\n/*\n * FC transport template entry, get SCSI target port ID.\n */\nstatic void\nbfad_im_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu32        fc_id = -1;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tfc_id = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\n\n\tfc_starget_port_id(starget) = fc_id;\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n/*\n * FC transport template entry, get SCSI target nwwn.\n */\nstatic void\nbfad_im_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu64             node_name = 0;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tnode_name = bfa_fcs_itnim_get_nwwn(&itnim->fcs_itnim);\n\n\tfc_starget_node_name(starget) = cpu_to_be64(node_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n/*\n * FC transport template entry, get SCSI target pwwn.\n */\nstatic void\nbfad_im_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu64             port_name = 0;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tport_name = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\n\n\tfc_starget_port_name(starget) = cpu_to_be64(port_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n/*\n * FC transport template entry, get SCSI host port ID.\n */\nstatic void\nbfad_im_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\n\tfc_host_port_id(shost) =\n\t\t\tbfa_hton3b(bfa_fcs_lport_get_fcid(port->fcs_port));\n}\n\n/*\n * FC transport template entry, get SCSI host port type.\n */\nstatic void\nbfad_im_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_lport_attr_s port_attr;\n\n\tbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\n\n\tswitch (port_attr.port_type) {\n\tcase BFA_PORT_TYPE_NPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_NLPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_P2P:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_PTP;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_LPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/*\n * FC transport template entry, get SCSI host port state.\n */\nstatic void\nbfad_im_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_port_attr_s attr;\n\n\tbfa_fcport_get_attr(&bfad->bfa, &attr);\n\n\tswitch (attr.port_state) {\n\tcase BFA_PORT_ST_LINKDOWN:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\tbreak;\n\tcase BFA_PORT_ST_LINKUP:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\t\tbreak;\n\tcase BFA_PORT_ST_DISABLED:\n\tcase BFA_PORT_ST_STOPPED:\n\tcase BFA_PORT_ST_IOCDOWN:\n\tcase BFA_PORT_ST_IOCDIS:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\t\tbreak;\n\tcase BFA_PORT_ST_UNINIT:\n\tcase BFA_PORT_ST_ENABLING_QWAIT:\n\tcase BFA_PORT_ST_ENABLING:\n\tcase BFA_PORT_ST_DISABLING_QWAIT:\n\tcase BFA_PORT_ST_DISABLING:\n\tdefault:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/*\n * FC transport template entry, get SCSI host active fc4s.\n */\nstatic void\nbfad_im_get_host_active_fc4s(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\n\tmemset(fc_host_active_fc4s(shost), 0,\n\t       sizeof(fc_host_active_fc4s(shost)));\n\n\tif (port->supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\tfc_host_active_fc4s(shost)[2] = 1;\n\n\tfc_host_active_fc4s(shost)[7] = 1;\n}\n\n/*\n * FC transport template entry, get SCSI host link speed.\n */\nstatic void\nbfad_im_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_port_attr_s attr;\n\n\tbfa_fcport_get_attr(&bfad->bfa, &attr);\n\tswitch (attr.speed) {\n\tcase BFA_PORT_SPEED_10GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_16GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_8GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_4GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_2GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_1GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/*\n * FC transport template entry, get SCSI host port type.\n */\nstatic void\nbfad_im_get_host_fabric_name(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\twwn_t           fabric_nwwn = 0;\n\n\tfabric_nwwn = bfa_fcs_lport_get_fabric_name(port->fcs_port);\n\n\tfc_host_fabric_name(shost) = cpu_to_be64(fabric_nwwn);\n\n}\n\n/*\n * FC transport template entry, get BFAD statistics.\n */\nstatic struct fc_host_statistics *\nbfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}\n\n/*\n * FC transport template entry, reset BFAD statistics.\n */\nstatic void\nbfad_im_reset_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunsigned long   flags;\n\tbfa_status_t    rc;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_port_clear_stats(BFA_FCPORT(&bfad->bfa), bfad_hcb_comp,\n\t\t\t\t\t&fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (rc != BFA_STATUS_OK)\n\t\treturn;\n\n\twait_for_completion(&fcomp.comp);\n\n\treturn;\n}\n\n/*\n * FC transport template entry, set rport loss timeout.\n * Update dev_loss_tmo based on the value pushed down by the stack\n * In case it is lesser than path_tov of driver, set it to path_tov + 1\n * to ensure that the driver times out before the application\n */\nstatic void\nbfad_im_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)\n{\n\tstruct bfad_itnim_data_s *itnim_data = rport->dd_data;\n\tstruct bfad_itnim_s   *itnim = itnim_data->itnim;\n\tstruct bfad_s         *bfad = itnim->im->bfad;\n\tuint16_t path_tov = bfa_fcpim_path_tov_get(&bfad->bfa);\n\n\trport->dev_loss_tmo = timeout;\n\tif (timeout < path_tov)\n\t\trport->dev_loss_tmo = path_tov + 1;\n}\n\nstatic int\nbfad_im_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tchar *vname = fc_vport->symbolic_name;\n\tstruct Scsi_Host *shost = fc_vport->shost;\n\tstruct bfad_im_port_s *im_port =\n\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_lport_cfg_s port_cfg;\n\tstruct bfad_vport_s *vp;\n\tint status = 0, rc;\n\tunsigned long flags;\n\n\tmemset(&port_cfg, 0, sizeof(port_cfg));\n\tu64_to_wwn(fc_vport->node_name, (u8 *)&port_cfg.nwwn);\n\tu64_to_wwn(fc_vport->port_name, (u8 *)&port_cfg.pwwn);\n\tif (strlen(vname) > 0)\n\t\tstrcpy((char *)&port_cfg.sym_name, vname);\n\tport_cfg.roles = BFA_LPORT_ROLE_FCP_IM;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tlist_for_each_entry(vp, &bfad->pbc_vport_list, list_entry) {\n\t\tif (port_cfg.pwwn ==\n\t\t\t\tvp->fcs_vport.lport.port_cfg.pwwn) {\n\t\t\tport_cfg.preboot_vp =\n\t\t\t\tvp->fcs_vport.lport.port_cfg.preboot_vp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\trc = bfad_vport_create(bfad, 0, &port_cfg, &fc_vport->dev);\n\tif (rc == BFA_STATUS_OK) {\n\t\tstruct bfad_vport_s *vport;\n\t\tstruct bfa_fcs_vport_s *fcs_vport;\n\t\tstruct Scsi_Host *vshost;\n\n\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0,\n\t\t\t\t\tport_cfg.pwwn);\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\tif (fcs_vport == NULL)\n\t\t\treturn VPCERR_BAD_WWN;\n\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n\t\tif (disable) {\n\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\t\tbfa_fcs_vport_stop(fcs_vport);\n\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t\t}\n\n\t\tvport = fcs_vport->vport_drv;\n\t\tvshost = vport->drv_port.im_port->shost;\n\t\tfc_host_node_name(vshost) = wwn_to_u64((u8 *)&port_cfg.nwwn);\n\t\tfc_host_port_name(vshost) = wwn_to_u64((u8 *)&port_cfg.pwwn);\n\t\tfc_host_supported_classes(vshost) = FC_COS_CLASS3;\n\n\t\tmemset(fc_host_supported_fc4s(vshost), 0,\n\t\t\tsizeof(fc_host_supported_fc4s(vshost)));\n\n\t\t/* For FCP type 0x08 */\n\t\tif (supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\t\tfc_host_supported_fc4s(vshost)[2] = 1;\n\n\t\t/* For fibre channel services type 0x20 */\n\t\tfc_host_supported_fc4s(vshost)[7] = 1;\n\n\t\tfc_host_supported_speeds(vshost) =\n\t\t\t\tbfad_im_supported_speeds(&bfad->bfa);\n\t\tfc_host_maxframe_size(vshost) =\n\t\t\t\tbfa_fcport_get_maxfrsize(&bfad->bfa);\n\n\t\tfc_vport->dd_data = vport;\n\t\tvport->drv_port.im_port->fc_vport = fc_vport;\n\t} else if (rc == BFA_STATUS_INVALID_WWN)\n\t\treturn VPCERR_BAD_WWN;\n\telse if (rc == BFA_STATUS_VPORT_EXISTS)\n\t\treturn VPCERR_BAD_WWN;\n\telse if (rc == BFA_STATUS_VPORT_MAX)\n\t\treturn VPCERR_NO_FABRIC_SUPP;\n\telse if (rc == BFA_STATUS_VPORT_WWN_BP)\n\t\treturn VPCERR_BAD_WWN;\n\telse\n\t\treturn FC_VPORT_FAILED;\n\n\treturn status;\n}\n\nint\nbfad_im_issue_fc_host_lip(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunsigned long flags;\n\tuint32_t status;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tstatus = bfa_port_disable(&bfad->bfa.modules.port,\n\t\t\t\t\tbfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tstatus = bfa_port_enable(&bfad->bfa.modules.port,\n\t\t\t\t\tbfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nbfad_im_vport_delete(struct fc_vport *fc_vport)\n{\n\tstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) vport->drv_port.im_port;\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\tstruct Scsi_Host *vshost;\n\twwn_t   pwwn;\n\tint rc;\n\tunsigned long flags;\n\tstruct completion fcomp;\n\n\tif (im_port->flags & BFAD_PORT_DELETE) {\n\t\tbfad_scsi_host_free(bfad, im_port);\n\t\tlist_del(&vport->list_entry);\n\t\tkfree(vport);\n\t\treturn 0;\n\t}\n\n\tvshost = vport->drv_port.im_port->shost;\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn VPCERR_BAD_WWN;\n\n\tvport->drv_port.flags |= BFAD_PORT_DELETE;\n\n\tvport->comp_del = &fcomp;\n\tinit_completion(vport->comp_del);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_fcs_vport_delete(&vport->fcs_vport);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (rc == BFA_STATUS_PBC) {\n\t\tvport->drv_port.flags &= ~BFAD_PORT_DELETE;\n\t\tvport->comp_del = NULL;\n\t\treturn -1;\n\t}\n\n\twait_for_completion(vport->comp_del);\n\n\tbfad_scsi_host_free(bfad, im_port);\n\tlist_del(&vport->list_entry);\n\tkfree(vport);\n\n\treturn 0;\n}\n\nstatic int\nbfad_im_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct bfad_vport_s *vport;\n\tstruct bfad_s *bfad;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\tstruct Scsi_Host *vshost;\n\twwn_t   pwwn;\n\tunsigned long flags;\n\n\tvport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tbfad = vport->drv_port.bfad;\n\tvshost = vport->drv_port.im_port->shost;\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn VPCERR_BAD_WWN;\n\n\tif (disable) {\n\t\tbfa_fcs_vport_stop(fcs_vport);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t} else {\n\t\tbfa_fcs_vport_start(fcs_vport);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n\t}\n\n\treturn 0;\n}\n\nvoid\nbfad_im_vport_set_symbolic_name(struct fc_vport *fc_vport)\n{\n\tstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *)vport->drv_port.im_port;\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct Scsi_Host *vshost = vport->drv_port.im_port->shost;\n\tchar *sym_name = fc_vport->symbolic_name;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\twwn_t\tpwwn;\n\tunsigned long flags;\n\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tif (strlen(sym_name) > 0)\n\t\tbfa_fcs_lport_set_symname(&fcs_vport->lport, sym_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\nstruct fc_function_template bfad_im_fc_function_template = {\n\n\t/* Target dynamic attributes */\n\t.get_starget_port_id = bfad_im_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\t.get_starget_node_name = bfad_im_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = bfad_im_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t/* Host dynamic attribute */\n\t.get_host_port_id = bfad_im_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t/* Host fixed attributes */\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t/* More host dynamic attributes */\n\t.show_host_port_type = 1,\n\t.get_host_port_type = bfad_im_get_host_port_type,\n\t.show_host_port_state = 1,\n\t.get_host_port_state = bfad_im_get_host_port_state,\n\t.show_host_active_fc4s = 1,\n\t.get_host_active_fc4s = bfad_im_get_host_active_fc4s,\n\t.show_host_speed = 1,\n\t.get_host_speed = bfad_im_get_host_speed,\n\t.show_host_fabric_name = 1,\n\t.get_host_fabric_name = bfad_im_get_host_fabric_name,\n\n\t.show_host_symbolic_name = 1,\n\n\t/* Statistics */\n\t.get_fc_host_stats = bfad_im_get_stats,\n\t.reset_fc_host_stats = bfad_im_reset_stats,\n\n\t/* Allocation length for host specific data */\n\t.dd_fcrport_size = sizeof(struct bfad_itnim_data_s *),\n\n\t/* Remote port fixed attributes */\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = bfad_im_set_rport_loss_tmo,\n\t.issue_fc_host_lip = bfad_im_issue_fc_host_lip,\n\t.vport_create = bfad_im_vport_create,\n\t.vport_delete = bfad_im_vport_delete,\n\t.vport_disable = bfad_im_vport_disable,\n\t.set_vport_symbolic_name = bfad_im_vport_set_symbolic_name,\n\t.bsg_request = bfad_im_bsg_request,\n\t.bsg_timeout = bfad_im_bsg_timeout,\n};\n\nstruct fc_function_template bfad_im_vport_fc_function_template = {\n\n\t/* Target dynamic attributes */\n\t.get_starget_port_id = bfad_im_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\t.get_starget_node_name = bfad_im_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = bfad_im_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t/* Host dynamic attribute */\n\t.get_host_port_id = bfad_im_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t/* Host fixed attributes */\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t/* More host dynamic attributes */\n\t.show_host_port_type = 1,\n\t.get_host_port_type = bfad_im_get_host_port_type,\n\t.show_host_port_state = 1,\n\t.get_host_port_state = bfad_im_get_host_port_state,\n\t.show_host_active_fc4s = 1,\n\t.get_host_active_fc4s = bfad_im_get_host_active_fc4s,\n\t.show_host_speed = 1,\n\t.get_host_speed = bfad_im_get_host_speed,\n\t.show_host_fabric_name = 1,\n\t.get_host_fabric_name = bfad_im_get_host_fabric_name,\n\n\t.show_host_symbolic_name = 1,\n\n\t/* Statistics */\n\t.get_fc_host_stats = bfad_im_get_stats,\n\t.reset_fc_host_stats = bfad_im_reset_stats,\n\n\t/* Allocation length for host specific data */\n\t.dd_fcrport_size = sizeof(struct bfad_itnim_data_s *),\n\n\t/* Remote port fixed attributes */\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = bfad_im_set_rport_loss_tmo,\n};\n\n/*\n *  Scsi_Host_attrs SCSI host attributes\n */\nstatic ssize_t\nbfad_im_serial_num_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar serial_num[BFA_ADAPTER_SERIAL_NUM_LEN];\n\n\tbfa_get_adapter_serial_num(&bfad->bfa, serial_num);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", serial_num);\n}\n\nstatic ssize_t\nbfad_im_model_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar model[BFA_ADAPTER_MODEL_NAME_LEN];\n\n\tbfa_get_adapter_model(&bfad->bfa, model);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", model);\n}\n\nstatic ssize_t\nbfad_im_model_desc_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar model[BFA_ADAPTER_MODEL_NAME_LEN];\n\tchar model_descr[BFA_ADAPTER_MODEL_DESCR_LEN];\n\tint nports = 0;\n\n\tbfa_get_adapter_model(&bfad->bfa, model);\n\tnports = bfa_get_nports(&bfad->bfa);\n\tif (!strcmp(model, \"QLogic-425\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe dual port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-825\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe dual port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-42B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe dual port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-82B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe dual port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-1010\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps single port CNA\");\n\telse if (!strcmp(model, \"QLogic-1020\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps dual port CNA\");\n\telse if (!strcmp(model, \"QLogic-1007\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps CNA for IBM Blade Center\");\n\telse if (!strcmp(model, \"QLogic-415\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe single port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-815\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe single port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-41B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe single port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-81B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe single port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-804\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps FC HBA for HP Bladesystem C-class\");\n\telse if (!strcmp(model, \"QLogic-1741\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps CNA for Dell M-Series Blade Servers\");\n\telse if (strstr(model, \"QLogic-1860\")) {\n\t\tif (nports == 1 && bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 10Gbps single port CNA\");\n\t\telse if (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe single port FC HBA\");\n\t\telse if (nports == 2 && bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 10Gbps dual port CNA\");\n\t\telse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe dual port FC HBA\");\n\t} else if (!strcmp(model, \"QLogic-1867\")) {\n\t\tif (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe single port FC HBA for IBM\");\n\t\telse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe dual port FC HBA for IBM\");\n\t} else\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"Invalid Model\");\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", model_descr);\n}\n\nstatic ssize_t\nbfad_im_node_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\tu64        nwwn;\n\n\tnwwn = bfa_fcs_lport_get_nwwn(port->fcs_port);\n\treturn snprintf(buf, PAGE_SIZE, \"0x%llx\\n\", cpu_to_be64(nwwn));\n}\n\nstatic ssize_t\nbfad_im_symbolic_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_lport_attr_s port_attr;\n\tchar symname[BFA_SYMNAME_MAXLEN];\n\n\tbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\n\tstrlcpy(symname, port_attr.port_cfg.sym_name.symname,\n\t\t\tBFA_SYMNAME_MAXLEN);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", symname);\n}\n\nstatic ssize_t\nbfad_im_hw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar hw_ver[BFA_VERSION_LEN];\n\n\tbfa_get_pci_chip_rev(&bfad->bfa, hw_ver);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", hw_ver);\n}\n\nstatic ssize_t\nbfad_im_drv_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", BFAD_DRIVER_VERSION);\n}\n\nstatic ssize_t\nbfad_im_optionrom_version_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar optrom_ver[BFA_VERSION_LEN];\n\n\tbfa_get_adapter_optrom_ver(&bfad->bfa, optrom_ver);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", optrom_ver);\n}\n\nstatic ssize_t\nbfad_im_fw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar fw_ver[BFA_VERSION_LEN];\n\n\tbfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", fw_ver);\n}\n\nstatic ssize_t\nbfad_im_num_of_ports_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tbfa_get_nports(&bfad->bfa));\n}\n\nstatic ssize_t\nbfad_im_drv_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", BFAD_DRIVER_NAME);\n}\n\nstatic ssize_t\nbfad_im_num_of_discovered_ports_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tint        nrports = 2048;\n\tstruct bfa_rport_qualifier_s *rports = NULL;\n\tunsigned long   flags;\n\n\trports = kcalloc(nrports, sizeof(struct bfa_rport_qualifier_s),\n\t\t\t GFP_ATOMIC);\n\tif (rports == NULL)\n\t\treturn snprintf(buf, PAGE_SIZE, \"Failed\\n\");\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tbfa_fcs_lport_get_rport_quals(port->fcs_port, rports, &nrports);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tkfree(rports);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", nrports);\n}\n\nstatic          DEVICE_ATTR(serial_number, S_IRUGO,\n\t\t\t\tbfad_im_serial_num_show, NULL);\nstatic          DEVICE_ATTR(model, S_IRUGO, bfad_im_model_show, NULL);\nstatic          DEVICE_ATTR(model_description, S_IRUGO,\n\t\t\t\tbfad_im_model_desc_show, NULL);\nstatic          DEVICE_ATTR(node_name, S_IRUGO, bfad_im_node_name_show, NULL);\nstatic          DEVICE_ATTR(symbolic_name, S_IRUGO,\n\t\t\t\tbfad_im_symbolic_name_show, NULL);\nstatic          DEVICE_ATTR(hardware_version, S_IRUGO,\n\t\t\t\tbfad_im_hw_version_show, NULL);\nstatic          DEVICE_ATTR(driver_version, S_IRUGO,\n\t\t\t\tbfad_im_drv_version_show, NULL);\nstatic          DEVICE_ATTR(option_rom_version, S_IRUGO,\n\t\t\t\tbfad_im_optionrom_version_show, NULL);\nstatic          DEVICE_ATTR(firmware_version, S_IRUGO,\n\t\t\t\tbfad_im_fw_version_show, NULL);\nstatic          DEVICE_ATTR(number_of_ports, S_IRUGO,\n\t\t\t\tbfad_im_num_of_ports_show, NULL);\nstatic          DEVICE_ATTR(driver_name, S_IRUGO, bfad_im_drv_name_show, NULL);\nstatic          DEVICE_ATTR(number_of_discovered_ports, S_IRUGO,\n\t\t\t\tbfad_im_num_of_discovered_ports_show, NULL);\n\nstruct device_attribute *bfad_im_host_attrs[] = {\n\t&dev_attr_serial_number,\n\t&dev_attr_model,\n\t&dev_attr_model_description,\n\t&dev_attr_node_name,\n\t&dev_attr_symbolic_name,\n\t&dev_attr_hardware_version,\n\t&dev_attr_driver_version,\n\t&dev_attr_option_rom_version,\n\t&dev_attr_firmware_version,\n\t&dev_attr_number_of_ports,\n\t&dev_attr_driver_name,\n\t&dev_attr_number_of_discovered_ports,\n\tNULL,\n};\n\nstruct device_attribute *bfad_im_vport_attrs[] = {\n\t&dev_attr_serial_number,\n\t&dev_attr_model,\n\t&dev_attr_model_description,\n\t&dev_attr_node_name,\n\t&dev_attr_symbolic_name,\n\t&dev_attr_hardware_version,\n\t&dev_attr_driver_version,\n\t&dev_attr_option_rom_version,\n\t&dev_attr_firmware_version,\n\t&dev_attr_number_of_ports,\n\t&dev_attr_driver_name,\n\t&dev_attr_number_of_discovered_ports,\n\tNULL,\n};\n\n\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2005-2014 Brocade Communications Systems, Inc.\n * Copyright (c) 2014- QLogic Corporation.\n * All rights reserved\n * www.qlogic.com\n *\n * Linux driver for QLogic BR-series Fibre Channel Host Bus Adapter.\n */\n\n/*\n *  bfa_attr.c Linux driver configuration interface module.\n */\n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n\n/*\n * FC transport template entry, get SCSI target port ID.\n */\nstatic void\nbfad_im_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu32        fc_id = -1;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tfc_id = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\n\n\tfc_starget_port_id(starget) = fc_id;\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n/*\n * FC transport template entry, get SCSI target nwwn.\n */\nstatic void\nbfad_im_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu64             node_name = 0;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tnode_name = bfa_fcs_itnim_get_nwwn(&itnim->fcs_itnim);\n\n\tfc_starget_node_name(starget) = cpu_to_be64(node_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n/*\n * FC transport template entry, get SCSI target pwwn.\n */\nstatic void\nbfad_im_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu64             port_name = 0;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tport_name = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\n\n\tfc_starget_port_name(starget) = cpu_to_be64(port_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n/*\n * FC transport template entry, get SCSI host port ID.\n */\nstatic void\nbfad_im_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\n\tfc_host_port_id(shost) =\n\t\t\tbfa_hton3b(bfa_fcs_lport_get_fcid(port->fcs_port));\n}\n\n/*\n * FC transport template entry, get SCSI host port type.\n */\nstatic void\nbfad_im_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_lport_attr_s port_attr;\n\n\tbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\n\n\tswitch (port_attr.port_type) {\n\tcase BFA_PORT_TYPE_NPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_NLPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_P2P:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_PTP;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_LPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/*\n * FC transport template entry, get SCSI host port state.\n */\nstatic void\nbfad_im_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_port_attr_s attr;\n\n\tbfa_fcport_get_attr(&bfad->bfa, &attr);\n\n\tswitch (attr.port_state) {\n\tcase BFA_PORT_ST_LINKDOWN:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\tbreak;\n\tcase BFA_PORT_ST_LINKUP:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\t\tbreak;\n\tcase BFA_PORT_ST_DISABLED:\n\tcase BFA_PORT_ST_STOPPED:\n\tcase BFA_PORT_ST_IOCDOWN:\n\tcase BFA_PORT_ST_IOCDIS:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\t\tbreak;\n\tcase BFA_PORT_ST_UNINIT:\n\tcase BFA_PORT_ST_ENABLING_QWAIT:\n\tcase BFA_PORT_ST_ENABLING:\n\tcase BFA_PORT_ST_DISABLING_QWAIT:\n\tcase BFA_PORT_ST_DISABLING:\n\tdefault:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/*\n * FC transport template entry, get SCSI host active fc4s.\n */\nstatic void\nbfad_im_get_host_active_fc4s(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\n\tmemset(fc_host_active_fc4s(shost), 0,\n\t       sizeof(fc_host_active_fc4s(shost)));\n\n\tif (port->supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\tfc_host_active_fc4s(shost)[2] = 1;\n\n\tfc_host_active_fc4s(shost)[7] = 1;\n}\n\n/*\n * FC transport template entry, get SCSI host link speed.\n */\nstatic void\nbfad_im_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_port_attr_s attr;\n\n\tbfa_fcport_get_attr(&bfad->bfa, &attr);\n\tswitch (attr.speed) {\n\tcase BFA_PORT_SPEED_10GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_16GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_8GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_4GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_2GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_1GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/*\n * FC transport template entry, get SCSI host port type.\n */\nstatic void\nbfad_im_get_host_fabric_name(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\twwn_t           fabric_nwwn = 0;\n\n\tfabric_nwwn = bfa_fcs_lport_get_fabric_name(port->fcs_port);\n\n\tfc_host_fabric_name(shost) = cpu_to_be64(fabric_nwwn);\n\n}\n\n/*\n * FC transport template entry, get BFAD statistics.\n */\nstatic struct fc_host_statistics *\nbfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK) {\n\t\tkfree(fcstats);\n\t\treturn NULL;\n\t}\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}\n\n/*\n * FC transport template entry, reset BFAD statistics.\n */\nstatic void\nbfad_im_reset_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunsigned long   flags;\n\tbfa_status_t    rc;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_port_clear_stats(BFA_FCPORT(&bfad->bfa), bfad_hcb_comp,\n\t\t\t\t\t&fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (rc != BFA_STATUS_OK)\n\t\treturn;\n\n\twait_for_completion(&fcomp.comp);\n\n\treturn;\n}\n\n/*\n * FC transport template entry, set rport loss timeout.\n * Update dev_loss_tmo based on the value pushed down by the stack\n * In case it is lesser than path_tov of driver, set it to path_tov + 1\n * to ensure that the driver times out before the application\n */\nstatic void\nbfad_im_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)\n{\n\tstruct bfad_itnim_data_s *itnim_data = rport->dd_data;\n\tstruct bfad_itnim_s   *itnim = itnim_data->itnim;\n\tstruct bfad_s         *bfad = itnim->im->bfad;\n\tuint16_t path_tov = bfa_fcpim_path_tov_get(&bfad->bfa);\n\n\trport->dev_loss_tmo = timeout;\n\tif (timeout < path_tov)\n\t\trport->dev_loss_tmo = path_tov + 1;\n}\n\nstatic int\nbfad_im_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tchar *vname = fc_vport->symbolic_name;\n\tstruct Scsi_Host *shost = fc_vport->shost;\n\tstruct bfad_im_port_s *im_port =\n\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_lport_cfg_s port_cfg;\n\tstruct bfad_vport_s *vp;\n\tint status = 0, rc;\n\tunsigned long flags;\n\n\tmemset(&port_cfg, 0, sizeof(port_cfg));\n\tu64_to_wwn(fc_vport->node_name, (u8 *)&port_cfg.nwwn);\n\tu64_to_wwn(fc_vport->port_name, (u8 *)&port_cfg.pwwn);\n\tif (strlen(vname) > 0)\n\t\tstrcpy((char *)&port_cfg.sym_name, vname);\n\tport_cfg.roles = BFA_LPORT_ROLE_FCP_IM;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tlist_for_each_entry(vp, &bfad->pbc_vport_list, list_entry) {\n\t\tif (port_cfg.pwwn ==\n\t\t\t\tvp->fcs_vport.lport.port_cfg.pwwn) {\n\t\t\tport_cfg.preboot_vp =\n\t\t\t\tvp->fcs_vport.lport.port_cfg.preboot_vp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\trc = bfad_vport_create(bfad, 0, &port_cfg, &fc_vport->dev);\n\tif (rc == BFA_STATUS_OK) {\n\t\tstruct bfad_vport_s *vport;\n\t\tstruct bfa_fcs_vport_s *fcs_vport;\n\t\tstruct Scsi_Host *vshost;\n\n\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0,\n\t\t\t\t\tport_cfg.pwwn);\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\tif (fcs_vport == NULL)\n\t\t\treturn VPCERR_BAD_WWN;\n\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n\t\tif (disable) {\n\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\t\tbfa_fcs_vport_stop(fcs_vport);\n\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t\t}\n\n\t\tvport = fcs_vport->vport_drv;\n\t\tvshost = vport->drv_port.im_port->shost;\n\t\tfc_host_node_name(vshost) = wwn_to_u64((u8 *)&port_cfg.nwwn);\n\t\tfc_host_port_name(vshost) = wwn_to_u64((u8 *)&port_cfg.pwwn);\n\t\tfc_host_supported_classes(vshost) = FC_COS_CLASS3;\n\n\t\tmemset(fc_host_supported_fc4s(vshost), 0,\n\t\t\tsizeof(fc_host_supported_fc4s(vshost)));\n\n\t\t/* For FCP type 0x08 */\n\t\tif (supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\t\tfc_host_supported_fc4s(vshost)[2] = 1;\n\n\t\t/* For fibre channel services type 0x20 */\n\t\tfc_host_supported_fc4s(vshost)[7] = 1;\n\n\t\tfc_host_supported_speeds(vshost) =\n\t\t\t\tbfad_im_supported_speeds(&bfad->bfa);\n\t\tfc_host_maxframe_size(vshost) =\n\t\t\t\tbfa_fcport_get_maxfrsize(&bfad->bfa);\n\n\t\tfc_vport->dd_data = vport;\n\t\tvport->drv_port.im_port->fc_vport = fc_vport;\n\t} else if (rc == BFA_STATUS_INVALID_WWN)\n\t\treturn VPCERR_BAD_WWN;\n\telse if (rc == BFA_STATUS_VPORT_EXISTS)\n\t\treturn VPCERR_BAD_WWN;\n\telse if (rc == BFA_STATUS_VPORT_MAX)\n\t\treturn VPCERR_NO_FABRIC_SUPP;\n\telse if (rc == BFA_STATUS_VPORT_WWN_BP)\n\t\treturn VPCERR_BAD_WWN;\n\telse\n\t\treturn FC_VPORT_FAILED;\n\n\treturn status;\n}\n\nint\nbfad_im_issue_fc_host_lip(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunsigned long flags;\n\tuint32_t status;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tstatus = bfa_port_disable(&bfad->bfa.modules.port,\n\t\t\t\t\tbfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tstatus = bfa_port_enable(&bfad->bfa.modules.port,\n\t\t\t\t\tbfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nbfad_im_vport_delete(struct fc_vport *fc_vport)\n{\n\tstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) vport->drv_port.im_port;\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\tstruct Scsi_Host *vshost;\n\twwn_t   pwwn;\n\tint rc;\n\tunsigned long flags;\n\tstruct completion fcomp;\n\n\tif (im_port->flags & BFAD_PORT_DELETE) {\n\t\tbfad_scsi_host_free(bfad, im_port);\n\t\tlist_del(&vport->list_entry);\n\t\tkfree(vport);\n\t\treturn 0;\n\t}\n\n\tvshost = vport->drv_port.im_port->shost;\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn VPCERR_BAD_WWN;\n\n\tvport->drv_port.flags |= BFAD_PORT_DELETE;\n\n\tvport->comp_del = &fcomp;\n\tinit_completion(vport->comp_del);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_fcs_vport_delete(&vport->fcs_vport);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (rc == BFA_STATUS_PBC) {\n\t\tvport->drv_port.flags &= ~BFAD_PORT_DELETE;\n\t\tvport->comp_del = NULL;\n\t\treturn -1;\n\t}\n\n\twait_for_completion(vport->comp_del);\n\n\tbfad_scsi_host_free(bfad, im_port);\n\tlist_del(&vport->list_entry);\n\tkfree(vport);\n\n\treturn 0;\n}\n\nstatic int\nbfad_im_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct bfad_vport_s *vport;\n\tstruct bfad_s *bfad;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\tstruct Scsi_Host *vshost;\n\twwn_t   pwwn;\n\tunsigned long flags;\n\n\tvport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tbfad = vport->drv_port.bfad;\n\tvshost = vport->drv_port.im_port->shost;\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn VPCERR_BAD_WWN;\n\n\tif (disable) {\n\t\tbfa_fcs_vport_stop(fcs_vport);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t} else {\n\t\tbfa_fcs_vport_start(fcs_vport);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n\t}\n\n\treturn 0;\n}\n\nvoid\nbfad_im_vport_set_symbolic_name(struct fc_vport *fc_vport)\n{\n\tstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *)vport->drv_port.im_port;\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct Scsi_Host *vshost = vport->drv_port.im_port->shost;\n\tchar *sym_name = fc_vport->symbolic_name;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\twwn_t\tpwwn;\n\tunsigned long flags;\n\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tif (strlen(sym_name) > 0)\n\t\tbfa_fcs_lport_set_symname(&fcs_vport->lport, sym_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\nstruct fc_function_template bfad_im_fc_function_template = {\n\n\t/* Target dynamic attributes */\n\t.get_starget_port_id = bfad_im_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\t.get_starget_node_name = bfad_im_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = bfad_im_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t/* Host dynamic attribute */\n\t.get_host_port_id = bfad_im_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t/* Host fixed attributes */\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t/* More host dynamic attributes */\n\t.show_host_port_type = 1,\n\t.get_host_port_type = bfad_im_get_host_port_type,\n\t.show_host_port_state = 1,\n\t.get_host_port_state = bfad_im_get_host_port_state,\n\t.show_host_active_fc4s = 1,\n\t.get_host_active_fc4s = bfad_im_get_host_active_fc4s,\n\t.show_host_speed = 1,\n\t.get_host_speed = bfad_im_get_host_speed,\n\t.show_host_fabric_name = 1,\n\t.get_host_fabric_name = bfad_im_get_host_fabric_name,\n\n\t.show_host_symbolic_name = 1,\n\n\t/* Statistics */\n\t.get_fc_host_stats = bfad_im_get_stats,\n\t.reset_fc_host_stats = bfad_im_reset_stats,\n\n\t/* Allocation length for host specific data */\n\t.dd_fcrport_size = sizeof(struct bfad_itnim_data_s *),\n\n\t/* Remote port fixed attributes */\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = bfad_im_set_rport_loss_tmo,\n\t.issue_fc_host_lip = bfad_im_issue_fc_host_lip,\n\t.vport_create = bfad_im_vport_create,\n\t.vport_delete = bfad_im_vport_delete,\n\t.vport_disable = bfad_im_vport_disable,\n\t.set_vport_symbolic_name = bfad_im_vport_set_symbolic_name,\n\t.bsg_request = bfad_im_bsg_request,\n\t.bsg_timeout = bfad_im_bsg_timeout,\n};\n\nstruct fc_function_template bfad_im_vport_fc_function_template = {\n\n\t/* Target dynamic attributes */\n\t.get_starget_port_id = bfad_im_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\t.get_starget_node_name = bfad_im_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = bfad_im_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t/* Host dynamic attribute */\n\t.get_host_port_id = bfad_im_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t/* Host fixed attributes */\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t/* More host dynamic attributes */\n\t.show_host_port_type = 1,\n\t.get_host_port_type = bfad_im_get_host_port_type,\n\t.show_host_port_state = 1,\n\t.get_host_port_state = bfad_im_get_host_port_state,\n\t.show_host_active_fc4s = 1,\n\t.get_host_active_fc4s = bfad_im_get_host_active_fc4s,\n\t.show_host_speed = 1,\n\t.get_host_speed = bfad_im_get_host_speed,\n\t.show_host_fabric_name = 1,\n\t.get_host_fabric_name = bfad_im_get_host_fabric_name,\n\n\t.show_host_symbolic_name = 1,\n\n\t/* Statistics */\n\t.get_fc_host_stats = bfad_im_get_stats,\n\t.reset_fc_host_stats = bfad_im_reset_stats,\n\n\t/* Allocation length for host specific data */\n\t.dd_fcrport_size = sizeof(struct bfad_itnim_data_s *),\n\n\t/* Remote port fixed attributes */\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = bfad_im_set_rport_loss_tmo,\n};\n\n/*\n *  Scsi_Host_attrs SCSI host attributes\n */\nstatic ssize_t\nbfad_im_serial_num_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar serial_num[BFA_ADAPTER_SERIAL_NUM_LEN];\n\n\tbfa_get_adapter_serial_num(&bfad->bfa, serial_num);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", serial_num);\n}\n\nstatic ssize_t\nbfad_im_model_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar model[BFA_ADAPTER_MODEL_NAME_LEN];\n\n\tbfa_get_adapter_model(&bfad->bfa, model);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", model);\n}\n\nstatic ssize_t\nbfad_im_model_desc_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar model[BFA_ADAPTER_MODEL_NAME_LEN];\n\tchar model_descr[BFA_ADAPTER_MODEL_DESCR_LEN];\n\tint nports = 0;\n\n\tbfa_get_adapter_model(&bfad->bfa, model);\n\tnports = bfa_get_nports(&bfad->bfa);\n\tif (!strcmp(model, \"QLogic-425\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe dual port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-825\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe dual port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-42B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe dual port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-82B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe dual port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-1010\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps single port CNA\");\n\telse if (!strcmp(model, \"QLogic-1020\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps dual port CNA\");\n\telse if (!strcmp(model, \"QLogic-1007\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps CNA for IBM Blade Center\");\n\telse if (!strcmp(model, \"QLogic-415\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe single port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-815\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe single port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-41B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe single port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-81B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe single port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-804\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps FC HBA for HP Bladesystem C-class\");\n\telse if (!strcmp(model, \"QLogic-1741\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps CNA for Dell M-Series Blade Servers\");\n\telse if (strstr(model, \"QLogic-1860\")) {\n\t\tif (nports == 1 && bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 10Gbps single port CNA\");\n\t\telse if (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe single port FC HBA\");\n\t\telse if (nports == 2 && bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 10Gbps dual port CNA\");\n\t\telse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe dual port FC HBA\");\n\t} else if (!strcmp(model, \"QLogic-1867\")) {\n\t\tif (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe single port FC HBA for IBM\");\n\t\telse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe dual port FC HBA for IBM\");\n\t} else\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"Invalid Model\");\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", model_descr);\n}\n\nstatic ssize_t\nbfad_im_node_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\tu64        nwwn;\n\n\tnwwn = bfa_fcs_lport_get_nwwn(port->fcs_port);\n\treturn snprintf(buf, PAGE_SIZE, \"0x%llx\\n\", cpu_to_be64(nwwn));\n}\n\nstatic ssize_t\nbfad_im_symbolic_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_lport_attr_s port_attr;\n\tchar symname[BFA_SYMNAME_MAXLEN];\n\n\tbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\n\tstrlcpy(symname, port_attr.port_cfg.sym_name.symname,\n\t\t\tBFA_SYMNAME_MAXLEN);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", symname);\n}\n\nstatic ssize_t\nbfad_im_hw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar hw_ver[BFA_VERSION_LEN];\n\n\tbfa_get_pci_chip_rev(&bfad->bfa, hw_ver);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", hw_ver);\n}\n\nstatic ssize_t\nbfad_im_drv_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", BFAD_DRIVER_VERSION);\n}\n\nstatic ssize_t\nbfad_im_optionrom_version_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar optrom_ver[BFA_VERSION_LEN];\n\n\tbfa_get_adapter_optrom_ver(&bfad->bfa, optrom_ver);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", optrom_ver);\n}\n\nstatic ssize_t\nbfad_im_fw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar fw_ver[BFA_VERSION_LEN];\n\n\tbfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", fw_ver);\n}\n\nstatic ssize_t\nbfad_im_num_of_ports_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tbfa_get_nports(&bfad->bfa));\n}\n\nstatic ssize_t\nbfad_im_drv_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", BFAD_DRIVER_NAME);\n}\n\nstatic ssize_t\nbfad_im_num_of_discovered_ports_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tint        nrports = 2048;\n\tstruct bfa_rport_qualifier_s *rports = NULL;\n\tunsigned long   flags;\n\n\trports = kcalloc(nrports, sizeof(struct bfa_rport_qualifier_s),\n\t\t\t GFP_ATOMIC);\n\tif (rports == NULL)\n\t\treturn snprintf(buf, PAGE_SIZE, \"Failed\\n\");\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tbfa_fcs_lport_get_rport_quals(port->fcs_port, rports, &nrports);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tkfree(rports);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", nrports);\n}\n\nstatic          DEVICE_ATTR(serial_number, S_IRUGO,\n\t\t\t\tbfad_im_serial_num_show, NULL);\nstatic          DEVICE_ATTR(model, S_IRUGO, bfad_im_model_show, NULL);\nstatic          DEVICE_ATTR(model_description, S_IRUGO,\n\t\t\t\tbfad_im_model_desc_show, NULL);\nstatic          DEVICE_ATTR(node_name, S_IRUGO, bfad_im_node_name_show, NULL);\nstatic          DEVICE_ATTR(symbolic_name, S_IRUGO,\n\t\t\t\tbfad_im_symbolic_name_show, NULL);\nstatic          DEVICE_ATTR(hardware_version, S_IRUGO,\n\t\t\t\tbfad_im_hw_version_show, NULL);\nstatic          DEVICE_ATTR(driver_version, S_IRUGO,\n\t\t\t\tbfad_im_drv_version_show, NULL);\nstatic          DEVICE_ATTR(option_rom_version, S_IRUGO,\n\t\t\t\tbfad_im_optionrom_version_show, NULL);\nstatic          DEVICE_ATTR(firmware_version, S_IRUGO,\n\t\t\t\tbfad_im_fw_version_show, NULL);\nstatic          DEVICE_ATTR(number_of_ports, S_IRUGO,\n\t\t\t\tbfad_im_num_of_ports_show, NULL);\nstatic          DEVICE_ATTR(driver_name, S_IRUGO, bfad_im_drv_name_show, NULL);\nstatic          DEVICE_ATTR(number_of_discovered_ports, S_IRUGO,\n\t\t\t\tbfad_im_num_of_discovered_ports_show, NULL);\n\nstruct device_attribute *bfad_im_host_attrs[] = {\n\t&dev_attr_serial_number,\n\t&dev_attr_model,\n\t&dev_attr_model_description,\n\t&dev_attr_node_name,\n\t&dev_attr_symbolic_name,\n\t&dev_attr_hardware_version,\n\t&dev_attr_driver_version,\n\t&dev_attr_option_rom_version,\n\t&dev_attr_firmware_version,\n\t&dev_attr_number_of_ports,\n\t&dev_attr_driver_name,\n\t&dev_attr_number_of_discovered_ports,\n\tNULL,\n};\n\nstruct device_attribute *bfad_im_vport_attrs[] = {\n\t&dev_attr_serial_number,\n\t&dev_attr_model,\n\t&dev_attr_model_description,\n\t&dev_attr_node_name,\n\t&dev_attr_symbolic_name,\n\t&dev_attr_hardware_version,\n\t&dev_attr_driver_version,\n\t&dev_attr_option_rom_version,\n\t&dev_attr_firmware_version,\n\t&dev_attr_number_of_ports,\n\t&dev_attr_driver_name,\n\t&dev_attr_number_of_discovered_ports,\n\tNULL,\n};\n\n\n"], "filenames": ["drivers/scsi/bfa/bfad_attr.c"], "buggy_code_start_loc": [278], "buggy_code_end_loc": [279], "fixing_code_start_loc": [278], "fixing_code_end_loc": [282], "type": "CWE-401", "message": "A memory leak in the bfad_im_get_stats() function in drivers/scsi/bfa/bfad_attr.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering bfa_port_get_stats() failures, aka CID-0e62395da2bd.", "other": {"cve": {"id": "CVE-2019-19066", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.733", "lastModified": "2021-06-14T18:15:18.313", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A memory leak in the bfad_im_get_stats() function in drivers/scsi/bfa/bfad_attr.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering bfa_port_get_stats() failures, aka CID-0e62395da2bd."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n bfad_im_get_stats() en el archivo drivers/scsi/bfa/bfad_attr.c en el kernel de Linux versiones hasta la versi\u00f3n  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n de bfa_port_get_stats(), tambi\u00e9n se conoce como CID-0e62395da2bd."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0e62395da2bd5166d7c9e14cbc7503b256a34cb0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4301-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4302-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0e62395da2bd5166d7c9e14cbc7503b256a34cb0"}}